;;; -*- Mode: tdl; Coding: utf-8; -*-

; <type val="w_period_plr">
; <description>Period affixed to end of word    
; <ex>cat.                       
; <nex>
; <todo>
; </type>
w_period_plr :=
%suffix (!. !..)
punctuation_period_rule &
 [ RNAME lpp ].

; <type val="w_qmark_plr">
; <description>Question mark affixed to word    
; <ex>cat?                       
; <nex>
; <todo>
; </type>
w_qmark_plr :=
%suffix (!p !p\?)
punctuation_qmark_rule &
 [ RNAME lpq ].

; <type val="w_qqmark_plr">
; <description>Double question mark affixed     
; <ex>cat??                      
; <nex>
; <todo>
; </type>
w_qqmark_plr :=
%suffix (!p !p\?)
w_qqmark_rule &
 [ RNAME lpqq ].

; <type val="w_qmark-bang_plr">
; <description>Qmark and exclam point affixed   
; <ex>cat?!                      
; <nex>
; <todo>
; </type>
w_qmark-bang_plr :=
%suffix (!p !p\!)
w_qmark-bang_rule &
 [ RNAME lpcq ].

; <type val="w_comma_plr">
; <description>Comma affixed                    
; <ex>cat,                       
; <nex>
; <todo>
; </type>
w_comma_plr :=
%suffix (!q !q,)
punctuation_comma_rule &
 [ RNAME lpcm ].

; <type val="w_bang_plr">
; <description>Exclamation point affixed        
; <ex>cat!                       
; <nex>
; <todo>
; </type>
w_bang_plr :=
%suffix (!p !p\!)
punctuation_bang_rule &
 [ RNAME lpx ].

; <type val="w_semicol_plr">
; <description>Semicolon affixed                
; <ex>cat;                       
; <nex>
; <todo>
; </type>
w_semicol_plr :=
%suffix (!k !k;)
w_semicol_rule &
 [ RNAME lpsc ].

; For robustness, where typo leaves two semicolons
; <type val="w_double_semicol_plr">
; <description>Robust double semicolon
; <ex>cat;;                       
; <nex>
; <todo>
; </type>
w_double_semicol_plr :=
%suffix (!. !.;;)
w_double_semicol_rule &
 [ RNAME lpds ].

; <type val="w_rparen_plr">
; <description>Right parenthesis affixed        
; <ex>cat)                       
; <nex>
; <todo>
; </type>
w_rparen_plr :=
%suffix (!p !p\))
w_rparen_rule &
 [ RNAME lprp ].

; For robustness, where mis-editing left comma preceding right paren
; <type val="w_comma-rp_plr">
; <description>Comma wrongly before right paren 
; <ex>cat,)                      
; <nex>
; <todo>
; </type>
w_comma-rp_plr :=
%suffix (!p !p,\))
w_comma-rp_rule &
 [ RNAME lpcp ].

; <type val="w_lparen_plr">
; <description>Left parenthesis prefixed        
; <ex>(cat                       
; <nex>
; <todo>
; </type>
w_lparen_plr :=
%prefix (!f \(!f)
w_lparen_rule &
 [ RNAME lplp ].

; <type val="w_rbrack_plr">
; <description>Right square bracket affixed     
; <ex>cat]                       
; <nex>
; <todo>
; </type>
w_rbrack_plr :=
%suffix (!p !p]) (!p !p}) (!p !p|)
w_rbrack_rule &
 [ RNAME lprb ].

; <type val="w_lbrack_plr">
; <description>Left square bracket prefixed     
; <ex>[cat                       
; <nex>
; <todo>
; </type>
w_lbrack_plr :=
%prefix (!f [!f) (!f {!f) (!f |!f)
w_lbrack_rule &
 [ RNAME lplb ].

;;
;; _fix_me_
;; how many variants of quote marks to include depends on what decisions we
;; make in pre-processing.  as of September 2008, we have opted for a total of
;; six, viz. UniCode directional quotes (|“|, |”|, |‘|, and |’|), as well as
;; straight ASCII quotes (|"| and |'|).  when an input text makes use of good
;; directional quotes we preserve those (to not introduce ambiguity).  also, by
;; default we disambiguate quotes in pre-processing, based on proximity to 
;; token boundaries, i.e. in processing inputs following standard orthography
;; we only see proper opening and closing quotes (of which the latter can also
;; be apostrophes or units of measure).  however, there also is a configuration
;; for `messed up' inputs, e.g. ones that were pre-tokenized, so we no longer
;; stand a chance of disambiguating quotes.  in this mode, straight quotes are
;; ambiguous between opening or closing ones.  finally, if only for robustness
;; (or use without the full pre-processors), allow some variants that we do not
;; expect to see in the ideal world: |``|, |''|, and |`|.
;;
; <type val="w_dqright_plr">
; <description>Double quote affixed to end      
; <ex>cat"                       
; <nex>
; <todo>
; </type>
w_dqright_plr :=
%suffix (!q !q”) (!q !q") (!q !q'')
punctuation_dqright_rule &
 [ RNAME lpdr ].

; <type val="w_dqleft_plr">
; <description>Double quote prefixed            
; <ex>"cat                       
; <nex>
; <todo>
; </type>
w_dqleft_plr :=
%prefix (!f ”!f) (!f “!f) (!f "!f) (!f ``!f)
punctuation_dqleft_rule &
 [ RNAME lpdl ].

; <type val="w_sqright_plr">
; <description>Single quote affixed to end      
; <ex>cat'                       
; <nex>
; <todo>
; </type>
w_sqright_plr :=
%suffix (!q !q’) (!q !q')
punctuation_sqright_rule &
 [ RNAME lpsr ].

;; DPF 20-feb-10 - Let's try doing without the straight quote as left
;; punctuation, since it creates spurious ambiguity for |They'd arrived.|
;; DPF 06-mar-10 - But now we need it for e.g. |The 'cat' arrived.|
;; _fix_me_
;; in fact, this ambiguity will disappear once we fully move to supporting the
;; UniCode apostrophe, i.e. convert the lexicon to include |don’t|, |’d|, and
;; |o’clock|.  at present, we hack around these by `normalizing' (in the wrong
;; direction) apostrophes to straight typewriter quotes.       (23-mar-10; oe)
;;
; <type val="w_sqleft_plr">
; <description>Single quote prefixed            
; <ex>'cat                       
; <nex>
; <todo>
; </type>
w_sqleft_plr :=
%prefix (!f ‘!f) (!f '!f) (!f `!f) (!f "‘!f) (!f "'!f) (!f "`!f)
punctuation_sqleft_rule &
 [ RNAME lpsl ].

; <type val="w_hyphen_plr">
; <description>Hyphen affixed to end            
; <ex>cat-                       
; <nex>
; <todo>
; </type>
w_hyphen_plr :=
%suffix (!p !p-)
w_hyphen_rule &
 [ RNAME lphr ].

;; DPF 2012-08-29 - Recent REPP changes now attach three dots to preceding
;; token without a space, when the dots are between two tokens, 
;; so add variant of hyphen suffix rule to accommodate.
;;
; <type val="w_threedot_plr">
; <description>Three dots affixed to end            
; <ex>cat...                       
; <nex>
; <todo>
; </type>
w_threedot_plr :=
%suffix (!p !p...)
w_threedot_rule &
 [ RNAME lptd ].

; <type val="w_asterisk_plr">
; <description>Asterisk affixed to end            
; <ex>cat*                       
; <nex>
; <todo>
; </type>
w_asterisk_plr :=
%suffix (!p !p\*)
w_asterisk_rule &
 [ RNAME lpax ].

; <type val="w_asterisk-pre_plr">
; <description>Asterisk prefixed to word
; <ex>*cat                       
; <nex>
; <todo>
; </type>
w_asterisk-pre_plr :=
%prefix (!p \*!p)
w_asterisk_pre_rule &
 [ RNAME lpaxp ].

; Add punct_comma_informal_rule for e.g. comma-marked subjects and 
; hd-cmp_u_c heads but don't use for generation.
; <type val="w_comma-nf_plr">
; <description>Nonformal comma affixed          
; <ex>cat,                       
; <nex>
; <todo>
; </type>
w_comma-nf_plr :=
%suffix (!. !.,)
punctuation_comma_informal_rule &
 [ RNAME lpcr ].

;; DPF 2012-02-18 - Tried adding double quotes to enable foreign-word analysis
;; but this leads to a lot of ambiguity whenever double quotes appaer.  More
;; research is needed.
;; %prefix (!f ¦i!f) (!f ”!f) (!f “!f) (!f "!f) (!f ``!f)
;; %suffix (!q !qi¦) (!q !q”) (!q !q") (!q !q'')
; <type val="w_italleft_plr">
; <description>Italics mark |ยฆi| prefixed      
; <ex>ยฆicat                     
; <nex>
; <todo>
; </type>
w_italleft_plr :=
%prefix (!f ¦i!f)
punctuation_italleft_rule &
 [ RNAME lpil ].

; <type val="w_italright_plr">
; <description>Italics mark |iยฆ| affixed       
; <ex>catiยฆ                     
; <nex>
; <todo>
; </type>
w_italright_plr :=
%suffix (!q !qi¦)
punctuation_italright_rule &
 [ RNAME lpir ].

; <type val="w_drop-ileft_plr">
; <description>Ignored italics mark affixed     
; <ex>catiยฆ                     
; <nex>
; <todo>
; </type>
w_drop-ileft_plr :=
%prefix (!f ¦i!f)
punct_drop_italleft_rule &
 [ RNAME lpxdl ].

; <type val="w_drop-iright_plr">
; <description>Ignored italics mark prefixed    
; <ex>catiยฆ                     
; <nex>
; <todo>
; </type>
w_drop-iright_plr :=
%suffix (!q !qi¦)
punct_drop_italright_rule &
 [ RNAME lpxdr ].

;; DPF 2014-04-24
;; Spencer Rarrick proposed the clever idea of introducing an underspecified
;; punctuation rule that will effectively only get used in generation (given
;; the choice of unlikely character sequence for the suffix), and which 
;; enables packing in generation to pack the period and question-mark edges,
;; reducing the number of edges in the packed generator chart, and still 
;; producing the right end results since edges produced with this underspecified
;; variant will lack an adequately specific value for SF to match the input
;; MRS's requirement, and hence will be discarded in unpacking, in favor of
;; whichever of period or qmark matches the input MRS.
;; MONITOR: Let's keep an eye on this efficiency-motivated rule, to see that
;; it earns its keep and does not cause trouble.
;; DPF 2014-07-24 - Unfortunately, it is not clear how to block this rule's
;; output for MRS input where the SF value is underspecified, as with the
;; MRS produced by parsing a no-punct sentence like |Kim arose| so let's
;; comment it out for now.
;; 
#|
w_generic_clause_plr :=
%suffix (!p !pzzzz)
punctuation_clause_rule &
 [ RNAME lgcr ].
|#