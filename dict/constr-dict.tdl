;; Allow verb phrase fragments with an unfilled gap
;; |to rely on|
;;
; <type val="vp_sl-frg_c">
; <description>Fragment VP with slash, for dict defs and robust parsing
; <ex>To devour.             
; <nex>
; <todo>
; </type>
vp_sl-frg_c := frag_vp_slash_rule &
  [ RNAME frvs ].

;; Allow clauses with an unfilled gap
;; |this procedure will depend on:|
;;
#|
; <type val="s_sl-frg_c">
; <description>Fragment S with slash, for robust parsing
; <ex>This means and includes ...
; <nex>
; <todo>
; </type>
s_sl-frg_c := frag_s_slash_rule &
  [ RNAME frsg ].
|#

;; Allow bare-singular NPs contained in larger constituents
;; |to replace cat with dog|
;;
#|
; <type val="hdn_bnp-rbst_c">
; <description>Robust bare singular count NP    
; <ex>We saw cat running         
; <nex>
; <todo>
; </type>
hdn_bnp-rbst_c := bare_np_sg_phrase_robust &
  [ RNAME bnpr ].
|#

;; Allow comma-separated run-on of a sentence (or fragment) followed by a frag.
;; |to admire cats, of art or biology|
;;
; <type val="cl-cl_runon-frg_c">
; <description>Run-on sentence, comma-marked w/two clauses or fragments
; <ex>B arrived; C left.         
; <nex>
; <todo>
; </type>
cl-frg_runon_c := basic_run_on_coord_rule &
 [ SYNSEM [ MODIFD.LPERIPH +,
	    LOCAL.CONT.HOOK.INDEX.E #e ],
   LCONJ-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.E #e,
		      PUNCT.RPUNCT comma_punct ],
   RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD frag,
   RNAME snsf ].

;; Block imperative sentences, to avoid unwanted ambiguity with VP fragments
;;
hd_imp_c := never_unify_rule.