;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-1999
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  multiletypes.tdl
;;;
;;;  Multiply-inheriting lexical entry types (yield of lextypes hierarchy)
;;;
;;;  Created by Dan Flickinger, 15-June-1996

:begin :type.

le_nonque := lex_entry & nonque.

intr_noun_word_le := intr_noun_word & affixed_lex_entry.
intr_noun_word_mle1 := intr_noun_word & affixed_two_lex_entry.
intr_noun_word_3mle3 := intr_noun_word & affixed_three_lex_entry.
intr_noun_word_4mle4 := intr_noun_word & affixed_four_lex_entry.
massn_le := mass_noun_word & affixed_lex_entry.
massn_mle1 := mass_noun_word & affixed_two_lex_entry.
massn_ppcomp_word_le := mass_noun_ppcomp_word & affixed_lex_entry.
intrans_adj_le := reg_intrans_adj & affixed_lex_entry.
intrans_adj_mle := reg_intrans_adj & affixed_two_lex_entry.
attr_intrans_adj_le := attr_intrans_adj & affixed_lex_entry.
pred_intrans_adj_le := pred_intrans_adj & affixed_lex_entry.
trans_adj_le := reg_trans_adj & affixed_lex_entry.

poss_le := poss_pro_word & lex_entry.
pp_mle := pp_word & multi_lex_entry2.
det_le := det_word_transparent & le_nonque.
det_mle1 := det_word_modable & multi_lex_entry1 & nonque.
det_sg_le := det_word_sing_modable & le_nonque.
det_sg_nomod_le := det_word_sing_nonmodable & le_nonque.
det_pl_le := det_word_plur & le_nonque.
det_sm_le := det_word_sg_mass & le_nonque.
det_plm_mle := det_word_pl_mass & multi_lex_entry1.
next_last_det_le := next_last_det_word & le_nonque.
pdet_le := pdet_word & le_nonque.
pdet_sg_le := pdet_word_sing & le_nonque.
pdet_pl_le := pdet_word_plur & le_nonque.
pdet_pl_mass_le := pdet_word_pl_mass & le_nonque.
pdet_pl_mass_mle := pdet_word_pl_mass & multi_lex_entry1 & nonque.
pdet_pl_mle2 := pdet_word_plur & multi_lex_entry2 & nonque.
pdet_ms_le := pdet_word_mass & le_nonque.
mealtime_word_mle := mealtime_word & multi_lex_entry2.
bare_unspecified_card_le := card_only_word & lex_entry &
			    unspecified_num_without_complements.
bare_unspecified_card_mle1 := card_only_word & multi_lex_entry1 &
			      unspecified_num_without_complements.
bare_specified_card_le := card_only_word & lex_entry &
			  specified_num_without_complements.
complemented_unspecified_card_le := norm_card_word & lex_entry & 
				    unspecified_num_with_complements.
complemented_specified_card_le := norm_card_word & lex_entry &
				  specified_num_with_complements.
bare_unspecified_ord_le := ord_word & unspecified_num_without_complements.
bare_specified_ord_le := ord_word & specified_num_without_complements.

approx_bare_unspecified_card_le := card_only_word & lex_entry &
			           approx_unspecified_num_without_complements.

mv_cp_prop_raise_key_le := main_verb_sans_key & reg_lex_entry & affix_bearing &
  [ SYNSEM cp_prop_raise_key_verb & 
            [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].
mv_adv_le := main_verb_sans_key & reg_lex_entry & affix_bearing &
  [ SYNSEM adv_verb &
	   [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].
mv_sorb_pass_le := main_verb_sans_key & lex_entry & non_affix_bearing &
  [ SYNSEM sor_verb &
            [ LOCAL [ CAT [ HEAD [ VFORM psp_irreg,
				   PRD - ],
			    VAL [ SUBJ < [ OPT - ] >,
				  COMPS < [ OPT - ], ... > ] ],
		      CONT psoa & [ INDEX #event,
				    LISZT <! #key !> ],
		      KEYS.KEY #key &
			  [ EVENT #event ] ] ] ].

mv_unerg_mle2 := main_verb & reg_affixed_two_lex_entry &
  [ SYNSEM unerg_verb ].

mv_np_trans_mle2 := main_verb & reg_affixed_two_lex_entry &
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

mv_unerg_nale := main_verb & basic_lex_entry &
  [ INFLECTED +,
    SYNSEM unerg_verb &
	      [ LOCAL.CONT.LISZT <! *top* !> ] ].

mv_np_trans_nale := main_verb & basic_lex_entry &
  [ INFLECTED +,
    SYNSEM np_trans_verb &
	   [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
		     CONT.LISZT <! *top* !> ] ] ].

intr_noun_word_nale := intr_noun_word & basic_lex_entry &
  [ INFLECTED + ].

proper_nale := proper_name_sg & basic_lex_entry &
  [ INFLECTED + ].

intrans_adj_nale := reg_intrans_adj & basic_lex_entry &
  [ INFLECTED + ].

adv_word_nale := adverb_word & basic_lex_entry &
  [ INFLECTED + ].

:end :type.
