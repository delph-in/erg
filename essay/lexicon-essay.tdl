math_xml_pn_sg := n_-_pn-sg_le &
 [ ORTH < "_MATH_" >,
   SYNSEM [ LKEYS.KEYREL.CARG "math-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

math_xml_pn_pl := n_-_pn-pl_le &
 [ ORTH < "_MATH_" >,
   SYNSEM [ LKEYS.KEYREL.CARG "math-xml",
            LOCAL.CAT.HEAD.MINORS.NORM no_rel,
	    MODIFD.LPERIPH +,
            PHON.ONSET con ] ].

math_xml_pn_pl2 := n_-_pn-pl_le &
 [ ORTH < "_MATH_s" >,
   SYNSEM [ LKEYS.KEYREL.CARG "math-xml",
            LOCAL.CAT.HEAD.MINORS.NORM no_rel,
	    MODIFD.LPERIPH +,
            PHON.ONSET con ] ].

math_xml_pn_pl3 := n_-_pn-pl_le &
 [ ORTH < "_MATH_", "'s" >,
   SYNSEM [ LKEYS.KEYREL.CARG "math-xml",
            LOCAL.CAT.HEAD.MINORS.NORM no_rel,
	    MODIFD.LPERIPH +,
            PHON.ONSET con ] ].

;; Needed to permit e.g. |3-step _MATH_|
math_xml_n1 := n_-_c-sg_le &
 [ ORTH < "_MATH_" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_math-xml_n_1_rel",
            LOCAL.CAT.HEAD [ --BARE -,
			     MINORS [ MIN norm_nom_rel,
				      NORM norm_rel ] ],
            PHON.ONSET con ] ].

math_xml_cp_1 := x_-_generic-cp_le &
 [ ORTH < "_MATH_" >,
   SYNSEM.PHON.ONSET con ].

math_xml_crd_1 := aj_-_i-crd-thr_le &
  [ ORTH < "_MATH_" >,
    SYNSEM [ LKEYS.KEYREL.CARG "_MATH_",
	     LOCAL [ CAT.HEAD [ MOD.FIRST expressed_synsem,
				CASE no_case ],
		     CONT.HOOK.INDEX ref-ind ],
             PHON.ONSET con ] ].

mathdisp_xml_pn := n_-_pn_le &
 [ ORTH < "_MATHDISP_" >,
   SYNSEM [ LKEYS.KEYREL.CARG "mathdisp-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

mathdisp_xml_cp_1 := x_-_generic-cp_le &
 [ ORTH < "_MATHDISP_" >,
   SYNSEM.PHON.ONSET con ].

math_cdm_xml_pn := n_-_pn_le &
 [ ORTH < "_MATH_CDM" >,
   SYNSEM [ LKEYS.KEYREL.CARG "math_cdm-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

cite_xml_pn_sg := n_-_pn-sg_le &
 [ ORTH < "_CITE_" >,
   SYNSEM [ LKEYS.KEYREL.CARG "cite-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

cite_xml_pn_pl := n_-_pn-pl_le &
 [ ORTH < "_CITE_" >,
   SYNSEM [ LKEYS.KEYREL.CARG "cite-xml",
            LOCAL.CAT.HEAD.MINORS.NORM no_rel,
	    MODIFD.LPERIPH +,
            PHON.ONSET con ] ].

ref_xml_pn := n_-_pn_le &
 [ ORTH < "_REF_" >,
   SYNSEM [ LKEYS.KEYREL.CARG "ref-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

ref_xml_pn2 := n_-_pn_le &
 [ ORTH < "(_REF_)" >,
   SYNSEM [ LKEYS.KEYREL.CARG "ref-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

refa_xml_pn := n_-_pn_le &
 [ ORTH < "(_REF_)a" >,
   SYNSEM [ LKEYS.KEYREL.CARG "refa-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

refa_xml_pn2 := n_-_pn_le &
 [ ORTH < "_REF_(a)" >,
   SYNSEM [ LKEYS.KEYREL.CARG "refa-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

refb_xml_pn := n_-_pn_le &
 [ ORTH < "(_REF_)b" >,
   SYNSEM [ LKEYS.KEYREL.CARG "refb-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

refb_xml_pn_2 := n_-_pn_le &
 [ ORTH < "_REF_(b)" >,
   SYNSEM [ LKEYS.KEYREL.CARG "refb-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

refc_xml_pn := n_-_pn_le &
 [ ORTH < "(_REF_)c" >,
   SYNSEM [ LKEYS.KEYREL.CARG "refc-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

refc_xml_pn_2 := n_-_pn_le &
 [ ORTH < "_REF_(c)" >,
   SYNSEM [ LKEYS.KEYREL.CARG "refc-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

refii_xml_pn := n_-_pn_le &
 [ ORTH < "_REF_(ii)" >,
   SYNSEM [ LKEYS.KEYREL.CARG "ref-ii-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

refiii_xml_pn := n_-_pn_le &
 [ ORTH < "_REF_(iii)" >,
   SYNSEM [ LKEYS.KEYREL.CARG "ref-iii-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

refiv_xml_pn := n_-_pn_le &
 [ ORTH < "_REF_(iv)" >,
   SYNSEM [ LKEYS.KEYREL.CARG "ref-iv-xml",
            LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
            PHON.ONSET con ] ].

;; |that cats|
this_det_rbst := mal_det_pl_le &
 [ ORTH < "this" >,
   SYNSEM [ LKEYS.KEYREL.PRED _these_q_dem_rel,
	    PHON.ONSET con ] ].

that_det_rbst := mal_det_pl_le &
 [ ORTH < "that" >,
   SYNSEM [ LKEYS.KEYREL.PRED _those_q_dem_rel,
	    PHON.ONSET con ] ].

;; Prevent use of robust n3sg inflection
less_than_v1 := v_np_ntr_le &
 [ ORTH < "<" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_less+than_a_1_rel",
            LOCAL.CAT.HEAD.--MAL3SG -,
            PHON.ONSET con ] ].

greater_than_v1 := v_np_ntr_le &
 [ ORTH < ">" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_greater+than_a_1_rel",
            LOCAL.CAT.HEAD.--MAL3SG -,
            PHON.ONSET con ] ].

;; Avoid spurious robust bare-NP, since also have mass noun variant
note_n1 := n_-_c_le &
 [ ORTH < "note" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_note_n_1_rel",
            LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

;; Avoid spurious bare-NP parse since this often appears as a title:
section_n1 := n_pp_c_le &
 [ ORTH < "section" >,
   SYNSEM [ LKEYS [ --COMPKEY _of_p_sel_rel,
                    KEYREL.PRED "_section_n_of_rel" ],
            LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

;; Spurious |of course|
course_n1 := n_pp_c-ns-of_le &
 [ ORTH < "course" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_course_n_of_rel",
            LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

;; Missing "to" |according the report|
according_to_rbst := p_np_i_le &
 [ ORTH < "according" >,
   SYNSEM [ LKEYS.KEYREL.PRED _according+to_p_rel,
            PHON.ONSET voc ],
   GENRE robust ].

;; Mark plurals of decades with apostrophes as robust: |1980's|
;;
generic_pl_apos_noun_ne := never_unify_le & [ ORTH < "_never_unify_" > ].
generic_pl_apos_noun_ne_rbst := n_-_c-pl-gen_le &
  [ ORTH < "_generic_plur_apos_ne_" >,
    TOKENS.+LIST < [ +CLASS plur_apos_ne ] >,
    GENRE robust ].

;; For |where _MATH_| since lex entry for _MATH_ has empty SLASH
where_subord := p_cp_s_le &
 [ ORTH < "where" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_when_x_subord_rel",
            LOCAL.CAT.VAL.COMPS.FIRST.LEX +,
            PHON.ONSET con ] ].

;; For some reason, the inflr rule third_sg_fin_v_rbst interacts badly with
;; the entry lie_mental_v1 when packing is on, crashing ACE with this msg:
;; "error: edge #263 had generalization daughter #248 which packs nothing"
;;
lie_mental_v1 := v_pp*_le &
 [ ORTH < "lie" >,
   SYNSEM [ LKEYS [ --COMPKEY _to_p_rel,
                    KEYREL.PRED "_lie_v_mental_rel" ],
	    LOCAL.CAT.HEAD.--MAL3SG -,
	    PHON.ONSET con ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Missing infinitival |to|

want_mal_v1_rbst := v_vp_seq-bse_le_rbst &
  [ ORTH < "want" >,
    SYNSEM [ LKEYS.KEYREL.PRED "_want_v_1_rel",
	     PHON.ONSET con ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Missing |to| for raising: |they tend win.|

chance_v1_rbst := v_vp_ssr-nimp_le_rbst &
 [ ORTH < "chance" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_chance_v_1_rel",
            PHON.ONSET con ] ].

get_to_v1_rbst := v_vp_ssr-nimp_le_rbst &
 [ ORTH < "get" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_get_v_to_rel",
            PHON.ONSET con ] ].

happen_v2_rbst := v_vp_ssr-nimp_le_rbst &
 [ ORTH < "happen" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_happen_v_1_rel",
            PHON.ONSET con ] ].

have_to1_rbst := v_vp_ssr-nimp_le_rbst &
 [ ORTH < "have" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_have_v_qmodal-2_rel",
            PHON.ONSET con ] ].

tend_v1_rbst := v_vp_ssr-nimp_le_rbst &
 [ ORTH < "tend" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_tend_v_1_rel",
            PHON.ONSET con ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Erroneous obj-control as subj-control

advise_mal_v1_rbst := v_vp_seq_le_rbst &
 [ ORTH < "advise" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_advise_v_1_rel",
            PHON.ONSET voc ] ].

allow_mal_v1_rbst := v_vp_seq_le_rbst &
 [ ORTH < "allow" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_allow_v_1_rel",
            PHON.ONSET voc ] ].

enable_mal_v1_rbst := v_vp_seq_le_rbst &
 [ ORTH < "enable" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_enable_v_1_rel",
            PHON.ONSET voc ] ].

permit_mal_v1_rbst := v_vp_seq_le_rbst &
 [ ORTH < "permit" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_permit_v_1_rel",
            PHON.ONSET con ] ].

;; Missing prep |to|

amount_to_v1_rbst := v_np_pp_le_rbst &
 [ ORTH < "amount" >,
   SYNSEM [ LKEYS [ --COMPKEY _to_p_sel_rel,
                    KEYREL.PRED "_amount_v_to_rel" ],
            PHON.ONSET voc ] ].

correspond_to_v1_rbst := v_np_pp_le_rbst &
 [ ORTH < "correspond" >,
   SYNSEM [ LKEYS [ --COMPKEY _to_p_sel_rel,
                    KEYREL.PRED "_correspond_v_to_rel" ],
            PHON.ONSET con ] ].

lead_to_v1_rbst := v_np_pp_le_rbst &
 [ ORTH < "lead" >,
   SYNSEM [ LKEYS [ --COMPKEY _to_p_sel_rel,
                    KEYREL.PRED "_lead_v_to_rel" ],
            PHON.ONSET con ] ].

respond_to_v1_rbst := v_np_pp_le_rbst &
 [ ORTH < "respond" >,
   SYNSEM [ LKEYS [ --COMPKEY _to_p_sel_rel,
                    KEYREL.PRED "_respond_v_to_rel" ],
            PHON.ONSET con ] ].

;; |allows us focus on X|
allow_v1_bse_rbst := v_np-vp_bse_le_rbst &
 [ ORTH < "allow" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_allow_v_1_rel",
            PHON.ONSET voc ] ].

;; |allows us focus on X|
assume_v1_bse_rbst := v_np-vp_bse_le_rbst &
 [ ORTH < "assume" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_assume_v_1_rel",
            PHON.ONSET voc ] ].

;; |causes X grow|
cause_v1_bse_rbst := v_np-vp_bse_le_rbst &
 [ ORTH < "cause" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_cause_v_1_rel",
            PHON.ONSET con ] ].

;; |considered [to] be the following|
consider_v1_rbst := v_np-vp_bse_le_rbst &
 [ ORTH < "consider" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_consider_v_1_rel",
            PHON.ONSET con ] ].

;; |we need arise|
need_bse_v1_rbst := v_vp_must-p_le &
 [ ORTH < "need" >,
   SYNSEM [ LKEYS.KEYREL.PRED _need_v_qmodal_rel,
            PHON.ONSET con ],
   GENRE robust ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Contracted auxiliaries

be_c_are_cx := v_prd_are-cx_le &
 [ ORTH < "'re" >,
   SYNSEM.PHON.ONSET con ].

be_c_are_cx_2 := v_prd_are-cx_le &
 [ ORTH < "’re" >,
   SYNSEM.PHON.ONSET con ].

be_c_is_cx := v_prd_is-cx_le &
 [ ORTH < "s" >,
   SYNSEM.PHON.ONSET voc ].

be_c_is_cx_2 := v_prd_is-cx_le &
 [ ORTH < "'s" >,
   SYNSEM.PHON.ONSET con ].

be_c_is_cx_3 := v_prd_is-cx_le &
 [ ORTH < "’s" >,
   SYNSEM.PHON.ONSET con ].

be_c_is_cx_lq_2 := v_prd_is-cx_le &
 [ ORTH < "‘s" >,
   SYNSEM.PHON.ONSET con ].

be_id_am_cx := v_np_am-cx_le &
 [ ORTH < "m" >,
   SYNSEM.PHON.ONSET voc ].

be_id_am_cx_2 := v_np_am-cx_le &
 [ ORTH < "'m" >,
   SYNSEM.PHON.ONSET con ].

be_id_am_cx_3 := v_np_am-cx_le &
 [ ORTH < "’m" >,
   SYNSEM.PHON.ONSET con ].

be_id_are_cx := v_np_are-cx_le &
 [ ORTH < "'re" >,
   SYNSEM.PHON.ONSET con ].

be_id_are_cx_2 := v_np_are-cx_le &
 [ ORTH < "’re" >,
   SYNSEM.PHON.ONSET con ].

be_id_is_cx := v_np_is-cx_le &
 [ ORTH < "s" >,
   SYNSEM.PHON.ONSET voc ].

be_id_is_cx_2 := v_np_is-cx_le &
 [ ORTH < "'s" >,
   SYNSEM.PHON.ONSET con ].

be_id_is_cx_3 := v_np_is-cx_le &
 [ ORTH < "’s" >,
   SYNSEM.PHON.ONSET con ].

be_id_is_cx_lq_2 := v_np_is-cx_le &
 [ ORTH < "‘s" >,
   SYNSEM.PHON.ONSET con ].

be_it_cop_is_cx := v_np-rc_is-cx_le &
 [ ORTH < "s" >,
   SYNSEM.PHON.ONSET voc ].

be_it_cop_is_cx_2 := v_np-rc_is-cx_le &
 [ ORTH < "'s" >,
   SYNSEM.PHON.ONSET con ].

be_it_cop_is_cx_3 := v_np-rc_is-cx_le &
 [ ORTH < "’s" >,
   SYNSEM.PHON.ONSET con ].

be_it_cop_is_cx_lq_2 := v_np-rc_is-cx_le &
 [ ORTH < "‘s" >,
   SYNSEM.PHON.ONSET con ].

be_nv_is_cx := v_cp_is-cx_le &
 [ ORTH < "s" >,
   SYNSEM.PHON.ONSET voc ].

be_nv_is_cx_2 := v_cp_is-cx_le &
 [ ORTH < "'s" >,
   SYNSEM.PHON.ONSET con ].

be_nv_is_cx_3 := v_cp_is-cx_le &
 [ ORTH < "’s" >,
   SYNSEM.PHON.ONSET con ].

be_nv_is_cx_lq_2 := v_cp_is-cx_le &
 [ ORTH < "‘s" >,
   SYNSEM.PHON.ONSET con ].

be_th_cop_is_cx := v_np-xp_is-cx_le &
 [ ORTH < "s" >,
   SYNSEM.PHON.ONSET voc ].

be_th_cop_is_cx_2 := v_np-xp_is-cx_le &
 [ ORTH < "'s" >,
   SYNSEM.PHON.ONSET con ].

be_th_cop_is_cx_3 := v_np-xp_is-cx_le &
 [ ORTH < "’s" >,
   SYNSEM.PHON.ONSET con ].

be_th_cop_is_cx_lq_2 := v_np-xp_is-cx_le &
 [ ORTH < "‘s" >,
   SYNSEM.PHON.ONSET con ].

had_aux_cx := v_vp_had-cx_le &
 [ ORTH < "d" >,
   SYNSEM.PHON.ONSET con ].

had_aux_cx_2 := v_vp_had-cx_le &
 [ ORTH < "'d" >,
   SYNSEM.PHON.ONSET con ].

had_aux_cx_3 := v_vp_had-cx_le &
 [ ORTH < "’d" >,
   SYNSEM.PHON.ONSET con ].

has_aux_cx := v_vp_has-cx_le &
 [ ORTH < "s" >,
   SYNSEM.PHON.ONSET voc ].

has_aux_cx_2 := v_vp_has-cx_le &
 [ ORTH < "'s" >,
   SYNSEM.PHON.ONSET con ].

has_aux_cx_3 := v_vp_has-cx_le &
 [ ORTH < "’s" >,
   SYNSEM.PHON.ONSET con ].

has_aux_cx_lq_2 := v_vp_has-cx_le &
 [ ORTH < "‘s" >,
   SYNSEM.PHON.ONSET con ].

have-poss_cx := v_np_poss-cx_le &
 [ DIALECT br,
   ORTH < "’ve" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_have_v_1_rel",
            PHON.ONSET con ] ].

have-poss_cx2 := v_np_poss-cx_le &
 [ DIALECT br,
   ORTH < "'ve" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_have_v_1_rel",
            PHON.ONSET con ] ].

have_bse_aux_cx_1 := v_vp_have-bse-cx_le &
 [ ORTH < "ve" >,
   SYNSEM.PHON.ONSET con ].

have_bse_aux_cx_2 := v_vp_have-bse-cx_le &
 [ ORTH < "'ve" >,
   SYNSEM.PHON.ONSET con ].

have_bse_aux_cx_3 := v_vp_have-bse-cx_le &
 [ ORTH < "’ve" >,
   SYNSEM.PHON.ONSET con ].

have_fin_aux_cx := v_vp_have-f-cx_le &
 [ ORTH < "ve" >,
   SYNSEM.PHON.ONSET con ].

have_fin_aux_cx_2 := v_vp_have-f-cx_le &
 [ ORTH < "'ve" >,
   SYNSEM.PHON.ONSET con ].

have_fin_aux_cx_3 := v_vp_have-f-cx_le &
 [ ORTH < "’ve" >,
   SYNSEM.PHON.ONSET con ].

will_aux_pos_cx := v_vp_will-p-cx_le &
 [ ORTH < "ll" >,
   SYNSEM [ LKEYS.KEYREL.PRED _will_v_aux_rel,
            PHON.ONSET con ] ].

will_aux_pos_cx_2 := v_vp_will-p-cx_le &
 [ ORTH < "'ll" >,
   SYNSEM [ LKEYS.KEYREL.PRED _will_v_aux_rel,
            PHON.ONSET con ] ].

will_aux_pos_cx_3 := v_vp_will-p-cx_le &
 [ ORTH < "’ll" >,
   SYNSEM [ LKEYS.KEYREL.PRED _will_v_aux_rel,
            PHON.ONSET con ] ].

would_aux_pos_cx := v_vp_mdl-p-cx_le &
 [ ORTH < "d" >,
   SYNSEM [ LKEYS.KEYREL.PRED _would_v_modal_rel,
            PHON.ONSET con ] ].

would_aux_pos_cx_2 := v_vp_mdl-p-cx_le &
 [ ORTH < "'d" >,
   SYNSEM [ LKEYS.KEYREL.PRED _would_v_modal_rel,
            PHON.ONSET con ] ].

would_aux_pos_cx_3 := v_vp_mdl-p-cx_le &
 [ ORTH < "’d" >,
   SYNSEM [ LKEYS.KEYREL.PRED _would_v_modal_rel,
            PHON.ONSET con ] ].
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; This one does not require a hyphen |integer linear order|
linear_cmpd_n2 := n_-_c-cpd_le &
 [ ORTH < "linear" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_linear_a_1_rel",
            PHON.ONSET con ] ].

;; Redefine this one, since we want non-robust comma |Kim, as well as Browne,..|

as_well_as_conj_1 := p_np_i_le &
 [ ORTH < "as", "well", "as" >,
   SYNSEM [ LKEYS.KEYREL.PRED _as+well+as_p_rel,
            PHON.ONSET voc ] ].

;; Prevent robust bare singular, to allow acronym RUG
rug_n1 := n_-_c_le &
 [ ORTH < "rug" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_rug_n_1_rel",
   	    LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

;; Block unwanted analysis as S-initial extracted adverb
fig_abb := never_unify_le & [ ORTH < "_never_unify_" > ].

fig_n1 := n_-_c_le &
 [ ORTH < "fig" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_fig_n_1_rel",
   	    LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

figure_abb_n1 := n_-_c_le &
 [ ORTH < "Fig." >,
   SYNSEM [ LKEYS.KEYREL.PRED "_figure_n_1_rel",
   	    LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

model_n2 := n_pp_c-of_le &
 [ ORTH < "model" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_model_n_of_rel",
   	    LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

theorem_n1 := n_-_c_le &
 [ ORTH < "theorem" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_theorem_n_1_rel",
   	    LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

center_of_mass_a1 := aj_-_i_le &
 [ ORTH < "center", "of", "mass" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_center+of+mass_n_1_rel",
            PHON.ONSET con ] ].

center_of_mass_a2 := aj_-_i_le &
 [ ORTH < "center-", "of-", "mass" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_center+of+mass_n_1_rel",
            PHON.ONSET con ] ].

center_of_mass_a1_br := aj_-_i_le &
 [ DIALECT br,
   ORTH < "centre", "of", "mass" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_center+of+mass_n_1_rel",
            PHON.ONSET con ] ].

center_of_mass_a2_br := aj_-_i_le &
 [ DIALECT br,
   ORTH < "centre-", "of-", "mass" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_center+of+mass_n_1_rel",
            PHON.ONSET con ] ].

;; bare singular competes in |as well|
well_n1 := n_-_c-ntc_le &
 [ ORTH < "well" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_well_n_1_rel",
   	    LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

;; We want |_MATH_ in _MATH_| as a clause
in_math_xml_root_post := av_-_s-cp-nsp-po_le &
 [ ORTH < "in", "_MATH_" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_in+math_a_1_rel",
            PHON.ONSET con ] ].

;; Avoid robust analysis of |goods|
good_n1 := n_-_m-nocnh_le &
 [ ORTH < "good" >,
   ALTS.PLMASS -,
   SYNSEM [ LKEYS.KEYREL.PRED "_good_n_1_rel",
            PHON.ONSET con ] ].

;; Avoid |s| sans apostrophe as contracted copula as in |waiting 60 s in ...|
be_c_is_cx := never_unify_le & [ ORTH < "_never_unify_" > ].
be_id_is_cx := never_unify_le & [ ORTH < "_never_unify_" > ].
be_it_cop_is_cx := never_unify_le & [ ORTH < "_never_unify_" > ].
be_nv_is_cx := never_unify_le & [ ORTH < "_never_unify_" > ].
be_th_cop_is_cx := never_unify_le & [ ORTH < "_never_unify_" > ].
has_aux_cx := never_unify_le & [ ORTH < "_never_unify_" > ].

;; For some reason, unknown word |Huang| gets tagged as v-prespart
huang_pn := n_-_pn_le &
 [ ORTH < "Huang" >,
   SYNSEM [ LKEYS.KEYREL.CARG "Huang",
            PHON.ONSET con ] ].

zero_n1 := n_-_c_le &
 [ ORTH < "zero" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_zero_n_1_rel",
   	    LOCAL.CAT.HEAD.--BARE -,
            PHON.ONSET con ] ].

