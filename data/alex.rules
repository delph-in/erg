;			COMPUTING GOOD-TIME AND BAD-TIME

; *** Can we generalise any of this?  For example, can we generalise
; def_rel to a monotone quantifier?  And can we generalise
; numbered_hour_rel, so that we have one function for dofm, dofw,
; numbered_hour, and so on?
;
;  All these rules will need a temp_rel constraint on the bound
; variable in the input, once mrs munging rules can handle
; supertypes.  This is so that we get good_time only when the
; appropriate variable is a temporal expression.  And we will need
; corresponding good_place rules for place_rel's (e.g., "office" will
; have to be classified as a place_rel).
;
; All these expressions will have to have temp_rel and
; monotonic_quantifier conditions added once the munging rules can
; handle supertypes, and once the quantifier types are introduced.
; Nonmontone quantifiers such as "no" will need to be handled by other
; rules.
;
; alex_equals_rel(c,x) is to be interpreted as "c denotes an
; interval which temporally includes x".  So remember that it's
; temporal inclusion rather than equality that we should have here!!!!!!!!!
;
; good_time(c) is to be interpreted as follows: 
; good_time(c) is true iff:
; (a) c is a good time, and 
; (b) if there is a c' such that for all P except good_time where P(c)
; is true, P(c') is also true, then c is contained in c'.  That is, c
; is the minimal interval that satisfies the conditions in the MRS
; that are placed on c.
;
; bad_time(c) will be interpreted in a similar way.  Note that if we
; sometimes need something other than the minimal interval, then we
; can separate out conditions (a) and (b) in the truth definition of
; good_time, and we should make good_time just mean (a), and some
; other predicate such as alex_mininterval_rel(c) mean the (b) part. 
;
; When we have something like "every Monday is good", we will get
; good_time(c) in the top handel, and
; alex_equals_rel(c,x) in the scope of the quantifier every where x
; is the bound variable.  This will mean that any x that satisfies
; Monday(x) is included in c, but c is also the smallest interval that
; contains these x's.  In other words, c is exactly the set of
; elements x such that x satisfies Monday(x).  In "No monday is good"
; we want to get bad_time(c) in the top handel, and
; alex_equals_rel(c,x) in the scope of a universal quantifier which has
; the same conditions in its restrictor as appear in the restrictor of
; "no".  So this will mean that for any x such that Monday(x) is true,
; x is in c, and c is the smallest interval that contains these x's,
; and c is a bad_time.  "No Monday is bad" will be similar, except
; we'll have good_time(c) replacing bad_time(c).   
; 
; Note that for non-monotone quantifiers, we must repeat the
; conditions in the restrictor within another quantifier.  This is
; because putting alex_equals_rel(c,x) in the scope of the
; "no"-quantifier doesn't semantically give what you want.
; no(x,K1,K2) is verified by an embedding function f if for any g that
; extends f, if g verifies K1, then there is no h that extends g which
; verifies K2.  So if we put alex_equals(c,x) in K2, then the result
; will mean that either alex_equals(c,x) is false, or Q(x) is false,
; where Q(x) is the original stuff that was in there.  But we want to
; maintain that Q(x) is false, and ensure alex_equals(c,x) is true.
; This is why we have to repeat the restrictor stuff in a universally
; quantified formula in these cases.
;
; When we deal with something like "No Monday is good", we want
; bad_time(c) & alex_minimal_interval(c) at the top handel, and
; alex_includes_rel(c,x) in the scope of a universal quantifier which
; repeats the restrictor in the "no"-quantifier.  "No Monday
; is bad" requires good_time(c) instead of bad_time(c).   
;
;  Dealing with "<temporal expression> is fine"
;  -------------------------------------------
;
; I have ensured
; that good-time picks the right interval by identifying the variable
; with the one that _fine predicates over.  This means that even
; though there is a reading of "two on the sixteenth is fine" where
; the quantifier introduced by the sixteenth has wide scope over the
; one introduced by "two o'clock" (and this is a spurious ambiguity),
; good-time will still predicate over a constant that is equal to the 
; variable that denotes two o'clock, and this will be attached to the
; top handel.  So here dealing with underspecification helps us; we
; don't have to worry about the relative scope of the quantifiers in
; the input to the re-write rule.
;
; This should handle "two is fine", "two fifteen is fine", "two
; o'clock on the sixteenth is fine", "two seems fine", "the sixteenth
; is fine", "two in the afternoon is fine", "two would be fine", "two
; would probably be fine".
; "that will be fine with me", "that's fine by me", "if you want to do
; it before twelve, that is fine" etc etc.  Note that with this last
; sentence, discourse update would need to be used to resolve "that"
; to "twelve" rather than "you want to do it before twelve", because
; we are placing good-time(x) on the argument x of _fine.
;
; It should not do "Fine, but not two", or "Fine, at two", because
; "fine" in these sentences produces EXCL(fine) in the MRS.
;
; There are still bugs, which mean that "two seems fine" has
; interpretations were _sound_seem is in the restrictor of the
; quantifier.  Furthermore, "fine by me" doesn't trigger this rule,
; because this sentence produces only readings for "fine" where it's
; an ADV rather than an ADJ, and it produces EXCL(fine) in the MRS.
;
; There's a sentence in the verbmobil corpus "That would be fine, on
; August 8th at 9:30", where we get good-time(v10) where v10 is
; identified with "that"; as with discourse update across sentence
; boundaries, we will have to use discourse principles to identify
; "that" with the time expression given, namely August 8th at 9:30.
; Similarly for "If you want to do it before 12, that would be fine".
; See the file
; ~/Research/California/Data/Parsed.Data/finding.antecedents for more
; on how we will resolve anaphora such as "that" in "that is fine".
;
; This rule will work for "that is fine"-type sentences only if we
; make the simplifying assumption that "that" always resolves to a
; time.  For otherwise, we're stating good-time(x) on something that's
; not a time.  This is an unsound assumption, but it seems to work in
; practice.  This is because 
; all the sentences in Verbmobil of the form "that's fine with me" are
; ones where it would be reasonable to identify "that" with a time
; expression (although many of these from a theoretical semantic point
; of view actually should stand for events such as "meeting you on the
; 16th").  There is one exception to this: "A: I would love to get
; some lunch afterwards. B: That would be fine."
;
; Note that as things stand, it supplies good-time even if _fine and
; support are in the restrictor of the quantifier.  
;
; Note that this rule does not handle negation.  We need to modify
; this rule by adding conditions in the input that negation isn't
; present, and then we need to produce a corresponding rule that
; produces bad-time in the output when there is negation in the input.
; As things stand, "two isn't fine" triggers the rule below, to
; produce good-time (but at least the alex_equals isn't in the scope
; of the negation!).

time_is_fine_rule := mrs_rule &
	[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ] !>,
LCONDITION.LISZT <! quant_rel &
		[ HANDEL #h2,
		  BV #x1,
		  RESTR #h33,
		  SCOPE #h44,
		  DIM #d1 ],
		_fine_rel & 
		[ HANDEL #h4,
		 ARG #x1,
		 DIM #d333 ] !>,
 OUTPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		good_time_rel &
		 [HANDEL #h1,
		  INST   #y ],
		alex_equals_rel &
		[HANDEL #h44,
		ALEXARG1 #y,
		ALEXARG2 #x1 ]
			!> ].

; DEALING WITH "<temporal expression> is impossible"
;-------------------------------
; This rule should fire for "two is impossible"; "the sixteenth is
; impossible"; "two sounds impossible" etc etc.  We would have similar
; rules for "that is bad", "two is bad", "two is scheduled", "two
; seems bad", "the twenty seventh is pretty full", and so on.  To get
; these other rules producing bad_time, just replace _impossible_rel
; below with _bad_rel, _full_rel, _schedule_rel, etc.
;
;
; This produces bad_time.  We need a corresponding good_time rule for
; when negated condition is present (i.e., for "two is not impossible").  
; This rule lacks the necessary condition that there is no negation in
; the sentence.  This has to be added.

time_is_impossible_rule := mrs_rule &
	[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &		
		[ HANDEL #h2,
		  BV #x1,
		  RESTR #h33,
		  SCOPE #h44,
		  DIM #d1 ],
		_impossible_rel & 
		[ HANDEL #h4,
		 ARG #x1 ] !>,
 OUTPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		 SOA #h22 ],
		bad_time_rel &
		 [HANDEL #h1,
		  INST   #y ],
	 	 ^c20 &
		[HANDEL #h2,
		 BV #x1,
		RESTR  #h33,
		SCOPE #h44,
		DIM #d1 ],
		_impossible_rel & 
		[HANDEL #h4,
		 ARG #x1 ],
		alex_equals_rel &
		[HANDEL #h44,
		ALEXARG1 #y,
		ALEXARG2 #x1 ]
			!> ].

; BEING ON VACATION ON <TIME-EXPRESSION>
; -------------------------------------
; This will produce bad_time for "I will be on vacation on
; <time-expression>", where <time-expression> can be "the sixteenth"
; "some time around the sixteenth", (when time gets typed as a temp_rel
; and these rewrite rules are able to reason about supertypes), "every
; Monday in March", etc etc.  It can also handle "I will take my
; vacation on <time-expression>", "I plan to take my vacation on
; <time-expression>" etc.  This is because there are no constraints at
; all on the INPUT as to what the verb is.  The input only requires
; the word VACATION, and for there to be an _on_temp_rel to a time
; expression.  So there is a danger of over-generation here.
;
; Note that there is a bug in the grammar (on 29/9/98), in that some
; of the parses of "I am on vacation on the sixteenth" produce MRSs
; that don't contain _vacation(x3).  Some do, however.  
; 
; We will be able to generalise this rule once we can have
; inc_temp_rel as a supertype, to handle "vacation on...", "vacation
; for ...", "vacation in March" and "vacation around ...".  When we
; can use supertypes, we can replace _on_temp_rel with ^c21 &
; inc_temp_rel in the input and output.  We need another rule for 
; handling "vacation until the sixteenth" or "vacation by then".  In
; the former case, we want the bad_time to be 
; between some anaphorically specified time and the
; sixteenth, rather than it being the sixteenth.  This rule would need
; the same kind of ploy as we use in the rule for generating good_time
; for "Let's meet after the sixteenth", given below.  Similarly for
; "vacation after the sixteenth" and "I will be on vacation by then"
;
; Note that there are some parses of "I am taking a vacation on the
; sixteenth", where the _on_temp_rel modifies "vacation" rather than
; the event.  The rule below introduces bad_time for both the cases
; were the parse is "I am taking (vacation on the sixteenth)" and for
; the parse "(I am taking vacation) on the sixteenth".

vacation_on_t_rule := mrs_rule &
	[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &		
		[ HANDEL #h2,
		  BV #x1,
		  RESTR #h33,
		  SCOPE #h44,
		  DIM #d1 ],
		_on_temp_rel & 
		[ HANDEL #h4,
		 ARG #d56,
		 DIM #d55,
		 ARG3 #x1 ], 
		_vacation_rel &
		[ HANDEL #h5,
		  INST #x3 ] !>,
 OUTPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &		
		[ HANDEL #h2,
		  BV #x1,
		  RESTR #h33,
		  SCOPE #h44,
		  DIM #d1 ],
		_on_temp_rel & 
		[ HANDEL #h4,
		 ARG #d56,
		 DIM #d55,
		 ARG3 #x1 ], 
		_vacation_rel &
		[ HANDEL #h5,
		  INST #x3 ],
		bad_time_rel &
		[ HANDEL #h1,
		  INST #c ],
		alex_equals_rel &
		[ HANDEL #h44,
		  ALEXARG1 #c,
		  ALEXARG2 #x1 ]
			!> ].


; <TIME-EXPRESSION> WORKS
; ----------------------
; This produces good_time for "two o'clock works for me", "the
; sixteenth will work", "every monday in March works" etc. etc.
;
; Note that we need to add the negation constraint.  We need a
; corresponding bad_time rule to deal with "the twenty seventh does
; not work". 
;

t_works_rule := mrs_rule &
	[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &		
		[ HANDEL #h2,
		  BV #x1,
		  RESTR #h33,
		  SCOPE #h44,
		  DIM #d1 ],
		_work_acceptable_rel & 
		[ HANDEL #h4,
		 EVENT #e2,
		 ARG3 #x1 ] !>,
 OUTPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &		
		[ HANDEL #h2,
		  BV #x1,
		  RESTR #h33,
		  SCOPE #h44,
		  DIM #d1 ],
		_work_acceptable_rel & 
		[ HANDEL #h4,
		 EVENT #e2,
		 ARG3 #x1 ],
		good_time_rel &
		[ HANDEL #h1,
		  INST #c ],
		alex_equals_rel &
		[ HANDEL #h44,
		  ALEXARG1 #c,
		  ALEXARG2 #x1 ] !> ].



; SOUNDS FINE
; -----------
;
; "sounds/that is fine" should produce good-time.
; "sounds fine" doesn't explicitly produce a time variable, however.
; But it does produce a structure where there is a pron(x7) and
; _fine(x7,d8), and good_time
; should predicate over this pronoun.
;
; This deals with "sounds fine" when there is no quantifier, but a
; pronoun condition is introduced instead.  There is no need
; for an alex_equals condition. This will also handle "that is fine",
; "that seems fine" etc.;
;
; Note that this rule overgenerates, because it doesn't take into
; account any resolution of the antecedent that "that" in "that is
; fine", or the implicit pronoun in "sounds fine".  The algorithm for
; computing this has not been encoded yet; Ann will do it.  See the
; file ~/Research/California98/Data/Parsed.Data/finding.antecedents
; for the heuristics for finding the antecedents.  Once this
; algorithm is coded up, the rule below will need to be changed to include
; a temp_rel(x4) condition (as with all the other rules for
; introducing good_time and bad_time).  There will also be an equivalent
; good_place rule for "that is fine", when the pronoun "that" is
; resolved to satisfy place_rel(x4).
;
; Note that this rule does not handle negation.  We need to modify
; this rule by adding conditions in the input that negation isn't
; present, and then we need to produce a corresponding rule that
; produces bad-time in the output when there is negation in the input.

sounds_fine_rule :=  mrs_rule &
	[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		pron_rel & 
		[ HANDEL #h1,
		  INST #x4 ],
		 _fine_rel & 
		[ HANDEL #h222,
	          ARG #x4,
		  DIM #d5 ] !>,
	 OUTPUT.LISZT <!
		  prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		pron_rel & 
		[ HANDEL #h1,
		  INST #x4 ],
		 _fine_rel & 
		[ HANDEL #h222,
	          ARG #x4,
		  DIM #d5 ], 
		good_time_rel &
		[HANDEL #h1,
		 INST #x4] !> ].


; SOUNDS GOOD
;------------
; "two sounds good" and "sounds good" should both produce good-time.
; "sounds good" doesn't explicitly produce a time variable, however.
; But it does produce a structure where there is a pron(x7) and
; _good(x7,d8), and given the parse for "two sounds good", good_time
; should predicate over this pronoun.
;
;
; This deals with "sounds good" when there is no quantifier, but a
; pronoun condition is introduced instead.  
;
; Note that this rule does not handle negation.  We need to modify
; this rule by adding conditions in the input that negation isn't
; present, and then we need to produce a corresponding rule that
; produces bad-time in the output when there is negation in the input.

sounds_good_rule :=  mrs_rule &
	[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		pron_rel & 
		[ HANDEL #h1,
		  INST #x4 ],
		 _good_rel & 
		[ HANDEL #h222,
	          ARG #x4,
		  DIM #d5 ] !>,
	 OUTPUT.LISZT <!
		  prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		pron_rel & 
		[ HANDEL #h1,
		  INST #x4 ],
		 _good_rel & 
		[ HANDEL #h222,
	          ARG #x4,
		  DIM #d5 ], 
		good_time_rel &
		[HANDEL #h1,
		 INST #x4] !> ].

; <TIME> SOUNDS GOOD
;-------------------
;
; The following rule assumes a quantified (time) expression 
; in the input.  It should parse "two sounds good", "two is good",
; "the sixteenth is good", "two on the sixteenth is good" etc, etc.
;
; Note that this rule needs temp_rel(x4) added, once these re-write
; rules can reason about supertypes.  As things stand, it will be
; triggered by "meeting in March sounds good" (where we will get
; good_time predicated of the nominalized meeting rather than march),
; and "Your office sounds good".
;
; Note that this rule doesn't handle negation yet, and some other
; conditions need to be added to block this rule from firing when
; analysing "two does not sound good".

time_sounds_good_rule :=  mrs_rule &
	[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		 _good_rel & 
		[ HANDEL #h222,
	          ARG #x4,
		  DIM #d6 ] !>,
	 OUTPUT.LISZT <!
		  prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		 _good_rel & 
		[ HANDEL #h222,
	          ARG #x4,
		  DIM #d6 ], 
		good_time_rel &
		[HANDEL #h1,
		 INST #y],
		alex_equals_rel & 
		[HANDEL #h4,
		ALEXARG1 #y,
		ALEXARG2 #x4] !> ].

; Note that once the supertypes things are sorted out for re-write
; rules, we can block "meeting in March sounds good" producing a
; good_time on the meeting for the above by
; introducing temp_rel(x4), and we have another rule which stipulates
; in the input the addition conditions: nominalize(x4,h3) and h3:_meet_v(e6,d7) &
; h3:temp_loc_rel(x4,d8,x9) and _good(x4,d23) and in the output it
; stipulates:  good_time(c) & alex_equals(c,x9). 



; MEET AT <TIME EXPRESSION>
;----------------------------
;
; The following will deal with sentences such as "I will meet you at
; <time-expression>", where <time-expression> can be "two", "ten
; minutes past two", "any time around two", "at some time around
; two" and "at any time around Tuesday", "two o'clock in the
; afternoon", "two o'clock on Tuesday next week", etc etc.  Note that
; the expressions involving the word "time" (i.e., "at some time around
; two", "at any time around Tuesday", "at any time around two")
; will trigger this rule only once "time" is categorised as
; temp_rel, but this rule won't catch this case right now, on
; 25/9/98); etc. etc.  Furthermore, "half past two" doesn't currently
; trigger this rule because of a bug on the representation of half
; (which currently doesn't introduce a def quantifier.  But this will be
; changed, and once it is, this rule will work.
;
; We would need other rules for dealing with other _meet
; predicates, such as _meet_v_rel (which occurs in "Let us meet at
; two"), and _meet_up_rel ("Let's meet up at two").  The same holds
; for other verbs that `trigger' good-time (e.g., "get together",
; "arrange a meeting" etc etc etc). We could do this
; via macros, which generate new re-write rules from certain
; triggers. 
;
; We would also need other rules for dealing with other
; temporal location adverbials such as _on_temp_rel 
; (e.g., "I will meet you on Tuesday").  Introducing new subtypes on
; temp_loc_rel would  help generalise the rule.  For example, we could
; introduce
; inc_temp_loc_rel as a subtype of temp_loc_rel, which specifies
; inclusive temporal relationships such as "in", "on", "at", "around",
; but not "after".  noninc_temp_loc_rel would be the supertype for
; "after" and "before".  We would then need another type for dealing
; with "earlier than" and "later than" since these aren't typed as
; temp_loc_rel at all.  If we had the type inc_temp_loc_rel, then we
; should replace _at_temp_rel in the rule below with ^c30 & inc_temp_loc_rel. 
;
; Note that this rule does not handle negation.  It will produce
; good-time(t) for "I will not meet you at <time-expression>".  A
; negation condition needs to be introduced into this rule, and then we
; need a similar rule for inferring bad-time(t).

x_meet_y_at_t_rule := mrs_rule &
	[INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		_meet_someone_rel &
		[ HANDEL #h222,
		  EVENT  #e1,
		  ARG1    #x,
                  ARG3   #y ], 
		_at_temp_rel &
		[ HANDEL #h223,
		  ARG #e1,
		  DIM #d6,
		  ARG3 #x4 ] !>,
OUTPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		_meet_someone_rel &
		[ HANDEL #h222,
		  EVENT  #e1,
		  ARG1    #x,
                  ARG3    #y ], 
		_at_temp_rel &
		[ HANDEL #h223,
		  ARG #e1,
		  DIM #d6,
		  ARG3 #x4 ],
		good_time_rel &
		[ HANDEL #h1,
		  INST #c ],
		alex_equals_rel & 
		[ HANDEL #h4,
		ALEXARG1 #c,
		ALEXARG2 #x4 ] !> ].


; MEETING AFTER <TIME-EXPRESSION>
; --------------------------------

; This is like the previous rule, except the input contains
; after_prepx_temp_rel rather than at_temp_rel, and the output
; contains alex_after rather than alex_equals on the good_time
; variable and the variable introduced by <time-expression>.  In other
; words, in "I will meet you after two", we get good-time(c) & 
; _after_prepx(e,d,x) & alex_after(c,d,x) & numbered_hour(x,d7,d8,2,d11), 
; rather than good-time(c) and numbered_hour(x,d7,d8,2,d11) &
; _after_prepx(e,d,x) & alex_equals(c,x).  That is, instead of
; alex_equals(c,x), we have alex_after(c,d,x). d in this case is
; filled in by "just after two", but not by "right after two".
;
; This rule should handle "I will meet you after two", "I will meet
; you after Tuesday" (note that there are several parses of this, and
; only some of the parses---which are the preferred readings---trigger
; the rule below, "I will meet you just after two", "I will meet you
; after any time on Tuesday" (once "time" is re-typed to be a
; temp_rel), "I will meet you just after next week" and so on.  Note
; that the rule also produces good_time for "I'll meet you after
; Stuttgart".  As things stand, "stuttgart" isn't coerced into
; a temporal interval or event in this construction.  The grammar
; would need to be changed if it were to do this.  But getting
; good-time predicated of the coerced variable would be the
; appropriate thing to do.  Given that coercion isn't encoded in the
; grammar, getting good-time predicated of Stuttgart itself is the
; next best possibility.  I could rule this out by putting a condition
; c^21 & temp_rel & [INST #x4] in the input and out below, but this
; won't work currently (25/9/98) because these rules don't reason
; about supertypes.
; 
; As with the previous rule, this rule could be generalised, by
; replacing _at_temp_rel with ^c30 & noninc_loc_temp_rel (so that the
; same rule covers "after <time-expression>" and "before
; <time-expression>".  
;
; As always, this rule doesn't handle negation.  We will need to add a
; condition to the input that there is no negation.  As it stands, it
; says good-time of "I will not meet you after two".


x_meet_y_after_t_rule := mrs_rule &
	[INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		_meet_someone_rel &
		[ HANDEL #h222,
		  EVENT  #e1,
		  ARG1    #x,
                  ARG3    #y ], 
		_after_prepx_rel &
		[ HANDEL #h223,
		  ARG #e1,
		  DIM #d6,
		  ARG3 #x4 ] !>,
	OUTPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		_meet_someone_rel &
		[ HANDEL #h222,
		  EVENT  #e1,
		  ARG1    #x,
                  ARG3    #y ], 
		_after_prepx_rel &
		[ HANDEL #h223,
		  ARG #e1,
		  DIM #d6,
		  ARG3 #x4 ],
		good_time_rel &
		[ HANDEL #h1,
		  INST #c ],
		alex_after_rel & 
		[ HANDEL #h4,
		  ARG  #c,
		  DIM  #d6,
		  ARG3 #x4 ] !> ].

; I PREFER <time-expression>
;--------------------------


; "I prefer afternoons" is a case where we must get good_time(c) and
; contrast(c,complement(c)) (where I assume the complement(c) is
; "mornings".   "I prefer afternoons to ten o'clock in the morning"
; should produce contrast(afternoons,10am).  So it's only a complement
; of the positive thing when there is an uninstantiated argument as to
; what the thing is that's not preferred.  We will need to do some
; rewriting rules which capture the reasoning that if
; contrast(c,comp(c)) holds, and beta attaches to alpha which gave
; good_time(t_alpha), then contrast(c,t_alpha \cap comp(c)) holds.  If
; t_alpha\cap c is nonempty, then we get contrast(t_alpha\cap c,
; t_\alpha\cap comp(c)).  If t_alpha\cap c is empty, then we must get
; contrast(c,t_alpha\cap comp(c)).  
;
; Note that this rule does not deal with negation, and would produce
; good_time for "I don't prefer afternoons".  However, the
; contrast rule I_prefer_t_contrast_rule below should 
; fire regardless of whether there is a
; negation there or not: "I don't prefer afternoons" should produce
; contrast(afternoon, comp(afternoons)) too.  This rule is generalised
; to fire when there is good_time, when there is bad_time, when there
; is good_place and when there is bad_place.

I_prefer_t_contrast_rule := mrs_rule &
		[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c21 &
		[ HANDEL #h1,
		  INST #c ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		_prefer_rel &
		[ HANDEL #h222,
		  EVENT  #e1,
		  ARG1    #x,
                  ARG3    #x4 ],
		alex_equals_rel & 
		[ HANDEL #h4,
		  ALEXARG1 #c,
		  ALEXARG2 #x4 ] !>,
		OUTPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c21 &
		[ HANDEL #h1,
		  INST #c ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		_prefer_rel &
		[ HANDEL #h222,
		  EVENT  #e1,
		  ARG1    #x,
                  ARG3   #x4 ],
		alex_equals_rel & 
		[ HANDEL #h4,
		  ALEXARG1 #c,
		  ALEXARG2 #x4 ],
		contrast_rel &
		[ HANDEL #h1,
		  INST	#c,
		  CONTRASTWITH #c1 ], 
		complement_of_rel &
		[ HANDEL #h1,
		  INST #c1,
		  COMPLEMENTED #c ] !> ].


I_prefer_t_good_time_rule := mrs_rule &
		[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		_prefer_rel &
		[ HANDEL #h222,
		  EVENT  #e1,
		  ARG1    #x,
                  ARG3    #x4 ] !>,
		OUTPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		^c20 &
		[ HANDEL #h221,
		  BV #x4,
		  RESTR #h3,
		  SCOPE #h4,
		  DIM #d5 ],
		_prefer_rel &
		[ HANDEL #h222,
		  EVENT  #e1,
		  ARG1    #x,
                  ARG3    #x4 ],
		good_time_rel & 
		[ HANDEL #h1,
		  INST #c ],
		alex_equals_rel & 
		[ HANDEL #h4,
		  ALEXARG1 #c,
		  ALEXARG2 #x4 ] !> ].

;;;;;;;;;;;;;;;;;

; TURNING "NO <TIME-EXPRESSION> IS GOOD" to "EVERY <TIME-EXPRESSION>
; IS NOT GOOD"
; ------------------------------------------------------------------

; For "No Monday is good", we need bad_time(c), and for every x such
; that Monday(x), for x to be contained in c (bad_time's truth
; conditions ensures that this is the minimal interval c that
; satisfies these conditions).  But there is no straightforward way
; with these re-write rules of keeping a no-quantifier with its
; restrictor and scope, and duplicating this structure, while
; replacing the no-quantifier with an every-quantifier, and replacing
; the bound variable x in the no-quantifier with a bound variable y in
; the every-quantifier.  So instead of doing this, I'm going to turn
; every sentence with "no" in it into an every-quantifier, where a
; negation has scope over the scope of the every-quantifier.  This
; will turn "No Monday is good" into "Every monday is not good" (under
; the reading where every has wide scope over negation).  It will turn
; "There is no Monday that is good" into "There is every Monday that
; is not good", and so on.
;
; This rule will not insert a good time or a bad time, that will be
; left to other re-write rules, which will be restricted to working
; with monotone quantifiers.  We have also restricted this re-writing
; of "no" to "every" to just those sentences that have "no
; <time-expression>", as opposed to "no <person>", for example.

no_to_every_rule := mrs_rule &
	[ INPUT.LISZT <! prpstn_rel &
			[ HANDEL #h1,
			  SOA #h2 ],
			_no_det_rel & 
			[ HANDEL #h3,
			  BV #x,
			  RESTR #h21,
			  SCOPE #h22,
			  DIM #d66 ]  !>,
	LCONDITIONS [ LISZT <! temp_rel &
			[ HANDEL #h212,
			  INST #x ] !> ,
		   H-CONS <! [ SC-ARG #h21, 
			  OUTSCPD #h212 ] !> ],
	  OUTPUT.LISZT <! prpstn_rel &
			[ HANDEL #h1,
			  SOA #h2 ],
			alex_every_q_rel & 
			[ HANDEL #h3,
			  BV #x,
			  RESTR #h21,
			  SCOPE handle & #h222,
			  DIM #d66 ],
			alex_neg_rel & 
			[ HANDEL #h222,
			  ARG #h22] !>].


;;;;;;;;;;;;;;;;;;

; REASONING ABOUT TIMES
; ---------------------

; Consider the parse for "I will meet you at two o'clock on Tuesday
; next week":
;
; pron(x5) /\ pron(x3) /\ prpstn(minute(x11, 00) /\ def(x7, numbered_hour(x7, d9, d10, 2, x11), def(x18, dofw(x18, TUE), def(x24, _next(x24, d31) /\ _week(x24, v26), temp_loc(e2, d23, x24) /\ _on_temp(e2, d17, x18), d30) /\ _meet_someone(e2, x3, x5) /\ _at_temp(e2, d6, x7), d22) /\ alex_equals(v20, x7), d15)) /\ good_time(v20)
;
; There is nothing in this MRS which specifies that x7 (two o'clock)
; is contained in x18 (Tuesday), which is contained in x24 (next
; week).  However, it should be possible to right the relevant rules
; that would `mimic' temporal reasoning, and would allow us to entail
; that x7 is contained in x18, which is contained in x24.  This is
; because temp_loc(e2,d23,x24) means "e2 is located at x24", and
; _on_temp(e2,d17,x18) also means this, and since x18 is a dofw, and
; x24 is a _week, this means that x18 is contained in x24.  Similarly
; for _at_temp(e2,d6,x7) and _on_temp(e2,d17,x18) ((and
; temp_loc(e2,d23,x24)).  Here is an attempt at these rules.  It
; should be possible to generalise these by substituting things like
; dofw for macros.
; 
; Also note that I have specified that the handel on the temporal
; inclusion relation is the same as the _on_temp_rel.  But this will
; sometimes produced invalid MRSs when it shouldn't.  This can be
; corrected when munging rules can deal with conditions on the
; relative scopes of handels.  We will have to replace #h222 in
; alex_temp_in_rel with #h223, and then specify that #h223 has
; narrower scope than the handels of both the quantifiers (which will
; have to be introduced into the input and output rules too).

numbered_hour_is_in_dofw := mrs_rule & 
	[ INPUT.LISZT <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		_at_temp_rel & 
		[ HANDEL #h220,
		  ARG #e2,
		  DIM #d6,
		  ARG3 #x7 ], 
		numbered_hour_rel &
		[ HANDEL #h221, 
		  INST #x7 ],
		dofw_rel & 
		[ HANDEL #h300,
		  INST #x18 ],
		_on_temp_rel &
		[ HANDEL #h222,
		  ARG #e2,
		  DIM #d17,
		  ARG3 #x18 ] !>,
	OUTPUT.LISZT 	 <! prpstn_rel &
		[ HANDEL #h1,
		  SOA #h22 ],
		_at_temp_rel & 
		[ HANDEL #h220,
		  ARG #e2,
		  DIM #d6,
		  ARG3 #x7 ], 
		numbered_hour_rel &
		[ HANDEL #h221, 
		  INST #x7 ],
		dofw_rel & 
		[ HANDEL #h300,
		  INST #x18 ],
		_on_temp_rel &
		[ HANDEL #h222,
		  ARG #e2,
		  DIM #d17,
		  ARG3 #x18 ],
		alex_temp_inc_rel & 
		[ HANDEL #h222,
		  ALEXARG1 #x7,
		  ALEXARG2 #x18 ] !> ].

