;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  roots.tdl
;;;

:begin :instance.

; The instances in this file, principally ROOT and FRAG, are needed by the 
; parser to know which phrase types to accept as successful parses of the full 
; input string.  They should be the only instances of phrase that fail to assign
; some other status  (e.g. 'rule or 'lex-entry), so they alone get to be of 
; status 'root-node (assigned on type sign), which is what the parser requires.
; This is obscure, but seems to work.

; ERB (13-11-96) Nifty trick: all clauses have a MESSAGE value, but only those
; that are actually functioning as the root of the sentence get to put that
; MESSAGE into the semantics.  All root clauses will therefore have an RLISZT
; consisting of their MESSAGE appended to their C-CONT.LISZT.  Similarly, 
; ROOT also introduces an RH-CONS which adds the relevant scope constraint to 
; the H-CONS attribute of the clause itself.

root := phrase & 
  [ SYNSEM [ LOCAL [ CAT [ ROOT +,
			   HEAD.MOOD ind_or_mod_subj & strict_mood,
			   VAL [ SUBJ < >,
				     SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE <! message & #msg & 
				     [ HANDEL #mhand,
				       SOA #soa ] !>,
			    LISZT *diff-list* &
				    [ LIST #list,
				      LAST #last ],
			    H-CONS *diff-list* &
				    [ LIST #sclist,
				      LAST #sclast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist,
				      LAST #hslast ],
			    TOP-H #mhand,
			    RLISZT *diff-list* &
				    [ LIST < #msg . #list >,
				      LAST #last ],
			    RH-CONS *diff-list* &
				    [ LIST 
				        < is-one-of &
					  [ SC-ARG #soa,
					    CANDS *diff-list* &
						  [ LIST < #hand . #hslist >,
						    LAST #hslast ] ] . #sclist >,
				      LAST #sclast ] ],
		     CONJ cnil ],
	     NON-LOCAL [ SLASH 0-dlist,
			 REL 0-dlist,
			 QUE 0-dlist ] ],
    C-CONT.TOP #hand ].

;; ECONT's TOP cannot be identified with C-CONT's TOP, given examples
;; like "perhaps in Berlin", where the ECONT.TOP is that of "in", but
;; the C-CONT.TOP must be that of "perhaps" which takes scope over "in".

frag := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ AUX -,
				  PRD +,
				  VFORM non_fin ],
			   ROOT na,
			   VAL [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ RLISZT *diff-list* &
				    [ LIST < message &
					     [ HANDEL #mhand,
					       SOA #soa ]
					     . < abstr_e_rel &
						 [ HANDEL #hand,
						   EVENT event ] . #first > >,
				      LAST #last ],
			    LISZT [ LIST #middle,
				    LAST #last ],
			    TOP-H #mhand,
			    RH-CONS *diff-list* &
				   [ LIST < is-one-of &
					    [ SC-ARG #soa,
					      CANDS *diff-list* &
						   [ LIST < #hand . #hslist >,
						     LAST #hslast ] ] 
					    . #hconslist >,
				     LAST #hconslast ],
			    H-CONS [ LIST #hconslist,
				     LAST #hconslast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist,
				      LAST #hslast ],
			    ECONT.LISZT [ LIST #first,
					  LASt #middle ],
			    MESSAGE <! !> ],
		     CONJ cnil ],
	     NON-LOCAL [ REL 0-dlist,
			 SLASH 0-dlist ] ] ].

; In VIT representation, don't want 'abstr_rel' if the only element in the
; turn is an exclamative (or a sequence of them).
frag-excl := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adv,
			   ROOT + ],
		     CONT [ RLISZT *diff-list* &
				    [ LIST #first,
				      LAST #last ],
			    LISZT [ LIST #middle,
				    LAST #last ],
			    KEY excl_rel,
			    RH-CONS [ LIST #hconslist,
				      LAST #hconslast ],
			    H-CONS [ LIST #hconslist,
				     LAST #hconslast ],
			    ECONT.LISZT [ LIST #first,
					  LASt #middle ],
			    MESSAGE <! !> ] ],
	     NON-LOCAL [ REL 0-dlist,
			 SLASH 0-dlist ] ] ].

frag-msg := sign &
  [ SYNSEM [ LOCAL [ CAT [ ROOT na,
			   HEAD root-marker,
			   VAL [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE <! relation & #msg &
				     [ HANDEL #mhand ] !>,
			    TOP-H #mhand,
			    KEY.RESTR #hand,
			    RLISZT *diff-list* &
				    [ LIST < #msg . < abstr_rel &
					              [ HANDEL #hand,
							ARG #arg & individual] 
						      . < abstr_3_rel &
							  [ HANDEL handle,
							    INST #index,
							    ARG3 #arg ]
							  . #first > > >,
				      LAST #last ],
			    LISZT *diff-list* &
				    [ LIST #middle,
				      LAST #last ],
			    RH-CONS #hclist,
			    H-CONS #hclist,
			    ECONT [ TOP #hand,
				      INDEX #index,
				      LISZT [ LIST #first,
					      LAST #middle ] ] ],
		     CONJ cnil ],
	     NON-LOCAL [ REL 0-dlist,
			 SLASH 0-dlist ] ],
    C-CONT.TOP #mhand ].

; Restrict to third singular subjectless finite VPs.

fin_frag := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
				[ INV -,
				  VFORM fin,
				  TENSE present,
				  MOOD ind_or_mod_subj ],
			   ROOT na,
			   VAL [ SUBJ < unexpressed &
					    [ LOCAL.CONT.INDEX #inst &
							[ PRONTYPE std_3 ] ] >,
				     SPR *olist*,
				     COMPS *olist* ] ],
		     AGR.PNG.PN 3sg,
		     CONT [ TOP #hand,
			    RLISZT *diff-list* &
				    [ LIST < prpstn_rel &
					     [ HANDEL #mhand,
					       SOA #soa ]
					     . < pron_rel &
						 [ HANDEL #mhand,
						   INST #inst &
						      [ PRONTYPE std_pron ] ]
						 . #first > >,
				      LAST #last ],
			    LISZT [ LIST #middle,
				    LAST #last ],
			    TOP-H #mhand,
			    RH-CONS *diff-list* &
				   [ LIST < is-one-of &
					    [ SC-ARG #soa,
					      CANDS *diff-list* &
						    [ LIST < #hand . #hslist >,
						      LAST #hslast ] ] 
					    . #hconslist >,
				     LAST #hconslast ],
			    H-CONS [ LIST #hconslist,
				     LAST #hconslast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist,
				      LAST #hslast ],
			    ECONT.LISZT [ LIST #first,
					  LASt #middle ],
			    MESSAGE <! !> ] ],
	     NON-LOCAL [ REL 0-dlist,
			 SLASH 0-dlist ] ] ].

coord-frag := phrase &
  [ SYNSEM [ LOCAL [ CAT.HEAD n_or_p,
		     CONJ complex-conj &
			[ CHEAD [ LEFT < cnil, ... >,
				  RELTN #rel & [ HANDEL #chand,
						 C-ARG #ind,
						 C-HANDELS #hands,
						 C-INDICES #inds ] ],
			  HANDELS #hands,
			  INDICES #inds ],
		     CONT [ TOP-H #chand,
			    INDEX #ind,
			    LISZT [ LIST #list,
				    LAST #last ],
			    RLISZT *diff-list* &
				  [ LIST < #rel . #list >,
				    LAST #last ] ] ],
	     NON-LOCAL [ SLASH 0-dlist,
			 REL 0-dlist,
			 QUE 0-dlist ] ] ].

:end :instance.

