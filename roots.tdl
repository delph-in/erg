;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2005
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see LICENSE for conditions
;;;
;;;  roots.tdl
;;;

; The instances in this file are needed by the parser to know which phrase 
; types to accept as successful parses of the full input string.

; Recommended for generation
root_strict := phrase &
  [ INFLECTD +,
    SYNSEM root_synsem &
             [ LOCAL.CAT.HEAD verb,
               PUNCT.RPUNCT basic_clause_punct ],
    GENRE edited,
    DIALECT us ].

; Recommended for parsing, unless domain is all edited text
root_informal := phrase &
  [ INFLECTD +,
    SYNSEM root_synsem,
    GENRE standard ].

root_robust := phrase &
  [ INFLECTD +,
    SYNSEM basic_root_synsem &
             [ LOCAL [ CAT [ HEAD verb_or_frag & 
				  [ MOD *anti_list*,
				    VFORM fin_or_bse_or_imp ],
			     MC na_or_+ ],
                       CONJ cnil_or_lexconj ] ],
    GENRE robust ].

; robust sentences only
root_robust_s := phrase &
  [ INFLECTD +,
    SYNSEM basic_root_synsem &
             [ LOCAL [ CAT [ HEAD verb & 
				  [ MOD *anti_list* ],
			     VAL.SUBJ *anti_list*,
			     MC na_or_+ ],
                       CONJ cnil ],
	       PUNCT.RPUNCT clause_or_pair_or_no_punct ],
    GENRE robust,
    DIALECT us ].

root_formal := phrase &
  [ INFLECTD +,
    SYNSEM root_synsem &
             [ LOCAL.CAT.HEAD verb,
               PUNCT.RPUNCT basic_clause_punct ],
    GENRE formal,
    DIALECT us ].

; For robust spoken language phenomena, like sentence final |and|
root_spoken := phrase &
  [ INFLECTD +,
    SYNSEM basic_root_synsem &
             [ LOCAL [ CAT [ HEAD verb & [ VFORM fin_or_imp ],
			     MC + ],
                       CONJ cnil_or_lexconj ] ],
    GENRE spoken ].

root_spoken_frag := phrase &
  [ INFLECTD +,
    SYNSEM basic_root_synsem &
             [ LOCAL [ CAT [ HEAD frag,
			     MC + ],
                       CONJ cnil_or_lexconj ] ],
    GENRE spoken ].


#|
root_frag := sign &
  [ SYNSEM synsem &
	   [ LOCAL [ CAT [ HEAD conj_or_frag,
                           VAL.COMPS *olist*,
                           MC na_or_+ ],
                     CONJ cnil_or_lexconj,
                     CONT.HOOK.INDEX.SF #pred ],
             NONLOC.SLASH 0-dlist & [ LIST < > ],
             PUNCT.RPUNCT clause_or_no_punct & [ PSF #pred ] ],
    GENRE formal,
    DIALECT us ].
|#

; Informal fragments
root_inffrag := sign &
  [ SYNSEM root_frag_synsem,
    GENRE standard ].

; For well-formed fragments in formal genre
root_frag := sign &
  [ SYNSEM root_frag_synsem &
	   [ PUNCT.RPUNCT clause_or_no_punct ],
    GENRE formal,
    DIALECT us ].

; Used to determine on which candidate root edges to not apply the idiom checks
; (for efficiency)
root_non_idiom := sign &
  [ IDIOM - ].

;;; The following four are used for `fragmented' (in the LOGON sense) input 
;;; for generator

root_phr := sign &
  [ SYNSEM phr_synsem &
	   [ LOCAL [ CAT [ HEAD [ INV -,
                                  TAM.MOOD indicative,
                                  MINORS.MIN norm_rel ],
			   VAL [ COMPS < >,
                                 SPR *olist* ] ],
		     CONJ cnil ],
             NONLOC [ SLASH 0-dlist & [ LIST < > ],
			 REL 0-dlist & [ LIST < > ] ],
             LEX -,
             PUNCT no_punctuation ],
    INFLECTD + ].

root_lex := sign &
  [ SYNSEM [ LEX +,
             LOCAL [ CAT.HEAD non_frag &
			      [ AUX na ],
                     CONJ cnil ],
             PUNCT.RPUNCT clause_or_no_punct ],
    INFLECTD + ].

; DPF 09-Jan-00 - Removed MSG message from root_conj, to admit eg "or on 
; Tuesday"

root_conj := sign &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
		     CONJ lex-conj ],
             NONLOC [ SLASH 0-dlist & [ LIST < > ],
			 REL 0-dlist & [ LIST < > ] ],
             PUNCT no_punctuation ],
    INFLECTD + ].

root_subord := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD prep,
			   VAL.COMPS < > ],
		     CONJ cnil ],
             NONLOC [ SLASH 0-dlist & [ LIST < > ],
                      REL 0-dlist & [ LIST < > ] ],
             PUNCT no_punctuation ],
    INFLECTD + ].

; Exclude imperatives and questions (e.g. for grammar checking)

root_decl := phrase &
  [ INFLECTD +,
    SYNSEM root_synsem &
	     [ LOCAL.CONT.HOOK.INDEX.SF prop ],
    GENRE standard,
    DIALECT us ].

root_standard := phrase &
  [ INFLECTD +,
    SYNSEM root_synsem,
    GENRE standard,
    DIALECT us ].

root_question := phrase &
  [ INFLECTD +,
    SYNSEM root_synsem &
	     [ LOCAL.CONT.HOOK.INDEX.SF ques ],
    DIALECT us ].

