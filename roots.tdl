;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  roots.tdl
;;;

:begin :instance.

; The instances ROOT and FRAG are needed by the parser to know which phrase 
; types to accept as successful parses of the full input string.  They should 
; be the only instances of phrase that fail to assign some other status 
; (e.g. 'rule or 'lex-entry), so they alone get to be of status 'root-node 
; (assigned on type sign), which is what the parser requires.  This is obscure,
; but seems to work.

; ERB (13-11-96) Nifty trick: all clauses have a MESSAGE value, but only those
; that are actually functioning as the root of the sentence get to put that
; MESSAGE into the semantics.  All root clauses will therefore have an RLISZT
; consisting of their MESSAGE appended to their C-CONT.LISZT.  Similarly, 
; ROOT also introduces an RH-CONS which adds the relevant scope constraint to 
; the H-CONS attribute of the clause itself.

root := phrase & 
  [ SYNSEM [ LOCAL [ CAT [ ROOT +,
			   HEAD.MOOD ind_or_mod_subj & strict_mood,
			   VALENCE [ SUBJ < >,
				     SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE message & #mes & 
				    [ HANDEL #mhand,
				      SOA #soa ],
			    LISZT *diff-list* &
				    [ LIST #list,
				      LAST #last ],
			    H-CONS *diff-list* &
				    [ LIST #sclist,
				      LAST #sclast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist ],
			    TOP-H #mhand,
			    RLISZT *diff-list* &
				    [ LIST < #mes . #list >,
				      LAST #last ],
			    RH-CONS *diff-list* &
				    [ LIST 
				    < is-one-of &
				    [ SC-ARG #soa,
				      CANDS < #hand . #hslist > ] . #sclist >,
				     LAST #sclast ] ],
		     CONJ cnil ],
	     NON-LOCAL [ SLASH <! !>,
			 REL <! !>,
			 QUE <! !> ] ],
    C-CONT.TOP #hand ].

;; ECONT's TOP cannot be identified with C-CONT's TOP, given examples
;; like "perhaps in Berlin", where the ECONT.TOP is that of "in", but
;; the C-CONT.TOP must be that of "perhaps" which takes scope over "in".

frag := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ INV -,
				  PRD +,
				  VFORM non_fin ],
			   ROOT na,
			   VALENCE [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ RLISZT *diff-list* &
				    [ LIST < message &
					     [ HANDEL #mhand,
					       SOA #soa ]
					     . < abstr_e_rel &
						 [ HANDEL #hand,
						   EVENT event ] . #first > >,
				      LAST #last ],
			    LISZT [ LIST #middle,
				    LAST #last ],
			    TOP-H #mhand,
			    RH-CONS *diff-list* &
				   [ LIST < is-one-of &
					    [ SC-ARG #soa,
					      CANDS < #hand . #hslist > ] 
					    . #hconslist >,
				     LAST #hconslast ],
			    H-CONS [ LIST #hconslist,
				     LAST #hconslast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist ],
			    ECONT.LISZT [ LIST #first,
					    LASt #middle ],
			    MESSAGE no_rel ] ],
	     NON-LOCAL [ REL <! !>,
			 SLASH <! !> ] ] ].

; In VIT representation, don't want 'abstr_rel' if the only element in the
; turn is an exclamative (or a sequence of them).
frag-excl := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adv,
			   ROOT + ],
		     CONT [ RLISZT *diff-list* &
				    [ LIST #first,
				      LAST #last ],
			    LISZT [ LIST #middle,
				    LAST #last ],
			    KEY excl_rel,
			    RH-CONS [ LIST #hconslist,
				      LAST #hconslast ],
			    H-CONS [ LIST #hconslist,
				     LAST #hconslast ],
			    ECONT.LISZT [ LIST #first,
					  LASt #middle ],
			    MESSAGE no_rel ] ],
	     NON-LOCAL [ REL <! !>,
			 SLASH <! !> ] ] ].

frag-msg := sign &
  [ SYNSEM [ LOCAL [ CAT [ ROOT na,
			   HEAD root-marker,
			   VALENCE [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE relation & #msg &
				    [ HANDEL #mhand ],
			    TOP-H #mhand,
			    KEY.RESTR #hand,
			    RLISZT *diff-list* &
				    [ LIST < #msg . < abstr_rel &
					              [ HANDEL #hand,
							ARG #arg & individual] 
						      . < abstr_3_rel &
							  [ HANDEL handle,
							    INST #index,
							    ARG3 #arg ]
							  . #first > > >,
				      LAST #last ],
			    LISZT *diff-list* &
				    [ LIST #middle,
				      LAST #last ],
			    RH-CONS #hclist,
			    H-CONS #hclist,
			    ECONT [ TOP #hand,
				      INDEX #index,
				      LISZT [ LIST #first,
					      LAST #middle ] ] ],
		     CONJ cnil ],
	     NON-LOCAL [ REL <! !>,
			 SLASH <! !> ] ],
    C-CONT.TOP #mhand ].

; Restrict to third singular subjectless finite VPs.

fin_frag := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ INV -,
				  VFORM fin,
				  TENSE present,
				  MOOD ind_or_mod_subj ],
			   ROOT na,
			   VALENCE [ SUBJ < unexpressed &
					    [ LOCAL.CONT.INDEX #inst &
							[ PRONTYPE std_3 ] ] >,
				     SPR *olist*,
				     COMPS *olist* ] ],
		     AGR.PNG.PN 3sg,
		     CONT [ TOP #hand,
			    RLISZT *diff-list* &
				    [ LIST < prpstn_rel &
					     [ HANDEL #mhand,
					       SOA #soa ]
					     . < pron_rel &
						 [ HANDEL #mhand,
						   INST #inst &
						      [ PRONTYPE std_pron ] ]
						 . #first > >,
				      LAST #last ],
			    LISZT [ LIST #middle,
				    LAST #last ],
			    TOP-H #mhand,
			    RH-CONS *diff-list* &
				   [ LIST < is-one-of &
					    [ SC-ARG #soa,
					      CANDS < #hand . #hslist > ] 
					    . #hconslist >,
				     LAST #hconslast ],
			    H-CONS [ LIST #hconslist,
				     LAST #hconslast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist ],
			    ECONT.LISZT [ LIST #first,
					    LASt #middle ],
			    MESSAGE no_rel ] ],
	     NON-LOCAL [ REL <! !>,
			 SLASH <! !> ] ] ].

:end :instance.