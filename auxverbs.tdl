;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-1999
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  auxverbs.tdl
;;;
;;;  The auxiliary verb system for English
;;;
;;;  Created: Rob Malouf, 17-Nov-1994
;;;
;;;  $Id$

will_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin,
                                PRD -,
                                TAM ind_or_mod_subj_tam ],
                         VAL [ SUBJ < synsem & 
				      [ LOCAL [ CAT nomp_cat_nom_min,
						CONT.MSG no_msg,
						CONJ cnil ] ] >,
			       COMPS.FIRST.--SEMIND #event ] ],
                   CONT psoa & [ HOOK.INDEX #event ] ] ].

will_aux_pos_lex_e := will_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #hand ] >,
                   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

va_will_pos_le := will_aux_pos_lex_e &
 [ SYNSEM.LOCAL.CAT [ HEAD.TAM [ TENSE future,
                                 MOOD indicative ],
                      VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].
                        
va_will_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word &
 [ SYNSEM.LOCAL.CAT [ HEAD.TAM [ TENSE future,
                                 MOOD indicative ],
                      VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].

va_will_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM [ TENSE future,
                                      MOOD indicative ],
                           VAL.COMPS.FIRST.LOCAL [ CAT vp_bse_cat,
                                                   CONT.HOOK.LTOP #chand ] ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! [ LBL #ltop,
                                      PRED neg_rel,
                                      ARG1 #arghand ] !>,
                            HCONS <! qeq & [ HARG #arghand,
                                             LARG #chand ] !> ] ] ] ].

va_would_pos_le := will_aux_pos_lex_e & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE future,
                                MOOD modal_subj ] ].

va_would_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE future,
                                MOOD modal_subj ] ].

va_would_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM [ TENSE future,
                                      MOOD modal_subj ],
			   VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #chand ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! [ LBL #ltop,
                                      PRED neg_rel,
                                      ARG1 #arghand ] !>,
                            HCONS <! qeq & [ HARG #arghand,
                                             LARG #chand ] !> ] ] ] ].

va_would_like_pos_le := will_aux_pos_lex_e & 
  [ SYNSEM [ LOCAL.CAT.HEAD.TAM [ TENSE present,
                                  MOOD modal_subj ],
             LKEYS.--COMPKEY would_like_rel ] ].

va_would_like_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word & 
  [ SYNSEM [ LOCAL.CAT.HEAD.TAM [ TENSE present,
                                  MOOD modal_subj ],
             LKEYS.--COMPKEY would_like_rel ] ].                   

va_would_like_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM [ TENSE present,
                                      MOOD modal_subj ],
			   VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.KEYS.KEY 
                                                             would_like_rel,
                                                   CONT.HOOK.LTOP #chand ] ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! [ LBL #ltop,
                                      PRED neg_rel,
                                      ARG1 #arghand ] !>,
                            HCONS <! qeq & [ HARG #arghand,
                                             LARG #chand ] !> ] ] ] ].

;;; Modal verbs

modal_pos_lex_ent := pos_modal_verb_word & add_cont &
  [ SYNSEM.LKEYS.KEYREL.PRED modal_rel ].

va_modal_pos_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE present,
                                MOOD indicative ] ].

va_modal_pos_noninv_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD [ TAM [ TENSE present,
                                  MOOD indicative ],
                            INV - ] ].

va_modal_pos_cx_le := modal_pos_lex_ent & contracted_aux_word.

modal_subj_pos_lex_ent := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE present,
                                MOOD modal_subj ] ].

va_modal_subj_pos_le :< modal_subj_pos_lex_ent.

modal_subj_pos_cx_le := modal_subj_pos_lex_ent & contracted_aux_word.

; 'could' - underspecified for sense (modal_subj or indicative-past)
va_modal_pos_unsp_le :< modal_pos_lex_ent.

va_ought_pos_le := pos_ought_verb_word & add_cont &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

va_past_ought_pos_le := past_ought_verb_word & add_cont &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE past ].

va_quasimodal_le := quasimodal_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp, 
                            PRD +,
                            TAM.TENSE future ] ].

va_quasimodal_psp_le := quasimodal_psp_word.

va_quasimodal_bse_le := quasimodal_bse_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp, 
                            PRD +,
                            TAM.TENSE future ] ].

generic_modal_neg_super := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.LTOP #chand,
		     CONT [ HOOK.LTOP #ltop,
                            RELS <! [ LBL #ltop,
                                      PRED neg_rel,
                                      ARG1 #narghand ], 
                                  #key !>,
			    HCONS <! qeq &
				  [ HARG #arghand,
				    LARG #chand ],
				    qeq &
				  [ HARG #narghand,
				    LARG #khand ] !> ] ],
             LKEYS.KEYREL #key &
                   [ LBL #khand,
                     PRED modal_rel,
                     ARG1 #arghand ] ] ].

generic_modal_neg := generic_modal_neg_super & aux_verb_word &
  [ SYNSEM.LKEYS.KEYREL.WLINK *cons* ].

va_modal_neg_le := modal_verb_word & generic_modal_neg &
  [ SYNSEM [ LOCAL.CAT.HEAD.TAM.TENSE present,
             LKEYS.KEYREL.PRED modal_rel ] ].

va_modal_subj_neg_le := modal_verb_word & generic_modal_neg & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE present,
                                MOOD modal_subj ] ].
; "couldn't"
va_modal_neg_unsp_le := modal_verb_word & generic_modal_neg.

va_ought_neg_le := ought_verb_word & generic_modal_neg_super &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

; *** Auxiliary DO ***

; For tag questions we need the KEY of auxiliary _do_ to match all main verbs.
; The supertype for this is v_event_rel.  Originally, it had been no_rel, to 
; block _do_'s being a complement of other auxiliaries.  On the hypothesis
; that auxiliary _do_ in fact lacks a non-finite form all together, the
; do_aux_word type is constrained to VFORM fin.

do_aux_word := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTED +,
    SYNSEM ssr_two_arg_verb &
           [ LOCAL [ CAT [ HEAD [ AUX +,
                                  TAM [ TENSE #tense,
                                        ASPECT #aspect,
                                        MOOD indicative ],
                                  VOICE active,
                                  KEYS.KEY #key & nonaux_event_rel ],
                           VAL [ SUBJ < synsem & 
                                        [ OPT -,
                                          LOCAL [ CAT nomp_cat_nom_min,
                                                  CONT.MSG no_msg,
                                                  CONJ cnil ] ] >,
                                 COMPS < synsem &
                                         [ LOCAL [ CAT vp_bse_unspec_cat &
                                                       [ HEAD 
                                                          [ AUX -,
                                                            KEYS.KEY #key ] ],
                                                   CONT.HOOK [ LTOP #cltop,
                                                               INDEX #index ],
                                                   CONJ cnil ],
                                           OPT - ] > ],
                           POSTHEAD + ],
                     CONT psoa & [ HOOK.INDEX #index & 
                                              [ E [ TENSE #tense,
                                                    ASPECT #aspect,
                                                    MOOD indicative ] ] ] ],
             LKEYS.KEYREL [ LBL #cltop,
                            PRED mod_role_rel,
                            ARG0 #index ] ] ].

; Removed raise-cont from parents, to allow ARG0 to not be identified with the
; comp-dtr's ARG0   - is in conflict with collapsing of base and fin-non3rdsg 
; forms, given that we encode VIT attributes in the event feature structure.
; Sample problem: "Kim does sleep"

; DPF 6-Feb-02 - Changed MOOD indicative to indicative* in order to support
; coordination of e.g. yes-no questions and modal_subj declaratives.  Same in
; type do_aux_neg_pres.
; DPF 13-Mar-02 - But this allowed "want" version of "like" to be complement.
; So instead make do_aux_word stamp indicative* for its own MOOD, and not
; copy it up from complement dtr.  Then require complement dtr to be simply
; MOOD indicative.  And by the way broke link from "do" to bse_aux_verb_word
; which insists on making the aux verb's TAM identical to its INDEX, which we
; can't have for "do".

do_fin := do_aux_word & raise_cont & 
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin,
				PRD - ],
			 VAL [ SUBJ < [ OPT - ] >,
			       COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #hand ] ],
                   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

do_aux_neg_word := do_aux_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ PRD -,
                                  VFORM fin ],
                           VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #chand ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! [ LBL #ltop,
                                      PRED neg_rel,
                                      ARG1 #arghand ] !>,
                            HCONS <! qeq &
                                   [ HARG #arghand,
                                     LARG #chand ] !> ] ] ] ].

do_pres := do_fin &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM ind_or_mod_subj_tam &
                                  [ TENSE present,
                                    ASPECT no_aspect ],
                         VAL.SUBJ < [ --SEMIND.PNG #png ] > ],
                   AGR.PNG #png ] ].

va_does_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SEMIND.PNG png & [ PN 3sg ] ] > ].

va_do_fin_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ 
			     < [ --SEMIND.PNG png & [ PN non3sg ] ] > ].

va_did_le := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM past_or_subj_tam ].

do_aux_neg_pres := do_aux_neg_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE present,
				ASPECT no_aspect ] ].

va_do_neg_past_le := do_aux_neg_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM past_or_subj_tam ].

; ERB (31-03-97) The agreement on do, but not have and be, was previously
; taken care of in lexicon.tdl.  I am making these types to move that
; information here for symmetry.  The rest of the do paradigm seems
; to be generated by lexical rules, so these two are the only types.

va_doesnt_neg_pres_le := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

va_dont_neg_pres_le := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg ] ].

; *** Perfect HAVE ***

have_aux_word := psp_aux_verb_word & 
  [ SYNSEM [ LOCAL.CAT.HEAD.TAM.ASPECT.PERF +,
             LKEYS.KEYREL.PRED have_aux_rel ] ].

have_aux_pos_lex_entry := have_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                       INDEX #index ] ] >,
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index ],
			  RELS <! !>,
			  HCONS <! !> ] ] ].

have_aux_neg_lex_entry := have_aux_word &
  [ SYNSEM lex_synsem &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD - ],
			   POSTHEAD +,
			   VAL [ SUBJ < [ OPT - ] >,
				 COMPS.FIRST
				      [ LOCAL.CONT.HOOK [ LTOP #chand,
                                                          INDEX #vind ] ] ] ],
		     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #vind ],
			    RELS <! [ LBL #ltop,
                                      PRED neg_rel,
                                      ARG1 #arghand ] !>,
			    HCONS <! qeq &
				    [ HARG #arghand,
				      LARG #chand ] !> ] ] ] ].

have_fin := have_aux_word &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin,
				PRD - ],
			 POSTHEAD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      CONT.MSG no_msg,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

have_pres := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE present,
				ASPECT.PERF +,
				MOOD indicative ] ].

have_past := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE past,
				ASPECT.PERF +,
				MOOD indicative ] ].

have_subj := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ ASPECT.PERF +,
				MOOD subjunctive ] ].

;; We make "having" be [PRD -] to block "Kim is having fallen" and (the
;; restrictive reading of) "The book having fallen is red".  We will also 
;; exclude possibly grammatical examples like "anyone having seen that movie ..."
;; but there are no attested instances of these in the full BNC.

va_have_prespart_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp,
                            PRD - ] ].

va_have_bse_lexent := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
                                VFORM bse_only,
                                TAM.ASPECT.PERF + ],
                         VAL.SUBJ < unexpressed > ],
		   CONT psoa ] ].

va_have_bse_le :< va_have_bse_lexent.
va_have_bse_cx_le := va_have_bse_lexent & contracted_aux_word.

has_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ --SEMIND.PNG png & [ PN 3sg ] ] > ].

va_has_le :< has_aux_lex_ent.

va_has_cx_le := has_aux_lex_ent & contracted_aux_word.

have_fin_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg ] ].

va_have_fin_le :< have_fin_aux_lex_ent.

va_have_fin_cx_le := have_fin_aux_lex_ent & contracted_aux_word.

had_aux_lex_ent := have_aux_pos_lex_entry & have_past.

va_had_subj_le := have_aux_pos_lex_entry & have_subj.

va_had_le :< had_aux_lex_ent.

va_had_cx_le := had_aux_lex_ent & contracted_aux_word.

va_has_neg_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

va_have_fin_neg_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg ] ].

va_had_neg_le := have_aux_neg_lex_entry & have_past.

va_had_subj_neg_le := have_aux_neg_lex_entry & have_subj.

; *** Generic BE ***

be_verb := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTED +,
    SYNSEM.LOCAL.CAT [ HEAD.AUX +,
		       VAL [ SUBJ < synsem_min & 
				    [ LOCAL [ CAT nomp_cat_min,
					      CONJ cnil ] ] >,
			     COMPS < synsem & [ OPT - ], ... > ] ] ].

; DPF 20-Oct-01 - Changed [TAM.ASPECT strict_nonprf] to nonprf, since it was
; blocking coordination of "Kim has arrived and Sandy is happy".  This change
; now allows "Kim is being hiring Browne" but we can live with it for now.

be_fin := be_verb &
  [ SYNSEM.LOCAL non_perf &
		 [ CAT [ HEAD [ VFORM fin,
				PRD -,
				TAM.ASPECT.PERF - ],
			 POSTHEAD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

be_pres := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE present,
				MOOD indicative ] ].

be_past := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE past,
				MOOD indicative ] ].
be_subj := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; Make be_prespart unmarked for PRD so we can block the identity-copula reading
; for "Kim is being good" while allowing the predicative-copula reading.
; 20-Oct-01 - Added POSTHEAD + to block pre-noun modification as in "*the being
; Kim person arrived"
; Added SLASH 0-dlist to avoid endless recursion when generating, since we no
; longer block "Kim is being silly", and don't want to use VFORM to block
; "Kim is being arriving" since that would put VFORM on type subst (too high),
; even though we'd like to exclude this example.  So we add COMPS..AUX - to
; prevent "*Kim is being being silly", which avoids the worst case.

be_prespart := be_verb &
  [ SYNSEM [ LOCAL.CAT [ HEAD.VFORM prp,
                         VAL.COMPS < [ LOCAL.CAT.HEAD.AUX - ] >,
                         POSTHEAD + ],
             NON-LOCAL.SLASH 0-dlist ] ].

be_pastpart := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM psp,
                                TAM.ASPECT.PERF +,
                                PRD - ],
                         VAL.COMPS < [ LOCAL.CAT.HEAD.AUX - ] >,
                         POSTHEAD + ],
		   CONT psoa ] ]. 
be_neg := sign &
  [ INFLECTED +,
    SYNSEM lex_synsem &
	   [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          HCONS <! qeq &
                                 [ HARG #arghand,
                                   LARG #khand ] !> ],
             LKEYS [ KEYREL.LBL #khand,
                     ALTKEYREL [ LBL #ltop,
                                 PRED neg_rel,
                                 ARG1 #arghand ] ] ] ].

be_be_lex_entry := be_verb & 
  [ STEM < "be" >,
    SYNSEM.LOCAL.CAT [ HEAD [ PRD -,
                              VFORM bse,
                              TAM.ASPECT.PERF - ],
                       VAL.SUBJ < unexpressed & [ OPT - ] > ] ].

be_being_lex_entry := be_prespart & 
  [ STEM < "being" > ].

be_been_lex_entry := be_pastpart & 
  [ STEM < "been" > ].

be_pres_lex_entry := be_pres.

be_past_lex_entry := be_past.

be_subj_lex_entry := be_subj.

be_pres_neg_lex_entry := be_pres & be_neg.
be_past_neg_lex_entry := be_past & be_neg.
be_subj_neg_lex_entry := be_subj & be_neg.

be_am_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg ] ].

be_is_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg ] ].

be_was_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg ] ].

be_were_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg ] ].

be_was_subjnct_lex_entry := be_subj_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg ] ].

be_were_subjnct_lex_entry :< be_subj_lex_entry.

be_am_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.INV +,
                   AGR.PNG png & [ PN 1sg ] ] ].

be_is_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg ] ].

be_was_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg ] ].

be_was_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg ] ].

be_were_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg ] ].

be_were_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; *** Copula BE ***

; DPF 27-Nov-99 - Made KEY.LBL identified with COMPS..KEY.LBL,
; to avoid assymetry of LBL and WLINK for VM, which was causing errors
; for e.g. "it is really going to be".  This used to lose a possible ambiguity
; for e.g. "kim is not sleeping", since the support_rel will always be in
; the scope of the negation, regardless of whether the "not" attaches to
; "be" or to the complement phrase.  
; DPF 01-Mar-00 - But now that we've eliminated support_rels, it may work ok.

be_copula := prd_aux_verb_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.TAM #tam,
			 VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.TAM #tam,
                                                 CONT.HOOK.LTOP #hand ] ],
             LKEYS.KEYREL [ LBL #hand,
                            PRED _be_prd_rel ] ] ].

be_cop_pos_generic := be_copula &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		   CONT [ HOOK.LTOP #ltop,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

be_cop_pos := be_cop_pos_generic &
 [ SYNSEM.LOCAL non_perf ].

be_cop_neg := be_copula &
  [ SYNSEM [ LOCAL non_perf &
                   [ CONT [ HOOK.LTOP #ltop,
                            RELS <! #altkey !> ] ],
             LKEYS.ALTKEYREL #altkey & [ LBL #ltop ] ] ].

vc_prd_be_le := be_be_lex_entry & be_cop_pos_generic &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.AUX - ] > ].

vc_prd_being_le := be_being_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD +,
                            TAM.ASPECT.PROGR + ] ].

vc_prd_been_le := be_been_lex_entry & be_cop_pos_generic.
vc_prd_am_le := be_am_lex_entry & be_cop_pos.
vc_prd_am_cx_le := be_am_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_is_le := be_is_lex_entry & be_cop_pos.
vc_prd_is_cx_le := be_is_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_are_le := be_are_lex_entry & be_cop_pos.
vc_prd_are_cx_le := be_are_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_was_le := be_was_lex_entry & be_cop_pos.
vc_prd_was_subj_le := be_was_subjnct_lex_entry & be_cop_pos.
vc_prd_were_le := be_were_lex_entry & be_cop_pos.
vc_prd_were_subj_le := be_were_subjnct_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg ] ].

vc_prd_am_neg_le := be_am_neg_contr_lex_entry & be_cop_neg.
vc_prd_is_neg_le := be_is_neg_contr_lex_entry & be_cop_neg.
vc_prd_are_neg_le := be_are_neg_contr_lex_entry & be_cop_neg.
vc_prd_was_neg_le := be_was_neg_contr_lex_entry & be_cop_neg.
vc_prd_was_neg_subj_le := be_was_subjnct_neg_contr_lex_entry & be_cop_neg.
vc_prd_were_neg_le := be_were_neg_contr_lex_entry & be_cop_neg.
vc_prd_were_neg_subj_le := be_were_subjnct_neg_contr_lex_entry & be_cop_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg ] ].

; *** Identity BE ***
; For now, exclude gerundive complements, to avoid semantically anomalous
; reading for "Kim is sleeping"
; DPF 08-Jan-00 Made COMP be nom_rel instead of reg_nom_rel, to allow "Tuesday
; is my last day" and "that's him".
; DPF 22-Feb-01 - Added ALTKEY restriction on SUBJ to prevent free relatives
; from appearing in subject position, to get the contrast of "I admire what
; you are" vs. "*I admire what are you" (and cf. "I admire what is best").
; DPF 26-Aug-01 - Added KEY nom_rel to SUBJ, like for COMP, to avoid having
; measure_nps in subject position.
; DPF 19-Oct-02 - Removed identification of PRONTYPE on SUBJ and COMP, since
; this blocks "it is I/me" "that's me" etc.
; DPF 27-Apr-03 - Removed [COMPS..PRD -] since this prevents 'today is December
; third', and it's not clear what it was blocking.  (Nor is it clear why
; 'third' has to be [PRD +].)
; DPF 10-Jun-03 - Try identifying SORT values of subj and comp.
; DPF 5-Sep-03 - Don't understand comment of 22-Feb-02 above, but clearly
; free relatives can be subjects of identity copula: "What he does is your
; problem".  So removed this constraint.

id_cop_verb := aux_verb & two_arg_subst & basic_two_arg &
  [ LOCAL [ CAT [ HEAD.TAM.ASPECT.PROGR -,
                  VAL [ SUBJ < [ LOCAL.CAT.HEAD.KEYS.KEY nom_rel,
                                 --SEMIND #id1ind & ref-ind &
                                       [ PRONTYPE real_pron,
                                         SORT #sort ],
                                 NON-LOCAL non-local_norel ] >,
                        COMPS < [ LOCAL [ CAT nomp_cat_min & 
                                              [ HEAD [ MOD < >,
                                                       KEYS.KEY nom_rel ] ],
                                          CONJ cnil ],
                                  --SEMIND #id2ind & ref-ind &
                                        [ PRONTYPE real_pron,
                                          SORT #sort ],
                                  NON-LOCAL non-local_norel ] > ] ],
            CONT.HOOK.XARG #id1ind ],
    LKEYS.KEYREL arg12_relation &
                 [ PRED _cop_id_rel,
                   ARG1 #id1ind,
                   ARG2 #id2ind,
                   WLINK *cons* ] ].

be_id := be_verb &
  [ SYNSEM id_cop_verb &
	   [ LOCAL.CONT [ HOOK.INDEX #event,
			  RELS.LIST.FIRST.ARG0 #event ] ] ].

be_id_pos := be_id &
  [ SYNSEM [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! #key !>,
			  HCONS <! !> ],
             LKEYS.KEYREL #key & [ LBL #ltop ] ] ].

be_id_neg_synsem :< id_cop_verb.

be_id_neg := be_id &
  [ SYNSEM be_id_neg_synsem & 
	   [ LOCAL.CONT.RELS <! #key, #altkey !>,
             LKEYS [ KEYREL #key,
                     ALTKEYREL #altkey ] ] ].

vc_id_be_le := be_be_lex_entry & be_id &
  [ SYNSEM [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! #key !>,
			  HCONS <! !> ],
             LKEYS.KEYREL #key & [ LBL #ltop ] ] ].

vc_id_being_le := be_being_lex_entry & be_id_pos.
vc_id_been_le := be_been_lex_entry & be_id_pos.
vc_id_am_le := be_am_lex_entry & be_id_pos.
vc_id_am_cx_le := be_am_lex_entry & be_id_pos & contracted_aux_word.
vc_id_is_le := be_is_lex_entry & be_id_pos.
vc_id_is_cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word.
vc_id_are_le := be_are_lex_entry & be_id_pos.
vc_id_are_cx_le := be_are_lex_entry & be_id_pos & contracted_aux_word.
vc_id_was_le := be_was_lex_entry & be_id_pos.
vc_id_was_subj_le := be_was_subjnct_lex_entry & be_id_pos.
vc_id_were_le := be_were_lex_entry & be_id_pos.
vc_id_were_subj_le := be_were_subjnct_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg ] ].

vc_id_am_neg_le := be_am_neg_contr_lex_entry & be_id_neg.
vc_id_is_neg_le := be_is_neg_contr_lex_entry & be_id_neg.
vc_id_are_neg_le := be_are_neg_contr_lex_entry & be_id_neg.
vc_id_was_neg_le := be_was_neg_contr_lex_entry & be_id_neg.
vc_id_was_neg_subj_le := be_was_subjnct_neg_contr_lex_entry & be_id_neg.
vc_id_were_neg_le := be_were_neg_contr_lex_entry & be_id_neg.
vc_id_were_neg_subj_le := be_were_subjnct_neg_contr_lex_entry & be_id_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg ] ].

; *** There Copula BE ***

;; The relationship between the first COMP and the second cannot be one of
;; raising (since if the first is extracted its SLASH will be non-empty, and
;; that non-empty SLASH would also erroneously appear on the VP.  So the 
;; control relation must be equi rather than raising.
;; DPF 2-May-01 - HACK: To avoid spurious ambiguity temporarily, block second 
;; arg by changing its KEY from independent_rel to no_rel.

there_cop_verb := aux_verb & there_verb_synsem &
  [ LKEYS.KEYREL arg1_relation &
                 [ PRED _be_v_there_rel ] ].

be_th_cop := be_verb & 
  [ SYNSEM there_cop_verb ].

be_th_cop_pos := be_th_cop &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop,
                                 INDEX #event ],
			  RELS <! #key !>,
			  HCONS <! !> ],
             LKEYS.KEYREL #key & [ LBL #ltop,
                                     ARG0 #event ] ] ].

th_cop_neg_aux_verb :< there_cop_verb.

be_th_cop_neg := be_th_cop &
  [ SYNSEM th_cop_neg_aux_verb &
	   [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! #key, #altkey !> ],
             LKEYS [ KEYREL #key & [ LBL #ltop ],
                     ALTKEYREL #altkey ] ] ].

vc_there_be_le := be_be_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse_only ].

#|
vc_there_be_le := be_be_lex_entry & be_th_cop &
  [ SYNSEM [ LOCAL [ CAT.HEAD.VFORM bse_only,
                     CONT [ HOOK.INDEX #event,
                            RELS <! #key !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #key & [ ARG0 #event ] ] ].
|#

vc_there_being_le := be_being_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD -,
                            TAM.ASPECT.PROGR - ] ].

vc_there_been_le := be_been_lex_entry & be_th_cop_pos.
vc_there_is_le := be_is_lex_entry & be_th_cop_pos.
vc_there_are_le := be_are_lex_entry & be_th_cop_pos.
vc_there_was_le := be_was_lex_entry & be_th_cop_pos.
vc_there_was_subj_le := be_was_subjnct_lex_entry & be_th_cop_pos.
vc_there_were_le := be_were_lex_entry & be_th_cop_pos.
vc_there_were_subj_le := be_were_subjnct_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

vc_there_s_cx_le := be_pres_lex_entry & be_th_cop_pos & contracted_aux_word.
vc_there_is_neg_le := be_is_neg_contr_lex_entry & be_th_cop_neg.
vc_there_are_neg_le := be_are_neg_contr_lex_entry & be_th_cop_neg.
vc_there_was_neg_le := be_was_neg_contr_lex_entry & be_th_cop_neg.
vc_there_was_neg_subj_le := be_was_subjnct_neg_contr_lex_entry & be_th_cop_neg.
vc_there_were_neg_le := be_were_neg_contr_lex_entry & be_th_cop_neg.
vc_there_were_neg_subj_le := be_were_subjnct_neg_contr_lex_entry & 
                             be_th_cop_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].
