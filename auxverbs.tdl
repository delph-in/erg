;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-1999
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  auxverbs.tdl
;;;
;;;  The auxiliary verb system for English
;;;
;;;  Created: Rob Malouf, 17-Nov-1994
;;;
;;;  $Id$

will_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
				TAM.TENSE future* ],
			 VAL [ SUBJ < synsem & 
				      [ LOCAL [ CAT nomp_cat_nom_min,
						CONJ cnil ] ] >,
			       COMPS.FIRST.LOCAL [ CONT.INDEX #event,
                                                   KEYS.KEY 
                                                       [ HANDEL #khand ] ] ] ],
                   CONT psoa & [ INDEX #event ],
                   KEYS.KEY [ HANDEL #khand ] ] ].

will_aux_pos_lex_e := will_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.TOP #hand ] >,
                   CONT [ TOP #hand,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

will_pos_le := will_aux_pos_lex_e.

will_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word.

will_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.TOP #chand,
		     CONT [ --TOPKEY #altkey,
			    LISZT <! neg_rel & #altkey &
				   [ ARG #arghand ] !>,
                            H-CONS <! qeq & [ SC-ARG #arghand,
                                              OUTSCPD #chand ] !> ] ] ] ].

would_aux_pos_le := will_aux_pos_lex_e & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].

would_aux_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].

would_aux_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM.MOOD modal_subj*,
			   VAL.COMPS.FIRST.LOCAL.CONT.TOP #chand ],
                     CONT [ --TOPKEY #altkey,
			    LISZT <! neg_rel & #altkey &
				   [ ARG #arghand ] !>,
                            H-CONS <! qeq & [ SC-ARG #arghand,
                                              OUTSCPD #chand ] !> ] ] ] ].

;;; Modal verbs

modal_pos_lex_ent := pos_modal_verb_word & add_cont.

modal_pos_le :< modal_pos_lex_ent.

modal_pos_cx_le := modal_pos_lex_ent & contracted_aux_word.

modal_subj_pos_lex_ent := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].

modal_subj_pos_le :< modal_subj_pos_lex_ent.

modal_subj_pos_cx_le := modal_subj_pos_lex_ent & contracted_aux_word.

ought_pos_le := pos_ought_verb_word & add_cont.
past_ought_pos_le := past_ought_verb_word & add_cont.

quasimodal_le := quasimodal_word.

quasimodal_psp_le := quasimodal_psp_word.

generic_modal_neg_super := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.TOP #chand,
		     CONT [ --TOPKEY #altkey,
			    LISZT <! neg_rel & #altkey &
				 [ ARG #narghand ], 
				 #key !>,
			    H-CONS <! qeq &
				  [ SC-ARG #arghand,
				    OUTSCPD #chand ],
				    qeq &
				  [ SC-ARG #narghand,
				    OUTSCPD #khand ] !> ],
		     KEYS.KEY #key & [ HANDEL #khand,
				       ARG4 #arghand ] ] ] ].

generic_modal_neg := generic_modal_neg_super & aux_verb_word.

modal_neg_le := modal_verb_word & generic_modal_neg.
modal_subj_neg_le := modal_verb_word & generic_modal_neg & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].

ought_neg_le := ought_verb_word & generic_modal_neg_super.


; *** Auxiliary DO ***

; For tag questions we need the KEY of auxiliary _do_ to match all main verbs.
; The supertype for this is v_event_rel.  Originally, it had been no_rel, to 
; block _do_'s being a complement of other auxiliaries.  On the hypothesis
; that auxiliary _do_ in fact lacks a non-finite form all together, the
; do_aux_word type is constrained to VFORM fin, inherited from bse_aux_verb_word.

do_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ TAM #tam,
				VOICE active ],
			 VAL [ SUBJ < synsem & 
				      [ LOCAL [ CAT nomp_cat_nom_min,
						CONJ cnil ] ] >,
			       COMPS.FIRST.LOCAL [ CAT.HEAD.AUX -,
						   CONT [ TOP #ctop,
							  INDEX #index ] ] ] ],
		   CONT psoa & [ INDEX #index & [ E #tam ] ] ,
		   KEYS.KEY mod_role_rel & [ HANDEL #ctop ] ] ].

; Removed raise-cont from parents, to allow EVENT to not be identified with the
; comp-dtr's EVENT   - is in conflict with collapsing of base and fin-non3rdsg 
; forms, given that we encode VIT attributes in the event feature structure.
; Sample problem: "Kim does sleep"

do_fin := do_aux_word & raise_cont & 
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin*,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] >,
				PRD - ],
			 POSTHEAD +,
			 VAL [ SUBJ < synsem & 
				      [ LOCAL [ CAT nomp_cat_nom_min,
						CONJ cnil ],
					OPT - ] >,
			       COMPS.FIRST.LOCAL.CONT.TOP #hand ] ],
		   CONT [ TOP #hand,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

do_aux_neg_word := do_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT [ TOP #chand,
                                                    INDEX #index ],
		   CONT [ --TOPKEY #altkey,
                          INDEX #index,
			  LISZT <! neg_rel & #altkey &
				 [ ARG #arghand ] !>,
			  H-CONS <! qeq &
				  [ SC-ARG #arghand,
				    OUTSCPD #chand ] !> ] ] ].

do_pres := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE present*,
				ASPECT no_aspect*,
				MOOD indicative* ] ].

does_aux_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.INDEX.PNG png & [ PN 3sg ] ] > ].

do_fin_aux_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ 
			     < [ LOCAL.CONT.INDEX.PNG png & 
						      [ PN non3sg & 
							   strict_sort ] ] > ].
did_aux_le := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE past*,
				ASPECT no_aspect*,
				MOOD indicative* ] ].

do_aux_neg_pres := do_aux_neg_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE present*,
				ASPECT no_aspect*,
				MOOD indicative* ] ].

do_aux_neg_past_le := do_aux_neg_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE past*,
				ASPECT no_aspect*,
				MOOD indicative* ] ].

do_aux_neg_subj_le := do_aux_neg_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD subjunctive ].

; ERB (31-03-97) The agreement on do, but not have and be, was previously
; taken care of in lexicon.tdl.  I am making these types to move that
; information here for symmetry.  The rest of the do paradigm seems
; to be generated by lexical rules, so these two are the only types.

doesnt_aux_neg_pres_le := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

dont_aux_neg_pres_le := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

; *** Perfect HAVE ***

have_aux_word := psp_aux_verb_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD.TAM.ASPECT perf*,
                   KEYS.KEY have_aux_rel ] ].

have_aux_pos_lex_entry := have_aux_word & topkey &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT [ TOP #hand,
						  INDEX #index ] ] >,
		   CONT [ TOP #hand,
			  INDEX #index,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

have_aux_neg_lex_entry := have_aux_word &
  [ SYNSEM lex_synsem &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin*,
				  PRD -,
				  MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] > ],
			   POSTHEAD +,
			   VAL [ SUBJ < [ OPT - ] >,
				 COMPS.FIRST
				      [ LOCAL.CONT [ TOP #chand,
						     INDEX #vind ] ] ] ],
		     CONT [ --TOPKEY #altkey,
			    INDEX #vind,
			    LISZT <! neg_rel & #altkey &
				   [ ARG #arghand ] !>,
			    H-CONS <! qeq &
				    [ SC-ARG #arghand,
				      OUTSCPD #chand ] !> ] ] ] ].

have_fin := have_aux_word &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin*,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] >,
				PRD - ],
			 POSTHEAD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

have_pres := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE present*,
				ASPECT perf*,
				MOOD indicative* ] ].

have_past := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE past*,
				ASPECT perf*,
				MOOD indicative* ] ].

have_subj := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ ASPECT perf*,
				MOOD subjunctive ] ].

;; We make "having" be [PRD -] to block "Kim is having fallen" and (the
;; restrictive reading of) "The book having fallen is red".  We will also 
;; exclude possibly grammatical examples like "anyone having seen that movie ..."
;; but there are no attested instances of these in the full BNC.

have_prespart_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD -,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat,
						CONT [ TOP #hand,
						       INDEX #nind ] ] ] > ],
			 VAL.SUBJ < [ LOCAL.CONT.INDEX #nind ] > ],
		   CONT.TOP #hand ] ].

have_bse_aux_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ PRD -,
                                VFORM bse_only,
                                TAM.ASPECT perf* ],
                         VAL.SUBJ < unexpressed > ],
		   CONT psoa ] ].

has_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL [ CAT nomp_cat_nom_min,
					  CONJ cnil,
					  CONT.INDEX.PNG png & 
					      [ PN 3sg ] ] ] > ].

has_aux_le :< has_aux_lex_ent.

has_aux_cx_le := has_aux_lex_ent & contracted_aux_word.

have_fin_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

have_fin_aux_le :< have_fin_aux_lex_ent.

have_fin_aux_cx_le := have_fin_aux_lex_ent & contracted_aux_word.

had_aux_lex_ent := have_aux_pos_lex_entry & have_past.

had_aux_le :< had_aux_lex_ent.

had_aux_subj_le := have_aux_pos_lex_entry & have_subj.

had_aux_cx_le := had_aux_lex_ent & contracted_aux_word.

has_aux_neg_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

have_fin_aux_neg_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

had_aux_neg_le := have_aux_neg_lex_entry & have_past.

had_aux_subj_neg_le := have_aux_neg_lex_entry & have_subj.

; *** Generic BE ***

be_verb := mcna & nonconj & nonmsg &
  [ INFLECTED +,
    SYNSEM.LOCAL.CAT [ HEAD.AUX +*,
		       VAL [ SUBJ < synsem_min & 
				    [ LOCAL [ CAT nomp_cat_min,
					      CONJ cnil ] ] >,
			     COMPS < synsem & [ OPT - ], ... > ] ] ].
be_fin := be_verb &
  [ SYNSEM.LOCAL non_perf &
		 [ CAT [ HEAD [ VFORM fin*,
				PRD -,
				TAM.ASPECT nonprf,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] > ],
			 POSTHEAD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

be_pres := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE present*,
				MOOD indicative* ] ].

be_past := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE past*,
				MOOD indicative* ] ].

be_subj := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD subjunctive ].

; Make be_prespart unmarked for PRD so we can block the identity-copula reading
; for "Kim is being good" while allowing the predicative-copula reading.

be_prespart := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				MOD < [ LOCAL intersective_mod & 
					      [ CAT nbar_cat,
						CONT.INDEX #nind ] ] > ],
			 VAL.SUBJ < [ LOCAL.CONT.INDEX #nind ] > ] ] ].

be_pastpart := be_verb &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT.HEAD [ VFORM psp,
			      PRD - ],
		   CONT psoa ] ]. 
be_neg := sign &
  [ INFLECTED +,
    SYNSEM lex_synsem &
	   [ LOCAL [ KEYS [ KEY.HANDEL #khand,
			    ALTKEY neg_rel & #altkey &
				       [ ARG #arghand ] ],
		     CONT [ --TOPKEY #altkey,
			    H-CONS <! qeq &
				    [ SC-ARG #arghand,
				      OUTSCPD #khand ]!> ] ] ] ].

be_be_lex_entry := be_verb & 
  [ STEM < "be" >,
    SYNSEM.LOCAL nomod_local &
	 [ CAT [ HEAD [ PRD -,
			VFORM bse,
			TAM [ ASPECT nonprf,
			      MOOD ind_or_mod_subj ] ],
		 VAL.SUBJ < unexpressed & [ OPT - ] > ] ] ].

be_being_lex_entry := be_prespart & 
  [ STEM < "being" > ].

be_been_lex_entry := be_pastpart & 
  [ STEM < "been" > ].

be_pres_lex_entry := be_pres.

be_past_lex_entry := be_past.

be_pres_neg_lex_entry := be_pres & be_neg.
be_past_neg_lex_entry := be_past & be_neg.

be_am_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg ] ].

be_is_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_am_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.INV +,
                   AGR.PNG png & [ PN 1sg ] ] ].

be_is_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

; *** Copula BE ***

; DPF 27-Nov-99 - Made KEY.HANDEL identified with COMPS.KEYS.KEY.HANDEL,
; to avoid assymetry of HANDEL and LABEL for VM, which was causing errors
; for e.g. "it is really going to be".  This used to lose a possible ambiguity
; for e.g. "kim is not sleeping", since the support_rel will always be in
; the scope of the negation, regardless of whether the "not" attaches to
; "be" or to the complement phrase.  
; DPF 01-Mar-00 - But now that we've eliminated support_rels, it may work ok.
; AAC killed LABEL

be_copula := prd_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM #tam,
			 VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.TAM #tam,
						 KEYS.KEY [ HANDEL #hand,
                                                            EVENT #event ] ] ],
		   CONT.INDEX #event,
		   KEYS.KEY _be_prd_rel & [ HANDEL #hand ] ] ].

be_cop_pos_generic := be_copula &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.TOP #top,
		   CONT [ TOP #top,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

be_cop_pos := be_cop_pos_generic &
 [ SYNSEM.LOCAL non_perf ].

be_cop_neg := be_copula &
  [ SYNSEM.LOCAL non_perf &
		 [ KEYS.ALTKEY #altkey,
		   CONT [ --TOPKEY #altkey,
			  LISZT <! #altkey !> ] ] ].

be_c_be_le := be_be_lex_entry & be_cop_pos_generic.
be_c_being_le := be_being_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.CAT [ HEAD.PRD +,
		       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM non_prp ] ].
be_c_been_le := be_been_lex_entry & be_cop_pos_generic.
be_c_am_le := be_am_lex_entry & be_cop_pos.
be_c_is_le := be_is_lex_entry & be_cop_pos.
be_c_is_cx_le := be_is_lex_entry & be_cop_pos & contracted_aux_word.
be_c_are_le := be_are_lex_entry & be_cop_pos.
be_c_was_le := be_was_lex_entry & be_cop_pos.
be_c_were_le := be_were_lex_entry & be_cop_pos.
be_c_am_neg_le := be_am_neg_contr_lex_entry & be_cop_neg.
be_c_is_neg_le := be_is_neg_contr_lex_entry & be_cop_neg.
be_c_are_neg_le := be_are_neg_contr_lex_entry & be_cop_neg.
be_c_was_neg_le := be_was_neg_contr_lex_entry & be_cop_neg.
be_c_were_neg_le := be_were_neg_contr_lex_entry & be_cop_neg.

; *** Identity BE ***

id_cop_verb := aux_verb & two_arg_subst & basic_two_arg &
  [ LOCAL [ CAT [ HEAD.TAM.ASPECT nonprg,
                  VAL [ SUBJ < [ LOCAL.CONT [ TOP #top,
                                              INDEX #id1ind & ref-ind ] ] >,
                        COMPS < [ LOCAL [ CAT nomp_cat_min & 
                                              [ HEAD [ PRD -,
                                                       MOD < > ] ],
                                          CONT 
                                              [ TOP #top,
                                                INDEX #id2ind & ref-ind ],
                                          KEYS.KEY reg_nom_rel,
                                          CONJ cnil ] ] > ] ],
	    CONT.TOP #top,
	    KEYS.KEY _cop_id_rel &
			   [ ARG1 #id1ind,
			     ARG3 #id2ind ] ] ].

be_id := be_verb &
  [ SYNSEM id_cop_verb &
	   [ LOCAL.CONT [ INDEX #event,
			  LISZT.LIST.FIRST.EVENT #event ] ] ].

be_id_pos := be_id & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT [ LISZT <! #key !>,
			  H-CONS <! !> ] ] ].

be_id_neg_synsem :< id_cop_verb.

be_id_neg := be_id &
  [ SYNSEM be_id_neg_synsem & 
	   [ LOCAL [ KEYS [ KEY #key,
			    ALTKEY #altkey ],
		     CONT.LISZT <! #key, #altkey !> ] ] ].

be_id_be_le := be_be_lex_entry & be_id & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT [ LISZT <! #key !>,
			  H-CONS <! !> ] ] ].

be_id_being_le := be_being_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].
be_id_been_le := be_been_lex_entry & be_id_pos.
be_id_am_le := be_am_lex_entry & be_id_pos.
be_id_is_le := be_is_lex_entry & be_id_pos.
be_id_is_cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word.
be_id_are_le := be_are_lex_entry & be_id_pos.
be_id_was_le := be_was_lex_entry & be_id_pos.
be_id_were_le := be_were_lex_entry & be_id_pos.
be_id_am_neg_le := be_am_neg_contr_lex_entry & be_id_neg.
be_id_is_neg_le := be_is_neg_contr_lex_entry & be_id_neg.
be_id_are_neg_le := be_are_neg_contr_lex_entry & be_id_neg.
be_id_was_neg_le := be_was_neg_contr_lex_entry & be_id_neg.
be_id_were_neg_le := be_were_neg_contr_lex_entry & be_id_neg.

; *** There Copula BE ***

;; The relationship between the first COMP and the second cannot be one of
;; raising (since if the first is extracted its SLASH will be non-empty, and
;; that non-empty SLASH would also erroneously appear on the VP.  So the control
;; relation must be equi rather than raising.

there_cop_verb := aux_verb & unsat_three_arg_subst & basic_three_arg &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL [ CONT.INDEX there-ind &
							  [ PNG #png ] ] ] >,
		      COMPS < synsem &
			    [ LOCAL [ AGR non_expl-ind &
					  [ PNG #png ],
				      CAT np_cat_acc_min,
				      CONT.INDEX #cind,
				      CONJ cnil,
                                      KEYS.KEY nonpro_rel & [ HANDEL #khand ]],
			      OPT - ],
			    [ LOCAL local &
				    [ CAT [ HEAD.PRD +,
					    VAL [ SUBJ < synsem & 
							 [ LOCAL.CONT.INDEX 
									  #cind,
							   NON-LOCAL.SLASH 
								      0-dlist ]>,
						  SPR *olist*,
						  COMPS *olist* ],
					    MC na ],
				      CONT.TOP #khand,
				      KEYS.KEY independent_rel ],
			      OPT + ] > ],
	    KEYS.KEY _there_cop_rel &
			 [ ARG3 #cind,
                           LABEL *cons* ] ] ].

be_th_cop := be_verb & 
  [ SYNSEM there_cop_verb ].

be_th_cop_pos := be_th_cop & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key & [ EVENT #event ],
		   CONT [ INDEX #event,
			  LISZT <! #key !>,
			  H-CONS <! !> ] ] ].

th_cop_neg_aux_verb :< there_cop_verb.

be_th_cop_neg := be_th_cop &
  [ SYNSEM th_cop_neg_aux_verb &
	   [ LOCAL [ KEYS [ KEY #key,
			    ALTKEY #altkey ],
		     CONT [ LISZT <! #key, #altkey !>,
			    --TOPKEY #altkey ] ] ] ].

be_th_cop_be_le := be_be_lex_entry & be_th_cop &
  [ SYNSEM.LOCAL [ CAT.HEAD.VFORM bse_only,
                   KEYS.KEY #key & [ EVENT #event ],
		   CONT [ INDEX #event,
			  LISZT <! #key !>,
			  H-CONS <! !> ] ] ].

be_th_cop_being_le := be_being_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].
be_th_cop_been_le := be_been_lex_entry & be_th_cop_pos.
be_th_cop_is_le := be_is_lex_entry & be_th_cop_pos.
be_th_cop_are_le := be_are_lex_entry & be_th_cop_pos.
be_th_cop_was_le := be_was_lex_entry & be_th_cop_pos.
be_th_cop_were_le := be_were_lex_entry & be_th_cop_pos.
be_th_cop_s_cx_le := be_pres_lex_entry & be_th_cop_pos & contracted_aux_word.
be_th_cop_is_neg_le := be_is_neg_contr_lex_entry & be_th_cop_neg.

be_th_cop_are_neg_le := be_are_neg_contr_lex_entry & be_th_cop_neg.

be_th_cop_was_neg_le := be_was_neg_contr_lex_entry & be_th_cop_neg.

be_th_cop_were_neg_le := be_were_neg_contr_lex_entry & be_th_cop_neg.


