;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2005
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see erg/licence.txt for conditions
;;;
;;;  auxverbs.tdl
;;;
;;;  The auxiliary verb system for English
;;;
;;;  Created: Rob Malouf, 17-Nov-1994
;;;
;;;  $Id: auxverbs.tdl,v 1.38 2008/08/02 16:50:23 danf Exp $

will_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin,
                                PRD -,
                                TAM indic_tam ],
                         VAL [ SUBJ < synsem & 
				      [ LOCAL [ CAT nomp_cat_nom_min,
						CONJ cnil ],
                                        OPT - ] >,
			       COMPS.FIRST.--SIND #event ] ],
                   CONT psoa & [ HOOK.INDEX #event ] ] ].

will_aux_pos_lex_e := will_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #hand ] >,
                   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].


v_vp_will-p_le := will_aux_pos_lex_e &
 [ SYNSEM.LOCAL.CAT [ HEAD.TAM [ TENSE future,
                                 MOOD indicative ],
                      VAL.COMPS < [ LOCAL.CAT vp_bse_unspec_cat &
                                          [ HEAD.TAM.MOOD indicative ] ] > ] ].
                        
v_vp_will-p-cx_le := will_aux_pos_lex_e & contracted_aux_word &
 [ SYNSEM.LOCAL.CAT [ HEAD.TAM [ TENSE future,
                                 MOOD indicative ],
                      VAL.COMPS < [ LOCAL.CAT vp_bse_unspec_cat &
                                          [ HEAD.TAM.MOOD indicative ] ] > ] ].

va_will_neg_lexent := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM [ TENSE future,
                                      MOOD indicative ],
                           VAL.COMPS.FIRST.LOCAL [ CAT vp_bse_unspec_cat &
                                                   [ HEAD.TAM.MOOD indicative ],
                                                   CONT.HOOK.LTOP #chand ] ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #alt2keyrel & adv_relation &
                                  [ LBL #ltop,
                                    PRED neg_rel,
                                    ARG1 #arghand ] !>,
                            HCONS <! qeq & [ HARG #arghand,
                                             LARG #chand ] !> ] ],
             LKEYS.ALT2KEYREL #alt2keyrel ] ].

v_vp_will-n_le := va_will_neg_lexent.
v_vp_will-n-niv_le := va_will_neg_lexent & aux_not_contr.

;;; Modal verbs


v_vp_mdl-p_le := modal_pos_indic_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

v_vp_mdl-p-cx_le := modal_pos_indic_lexent & contracted_aux_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

; could
v_vp_mdl-p-pst_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE past ].

; would - unsp for MOOD
v_vp_mdl-p-unsp_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

v_vp_mdl-p-niv_le := modal_pos_indic_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ TAM.TENSE present,
                            INV - ] ].

v_vp_mdl-p-sv_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

v_vp_oght-p_le := pos_ought_verb_word & add_cont &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

v_vp_oght-p-pst_le := past_ought_verb_word & add_cont &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE past ].

v_vp_qsmd_le := quasimodal_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp, 
                            PRD + ] ].

v_vp_qsmd-psp_le := quasimodal_psp_word.

v_vp_qsmd-bse_le := quasimodal_bse_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp, 
                            PRD + ] ].

; 'didn't he used to sing?'
v_vp_nfin-mod_le := nonfin_modal_word.

generic_modal_neg_super := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
		     CONT [ HOOK.LTOP #ltop,
                            RELS <! #alt2keyrel & adv_relation &
                                  [ LBL #ltop,
                                    PRED neg_rel,
                                    ARG1 #narghand ], 
                                  #keyrel !>,
			    HCONS <! qeq &
				  [ HARG #arghand,
				    LARG #chand ],
				    qeq &
				  [ HARG #narghand,
				    LARG #khand ] !> ] ],
             LKEYS [ KEYREL #keyrel &
                            [ LBL #khand,
                              PRED modal_rel,
                              ARG1 #arghand ],
                     ALT2KEYREL #alt2keyrel ] ] ].

generic_modal_neg := generic_modal_neg_super & aux_verb_word &
  [ SYNSEM.LOCAL.CAT.POSTHD + ].

va_modal_neg_lexent := modal_verb_word & generic_modal_neg &
  [ SYNSEM.LKEYS.KEYREL.PRED modal_rel ].

v_vp_mdl-n_le := va_modal_neg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

; couldn't
v_vp_mdl-n-pst_le := va_modal_neg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE past ].

; "'d better not"
v_vp_mdl-n-niv_le := va_modal_neg_lexent & aux_not_contr &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

v_vp_mdl-n-sv_le := modal_verb_word & generic_modal_neg & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

v_vp_oght-n_le := ought_verb_word & generic_modal_neg_super &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

; *** Auxiliary DO ***

; For tag questions we need the MIN of auxiliary _do_ to match all main verbs.
; The supertype for this is v_event_rel.  Originally, it had been no_rel, to 
; block _do_'s being a complement of other auxiliaries.  On the hypothesis
; that auxiliary _do_ in fact lacks a non-finite form all together, the
; do_aux_word type is constrained to VFORM fin.

do_aux_word := nonc-hm &
  [ INFLECTD +,
    SYNSEM ssr_two_arg_verb &
           [ LOCAL [ CAT [ HEAD [ AUX +,
                                  TAM [ TENSE #tense,
                                        ASPECT #aspect,
                                        MOOD indicative ],
                                  MINORS.MIN #min & nonaux_event_rel ],
                           VAL [ SUBJ < synsem & 
                                        [ OPT -,
                                          LOCAL [ CAT nomp_cat_nom_min,
                                                  CONJ cnil ] ] >,
                                 COMPS < synsem &
                                         [ --MIN #min,
                                           LOCAL [ CAT vp_bse_unspec_cat &
                                                       [ HEAD.AUX - ],
                                                   CONT.HOOK [ LTOP #cltop,
                                                               INDEX #index ],
                                                   CONJ cnil ],
                                           --SIND #index,
                                           OPT - ] > ],
                           POSTHD + ],
                     CONT psoa & [ HOOK.INDEX #index & 
                                              [ E [ TENSE #tense,
                                                    ASPECT #aspect,
                                                    MOOD indicative ] ] ] ],
             LKEYS.KEYREL [ LBL #cltop,
                            PRED mod_role_rel,
                            ARG0 #index ] ] ].

; Removed raise-cont from parents, to allow ARG0 to not be identified with the
; comp-dtr's ARG0   - is in conflict with collapsing of base and fin-non3rdsg 
; forms, given that we encode VIT attributes in the event feature structure.
; Sample problem: "Kim does sleep"

; DPF 6-Feb-02 - Changed MOOD indicative to indicative* in order to support
; coordination of e.g. yes-no questions and modal_subj declaratives.  Same in
; type do_aux_neg_pres.
; DPF 13-Mar-02 - But this allowed "want" version of "like" to be complement.
; So instead make do_aux_word stamp indicative* for its own MOOD, and not
; copy it up from complement dtr.  Then require complement dtr to be simply
; MOOD indicative.  And by the way broke link from "do" to bse_aux_verb_word
; which insists on making the aux verb's TAM identical to its INDEX, which we
; can't have for "do".

do_fin := do_aux_word & raise_cont & 
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin,
				PRD - ],
			 VAL [ SUBJ < [ OPT - ] >,
			       COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #hand ] ],
                   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

do_aux_neg_word := do_aux_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ PRD -,
                                  VFORM fin ],
                           VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #chand ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #alt2keyrel & adv_relation &
                                  [ LBL #ltop,
                                    PRED neg_rel,
                                    ARG1 #arghand ] !>,
                            HCONS <! qeq &
                                   [ HARG #arghand,
                                     LARG #chand ] !> ] ],
             LKEYS.ALT2KEYREL #alt2keyrel ] ].

do_pres := do_fin &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM indic_tam &
                                  [ TENSE present,
                                    ASPECT no_aspect ],
                         VAL.SUBJ < [ --SIND.PNG #png ] > ],
                   AGR.PNG #png ] ].

v_vp_does_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN 3s ] ] > ].

v_vp_do-f_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ 
			     < [ --SIND.PNG png & [ PN -3s ] ] > ].

v_vp_did_le := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM past_or_subj_tam ].

do_aux_neg_pres := do_aux_neg_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM indic_tam &
                              [ TENSE present,
				ASPECT no_aspect ] ].

v_vp_did-n_le := do_aux_neg_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM past_or_subj_tam ].

; ERB (31-03-97) The agreement on do, but not have and be, was previously
; taken care of in lexicon.tdl.  I am making these types to move that
; information here for symmetry.  The rest of the do paradigm seems
; to be generated by lexical rules, so these two are the only types.

v_vp_does-n_le := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

v_vp_do-f-n_le := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ] ].

; *** Perfect HAVE ***

have_aux_word := psp_aux_verb_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD.TAM.ASPECT.PRF +,
                           VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #index ],
                     CONT.HOOK.INDEX #index ],
             LKEYS.KEYREL.PRED have_aux_rel ] ].

have_aux_pos_lex_entry := have_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #hand ] >,
		   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

aux_not_contr := sign &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
                       VAL.COMPS.FIRST unexpressed & [ OPT - ] ] ].
                   
have_aux_neg_lex_entry := have_aux_word &
  [ SYNSEM lex_synsem &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD - ],
			   POSTHD +,
			   VAL [ SUBJ < [ OPT - ] >,
				 COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #chand ] ],
                     CONT [ HOOK.LTOP #ltop,
			    RELS <! #alt2keyrel & adv_relation &
                                    [ LBL #ltop,
                                      PRED neg_rel,
                                      ARG1 #arghand ] !>,
			    HCONS <! qeq &
				    [ HARG #arghand,
				      LARG #chand ] !> ] ],
             LKEYS.ALT2KEYREL #alt2keyrel ] ].

have_fin := have_aux_word &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin,
				PRD - ],
			 POSTHD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

have_pres := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM indic_tam &
                              [ TENSE present,
				ASPECT.PRF + ] ].

have_past := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE past,
				ASPECT.PRF +,
				MOOD indicative ] ].

have_subj := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam &
                              [ ASPECT.PRF +,
				MOOD subjunctive ] ].

;; We make "having" be [PRD -] to block "Kim is having fallen" and (the
;; restrictive reading of) "The book having fallen is red".  We will also 
;; exclude possibly grammatical examples like "anyone having seen that movie"
;; but there are no attested instances of these in the full BNC.
;; DPF 29-oct-06 - Remove this PRD - constraint, since it also blocks
;; depictives as in "We left, having finished."  Instead, block "is having"
;; by adding NORM no_rel.  Maybe FIX?

v_vp_have-prp_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp,
                            TAM.ASPECT.PROGR +,
                            MINORS.NORM no_rel ] ].

va_have_bse_lexent := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
                                VFORM bse_only,
                                TAM.ASPECT.PRF + ],
                         VAL.SUBJ < unexpressed >,
                         POSTHD + ],
		   CONT psoa ] ].

v_vp_have-bse_le :< va_have_bse_lexent.
v_vp_have-bse-cx_le := va_have_bse_lexent & contracted_aux_word.

has_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.AGR.PNG png & [ PN 3s ] ] > ].

v_vp_has_le :< has_aux_lex_ent.

v_vp_has-cx_le := has_aux_lex_ent & contracted_aux_word.

have_fin_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ] ].

v_vp_have-f_le :< have_fin_aux_lex_ent.

v_vp_have-f-cx_le := have_fin_aux_lex_ent & contracted_aux_word.

had_aux_lex_ent := have_aux_pos_lex_entry & have_past.

v_vp_had-sv_le := have_aux_pos_lex_entry & have_subj.

v_vp_had_le :< had_aux_lex_ent.

v_vp_had-cx_le := had_aux_lex_ent & contracted_aux_word.

v_vp_has-n_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

v_vp_has-n-niv_le := have_aux_neg_lex_entry & have_pres & aux_not_contr &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

v_vp_have-f-n_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ] ].

v_vp_have-n-niv_le := have_aux_neg_lex_entry & have_pres & 
                            aux_not_contr &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ] ].

v_vp_had-n_le := have_aux_neg_lex_entry & have_past.

v_vp_had-n-niv_le := have_aux_neg_lex_entry & have_past & aux_not_contr.

v_vp_had-n-sv_le := have_aux_neg_lex_entry & have_subj.

; *** should of ***

v_vp_shld-of_le := psp_aux_verb_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                  PRD -,
                                  TAM indic_tam &
                                        [ TENSE present,
                                          ASPECT.PRF + ] ],
                           VAL [ SUBJ < synsem & 
                                        [ LOCAL [ CAT nomp_cat_nom_min,
                                                  CONJ cnil ],
                                          OPT - ] >,
                                 COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] > ] ],
                     CONT [ HOOK [ LTOP #hand,
                                   INDEX #index ],
                            RELS <! #keyrel & [ LBL #hand,
                                                PRED _should_v_modal_rel,
                                                ARG0 #index,
                                                ARG1 #arg1 ] !>,
                            HCONS <! qeq & [ HARG #arg1,
                                             LARG #chand ] !> ] ],
             LKEYS.KEYREL #keyrel ] ].

; *** Generic BE ***

be_verb := nonc-hm &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < synsem_min & 
                                  [ LOCAL [ CAT nomp_cat_min,
                                            CONJ cnil ] ] >,
                           COMPS < synsem & [ OPT - ], ... > ] ].

; DPF 20-Oct-01 - Changed [TAM.ASPECT strict_nonprf] to nonprf, since it was
; blocking coordination of "Kim has arrived and Sandy is happy".  This change
; now allows "Kim is being hiring Browne" but we can live with it for now.

be_fin := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin,
				PRD -,
				TAM.ASPECT.PRF - ],
			 POSTHD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

be_pres := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM indic_tam &
                              [ TENSE present,
                                MOOD indicative ] ].

be_past := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM indic_tam &
                              [ TENSE past ] ].
be_subj := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; Make be_prespart unmarked for PRD so we can block the identity-copula reading
; for "Kim is being good" while allowing the predicative-copula reading.
; 20-Oct-01 - Added POSTHD + to block pre-noun modification as in "*the being
; Kim person arrived"
; Added SLASH 0-dlist to avoid endless recursion when generating, since we no
; longer block "Kim is being silly", and don't want to use VFORM to block
; "Kim is being arriving" since that would put VFORM on type subst (too high),
; even though we'd like to exclude this example.  So we add COMPS..AUX - to
; prevent "*Kim is being being silly", which avoids the worst case.
; DPF 18-oct-03 - Also add COMPS..ASPECT.PROGR - to block *Kim is being singing

be_prespart := be_verb &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ VFORM prp,
                                INV - ],
                         VAL.COMPS < [ LOCAL.CAT.HEAD.AUX - ], ... >,
                         POSTHD + ],
             NONLOC.SLASH 0-dlist ] ].

be_pastpart := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM psp,
                                TAM.ASPECT.PRF +,
                                PRD -,
                                INV - ],
                         POSTHD + ],
		   CONT psoa ] ]. 
be_neg := sign &
  [ INFLECTD +,
    SYNSEM lex_synsem &
	   [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          HCONS <! qeq &
                                 [ HARG #arghand,
                                   LARG #khand ] !> ],
             LKEYS [ KEYREL.LBL #khand,
                     ALT2KEYREL adv_relation &
                                [ LBL #ltop,
                                  PRED neg_rel,
                                  ARG1 #arghand ] ] ] ].

be_be_lex_entry := be_verb & 
  [ STEM < "be" >,
    SYNSEM.LOCAL.CAT [ HEAD [ PRD -,
                              VFORM bse,
                              TAM.ASPECT.PRF -,
                              INV - ],
                       VAL.SUBJ < synsem & [ OPT - ] > ] ].

be_being_lex_entry := be_prespart & 
  [ STEM < "being" > ].

be_been_lex_entry := be_pastpart & 
  [ STEM < "been" > ].

be_pres_lex_entry := be_pres.

be_past_lex_entry := be_past.

be_subj_lex_entry := be_subj.

be_pres_neg_lex_entry := be_pres & be_neg.
be_past_neg_lex_entry := be_past & be_neg.
be_subj_neg_lex_entry := be_subj & be_neg.

be_am_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1s ] ].

be_is_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

be_are_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

be_was_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 13s ] ].

be_were_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

be_was_subjnct_lex_entry := be_subj_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 13s ] ].

be_were_subjnct_lex_entry :< be_subj_lex_entry.

; aren't
be_am_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD.INV +,
                         VAL.SUBJ < [ --SIND.PNG #png ] > ],
                   AGR.PNG png & #png & [ PN 1s ] ] ].

; 'm not
be_am_neg_contr_noinv_lex_entry := be_pres_neg_lex_entry & aux_not_contr &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1s ] ].

; isn't
be_is_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

; 's not
be_is_neg_contr_noinv_lex_entry := be_pres_neg_lex_entry & aux_not_contr &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

; aren't
be_are_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

; 're not
be_are_neg_contr_noinv_lex_entry := be_pres_neg_lex_entry & aux_not_contr &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

be_was_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 13s ] ].

be_was_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 13s ] ].

be_were_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

be_were_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; *** Copula BE ***

; DPF 27-Nov-99 - Made KEYREL.LBL identified with COMPS..KEYREL.LBL,
; to avoid assymetry of LBL for VM, which was causing errors
; for e.g. "it is really going to be".  This used to lose a possible ambiguity
; for e.g. "kim is not sleeping", since the support_rel will always be in
; the scope of the negation, regardless of whether the "not" attaches to
; "be" or to the complement phrase.  
; DPF 01-Mar-00 - But now that we've eliminated support_rels, it may work ok.

be_copula := prd_aux_verb_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.TAM #tam,
			 VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.TAM #tam,
                                                 CONT.HOOK.LTOP #hand ] ],
             LKEYS.KEYREL [ LBL #hand,
                            PRED be_v_prd_rel ] ] ].

be_cop_pos_generic := be_copula &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		   CONT [ HOOK.LTOP #ltop,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

be_cop_pos := be_cop_pos_generic.

be_cop_neg := be_copula &
  [ SYNSEM [ LOCAL [ CONT [ HOOK.LTOP #ltop,
                            RELS <! #alt2keyrel !> ] ],
             LKEYS.ALT2KEYREL #alt2keyrel & [ LBL #ltop ] ] ].

v_prd_be_le := be_be_lex_entry & be_cop_pos_generic.

; DPF 18-oct-03 - Added COMPS..ALTMIN no_rel to block "being arriving" while
; still allowing "being hired", "being happy", "being in Berlin"
; DPF 03-oct-06 - But now using ALTMIN to control application of partitive
; rule to superlative adjectives, so need to make this COMPS..ALTMIN more
; specific, to include prd adjs and PPs, but exclude pres-participle verbs,
; so use event_dim_rel.

v_prd_being_le := be_being_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.CAT [ HEAD [ PRD +,
                              TAM.ASPECT.PROGR + ],
                       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN 
                                                            event_dim_rel ] ].

v_prd_been_le := be_been_lex_entry & be_cop_pos_generic.
v_prd_am_le := be_am_lex_entry & be_cop_pos.
v_prd_am-cx_le := be_am_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_is_lexent := be_is_lex_entry & be_cop_pos.
v_prd_is_le := vc_prd_is_lexent.
v_prd_is-cx_le := vc_prd_is_lexent & contracted_aux_word.
vc_prd_are_lexent := be_are_lex_entry & be_cop_pos.
v_prd_are_le := vc_prd_are_lexent.
v_prd_are-cx_le := vc_prd_are_lexent & contracted_aux_word.
v_prd_was_le := be_was_lex_entry & be_cop_pos.
v_prd_was-sv_le := be_was_subjnct_lex_entry & be_cop_pos.
v_prd_wre_le := be_were_lex_entry & be_cop_pos.
v_prd_wre-sv_le := be_were_subjnct_lex_entry & be_cop_pos.

v_prd_am-n_le := be_am_neg_contr_lex_entry & be_cop_neg.
v_prd_am-n-niv_le := be_am_neg_contr_noinv_lex_entry & be_cop_neg.
v_prd_is-n_le := be_is_neg_contr_lex_entry & be_cop_neg.
v_prd_is-n-niv_le := be_is_neg_contr_noinv_lex_entry & be_cop_neg.
v_prd_are-n_le := be_are_neg_contr_lex_entry & be_cop_neg.
v_prd_are-n-niv_le := be_are_neg_contr_noinv_lex_entry & be_cop_neg.
v_prd_was-n_le := be_was_neg_contr_lex_entry & be_cop_neg.
v_prd_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_cop_neg.
v_prd_wre-n_le := be_were_neg_contr_lex_entry & be_cop_neg.
v_prd_wre-n-sv_le := be_were_subjnct_neg_contr_lex_entry & be_cop_neg.

; *** Identity BE ***
; For now, exclude gerundive complements, to avoid semantically anomalous
; reading for "Kim is sleeping"
; DPF 08-Jan-00 Made COMP be nom_rel instead of reg_nom_rel, to allow "Tuesday
; is my last day" and "that's him".
; DPF 22-Feb-01 - Added ALTMIN restriction on SUBJ to prevent free relatives
; from appearing in subject position, to get the contrast of "I admire what
; you are" vs. "*I admire what are you" (and cf. "I admire what is best").
; DPF 26-Aug-01 - Added MIN nom_rel to SUBJ, like for COMP, to avoid having
; measure_nps in subject position.
; DPF 19-Oct-02 - Removed identification of PRONTYPE on SUBJ and COMP, since
; this blocks "it is I/me" "that's me" etc.
; DPF 27-Apr-03 - Removed [COMPS..PRD -] since this prevents 'today is December
; third', and it's not clear what it was blocking.  (Nor is it clear why
; 'third' has to be [PRD +].)
; DPF 10-Jun-03 - Try identifying SORT values of subj and comp.
; DPF 5-Sep-03 - Don't understand comment of 22-Feb-02 above, but clearly
; free relatives can be subjects of identity copula: "What he does is your
; problem".  So removed this constraint.
; DPF 18-dec-03 - Keeping identity of SORT values is too hard - e.g. "The
; cabin is a good place to stay".  
; DPF 30-aug-04 - Removed PRONTYPE real_pron from SUBJ, since it
; prevented "consultant hiring is a disadvantage" with N-N-cmpnd subject NP.
; Leave on COMPS for now, to continue to block spurious analysis for
; "the boy is fishing."
; DPF 19-nov-04 - Removed identification of SUBJ..AGR with SUBJ..--SIND since
; want "three kilometers" measure-NP to be syntactically singular, even though
; semantic index comes from "kilometers" which is plural.
; DPF 05-nov-05 - Added CASE non_obliq to COMPS to block idiomatic detless NPs
; as in 'on top' from giving "*Kim is top."
; DPF 13-nov-05 - But sadly this also blocks "This is why we suffer".  So
; instead try requiring non-empty SPEC, where detless NPs have SPEC < >.
; DPF 28-oct-06 - Removed PRONTYPE real_pron from COMPS, since we want to
; allow "The reason is the fishing."  No longer getting as much spurious
; ambiguity, for example with "The boy is fishing."  See if too much remains.

id_cop_verb := aux_verb & basic_two_arg & two_arg_subst &
  [ LOCAL [ CAT [ HEAD.MINORS [ MIN be_v_id_rel,
				ALTMIN nonpass_rel ],
                  VAL [ SUBJ < [ --MIN nom_or_mnp_rel,
                                 --SIND #id1ind & basic_non_expl &
                                       [ SORT #sort ],
                                 NONLOC non-local_norel ] >,
                        COMPS < [ --MIN nom_or_mnp_rel,
                                  LOCAL [ CAT nomp_cat_min & 
                                              [ HEAD.MOD < >,
                                                VAL.SPEC *cons* ],
                                          CONJ cnil ],
                                  --SIND #id2ind & non_expl-ind &
                                        [ SORT #sort ],
                                  NONLOC.REL 0-dlist ] > ] ],
            CONT.HOOK.XARG #id1ind ],
    LKEYS.KEYREL arg12_relation &
                 [ ARG1 #id1ind,
                   ARG2 #id2ind ] ].

be_id := be_verb &
  [ SYNSEM id_cop_verb &
	   [ LOCAL.CONT [ HOOK.INDEX #event,
			  RELS.LIST.FIRST.ARG0 #event ],
             LKEYS.KEYREL.PRED _be_v_id_rel ] ].

be_id_pos := be_id &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

be_id_neg_synsem := id_cop_verb &
  [ LKEYS.KEYREL.PRED _be_v_id_rel ].

be_id_neg := be_id &
  [ SYNSEM be_id_neg_synsem & 
	   [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT.RELS <! #keyrel, #alt2keyrel !> ],
             LKEYS [ KEYREL #keyrel,
                     ALT2KEYREL #alt2keyrel ] ] ].

v_np_be_le := be_be_lex_entry & be_id &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

v_np_being_le := be_being_lex_entry & be_id &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR +,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

v_np_been_le := be_been_lex_entry & be_id_pos.
v_np_am_le := be_am_lex_entry & be_id_pos.
v_np_am-cx_le := be_am_lex_entry & be_id_pos & contracted_aux_word.
v_np_is_le := be_is_lex_entry & be_id_pos.
v_np_is-cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word.
v_np_are_le := be_are_lex_entry & be_id_pos.
v_np_are-cx_le := be_are_lex_entry & be_id_pos & contracted_aux_word.
v_np_was_le := be_was_lex_entry & be_id_pos.
v_np_was-sv_le := be_was_subjnct_lex_entry & be_id_pos.
v_np_wre_le := be_were_lex_entry & be_id_pos.
v_np_wre-sv_le := be_were_subjnct_lex_entry & be_id_pos.

v_np_am-n_le := be_am_neg_contr_lex_entry & be_id_neg.
v_np_am-n-niv_le := be_am_neg_contr_noinv_lex_entry & be_id_neg.
v_np_is-n_le := be_is_neg_contr_lex_entry & be_id_neg.
v_np_is-n-niv_le := be_is_neg_contr_noinv_lex_entry & be_id_neg.
v_np_are-n_le := be_are_neg_contr_lex_entry & be_id_neg.
v_np_are-n-niv_le := be_are_neg_contr_noinv_lex_entry & be_id_neg.
v_np_was-n_le := be_was_neg_contr_lex_entry & be_id_neg.
v_np_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_id_neg.
v_np_wre-n_le := be_were_neg_contr_lex_entry & be_id_neg.
v_np_wre-n-sv_le := be_were_subjnct_neg_contr_lex_entry & be_id_neg.

; Note that for "it's because Kim arrived." the ARG1 of the subord_rel is
; incorrectly not bound to any lbl.  Awkward to get right, since no handle
; for "the reason is because Kim arrived".  FIX...
; DPF 13-may-08 - Removed --COMPHD comp_or_p because we also want to
; get "The short answer is nobody wins."  So far this was the only use of
; the feature, so maybe discard.
; DPF 27-may-08 - Added POSTHD + to block spurious analysis for
; "Kim is of programmers."

nv_cop_verb := aux_verb & two_arg_subst & basic_two_arg &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN be_v_nv_rel,
                  VAL [ SUBJ < canonical_synsem &
			       [ --MIN nom_or_mnp_rel,
                                 --SIND #id1ind & non_expl-ind &
				       [ SORT nom-event ],
                                 NONLOC non-local_none ] >,
                        COMPS < [ --MIN verb_or_subord_rel,
                                  LOCAL [ CAT [ HEAD verbal_or_p &
						     [ MINORS.NORM norm_rel,
						       PRD - ],
                                                VAL [ SUBJ *anti_list*,
                                                      COMPS < > ],
						POSTHD +,
						MC - ],
                                          CONT.HOOK [ LTOP #cltop,
						      INDEX [ SF prop-or-ques,
							      --TPC - ] ],
					  CONJ cnil ],
                                  NONLOC non-local_none ] > ] ],
	    CONT.HOOK.XARG #id1ind ],
    NONLOC non-local_none,
    LKEYS.KEYREL arg12_relation &
                 [ PRED _be_v_nv_rel,
                   ARG1 #id1ind,
                   ARG2 #cltop ] ].

be_nv := be_verb &
  [ SYNSEM nv_cop_verb &
	   [ LOCAL.CONT [ HOOK.INDEX #event,
			  RELS.LIST.FIRST.ARG0 #event ] ],
    ALTS.VPELLIP - ].

be_nv_pos := be_nv &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

be_nv_neg_synsem :< nv_cop_verb.

be_nv_neg := be_nv &
  [ SYNSEM be_nv_neg_synsem & 
	   [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT.RELS <! #keyrel, #alt2keyrel !> ],
             LKEYS [ KEYREL #keyrel,
                     ALT2KEYREL #alt2keyrel ] ] ].

v_cp_be_le := be_be_lex_entry & be_nv &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

v_cp_being_le := be_being_lex_entry & be_nv &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR +,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

v_cp_been_le := be_been_lex_entry & be_nv_pos.
v_cp_is_le := be_is_lex_entry & be_nv_pos.
v_cp_is-cx_le := be_is_lex_entry & be_nv_pos & contracted_aux_word.
v_cp_are_le := be_are_lex_entry & be_nv_pos.
v_cp_was_le := be_was_lex_entry & be_nv_pos.
v_cp_was-sv_le := be_was_subjnct_lex_entry & be_nv_pos.
v_cp_wre_le := be_were_lex_entry & be_nv_pos.
v_cp_wre-sv_le := be_were_subjnct_lex_entry & be_nv_pos.

v_cp_is-n_le := be_is_neg_contr_lex_entry & be_nv_neg.
v_cp_is-n-niv_le := be_is_neg_contr_noinv_lex_entry & be_nv_neg.
v_cp_are-n_le := be_are_neg_contr_lex_entry & be_nv_neg.
v_cp_was-n_le := be_was_neg_contr_lex_entry & be_nv_neg.
v_cp_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_nv_neg.
v_cp_wre-n_le := be_were_neg_contr_lex_entry & be_nv_neg.
v_cp_wre-n-sv_le := be_were_subjnct_neg_contr_lex_entry & be_nv_neg.

; *** There Copula BE ***

;; The relationship between the first COMP and the second cannot be one of
;; raising (since if the first is extracted its SLASH will be non-empty, and
;; that non-empty SLASH would also erroneously appear on the VP.  So the 
;; control relation must be equi rather than raising.
;; DPF 2-May-01 - HACK: To avoid spurious ambiguity temporarily, block second 
;; arg by changing its MIN from independent_rel to no_rel.
;; DPF 29-may-07 - Removed AUX + to allow extraction of modifiers, as for
;; "occasionally there are unicorns in the garden".  FIX?

there_cop_verb := there_verb_synsem & aux_verb &
  [ LOCAL.CAT.HEAD.MINORS.MIN be_v_there_rel,
    LKEYS [ KEYREL.PRED _be_v_there_rel,
            --+ARGIND there-ind ] ].

be_th_cop := be_verb & 
  [ SYNSEM there_cop_verb ].

be_th_cop_pos := be_th_cop &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop,
                                 INDEX #event ],
			  RELS <! #keyrel !>,
			  HCONS <! !> ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
                                   ARG0 #event ] ] ].

be_th_cop_neg := be_th_cop &
  [ SYNSEM [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! #keyrel, #alt2keyrel !> ],
             LKEYS [ KEYREL #keyrel,
                     ALT2KEYREL #alt2keyrel & [ LBL #ltop ] ] ] ].

v_np-xp_be_le := be_be_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse_only ].

v_np-xp_being_le := be_being_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD -,
                            TAM.ASPECT.PROGR - ] ].

v_np-xp_been_le := be_been_lex_entry & be_th_cop_pos.
v_np-xp_is_le := be_is_lex_entry & be_th_cop_pos.
vc_there_are_lexent := be_are_lex_entry & be_th_cop_pos.
v_np-xp_are_le := vc_there_are_lexent.
v_np-xp_is-pl_le := vc_there_are_lexent &
  [ GENRE nonformal ].
v_np-xp_was_le := be_past_lex_entry & be_th_cop_pos.
v_np-xp_was-sv_le := be_was_subjnct_lex_entry & be_th_cop_pos.
v_np-xp_wre_le := be_were_lex_entry & be_th_cop_pos.
v_np-xp_wre-sv_le := be_were_subjnct_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

v_np-xp_is-cx_le := be_pres_lex_entry & be_th_cop_pos & contracted_aux_word.
v_np-xp_is-n_le := be_is_neg_contr_lex_entry & be_th_cop_neg.
v_np-xp_is-n-niv_le := be_is_neg_contr_noinv_lex_entry & be_th_cop_neg.
v_np-xp_are-n_le := be_are_neg_contr_lex_entry & be_th_cop_neg.
v_np-xp_was-n_le := be_was_neg_contr_lex_entry & be_th_cop_neg.
v_np-xp_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_th_cop_neg.
v_np-xp_wre-n_le := be_were_neg_contr_lex_entry & be_th_cop_neg.
v_np-xp_wre-n-sv_le := be_were_subjnct_neg_contr_lex_entry & 
                             be_th_cop_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

; *** It-cleft Copula BE ***

be_it_cop := be_verb & 
  [ SYNSEM itcleft_verb_synsem &
           [ LKEYS.--+ARGIND it-ind ] ].

be_it_cop_pos := be_it_cop &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop,
                                 INDEX #event ],
			  RELS <! #keyrel !>,
			  HCONS <! !> ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
				      ARG0 #event ] ] ].

be_it_cop_neg := be_it_cop &
  [ SYNSEM [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! #keyrel, #alt2keyrel !> ],
             LKEYS [ KEYREL #keyrel & [ LBL #ltop ],
                     ALT2KEYREL #alt2keyrel ] ] ].

v_np-rc_be_le := be_be_lex_entry & be_it_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse_only ].

v_np-rc_being_le := be_being_lex_entry & be_it_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD -,
                            TAM.ASPECT.PROGR - ] ].

v_np-rc_been_le := be_been_lex_entry & be_it_cop_pos.
v_np-rc_is_le := be_is_lex_entry & be_it_cop_pos.
v_np-rc_was_le := be_was_lex_entry & be_it_cop_pos.
v_np-rc_was-sv_le := be_was_subjnct_lex_entry & be_it_cop_pos.

v_np-rc_is-cx_le := be_pres_lex_entry & be_it_cop_pos & contracted_aux_word.
v_np-rc_is-n_le := be_is_neg_contr_lex_entry & be_it_cop_neg.
v_np-rc_was-n_le := be_was_neg_contr_lex_entry & be_it_cop_neg.
v_np-rc_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_it_cop_neg.

