;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-1999
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  auxverbs.tdl
;;;
;;;  The auxiliary verb system for English
;;;
;;;  Created: Rob Malouf, 17-Nov-1994
;;;
;;;  $Id$

will_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin*,
                                PRD -,
                                MOD < [ LOCAL intersective_mod &
                                              [ CAT nbar_cat ] ] >,
                                TAM ind_or_mod_subj_tam ],
                         VAL [ SUBJ < synsem & 
				      [ LOCAL [ CAT nomp_cat_nom_min,
						KEYS.MESSAGE 0-dlist,
						CONJ cnil ] ] >,
			       COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #event ] ],
                   CONT psoa & [ HOOK.INDEX #event ] ] ].

will_aux_pos_lex_e := will_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #hand ] >,
                   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

va_will_pos_le := will_aux_pos_lex_e &
 [ SYNSEM.LOCAL.CAT [ HEAD.TAM [ TENSE future*,
                                 MOOD indicative* ],
                      VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].
                        
va_will_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word &
 [ SYNSEM.LOCAL.CAT [ HEAD.TAM [ TENSE future*,
                                 MOOD indicative* ],
                      VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].

va_will_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM [ TENSE future*,
                                      MOOD indicative* ],
                           VAL.COMPS.FIRST.LOCAL [ CAT vp_bse_cat,
                                                   CONT.HOOK.LTOP #chand ] ],
                     CONT [ --TOPKEY #altkey,
			    RELS <! neg_rel & #altkey &
				   [ ARG1 #arghand ] !>,
                            HCONS <! qeq & [ HARG #arghand,
                                             LARG #chand ] !> ] ] ] ].

va_would_pos_le := will_aux_pos_lex_e & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE future*,
                                MOOD modal_subj* ] ].

va_would_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE future*,
                                MOOD modal_subj* ] ].

va_would_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM [ TENSE future*,
                                      MOOD modal_subj* ],
			   VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #chand ],
                     CONT [ --TOPKEY #altkey,
			    RELS <! neg_rel & #altkey &
				   [ ARG1 #arghand ] !>,
                            HCONS <! qeq & [ HARG #arghand,
                                             LARG #chand ] !> ] ] ] ].

va_would_like_pos_le := will_aux_pos_lex_e & 
  [ SYNSEM.LOCAL [ CAT.HEAD.TAM [ TENSE present*,
                                  MOOD modal_subj* ],
                   KEYS.--COMPKEY would_like_rel ] ].

va_would_like_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD.TAM [ TENSE present*,
                                  MOOD modal_subj* ],
                   KEYS.--COMPKEY would_like_rel ] ].                   

va_would_like_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM [ TENSE present*,
                                      MOOD modal_subj* ],
			   VAL.COMPS.FIRST.LOCAL [ CONT.HOOK.LTOP #chand,
                                                   KEYS.KEY would_like_rel ] ],
                     CONT [ --TOPKEY #altkey,
			    RELS <! neg_rel & #altkey &
				   [ ARG1 #arghand ] !>,
                            HCONS <! qeq & [ HARG #arghand,
                                             LARG #chand ] !> ] ] ] ].

;;; Modal verbs

modal_pos_lex_ent := pos_modal_verb_word & add_cont.

va_modal_pos_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE present*,
                                MOOD indicative* ] ].

va_modal_pos_noninv_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD [ TAM [ TENSE present*,
                                  MOOD indicative* ],
                            INV - ] ].

va_modal_pos_cx_le := modal_pos_lex_ent & contracted_aux_word.

modal_subj_pos_lex_ent := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].

va_modal_subj_pos_le :< modal_subj_pos_lex_ent.
va_modal_subj_pos_pres_le := modal_subj_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present* ].

modal_subj_pos_cx_le := modal_subj_pos_lex_ent & contracted_aux_word.

va_ought_pos_le := pos_ought_verb_word & add_cont &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present* ].

va_past_ought_pos_le := past_ought_verb_word & add_cont &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE past* ].

va_quasimodal_le := quasimodal_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp, 
                            PRD +,
                            TAM.TENSE future* ] ].

va_quasimodal_psp_le := quasimodal_psp_word.

va_quasimodal_bse_le := quasimodal_bse_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp, 
                            PRD +,
                            TAM.TENSE future* ] ].

generic_modal_neg_super := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.LTOP #chand,
		     CONT [ --TOPKEY #altkey,
			    RELS <! neg_rel & #altkey &
				 [ ARG1 #narghand ], 
				 #key !>,
			    HCONS <! qeq &
				  [ HARG #arghand,
				    LARG #chand ],
				    qeq &
				  [ HARG #narghand,
				    LARG #khand ] !> ],
		     KEYS.KEY #key & [ LBL #khand,
				       ARG1 #arghand ] ] ] ].

generic_modal_neg := generic_modal_neg_super & aux_verb_word &
  [ SYNSEM.LOCAL.KEYS.KEY.WLINK *cons* ].

va_modal_neg_le := modal_verb_word & generic_modal_neg &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present* ].

va_modal_subj_neg_le := modal_verb_word & generic_modal_neg & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].
va_modal_subj_neg_pres_le := modal_verb_word & generic_modal_neg & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE present*,
                                MOOD modal_subj* ] ].

va_ought_neg_le := ought_verb_word & generic_modal_neg_super &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present* ].

; *** Auxiliary DO ***

; For tag questions we need the KEY of auxiliary _do_ to match all main verbs.
; The supertype for this is v_event_rel.  Originally, it had been no_rel, to 
; block _do_'s being a complement of other auxiliaries.  On the hypothesis
; that auxiliary _do_ in fact lacks a non-finite form all together, the
; do_aux_word type is constrained to VFORM fin.

do_aux_word := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTED +,
    SYNSEM ssr_two_arg_verb &
           [ LOCAL [ CAT [ HEAD [ AUX +*,
                                  TAM [ TENSE #tense,
                                        ASPECT #aspect,
                                        MOOD indicative* ],
                                  VOICE active,
                                  MOD < [ LOCAL intersective_mod &
                                                [ CAT nbar_cat ] ] > ],
                           VAL [ SUBJ < synsem & 
                                        [ OPT -,
                                          LOCAL [ CAT nomp_cat_nom_min,
                                                  KEYS.MESSAGE 0-dlist,
                                                  CONJ cnil ] ] >,
                                 COMPS < synsem &
                                         [ LOCAL [ CAT vp_bse_unspec_cat &
                                                       [ HEAD.AUX - ],
                                                   CONT.HOOK [ LTOP #cltop,
                                                               INDEX #index ],
                                                   CONJ cnil ],
                                           OPT - ] > ],
                           POSTHEAD + ],
                     CONT psoa & [ HOOK.INDEX #index & 
                                              [ E [ TENSE #tense,
                                                    ASPECT #aspect,
                                                    MOOD indicative ] ] ],
                     KEYS.KEY mod_role_rel & [ LBL #cltop ] ] ] ].

; Removed raise-cont from parents, to allow ARG0 to not be identified with the
; comp-dtr's ARG0   - is in conflict with collapsing of base and fin-non3rdsg 
; forms, given that we encode VIT attributes in the event feature structure.
; Sample problem: "Kim does sleep"

; DPF 6-Feb-02 - Changed MOOD indicative to indicative* in order to support
; coordination of e.g. yes-no questions and modal_subj declaratives.  Same in
; type do_aux_neg_pres.
; DPF 13-Mar-02 - But this allowed "want" version of "like" to be complement.
; So instead make do_aux_word stamp indicative* for its own MOOD, and not
; copy it up from complement dtr.  Then require complement dtr to be simply
; MOOD indicative.  And by the way broke link from "do" to bse_aux_verb_word
; which insists on making the aux verb's TAM identical to its INDEX, which we
; can't have for "do".

do_fin := do_aux_word & raise_cont & 
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin*,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] >,
				PRD - ],
			 VAL [ SUBJ < [ OPT - ] >,
			       COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #hand ] ],
                   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

do_aux_neg_word := do_aux_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -*,
                                VFORM fin* ],
                         VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #chand ],
                   CONT [ --TOPKEY #altkey,
			  RELS <! neg_rel & #altkey &
				 [ ARG1 #arghand ] !>,
			  HCONS <! qeq &
				  [ HARG #arghand,
				    LARG #chand ] !> ] ] ].

do_pres := do_fin &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM ind_or_mod_subj_tam &
                                  [ TENSE present*,
                                    ASPECT no_aspect* ],
                         VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG #png ] > ],
                   AGR.PNG #png ] ].

va_does_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG png & 
                                                            [ PN 3sg ] ] > ].

va_do_fin_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ 
			     < [ LOCAL.CONT.HOOK.INDEX.PNG png & 
                                                          [ PN non3sg & 
                                                               strict_sort]]>].

va_did_le := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM past_or_subj_tam ].

do_aux_neg_pres := do_aux_neg_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE present*,
				ASPECT no_aspect* ] ].

va_do_neg_past_le := do_aux_neg_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM past_or_subj_tam ].

; ERB (31-03-97) The agreement on do, but not have and be, was previously
; taken care of in lexicon.tdl.  I am making these types to move that
; information here for symmetry.  The rest of the do paradigm seems
; to be generated by lexical rules, so these two are the only types.

va_doesnt_neg_pres_le := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

va_dont_neg_pres_le := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

; *** Perfect HAVE ***

have_aux_word := psp_aux_verb_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD.TAM.ASPECT perf*,
                   KEYS.KEY have_aux_rel ] ].

have_aux_pos_lex_entry := have_aux_word & topkey &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                       INDEX #index ] ] >,
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index ],
			  RELS <! !>,
			  HCONS <! !> ] ] ].

have_aux_neg_lex_entry := have_aux_word &
  [ SYNSEM lex_synsem &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin*,
				  PRD -,
				  MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] > ],
			   POSTHEAD +,
			   VAL [ SUBJ < [ OPT - ] >,
				 COMPS.FIRST
				      [ LOCAL.CONT.HOOK [ LTOP #chand,
                                                          INDEX #vind ] ] ] ],
		     CONT [ --TOPKEY #altkey,
			    HOOK.INDEX #vind,
			    RELS <! neg_rel & #altkey &
				   [ ARG1 #arghand ] !>,
			    HCONS <! qeq &
				    [ HARG #arghand,
				      LARG #chand ] !> ] ] ] ].

have_fin := have_aux_word &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin*,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] >,
				PRD - ],
			 POSTHEAD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      KEYS.MESSAGE 0-dlist,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

have_pres := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE present*,
				ASPECT perf*,
				MOOD indicative* ] ].

have_past := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE past*,
				ASPECT perf*,
				MOOD indicative* ] ].

have_subj := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ ASPECT perf*,
				MOOD subjunctive ] ].

;; We make "having" be [PRD -] to block "Kim is having fallen" and (the
;; restrictive reading of) "The book having fallen is red".  We will also 
;; exclude possibly grammatical examples like "anyone having seen that movie ..."
;; but there are no attested instances of these in the full BNC.

va_have_prespart_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD -,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat,
						CONT.HOOK [ LTOP #hand,
                                                            INDEX #nind ] ]]>],
			 VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #nind ] > ],
		   CONT.HOOK.LTOP #hand ] ].

va_have_bse_lexent := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ PRD -,
                                VFORM bse_only,
                                TAM.ASPECT perf* ],
                         VAL.SUBJ < unexpressed > ],
		   CONT psoa ] ].

va_have_bse_le :< va_have_bse_lexent.
va_have_bse_cx_le := va_have_bse_lexent & contracted_aux_word.

has_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.CONT.HOOK.INDEX.PNG png & 
                                                            [ PN 3sg ] ] > ].

va_has_le :< has_aux_lex_ent.

va_has_cx_le := has_aux_lex_ent & contracted_aux_word.

have_fin_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

va_have_fin_le :< have_fin_aux_lex_ent.

va_have_fin_cx_le := have_fin_aux_lex_ent & contracted_aux_word.

had_aux_lex_ent := have_aux_pos_lex_entry & have_past.

va_had_subj_le := have_aux_pos_lex_entry & have_subj.

va_had_le :< had_aux_lex_ent.

va_had_cx_le := had_aux_lex_ent & contracted_aux_word.

va_has_neg_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

va_have_fin_neg_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

va_had_neg_le := have_aux_neg_lex_entry & have_past.

va_had_subj_neg_le := have_aux_neg_lex_entry & have_subj.

; *** Generic BE ***

be_verb := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTED +,
    SYNSEM.LOCAL.CAT [ HEAD.AUX +*,
		       VAL [ SUBJ < synsem_min & 
				    [ LOCAL [ CAT nomp_cat_min,
					      CONJ cnil ] ] >,
			     COMPS < synsem & [ OPT - ], ... > ] ] ].

; DPF 20-Oct-01 - Changed [TAM.ASPECT strict_nonprf] to nonprf, since it was
; blocking coordination of "Kim has arrived and Sandy is happy".  This change
; now allows "Kim is being hiring Browne" but we can live with it for now.

be_fin := be_verb &
  [ SYNSEM.LOCAL non_perf &
		 [ CAT [ HEAD [ VFORM fin*,
				PRD -,
				TAM.ASPECT nonprf,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] > ],
			 POSTHEAD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

be_pres := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE present*,
				MOOD indicative* ] ].

be_past := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE past*,
				MOOD indicative* ] ].
be_subj := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; Make be_prespart unmarked for PRD so we can block the identity-copula reading
; for "Kim is being good" while allowing the predicative-copula reading.
; 20-Oct-01 - Added POSTHEAD + to block pre-noun modification as in "*the being
; Kim person arrived"

be_prespart := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
                                TAM.ASPECT progr*,
				MOD < [ LOCAL intersective_mod & 
					      [ CAT nbar_cat,
						CONT.HOOK.INDEX #nind ] ] > ],
			 POSTHEAD +,
			 VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #nind ] > ] ] ].

be_pastpart := be_verb &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ VFORM psp,
                                TAM.ASPECT perf*,
                                PRD - ],
			 POSTHEAD + ],
		   CONT psoa ] ]. 
be_neg := sign &
  [ INFLECTED +,
    SYNSEM lex_synsem &
	   [ LOCAL [ KEYS [ KEY.LBL #khand,
			    ALTKEY neg_rel & #altkey &
				       [ ARG1 #arghand ] ],
		     CONT [ --TOPKEY #altkey,
			    HCONS <! qeq &
				    [ HARG #arghand,
				      LARG #khand ] !> ] ] ] ].

be_be_lex_entry := be_verb & 
  [ STEM < "be" >,
    SYNSEM.LOCAL nomod_local &
	 [ CAT [ HEAD [ PRD -,
			VFORM bse,
			TAM.ASPECT nonprf ],
		 VAL.SUBJ < unexpressed & [ OPT - ] > ] ] ].

be_being_lex_entry := be_prespart & 
  [ STEM < "being" > ].

be_been_lex_entry := be_pastpart & 
  [ STEM < "been" > ].

be_pres_lex_entry := be_pres.

be_past_lex_entry := be_past.

be_subj_lex_entry := be_subj.

be_pres_neg_lex_entry := be_pres & be_neg.
be_past_neg_lex_entry := be_past & be_neg.
be_subj_neg_lex_entry := be_subj & be_neg.

be_am_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg ] ].

be_is_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_subjnct_lex_entry := be_subj_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_subjnct_lex_entry :< be_subj_lex_entry.

be_am_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.INV +,
                   AGR.PNG png & [ PN 1sg ] ] ].

be_is_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_was_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_were_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; *** Copula BE ***

; DPF 27-Nov-99 - Made KEY.LBL identified with COMPS.KEYS.KEY.LBL,
; to avoid assymetry of LBL and WLINK for VM, which was causing errors
; for e.g. "it is really going to be".  This used to lose a possible ambiguity
; for e.g. "kim is not sleeping", since the support_rel will always be in
; the scope of the negation, regardless of whether the "not" attaches to
; "be" or to the complement phrase.  
; DPF 01-Mar-00 - But now that we've eliminated support_rels, it may work ok.

be_copula := prd_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM #tam,
			 VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.TAM #tam,
                                                 CONT.HOOK.LTOP #hand ] ],
                   KEYS.KEY _be_prd_rel & [ LBL #hand ] ] ].

be_cop_pos_generic := be_copula &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		   CONT [ HOOK.LTOP #ltop,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

be_cop_pos := be_cop_pos_generic &
 [ SYNSEM.LOCAL non_perf ].

be_cop_neg := be_copula &
  [ SYNSEM.LOCAL non_perf &
		 [ KEYS.ALTKEY #altkey,
		   CONT [ --TOPKEY #altkey,
			  RELS <! #altkey !> ] ] ].

; The non-empty COMPS..MOD blocks "I am going to be going to be arriving"
vc_prd_be_le := be_be_lex_entry & be_cop_pos_generic &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD < synsem > ] > ].

vc_prd_being_le := be_being_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.CAT [ HEAD.PRD +,
		       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM non_prp ] ].
; The non-empty COMPS..MOD blocks "I am going to have been going to have
; been arriving"
vc_prd_been_le := be_been_lex_entry & be_cop_pos_generic &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD < synsem > ] > ].
vc_prd_am_le := be_am_lex_entry & be_cop_pos.
vc_prd_am_cx_le := be_am_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_is_le := be_is_lex_entry & be_cop_pos.
vc_prd_is_cx_le := be_is_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_are_le := be_are_lex_entry & be_cop_pos.
vc_prd_are_cx_le := be_are_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_was_le := be_was_lex_entry & be_cop_pos.
vc_prd_was_subj_le := be_was_subjnct_lex_entry & be_cop_pos.
vc_prd_were_le := be_were_lex_entry & be_cop_pos.
vc_prd_were_subj_le := be_were_subjnct_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg & strict_sort ] ].

vc_prd_am_neg_le := be_am_neg_contr_lex_entry & be_cop_neg.
vc_prd_is_neg_le := be_is_neg_contr_lex_entry & be_cop_neg.
vc_prd_are_neg_le := be_are_neg_contr_lex_entry & be_cop_neg.
vc_prd_was_neg_le := be_was_neg_contr_lex_entry & be_cop_neg.
vc_prd_was_neg_subj_le := be_was_subjnct_neg_contr_lex_entry & be_cop_neg.
vc_prd_were_neg_le := be_were_neg_contr_lex_entry & be_cop_neg.
vc_prd_were_neg_subj_le := be_were_subjnct_neg_contr_lex_entry & be_cop_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg & strict_sort ] ].

; *** Identity BE ***
; For now, exclude gerundive complements, to avoid semantically anomalous
; reading for "Kim is sleeping"
; DPF 08-Jan-00 Made COMP be nom_rel instead of reg_nom_rel, to allow "Tuesday
; is my last day" and "that's him".
; DPF 22-Feb-01 - Added ALTKEY restriction on SUBJ to prevent free relatives
; from appearing in subject position, to get the contrast of "I admire what
; you are" vs. "*I admire what are you" (and cf. "I admire what is best").
; DPF 26-Aug-01 - Added KEY nom_rel to SUBJ, like for COMP, to avoid having
; measure_nps in subject position.
; DPF 19-Oct-02 - Removed identification of PRONTYPE on SUBJ and COMP, since
; this blocks "it is I/me" "that's me" etc.

id_cop_verb := aux_verb & two_arg_subst & basic_two_arg &
  [ LOCAL [ CAT [ HEAD.TAM.ASPECT nonprg,
                  VAL [ SUBJ < [ LOCAL [ KEYS 
                                         [ KEY nom_rel,
                                           ALTKEY non_freerel_rel ],
                                         CONT.HOOK.INDEX #id1ind & ref-ind &
                                              [ PRONTYPE real_pron ] ],
                                 NON-LOCAL non-local_norel ] >,
                        COMPS < [ LOCAL [ CAT nomp_cat_min & 
                                              [ HEAD [ PRD -,
                                                       MOD < > ] ],
                                          CONT.HOOK.INDEX #id2ind & ref-ind &
                                              [ PRONTYPE real_pron ],
					  KEYS.KEY nom_rel,
                                          CONJ cnil ],
                                  NON-LOCAL non-local_norel ] > ] ],
            CONT.HOOK.XARG #id1ind,
	    KEYS.KEY _cop_id_rel &
			   [ ARG1 #id1ind,
			     ARG2 #id2ind,
                             WLINK *cons* ] ] ].

be_id := be_verb &
  [ SYNSEM id_cop_verb &
	   [ LOCAL.CONT [ HOOK.INDEX #event,
			  RELS.LIST.FIRST.ARG0 #event ] ] ].

be_id_pos := be_id & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT [ RELS <! #key !>,
			  HCONS <! !> ] ] ].

be_id_neg_synsem :< id_cop_verb.

be_id_neg := be_id &
  [ SYNSEM be_id_neg_synsem & 
	   [ LOCAL [ KEYS [ KEY #key,
			    ALTKEY #altkey ],
		     CONT.RELS <! #key, #altkey !> ] ] ].

vc_id_be_le := be_be_lex_entry & be_id & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT [ RELS <! #key !>,
			  HCONS <! !> ] ] ].

vc_id_being_le := be_being_lex_entry & be_id_pos.
vc_id_been_le := be_been_lex_entry & be_id_pos.
vc_id_am_le := be_am_lex_entry & be_id_pos.
vc_id_am_cx_le := be_am_lex_entry & be_id_pos & contracted_aux_word.
vc_id_is_le := be_is_lex_entry & be_id_pos.
vc_id_is_cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word.
vc_id_are_le := be_are_lex_entry & be_id_pos.
vc_id_are_cx_le := be_are_lex_entry & be_id_pos & contracted_aux_word.
vc_id_was_le := be_was_lex_entry & be_id_pos.
vc_id_was_subj_le := be_was_subjnct_lex_entry & be_id_pos.
vc_id_were_le := be_were_lex_entry & be_id_pos.
vc_id_were_subj_le := be_were_subjnct_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg & strict_sort ] ].

vc_id_am_neg_le := be_am_neg_contr_lex_entry & be_id_neg.
vc_id_is_neg_le := be_is_neg_contr_lex_entry & be_id_neg.
vc_id_are_neg_le := be_are_neg_contr_lex_entry & be_id_neg.
vc_id_was_neg_le := be_was_neg_contr_lex_entry & be_id_neg.
vc_id_was_neg_subj_le := be_was_subjnct_neg_contr_lex_entry & be_id_neg.
vc_id_were_neg_le := be_were_neg_contr_lex_entry & be_id_neg.
vc_id_were_neg_subj_le := be_were_subjnct_neg_contr_lex_entry & be_id_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg & strict_sort ] ].

; *** There Copula BE ***

;; The relationship between the first COMP and the second cannot be one of
;; raising (since if the first is extracted its SLASH will be non-empty, and
;; that non-empty SLASH would also erroneously appear on the VP.  So the 
;; control relation must be equi rather than raising.
;; DPF 2-May-01 - HACK: To avoid spurious ambiguity temporarily, block second 
;; arg by changing its KEY from independent_rel to no_rel.

there_cop_verb := aux_verb & there_verb_synsem &
  [ LOCAL.KEYS.KEY _there_cop_rel ].

be_th_cop := be_verb & 
  [ SYNSEM there_cop_verb ].

be_th_cop_pos := be_th_cop & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key & [ ARG0 #event ],
		   CONT [ HOOK.INDEX #event,
			  RELS <! #key !>,
			  HCONS <! !> ] ] ].

th_cop_neg_aux_verb :< there_cop_verb.

be_th_cop_neg := be_th_cop &
  [ SYNSEM th_cop_neg_aux_verb &
	   [ LOCAL [ KEYS [ KEY #key,
			    ALTKEY #altkey ],
		     CONT [ RELS <! #key, #altkey !>,
			    --TOPKEY #altkey ] ] ] ].

vc_there_be_le := be_be_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse_only ].

#|
vc_there_be_le := be_be_lex_entry & be_th_cop &
  [ SYNSEM.LOCAL [ CAT.HEAD.VFORM bse_only,
                   KEYS.KEY #key & [ ARG0 #event ],
		   CONT [ HOOK.INDEX #event,
			  RELS <! #key !>,
			  HCONS <! !> ] ] ].
|#

vc_there_being_le := be_being_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].
vc_there_been_le := be_been_lex_entry & be_th_cop_pos.
vc_there_is_le := be_is_lex_entry & be_th_cop_pos.
vc_there_are_le := be_are_lex_entry & be_th_cop_pos.
vc_there_was_le := be_was_lex_entry & be_th_cop_pos.
vc_there_was_subj_le := be_was_subjnct_lex_entry & be_th_cop_pos.
vc_there_were_le := be_were_lex_entry & be_th_cop_pos.
vc_there_were_subj_le := be_were_subjnct_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg & strict_sort ] ].

vc_there_s_cx_le := be_pres_lex_entry & be_th_cop_pos & contracted_aux_word.
vc_there_is_neg_le := be_is_neg_contr_lex_entry & be_th_cop_neg.
vc_there_are_neg_le := be_are_neg_contr_lex_entry & be_th_cop_neg.
vc_there_was_neg_le := be_was_neg_contr_lex_entry & be_th_cop_neg.
vc_there_was_neg_subj_le := be_was_subjnct_neg_contr_lex_entry & be_th_cop_neg.
vc_there_were_neg_le := be_were_neg_contr_lex_entry & be_th_cop_neg.
vc_there_were_neg_subj_le := be_were_subjnct_neg_contr_lex_entry & 
                             be_th_cop_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg & strict_sort ] ].
