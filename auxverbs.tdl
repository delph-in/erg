;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-1999
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  auxverbs.tdl
;;;
;;;  The auxiliary verb system for English
;;;
;;;  Created: Rob Malouf, 17-Nov-1994
;;;
;;;  $Id$

will_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin*,
                                PRD -,
                                MOD < [ LOCAL intersective_mod &
                                              [ CAT nbar_cat ] ] >,
                                TAM ind_or_mod_subj_tam &
                                    [ TENSE future* ] ],
                         VAL [ SUBJ < synsem & 
				      [ LOCAL [ CAT nomp_cat_nom_min,
						KEYS.MESSAGE 0-dlist,
						CONJ cnil ] ] >,
			       COMPS.FIRST.LOCAL.CONT.INDEX #event ] ],
                   CONT psoa & [ INDEX #event ] ] ].

will_aux_pos_lex_e := will_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.TOP #hand ] >,
                   CONT [ TOP #hand,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

va_will_pos_le := will_aux_pos_lex_e &
 [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD indicative* ].
                        
va_will_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word &
 [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD indicative* ].

va_will_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM.MOOD indicative*,
                           VAL.COMPS.FIRST.LOCAL.CONT.TOP #chand ],
                     CONT [ --TOPKEY #altkey,
			    LISZT <! neg_rel & #altkey &
				   [ ARG #arghand ] !>,
                            H-CONS <! qeq & [ SC-ARG #arghand,
                                              OUTSCPD #chand ] !> ] ] ] ].

va_would_pos_le := will_aux_pos_lex_e & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].

va_would_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].

va_would_neg_le := will_aux_word & 
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT [ HEAD.TAM.MOOD modal_subj*,
			   VAL.COMPS.FIRST.LOCAL.CONT.TOP #chand ],
                     CONT [ --TOPKEY #altkey,
			    LISZT <! neg_rel & #altkey &
				   [ ARG #arghand ] !>,
                            H-CONS <! qeq & [ SC-ARG #arghand,
                                              OUTSCPD #chand ] !> ] ] ] ].

;;; Modal verbs

modal_pos_lex_ent := pos_modal_verb_word & add_cont.

va_modal_pos_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD indicative* ].

va_modal_pos_cx_le := modal_pos_lex_ent & contracted_aux_word.

modal_subj_pos_lex_ent := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].

va_modal_subj_pos_le :< modal_subj_pos_lex_ent.

modal_subj_pos_cx_le := modal_subj_pos_lex_ent & contracted_aux_word.

va_ought_pos_le := pos_ought_verb_word & add_cont.
va_past_ought_pos_le := past_ought_verb_word & add_cont.

va_quasimodal_le := quasimodal_word.

va_quasimodal_psp_le := quasimodal_psp_word.

va_quasimodal_bse_le := quasimodal_bse_word.

generic_modal_neg_super := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.TOP #chand,
		     CONT [ --TOPKEY #altkey,
			    LISZT <! neg_rel & #altkey &
				 [ ARG #narghand ], 
				 #key !>,
			    H-CONS <! qeq &
				  [ SC-ARG #arghand,
				    OUTSCPD #chand ],
				    qeq &
				  [ SC-ARG #narghand,
				    OUTSCPD #khand ] !> ],
		     KEYS.KEY #key & [ HANDEL #khand,
				       ARG4 #arghand ] ] ] ].

generic_modal_neg := generic_modal_neg_super & aux_verb_word &
  [ SYNSEM.LOCAL.KEYS.KEY.LABEL *cons* ].

va_modal_neg_le := modal_verb_word & generic_modal_neg.
va_modal_subj_neg_le := modal_verb_word & generic_modal_neg & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD modal_subj* ].

va_ought_neg_le := ought_verb_word & generic_modal_neg_super.


; *** Auxiliary DO ***

; For tag questions we need the KEY of auxiliary _do_ to match all main verbs.
; The supertype for this is v_event_rel.  Originally, it had been no_rel, to 
; block _do_'s being a complement of other auxiliaries.  On the hypothesis
; that auxiliary _do_ in fact lacks a non-finite form all together, the
; do_aux_word type is constrained to VFORM fin, inherited from bse_aux_verb_word.

do_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ TAM #tam,
				VOICE active,
                                MOD < [ LOCAL intersective_mod &
                                              [ CAT nbar_cat ] ] > ],
                         VAL [ SUBJ < synsem & 
				      [ LOCAL [ CAT nomp_cat_nom_min,
						KEYS.MESSAGE 0-dlist,
						CONJ cnil ] ] >,
			       COMPS.FIRST.LOCAL [ CAT.HEAD.AUX -,
						   CONT [ TOP #ctop,
							  INDEX #index ] ] ] ],
		   CONT psoa & [ INDEX #index & [ E #tam ] ] ,
		   KEYS.KEY mod_role_rel & [ HANDEL #ctop ] ] ].

; Removed raise-cont from parents, to allow EVENT to not be identified with the
; comp-dtr's EVENT   - is in conflict with collapsing of base and fin-non3rdsg 
; forms, given that we encode VIT attributes in the event feature structure.
; Sample problem: "Kim does sleep"

do_fin := do_aux_word & raise_cont & 
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin*,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] >,
				PRD - ],
			 POSTHEAD +,
			 VAL [ SUBJ < [ OPT - ] >,
			       COMPS.FIRST.LOCAL.CONT.TOP #hand ] ],
		   CONT [ TOP #hand,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

do_aux_neg_word := do_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT [ TOP #chand,
                                                    INDEX #index ],
		   CONT [ --TOPKEY #altkey,
                          INDEX #index,
			  LISZT <! neg_rel & #altkey &
				 [ ARG #arghand ] !>,
			  H-CONS <! qeq &
				  [ SC-ARG #arghand,
				    OUTSCPD #chand ] !> ] ] ].

do_pres := do_fin &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM ind_or_mod_subj_tam &
                                  [ TENSE present*,
                                    ASPECT no_aspect*,
                                    MOOD indicative* ],
                         VAL.SUBJ < [ LOCAL.CONT.INDEX.PNG #png ] > ],
                   AGR.PNG #png ] ].

va_does_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.INDEX.PNG png & [ PN 3sg ] ] > ].

va_do_fin_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ 
			     < [ LOCAL.CONT.INDEX.PNG png & 
						      [ PN non3sg & 
							   strict_sort ] ] > ].

va_did_le := do_fin &

  [ SYNSEM.LOCAL.CAT.HEAD.TAM past_or_subj_tam ].

do_aux_neg_pres := do_aux_neg_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE present*,
				ASPECT no_aspect*,
				MOOD indicative* ] ].

va_do_neg_past_le := do_aux_neg_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM past_or_subj_tam ].

; ERB (31-03-97) The agreement on do, but not have and be, was previously
; taken care of in lexicon.tdl.  I am making these types to move that
; information here for symmetry.  The rest of the do paradigm seems
; to be generated by lexical rules, so these two are the only types.

va_doesnt_neg_pres_le := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

va_dont_neg_pres_le := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

; *** Perfect HAVE ***

have_aux_word := psp_aux_verb_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD.TAM.ASPECT perf*,
                   KEYS.KEY have_aux_rel ] ].

have_aux_pos_lex_entry := have_aux_word & topkey &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT [ TOP #hand,
						  INDEX #index ] ] >,
		   CONT [ TOP #hand,
			  INDEX #index,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

have_aux_neg_lex_entry := have_aux_word &
  [ SYNSEM lex_synsem &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin*,
				  PRD -,
				  MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] > ],
			   POSTHEAD +,
			   VAL [ SUBJ < [ OPT - ] >,
				 COMPS.FIRST
				      [ LOCAL.CONT [ TOP #chand,
						     INDEX #vind ] ] ] ],
		     CONT [ --TOPKEY #altkey,
			    INDEX #vind,
			    LISZT <! neg_rel & #altkey &
				   [ ARG #arghand ] !>,
			    H-CONS <! qeq &
				    [ SC-ARG #arghand,
				      OUTSCPD #chand ] !> ] ] ] ].

have_fin := have_aux_word &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin*,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] >,
				PRD - ],
			 POSTHEAD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      KEYS.MESSAGE 0-dlist,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

have_pres := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE present*,
				ASPECT perf*,
				MOOD indicative* ] ].

have_past := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE past*,
				ASPECT perf*,
				MOOD indicative* ] ].

have_subj := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ ASPECT perf*,
				MOOD subjunctive ] ].

;; We make "having" be [PRD -] to block "Kim is having fallen" and (the
;; restrictive reading of) "The book having fallen is red".  We will also 
;; exclude possibly grammatical examples like "anyone having seen that movie ..."
;; but there are no attested instances of these in the full BNC.

va_have_prespart_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD -,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat,
						CONT [ TOP #hand,
						       INDEX #nind ] ] ] > ],
			 VAL.SUBJ < [ LOCAL.CONT.INDEX #nind ] > ],
		   CONT.TOP #hand ] ].

va_have_bse_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ PRD -,
                                VFORM bse_only,
                                TAM.ASPECT perf* ],
                         VAL.SUBJ < unexpressed > ],
		   CONT psoa ] ].

has_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.CONT.INDEX.PNG png & 
						       [ PN 3sg ] ] > ].

va_has_le :< has_aux_lex_ent.

va_has_cx_le := has_aux_lex_ent & contracted_aux_word.

have_fin_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

va_have_fin_le :< have_fin_aux_lex_ent.

va_have_fin_cx_le := have_fin_aux_lex_ent & contracted_aux_word.

had_aux_lex_ent := have_aux_pos_lex_entry & have_past.

va_had_subj_le := have_aux_pos_lex_entry & have_subj.

va_had_le :< had_aux_lex_ent.

va_had_cx_le := had_aux_lex_ent & contracted_aux_word.

va_has_neg_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

va_have_fin_neg_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

va_had_neg_le := have_aux_neg_lex_entry & have_past.

va_had_subj_neg_le := have_aux_neg_lex_entry & have_subj.

; *** Generic BE ***

be_verb := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTED +,
    SYNSEM.LOCAL.CAT [ HEAD.AUX +*,
		       VAL [ SUBJ < synsem_min & 
				    [ LOCAL [ CAT nomp_cat_min,
					      CONJ cnil ] ] >,
			     COMPS < synsem & [ OPT - ], ... > ] ] ].
be_fin := be_verb &
  [ SYNSEM.LOCAL non_perf &
		 [ CAT [ HEAD [ VFORM fin*,
				PRD -,
				TAM.ASPECT strict_nonprf,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] > ],
			 POSTHEAD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      KEYS.MESSAGE 0-dlist,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

be_pres := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE present*,
				MOOD indicative* ] ].

be_past := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                              [ TENSE past*,
				MOOD indicative* ] ].
be_subj := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; Make be_prespart unmarked for PRD so we can block the identity-copula reading
; for "Kim is being good" while allowing the predicative-copula reading.

be_prespart := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
                                TAM.ASPECT progr*,
				MOD < [ LOCAL intersective_mod & 
					      [ CAT nbar_cat,
						CONT.INDEX #nind ] ] > ],
			 VAL.SUBJ < [ LOCAL.CONT.INDEX #nind ] > ] ] ].

be_pastpart := be_verb &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT.HEAD [ VFORM psp,
                              TAM.ASPECT perf*,
			      PRD - ],
		   CONT psoa ] ]. 
be_neg := sign &
  [ INFLECTED +,
    SYNSEM lex_synsem &
	   [ LOCAL [ KEYS [ KEY.HANDEL #khand,
			    ALTKEY neg_rel & #altkey &
				       [ ARG #arghand ] ],
		     CONT [ --TOPKEY #altkey,
			    H-CONS <! qeq &
				    [ SC-ARG #arghand,
				      OUTSCPD #khand ]!> ] ] ] ].

be_be_lex_entry := be_verb & 
  [ STEM < "be" >,
    SYNSEM.LOCAL nomod_local &
	 [ CAT [ HEAD [ PRD -,
			VFORM bse,
			TAM.ASPECT nonprf ],
		 VAL.SUBJ < unexpressed & [ OPT - ] > ] ] ].

be_being_lex_entry := be_prespart & 
  [ STEM < "being" > ].

be_been_lex_entry := be_pastpart & 
  [ STEM < "been" > ].

be_pres_lex_entry := be_pres.

be_past_lex_entry := be_past.

be_subj_lex_entry := be_subj.

be_pres_neg_lex_entry := be_pres & be_neg.
be_past_neg_lex_entry := be_past & be_neg.
be_subj_neg_lex_entry := be_subj & be_neg.

be_am_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg ] ].

be_is_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_subjnct_lex_entry := be_subj_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_subjnct_lex_entry :< be_subj_lex_entry.

be_am_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.INV +,
                   AGR.PNG png & [ PN 1sg ] ] ].

be_is_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_was_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_were_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; *** Copula BE ***

; DPF 27-Nov-99 - Made KEY.HANDEL identified with COMPS.KEYS.KEY.HANDEL,
; to avoid assymetry of HANDEL and LABEL for VM, which was causing errors
; for e.g. "it is really going to be".  This used to lose a possible ambiguity
; for e.g. "kim is not sleeping", since the support_rel will always be in
; the scope of the negation, regardless of whether the "not" attaches to
; "be" or to the complement phrase.  
; DPF 01-Mar-00 - But now that we've eliminated support_rels, it may work ok.

be_copula := prd_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM #tam,
			 VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.TAM #tam,
                                                 CONT.TOP #hand ] ],
                   KEYS.KEY _be_prd_rel & [ HANDEL #hand ] ] ].

be_cop_pos_generic := be_copula &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.TOP #top,
		   CONT [ TOP #top,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

be_cop_pos := be_cop_pos_generic &
 [ SYNSEM.LOCAL non_perf ].

be_cop_neg := be_copula &
  [ SYNSEM.LOCAL non_perf &
		 [ KEYS.ALTKEY #altkey,
		   CONT [ --TOPKEY #altkey,
			  LISZT <! #altkey !> ] ] ].

; The non-empty COMPS..MOD blocks "I am going to be going to be arriving"
vc_prd_be_le := be_be_lex_entry & be_cop_pos_generic &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD < synsem > ] > ].

vc_prd_being_le := be_being_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.CAT [ HEAD.PRD +,
		       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM non_prp ] ].
; The non-empty COMPS..MOD blocks "I am going to have been going to have
; been arriving"
vc_prd_been_le := be_been_lex_entry & be_cop_pos_generic &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD < synsem > ] > ].
vc_prd_am_le := be_am_lex_entry & be_cop_pos.
vc_prd_am_cx_le := be_am_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_is_le := be_is_lex_entry & be_cop_pos.
vc_prd_is_cx_le := be_is_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_are_le := be_are_lex_entry & be_cop_pos.
vc_prd_was_le := be_was_lex_entry & be_cop_pos.
vc_prd_was_subj_le := be_was_subjnct_lex_entry & be_cop_pos.
vc_prd_were_le := be_were_lex_entry & be_cop_pos.
vc_prd_were_subj_le := be_were_subjnct_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg & strict_sort ] ].

vc_prd_am_neg_le := be_am_neg_contr_lex_entry & be_cop_neg.
vc_prd_is_neg_le := be_is_neg_contr_lex_entry & be_cop_neg.
vc_prd_are_neg_le := be_are_neg_contr_lex_entry & be_cop_neg.
vc_prd_was_neg_le := be_was_neg_contr_lex_entry & be_cop_neg.
vc_prd_was_neg_subj_le := be_was_subjnct_neg_contr_lex_entry & be_cop_neg.
vc_prd_were_neg_le := be_were_neg_contr_lex_entry & be_cop_neg.
vc_prd_were_neg_subj_le := be_were_subjnct_neg_contr_lex_entry & be_cop_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg & strict_sort ] ].

; *** Identity BE ***
; For now, exclude gerundive complements, to avoid semantically anomalous
; reading for "Kim is sleeping"
; DPF 08-Jan-00 Made COMP be nom_rel instead of reg_nom_rel, to allow "Tuesday
; is my last day" and "that's him".
; DPF 22-Feb-01 - Added ALTKEY restriction on SUBJ to prevent free relatives
; from appearing in subject position, to get the contrast of "I admire what
; you are" vs. "*I admire what are you" (and cf. "I admire what is best").

id_cop_verb := aux_verb & two_arg_subst & basic_two_arg &
  [ LOCAL [ CAT [ HEAD.TAM.ASPECT nonprg,
                  VAL [ SUBJ < [ LOCAL [ KEYS.ALTKEY i_or_e_quant_rel_or_no_rel,
                                         CONT [ TOP #top,
                                                INDEX #id1ind & ref-ind ] ] ]>,
                        COMPS < [ LOCAL [ CAT nomp_cat_min & 
                                              [ HEAD [ PRD -,
                                                       MOD < > ] ],
                                          CONT 
                                              [ TOP #top,
                                                INDEX #id2ind & ref-ind ],
					  KEYS.KEY nom_rel,
                                          CONJ cnil ] ] > ] ],
	    CONT.TOP #top,
	    KEYS.KEY _cop_id_rel &
			   [ ARG1 #id1ind,
			     ARG3 #id2ind,
                             LABEL *cons* ] ] ].

be_id := be_verb &
  [ SYNSEM id_cop_verb &
	   [ LOCAL.CONT [ INDEX #event,
			  LISZT.LIST.FIRST.EVENT #event ] ] ].

be_id_pos := be_id & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT [ LISZT <! #key !>,
			  H-CONS <! !> ] ] ].

be_id_neg_synsem :< id_cop_verb.

be_id_neg := be_id &
  [ SYNSEM be_id_neg_synsem & 
	   [ LOCAL [ KEYS [ KEY #key,
			    ALTKEY #altkey ],
		     CONT.LISZT <! #key, #altkey !> ] ] ].

vc_id_be_le := be_be_lex_entry & be_id & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT [ LISZT <! #key !>,
			  H-CONS <! !> ] ] ].

vc_id_being_le := be_being_lex_entry & be_id_pos.
vc_id_been_le := be_been_lex_entry & be_id_pos.
vc_id_am_le := be_am_lex_entry & be_id_pos.
vc_id_am_cx_le := be_am_lex_entry & be_id_pos & contracted_aux_word.
vc_id_is_le := be_is_lex_entry & be_id_pos.
vc_id_is_cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word.
vc_id_are_le := be_are_lex_entry & be_id_pos.
vc_id_was_le := be_was_lex_entry & be_id_pos.
vc_id_was_subj_le := be_was_subjnct_lex_entry & be_id_pos.
vc_id_were_le := be_were_lex_entry & be_id_pos.
vc_id_were_subj_le := be_were_subjnct_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg & strict_sort ] ].

vc_id_am_neg_le := be_am_neg_contr_lex_entry & be_id_neg.
vc_id_is_neg_le := be_is_neg_contr_lex_entry & be_id_neg.
vc_id_are_neg_le := be_are_neg_contr_lex_entry & be_id_neg.
vc_id_was_neg_le := be_was_neg_contr_lex_entry & be_id_neg.
vc_id_was_neg_subj_le := be_was_subjnct_neg_contr_lex_entry & be_id_neg.
vc_id_were_neg_le := be_were_neg_contr_lex_entry & be_id_neg.
vc_id_were_neg_subj_le := be_were_subjnct_neg_contr_lex_entry & be_id_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg & strict_sort ] ].

; *** There Copula BE ***

;; The relationship between the first COMP and the second cannot be one of
;; raising (since if the first is extracted its SLASH will be non-empty, and
;; that non-empty SLASH would also erroneously appear on the VP.  So the 
;; control relation must be equi rather than raising.
;; DPF 2-May-01 - HACK: To avoid spurious ambiguity temporarily, block second 
;; arg by changing its KEY from independent_rel to no_rel.

there_cop_verb := aux_verb & unsat_three_arg_subst & basic_three_arg &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL [ CONT.INDEX there-ind &
					   [ PNG [ PN #pn,
                                                   GEN no_gend_there ] ] ] ] >,
		      COMPS < synsem &
			    [ LOCAL [ AGR non_expl-ind &
					  [ PNG [ PN #pn,
                                                  GEN neut ] ],
                                      CAT np_cat_acc_min,
				      CONT.INDEX #cind,
				      CONJ cnil,
                                      KEYS.KEY nonpro_rel & [ HANDEL #chand ]],
			      OPT - ],
			    [ LOCAL local &
				    [ CAT [ HEAD [ PRD +,
                                                   TAM.TENSE no_tense ],
					    VAL [ SUBJ < synsem & 
							 [ LOCAL.CONT.INDEX 
									  #cind,
							   NON-LOCAL.SLASH 
								      0-dlist ]>,
						  SPR *olist*,
						  COMPS *olist* ],
					    MC na ],
                                      CONT.TOP #chand,
                                      KEYS.KEY no_rel ],
                              OPT + ] > ],
	    KEYS.KEY _there_cop_rel &
			 [ ARG3 #cind,
                           LABEL *cons* ] ] ].

be_th_cop := be_verb & 
  [ SYNSEM there_cop_verb ].

be_th_cop_pos := be_th_cop & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key & [ EVENT #event ],
		   CONT [ INDEX #event,
			  LISZT <! #key !>,
			  H-CONS <! !> ] ] ].

th_cop_neg_aux_verb :< there_cop_verb.

be_th_cop_neg := be_th_cop &
  [ SYNSEM th_cop_neg_aux_verb &
	   [ LOCAL [ KEYS [ KEY #key,
			    ALTKEY #altkey ],
		     CONT [ LISZT <! #key, #altkey !>,
			    --TOPKEY #altkey ] ] ] ].

vc_there_be_le := be_be_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse_only ].

#|
vc_there_be_le := be_be_lex_entry & be_th_cop &
  [ SYNSEM.LOCAL [ CAT.HEAD.VFORM bse_only,
                   KEYS.KEY #key & [ EVENT #event ],
		   CONT [ INDEX #event,
			  LISZT <! #key !>,
			  H-CONS <! !> ] ] ].
|#

vc_there_being_le := be_being_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].
vc_there_been_le := be_been_lex_entry & be_th_cop_pos.
vc_there_is_le := be_is_lex_entry & be_th_cop_pos.
vc_there_are_le := be_are_lex_entry & be_th_cop_pos.
vc_there_was_le := be_was_lex_entry & be_th_cop_pos.
vc_there_was_subj_le := be_was_subjnct_lex_entry & be_th_cop_pos.
vc_there_were_le := be_were_lex_entry & be_th_cop_pos.
vc_there_were_subj_le := be_were_subjnct_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg & strict_sort ] ].

vc_there_s_cx_le := be_pres_lex_entry & be_th_cop_pos & contracted_aux_word.
vc_there_is_neg_le := be_is_neg_contr_lex_entry & be_th_cop_neg.
vc_there_are_neg_le := be_are_neg_contr_lex_entry & be_th_cop_neg.
vc_there_was_neg_le := be_was_neg_contr_lex_entry & be_th_cop_neg.
vc_there_was_neg_subj_le := be_was_subjnct_neg_contr_lex_entry & be_th_cop_neg.
vc_there_were_neg_le := be_were_neg_contr_lex_entry & be_th_cop_neg.
vc_there_were_neg_subj_le := be_were_subjnct_neg_contr_lex_entry & 
                             be_th_cop_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg & strict_sort ] ].
