;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  auxverbs.tdl
;;;
;;;  The auxiliary verb system for English
;;;
;;;  Created: Rob Malouf, 17-Nov-1994
;;;  Last revision: Dan Flickinger, 24-Feb-97
;;;
;;;  $Id$

; *** Future WILL ***

will_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
				VFORM fin,
                                TENSE future,
				MOOD indicative ],
			 VALENCE [ SUBJ @nomp($case=nom),
				   COMPS.FIRST.LOCAL.CONT [ HANDEL #hand,
							    INDEX #event &
							     [ TIME #e ] ] ] ],
		   CONT [ INDEX #event & [ SPCH #s ],
			  --STEMLISZT <! temp_prec_rel & #key &
				    [ HANDEL #hand,
				      EVENT1 #s,
				      LATER #e ] !>,
			  KEY #key ],
		   CTXT.C-INDS.SPEECH #s ] ].

will_aux_pos_le := will_aux_word & non_affix_bearing & nonhcons & lex_entry &
  [ SYNSEM.LOCAL.CONT [ HANDEL #hand,
			KEY.HANDEL #hand ] ].

will_aux_neg_mle1 := will_aux_word & multi_lex_entry1 &
  [ SYNSEM scoping_aux_verb &
	   [ LOCAL [ CAT [ VALENCE.COMPS.FIRST #comp,
			   --SCOPEDARG #comp & [ LOCAL.CONT.HANDEL #argh,
						 --ARG #arg,
						 --ARGH #argh ] ],
		     CONT [ HANDEL #hand,
			    --STEMLISZT [ LIST #list,
					  LAST #last ],
			    LISZT [ LIST < neg_rel &
					   [ HANDEL #hand,
					     ARG #arg ] . #list >,
				  LAST #last ] ] ] ] ].

;;; Modal verbs

modal_pos_le := pos_modal_verb_word & add_cont & non_affix_bearing & lex_entry.
ought_pos_le := pos_ought_verb_word & add_cont & non_affix_bearing & lex_entry.
past_ought_pos_le := past_ought_verb_word & add_cont & non_affix_bearing & lex_entry.

quasimodal_le := quasimodal_word & add_cont & non_affix_bearing & lex_entry.

generic_modal_neg := aux_verb_word &
  [ SYNSEM scoping_neg_aux_verb &
	   [ LOCAL [ CAT.--SCOPEDARG2.--ARG #arg,
		     CONT [ HANDEL #hand,
			    --STEMLISZT [ LIST #list & < #key, ... >,
					  LAST #last ],
			    LISZT [ LIST < neg_rel &
					   [ HANDEL #hand,
					     ARG #arg ] . #list >,
				    LAST #last ],
			    KEY #key ] ] ] ].

modal_neg_le := modal_verb_word & generic_modal_neg & lex_entry.
modal_neg_mle1 := modal_verb_word & generic_modal_neg & multi_lex_entry1.
ought_neg_mle1 := ought_verb_word & generic_modal_neg & multi_lex_entry1.


; *** Auxiliary DO ***

; For tag questions we need the KEY of auxiliary _do_ to match all main verbs.
; The supertype for this is event_rel.  Originally, it had been no_rel, to 
; block _do_'s being a complement of other auxiliaries.  On the hypothesis
; that auxiliary _do_ in fact lacks a non-finite form all together, the
; do_aux_word type is constrained to VFORM fin

do_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin,
				VOICE active ],
			 VALENCE [ SUBJ @nomp($case=nom),
				   COMPS.FIRST.LOCAL.CAT.HEAD.AUX - ] ],
		   CONT [ KEY mod_role_rel,
			  INDEX [ TIME #e,
				  REFERENCE #e ] ] ] ].

do_aux_pos_le := do_aux_word & raise_cont & affix_bearing & nonhcons & 
                 lex_entry.

do_aux_neg_word := do_aux_word & non_affix_bearing & multi_lex_entry1 &
  [ SYNSEM scopedarg_synsem & 
	   [ LOCAL [ CAT [ VALENCE.COMPS.FIRST #comp &
					       [ LOCAL.CONT.INDEX #vind ],
			   --SCOPEDARG #comp & [ LOCAL.CONT.HANDEL #argh,
						 --ARG #arg,
						 --ARGH #argh ] ],
		     CONT [ HANDEL #hand,
			    INDEX #vind,
			    --STEMLISZT.LIST < neg_rel &
					       [ HANDEL #hand,
						 ARG #arg ], ... > ] ] ] ].
do_aux_neg_pres := do_aux_neg_word &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE present,
			      MOOD indicative ],
		   CONT [ HANDEL #hand,
			  INDEX [ REFERENCE #r,
				  SPCH #s ],
			  --STEMLISZT <! neg_rel, temp_over_rel &
				     [ HANDEL #hand,
				    EVENT1 #r,
				       WHEN #s ] !> ],
		   CTXT.C-INDS.SPEECH #s ] ].

do_aux_neg_past_mle1 := do_aux_neg_word &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE past, 
			      MOOD indicative ],
		   CONT [ HANDEL #hand,
			  INDEX [ REFERENCE #r,
				  SPCH #s ],
			  --STEMLISZT <! neg_rel, temp_prec_rel &
				     [ HANDEL #hand,
				       EVENT1 #r,
				       LATER #s ] !> ],
		   CTXT.C-INDS.SPEECH #s ] ].

do_aux_neg_subj_mle1 := do_aux_neg_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOOD subjunctive,
		   CONT [ HANDEL #hand,
			  --STEMLISZT <! neg_rel, irrealis_rel &
				     [ HANDEL #hand ] !> ] ] ].

; ERB (31-03-97) The agreement on do, but not have and be, was previously
; taken care of in lexicon.tdl.  I am making these types to move that
; information here for symmetry.  The rest of the do paradigm seems
; to be generated by lexical rules, so these two are the only types.

doesnt_aux_neg_pres_mle1 := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.CAT.AGR.PNG 3sg ].

dont_aux_neg_pres_mle1 := do_aux_neg_pres &
  [ SYNSEM.LOCAL.CAT.AGR.PNG non3sg ].

; *** Perfect HAVE ***

have_aux_word := psp_aux_verb_word & non_affix_bearing &
  [ SYNSEM.LOCAL.CONT [ KEY #key,
			--TMP.HAVE.LIST < #key, ... > ] ].

have_aux_pos_lex_entry := have_aux_word & nonhcons & lex_entry &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS < [ LOCAL.CONT [ HANDEL #hand,
						      INDEX #index ] ] >,
		   CONT [ HANDEL #hand,
			  INDEX #index,
			  --TMP.HAVE #liszt,
			  --STEMLISZT #liszt ] ] ].

have_aux_neg_lex_entry := have_aux_word & multi_lex_entry1 &
  [ SYNSEM scopedarg_synsem &
	   [ LOCAL [ CAT [ HEAD.VFORM fin,
			   VALENCE.COMPS.FIRST #comp &
				      [ LOCAL.CONT.INDEX #vind ],
			   --SCOPEDARG #comp & [ LOCAL.CONT.HANDEL #argh,
						 --ARG #arg,
						 --ARGH #argh ] ],
		     CONT [ HANDEL #hand,
			    INDEX #vind,
			    --TMP [ HAVE [ LIST #list,
					   LAST #last ],
				    NEG #neg & [ LIST < neg_rel &
							[ HANDEL #hand,
							  ARG #arg ] . #list >,
						 LAST #last ] ],
			    --STEMLISZT #neg ] ] ] ].

have_fin := have_aux_word &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ VFORM fin,
				PRD - ],
			 VALENCE.SUBJ @nomp($case=nom) ] ] ].

have_pres := have_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE presperf,
			      MOOD indicative ],
		   CONT [ HANDEL #hand,
			  INDEX [ REFERENCE #r,
				  SPCH #s ],
			  --TMP.HAVE <! temp_over_rel &
				    [ HANDEL #hand,
				      EVENT1 #r,
				      WHEN #s ] !> ],
		   CTXT.C-INDS.SPEECH #s ] ].

have_past := have_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE pastperf,
			      MOOD indicative ],
		   CONT [ HANDEL #hand,
			  INDEX [ REFERENCE #r,
				  SPCH #s ],
			  --TMP.HAVE <! temp_prec_rel &
				    [ HANDEL #hand,
				      EVENT1 #r,
				      LATER #s ] !> ],
		   CTXT.C-INDS.SPEECH #s ] ].

have_subj := have_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE pastperf,
			      MOOD subjunctive ],
		   CONT [ HANDEL #hand,
			  --TMP.HAVE <! irrealis_rel &
				    [ HANDEL #hand ] !> ] ] ].

have_prespart_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD + ],
			 VALENCE.SUBJ.LOCAL.CONT.INDEX #nind,
			 MOD [ CAT [ HEAD noun,
				     VALENCE [ SPR < synsem >,
					       COMPS *olist* ] ],
			       CONT [ HANDEL #hand,
				      INDEX #nind ] ] ],
		   CONT [ HANDEL #hand,
			  KEY.HANDEL #hand,
			  INDEX.TIME #e,
			  MODCONT [ HANDEL #hand,
				    INDEX #nind,
				    LISZT <! !> ],
			  --TMP.HAVE <! prog_rel &
				    [ HANDEL #hand,
				      EVENT1 #e ] !> ] ] ].


have_bse_aux_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ PRD -,
				VFORM bse ] ],
		   CONT.--TMP.HAVE <! !> ] ].

has_aux_le := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.VALENCE.SUBJ @third-sg-np ( ) ].

have_fin_aux_le := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.AGR.PNG non3sg ].

had_aux_le := have_aux_pos_lex_entry & have_past.

had_aux_subj_le := have_aux_pos_lex_entry & have_subj.

has_aux_neg_mle1 := have_aux_neg_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.AGR.PNG 3sg ].

have_fin_aux_neg_mle1 := have_aux_neg_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.AGR.PNG non3sg ].

had_aux_neg_mle1 := have_aux_neg_lex_entry & have_past.

had_aux_subj_neg_mle1 := have_aux_neg_lex_entry & have_subj.

; *** Generic BE ***

be_verb := hcons_word & non_affix_bearing &
  [ SYNSEM.LOCAL.CAT [ HEAD.AUX +,
		       VALENCE [ SUBJ synsem & [ LOCAL.CAT.HEAD nominal ],
				 COMPS < synsem & [ OPT - ], ... > ] ] ].
be_fin := be_verb &
  [ SYNSEM.LOCAL non_perf & nomod_local &
		 [ CAT [ HEAD.VFORM fin,
			 VALENCE.SUBJ @nomp($case=nom) ] ] ].
be_pres := be_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE present,
			      MOOD indicative ],
		   CONT [ INDEX [ REFERENCE #r,
				  SPCH #s ],
			  --TMP.BE <! temp_over_rel &
				  [ HANDEL #hand,
				    EVENT1 #r,
				    WHEN #s ] !>,
			  KEY.HANDEL #hand ],
		   CTXT.C-INDS.SPEECH #s ] ].

be_past := be_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE past,
			      MOOD indicative ],
		   CONT [ INDEX [ REFERENCE #r,
				  SPCH #s ],
			  --TMP.BE <! temp_prec_rel &
				  [ HANDEL #hand,
				    EVENT1 #r,
				    LATER #s ] !>,
			  KEY.HANDEL #hand ],
		   CTXT.C-INDS.SPEECH #s ] ].

be_subj := be_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOOD subjunctive,
		   CONT.--TMP.BE <! irrealis_rel !> ] ].

be_prespart := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD + ],
			 VALENCE.SUBJ.LOCAL.CONT.INDEX #nind,
			 MOD [ CAT [ HEAD noun,
				     VALENCE [ SPR < synsem >,
					       COMPS *olist* ] ],
			       CONT [ HANDEL #hand,
				      INDEX #nind ] ] ],
		   CONT [ HANDEL #hand,
			  INDEX.TIME #e,
			  --TMP.BE <! prog_rel &
				  [ HANDEL #hand,
				    EVENT1 #e ] !> ] ] ].

be_pastpart := be_verb &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ VFORM psp,
				PRD - ] ],
		   CONT [ HANDEL #hand,
			  INDEX [ TIME #e,
				  REFERENCE #r ],
			  --TMP.BE <! temp_prec_rel &
				  [ HANDEL #hand,
				    EVENT1 #e,
				    LATER #r ] !> ] ] ].
be_neg := sign &
  [ SYNSEM scopedarg_neg_aux_synsem &
	   [ LOCAL [ CAT.--SCOPEDARG2.--ARG #arg,
		     CONT [ HANDEL #hand,
			    --TMP [ BE [ LIST #list,
					 LAST #last ],
				    NEG [ LIST < neg_rel &
						 [ HANDEL #hand,
						   ARG #arg ] . #list >,
					  LAST #last ] ] ] ] ] ].

be_be_lex_entry := be_verb & lex_entry &
  [ STEM < "be" >,
    SYNSEM.LOCAL nomod_local &
	 [ CAT.HEAD [ PRD -,
		      VFORM bse ] ] ].

be_being_lex_entry := be_prespart & lex_entry & 
  [ STEM < "being" > ].

be_been_lex_entry := be_pastpart & lex_entry & 
  [ STEM < "been" > ].

be_pres_lex_entry := be_pres & lex_entry &
  [ SYNSEM.LOCAL.CONT [ HANDEL #hand,
			KEY.HANDEL #hand ] ].
be_past_lex_entry := be_past & lex_entry & 
  [ SYNSEM.LOCAL.CONT [ HANDEL #hand,
			KEY.HANDEL #hand ] ].
be_pres_neg_lex_entry := be_pres & be_neg & multi_lex_entry.
be_past_neg_lex_entry := be_past & be_neg & multi_lex_entry.

be_am_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.CAT.AGR.PNG 1sg ].

be_is_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.CAT.AGR.PNG 3sg ].

be_are_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.CAT.AGR.PNG non1sg ].

be_was_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.CAT.AGR.PNG 1or3sg ].

be_were_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.CAT.AGR.PNG non1sg ].

be_am_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV +,
		       AGR.PNG 1sg ] ].

be_is_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT.AGR.PNG 3sg ].

be_are_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT.AGR.PNG non1sg ].

be_was_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT.AGR.PNG 1or3sg ].

be_were_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT.AGR.PNG non1sg ].

; *** Copula BE ***

be_copula := prd_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS.FIRST.LOCAL.CONT.MODCONT.LISZT
                                                       [ LIST #list,
							 LAST #last ],
		   CONT [ HANDEL #hand,
			  INDEX #event,
			  KEY #key,
			  --TMP.BE_COP *diff-list* &
				 [ LIST < support_rel & #key &
					  [ HANDEL #hand,
					    EVENT #event,
					    VARG #arg,
					    ARG #arg ]
					  . #list >,
				   LAST #last ] ] ] ].

be_copula_non_bse := be_copula &
  [ SYNSEM.LOCAL.CONT [ KEY.EVENT.TIME #eventtime,
			--TMP.BE.LIST.FIRST.EVENT1 #eventtime ] ].


be_cop_pos_generic := be_copula & 
  [ SYNSEM.LOCAL.CONT [ --TMP [ BE #liszt1,
			      BE_COP #liszt2,
			      BE_COP_POS dl-append &
				 [ ARG1 #liszt1,
				   ARG2 #liszt2,
				   RES #resliszt ] ],
			--STEMLISZT #resliszt ] ].

be_cop_pos := be_cop_pos_generic & be_copula_non_bse & nonhcons & 
 [ SYNSEM.LOCAL non_perf ].

be_cop_neg := be_copula &
  [ SYNSEM scoping_neg_aux_verb &
	   [ LOCAL non_perf &
		   [ CONT [ --TMP [ NEG #liszt1,
				    BE_COP #liszt2,
				    BE_COP_NEG dl-append &
					[ ARG1 #liszt1,
					  ARG2 #liszt2,
					  RES #resliszt ] ],
			    --STEMLISZT #resliszt ] ] ] ].

be_c_be_le := be_be_lex_entry & be_cop_pos_generic &
  [ SYNSEM.LOCAL non_perf & [ CONT.--TMP.BE <! !> ] ].
be_c_being_le := be_being_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.CAT.VALENCE.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM ~prp ].
be_c_been_le := be_been_lex_entry & be_cop_pos_generic.
be_c_am_le := be_am_lex_entry & be_cop_pos.
be_c_is_le := be_is_lex_entry & be_cop_pos.
be_c_are_le := be_are_lex_entry & be_cop_pos.
be_c_was_le := be_was_lex_entry & be_cop_pos.
be_c_were_le := be_were_lex_entry & be_cop_pos.
be_c_am_neg_le := be_am_neg_contr_lex_entry & be_cop_neg.
be_c_is_neg_le := be_is_neg_contr_lex_entry & be_cop_neg.
be_c_are_neg_le := be_are_neg_contr_lex_entry & be_cop_neg.
be_c_was_neg_le := be_was_neg_contr_lex_entry & be_cop_neg.
be_c_were_neg_le := be_were_neg_contr_lex_entry & be_cop_neg.

; *** Identity BE ***

cop_id_rel := role_rel &
	      [ ID1 non_expl-ind & #id1,
		ID2 non_expl-ind & #id2,
		ARG1 #id1,
		ARG3 #id2 ].
  
id_cop_verb := verb_synsem & two_arg_subst &
  [ LOCAL [ CAT [ VALENCE [ SUBJ.LOCAL.CONT.INDEX #id1ind,
			    COMPS < [ LOCAL 
				       [ CAT [ HEAD noun,
					       VALENCE [ SUBJ none,
							 SPR *olist*,
							 COMPS *olist* ] ],
					 CONT.INDEX #id2ind ] ] > ] ],
	    CONT [ --TMP [ BE.LIST.FIRST.EVENT1 #eventtime,
			 BE_ID <! cop_id_rel & #key &
				[ EVENT.TIME #eventtime,
				  ID1 #id1ind,
				  ID2 #id2ind ] !> ],
		   KEY #key ] ] ].

be_id := be_verb &
  [ SYNSEM id_cop_verb ].

be_id_pos := be_id & nonhcons &
  [ SYNSEM.LOCAL.CONT [ INDEX #event,
			--TMP [ BE #liszt1 & <! [ HANDEL #idhand ] !>,
			      BE_ID #liszt2 & <! [ HANDEL #idhand,
						   EVENT #event ] !>,
			      BE_ID_POS dl-append &
				 [ ARG1 #liszt1,
				   ARG2 #liszt2,
				   RES [ LIST #reslist,
					 LAST #reslast ] ] ],
			--STEMLISZT [ LIST #reslist,
				      LAST #reslast ] ] ].

be_id_neg_synsem := id_cop_verb & scopedarg_neg_aux_synsem.

be_id_neg := be_id &
  [ SYNSEM be_id_neg_synsem & 
	   [ LOCAL.CONT [ --TMP [ NEG #liszt1,
				  BE_ID #liszt2,
				  BE_ID_NEG dl-append &
				      [ ARG1 #liszt1,
					ARG2 #liszt2,
					RES #resliszt ] ],
			  --STEMLISZT #resliszt ] ] ].

be_id_be_le := be_be_lex_entry & be_id &
  [ SYNSEM.LOCAL.CONT [ INDEX #event,
			--TMP.BE_ID #liszt &
			      [ LIST.FIRST.EVENT #event ],
			--STEMLISZT #liszt ] ].

be_id_being_le := be_being_lex_entry & be_id_pos.
be_id_been_le := be_been_lex_entry & be_id_pos.
be_id_am_le := be_am_lex_entry & be_id_pos.
be_id_is_le := be_is_lex_entry & be_id_pos.
be_id_are_le := be_are_lex_entry & be_id_pos.
be_id_was_le := be_was_lex_entry & be_id_pos.
be_id_were_le := be_were_lex_entry & be_id_pos.
be_id_am_neg_le := be_am_neg_contr_lex_entry & be_id_neg.
be_id_is_neg_le := be_is_neg_contr_lex_entry & be_id_neg.
be_id_are_neg_le := be_are_neg_contr_lex_entry & be_id_neg.
be_id_was_neg_le := be_was_neg_contr_lex_entry & be_id_neg.
be_id_were_neg_le := be_were_neg_contr_lex_entry & be_id_neg.

; *** There Copula BE ***

_there_cop_rel := event_rel &
  [ ARG3 non_expl-ind ].
  
there_cop_verb := verb_synsem & three_arg_subst &
  [ LOCAL [ CAT [ VALENCE [ SUBJ.LOCAL.CONT.INDEX there-ind &
						[ PNG #png ],
			  COMPS < #subj &
				  [ LOCAL [ CAT [ HEAD noun & [ CASE acc ],
						  AGR non_expl-ind &
						       [ PNG #png ],
						  VALENCE [ SUBJ none,
							    SPR *olist*,
							    COMPS *olist* ] ],
					    CONT.INDEX #cind ],
				    OPT - ],
				  [ LOCAL local &
					[ CAT [ HEAD.PRD +,
						VALENCE [ SUBJ synsem & #subj,
							  SPR *olist*,
							  COMPS *olist* ],
						ROOT na ],
					  CONT [ HANDEL #hand,
						 MODCONT.LISZT [ LIST #list,
								 LAST #last]]],
				    OPT + ] > ] ],
	    CONT [ --TMP [ BE.LIST.FIRST.EVENT1 #eventtime,
			   BE_TH_COP *diff-list* &
				     [ LIST < _there_cop_rel & #key &
					      [ HANDEL #hand,
						EVENT.TIME #eventtime,
						ARG3 #cind ]
					      . #list >,
				       LAST #last ] ],
		   KEY #key ] ] ].

be_th_cop := be_verb & 
  [ SYNSEM there_cop_verb ].

be_th_cop_pos := be_th_cop & nonhcons &
  [ SYNSEM.LOCAL.CONT [ INDEX #event,
			--TMP [ BE #liszt1 & <! [ HANDEL #idhand ] !>,
				BE_TH_COP #liszt2 & 
				   [ LIST < [ HANDEL #idhand,
					      EVENT #event ], ... > ],
				BE_TH_COP_POS dl-append &
				 [ ARG1 #liszt1,
				   ARG2 #liszt2,
				   RES [ LIST #reslist,
					 LAST #reslast ] ] ],
			--STEMLISZT [ LIST #reslist,
				      LAST #reslast ] ] ].

th_cop_neg_aux_verb := there_cop_verb & scopedarg_neg_aux_synsem.

be_th_cop_neg := be_th_cop &
  [ SYNSEM th_cop_neg_aux_verb &
	   [ LOCAL.CONT [ --TMP [ NEG #liszt1,
				  BE_TH_COP #liszt2,
				  BE_TH_COP_NEG dl-append &
				      [ ARG1 #liszt1,
					ARG2 #liszt2,
					RES #resliszt ] ],
			  --STEMLISZT #resliszt ] ] ].

be_th_cop_be_le := be_be_lex_entry & be_th_cop &
  [ SYNSEM.LOCAL.CONT [ INDEX #event,
			--TMP.BE_TH_COP #liszt &
			      [ LIST.FIRST.EVENT #event ],
			--STEMLISZT #liszt ] ].

be_th_cop_being_le := be_being_lex_entry & be_th_cop_pos.
be_th_cop_been_le := be_been_lex_entry & be_th_cop_pos.
be_th_cop_is_le := be_is_lex_entry & be_th_cop_pos.
be_th_cop_are_le := be_are_lex_entry & be_th_cop_pos.
be_th_cop_was_le := be_was_lex_entry & be_th_cop_pos.
be_th_cop_were_le := be_were_lex_entry & be_th_cop_pos.
be_th_cop_s_cx_le := be_pres_lex_entry & be_th_cop_pos.
be_th_cop_is_neg_le := be_is_neg_contr_lex_entry & be_th_cop_neg.
be_th_cop_are_neg_le := be_are_neg_contr_lex_entry & be_th_cop_neg.
be_th_cop_was_neg_le := be_was_neg_contr_lex_entry & be_th_cop_neg.
be_th_cop_were_neg_le := be_were_neg_contr_lex_entry & be_th_cop_neg.

