;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  auxverbs.tdl
;;;
;;;  The auxiliary verb system for English
;;;
;;;  Created: Rob Malouf, 17-Nov-1994
;;;  Last revision: Dan Flickinger, 20-Oct-97
;;;
;;;  $Id$

#|
;;; Will, shall, would  --  patched for LKB

will_pos_lex_ent := pos_will_verb_word & add_cont & infl_lex_entry.
will_pos_le :< will_pos_lex_ent.
will_pos_cx_le := will_pos_lex_ent & contracted_aux_word.

|#

will_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.PRD -,
			 VAL [ SUBJ < @nomp_nom() >,
			       COMPS.FIRST.LOCAL.CONT.INDEX #event ] ],
		   CONT psoa & [ INDEX #event ] ] ].

will_aux_pos_lex_e := will_aux_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT [ TOP #hand,
						  KEY [ HANDEL #khand,
							LABEL #label ] ] ] >,
		   CONT [ TOP #hand,
			  KEY [ HANDEL #khand,
				LABEL #label ],
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

will_pos_le := will_aux_pos_lex_e & lex_entry.

will_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word & lex_entry.

will_neg_mle1 := will_aux_word & multi_lex_entry1 &
  [ SYNSEM aux_verb &
	   [ LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.TOP #chand,
		     CONT [ --TOPKEY #altkey,
			    LISZT <! neg_rel & #altkey &
				   [ ARG #chand ] !> ] ] ],
    ARGS < [ AFFIX no-affix ] , ... > ].


would_aux_pos_le := will_aux_pos_lex_e & lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MOOD modal_subj* ].

would_aux_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word & lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MOOD modal_subj* ].

would_aux_neg_mle1 := will_aux_word & multi_lex_entry1 &
  [ SYNSEM.LOCAL.CAT.HEAD.MOOD modal_subj* ].

;;; Modal verbs

modal_pos_lex_ent := pos_modal_verb_word & add_cont & infl_lex_entry.

modal_pos_le :< modal_pos_lex_ent.

modal_pos_cx_le := modal_pos_lex_ent & contracted_aux_word.

modal_subj_pos_lex_ent := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOOD modal_subj* ].

modal_subj_pos_le :< modal_subj_pos_lex_ent.

modal_subj_pos_cx_le := modal_subj_pos_lex_ent & contracted_aux_word.

ought_pos_le := pos_ought_verb_word & add_cont & infl_lex_entry.
past_ought_pos_le := past_ought_verb_word & add_cont & infl_lex_entry.

quasimodal_le := quasimodal_word & infl_lex_entry.

generic_modal_neg_super := aux_verb_word_super &
  [ SYNSEM.LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.TOP #chand,
		   CONT [ --TOPKEY #altkey,
			  LISZT <! neg_rel & #altkey &
				 [ ARG #khand ], 
				 #key !>,
			  KEY #key & [ HANDEL #khand,
				       ARG4 #arghand ],
			  H-CONS <! qeq &
				  [ SC-ARG #arghand,
				    OUTSCPD #chand ] !> ] ] ].

generic_modal_neg := generic_modal_neg_super & aux_verb_word.

modal_neg_le := modal_verb_word & generic_modal_neg & infl_lex_entry.
modal_neg_mle1 := modal_verb_word & generic_modal_neg & basic_mle1.
modal_subj_neg_mle1 := modal_verb_word & generic_modal_neg & basic_mle1 &
  [ SYNSEM.LOCAL.CAT.HEAD.MOOD modal_subj* ].

ought_neg_mle1 := ought_verb_word & generic_modal_neg_super & 
		  non_affix_bearing & basic_mle1.


; *** Auxiliary DO ***

; For tag questions we need the KEY of auxiliary _do_ to match all main verbs.
; The supertype for this is event_rel.  Originally, it had been no_rel, to 
; block _do_'s being a complement of other auxiliaries.  On the hypothesis
; that auxiliary _do_ in fact lacks a non-finite form all together, the
; do_aux_word type is constrained to VFORM fin, inherited from bse_aux_verb_word.

do_aux_word := bse_aux_verb_word &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT [ HEAD.VOICE active,
			   VAL [ SUBJ < @nomp_nom() >,
				 COMPS.FIRST.LOCAL [ CAT.HEAD.AUX -,
						     CONT.KEY #key ] ] ],
		     CONT psoa & [ KEY mod_role_rel & #key ] ] ] ].

; Removed raise-cont from parents, to allow EVENT to not be identified with the
; comp-dtr's EVENT   - is in conflict with collapsing of base and fin-non3rdsg 
; forms, given that we encode VIT attributes in the event feature structure.
; Sample problem: "Kim does sleep"

do_fin := do_aux_word & raise_cont & infl_lex_entry &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] >,
				PRD - ],
			 VAL [ SUBJ < @nomp_nom() &
				      [ OPT - ] >,
			       COMPS.FIRST.LOCAL.CONT.TOP #hand ] ],
		   CONT [ TOP #hand,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

do_aux_neg_word := do_aux_word & basic_mle1 &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.TOP #chand,
		     CONT [ --TOPKEY #altkey,
			    LISZT <! neg_rel & #altkey &
				   [ ARG #arghand ] !>,
			    H-CONS <! qeq &
				    [ SC-ARG #arghand,
				      OUTSCPD #chand ] !> ] ] ] ].

do_pres := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE present*,
			    MOOD indicative* ] ].

does_aux_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.INDEX.PNG png & [ PN 3sg ] ] > ].

do_fin_aux_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ 
			     < [ LOCAL.CONT.INDEX.PNG png & 
						      [ PN non3sg & 
							   strict_sort ] ] > ].
did_aux_le := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE past*,
			    MOOD indicative* ] ].

do_aux_neg_pres := do_aux_neg_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE present*,
			    MOOD indicative* ] ].

do_aux_neg_past_mle1 := do_aux_neg_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE past*,
			    MOOD indicative* ] ].

do_aux_neg_subj_mle1 := do_aux_neg_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOOD subjunctive ].

; ERB (31-03-97) The agreement on do, but not have and be, was previously
; taken care of in lexicon.tdl.  I am making these types to move that
; information here for symmetry.  The rest of the do paradigm seems
; to be generated by lexical rules, so these two are the only types.

doesnt_aux_neg_pres_mle1 := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

dont_aux_neg_pres_mle1 := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

; *** Perfect HAVE ***

have_aux_word := psp_aux_verb_word & non_affix_bearing &
  [ SYNSEM.LOCAL.CONT.KEY have_aux_rel ].

have_aux_pos_lex_entry := have_aux_word & infl_lex_entry & topkey &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT [ TOP #hand,
						  INDEX #index ] ] >,
		   CONT [ TOP #hand,
			  INDEX #index,
			  LISZT <! !>,
			  H-CONS <! !> ] ] ].

have_aux_neg_lex_entry := have_aux_word & basic_mle1 &
  [ SYNSEM lex_synsem &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD -,
				  MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] > ],
			   VAL [ SUBJ < [ OPT - ] >,
				 COMPS.FIRST
				      [ LOCAL.CONT [ TOP #chand,
						     INDEX #vind ] ] ] ],
		     CONT [ --TOPKEY #altkey,
			    INDEX #vind,
			    LISZT <! neg_rel & #altkey &
				   [ ARG #arghand ] !>,
			    H-CONS <! qeq &
				    [ SC-ARG #arghand,
				      OUTSCPD #chand ] !> ] ] ] ].

have_fin := have_aux_word &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] >,
				PRD - ],
			 VAL.SUBJ < @nomp_nom() &
					[ OPT - ] > ],
		   CONT psoa ] ].

have_pres := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE presperf*,
			    MOOD indicative* ] ].

have_past := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE pastperf*,
			    MOOD indicative* ] ].

have_subj := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE pastperf*,
			    MOOD subjunctive ] ].

;; We make "having" be [PRD -] to block "Kim is having fallen" and (the
;; restrictive reading of) "The book having fallen is red".  We will also 
;; exclude possibly grammatical examples like "anyone having seen that movie ..."
;; but there are no attested instances of these in the full BNC.

have_prespart_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD -,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat,
						CONT [ TOP #hand,
						       INDEX #nind ] ] ] > ],
			 VAL.SUBJ < [ LOCAL.CONT.INDEX #nind ] > ],
		   CONT.TOP #hand ] ].

; DPF (27-Apr-99) The value of TENSE here should probably be just "perf" rather
; than "presperf", but it's not clear.
have_bse_aux_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT.HEAD [ PRD -,
			      VFORM bse_only,
			      TENSE presperf* ],
		   CONT psoa ] ].

has_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < @nomp() & [ LOCAL.CONT.INDEX.PNG png & 
								 [ PN 3sg ] ] > ].

has_aux_le :< has_aux_lex_ent.

has_aux_cx_le := has_aux_lex_ent & contracted_aux_word.

have_fin_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

have_fin_aux_le :< have_fin_aux_lex_ent.

have_fin_aux_cx_le := have_fin_aux_lex_ent & contracted_aux_word.

had_aux_lex_ent := have_aux_pos_lex_entry & have_past.

had_aux_le :< had_aux_lex_ent.

had_aux_subj_le := have_aux_pos_lex_entry & have_subj.

had_aux_cx_le := had_aux_lex_ent & contracted_aux_word.

has_aux_neg_mle1 := have_aux_neg_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

have_fin_aux_neg_mle1 := have_aux_neg_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non3sg & strict_sort ] ].

had_aux_neg_mle1 := have_aux_neg_lex_entry & have_past.

had_aux_subj_neg_mle1 := have_aux_neg_lex_entry & have_subj.

; *** Generic BE ***

be_verb := mcna & nonconj & nonmsg & non_affix_bearing &
  [ SYNSEM.LOCAL.CAT [ HEAD.AUX +*,
		       VAL [ SUBJ < @nomp() >,
			     COMPS < synsem & [ OPT - ], ... > ] ] ].
be_fin := be_verb &
  [ SYNSEM.LOCAL non_perf &
		 [ CAT [ HEAD [ VFORM fin,
				PRD -,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] > ],
			 VAL.SUBJ < @nomp_nom() &
					[ OPT - ] > ],
		   CONT psoa ] ].

be_pres := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE present*,
			    MOOD indicative* ] ].

be_past := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE past*,
			    MOOD indicative* ] ].

be_subj := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.MOOD subjunctive ].

be_prespart := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD +,
				MOD < [ LOCAL intersective_mod & 
					      [ CAT nbar_cat,
						CONT.INDEX #nind ] ] > ],
			 VAL.SUBJ < [ LOCAL.CONT.INDEX #nind ] > ] ] ].

be_pastpart := be_verb &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT.HEAD [ VFORM psp,
			      PRD - ],
		   CONT psoa ] ]. 
be_neg := sign &
  [ INFLECTED +,
    SYNSEM lex_synsem &
	   [ LOCAL.CONT [ KEY.HANDEL #khand,
			  --TOPKEY #altkey,
			  ALTKEY neg_rel & #altkey &
			      [ ARG #arghand ],
			  H-CONS <! qeq &
				  [ SC-ARG #arghand,
				    OUTSCPD #khand ]!> ] ] ].

be_be_lex_entry := be_verb & infl_lex_entry &
  [ STEM < "be" >,
    SYNSEM.LOCAL nomod_local &
	 [ CAT [ HEAD [ PRD -,
			VFORM bse ],
		 VAL.SUBJ < [ OPT - ] > ] ] ].

be_being_lex_entry := be_prespart & infl_lex_entry & 
  [ STEM < "being" > ].

be_been_lex_entry := be_pastpart & infl_lex_entry & 
  [ STEM < "been" > ].

be_pres_lex_entry := be_pres & infl_lex_entry.

be_past_lex_entry := be_past & infl_lex_entry.

be_pres_neg_lex_entry := be_pres & be_neg & basic_mle1.
be_past_neg_lex_entry := be_past & be_neg & basic_mle1.

be_am_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1sg ] ].

be_is_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_am_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.INV +,
                   AGR.PNG png & [ PN 1sg ] ] ].

be_is_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3sg ] ].

be_are_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

be_was_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1or3sg & strict_sort ] ].

be_were_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN non1sg & strict_sort ] ].

; *** Copula BE ***

;; DPF 25-Oct-98 We need this first definition in order to get the prop_to_prop
;; vitrifier rule to fire, for e.g. "how is the seventeenth?.  Don't know why
;; this definition was commented out in favor of the next one, but I'm sure it
;; will become clear soon.

be_copula := prd_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT [ TOP #hand,
						    KEY.LABEL #label ],
		   CONT [ INDEX #event,
			  KEY support_rel &
			      [ HANDEL #hand,
				LABEL #label,
				EVENT #event ] ] ] ].

be_cop_pos_generic := be_copula & topkey &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.TOP #top,
		   CONT [ TOP #top,
			  KEY #key,
			  LISZT <! #key !>,
			  H-CONS <! !> ] ] ].

be_cop_pos := be_cop_pos_generic &
 [ SYNSEM.LOCAL non_perf ].

be_cop_neg := be_copula &
  [ SYNSEM.LOCAL non_perf &
		 [ CONT [ KEY #key,
			  ALTKEY #altkey,
			  --TOPKEY #altkey,
			  LISZT <! #key, #altkey !> ] ] ].

be_c_be_le := be_be_lex_entry & be_cop_pos_generic.
be_c_being_le := be_being_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM non_prp ].
be_c_been_le := be_been_lex_entry & be_cop_pos_generic.
be_c_am_le := be_am_lex_entry & be_cop_pos.
be_c_is_le := be_is_lex_entry & be_cop_pos.
be_c_is_cx_le := be_is_lex_entry & be_cop_pos & contracted_aux_word.
be_c_are_le := be_are_lex_entry & be_cop_pos.
be_c_was_le := be_was_lex_entry & be_cop_pos.
be_c_were_le := be_were_lex_entry & be_cop_pos.
be_c_am_neg_le := be_am_neg_contr_lex_entry & be_cop_neg.
be_c_is_neg_le := be_is_neg_contr_lex_entry & be_cop_neg.
be_c_are_neg_le := be_are_neg_contr_lex_entry & be_cop_neg.
be_c_was_neg_le := be_was_neg_contr_lex_entry & be_cop_neg.
be_c_were_neg_le := be_were_neg_contr_lex_entry & be_cop_neg.

; *** Identity BE ***

id_cop_verb := aux_verb & two_arg_subst & basic_two_arg &
  [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT.INDEX #id1ind & non_expl-ind ] >,
			COMPS < [ LOCAL [ CAT [ HEAD noun,
						VAL [ SUBJ < >,
						      SPR *olist*,
						      COMPS *olist* ] ],
					  CONT.INDEX #id2ind & ref-ind ] ] > ] ],
	    CONT.KEY _cop_id_rel &
		[ ARG #id1ind,
		  ARG3 #id2ind ] ] ].

be_id := be_verb &
  [ SYNSEM id_cop_verb &
	   [ LOCAL.CONT [ INDEX #event,
			  LISZT.LIST.FIRST.EVENT #event ] ] ].

be_id_pos := be_id & topkey &
  [ SYNSEM.LOCAL.CONT [ LISZT <! #key !>,
			KEY #key,
			H-CONS <! !> ] ].

be_id_neg_synsem :< id_cop_verb.

be_id_neg := be_id &
  [ SYNSEM be_id_neg_synsem & 
	   [ LOCAL.CONT [ LISZT <! #key, #altkey !>,
			  KEY #key,
			  ALTKEY #altkey ] ] ].

be_id_be_le := be_be_lex_entry & be_id & topkey &
  [ SYNSEM.LOCAL.CONT [ LISZT <! #key !>,
			KEY #key,
			H-CONS <! !> ] ].

be_id_being_le := be_being_lex_entry & be_id_pos.
be_id_been_le := be_been_lex_entry & be_id_pos.
be_id_am_le := be_am_lex_entry & be_id_pos.
be_id_is_le := be_is_lex_entry & be_id_pos.
be_id_is_cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word.
be_id_are_le := be_are_lex_entry & be_id_pos.
be_id_was_le := be_was_lex_entry & be_id_pos.
be_id_were_le := be_were_lex_entry & be_id_pos.
be_id_am_neg_le := be_am_neg_contr_lex_entry & be_id_neg.
be_id_is_neg_le := be_is_neg_contr_lex_entry & be_id_neg.
be_id_are_neg_le := be_are_neg_contr_lex_entry & be_id_neg.
be_id_was_neg_le := be_was_neg_contr_lex_entry & be_id_neg.
be_id_were_neg_le := be_were_neg_contr_lex_entry & be_id_neg.

; *** There Copula BE ***

;; The relationship between the first COMP and the second cannot be one of
;; raising (since if the first is extracted its SLASH will be non-empty, and
;; that non-empty SLASH would also erroneously appear on the VP.  So the control
;; relation must be equi rather than raising.

there_cop_verb := aux_verb & unsat_three_arg_subst & basic_three_arg &
  [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT [ INDEX there-ind &
						    [ PNG #png ],
					      KEY.LABEL #label ] ] >,
			COMPS < @nomp_acc() &
				[ LOCAL [ AGR non_expl-ind &
					      [ PNG #png ],
					  CONT.INDEX #cind ],
				  OPT - ],
				[ LOCAL local &
					[ CAT [ HEAD.PRD +,
						VAL [ SUBJ < synsem & 
							     [ LOCAL.CONT.INDEX 
								      #cind,
							       NON-LOCAL.SLASH 
								      0-dlist ]>,
						      SPR *olist*,
						      COMPS *olist* ],
					    MC na ],
					  CONT [ TOP #hand,
						 KEY independent_rel ] ],
				  OPT + ] > ] ],
	    CONT.KEY _there_cop_rel &
		     [ HANDEL #hand,
		       LABEL #label,
		       ARG3 #cind ] ] ].

be_th_cop := be_verb & 
  [ SYNSEM there_cop_verb ].

be_th_cop_pos := be_th_cop & topkey &
  [ SYNSEM.LOCAL.CONT [ INDEX #event,
			LISZT <! #key !>,
			KEY #key & [ EVENT #event ],
			H-CONS <! !> ] ].

th_cop_neg_aux_verb :< there_cop_verb.

be_th_cop_neg := be_th_cop &
  [ SYNSEM th_cop_neg_aux_verb &
	   [ LOCAL [ CONT [ LISZT <! #key, #altkey !>,
			    KEY #key,
			    ALTKEY #altkey,
			    --TOPKEY #altkey ] ] ] ].

be_th_cop_be_le := be_be_lex_entry & be_th_cop &
  [ SYNSEM.LOCAL.CONT [ INDEX #event,
			LISZT <! #key !>,
			KEY #key & [ EVENT #event ],
			H-CONS <! !> ] ].

be_th_cop_being_le := be_being_lex_entry & be_th_cop_pos.
be_th_cop_been_le := be_been_lex_entry & be_th_cop_pos.
be_th_cop_is_le := be_is_lex_entry & be_th_cop_pos.
be_th_cop_are_le := be_are_lex_entry & be_th_cop_pos.
be_th_cop_was_le := be_was_lex_entry & be_th_cop_pos.
be_th_cop_were_le := be_were_lex_entry & be_th_cop_pos.
be_th_cop_s_cx_le := be_pres_lex_entry & be_th_cop_pos & contracted_aux_word.
be_th_cop_is_neg_le := be_is_neg_contr_lex_entry & be_th_cop_neg.
be_th_cop_are_neg_le := be_are_neg_contr_lex_entry & be_th_cop_neg.
be_th_cop_was_neg_le := be_was_neg_contr_lex_entry & be_th_cop_neg.
be_th_cop_were_neg_le := be_were_neg_contr_lex_entry & be_th_cop_neg.


