;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2013
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see LICENSE for conditions
;;;
;;;  auxverbs.tdl
;;;
;;;  The auxiliary verb system for English
;;;
;;;  Created: Rob Malouf, 17-Nov-1994
;;;
;;;  $Id$

will_aux_synsem := bse_aux_verb_ssr &
  [ LOCAL [ CAT [ HEAD [ VFORM fin,
			 PRD -,
			 TAM indic_tam ],
		  VAL [ SUBJ < synsem & 
			       [ LOCAL [ CAT nomp_cat_nom_min,
					 CONJ cnil ],
				 OPT - ] >,
			COMPS.FIRST.--SIND #event ] ],
	    CONT psoa & [ HOOK.INDEX #event ] ] ].

will_aux_word := bse_aux_verb_word &
  [ SYNSEM will_aux_synsem ].

will_aux_pos_synsem := will_aux_synsem &
  [ LOCAL [ CAT.VAL.COMPS < canonical_synsem &
			    [ LOCAL.CONT.HOOK.LTOP #hand ] >,
	    CONT [ HOOK.LTOP #hand,
		   RELS <! !>,
		   HCONS <! !> ] ],
    LKEYS.KEYREL.LBL #hand ].

will_aux_pos_lex_e := will_aux_word &
  [ SYNSEM will_aux_pos_synsem ].

will_aux_inv_synsem_min := synsem_min.
will_aux_inv_synsem := basic_two_arg & basic_verb_synsem & 
		       will_aux_inv_synsem_min &
  [ LOCAL [ CAT [ HEAD [ AUX -,
			 VFORM fin,
			 TAM #tam,
			 MINORS.MIN v_event_rel ],
		  VAL [ SUBJ < canonical_synsem &
			       [ --MIN independent_rel,
				 LOCAL [ CAT basic_prd_cat &
					     [ HEAD v_or_a_or_p &
						    [ MOD < anti_synsem &
							  [ --SIND #sind ] > ],
					       VAL.SUBJ *olist* ],
					 CONT.HOOK 
					     [ INDEX event & #event,
					       XARG #sind & individual_min ] ],
				 OPT - ] >,
			COMPS < canonical_synsem &
				[ LOCAL [ CAT vp_bse_unspec_cat &
					      [ VAL.SUBJ 
						< [ LOCAL.CAT basic_prd_cat ]>],
					  CONJ cnil,
					  CONT.HOOK.LTOP #hand ],
				  OPT -,
				  --SIND #xarg ] > ] ],
	    CONT [ HOOK [ LTOP #hand,
			  INDEX #event & [ E #tam ],
			  XARG #xarg ],
		   RELS <! !>,
		   HCONS <! !> ] ] ].

; inverted `will': "also included will be cats"

v_vp_will-inv_le := aux_verb_word_super & 
  [ SYNSEM will_aux_inv_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM will_aux_inv_synsem_min ] ].

will_aux_pos_norm_synsem_min := synsem_min.
will_aux_pos_norm_synsem := will_aux_pos_synsem & will_aux_pos_norm_synsem_min &
  [ LOCAL.CAT [ HEAD.TAM [ TENSE future,
			   MOOD indicative ],
		VAL.COMPS < [ LOCAL.CAT vp_bse_unspec_cat &
					[ HEAD.TAM.MOOD indicative ] ] > ] ].

; <type val="v_vp_will-p_le">
; <description>Cmps VP(bse), aux, pos           
; <ex>B will sing.
; <nex>
; <todo>
; </type>
v_vp_will-p_le := will_aux_pos_lex_e &
 [ SYNSEM will_aux_pos_norm_synsem  &
	  [ LOCAL.CAT.HEAD.LSYNSEM will_aux_pos_norm_synsem_min ] ].

                        
; <type val="v_vp_will-p-cx_le">
; <description>Cmps VP(bse), aux, pos contract  
; <ex>B'll sing.
; <nex>
; <todo>
; </type>
v_vp_will-p-cx_le := will_aux_pos_lex_e & contracted_aux_word &
  [ SYNSEM will_aux_pos_norm_synsem &
	  [ LOCAL.CAT.HEAD.LSYNSEM will_aux_pos_norm_synsem_min ] ].

will_aux_neg_synsem_min := synsem_min.
will_aux_neg_synsem := will_aux_synsem & will_aux_neg_synsem_min &
  [ LOCAL [ CAT [ HEAD.TAM [ TENSE future,
			     MOOD indicative ],
		  VAL.COMPS.FIRST.LOCAL [ CAT vp_bse_unspec_cat &
					      [ HEAD.TAM.MOOD indicative ],
					  CONT.HOOK.LTOP #chand ] ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #alt2keyrel & adv_relation &
			 [ LBL #ltop,
			   PRED neg_rel,
			   ARG1 #arghand ] !>,
		   HCONS <! qeq & [ HARG #arghand,
				    LARG #chand ] !> ] ],
    LKEYS.ALT2KEYREL #alt2keyrel ].

va_will_neg_lexent := will_aux_word & 
  [ SYNSEM will_aux_neg_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM will_aux_neg_synsem_min ] ].

; <type val="v_vp_will-n_le">
; <description>Cmps VP(bse), aux, neg contract  
; <ex>B won't sing.
; <nex>
; <todo>
; </type>
v_vp_will-n_le := va_will_neg_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST canonical_synsem ].

; <type val="v_vp_will-n-niv_le">
; <description>Cmps VP(bse), aux, neg c, no inv, no overt complement
; <ex>B'll not.
; <nex>
; <todo>
; </type>
v_vp_will-n-niv_le := va_will_neg_lexent & aux_not_contr.

;;; Modal verbs


; <type val="v_vp_mdl-p_le">
; <description>Cmps VP(bse), modal, pos         
; <ex>B can sing.
; <nex>
; <todo>
; </type>
v_vp_mdl-p_le := modal_pos_indic_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

; <type val="v_vp_must-p_le">
; <description>Cmps VP(bse), must, pos         
; <ex>B must sing.
; <nex>
; <todo>
; </type>
v_vp_must-p_le := modal_pos_indic_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present,
    ALTS.ADVADD - ].

; <type val="v_vp_mdl-p-cx_le">
; <description>Cmps VP(bse), aux, pos contract  
; <ex>B'd sing.
; <nex>
; <todo>
; </type>
v_vp_mdl-p-cx_le := modal_pos_indic_lexent & contracted_aux_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

; could
; <type val="v_vp_mdl-p-pst_le">
; <description>Cmps VP(bse), modal, pos, past   
; <ex>B could sing yesterday.
; <nex>
; <todo>
; </type>
v_vp_mdl-p-pst_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE past,
    ALTS.CSAI - ].

; would - unsp for MOOD
; <type val="v_vp_mdl-p-unsp_le">
; <description>Cmps VP(bse), modal, pos,unsp md 
; <ex>B could sing tomorrow.
; <nex>
; <todo>
; </type>
v_vp_mdl-p-unsp_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present,
    ALTS.CSAI - ].

; <type val="v_vp_mdl-p-niv_le">
; <description>Cmps VP(bse), modal, pos, no inv 
; <ex>B better go.
; <nex>
; <todo>
; </type>
v_vp_mdl-p-niv_le := modal_pos_indic_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ TAM.TENSE present,
                            INV - ] ].

; <type val="v_vp_mdl-p-sv_le">
; <description>Cmps VP(bse), modal, pos, sbjctv 
; <ex>B might sing.
; <nex>
; <todo>
; </type>
v_vp_mdl-p-sv_le := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

; <type val="v_vp_oght-p_le">
; <description>Cmps VP(inf), modal, pos         
; <ex>B ought to sing.
; <nex>
; <todo>
; </type>
v_vp_oght-p_le := pos_ought_verb_word & add_cont &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

; <type val="v_vp_oght-p-pst_le">
; <description>Cmps VP(inf), modal, pos, past   
; <ex>B used to sing.
; <nex>
; <todo>
; </type>
v_vp_oght-p-pst_le := past_ought_verb_word & add_cont &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE past ].

; <type val="v_vp_qsmd_le">
; <description>Cmps VP(inf), quasi-modal        
; <ex>B is going to sing.
; <nex>
; <todo>
; </type>
v_vp_qsmd_le := quasimodal_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp, 
                            PRD + ] ].

; <type val="v_vp_qsmd-psp_le">
; <description>Cmps VP(inf), quasi-modal, psp   
; <ex>B has got to sing.
; <nex>
; <todo>
; </type>
v_vp_qsmd-psp_le := quasimodal_psp_word.

; <type val="v_vp_qsmd-psp-bse_le">
; <description>Cmps VP(bse), quasi-modal, psp   
; <ex>B has gotta sing.
; <nex>
; <todo>
; </type>
v_vp_qsmd-psp-bse_le := quasimodal_psp_bse_word.

; <type val="v_vp_qsmd-bse_le">
; <description>Cmps VP(bse), quasi-modal        
; <ex>B is gonna sing.
; <nex>
; <todo>
; </type>
v_vp_qsmd-bse_le := quasimodal_bse_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp, 
                            PRD + ] ].

; 'didn't he used to sing?'
; <type val="v_vp_nfin-mod_le">
; <description>Cmps VP(inf), s-s-rais, nonfin   
; <ex>Didn't C used to sing?
; <nex>
; <todo>
; </type>
v_vp_nfin-mod_le := nonfin_modal_word.

generic_modal_neg_basic_synsem := aux_verb_ssr &
  [ LOCAL [ CAT.HEAD.LSYNSEM aux_verb_ssr_min,
	    CONT [ RELS <! #alt2keyrel & adv_relation &
			 [ PRED neg_rel,
			   ARG1 #narghand ], 
			 #keyrel !>,
		   HCONS <! qeq &
			  [ HARG #arghand ],
			  qeq &
			  [ HARG #narghand ] !> ] ],
    LKEYS [ KEYREL #keyrel &
		   [ PRED modal_rel,
		     ARG0 non_conj_event,
		     ARG1 #arghand ],
	    ALT2KEYREL #alt2keyrel ] ].

generic_modal_neg_basic := aux_verb_word_super &
  [ SYNSEM generic_modal_neg_basic_synsem,
    ALTS.CSAI - ].

generic_modal_neg_super_synsem := generic_modal_neg_basic_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! [ LBL #ltop ], relation !>,
		   HCONS <! [ LARG #chand ],
			  [ LARG #khand ] !> ] ],
    LKEYS.KEYREL.LBL #khand ].

generic_modal_neg_super := generic_modal_neg_basic &
  [ SYNSEM generic_modal_neg_super_synsem ].

must_modal_neg_synsem := generic_modal_neg_basic_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT [ HOOK.LTOP #khand,
		   RELS <! [ LBL #neghand ], relation !>,
		   HCONS <! [ LARG #neghand ],
			  [ LARG #chand ] !> ] ],
    LKEYS.KEYREL.LBL #khand ].

must_modal_neg := generic_modal_neg_basic &
  [ SYNSEM must_modal_neg_synsem ].

generic_modal_neg := generic_modal_neg_super & aux_verb_word &
  [ SYNSEM.LOCAL.CAT.POSTHD + ].

modal_neg_synsem_min := synsem_min.
modal_neg_synsem := modal_verb_synsem & generic_modal_neg_super_synsem &
		    modal_neg_synsem_min.

va_modal_neg_lexent := modal_verb_word & generic_modal_neg &
  [ SYNSEM modal_neg_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM modal_neg_synsem_min,
	     LKEYS.KEYREL.PRED modal_rel ] ].

must_neg_synsem_min := synsem_min.
must_neg_synsem := generic_modal_verb_super_synsem & must_modal_neg_synsem &
		   bse_aux_verb_ssr & must_neg_synsem_min &
  [ LOCAL [ CAT [ HEAD [ PRD -,
			 VFORM fin ],
		  POSTHD +,
		  VAL [ SUBJ < synsem & [ LOCAL [ CAT nomp_cat_nom_min,
						  CONJ cnil ],
					  --SIND basic_non_event,
					  OPT - ] >,
			COMPS.FIRST [ LOCAL.CAT vp_bse_cat,
				      --SIND.SF basic-prop ] ] ],
	    CONT psoa ],
    LKEYS.KEYREL.PRED modal_rel ].

va_must_neg_lexent := generic_modal_verb_word_super & must_modal_neg &
		      bse_aux_verb_word &
  [ SYNSEM must_neg_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM must_neg_synsem_min ] ].

; <type val="v_vp_mdl-n_le">
; <description>Cmps VP(bse), modal, neg-cntrct  
; <ex>B can't sing.
; <nex>
; <todo>
; </type>
v_vp_mdl-n_le := va_modal_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.TENSE present,
		       VAL.COMPS.FIRST canonical_synsem ] ].

; <type val="v_vp_mdl-n_le">
; <description>Cmps VP(bse), modal must, neg-cntrct (idiosyncratic scope)
; <ex>B mustn't sing.
; <nex>
; <todo>
; </type>
v_vp_must-n_le := va_must_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.TENSE present,
		       VAL.COMPS.FIRST canonical_synsem ] ].

; couldn't
; <type val="v_vp_mdl-n-pst_le">
; <description>Cmps VP(bse), modal, neg-c, past 
; <ex>B couldn't sing.
; <nex>
; <todo>
; </type>
v_vp_mdl-n-pst_le := va_modal_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.TENSE past,
		       VAL.COMPS.FIRST canonical_synsem ] ].

; "'d better not"
; <type val="v_vp_mdl-n-niv_le">
; <description>Cmps VP(bse), modal,neg-c,no inv, no overt comp
; <ex>B'd better not.
; <nex>
; <todo>
; </type>
v_vp_mdl-n-niv_le := va_modal_neg_lexent & aux_not_contr &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.TENSE present ].

modal_neg_verb_synsem_min := synsem_min.
modal_neg_verb_synsem := modal_verb_synsem & generic_modal_neg_super_synsem &
			 modal_neg_verb_synsem_min.

; <type val="v_vp_mdl-n-sv_le">
; <description>Cmps VP(bse), modal, neg-c       
; <ex>B shouldn't sing.
; <nex>
; <todo>
; </type>
v_vp_mdl-n-sv_le := modal_verb_word & generic_modal_neg & 
  [ SYNSEM.LOCAL.CAT [ HEAD [ TAM.TENSE present,
			      LSYNSEM modal_neg_verb_synsem_min ],
		       VAL.COMPS.FIRST canonical_synsem ] ].

ought_verb_neg_synsem_min := synsem_min.
ought_verb_neg_synsem := ought_verb_synsem & generic_modal_neg_super_synsem &
			 ought_verb_neg_synsem_min.

; <type val="v_vp_oght-n_le">
; <description>Cmps VP(inf), modal, neg-c       
; <ex>B oughtn't to sing.
; <nex>
; <todo>
; </type>
v_vp_oght-n_le := ought_verb_word & generic_modal_neg_super &
  [ SYNSEM.LOCAL.CAT.HEAD [ TAM.TENSE present,
			    LSYNSEM ought_verb_neg_synsem_min ] ].

; *** Auxiliary DO ***

; For tag questions we need the MIN of auxiliary _do_ to match all main verbs.
; The supertype for this is v_event_rel.  Originally, it had been no_rel, to 
; block _do_'s being a complement of other auxiliaries.  On the hypothesis
; that auxiliary _do_ in fact lacks a non-finite form all together, the
; do_aux_word type is constrained to VFORM fin.

do_aux_synsem := ssr_two_arg_verb &
  [ LOCAL [ CAT [ HEAD [ AUX +,
			 TAM [ TENSE #tense,
			       ASPECT #aspect,
			       MOOD indicative ],
			 MINORS.MIN nonaux_event_rel,
			 LSYNSEM ssr_two_arg_verb_min ],
		  VAL [ SUBJ < synsem & 
			       [ OPT -,
				 LOCAL [ CAT nomp_cat_nom_min &
					     [ HEAD.MINORS #minors ],
					 CONJ cnil ] ] >,
			COMPS < canonical_synsem &
				[ --MIN nonaux_event_rel,
				  LOCAL [ CAT vp_bse_unspec_cat &
					      [ HEAD.AUX -,
						VAL.SUBJ.FIRST.LOCAL.CAT.HEAD
						 [ MINORS #minors ] ],
					  CONT.HOOK [ LTOP #cltop,
						      INDEX #index ],
					  CONJ cnil ],
				  --SIND #index,
				  OPT - ] > ],
		  POSTHD + ],
	    CONT psoa & [ HOOK.INDEX #index & 
				     [ E [ TENSE #tense,
					   ASPECT #aspect,
					   MOOD indicative ] ] ] ],
    LKEYS.KEYREL [ LBL #cltop,
		   PRED mod_role_rel,
		   ARG0 #index ] ].

do_aux_word := nonc-hm &
  [ INFLECTD +,
    SYNSEM do_aux_synsem,
    ALTS.CSAI - ].

; Removed raise-cont from parents, to allow ARG0 to not be identified with the
; comp-dtr's ARG0   - is in conflict with collapsing of base and fin-non3rdsg 
; forms, given that we encode VIT attributes in the event feature structure.
; Sample problem: "Kim does sleep"

; DPF 6-Feb-02 - Changed MOOD indicative to indicative* in order to support
; coordination of e.g. yes-no questions and modal_subj declaratives.  Same in
; type do_aux_neg_pres.
; DPF 13-Mar-02 - But this allowed "want" version of "like" to be complement.
; So instead make do_aux_word stamp indicative* for its own MOOD, and not
; copy it up from complement dtr.  Then require complement dtr to be simply
; MOOD indicative.  And by the way broke link from "do" to bse_aux_verb_word
; which insists on making the aux verb's TAM identical to its INDEX, which we
; can't have for "do".

do_fin_synsem_min := synsem_min.
do_fin_synsem := do_aux_synsem & do_fin_synsem_min &
  [ LOCAL local &
	  [ CAT [ HEAD [ VFORM fin,
			 PRD - ],
		  VAL [ SUBJ < [ OPT -,
				 LOCAL.CONT.HOOK.LTOP #hand ] >,
			COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #hand ] ],
	    CONT [ HOOK.LTOP #hand,
		   RELS <! !>,
		   HCONS <! !> ] ] ].

do_fin := do_aux_word & raise_cont & 
  [ SYNSEM do_fin_synsem ].

do_aux_neg_synsem_min := synsem_min.
do_aux_neg_synsem := do_aux_synsem & do_aux_neg_synsem_min &
  [ LOCAL [ CAT [ HEAD [ PRD -,
			 VFORM fin ],
		  VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #chand,
			COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #chand ] ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #alt2keyrel & adv_relation &
			 [ LBL #ltop,
			   PRED neg_rel,
			   ARG1 #arghand ] !>,
		   HCONS <! qeq &
			  [ HARG #arghand,
			    LARG #chand ] !> ] ],
    LKEYS.ALT2KEYREL #alt2keyrel ].

do_aux_neg_word := do_aux_word &
  [ SYNSEM do_aux_neg_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM do_aux_neg_synsem_min ] ].

do_pres_synsem_min := synsem_min.
do_pres_synsem := do_fin_synsem & do_pres_synsem_min &
  [ LOCAL [ CAT [ HEAD.TAM indic_tam &
			   [ TENSE present,
			     ASPECT no_aspect ],
		  VAL.SUBJ < [ --SIND.PNG #png ] > ],
	    AGR.PNG #png ] ].

do_pres := do_fin &
  [ SYNSEM do_pres_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM do_pres_synsem_min ] ].

; <type val="v_vp_does_le">
; <description>Cmps VP(bse), do, pres 3sg       
; <ex>B does not sing.
; <nex>
; <todo>
; </type>
v_vp_does_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN 3s ] ] > ].

; <type val="v_vp_do-f_le">
; <description>Cmps VP(bse), do, pres non3sg    
; <ex>We do not sing.
; <nex>
; <todo>
; </type>
v_vp_do-f_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ 
			     < [ --SIND.PNG png & [ PN -3s ] ] > ].

; <type val="v_vp_did_le">
; <description>Cmps VP(bse), do, past           
; <ex>B did not sing.
; <nex>
; <todo>
; </type>
v_vp_did_le := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TAM past_or_subj_tam,
			    LSYNSEM do_fin_synsem_min ] ].

do_aux_neg_pres := do_aux_neg_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM indic_tam &
                              [ TENSE present,
				ASPECT no_aspect ] ].

; <type val="v_vp_did-n_le">
; <description>Cmps VP(bse), do, neg-c, past    
; <ex>B didn't sing.
; <nex>
; <todo>
; </type>
v_vp_did-n_le := do_aux_neg_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TAM past_or_subj_tam ].

; ERB (31-03-97) The agreement on do, but not have and be, was previously
; taken care of in lexicon.tdl.  I am making these types to move that
; information here for symmetry.  The rest of the do paradigm seems
; to be generated by lexical rules, so these two are the only types.

; <type val="v_vp_does-n_le">
; <description>Cmps VP(bse), do, neg-c, pres3sg 
; <ex>B didn't sing.
; <nex>
; <todo>
; </type>
v_vp_does-n_le := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

; <type val="v_vp_do-f-n_le">
; <description>Cmps VP(bse), do, neg-c,pr n3sg  
; <ex>We don't sing.
; <nex>
; <todo>
; </type>
v_vp_do-f-n_le := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ] ].

; *** Perfect HAVE ***

basic_have_aux_verb_synsem := aux_verb_ssr &
  [ LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #index,
	    CONT.HOOK [ LTOP #lbl,
			INDEX #index ] ],
    LKEYS.KEYREL [ PRED have_aux_rel,
		   LBL #lbl ] ].

have_aux_verb_synsem := basic_have_aux_verb_synsem & psp_aux_verb_ssr &
  [ LOCAL.CAT.HEAD.TAM.ASPECT.PRF + ].

have_aux_word := psp_aux_verb_word & 
  [ SYNSEM have_aux_verb_synsem ].

have_aux_pos_synsem_min := synsem_min.
have_aux_pos_synsem := have_aux_verb_synsem & have_aux_pos_synsem_min &
  [ LOCAL [ CAT.VAL.COMPS < canonical_synsem &
			    [ LOCAL.CONT.HOOK.LTOP #hand ] >,
	    CONT [ HOOK.LTOP #hand,
		   RELS <! !>,
		   HCONS <! !> ] ] ].

have_aux_pos_lex_entry := have_aux_word &
  [ SYNSEM have_aux_pos_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM have_aux_pos_synsem_min ] ].

aux_not_contr := sign &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
                       VAL.COMPS.FIRST unexpressed & [ OPT - ] ] ].
                   
have_aux_neg_synsem := have_aux_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ VFORM fin,
			 PRD - ],
		  POSTHD +,
		  VAL [ SUBJ < [ OPT - ] >,
			COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #chand ] ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #alt2keyrel & adv_relation &
			 [ LBL #ltop,
			   PRED neg_rel,
			   ARG1 #arghand ] !>,
		   HCONS <! qeq &
			  [ HARG #arghand,
			    LARG #chand ] !> ] ],
    LKEYS.ALT2KEYREL #alt2keyrel ].

have_aux_neg_lex_entry := have_aux_word &
  [ SYNSEM have_aux_neg_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM have_aux_neg_fin_synsem_min ],
    ALTS.CSAI - ].

have_fin_synsem := have_aux_verb_synsem &
  [ LOCAL local &
	  [ CAT [ HEAD [ VFORM fin,
			 PRD - ],
		  POSTHD +,
		  VAL.SUBJ < synsem & 
			     [ LOCAL [ CAT nomp_cat_nom_min,
				       CONJ cnil ],
			       OPT - ] > ],
	    CONT psoa ]].

have_fin := have_aux_word &
  [ SYNSEM have_fin_synsem ].

have_pres := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM indic_tam &
                              [ TENSE present,
				ASPECT.PRF + ],
    ALTS.CSAI - ].

have_past := have_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM [ TENSE past,
				ASPECT.PRF +,
				MOOD indicative ],
    ALTS.CSAI - ].

have_subj := have_fin &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM subjnct_tam &
				[ ASPECT.PRF +,
				  MOOD subjunctive ],
		       VAL.COMPS.FIRST canonical_synsem ] ].

;; We make "having" be [PRD -] to block "Kim is having fallen" and (the
;; restrictive reading of) "The book having fallen is red".  We will also 
;; exclude possibly grammatical examples like "anyone having seen that movie"
;; but there are no attested instances of these in the full BNC.
;; DPF 29-oct-06 - Remove this PRD - constraint, since it also blocks
;; depictives as in "We left, having finished."  Instead, block "is having"
;; by adding NORM no_rel.  Maybe FIX?

; <type val="v_vp_have-prp_le">
; <description>Cmps VP(psp), have, prp          
; <ex>Having sung, B left.
; <nex>
; <todo>
; </type>
v_vp_have-prp_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM prp,
                            TAM.ASPECT.PROGR +,
                            MINORS.NORM no_rel ] ].

va_have_bse_lexent := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
                                VFORM bse_only,
                                TAM.ASPECT.PRF + ],
                         VAL.SUBJ < unexpressed >,
                         POSTHD + ],
		   CONT psoa ] ].

; <type val="v_vp_have-bse_le">
; <description>Cmps VP(psp), have, bse          
; <ex>B will have sung.
; <nex>
; <todo>
; </type>
v_vp_have-bse_le := va_have_bse_lexent.
; <type val="v_vp_have-bse-cx_le">
; <description>Cmps VP(psp), have, bse, contr   
; <ex>We would've sung.
; <nex>
; <todo>
; </type>
v_vp_have-bse-cx_le := va_have_bse_lexent & contracted_aux_word.

has_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.AGR.PNG png & [ PN 3s ] ] > ].

; <type val="v_vp_has_le">
; <description>Cmps VP(psp), have, 3sg          
; <ex>B has sung.
; <nex>
; <todo>
; </type>
v_vp_has_le := has_aux_lex_ent.

; <type val="v_vp_has-cx_le">
; <description>Cmps VP(psp), have, 3sg, contr   
; <ex>B's sung.
; <nex>
; <todo>
; </type>
v_vp_has-cx_le := has_aux_lex_ent & contracted_aux_word.

have_fin_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ] ].

; <type val="v_vp_have-f_le">
; <description>Cmps VP(psp), have, n3sg         
; <ex>We have sung.
; <nex>
; <todo>
; </type>
v_vp_have-f_le := have_fin_aux_lex_ent.

; <type val="v_vp_have-f-cx_le">
; <description>Cmps VP(psp), have, n3sg, contr  
; <ex>We've sung.
; <nex>
; <todo>
; </type>
v_vp_have-f-cx_le := have_fin_aux_lex_ent & contracted_aux_word.

have_pos_fin_synsem := have_aux_pos_synsem & have_fin_synsem.

had_aux_lex_ent := have_aux_pos_lex_entry & have_past &
  [ SYNSEM have_pos_fin_synsem ].

; <type val="v_vp_had-sv_le">
; <description>Cmps VP(psp), have, subjtv       
; <ex>If we had sung, B would've
; <nex>
; <todo>
; </type>
v_vp_had-sv_le := have_aux_pos_lex_entry & have_subj &
  [ SYNSEM have_pos_fin_synsem ].

; <type val="v_vp_had_le">
; <description>Cmps VP(psp), have, past         
; <ex>B had sung.
; <nex>
; <todo>
; </type>
v_vp_had_le := had_aux_lex_ent.

; <type val="v_vp_had-cx_le">
; <description>Cmps VP(psp), have, past, contr  
; <ex>B'd sung already.
; <nex>
; <todo>
; </type>
v_vp_had-cx_le := had_aux_lex_ent & contracted_aux_word.

; <type val="v_vp_has-n_le">
; <description>Cmps VP(psp), have, 3sg, neg-c   
; <ex>B hasn't sung.
; <nex>
; <todo>
; </type>
v_vp_has-n_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL [ AGR.PNG png & [ PN 3s ],
		   CAT.VAL.COMPS.FIRST canonical_synsem ] ].

; <type val="v_vp_has-n-niv_le">
; <description>Cmps VP(psp), have,3sg,ng-c,ninv, no overt comp
; <ex>B's not.
; <nex>
; <todo>
; </type>
v_vp_has-n-niv_le := have_aux_neg_lex_entry & have_pres & aux_not_contr &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

have_aux_neg_fin_synsem_min := synsem_min.
have_aux_neg_fin_synsem := have_aux_neg_synsem & have_fin_synsem &
			   have_aux_neg_fin_synsem_min.

; <type val="v_vp_have-f-n_le">
; <description>Cmps VP(psp), have, n3sg, neg-c  
; <ex>We haven't sung.
; <nex>
; <todo>
; </type>
v_vp_have-f-n_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM have_aux_neg_fin_synsem &
	   [ LOCAL [ AGR.PNG png & [ PN -3s ],
		     CAT.VAL.COMPS.FIRST canonical_synsem ] ] ].


; <type val="v_vp_have-n-niv_le">
; <description>Cmps VP(psp), have,n3sg,ngc,ninv, no overt comp
; <ex>We've not.
; <nex>
; <todo>
; </type>
v_vp_have-n-niv_le := have_aux_neg_lex_entry & have_pres & 
		      aux_not_contr &
  [ SYNSEM have_aux_neg_fin_synsem &
	   [ LOCAL.AGR.PNG png & [ PN -3s ] ] ].


; <type val="v_vp_had-n_le">
; <description>Cmps VP(psp), have, past, neg-c  
; <ex>B hadn't sung.
; <nex>
; <todo>
; </type>
v_vp_had-n_le := have_aux_neg_lex_entry & have_past &
  [ SYNSEM have_aux_neg_fin_synsem &
	   [ LOCAL.CAT.VAL.COMPS.FIRST canonical_synsem ] ].

; <type val="v_vp_had-n-niv_le">
; <description>Cmps VP(psp), have,past,ngc,ninv, no overt complement
; <ex>B'd not.
; <nex>
; <todo>
; </type>
v_vp_had-n-niv_le := have_aux_neg_lex_entry & have_past & aux_not_contr &
  [ SYNSEM have_aux_neg_fin_synsem ].

; <type val="v_vp_had-n-sv_le">
; <description>Cmps VP(psp), have, subjtv,neg-c 
; <ex>If we hadn't sung, B'd've
; <nex>
; <todo>
; </type>
v_vp_had-n-sv_le := have_aux_neg_lex_entry & have_subj &
  [ SYNSEM have_aux_neg_fin_synsem ].

; *** should of ***

modal_of_synsem_min := synsem_min.
modal_of_synsem := psp_aux_verb_ssr & modal_of_synsem_min &
  [ LOCAL [ CAT [ HEAD [ VFORM fin,
			 PRD -,
			 TAM indic_tam &
			       [ TENSE present,
				 ASPECT.PRF + ] ],
		  VAL [ SUBJ < synsem & 
			       [ LOCAL [ CAT nomp_cat_nom_min,
					 CONJ cnil ],
				 OPT - ] >,
			COMPS < canonical_synsem &
				[ LOCAL.CONT.HOOK.LTOP #chand ] > ] ],
	    CONT [ HOOK [ LTOP #hand,
			  INDEX #index ],
		   RELS <! #keyrel & [ LBL #hand,
				       ARG0 #index,
				       ARG1 #arg1 ] !>,
		   HCONS <! qeq & [ HARG #arg1,
				    LARG #chand ] !> ] ],
    LKEYS.KEYREL #keyrel ].

; <type val="v_vp_mdl-of_le">
; <description>Cmps VP(psp), modal+of          
; <ex>B should of sung.
; <ex>B coulda sung.
; <nex>
; <todo>
; </type>
v_vp_mdl-of_le := psp_aux_verb_word & 
  [ SYNSEM modal_of_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM modal_of_synsem_min ],
    ALTS.CSAI - ].

; *** Generic BE ***

be_verb := nonc-hm &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < synsem_min & 
                                  [ LOCAL [ CAT nomp_cat_min,
                                            CONJ cnil ] ] >,
                           COMPS < synsem & [ OPT - ], ... >,
			   SPCMPS < > ] ].

; DPF 20-Oct-01 - Changed [TAM.ASPECT strict_nonprf] to nonprf, since it was
; blocking coordination of "Kim has arrived and Sandy is happy".  This change
; now allows "Kim is being hiring Browne" but we can live with it for now.

be_fin := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin,
				PRD -,
				TAM.ASPECT.PRF - ],
			 POSTHD +,
			 VAL.SUBJ < synsem & 
				    [ LOCAL [ CAT nomp_cat_nom_min,
					      CONJ cnil ],
				      OPT - ] > ],
		   CONT psoa ] ].

be_pres := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM indic_tam &
                              [ TENSE present,
                                MOOD indicative ],
    ALTS.CSAI - ].

be_past := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM indic_tam &
                              [ TENSE past ],
    ALTS.CSAI - ].

be_subj := be_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; Make be_prespart unmarked for PRD so we can block the identity-copula reading
; for "Kim is being good" while allowing the predicative-copula reading.
; 20-Oct-01 - Added POSTHD + to block pre-noun modification as in "*the being
; Kim person arrived"
; Added SLASH 0-dlist to avoid endless recursion when generating, since we no
; longer block "Kim is being silly", and don't want to use VFORM to block
; "Kim is being arriving" since that would put VFORM on type subst (too high),
; even though we'd like to exclude this example.  So we add COMPS..AUX - to
; prevent "*Kim is being being silly", which avoids the worst case.
; DPF 18-oct-03 - Also add COMPS..ASPECT.PROGR - to block *Kim is being singing
; DPF 24-feb-09 - Add NORM norm_rel to prevent N-V compound for "human being"

be_prespart := be_verb &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ VFORM prp,
                                INV -,
				MINORS.NORM norm_rel ],
                         VAL.COMPS < [ LOCAL.CAT.HEAD.AUX - ], ... >,
                         POSTHD + ],
             NONLOC.SLASH 0-dlist ] ].

be_pastpart := be_verb &
  [ ORTH < "been" >,
    SYNSEM.LOCAL [ CAT [ HEAD [ TAM.ASPECT.PRF +,
                                PRD -,
                                INV - ],
                         POSTHD + ],
		   CONT psoa ] ]. 
be_neg := sign &
  [ INFLECTD +,
    SYNSEM lex_synsem &
	   [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          HCONS.LIST < qeq &
				       [ HARG #arghand,
					 LARG #khand ], ... > ],
	     LKEYS [ KEYREL.LBL #khand,
                     ALT2KEYREL adv_relation &
                                [ LBL #ltop,
                                  PRED neg_rel,
                                  ARG1 #arghand ] ] ] ].

be_be_lex_entry := be_verb & 
  [ SYNSEM.LOCAL.CAT [ HEAD [ PRD -,
                              TAM.ASPECT.PRF -,
                              INV - ],
                       VAL.SUBJ < synsem & [ OPT - ] > ] ].

be_being_lex_entry := be_prespart &
  [ ORTH < "being" > ].

be_been_lex_entry := be_pastpart & 
  [ ORTH < "been" >,
    SYNSEM.LOCAL.CAT.HEAD.VFORM psp ].

be_pres_lex_entry := be_pres.

be_past_lex_entry := be_past.

be_subj_lex_entry := be_subj.

be_pres_neg_lex_entry := be_pres & be_neg.
be_past_neg_lex_entry := be_past & be_neg.
be_subj_neg_lex_entry := be_subj & be_neg &
  [ ALTS.CSAI - ].

be_am_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1s ] ].

be_is_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

be_are_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

be_was_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 13s ] ].

be_were_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

be_was_subjnct_lex_entry := be_subj_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 13s ],
    ALTS.CSAI - ].

be_were_subjnct_lex_entry := be_subj_lex_entry.

; aren't
be_am_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD.INV +,
                         VAL.SUBJ < [ --SIND.PNG #png ] > ],
                   AGR.PNG png & #png & [ PN 1s ] ] ].

; 'm not
be_am_neg_contr_noinv_lex_entry := be_pres_neg_lex_entry & aux_not_contr &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 1s ] ].

; isn't
be_is_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

; 's not
be_is_neg_contr_noinv_lex_entry := be_pres_neg_lex_entry & aux_not_contr &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

; aren't
be_are_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

; 're not
be_are_neg_contr_noinv_lex_entry := be_pres_neg_lex_entry & aux_not_contr &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

be_was_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 13s ] ].

be_was_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 13s ] ].

be_were_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -13s ] ].

be_were_subjnct_neg_contr_lex_entry := be_subj_neg_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM subjnct_tam ].

; *** Copula BE ***

; DPF 27-Nov-99 - Made KEYREL.LBL identified with COMPS..KEYREL.LBL,
; to avoid assymetry of LBL for VM, which was causing errors
; for e.g. "it is really going to be".  This used to lose a possible ambiguity
; for e.g. "kim is not sleeping", since the support_rel will always be in
; the scope of the negation, regardless of whether the "not" attaches to
; "be" or to the complement phrase.  
; DPF 01-Mar-00 - But now that we've eliminated support_rels, it may work ok.

be_copula := prd_aux_verb_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.TAM #tam,
			 VAL.COMPS.FIRST.LOCAL.CAT.HEAD.TAM #tam ],
             LKEYS.KEYREL.PRED be_v_prd_rel ] ].

be_cop_pos_generic := be_copula &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		   CONT [ HOOK.LTOP #ltop,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

be_cop_pos := be_cop_pos_generic.

be_cop_neg := be_copula &
  [ SYNSEM [ LOCAL [ CONT [ HOOK.LTOP #ltop,
                            RELS <! #alt2keyrel !>,
			    HCONS <! qeq !> ] ],
             LKEYS.ALT2KEYREL #alt2keyrel & [ LBL #ltop ] ] ].

vc_prd_be_lexent := be_be_lex_entry & be_cop_pos_generic.

; <type val="v_prd_be_le">
; <description>Cmps Pred-phr, be, bse           
; <ex>B will be ready.
; <nex>
; <todo>
; </type>
v_prd_be_le := vc_prd_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse ].

; DPF 18-oct-03 - Added COMPS..ALTMIN no_rel to block "being arriving" while
; still allowing "being hired", "being happy", "being in Berlin"
; DPF 03-oct-06 - But now using ALTMIN to control application of partitive
; rule to superlative adjectives, so need to make this COMPS..ALTMIN more
; specific, to include prd adjs and PPs, but exclude pres-participle verbs,
; so use event_dim_rel.

; <type val="v_prd_being_le">
; <description>Cmps Pred-phr, be, prp           
; <ex>B is being silly.
; <nex>
; <todo>
; </type>
v_prd_being_le := be_being_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.CAT [ HEAD [ PRD +,
                              TAM.ASPECT.PROGR + ],
                       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN 
                                                            event_dim_rel ] ].

; For robust variants
vc_prd_been_lexent := be_pastpart & be_cop_pos_generic.
vc_np_been_lexent := be_pastpart & be_id_pos.

; <type val="v_prd_been_le">
; <description>Cmps Pred-phr, be, psp           
; <ex>B has been ready.
; <nex>
; <todo>
; </type>
v_prd_been_le := be_been_lex_entry & be_cop_pos_generic.

; <type val="v_prd_am_le">
; <description>Cmps Pred-phr, be, pr1sg         
; <ex>I am ready. 
; <nex>
; <todo>
; </type>
v_prd_am_le := be_am_lex_entry & be_cop_pos.
; <type val="v_prd_am-cx_le">
; <description>Cmps Pred-phr, be, pr1sg, contr  
; <ex>I'm ready.  
; <nex>
; <todo>
; </type>
v_prd_am-cx_le := be_am_lex_entry & be_cop_pos & contracted_aux_word.
vc_prd_is_lexent := be_is_lex_entry & be_cop_pos.
; <type val="v_prd_is_le">
; <description>Cmps Pred-phr, be, pr3sg         
; <ex>B is ready. 
; <nex>
; <todo>
; </type>
v_prd_is_le := vc_prd_is_lexent.
; <type val="v_prd_is-cx_le">
; <description>Cmps Pred-phr, be, pr3sg, contr  
; <ex>B's ready.  
; <nex>
; <todo>
; </type>
v_prd_is-cx_le := vc_prd_is_lexent & contracted_aux_word.
vc_prd_are_lexent := be_are_lex_entry & be_cop_pos.
; <type val="v_prd_are_le">
; <description>Cmps Pred-phr, be, pr n3sg       
; <ex>We are ready.
; <nex>
; <todo>
; </type>
v_prd_are_le := vc_prd_are_lexent.
; <type val="v_prd_are-cx_le">
; <description>Cmps Pred-phr, be, pr n3sg,contr 
; <ex>We're ready.
; <nex>
; <todo>
; </type>
v_prd_are-cx_le := vc_prd_are_lexent & contracted_aux_word.

vc_prd_was_lexent := be_was_lex_entry & be_cop_pos.
; <type val="v_prd_was_le">
; <description>Cmps Pred-phr, be, past, sg      
; <ex>B was ready.  
; <nex>
; <todo>
; </type>
v_prd_was_le := vc_prd_was_lexent.
; <type val="v_prd_was-sv_le">
; <description>Cmps Pred-phr, be, subjcv, sg    
; <ex>If B was ready, C would be
; <nex>
; <todo>
; </type>
v_prd_was-sv_le := be_was_subjnct_lex_entry & be_cop_pos.

vc_prd_were_lexent := be_were_lex_entry & be_cop_pos.
; <type val="v_prd_wre_le">
; <description>Cmps Pred-phr, be, past, plural  
; <ex>We were ready.            
; <nex>
; <todo>
; </type>
v_prd_wre_le := vc_prd_were_lexent.
; <type val="v_prd_wre-sv_le">
; <description>Cmps Pred-phr, be, subjcv, plur  
; <ex>If we were ready, C'd be. 
; <nex>
; <todo>
; </type>
v_prd_wre-sv_le := be_were_subjnct_lex_entry & be_cop_pos.

; <type val="v_prd_am-n_le">
; <description>Cmps Pred-phr, be, pr1sg,ngc,inv 
; <ex>Aren't I ready?           
; <nex>
; <todo>
; </type>
v_prd_am-n_le := be_am_neg_contr_lex_entry & be_cop_neg.
; <type val="v_prd_am-n-niv_le">
; <description>Cmps Pred-phr, be,pr1sg,ngc,ninv 
; <ex>I'm not ready.            
; <nex>
; <todo>
; </type>
v_prd_am-n-niv_le := be_am_neg_contr_noinv_lex_entry & be_cop_neg.
; <type val="v_prd_is-n_le">
; <description>Cmps Pred-phr, be, pr3sg, contr  
; <ex>B's not ready.            
; <nex>
; <todo>
; </type>
v_prd_is-n_le := be_is_neg_contr_lex_entry & be_cop_neg.
; <type val="v_prd_is-n-niv_le">
; <description>Cmps Pred-phr, be,pr3s,cntr,ninv 
; <ex>B isn't ready.            
; <nex>
; <todo>
; </type>
v_prd_is-n-niv_le := be_is_neg_contr_noinv_lex_entry & be_cop_neg.
; <type val="v_prd_are-n_le">
; <description>Cmps Pred-phr, be, prn3sg, contr 
; <ex>We're not ready.          
; <nex>
; <todo>
; </type>
v_prd_are-n_le := be_are_neg_contr_lex_entry & be_cop_neg.
; <type val="v_prd_are-n-niv_le">
; <description>Cmps Pred-phr, be,prn3s,ctr,ninv 
; <ex>We aren't ready.          
; <nex>
; <todo>
; </type>
v_prd_are-n-niv_le := be_are_neg_contr_noinv_lex_entry & be_cop_neg.
; <type val="v_prd_was-n_le">
; <description>Cmps Pred-phr, be, pastsg, ngc   
; <ex>B wasn't ready.           
; <nex>
; <todo>
; </type>
v_prd_was-n_le := be_was_neg_contr_lex_entry & be_cop_neg.
; <type val="v_prd_was-n-sv_le">
; <description>Cmps Pred-phr, be, subjcv,sg,ngc 
; <ex>If B wasn't ready, C'd be.
; <nex>
; <todo>
; </type>
v_prd_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_cop_neg.
; <type val="v_prd_wre-n_le">
; <description>Cmps Pred-phr, be, pastpl, ngc   
; <ex>We weren't ready.         
; <nex>
; <todo>
; </type>
v_prd_wre-n_le := be_were_neg_contr_lex_entry & be_cop_neg.
; <type val="v_prd_wre-n-sv_le">
; <description>Cmps Pred-phr, be, subjcv,pl,ngc 
; <ex>If we weren't, C'd be.
; <nex>
; <todo>
; </type>
v_prd_wre-n-sv_le := be_were_subjnct_neg_contr_lex_entry & be_cop_neg.

; *** Identity BE ***
; For now, exclude gerundive complements, to avoid semantically anomalous
; reading for "Kim is sleeping"
; DPF 08-Jan-00 Made COMP be nom_rel instead of reg_nom_rel, to allow "Tuesday
; is my last day" and "that's him".
; DPF 22-Feb-01 - Added ALTMIN restriction on SUBJ to prevent free relatives
; from appearing in subject position, to get the contrast of "I admire what
; you are" vs. "*I admire what are you" (and cf. "I admire what is best").
; DPF 26-Aug-01 - Added MIN nom_rel to SUBJ, like for COMP, to avoid having
; measure_nps in subject position.
; DPF 19-Oct-02 - Removed identification of PRONTYPE on SUBJ and COMP, since
; this blocks "it is I/me" "that's me" etc.
; DPF 27-Apr-03 - Removed [COMPS..PRD -] since this prevents 'today is December
; third', and it's not clear what it was blocking.  (Nor is it clear why
; 'third' has to be [PRD +].)
; DPF 10-Jun-03 - Try identifying SORT values of subj and comp.
; DPF 5-Sep-03 - Don't understand comment of 22-Feb-02 above, but clearly
; free relatives can be subjects of identity copula: "What he does is your
; problem".  So removed this constraint.
; DPF 18-dec-03 - Keeping identity of SORT values is too hard - e.g. "The
; cabin is a good place to stay".  
; DPF 30-aug-04 - Removed PRONTYPE real_pron from SUBJ, since it
; prevented "consultant hiring is a disadvantage" with N-N-cmpnd subject NP.
; Leave on COMPS for now, to continue to block spurious analysis for
; "the boy is fishing."
; DPF 19-nov-04 - Removed identification of SUBJ..AGR with SUBJ..--SIND since
; want "three kilometers" measure-NP to be syntactically singular, even though
; semantic index comes from "kilometers" which is plural.
; DPF 05-nov-05 - Added CASE non_obliq to COMPS to block idiomatic detless NPs
; as in 'on top' from giving "*Kim is top."
; DPF 13-nov-05 - But sadly this also blocks "This is why we suffer".  So
; instead try requiring non-empty SPEC, where detless NPs have SPEC < >.
; DPF 28-oct-06 - Removed PRONTYPE real_pron from COMPS, since we want to
; allow "The reason is the fishing."  No longer getting as much spurious
; ambiguity, for example with "The boy is fishing."  See if too much remains.
; DPF 25-may-10 - Re 13-nov-05: No longer necessary, and SPEC *cons* was
; blocking "the cost is $100."
; DPF 04-jun-10 - Added COMPS..CASE non_obliq to prevent bare-sg nouns in PET,
; as in "*Kim is being in Paris"
; DPF 2010-sept-08 - Re 04-jun-10: But we also want to use CASE to exclude
; spurious analysis for "Where is Kim".  So change CASE to nom_or_obliq, and
; instead use HEAD mobile to exclude bare-sg nouns in PET (which does not
; currently attend to constraints in idioms.tdl).

id_cop_verb_min := synsem_min.
id_cop_verb := aux_verb & basic_two_arg & two_arg_subst & id_cop_verb_min &
  [ LOCAL [ CAT [ HEAD.MINORS [ MIN be_v_id_rel,
				ALTMIN nonpass_rel ],
                  VAL [ SUBJ < [ --MIN nom_or_mnp_rel,
                                 --SIND #id1ind & basic_non_expl &
                                       [ SORT #sort ],
                                 NONLOC non-local_norel ] >,
                        COMPS < [ --MIN nom_or_mnp_rel,
                                  LOCAL [ CAT [ HEAD supnoun & mobile &
						     [ POSS -,
						       MOD *anti_list*,
						       CASE nom_or_obliq ],
						VAL [ SUBJ *olist*,
						      SPR *olist*,
						      COMPS < > ],
						MC na_or_- ],
					  CONJ cnil ],
                                  --SIND #id2ind & non_expl-ind &
                                        [ SORT #sort ],
                                  NONLOC.REL 0-dlist ] > ] ],
            CONT.HOOK.XARG #id1ind ],
    LKEYS.KEYREL arg12_relation &
                 [ ARG0 non_conj_event,
		   ARG1 #id1ind,
                   ARG2 #id2ind ] ].

; Note: redefined in lextypes-epgy.tdl
be_id := be_verb &
  [ SYNSEM id_cop_verb &
	   [ LOCAL [ CONT [ HOOK.INDEX #event,
			    RELS.LIST.FIRST.ARG0 #event ],
		     CAT [ HEAD.LSYNSEM id_cop_verb_min,
			   VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
				 COMPS < [ LOCAL [ CAT.HEAD.--BARE -,
						   CONT.HOOK.LTOP #ltop ]] >]]],
	     LKEYS.KEYREL [ LBL #ltop,
			    PRED _be_v_id_rel ] ] ].

be_id_pos := be_id &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

be_id_neg_synsem := id_cop_verb &
  [ LKEYS.KEYREL.PRED _be_v_id_rel,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.--BARE - ] > ].

be_id_neg := be_id &
  [ SYNSEM be_id_neg_synsem & 
	   [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT [ RELS <! #keyrel, #alt2keyrel !>,
			    HCONS <! qeq !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALT2KEYREL #alt2keyrel ] ] ].

vc_np_be_lexent := be_be_lex_entry & be_id &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].
; <type val="v_np_be_le">
; <description>Cmps NP, be, bse                 
; <ex>B will be C. 
; <nex>
; <todo>
; </type>
v_np_be_le := vc_np_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse ].

; <type val="v_np_being_le">
; <description>Cmps NP, be, prp                 
; <ex>B is being C. 
; <nex>
; <todo>
; </type>
v_np_being_le := be_being_lex_entry & be_id &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR +,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

; <type val="v_np_been_le">
; <description>Cmps NP, be, psp                 
; <ex>B has been C.
; <nex>
; <todo>
; </type>
v_np_been_le := be_been_lex_entry & be_id_pos.

; <type val="v_np_am_le">
; <description>Cmps NP, be, pr1sg               
; <ex>I am C. 
; <nex>
; <todo>
; </type>
v_np_am_le := be_am_lex_entry & be_id_pos.
; <type val="v_np_am-cx_le">
; <description>Cmps NP, be, pr1sg, contr        
; <ex>I'm C.  
; <nex>
; <todo>
; </type>
v_np_am-cx_le := be_am_lex_entry & be_id_pos & contracted_aux_word.
; <type val="v_np_is_le">
; <description>Cmps NP, be, pr3sg               
; <ex>B is C. 
; <nex>
; <todo>
; </type>
v_np_is_le := be_is_lex_entry & be_id_pos.
; <type val="v_np_is-cx_le">
; <description>Cmps NP, be, pr3sg, contr        
; <ex>B's C.  
; <nex>
; <todo>
; </type>
v_np_is-cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word.
; <type val="v_np_are_le">
; <description>Cmps NP, be, pr n3sg             
; <ex>We are C
; <nex>
; <todo>
; </type>
v_np_are_le := be_are_lex_entry & be_id_pos.
; <type val="v_np_are-cx_le">
; <description>Cmps NP, be, pr n3sg,contr       
; <ex>We're C.
; <nex>
; <todo>
; </type>
v_np_are-cx_le := be_are_lex_entry & be_id_pos & contracted_aux_word.
; <type val="v_np_was_le">
; <description>Cmps NP, be, past, sg            
; <ex>B was C.  
; <nex>
; <todo>
; </type>
v_np_was_le := be_was_lex_entry & be_id_pos.
; <type val="v_np_was-sv_le">
; <description>Cmps NP, be, subjct, sg          
; <ex>If B was C, D would be.
; <nex>
; <todo>
; </type>
v_np_was-sv_le := be_was_subjnct_lex_entry & be_id_pos.
; <type val="v_np_wre_le">
; <description>Cmps NP, be, past, plural        
; <ex>We were C.            
; <nex>
; <todo>
; </type>
v_np_wre_le := be_were_lex_entry & be_id_pos.
; <type val="v_np_wre-sv_le">
; <description>Cmps NP, be, subjct, plur        
; <ex>If we were C, D'd be. 
; <nex>
; <todo>
; </type>
v_np_wre-sv_le := be_were_subjnct_lex_entry & be_id_pos.

; <type val="v_np_am-n_le">
; <description>Cmps NP, be, pr1sg,ngc,inv       
; <ex>Aren't I C?           
; <nex>
; <todo>
; </type>
v_np_am-n_le := be_am_neg_contr_lex_entry & be_id_neg.
; <type val="v_np_am-n-niv_le">
; <description>Cmps NP, be,pr1sg,ngc,ninv       
; <ex>I'm not C.            
; <nex>
; <todo>
; </type>
v_np_am-n-niv_le := be_am_neg_contr_noinv_lex_entry & be_id_neg.

v_np_is-n_lexent := be_is_neg_contr_lex_entry & be_id_neg.
; <type val="v_np_is-n_le">
; <description>Cmps NP, be, pr3sg, contr        
; <ex>B isn't C.            
; <nex>
; <todo>
; </type>
v_np_is-n_le := v_np_is-n_lexent.

; <type val="v_np_is-n-niv_le">
; <description>Cmps NP, be,pr3s,cntr,ninv       
; <ex>B's not C.            
; <nex>
; <todo>
; </type>
v_np_is-n-niv_le := be_is_neg_contr_noinv_lex_entry & be_id_neg.

v_np_are-n_lexent := be_are_neg_contr_lex_entry & be_id_neg.
; <type val="v_np_are-n_le">
; <description>Cmps NP, be, prn3sg, contr       
; <ex>We aren't C.          
; <nex>
; <todo>
; </type>
v_np_are-n_le := v_np_are-n_lexent.
; <type val="v_np_are-n-niv_le">
; <description>Cmps NP, be,prn3s,ctr,ninv       
; <ex>We're not C.          
; <nex>
; <todo>
; </type>
v_np_are-n-niv_le := be_are_neg_contr_noinv_lex_entry & be_id_neg.

v_np_was-n_lexent := be_was_neg_contr_lex_entry & be_id_neg.
; <type val="v_np_was-n_le">
; <description>Cmps NP, be, pastsg, ngc         
; <ex>B wasn't C.           
; <nex>
; <todo>
; </type>
v_np_was-n_le := v_np_was-n_lexent.
; <type val="v_np_was-n-sv_le">
; <description>Cmps NP, be, subjct,sg,ngc       
; <ex>If B wasn't C, D'd be.
; <nex>
; <todo>
; </type>
v_np_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_id_neg.

v_np_wre-n_lexent := be_were_neg_contr_lex_entry & be_id_neg.
; <type val="v_np_wre-n_le">
; <description>Cmps NP, be, pastpl, ngc         
; <ex>We weren't C.         
; <nex>
; <todo>
; </type>
v_np_wre-n_le := v_np_wre-n_lexent.
; <type val="v_np_wre-n-sv_le">
; <description>Cmps NP, be, subjct,pl,ngc       
; <ex>If we weren't, C'd be.xo
; <nex>
; <todo>
; </type>
v_np_wre-n-sv_le := be_were_subjnct_neg_contr_lex_entry & be_id_neg.

; Note that for "it's because Kim arrived." the ARG1 of the subord_rel is
; incorrectly not bound to any lbl.  Awkward to get right, since no handle
; for "the reason is because Kim arrived".  FIX...
; DPF 13-may-08 - Removed --COMPHD comp_or_p because we also want to
; get "The short answer is nobody wins."  So far this was the only use of
; the feature, so maybe discard.
; DPF 27-may-08 - Added POSTHD + to block spurious analysis for
; "Kim is of programmers."
; DPF 23-apr-09 - Added ALTMIN aux_event_rel to prevent 'being' from 
; undergoing adj_attr_verb_tr_part lexical rule as in *|the being six|
;; DPF 2012-11-09 - Added COMPS..LEX - to prevent spurious reading of
;; |that was so.|

nv_cop_verb_min := synsem_min.
nv_cop_verb := aux_verb & two_arg_subst & basic_two_arg & cp_addin_tam_pn &
	       nv_cop_verb_min &
  [ LOCAL [ CAT [ HEAD.MINORS [ MIN be_v_nv_rel,
				ALTMIN aux_event_rel ],
                  VAL [ SUBJ < synsem_min &
			       [ --MIN nom_or_mnp_rel,
                                 --SIND #id1ind & non_expl-ind &
				       [ SORT nom-event ],
                                 NONLOC #nonloc ] >,
                        COMPS < canonical_synsem &
				[ --MIN verb_or_subord_rel,
                                  LOCAL [ CAT [ HEAD verbal_or_p &
						     [ MINORS.NORM norm_rel,
						       PRD -,
						       TAM indic_tam & #tam,
						       --ADDIN [ ADDPN #pn,
								 ADDTAM #tam ]],
                                                VAL [ SUBJ *anti_list*,
                                                      COMPS < > ],
						POSTHD +,
						MC - ],
					  AGR.PNG.PN #pn,
                                          CONT.HOOK [ LTOP #cltop,
						      INDEX [ SF prop-or-ques,
							      --TPC - ],
						      XARG.SORT
						       basic-entity-or-event ],
					  CONJ cnil ],
				  LEX -,
                                  NONLOC non-local_none ] > ] ],
	    CONT.HOOK.XARG #id1ind ],
    NONLOC #nonloc,
    LKEYS.KEYREL arg12_relation &
                 [ PRED _be_v_nv_rel,
		   ARG0 non_conj_event,
                   ARG1 #id1ind,
                   ARG2 #cltop ] ].

be_nv := be_verb &
  [ SYNSEM nv_cop_verb &
	   [ LOCAL [ CAT.HEAD.LSYNSEM nv_cop_verb_min,
		     CONT [ HOOK.INDEX #event,
			    RELS.LIST.FIRST.ARG0 #event ] ] ],
    ALTS.VPELLIP - ].

be_nv_pos := be_nv &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

be_nv_neg_synsem := nv_cop_verb.

be_nv_neg := be_nv &
  [ SYNSEM be_nv_neg_synsem & 
	   [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
		     CONT [ RELS <! #keyrel, #alt2keyrel !>,
			    HCONS <! qeq !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALT2KEYREL #alt2keyrel ] ] ].

; <type val="v_cp_be_le">
; <description>Cmps S, be, bse                  
; <ex>The plan'll be that C wins
; <nex>
; <todo>
; </type>
v_cp_be_le := be_be_lex_entry & be_nv &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ TAM.ASPECT.PROGR -,
				VFORM bse ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

; <type val="v_cp_being_le">
; <description>Cmps S, be, prp                  
; <ex>The plan being C won, I do
; <nex>
; <todo>
; </type>
v_cp_being_le := be_being_lex_entry & be_nv &
  [ SYNSEM [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR +,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

; <type val="v_cp_been_le">
; <description>Cmps S, be, psp                  
; <ex>The plan'd been that C won
; <nex>
; <todo>
; </type>
v_cp_been_le := be_been_lex_entry & be_nv_pos.
; <type val="v_cp_is_le">
; <description>Cmps S, be, pr3sg                
; <ex>The plan is that C won.
; <nex>
; <todo>
; </type>
v_cp_is_le := be_is_lex_entry & be_nv_pos.
; <type val="v_cp_is-cx_le">
; <description>Cmps S, be, pr3sg, contr         
; <ex>The plan's that C won.
; <nex>
; <todo>
; </type>
v_cp_is-cx_le := be_is_lex_entry & be_nv_pos & contracted_aux_word.
; <type val="v_cp_are_le">
; <description>Cmps S, be, pr n3sg              
; <ex>The plans are that C wins.
; <nex>
; <todo>
; </type>
v_cp_are_le := be_are_lex_entry & be_nv_pos.
; <type val="v_cp_was_le">
; <description>Cmps S, be, past, sg             
; <ex>The plan was that C won.
; <nex>
; <todo>
; </type>
v_cp_was_le := be_was_lex_entry & be_nv_pos.
; <type val="v_cp_was-sv_le">
; <description>Cmps S, be, subjct, sg           
; <ex>If the plan was S, D would
; <nex>
; <todo>
; </type>
v_cp_was-sv_le := be_was_subjnct_lex_entry & be_nv_pos.
; <type val="v_cp_wre_le">
; <description>Cmps S, be, past, subjunctive
; <ex>We prefer that the plan were that C won.
; <nex>
; <todo>
; </type>
v_cp_wre_le := be_were_lex_entry & be_nv_pos.
; <type val="v_cp_wre-sv_le">
; <description>Cmps S, be, subjct, plur         
; <ex>If plans were S, D'd be. 
; <nex>
; <todo>
; </type>
v_cp_wre-sv_le := be_were_subjnct_lex_entry & be_nv_pos.

; <type val="v_cp_is-n_le">
; <description>Cmps S, be, pr3sg, contr         
; <ex>The plan isn't that S.
; <nex>
; <todo>
; </type>
v_cp_is-n_le := be_is_neg_contr_lex_entry & be_nv_neg.
; <type val="v_cp_are-n_le">
; <description>Cmps S, be, prn3sg, contr        
; <ex>The plans aren't that S.
; <nex>
; <todo>
; </type>
v_cp_are-n_le := be_are_neg_contr_lex_entry & be_nv_neg.
; <type val="v_cp_was-n_le">
; <description>Cmps S, be, pastsg, ngc          
; <ex>The plan wasn't that S.
; <nex>
; <todo>
; </type>
v_cp_was-n_le := be_was_neg_contr_lex_entry & be_nv_neg.
; <type val="v_cp_was-n-sv_le">
; <description>Cmps S, be, subjct,sg,ngc        
; <ex>If the plan wasn't S, C is
; <nex>
; <todo>
; </type>
v_cp_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_nv_neg.
; <type val="v_cp_wre-n_le">
; <description>Cmps S, be, pastpl, ngc          
; <ex>The plans weren't that S.
; <nex>
; <todo>
; </type>
v_cp_wre-n_le := be_were_neg_contr_lex_entry & be_nv_neg.
; <type val="v_cp_wre-n-sv_le">
; <description>Cmps S, be, subjct,pl,ngc        
; <ex>If plans weren't, C'd go.
; <nex>
; <todo>
; </type>
v_cp_wre-n-sv_le := be_were_subjnct_neg_contr_lex_entry & be_nv_neg.

; *** There Copula BE ***

;; The relationship between the first COMP and the second cannot be one of
;; raising (since if the first is extracted its SLASH will be non-empty, and
;; that non-empty SLASH would also erroneously appear on the VP.  So the 
;; control relation must be equi rather than raising.
;; DPF 2-May-01 - HACK: To avoid spurious ambiguity temporarily, block second 
;; arg by changing its MIN from independent_rel to no_rel.
;; DPF 29-may-07 - Removed AUX + to allow extraction of modifiers, as for
;; "occasionally there are unicorns in the garden".  FIX?

there_cop_verb_min := synsem_min.
there_cop_verb := there_verb_synsem & aux_verb & there_cop_verb_min &
  [ LOCAL.CAT.HEAD.MINORS.MIN be_v_there_rel,
    LKEYS [ KEYREL.PRED _be_v_there_rel,
            --+ARGIND there-ind ] ].

be_th_cop := be_verb & 
  [ SYNSEM there_cop_verb & 
	   [ LOCAL.CAT [ HEAD.LSYNSEM there_cop_verb_min,
			 VAL.COMPS.FIRST.LOCAL.CONT.HOOK.LTOP #ltop ],
	     LKEYS.KEYREL.LBL #ltop ] ].

be_th_cop_pos := be_th_cop &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop,
				 INDEX #event ],
			  RELS <! #keyrel !>,
			  HCONS <! !> ],
	     LKEYS.KEYREL #keyrel & [ LBL #ltop,
				      ARG0 #event ] ] ].

be_th_cop_neg := be_th_cop &
  [ SYNSEM [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! #keyrel, #alt2keyrel !>,
			  HCONS <! qeq !> ],
             LKEYS [ KEYREL #keyrel,
                     ALT2KEYREL #alt2keyrel & [ LBL #ltop ] ] ] ].

; <type val="v_np-xp_be_le">
; <description>Cmps NP,Prd-p, be,ex-s,bse       
; <ex>There will be music.
; <nex>
; <todo>
; </type>
v_np-xp_be_le := be_be_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse_only ].

; <type val="v_np-xp_being_le">
; <description>Cmps NP,Prd-p, be,ex-s,prp       
; <ex>There being music, C went.
; <nex>
; <todo>
; </type>
v_np-xp_being_le := be_being_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD -,
                            TAM.ASPECT.PROGR - ] ].

; <type val="v_np-xp_been_le">
; <description>Cmps NP,Prd-p, be,ex-s,psp       
; <ex>There has been music.
; <nex>
; <todo>
; </type>
v_np-xp_been_le := be_been_lex_entry & be_th_cop_pos.

vc_there_is_lexent := be_is_lex_entry & be_th_cop_pos.
; <type val="v_np-xp_is_le">
; <description>Cmps NP,Prd-p, be,ex-s,prsg      
; <ex>There is music.
; <nex>
; <todo>
; </type>
v_np-xp_is_le := vc_there_is_lexent.
vc_there_are_lexent := be_are_lex_entry & be_th_cop_pos.
; <type val="v_np-xp_are_le">
; <description>Cmps NP,Prd-p, be,ex-s,prpl      
; <ex>There are songs.
; <nex>
; <todo>
; </type>
v_np-xp_are_le := vc_there_are_lexent.
; <type val="v_np-xp_is-pl_le">
; <description>Cmps NP,Prd-p, be,ex-s ispl      
; <ex>There is music and food.
; <nex>
; <todo>
; </type>
v_np-xp_is-pl_le := vc_there_are_lexent &
  [ GENRE nonformal ].

; DPF 04mar10 - Returned to using parent be_was_lex_entry rather than 
; be_past_lex_entry, to block "there was cats in the garden".
vc_there_was_lexent := be_was_lex_entry & be_th_cop_pos.
; <type val="v_np-xp_was_le">
; <description>Cmps NP,Prd-p, be,ex-s,ptsg      
; <ex>There was music.
; <nex>
; <todo>
; </type>
v_np-xp_was_le := vc_there_was_lexent.
; <type val="v_np-xp_was-sv_le">
; <description>Cmps NP,Prd-p, be,ex-s,svsg      
; <ex>If there was food, we'd go
; <nex>
; <todo>
; </type>
v_np-xp_was-sv_le := be_was_subjnct_lex_entry & be_th_cop_pos.

vc_there_were_lexent := be_were_lex_entry & be_th_cop_pos.
; <type val="v_np-xp_wre_le">
; <description>Cmps NP,Prd-p, be,ex-s,ptpl      
; <ex>There were songs.
; <nex>
; <todo>
; </type>
v_np-xp_wre_le := vc_there_were_lexent.
; <type val="v_np-xp_wre-sv_le">
; <description>Cmps NP,Prd-p, be,ex-s,svpl      
; <ex>If there were ice, we'd go
; <nex>
; <todo>
; </type>
v_np-xp_wre-sv_le := be_were_subjnct_lex_entry & be_th_cop_pos &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

; <type val="v_np-xp_is-cx_le">
; <description>Cmps NP,Prd-p, be,ex-s,prsg,cntr 
; <ex>There's music.
; <nex>
; <todo>
; </type>
v_np-xp_is-cx_le := be_pres_lex_entry & be_th_cop_pos & contracted_aux_word.
; <type val="v_np-xp_is-n_le">
; <description>Cmps NP,Prd-p, be,ex-s,prsg,n-cr 
; <ex>There isn't music.
; <nex>
; <todo>
; </type>
v_np-xp_is-n_le := be_is_neg_contr_lex_entry & be_th_cop_neg.
; <type val="v_np-xp_is-n-niv_le">
; <description>Cmps NP,Prd-p, be,ex-s,prsg,n,nv 
; <ex>There's not any music.
; <nex>
; <todo>
; </type>
v_np-xp_is-n-niv_le := be_is_neg_contr_noinv_lex_entry & be_th_cop_neg.
; <type val="v_np-xp_are-n_le">
; <description>Cmps NP,Prd-p, be,ex-s,prpl,n-cr 
; <ex>There aren't songs.
; <nex>
; <todo>
; </type>
v_np-xp_are-n_le := be_are_neg_contr_lex_entry & be_th_cop_neg.
; <type val="v_np-xp_was-n_le">
; <description>Cmps NP,Prd-p, be,ex-s,ptsg,n-cr 
; <ex>There wasn't music.
; <nex>
; <todo>
; </type>
v_np-xp_was-n_le := be_was_neg_contr_lex_entry & be_th_cop_neg.
; <type val="v_np-xp_was-n-sv_le">
; <description>Cmps NP,Prd-p, be,ex-s,sbsg,n-cr 
; <ex>If there wasn't C, we'd go
; <nex>
; <todo>
; </type>
v_np-xp_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_th_cop_neg.
; <type val="v_np-xp_wre-n_le">
; <description>Cmps NP,Prd-p, be,ex-s,ptpl,n-cr 
; <ex>There weren't any songs.
; <nex>
; <todo>
; </type>
v_np-xp_wre-n_le := be_were_neg_contr_lex_entry & be_th_cop_neg.
; <type val="v_np-xp_wre-n-sv_le">
; <description>Cmps NP,Prd-p, be,ex-s,sbpl,n-cr 
; <ex>If there weren't C, B'd go
; <nex>
; <todo>
; </type>
v_np-xp_wre-n-sv_le := be_were_subjnct_neg_contr_lex_entry & 
                             be_th_cop_neg &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ] ].

; *** It-cleft Copula BE ***

be_it_cop := be_verb &
  [ SYNSEM itcleft_verb_synsem &
           [ LOCAL.CAT.HEAD.LSYNSEM itcleft_verb_synsem_min,
	     LKEYS.--+ARGIND it-ind ] ].

be_it_cop_pos := be_it_cop &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop,
                                 INDEX #event ],
			  RELS <! #keyrel !>,
			  HCONS <! !> ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
				      ARG0 #event ] ] ].

be_it_cop_neg := be_it_cop &
  [ SYNSEM [ LOCAL.CONT [ HOOK.LTOP #nltop,
                          RELS <! #keyrel, #alt2keyrel !>,
			  HCONS <! qeq & [ LARG #kltop ] !> ],
             LKEYS [ KEYREL #keyrel & [ LBL #kltop ],
                     ALT2KEYREL #alt2keyrel & [ LBL #nltop ] ] ] ].

; <type val="v_np-rc_be_le">
; <description>Cmps NP,Relcl, be,ex-s,bse       
; <ex>It will be C who wins.
; <nex>
; <todo>
; </type>
v_np-rc_be_le := be_be_lex_entry & be_it_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse_only ].

; <type val="v_np-rc_being_le">
; <description>Cmps NP,Relcl, be,ex-s,prp       
; <ex>It being C who won, D lost
; <nex>
; <todo>
; </type>
v_np-rc_being_le := be_being_lex_entry & be_it_cop_pos &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD -,
                            TAM.ASPECT.PROGR - ] ].

; <type val="v_np-rc_been_le">
; <description>Cmps NP,Relcl, be,ex-s,psp       
; <ex>It has been C who wins.
; <nex>
; <todo>
; </type>
v_np-rc_been_le := be_been_lex_entry & be_it_cop_pos.
; <type val="v_np-rc_is_le">
; <description>Cmps NP,Relcl, be,ex-s,prsg      
; <ex>It is C who wins.
; <nex>
; <todo>
; </type>
v_np-rc_is_le := be_is_lex_entry & be_it_cop_pos.
; <type val="v_np-rc_was_le">
; <description>Cmps NP,Relcl, be,ex-s,ptsg      
; <ex>It was C who won.
; <nex>
; <todo>
; </type>
v_np-rc_was_le := be_was_lex_entry & be_it_cop_pos.
; <type val="v_np-rc_was-sv_le">
; <description>Cmps NP,Relcl, be,ex-s,sbsg      
; <ex>If it was C who is, B'd go
; <nex>
; <todo>
; </type>
v_np-rc_was-sv_le := be_was_subjnct_lex_entry & be_it_cop_pos.

; <type val="v_np-rc_is-cx_le">
; <description>Cmps NP,Relcl, be,ex-s,pr,cntr   
; <ex>It's C who wins.
; <nex>
; <todo>
; </type>
v_np-rc_is-cx_le := be_pres_lex_entry & be_it_cop_pos & contracted_aux_word.
; <type val="v_np-rc_is-n_le">
; <description>Cmps NP,Relcl, be,ex-s,pr,n-cr   
; <ex>It isn't C who wins.
; <nex>
; <todo>
; </type>
v_np-rc_is-n_le := be_is_neg_contr_lex_entry & be_it_cop_neg.
; <type val="v_np-rc_was-n_le">
; <description>Cmps NP,Relcl, be,ex-s,pt,n-cr   
; <ex>It wasn't C who won.
; <nex>
; <todo>
; </type>
v_np-rc_was-n_le := be_was_neg_contr_lex_entry & be_it_cop_neg.
; <type val="v_np-rc_was-n-sv_le">
; <description>Cmps NP,Relcl, be,ex-s,sbsg,n-cr 
; <ex>If it wasn't C who is, B'd
; <nex>
; <todo>
; </type>
v_np-rc_was-n-sv_le := be_was_subjnct_neg_contr_lex_entry & be_it_cop_neg.

;; do-be copula
;;
be_do_verb_synsem_min := synsem_min.
be_do_verb_synsem := aux_verb & basic_two_arg & be_do_verb_synsem_min &
  [ LOCAL [ CAT [ HEAD [ MINORS [ MIN _be_v_do_rel,
				  ALTMIN nonpass_rel ],
			 INV - ],
                  VAL [ SUBJ < [ LOCAL [ CAT np_cat_nom,
					 CONT.HOOK [ INDEX #id1ind &
							   [ SORT do-event,
							     IFORM #iform ],
						     XARG #xarg ] ],
                                 NONLOC non-local_none,
				 LEX - ] >,
                        COMPS < expressed_synsem &
				[ LOCAL [ CAT vp_cat &
					  [ HEAD [ MINORS.MIN v_event_rel,
						   VFORM fin_or_bse_or_part &
							      #iform ],
					    VAL.SUBJ < synsem > ],
					  AGR.PNG.PN #pn,
					  CONT.HOOK [ LTOP #vltop,
						      INDEX #id2ind,
						      XARG #xarg & 
							   [ PNG.PN #pn ] ] ],
				  --SIND #id2ind,
				  NONLOC non-local_none,
				  OPT - ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
			  INDEX #event,
			  XARG #id1ind ],
		   RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #arg2,
				    LARG #vltop ] !> ] ],
    LEX +,
    LKEYS [ KEYREL arg12_relation & #keyrel &
                 [ LBL #ltop,
		   PRED _be_v_do_rel,
		   ARG0 #event & non_conj_event,
		   ARG1 #id1ind,
                   ARG2 #arg2 ],
	    --+COMPKEY _do_v_be_rel ] ].

be_do_verb_lexent := be_verb & 
  [ SYNSEM be_do_verb_synsem &
	   [ LOCAL.CAT.HEAD.LSYNSEM be_do_verb_synsem_min ] ].

; <type val="v_vp_do-be_le">
; <description>Cmps: base VP, do-be only
; <ex>What we'll do will be hire a manager.
; <nex>
; <todo>
; </type>
v_vp_do-be_le := be_be_lex_entry & be_do_verb_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM bse_only ].

; <type val="v_vp_do-been_le">
; <description>Cmps: base VP, do-be only
; <ex>What he's done has been hire a manager.
; <nex>
; <todo>
; </type>
v_vp_do-been_le := be_been_lex_entry & be_do_verb_lexent.

; <type val="v_vp_do-is_le">
; <description>Cmps: base VP, do-be only
; <ex>What he's done is hire a manager.
; <nex>
; <todo>
; </type>
v_vp_do-is_le := be_is_lex_entry & be_do_verb_lexent.

; <type val="v_vp_do-are_le">
; <description>Cmps: base VP, do-be only
; <ex>The things we do are arrive and leave.
; <nex>
; <todo>
; </type>
v_vp_do-are_le := be_are_lex_entry & be_do_verb_lexent.

; <type val="v_vp_do-was_le">
; <description>Cmps: base VP, do-be only
; <ex>What we did was hire a manager.
; <nex>
; <todo>
; </type>
v_vp_do-was_le := be_was_lex_entry & be_do_verb_lexent.

; <type val="v_vp_do-wre_le">
; <description>Cmps: base VP, do-be only
; <ex>The things we did were arrive and leave.
; <nex>
; <todo>
; </type>
v_vp_do-wre_le := be_were_lex_entry & be_do_verb_lexent.
