;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  auxverbs.tdl
;;;
;;;  The auxiliary verb system for English
;;;
;;;  Created: Rob Malouf, 17-Nov-1994
;;;  Last revision: Dan Flickinger, 20-Oct-97
;;;
;;;  $Id$

; *** Future WILL ***

will_aux_word := bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
                                TENSE future*,
				MOOD indicative* ],
			 VALENCE [ SUBJ < @nomp($case=nom) >,
				   COMPS.FIRST.LOCAL.CONT.INDEX #event ] ],
		   CONT [ INDEX #event,
			  KEY will_rel,
			  --STEMLISZT <! !> ] ] ].

will_aux_pos_lex_e := will_aux_word & non_affix_bearing & nonhcons & lex_entry &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS < [ LOCAL.CONT [ TOP #hand,
						      INDEX #index,
						      ECONT.TOP #hand ] ] >,
		   CONT [ TOP #hand,
			  INDEX #index,
			  KEY.HANDEL #hand,
			  --STEMLISZT <! !> ] ] ].

will_aux_pos_le :< will_aux_pos_lex_e.

will_aux_pos_cx_le := will_aux_pos_lex_e & contracted_aux_word.

will_aux_neg_mle1 := will_aux_word & multi_lex_entry1 &
  [ SYNSEM scoping_aux_verb &
	   [ LOCAL [ CAT [ VALENCE.COMPS.FIRST #comp,
			   --SCOPEDARG #comp & [ LOCAL.CONT.TOP #argh,
						 --ARG #arg,
						 --ARGH #argh ] ],
		     CONT [ TOP #hand,
			    --STEMLISZT [ LIST #list,
					  LAST #last ],
			    LISZT [ LIST < neg_rel &
					   [ HANDEL #hand,
					     ARG #arg ] . #list >,
				  LAST #last ] ] ] ],
    ARGS < [ AFFIX no-affix ] , ... > ].

;;; Modal verbs

modal_pos_lex_ent := pos_modal_verb_word & add_cont & non_affix_bearing & 
		     lex_entry.

modal_pos_le :< modal_pos_lex_ent.

modal_subj_pos_lex_ent := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOOD modal_subj* ].

modal_subj_pos_le :< modal_subj_pos_lex_ent.

modal_subj_pos_cx_le := modal_subj_pos_lex_ent & contracted_aux_word.

ought_pos_le := pos_ought_verb_word & add_cont & non_affix_bearing & 
		lex_entry.
past_ought_pos_le := past_ought_verb_word & add_cont & non_affix_bearing & 
		     lex_entry.

quasimodal_le := quasimodal_word & add_cont & non_affix_bearing & lex_entry.

generic_modal_neg := aux_verb_word &
  [ SYNSEM scoping_neg_aux_verb &
	   [ LOCAL [ CAT.--SCOPEDARG2.--ARG #arg,
		     CONT [ TOP #hand,
			    --STEMLISZT [ LIST #list & < #key, ... >,
					  LAST #last ],
			    LISZT [ LIST < neg_rel &
					   [ HANDEL #hand,
					     ARG #arg ] . #list >,
				    LAST #last ],
			    KEY #key ] ] ] ].

modal_neg_le := modal_verb_word & generic_modal_neg & lex_entry.
modal_neg_mle1 := modal_verb_word & generic_modal_neg & multi_lex_entry1.
modal_subj_neg_mle1 := modal_verb_word & generic_modal_neg & multi_lex_entry1 &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOOD modal_subj* ] ].

ought_neg_mle1 := ought_verb_word & generic_modal_neg & multi_lex_entry1.


; *** Auxiliary DO ***

; For tag questions we need the KEY of auxiliary _do_ to match all main verbs.
; The supertype for this is event_rel.  Originally, it had been no_rel, to 
; block _do_'s being a complement of other auxiliaries.  On the hypothesis
; that auxiliary _do_ in fact lacks a non-finite form all together, the
; do_aux_word type is constrained to VFORM fin, inherited from bse_aux_verb_word.

do_aux_word := bse_aux_verb_word & non_affix_bearing &
  [ SYNSEM.LOCAL [ CAT [ HEAD.VOICE active,
			 VALENCE [ SUBJ < @nomp($case=nom) >,
				   COMPS.FIRST.LOCAL.CAT.HEAD.AUX - ] ],
		   CONT.KEY mod_role_rel ] ].

; Removed raise-cont from parents, to allow EVENT to not be identified with the
; comp-dtr's EVENT   - is in conflict with collapsing of base and fin-non3rdsg 
; forms, given that we encode VIT attributes in the event feature structure.
; Sample problem: "Kim does sleep"

do_aux_pos_word := do_aux_word & raise_cont & nonhcons & lex_entry &
  [ SYNSEM.LOCAL.CONT.--TMP.FIN_VERB <! !> ].

do_aux_neg_word := do_aux_word & multi_lex_entry1 &
  [ SYNSEM scopedarg_synsem & 
	   [ LOCAL [ CAT [ VALENCE.COMPS.FIRST #comp,
			   --SCOPEDARG #comp & [ LOCAL.CONT.TOP #argh,
						 --ARG #arg,
						 --ARGH #argh ] ],
		     CONT [ TOP #hand,
			    INDEX event,
			    --STEMLISZT.LIST < neg_rel &
					       [ HANDEL #hand,
						 ARG #arg ], ... > ] ] ] ].
do_fin := do_aux_pos_word &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin,
				MOD @nbar(),
				PRD - ],
			 VALENCE.SUBJ < @nomp($case=nom) &
					[ OPT - ] > ],
		   CONT [ KEY #key,
			  ECONT [ KEY #key,
				  LISZT <! !> ] ] ] ].
do_pres := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE present*,
			    MOOD indicative* ] ].
does_aux_le := do_aux_pos_word & do_pres &
  [ SYNSEM.LOCAL.CAT.VALENCE.SUBJ < [ LOCAL.CONT.INDEX.PNG.PN 3sg ] > ].

do_fin_aux_le := do_aux_pos_word & do_pres &
  [ SYNSEM.LOCAL.CAT.VALENCE.SUBJ 
			     < [ LOCAL.CONT.INDEX.PNG.PN non3sg & strict_pn] > ].
did_aux_le := do_fin &
  [ SYNSEM.LOCAL.CAT.HEAD [ TENSE past*,
			    MOOD indicative* ] ].

do_aux_neg_pres := do_aux_neg_word &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE present*,
			      MOOD indicative* ],
		   CONT.--STEMLISZT <! neg_rel !> ] ].

do_aux_neg_past_mle1 := do_aux_neg_word &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE past*,
			      MOOD indicative* ],
		   CONT.--STEMLISZT <! neg_rel !> ] ].

do_aux_neg_subj_mle1 := do_aux_neg_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOOD subjunctive,
		   CONT [ TOP #hand,
			  --STEMLISZT <! neg_rel, irrealis_rel &
				     [ HANDEL #hand ] !> ] ] ].

; ERB (31-03-97) The agreement on do, but not have and be, was previously
; taken care of in lexicon.tdl.  I am making these types to move that
; information here for symmetry.  The rest of the do paradigm seems
; to be generated by lexical rules, so these two are the only types.

doesnt_aux_neg_pres_mle1 := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.AGR.PNG.PN 3sg ].

dont_aux_neg_pres_mle1 := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG.PN non3sg & strict_pn ].

; *** Perfect HAVE ***

have_aux_word := psp_aux_verb_word & non_affix_bearing &
  [ SYNSEM.LOCAL.CONT [ KEY #key,
			--TMP.HAVE.LIST < #key, ... > ] ].

have_aux_pos_lex_entry := have_aux_word & nonhcons & lex_entry &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS < [ LOCAL.CONT [ TOP #hand,
						      INDEX #index ] ] >,
		   CONT [ TOP #hand,
			  INDEX #index,
			  --TMP.HAVE #liszt,
			  --STEMLISZT #liszt ] ] ].

have_aux_neg_lex_entry := have_aux_word & multi_lex_entry1 &
  [ SYNSEM scopedarg_synsem &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD -,
				  MOD @nbar() ],
			   VALENCE [ SUBJ < [ OPT - ] >,
				     COMPS.FIRST #comp &
				      [ LOCAL.CONT.INDEX #vind ] ],
			   --SCOPEDARG #comp & [ LOCAL.CONT.TOP #argh,
						 --ARG #arg,
						 --ARGH #argh ] ],
		     CONT [ TOP #hand,
			    INDEX #vind,
			    --TMP [ HAVE [ LIST #list,
					   LAST #last ],
				    NEG #neg & [ LIST < neg_rel &
							[ HANDEL #hand,
							  ARG #arg ] . #list >,
						 LAST #last ] ],
			    --STEMLISZT #neg ] ] ] ].

have_fin := have_aux_word &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD [ VFORM fin,
				MOD @nbar(),
				PRD - ],
			 VALENCE.SUBJ < @nomp($case=nom) &
					[ OPT - ] > ],
		   CONT [ KEY #key,
			  ECONT [ KEY #key,
				    LISZT <! !> ] ] ] ].

have_pres := have_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE presperf*,
			      MOOD indicative* ],
		   CONT.--TMP.HAVE <! !> ] ].

have_past := have_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE pastperf*,
			      MOOD indicative* ],
		   CONT.--TMP.HAVE <! !> ] ].

have_subj := have_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE pastperf*,
			      MOOD subjunctive ],
		   CONT [ TOP #hand,
			  --TMP.HAVE <! irrealis_rel &
				    [ HANDEL #hand ] !> ] ] ].

have_prespart_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD +,
				MOD [ CAT [ HEAD noun,
					    VALENCE [ SPR < synsem >,
						      COMPS *olist* ] ],
				      CONT [ TOP #hand,
					     INDEX #nind ] ] ],
			 VALENCE.SUBJ < [ LOCAL.CONT.INDEX #nind ] > ],
		   CONT [ TOP #hand,
			  KEY.HANDEL #hand,
			  ECONT [ TOP #hand,
				    INDEX #nind,
				    LISZT <! !> ],
			  --TMP.HAVE <! prog_rel &
				    [ HANDEL #hand ] !> ] ] ].


have_bse_aux_le := have_aux_pos_lex_entry &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ PRD -,
				VFORM bse_only ] ],
		   CONT.--TMP.HAVE <! !> ] ].

has_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.CAT.VALENCE.SUBJ < @nomp() & [ LOCAL.CONT.INDEX.PNG.PN 3sg ] >].

has_aux_le :< has_aux_lex_ent.

has_aux_cx_le := has_aux_lex_ent & contracted_aux_word.

have_fin_aux_lex_ent := have_aux_pos_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG.PN non3sg & strict_pn ].

have_fin_aux_le :< have_fin_aux_lex_ent.

have_fin_aux_cx_le := have_fin_aux_lex_ent & contracted_aux_word.

had_aux_lex_ent := have_aux_pos_lex_entry & have_past.

had_aux_le :< had_aux_lex_ent.

had_aux_subj_le := have_aux_pos_lex_entry & have_subj.

had_aux_cx_le := had_aux_lex_ent & contracted_aux_word.

has_aux_neg_mle1 := have_aux_neg_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3sg ].

have_fin_aux_neg_mle1 := have_aux_neg_lex_entry & have_pres &
  [ SYNSEM.LOCAL.AGR.PNG.PN non3sg & strict_pn ].

had_aux_neg_mle1 := have_aux_neg_lex_entry & have_past.

had_aux_subj_neg_mle1 := have_aux_neg_lex_entry & have_subj.

; *** Generic BE ***

be_verb := hcons_amalg_word & non_affix_bearing &
  [ SYNSEM.LOCAL.CAT [ HEAD.AUX +*,
		       VALENCE [ SUBJ < @nomp() >,
				 COMPS < synsem & [ OPT - ], ... > ] ] ].
be_fin := be_verb &
  [ SYNSEM.LOCAL non_perf &
		 [ CAT [ HEAD [ VFORM fin,
				PRD -,
				MOD @nbar() ],
			 VALENCE.SUBJ < @nomp($case=nom) &
					[ OPT - ] > ],
		   CONT.ECONT.LISZT <! !> ] ].

be_pres := be_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE present*,
			      MOOD indicative* ],
		   CONT.--TMP.BE <! !> ] ].

be_past := be_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TENSE past*,
			      MOOD indicative* ],
		   CONT.--TMP.BE <! !> ] ].

be_subj := be_fin &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOOD subjunctive,
		   CONT.--TMP.BE <! irrealis_rel !> ] ].

be_prespart := be_verb &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD +,
				MOD [ CAT [ HEAD noun,
					    VALENCE [ SPR < synsem >,
						      COMPS *olist* ] ],
				      CONT [ TOP #hand,
					     INDEX #nind ] ] ],
			 VALENCE.SUBJ < [ LOCAL.CONT.INDEX #nind ] > ],
		   CONT [ TOP #hand,
			  --TMP.BE <! prog_rel &
				  [ HANDEL #hand ] !> ] ] ].

be_pastpart := be_verb &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ VFORM psp,
				PRD - ] ],
		   CONT.--TMP.BE <! !> ] ].
be_neg := sign &
  [ SYNSEM scopedarg_neg_aux_synsem &
	   [ LOCAL [ CAT.--SCOPEDARG2.--ARG #arg,
		     CONT [ TOP #hand,
			    --TMP [ BE [ LIST #list,
					 LAST #last ],
				    NEG [ LIST < neg_rel &
						 [ HANDEL #hand,
						   ARG #arg ] . #list >,
					  LAST #last ] ],
			    ECONT.KEY.HANDEL #hand ] ] ] ].

be_be_lex_entry := be_verb & lex_entry &
  [ STEM < "be" >,
    SYNSEM.LOCAL nomod_local &
	 [ CAT.HEAD [ PRD -,
		      VFORM bse ] ] ].

be_being_lex_entry := be_prespart & lex_entry & 
  [ STEM < "being" > ].

be_been_lex_entry := be_pastpart & lex_entry & 
  [ STEM < "been" > ].

be_pres_lex_entry := be_pres & lex_entry &
  [ SYNSEM.LOCAL.CONT [ TOP #hand,
			KEY #key & [ HANDEL #hand ],
			ECONT.KEY #key ] ].

be_past_lex_entry := be_past & lex_entry & 
  [ SYNSEM.LOCAL.CONT [ TOP #hand,
			KEY #key & [ HANDEL #hand ],
			ECONT.KEY #key ] ].

be_pres_neg_lex_entry := be_pres & be_neg & multi_lex_entry.
be_past_neg_lex_entry := be_past & be_neg & multi_lex_entry.

be_am_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG.PN 1sg ].

be_is_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3sg ].

be_are_lex_entry := be_pres_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG.PN non1sg & strict_pn ].

be_was_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG.PN 1or3sg & strict_pn ].

be_were_lex_entry := be_past_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG.PN non1sg & strict_pn ].

be_am_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.INV +,
                   AGR.PNG.PN 1sg ] ].

be_is_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3sg ].

be_are_neg_contr_lex_entry := be_pres_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG.PN non1sg & strict_pn ].

be_was_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG.PN 1or3sg & strict_pn ].

be_were_neg_contr_lex_entry := be_past_neg_lex_entry &
  [ SYNSEM.LOCAL.AGR.PNG.PN non1sg & strict_pn ].

; *** Copula BE ***

be_copula := prd_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS.FIRST.LOCAL.CONT 
						  [ KEY.HANDEL #hand,
						    ECONT.LISZT [ LIST #list,
								  LAST #last ] ],
		   CONT [ INDEX #event,
			  KEY #key,
			  --TMP.BE_COP *diff-list* &
				 [ LIST < support_rel & #key &
					  [ HANDEL #hand,
					    EVENT #event ]
					  . #list >,
				   LAST #last ] ] ] ].

be_copula_non_bse :< be_copula.

be_cop_pos_generic := be_copula & 
  [ SYNSEM.LOCAL.CONT [ TOP #hand,
			KEY.HANDEL #hand,
			--TMP [ BE #liszt1,
				BE_COP #liszt2,
				BE_COP_POS dl-append &
				   [ APPARG1 #liszt1,
				     APPARG2 #liszt2,
				     RES #resliszt ] ],
			--STEMLISZT #resliszt ] ].

be_cop_pos := be_cop_pos_generic & be_copula_non_bse & nonhcons & 
 [ SYNSEM.LOCAL non_perf ].

be_cop_neg := be_copula &
  [ SYNSEM scoping_neg_aux_verb &
	   [ LOCAL non_perf &
		   [ CONT [ --TMP [ NEG #liszt1,
				    BE_COP #liszt2,
				    BE_COP_NEG dl-append &
					[ APPARG1 #liszt1,
					  APPARG2 #liszt2,
					  RES #resliszt ] ],
			    --STEMLISZT #resliszt ] ] ] ].

; For mysterious reasons, can't replace "be_copula" parent in be_c_be_le with 
; "be_cop_pos_generic" even though it imposes the same constraints that are 
; acceptable here locally (plus the --TMP.BE <! !> constraint that only holds
; here).
be_c_be_le := be_be_lex_entry & be_copula &
  [ SYNSEM.LOCAL.CONT [ TOP #hand,
			KEY.HANDEL #hand,
			--TMP [ BE #liszt1 & <! !>,
				BE_COP #liszt2,
				BE_COP_POS dl-append &
				   [ APPARG1 #liszt1,
				     APPARG2 #liszt2,
				     RES #resliszt ] ],
			--STEMLISZT #resliszt ] ].

be_c_being_le := be_being_lex_entry & be_cop_pos &
  [ SYNSEM.LOCAL.CAT.VALENCE.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM non_prp ].
be_c_been_le := be_been_lex_entry & be_cop_pos_generic.
be_c_am_le := be_am_lex_entry & be_cop_pos.
be_c_is_le := be_is_lex_entry & be_cop_pos.
be_c_is_cx_le := be_is_lex_entry & be_cop_pos & contracted_aux_word.
be_c_are_le := be_are_lex_entry & be_cop_pos.
be_c_was_le := be_was_lex_entry & be_cop_pos.
be_c_were_le := be_were_lex_entry & be_cop_pos.
be_c_am_neg_le := be_am_neg_contr_lex_entry & be_cop_neg.
be_c_is_neg_le := be_is_neg_contr_lex_entry & be_cop_neg.
be_c_are_neg_le := be_are_neg_contr_lex_entry & be_cop_neg.
be_c_was_neg_le := be_was_neg_contr_lex_entry & be_cop_neg.
be_c_were_neg_le := be_were_neg_contr_lex_entry & be_cop_neg.

; *** Identity BE ***

id_cop_verb := aux_verb & two_arg_subst & two_arg &
  [ LOCAL [ CAT [ VALENCE [ SUBJ < [ LOCAL.CONT.INDEX #id1ind & ref-ind ] >,
			    COMPS < [ LOCAL 
				       [ CAT [ HEAD noun,
					       VALENCE [ SUBJ < >,
							 SPR *olist*,
							 COMPS *olist* ] ],
					 CONT.INDEX #id2ind ] ] > ] ],
	    CONT [ --TMP [ BE_ID <! support_rel & #key &
				[ HANDEL #hand ],
				_equal_adj_rel &
				[ HANDEL #hand,
				  NARG #id1ind,
				  PREPARG #id2ind ] !> ],
		   KEY #key ] ] ].

be_id := be_verb &
  [ SYNSEM id_cop_verb ].

be_id_pos := be_id & nonhcons &
  [ SYNSEM.LOCAL.CONT [ INDEX #event,
			--TMP [ BE #liszt1,
				BE_ID #liszt2 & <! [ EVENT #event ], relation !>,
				BE_ID_POS dl-append &
				 [ APPARG1 #liszt1,
				   APPARG2 #liszt2,
				   RES [ LIST #reslist,
					 LAST #reslast ] ] ],
			--STEMLISZT [ LIST #reslist,
				      LAST #reslast ] ] ].

be_id_neg_synsem := id_cop_verb & scopedarg_neg_aux_synsem.

be_id_neg := be_id &
  [ SYNSEM be_id_neg_synsem & 
	   [ LOCAL.CONT [ --TMP [ NEG #liszt1,
				  BE_ID #liszt2,
				  BE_ID_NEG dl-append &
				      [ APPARG1 #liszt1,
					APPARG2 #liszt2,
					RES #resliszt ] ],
			  --STEMLISZT #resliszt ] ] ].

be_id_be_le := be_be_lex_entry & be_id &
  [ SYNSEM.LOCAL.CONT [ TOP #top,
			INDEX #event,
			--TMP.BE_ID #liszt &
			      [ LIST.FIRST [ HANDEL #top,
					     EVENT #event ] ],
			--STEMLISZT #liszt ] ].

be_id_being_le := be_being_lex_entry & be_id_pos.
be_id_been_le := be_been_lex_entry & be_id_pos.
be_id_am_le := be_am_lex_entry & be_id_pos.
be_id_is_le := be_is_lex_entry & be_id_pos.
be_id_is_cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word.
be_id_are_le := be_are_lex_entry & be_id_pos.
be_id_was_le := be_was_lex_entry & be_id_pos.
be_id_were_le := be_were_lex_entry & be_id_pos.
be_id_am_neg_le := be_am_neg_contr_lex_entry & be_id_neg.
be_id_is_neg_le := be_is_neg_contr_lex_entry & be_id_neg.
be_id_are_neg_le := be_are_neg_contr_lex_entry & be_id_neg.
be_id_was_neg_le := be_was_neg_contr_lex_entry & be_id_neg.
be_id_were_neg_le := be_were_neg_contr_lex_entry & be_id_neg.

; *** There Copula BE ***

there_cop_verb := aux_verb & three_arg_subst &
  [ LOCAL [ CAT [ VALENCE [ SUBJ < [ LOCAL.CONT.INDEX there-ind &
						[ PNG #png ] ] >,
			  COMPS < #subj & @np($case=acc) &
				  [ LOCAL [ AGR non_expl-ind &
						       [ PNG #png ],
					    CONT.INDEX #cind ],
				    OPT - ],
				  [ LOCAL local &
				    [ CAT [ HEAD.PRD +,
					    VALENCE [ SUBJ < synsem & #subj >,
						      SPR *olist*,
						      COMPS *olist* ],
					    ROOT na ],
				      CONT [ TOP #hand,
					     ECONT.LISZT [ LIST #list,
							     LAST #last]]],
				    OPT + ] > ] ],
	    CONT [ --TMP.BE_TH_COP *diff-list* &
				     [ LIST < _there_cop_rel & #key &
					      [ HANDEL #hand,
						ARG3 #cind ]
					      . #list >,
				       LAST #last ],
		   KEY #key ] ] ].

be_th_cop := be_verb & 
  [ SYNSEM there_cop_verb ].

be_th_cop_pos := be_th_cop & nonhcons &
  [ SYNSEM.LOCAL.CONT [ INDEX #event,
			--TMP [ BE #liszt1,
				BE_TH_COP #liszt2 & 
				   [ LIST < [ EVENT #event ], ... > ],
				BE_TH_COP_POS dl-append &
				 [ APPARG1 #liszt1,
				   APPARG2 #liszt2,
				   RES [ LIST #reslist,
					 LAST #reslast ] ] ],
			--STEMLISZT [ LIST #reslist,
				      LAST #reslast ] ] ].

th_cop_neg_aux_verb := there_cop_verb & scopedarg_neg_aux_synsem.

be_th_cop_neg := be_th_cop &
  [ SYNSEM th_cop_neg_aux_verb &
	   [ LOCAL.CONT [ --TMP [ NEG #liszt1,
				  BE_TH_COP #liszt2,
				  BE_TH_COP_NEG dl-append &
				      [ APPARG1 #liszt1,
					APPARG2 #liszt2,
					RES #resliszt ] ],
			  --STEMLISZT #resliszt ] ] ].

be_th_cop_be_le := be_be_lex_entry & be_th_cop &
  [ SYNSEM.LOCAL.CONT [ INDEX #event,
			--TMP.BE_TH_COP #liszt &
			      [ LIST.FIRST.EVENT #event ],
			--STEMLISZT #liszt ] ].

be_th_cop_being_le := be_being_lex_entry & be_th_cop_pos.
be_th_cop_been_le := be_been_lex_entry & be_th_cop_pos.
be_th_cop_is_le := be_is_lex_entry & be_th_cop_pos.
be_th_cop_are_le := be_are_lex_entry & be_th_cop_pos.
be_th_cop_was_le := be_was_lex_entry & be_th_cop_pos.
be_th_cop_were_le := be_were_lex_entry & be_th_cop_pos.
be_th_cop_s_cx_le := be_pres_lex_entry & be_th_cop_pos & contracted_aux_word.
be_th_cop_is_neg_le := be_is_neg_contr_lex_entry & be_th_cop_neg.
be_th_cop_are_neg_le := be_are_neg_contr_lex_entry & be_th_cop_neg.
be_th_cop_was_neg_le := be_was_neg_contr_lex_entry & be_th_cop_neg.
be_th_cop_were_neg_le := be_were_neg_contr_lex_entry & be_th_cop_neg.

