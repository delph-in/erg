;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  constructions.tdl
;;;
;;;  The instances of phrases defined in syntax.tdl
;;;
;;;  Created: Ann Copestake, 30-Sept-97
;;;  Last revision: Dan Flickinger, 20-Oct-97
;;;
;;; $Id$

;;
;;  Constructions


:begin :instance.

; The instances ROOT and FRAG are needed by the parser to know which phrase 
; types to accept as successful parses of the full input string.  They should 
; be the only instances of phrase that fail to assign some other status 
; (e.g. 'rule or 'lex-entry), so they alone get to be of status 'root-node 
; (assigned on type sign), which is what the parser requires.  This is obscure,
; but seems to work.

; ERB (13-11-96) Nifty trick: all clauses have a MESSAGE value, but only those
; that are actually functioning as the root of the sentence get to put that
; MESSAGE into the semantics.  All root clauses will therefore have an RLISZT
; consisting of their MESSAGE appended to their C-CONT.LISZT.  Similarly, 
; ROOT also introduces an RH-CONS which adds the relevant scope constraint to 
; the H-CONS attribute of the clause itself.

root := phrase & 
  [ SYNSEM [ LOCAL [ CAT [ ROOT +,
			   HEAD.MOOD ind_or_mod_subj & strict_mood,
			   VALENCE [ SUBJ < >,
				     SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE message & #mes & 
				    [ HANDEL #mhand,
				      SOA #soa ],
			    LISZT *diff-list* &
				    [ LIST #list,
				      LAST #last ],
			    H-CONS *diff-list* &
				    [ LIST #sclist,
				      LAST #sclast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist ],
			    TOP-H #mhand,
			    RLISZT *diff-list* &
				    [ LIST < #mes . #list >,
				      LAST #last ],
			    RH-CONS *diff-list* &
				    [ LIST 
				    < is-one-of &
				    [ SC-ARG #soa,
				      CANDS < #hand . #hslist > ] . #sclist >,
				     LAST #sclast ] ],
		     CONJ cnil ],
	     NON-LOCAL [ SLASH <! !>,
			 QUE <! !> ] ],
    C-CONT.TOP #hand ].

;; MODCONT's TOP cannot be identified with C-CONT's TOP, given examples
;; like "perhaps in Berlin", where the MODCONT.TOP is that of "in", but
;; the C-CONT.TOP must be that of "perhaps" which takes scope over "in".

frag := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ PRD +,
				  INV -,
				  VFORM non_fin],
			   ROOT na,
			   VALENCE [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ RLISZT *diff-list* &
				    [ LIST < message &
					     [ HANDEL #mhand,
					       SOA #soa ]
					     . < abstr_rel &
						 [ HANDEL #hand,
						   EVENT event ] . #first > >,
				      LAST #last ],
			    LISZT [ LIST #middle,
				    LAST #last ],
			    TOP-H #mhand,
			    RH-CONS *diff-list* &
				   [ LIST < is-one-of &
					    [ SC-ARG #soa,
					      CANDS < #hand . #hslist > ] 
					    . #hconslist >,
				     LAST #hconslast ],
			    H-CONS [ LIST #hconslist,
				     LAST #hconslast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist ],
			    MODCONT.LISZT [ LIST #first,
					    LASt #middle ],
			    MESSAGE no_rel ] ],
	     NON-LOCAL [ REL <! !>,
			 SLASH <! !> ] ] ].

frag-msg := sign &
  [ SYNSEM [ LOCAL [ CAT [ ROOT na,
			   VALENCE [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE relation & #msg &
				    [ HANDEL #mhand,
				      RESTR #hand ],
			    TOP-H #mhand,
			    RLISZT *diff-list* &
				    [ LIST < #msg . < abstr_rel &
					              [ HANDEL #hand,
							ARG #arg & individual] 
						      . < abstr_rel &
							  [ HANDEL handle,
							    INST #index,
							    ARG3 #arg ]
							  . #first > > >,
				      LAST #last ],
			    LISZT *diff-list* &
				    [ LIST #middle,
				      LAST #last ],
			    RH-CONS #hclist,
			    H-CONS #hclist,
			    MODCONT [ TOP #hand,
				      INDEX #index,
				      LISZT [ LIST #first,
					      LASt #middle ] ] ] ],
	     NON-LOCAL [ REL <! !>,
			 SLASH <! !> ] ],
    C-CONT.TOP #mhand ].

subjh_d := subjh_rule_decl &
  [ RULE-NAME 'subjh_d ].

hcomp := hcomp_rule &
  [ RULE-NAME 'hcomp_nc ].

hoptcomp := hoptcomp_rule &
  [ RULE-NAME 'hoptcomp ].

hmark := hmark_rule &
  [ RULE-NAME 'hmark ].

extracomp := extracomp_rule &
  [ RULE-NAME 'extracomp ].

extrasubj := extrasubj_rule &
  [ RULE-NAME 'extrasubj ].

hspec_nc := hspec_nc_rule &
  [ RULE-NAME 'hspec_nc ].

hspec_c := hspec_c_rule &
  [ RULE-NAME 'hspec_c ].

hadj := hadj_rule &
  [ RULE-NAME 'hadj ].

adjh := adjh_rule &
  [ RULE-NAME 'adjh ].

extradj := extradj_rule &
  [ RULE-NAME 'extradj ].

fin_non_wh_rel := fin_non_wh_rel_rule &
  [ RULE-NAME 'fin_non_wh_rel ].

inf_non_wh_rel := inf_non_wh_rel_rule &
  [ RULE-NAME 'inf_non_wh_rel ].

bare_np := bare_np_rule &
  [ RULE-NAME 'bare_np ].

;n_n_cmpnd := n_n_cmpnd_rule &
;  [ RULE-NAME 'n_n_cmpnd ].

fillhead_non_wh := filler_head_rule_non_wh &
  [ RULE-NAME 'fillhead_non_wh ].

fillhead_wh_r := filler_head_rule_wh_root &
  [ RULE-NAME 'fillhead_wh_r ].

fillhead_wh_subj_r := filler_head_rule_wh_subj &
  [ RULE-NAME 'fillhead_wh_subj_r ].

fillhead_wh_nr_f := filler_head_rule_wh_nr_fin &
  [ RULE-NAME 'fillhead_wh_nr_f ].

fillhead_wh_nr_i := filler_head_rule_wh_nr_inf &
  [ RULE-NAME 'fillhead_wh_nr_i ].

fillhead_rel := filler_head_rule_rel &
  [ RULE-NAME 'fillhead_rel ].

top_coord := top_coord_rule &
       [ RULE-NAME 'top_coord ].

mid_coord := mid_coord_rule &
       [ RULE-NAME 'mid_coord ].

imper := imperative_rule &
       [ RULE-NAME 'imper_r ].

:end :instance.
