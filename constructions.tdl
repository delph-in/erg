;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  constructions.tdl
;;;
;;;  The instances of phrases defined in syntax.tdl
;;;
;;;  Created: Ann Copestake, 30-Sept-97
;;;  Last revision: Dan Flickinger, 20-Oct-97
;;;
;;; $Id$

;;
;;  Constructions

:begin :instance.

subjh := subjh_rule_decl &
  [ RULE-NAME 'subjh ].

subjh_sl := subjh_rule_slashed &
  [ RULE-NAME 'subjh_sl ].

hcomp := hcomp_rule &
  [ RULE-NAME 'hcomp ].

hoptcomp := hoptcomp_rule &
  [ RULE-NAME 'hoptcomp ].

hmark := hmark_rule &
  [ RULE-NAME 'hmark ].

extracomp := extracomp_rule &
  [ RULE-NAME 'extracomp ].

extrasubj := extrasubj_rule &
  [ RULE-NAME 'extrasubj ].

#|
hspec_nc := hspec_nc_rule &
  [ RULE-NAME 'hspec_nc ].

hspec_c := hspec_c_rule &
  [ RULE-NAME 'hspec_c ].
|#
hspec := hspec_rule &
  [ RULE-NAME 'hspec ].

adjh_s := adjh_s_rule &
  [ RULE-NAME 'adjh_s ].

hadj_s := hadj_s_rule &
  [ RULE-NAME 'hadj_s ].


#|
for the purposes of the generator, we really want two versions
of the intersective rules - 
one for slashed adjuncts and one for unslashed ones

hadj_i := hadj_i_h_rule &
  [ RULE-NAME 'hadj_i ].

|#

adjh_i := adjh_i_rule &
  [ RULE-NAME 'adjh_i ].

nadj_i := hadj_i_n_rule &
  [ RULE-NAME 'nadj_i ].

;;; cannot be slashed

hadj_i_s := hadj_i_h_rule &
  [ RULE-NAME 'hadj_i_s,
    ARGS.REST.FIRST.SYNSEM.NON-LOCAL.SLASH 1-dlist ].

hadj_i_uns := hadj_i_h_rule &
  [ RULE-NAME 'hadj_i_uns,
    ARGS.REST.FIRST.SYNSEM.NON-LOCAL.SLASH 0-dlist ].
    
extradj_i := extradj_i_rule &
  [ RULE-NAME 'extradj_i ].
#|
extradj_s := extradj_s_rule &
  [ RULE-NAME 'extradj_s ].
|#
fin_non_wh_rel := fin_non_wh_rel_rule &
  [ RULE-NAME 'fin_non_wh_rel ].

inf_non_wh_rel := inf_non_wh_rel_rule &
  [ RULE-NAME 'inf_non_wh_rel ].

; ERB (19-01-98) It looks like we really need both.
;non_wh_rel := non_wh_rel_rule &
;  [ RULE-NAME 'non_wh_rel ].

bare_np := bare_np_rule &
  [ RULE-NAME 'bare_np ].

n_n_cmpnd := n_n_cmpnd_rule &
  [ RULE-NAME 'n_n_cmpnd ].

temp_np := temp_mod_rule &
  [ RULE-NAME 'temp_np ].

;; Too expensive - maybe depend instead on different segmentation of input
#|
voc_np := vocative_rule &
  [ RULE-NAME 'voc_np ].
|#

fillhead_non_wh := filler_head_rule_non_wh &
  [ RULE-NAME 'fillhead_non_wh ].

fillhead_wh_r := filler_head_rule_wh_root &
  [ RULE-NAME 'fillhead_wh_r ].

fillhead_wh_subj_r := filler_head_rule_wh_subj &
  [ RULE-NAME 'fillhead_wh_subj_r ].

fillhead_wh_nr_f := filler_head_rule_wh_nr_fin &
  [ RULE-NAME 'fillhead_wh_nr_f ].

fillhead_wh_nr_i := filler_head_rule_wh_nr_inf &
  [ RULE-NAME 'fillhead_wh_nr_i ].

fillhead_rel := filler_head_rule_rel &
  [ RULE-NAME 'fillhead_rel ].

freerel := free_rel_rule &
  [ RULE-NAME 'freerel ].

top_coord_p := top_coord_prop_rule &
       [ RULE-NAME 'top_coord_p ].

mid_coord_p := mid_coord_prop_rule &
       [ RULE-NAME 'mid_coord_p ].

top_coord_np := top_coord_nonprop_rule &
       [ RULE-NAME 'top_coord_np ].

mid_coord_np := mid_coord_nonprop_rule &
       [ RULE-NAME 'mid_coord_np ].

imper := imperative_rule &
       [ RULE-NAME 'imper ].

yesno := yesno_rule &
       [ RULE-NAME 'yesno ].

;decl := decl_rule &
;       [ RULE-NAME 'decl ].

rootgap_l := root_gap_rule_premod &
       [ RULE-NAME 'rootgap_l ].

rootgap_r := root_gap_rule_postmod &
       [ RULE-NAME 'rootgap_r ].

root_cl := root_clause &
       [ RULE-NAME 'root_cl ].

;frag_nomod_i := frag_nomod.
;frag_mod_i := frag_mod_int.

;frag_subord := frag_subord_cl.

;frag_excl_i := frag_excl.

;frag_msg_i := frag_msg.

;frag_fin_i := frag_fin.

frag_coord_i := frag_coord.

:end :instance.
