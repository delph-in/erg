rebracket_conj_gpr := rebracket_coord_gpr.

ifnot_to_unless_gpr := if_not_to_unless_gpr.

;; Drop "the case that" with "unless"
;;
unless_the_case_gpr := unless_the_case_to_unless_gpr.

and_not_case_but_op_mtr := and_not_case_to_but_op_mtr.

same_to_and_loc_op_mtr := and_same_loc_op_mtr.

same_to_and_size_op_mtr := and_same_size_op_mtr.

;; binary coord of subjects

coord_subj_comp_op_gpr := coord_subj_compar_op_gpr.

coord_subj_three_op_gpr := coord_subj_threearg_op_gpr.

coord_subj_two_neg_op_gpr := coord_subj_twoarg_neg_op_gpr.

coord_subj_two_pos_op_gpr := coord_subj_twoarg_pos_op_gpr.

coord_subj_two_noprop_neg_op_gpr := coord_subj_twoarg_noprop_neg_gpr.

coord_subj_two_noprop_op_gpr := coord_subj_twoarg_noprop_pos_op_gpr.

coord_subj_one_neg_op_gpr := coord_subj_onearg_neg_op_gpr.

coord_subj_one_pos_op_gpr := coord_subj_onearg_pos_op_gpr.

;; n-ary coord

coord_subj_comp_nary_op_gpr := coord_subj_compar_nary_op_gpr.

coord_subj_three_nary_op_gpr := coord_subj_threearg_nary_op_gpr.

coord_subj_two_neg_nary_op_gpr := coord_subj_twoarg_neg_nary_op_gpr.

coord_subj_two_pos_nary_op_gpr := coord_subj_twoarg_pos_nary_op_gpr.

coord_subj_two_noprop_neg_nary_op_gpr := coord_subj_twoarg_noprop_neg_nary_gpr.

coord_subj_two_noprop_nary_op_gpr := coord_subj_twoarg_noprop_nary_op_gpr.

coord_subj_one_neg_nary_op_gpr := coord_subj_onearg_neg_nary_op_gpr.

coord_subj_one_pos_nary_op_gpr := coord_subj_onearg_pos_nary_op_gpr.

and_neg_but_op_mtr := and_neg_to_but_op_mtr.

;; It is not the case that ...
;;
notthecase_op_gpr := not_the_case_op_gpr.

;; B is a large cube
;;
adj_predn_gpr := adj_and_predn_gpr.

predn_adj_gpr := predn_and_adj_gpr.

;; B is smaller than C and (is) larger than D
;;
coord_vp_two_op_gpr := coord_vp_twoarg_op_gpr.

coord_vp_one_op_gpr := coord_vp_onearg_op_gpr.

;; "B is larger than C or D"
;;
common_vp_comp_op_gpr := shared_vp_comp_op_gpr.

;; "B is in the same column as C or D"
;;
common_vp_same_n_op_gpr := shared_vp_same_n_op_gpr.

;; "B is to the right of C or D"
;;
common_vp_dir_op_gpr := shared_vp_dir_op_gpr.

;; "B is in front of C or D"
;;
common_vp_loc_op_gpr := shared_vp_loc_op_gpr.

;; "B is not in front of C or D"
;;
common_vp_loc_neg_op_gpr := shared_vp_loc_neg_op_gpr.

;; "B is between C and D or E and F"
;;
common_vp_threearg_op_gpr := shared_vp_threearg_op_gpr.

;; "to the right or to the left of D"
;;
common_ppof_left_op_gpr := shared_ppof_left_op_gpr.
common_ppof_right_op_gpr := shared_ppof_right_op_gpr.

;; "to the right or left of D"
;;
common_to_the_op_gpr := shared_to_the_op_gpr.

;; Note - the following set need to be kept in this order, and roughly here
;; (five the-case, not-to-nor, and common_pred)
;;
;; "not the case that" => B is not a large cube'
;;
not_the_case_neg_nonconj_gpr := not_the_case_to_neg_noconj_gpr.

;; "not the case that B is large or small"
;;
not_the_case_neg_vpconj_gpr := not_the_case_to_neg_vpconj_gpr.

;; Replace not(or) with nor
;; Order: follow coord_vp to create conjoined VPs needed as input
;;
not_or_to_nor_op_mtr := neg_or_to_nor_op_mtr.

;; Replace not_the_case(or) with nor
;;

not_the_case_or_to_nor_one_op_mtr := neg_the_case_or_to_nor_onearg_op_mtr.

not_the_case_or_to_nor_comp_op_mtr := neg_the_case_or_to_nor_comp_op_mtr.

not_the_case_or_to_nor_two_op_mtr := neg_the_case_or_to_nor_twoarg_op_mtr.

;; "B is a cube or a tetrahedron"
;;
common_pred_op_gpr := shared_pred_op_gpr.


ifthen_to_onlyif_gpr := if_then_to_only_if_gpr &
[ OUTPUT.RELS.LIST.FIRST.PRED "_only+if_x_rel" ].

;; "B is small, and it is a cube"
;;
conj_pro_subj_unamb_gpr := coord_s_pro_subj_unambig_gpr &
[ CONTEXT.RELS <! [ ARG0 #e1 ], [ ARG0 #e2 & [ E.TENSE present ] ], [ ], [ ],
		  [ PRED conj_rel, L-INDEX #e1, R-INDEX #e2 ] !> ].

;; "B is larger than C, and it (i.e., B) is a cube"
;;
conj_pro_subj_ambig_gpr := coord_s_pro_subj_ambig_gpr &
[ CONTEXT.RELS <! [ ARG0 #e1 ], [ ARG0 #e2 & [ E.TENSE present ] ], [ ], [ ],
		  [ PRED conj_rel, L-INDEX #e1, R-INDEX #e2 ], [ ] !> ].

;; "If B is a cube, it is small"
;;
cond_pro_subj_gpr := cond_s_pro_subj_gpr.

cond_pro_subj_ambig_gpr := cond_s_pro_subj_ambig_gpr.

cond_pro_subj_embed_cons_gpr := cond_s_pro_subj_embed_cons_gpr.
cond_pro_subj_embed_cons_neg_gpr := cond_s_pro_subj_embed_cons_neg_gpr.
cond_pro_subj_embed_ant_gpr := cond_s_pro_subj_embed_ant_gpr.
cond_pro_subj_embed_ant_neg_gpr := cond_s_pro_subj_embed_ant_neg_gpr.

unless_pro_subj_gpr := unless_s_pro_subj_gpr.

unless_pro_subj_ambig_gpr := unless_s_pro_subj_ambig_gpr.

;; "B is small only if it is a cube"
;;
onlyif_pro_subj_gpr := onlyif_s_pro_subj_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ], [ PRED "_only+if_x_rel" ] !> ].

;; "B is small if and only if it is a cube"
;;
iff_pro_subj_gpr := bicond_s_pro_subj_gpr.

;; "B is a cube if and only if it is either medium or small" 
;;
iff_pro_subj_crdvp_gpr := bicond_s_pro_subj_coordvp_gpr.

;; If B is large, then C is
;;
vp_ellip_if_pos_one_gpr := vp_ellipsis_if_pos_onearg_gpr.

;; IF B is larger than D, then C is
;;
vp_ellip_if_pos_two_comp_gpr := vp_ellipsis_if_pos_twoarg_comp_gpr.

;; If B is large, then C isn't
;;
vp_ellip_if_neg_one_gpr := vp_ellipsis_if_neg_onearg_gpr.

;; If B is a cube, then C is
;;
vp_ellip_if_pos_two_gpr := vp_ellipsis_if_pos_twoarg_gpr.

;; If B is a cube, then C isn't
;;
vp_ellip_if_neg_two_gpr := vp_ellipsis_if_neg_twoarg_gpr.

;; C is large if and only if B is large.
;;
vp_ellip_iff_pos_one_gpr := vp_ellipsis_iff_pos_onearg_gpr.


;; C is larger than D if and only if B is.
;;
vp_ellip_iff_pos_two_comp_gpr := vp_ellipsis_iff_pos_twoarg_comp_gpr.

;; C is large if and only if B isn't
;;
vp_ellip_iff_neg_one_gpr := vp_ellipsis_iff_neg_onearg_gpr.

;; C is a cube, if and only if B is
;;
vp_ellip_iff_pos_two_gpr := vp_ellipsis_iff_pos_twoarg_gpr.

;; C is a cube, if and only if B isn't
;;
vp_ellip_iff_neg_two_gpr := vp_ellipsis_iff_neg_twoarg_gpr.

vp_ellip_coord_pos_one_gpr := vp_ellipsis_coord_pos_onearg_gpr.

vp_ellip_coord_pos_two_gpr := vp_ellipsis_coord_pos_twoarg_gpr.

vp_ellip_coord_pos_twoconj_gpr := vp_ellipsis_coord_pos_twoconj_gpr.


iff_to_justincase_gpr := iff_to_just_in_case_gpr.

iff_to_justincasefact_gpr := iff_to_just_in_case_fact_gpr.

;; Contrastive "and" to "but"
;;
;; Size
;;
and_but_small_large_op_mtr := and_but_size_op_mtr &
[ CONTEXT.RELS <! [ PRED "_small_a_1_rel", LBL #h1 ], 
		  [ PRED "_large_a_1_rel" ], [ ], [ ] !>,
  FILTER.HCONS <! qeq & [ LARG #h1 ] !> ].

and_but_small_large_2_op_mtr := and_but_size_op_mtr &
[ CONTEXT.RELS <! [ PRED "_small_a_1_rel" ], 
		  [ PRED "_large_a_1_rel", LBL #h1 ], [ ], [ ] !>,
  FILTER.HCONS <! qeq & [ LARG #h1 ] !> ].

and_but_large_small_op_mtr := and_but_size_op_mtr &
[ CONTEXT.RELS <! [ PRED "_large_a_1_rel", LBL #h1 ], 
		  [ PRED "_small_a_1_rel" ], [ ], [ ] !>,
  FILTER.HCONS <! qeq & [ LARG #h1 ] !> ].

and_but_large_small_2_op_mtr := and_but_size_op_mtr &
[ CONTEXT.RELS <! [ PRED "_large_a_1_rel" ], 
		  [ PRED "_small_a_1_rel", LBL #h1 ], [ ], [ ] !>,
  FILTER.HCONS <! qeq & [ LARG #h1 ] !> ].

;; and to but for same row/column
;;
and_but_loc_op_mtr := and_but_location_op_mtr.

;; either-or => neither
;;
either_to_neither_mtr := either_neither_mtr.

;; "not the case that ... or" => neither
;;
either_to_neither_the_case_mtr := either_neither_the_case_mtr.

;; neither => neither of them
;;
neither_part_op_mtr := neither_part_of_op_mtr.

;; none of X
;;
none_of_op_mtr := none_part_of_op_mtr.

;;;

;; and to but for front/back
;;
and_but_pos_op_mtr := and_but_front_back_op_mtr.

;;; new loc
;; "B is small; moreover, B is a cube"
;;
semicol_and_op_gpr := coord_sent_semi_op_gpr &
[ INPUT.RELS <! [ PRED _and_c_rel ] !>,
  OUTPUT.RELS <! [ ], [ PRED "_moreover_a_1_rel" ] !> ].

;; "B is small; however, C is large"
;;
semicol_but_op_gpr := coord_sent_semi_op_gpr &
[ INPUT.RELS <! [ PRED _but_c_rel ] !>,
  OUTPUT.RELS <! [ ], [ PRED "_however_a_1_rel" ] !> ].

;; Replace "if" with "provided (that)"
;; Order: precede addition of "also", and VP ellipsis
;;
ifthen_to_provided_gpr := cond_to_provided_mtr.

;; "if B is large, C is also large"
;;
also_adv_cond_onearg_gpr := also_adverb_cond_onearg_gpr &
[ OUTPUT.RELS <! [ ARG1.MARKS.ALSO-MARK + ] !> ].

also_adv_cond_twoarg_comp_gpr := also_adverb_cond_twoarg_comp_gpr &
[ OUTPUT.RELS <! [ ARG1.MARKS.ALSO-MARK + ] !> ].

also_adv_cond_twoarg_gpr := also_adverb_cond_twoarg_gpr &
[ OUTPUT.RELS <! [ ARG1.MARKS.ALSO-MARK + ] !> ].


;; Drop `then' if atomic consequent
;; Order: should follow also_adv addition, to get variants with and without
;;
drop_then_mtr := drop_cond_then_mtr &
[ OUTPUT.RELS <! [ PRED "_if_x_then_rel" ] !> ].

;; "B is small if it is a cube"
;; Order: must follow drop of "then"
;;
cond_pro_subj_rev_gpr := cond_s_pro_subj_rev_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ], [ PRED "_if_x_then_rel" ] !> ].

;; "B is in front of D if it (i.e, B) is a cube"
;;
cond_pro_subj_ambig_rev_gpr := cond_s_pro_subj_ambig_rev_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ], [ PRED "_if_x_then_rel" ], [ ] !> ].

;; "B is small provided it is a cube"
;; Order: must follow drop of "then"
;;
cond_pro_subj_rev_prov_gpr := cond_s_pro_subj_rev_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ], [ PRED "_provided_x_rel" ] !> ].

cond_pro_subj_ambig_rev_prov_gpr := cond_s_pro_subj_ambig_rev_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ], [ PRED "_provided_x_rel" ], [ ] !> ].

;; C is large if B is
;; Order: must follow drop of "then"
;;
vp_ellip_if_pos_ante_one_gpr := vp_ellipsis_if_pos_ante_onearg_gpr.

;; C is larger than B if D is
;;
vp_ellip_if_pos_ante_two_comp_gpr := vp_ellipsis_if_pos_ante_twoarg_comp_gpr.

;; C is a cube if B is
;;
vp_ellip_if_pos_ante_two_gpr := vp_ellipsis_if_pos_ante_twoarg_gpr.


;; "one of A, B, and C"
;;
one_of_set_two_mtr := one_of_set_twoarg_mtr.
one_of_set_one_mtr := one_of_set_onearg_mtr.

;; Coord pro subj
;; "A and B are cubes, and they are small"
;;
conj_pro_coord_subj_and_gpr := conjnct_pro_coord_subj_and_gpr.
conj_pro_coord_subj_or_gpr := conjnct_pro_coord_subj_or_gpr.

;; "B and C are small only if they are cubes"
;;
onlyif_pro_coord_subj_and_gpr := onlyif_s_pro_coord_subj_and_gpr.
onlyif_pro_coord_subj_or_gpr := onlyif_s_pro_coord_subj_or_gpr.

;; "B and C are small if and only if they are cubes"
;;
iff_pro_coord_subj_and_gpr := bicond_s_pro_coord_subj_and_gpr.
iff_pro_coord_subj_or_gpr := bicond_s_pro_coord_subj_or_gpr.

coord_vp_prosub_two_op_gpr := coord_vp_prosubj_twoarg_op_gpr.
coord_vp_prosub_one_op_gpr := coord_vp_prosubj_onearg_op_gpr.

;; "B is in front of or in back of C"
;;
common_dobj_onepred_op_gpr := shared_dobj_onepred_op_gpr.
common_dobj_twopred_op_gpr := shared_dobj_twopred_op_gpr.
common_dobj_onetwopred_op_gpr := shared_dobj_onetwopred_op_gpr.
common_dobj_twoonepred_op_gpr := shared_dobj_twoonepred_op_gpr.

;; "B is to the left of or right of C"
shared_nobj_op_gpr := shared_noun_obj_op_gpr.

;; "If B and C are cubes, then they are small"
;; Order: follow common_dobj* which creates the plural to be replaced by the
;; pronoun
;;
cond_pro_coord_subj_and_gpr := cond_s_pro_coord_subj_and_gpr.
cond_pro_coord_subj_or_gpr := cond_s_pro_coord_subj_or_gpr.

cond_pro_coord_subj_coord_cq_and_gpr := cond_s_pro_coord_subj_crd_cq_and_gpr.
cond_pro_coord_subj_coord_cq_or_gpr := cond_s_pro_coord_subj_crd_cq_or_gpr.

;; Add "both" adverb: "B and C are both cubes"
;; Order: follows coord of subjects to create the licensing plural NP
;;
both_adv_op_mtr := both_adverb_op_mtr &
[ OUTPUT.RELS <! [ ARG1.MARKS.BOTH-MARK + ] !> ].

;; Add "also" adverb with pronoun subj: "B is a cube iff it is also large"
;; 
also_adv_pro_op_mtr := also_adverb_op_mtr &
[ CONTEXT.RELS.LIST < [ PRED pron_rel ], ... >,
  OUTPUT.RELS <! [ ARG1.MARKS.ALSO-MARK + ] !> ].

;; And "also" with partitive "B and C are cubes iff one of them is also large"
;;
also_adv_part_op_mtr := also_adverb_op_mtr &
[ CONTEXT.RELS.LIST < [ PRED part_of_rel ], ... >,
  OUTPUT.RELS <! [ ARG1.MARKS.ALSO-MARK + ] !> ].


;; Add "either" for double neg conditional
;; "If B is not a cube, then C is not a cube either"
;;
either_adv_op_mtr := either_adverb_op_mtr &
[ OUTPUT.RELS <! [ ARG1.MARKS.EITHER-MARK + ] !> ].

;; "one of them"
;;
part_pron_one_op_mtr := partitive_pron_one_op_mtr.

;; "both of them"
;;
part_pron_both_op_mtr := partitive_pron_both_op_mtr.

;; "at least one of them"
;;
at_least_one_mtr := at_least_one_of_mtr.
