rebracket_conj_gpr := rebracket_coord_gpr.

same_to_and_loc_op_mtr := and_same_loc_op_mtr.

same_to_and_size_op_mtr := and_same_size_op_mtr.

;; Replace not(or) with nor
;;
not_or_to_nor_op_mtr := neg_or_to_nor_op_mtr.

;; binary coord of subjects

coord_subj_comp_op_gpr := coord_subj_compar_op_gpr.

coord_subj_three_op_gpr := coord_subj_threearg_op_gpr.

coord_subj_two_neg_op_gpr := coord_subj_twoarg_neg_op_gpr.

coord_subj_two_pos_op_gpr := coord_subj_twoarg_pos_op_gpr.

coord_subj_two_noprop_neg_op_gpr := coord_subj_twoarg_noprop_neg_gpr.

coord_subj_two_noprop_op_gpr := coord_subj_twoarg_noprop_pos_op_gpr.

coord_subj_one_neg_op_gpr := coord_subj_onearg_neg_op_gpr.

coord_subj_one_pos_op_gpr := coord_subj_onearg_pos_op_gpr.

;; n-ary coord

coord_subj_comp_nary_op_gpr := coord_subj_compar_nary_op_gpr.

coord_subj_three_nary_op_gpr := coord_subj_threearg_nary_op_gpr.

coord_subj_two_neg_nary_op_gpr := coord_subj_twoarg_neg_nary_op_gpr.

coord_subj_two_pos_nary_op_gpr := coord_subj_twoarg_pos_nary_op_gpr.

coord_subj_two_noprop_neg_nary_op_gpr := coord_subj_twoarg_noprop_neg_nary_gpr.

coord_subj_two_noprop_nary_op_gpr := coord_subj_twoarg_noprop_nary_op_gpr.

coord_subj_one_neg_nary_op_gpr := coord_subj_onearg_neg_nary_op_gpr.

coord_subj_one_pos_nary_op_gpr := coord_subj_onearg_pos_nary_op_gpr.


;; It is not the case that ...
;;
notthecase_op_gpr := not_the_case_op_gpr.

coord_vp_two_op_gpr := coord_vp_twoarg_op_gpr.

coord_vp_one_op_gpr := coord_vp_onearg_op_gpr.


coord_pred_c_op_gpr := coord_pred_comp_op_gpr.

common_dobj_op_gpr := shared_dobj_op_gpr.



;; "B is larger than C or D"
;;
common_vp_comp_op_gpr := shared_vp_comp_op_gpr.


;; "B is in the same column as C or D"
;;
common_vp_same_n_op_gpr := shared_vp_same_n_op_gpr.


;; "B is to the right of C or D"
;;
common_vp_dir_op_gpr := shared_vp_dir_op_gpr.

;; "B is between C and D or E and F"
;;
common_vp_threearg_op_gpr := shared_vp_threearg_op_gpr.


;; "to the right or to the left of D"
;;
common_ppof_op_gpr := shared_ppof_op_gpr.

;; "to the right or left of D"
;;
common_to_the_op_gpr := shared_to_the_op_gpr.

;; "B is a cube or a tetrahedron"
;;
common_pred_op_gpr := shared_pred_op_gpr.


ifthen_to_onlyif_gpr := if_then_to_only_if_gpr.

ifnot_to_unless_gpr := if_not_to_unless_gpr.


;; "B is small; moreover, B is a cube"
;;
semicol_and_op_gpr := coord_sent_semi_op_gpr &
[ INPUT.RELS <! [ PRED _and_c_rel ] !>,
  OUTPUT.RELS <! [ ], [ PRED "_moreover_a_1_rel" ] !> ].

;; "B is small; however, C is large"
;;
semicol_but_op_gpr := coord_sent_semi_op_gpr &
[ INPUT.RELS <! [ PRED _but_c_rel ] !>,
  OUTPUT.RELS <! [ ], [ PRED "_however_a_1_rel" ] !> ].


;; "B is small, and it is a cube"
;;
conj_pro_subj_gpr := pro_subj_gpr &
[ CONTEXT.RELS <! [ ARG0 #e1 ], [ ARG0 #e2 & [ E.TENSE present ] ], [ ], [ ],
		  [ PRED conj_rel, L-INDEX #e1, R-INDEX #e2 ] !> ].

;; "If B is a cube, it is small"
;;
cond_pro_subj_gpr := cond_s_pro_subj_gpr.

;; "B is small only if it is a cube"
;;
onlyif_pro_subj_gpr := onlyif_s_pro_subj_gpr.

iff_pro_subj_gpr := bicond_s_pro_subj_gpr.

;; Coord pro subj
;; "A and B are cubes, and they are small"
;;
conj_pro_coord_subj_gpr := pro_coord_subj_gpr &
[ CONTEXT.RELS <! [ ARG0 #e1 ], [ ARG0 #e2, ARG1 #x3 ], [ ],
		  [ ], [ ], [ ], 
		  [ PRED conj_rel, L-INDEX #e1, R-INDEX #e2 ] !>,
  OUTPUT.RELS.LIST < [ ARG0 #x3 ], ... >,
  FLAGS.EQUAL < semarg > ].

;; "If B and C are cubes, they are small"
;;
cond_pro_coord_subj_gpr := cond_s_pro_coord_subj_gpr.


;; "B and C are small only if they are cubes"
;;
onlyif_pro_coord_subj_gpr := onlyif_s_pro_coord_subj_gpr.

iff_pro_coord_subj_gpr := bicond_s_pro_coord_subj_gpr.

coord_vp_prosub_two_op_gpr := coord_vp_prosubj_twoarg_op_gpr.

coord_vp_prosub_one_op_gpr := coord_vp_prosubj_onearg_op_gpr.

;; B is a large cube
;;
adj_predn_gpr := adj_and_predn_gpr.

predn_adj_gpr := predn_and_adj_gpr.

;; If B is large, then C is
;;
vp_ellip_if_pos_one_gpr := vp_ellipsis_if_pos_onearg_gpr.

;; IF B is larger than D, then C is
;;
vp_ellip_if_pos_two_comp_gpr := vp_ellipsis_if_pos_twoarg_comp_gpr.

;; If B is large, then C isn't
;;
vp_ellip_if_neg_one_gpr := vp_ellipsis_if_neg_onearg_gpr.

;; If B is a cube, then C is
;;
vp_ellip_if_pos_two_gpr := vp_ellipsis_if_pos_twoarg_gpr.

;; If B is a cube, then C isn't
;;
vp_ellip_if_neg_two_gpr := vp_ellipsis_if_neg_twoarg_gpr.


;; C is large if and only if B is large.
;;
vp_ellip_iff_pos_one_gpr := vp_ellipsis_iff_pos_onearg_gpr.

;; C is larger than D if and only if B is.
;;
vp_ellip_iff_pos_two_comp_gpr := vp_ellipsis_iff_pos_twoarg_comp_gpr.

;; C is large if and only if B isn't
;;
vp_ellip_iff_neg_one_gpr := vp_ellipsis_iff_neg_onearg_gpr.

;; C is a cube, if and only if B is
;;
vp_ellip_iff_pos_two_gpr := vp_ellipsis_iff_pos_twoarg_gpr.

;; C is a cube, if and only if B isn't
;;
vp_ellip_iff_neg_two_gpr := vp_ellipsis_iff_neg_twoarg_gpr.


vp_ellip_coord_pos_one_gpr := vp_ellipsis_coord_pos_onearg_gpr.

vp_ellip_coord_pos_two_gpr := vp_ellipsis_coord_pos_twoarg_gpr.


iff_to_justincase_gpr := iff_to_just_in_case_gpr.


;; Contrastive "and" to "but"
;;
;; Size
;;
and_but_small_large_op_mtr := and_but_size_op_mtr &
[ CONTEXT.RELS <! [ PRED "_small_a_1_rel", LBL #h1 ], 
		  [ PRED "_large_a_1_rel" ], [ ], [ ] !>,
  FILTER.HCONS <! qeq & [ LARG #h1 ] !> ].

and_but_small_large_2_op_mtr := and_but_size_op_mtr &
[ CONTEXT.RELS <! [ PRED "_small_a_1_rel" ], 
		  [ PRED "_large_a_1_rel", LBL #h1 ], [ ], [ ] !>,
  FILTER.HCONS <! qeq & [ LARG #h1 ] !> ].

and_but_large_small_op_mtr := and_but_size_op_mtr &
[ CONTEXT.RELS <! [ PRED "_large_a_1_rel", LBL #h1 ], 
		  [ PRED "_small_a_1_rel" ], [ ], [ ] !>,
  FILTER.HCONS <! qeq & [ LARG #h1 ] !> ].

and_but_large_small_2_op_mtr := and_but_size_op_mtr &
[ CONTEXT.RELS <! [ PRED "_large_a_1_rel" ], 
		  [ PRED "_small_a_1_rel", LBL #h1 ], [ ], [ ] !>,
  FILTER.HCONS <! qeq & [ LARG #h1 ] !> ].

;; and to but for same row/column
;;
and_but_loc_op_mtr := and_but_location_op_mtr.

;; and to but for front/back
;;
and_but_pos_op_mtr := and_but_front_back_op_mtr.

;; Add "both" adverb: "B and C are both cubes"
;;
both_adv_op_mtr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED _and_c_rel, ARG0 #x1, L-INDEX ref-ind ],
		  [ LBL #h2, ARG0 #e3 & event & [ E.TENSE present ], 
		    ARG1 #x1 & ref-ind ] !>,
  FILTER.RELS <! [ PRED "_both_a_1_rel", LBL #h2 ] !>,
  INPUT.RELS <! !>,
  OUTPUT.RELS <! [ PRED "_both_a_1_rel", LBL #h2, 
		   ARG0 event & [ E.TENSE untensed ], ARG1 #e3 ] !> ].

;; Drop `then' if atomic consequent
;;
drop_then_mtr := drop_cond_then_mtr.

;; "at least one of ..."
;;
at_least_one_two_mtr := at_least_one_twoarg_mtr.
at_least_one_one_mtr := at_least_one_onearg_mtr.

;; either-or => neither
;;
either_to_neither_mtr := either_neither_mtr.