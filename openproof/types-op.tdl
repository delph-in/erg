;; This type is for "only if" as a patch given that the transfer machinery
;; currently does not allow reassignment of the top-level INDEX attribute,
;; where in the paraphrase of "if A then B" as "A only if B" the main clause
;; shifts.  So here we propagate the new complement's INDEX to be the main
;; one.
;;
p_cp_s-rev_le := noncqrs-h-nab &
  [ SYNSEM basic_subconj_cp_synsem &
	   [ LOCAL [ CAT [ HEAD [ PRD -,
	                          MOD < [ LOCAL.CONT.HOOK.INDEX.SF prop,
					  PUNCT.RPUNCT no_punct ] > ],
			   VAL [ SPR < [ --MIN just_only_deg_rel ] >,
				 COMPS < [ LOCAL 
					  [ CAT s_cat_unspec & 
						[ MC +,
						  HEAD verb & [ VFORM fin ] ],
					    CONT.HOOK.INDEX #ind &
						[ SF prop-or-comm ] ],
					   --SIND.E.TENSE real_tense,
					   PUNCT.RPUNCT.PSF #iforce,
					   NONLOC.SLASH 0-dlist,
					   OPT - ] > ],
			   POSTHD + ],
		     CONT.HOOK.INDEX #ind ],
	     LKEYS.KEYREL.ARG0.SF #iforce ] ].

;; Restrict subord conjs to only attach to S, not also to VP
;;
p_cp_s-unsp_le := subconj_word &
  [ SYNSEM subconj_synsem &
	   [ LOCAL.CAT [ HEAD [ PRD -,
				MOD < [ LOCAL.CAT.VAL.SUBJ *olist* ] > ],
			 VAL.SPR < [ --MIN just_only_deg_rel ] > ] ] ].

;; The normal grammar leaves SF underspecified for if-then sentences, since the
;; main clause might be a question or a command.  But for OP, everything is
;; declarative, so we unify SF from head and non-head, to ensure that the SF
;; value is always specialized to `prop', which makes the generator happy.
;;
reg_onearg_subconj_synsem := basic_onearg_subconj_synsem & 
			      subconj_lex_synsem &
  [ LOCAL.CAT [ HEAD.MOD < [ --SIND.SF #iforce ] >,
		VAL.COMPS < [ PUNCT.RPUNCT.PSF #iforce,
			      NONLOC.SLASH 0-dlist ] > ],
    LKEYS.KEYREL.ARG0.SF #iforce ].

;; Similary, we change the complement clause constraint to be MC +, to ensure
;; that the SF value is specialized to `prop', even though in general "if"
;; can also combine with subjunctive (MC -) clauses.
;;
subconj_synsem := subconj_cp_synsem & 
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT s_cat_unspec & 
					[ MC +,
					  HEAD verb & [ VFORM fin ] ],
				    CONT.HOOK.INDEX.SF prop-or-comm ],
			    --SIND.E.TENSE real_tense ] > ].



aj_pp-cp_i-it-brdg_le := norm_adj_word &
  [ SYNSEM adj_atrans_cp_bridge_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
	     LKEYS.KEYREL.ARG0.E.TENSE untensed ] ].

adj_atrans_cp_bridge_synsem := isect_synsem & basic_two_arg &
			       prd_synsem & cp_addin_tam_pn &
  [ LOCAL [ AGR #agr,
            CAT [ HEAD basic_adj & [ MINORS [ MIN adj_rel,
					      ALTMIN norm_rel & #altmin ],
				     TAM #tam,
				     MOD < [ LOCAL.CAT.HEAD no_head ] > ],
		  VAL [ SUBJ < >,
			SPCMPS < >,
			SPR < #spr & synsem_min &
                          [ --MIN degree_rel,
                            LOCAL
                            [ CAT [ HEAD.MINORS.ALTMIN #altmin,
				    VAL [ SPR *olist*,
                                          SPEC < [ LOCAL.CAT.HS-LEX #hslex ]>],
                                    MC na ],
                              CONT.HOOK.LTOP #ltop ],
                            NONLOC.SLASH 0-dlist,
                            OPT + ],
			  anti_synsem_min &
			  [ --MIN degree_rel ] >,
			COMPS #comps &
			     < synsem & #comp &
				[ LOCAL [ CONT.HOOK [ LTOP #chand,
						      INDEX #ind &
							    [ SF basic-prop ] ],
					  CONJ cnil,
					  CAT s_cat_fin_or_inf_v_c & 
						    [ HEAD comp ] ],
				  NONLOC.SLASH 0-dlist ] >,
			SPR.FIRST.LOCAL.CONT.HOOK.XARG #arg0,
			KCMP #comp & [ PUNCT.LPUNCT no_punct ] ],
		  HS-LEX #hslex ],
	    CONT [ HOOK [ INDEX #ind & [ E #tam ],
			  XARG it-ind & #agr ],
		   RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !>,
		   ICONS <! !> ],
	    ARG-S < #spr . #comps > ],
    MODIFD.LPERIPH bool,
    LKEYS [ KEYREL #keyrel & it_adj_arg1_relation & 
		   [ LBL #ltop,
		     ARG1 handle & #arg,
		     ARG0 #arg0 & non_conj_event ],
	    --+ARGIND it-ind ] ].

;; Relax the GENRE for now, to see if we still benefit from using `formal'
;; for the rest of OP generation
;;
contracted_aux_word := word &
  [ ALTS [ VPELLIP -,
           SQPNCT -,
	   CSAI - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST expressed_synsem ].

;; Removed RPERIPH + to allow post-modification, as in "it (i.e. B)"
;;
n_-_pr-it_lexent := basic_n_pers_pro_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR < [ --MIN no_rel ] >,
			       COMPS < > ],
                     CONT.RELS <! relation, relation !>,
                     CTXT.ACTIVATED - ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                             GEN neut ],
                                 PRONTYPE std_pron ] ] ].

;; Remove LPERIPH + on mother, to allow varied behavior with embedded vs
;; main-clause "if" for pronouns
;;
adj_head_scop_phrase := basic_adj_head_scop_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
    NH-DTR.SYNSEM [ LOCAL.CAT.VAL.COMPS *olist*,
		    PUNCT.RPUNCT comma_or_pair_or_no_punct ] ].

;; Constrain PRONTYPE to not_pron -- maybe push up into regular grammar? FIX
n_proper_lexent := norm_n_proper_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN named_np_rel,
		   CONT.HOOK.INDEX.PRONTYPE not_pron ] ].


