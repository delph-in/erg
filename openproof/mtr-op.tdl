;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OpenProof MRS-inflating and paraphrase rules

;;;; MRS `inflation' rules

openproof_mtr := monotonic_mtr &
[ INPUT.HOOK.INDEX #index,
  OUTPUT.HOOK.INDEX #index & [ E [ TENSE present, ASPECT.PRF - ] ] ].

;; "name"
;;
named_op_mtr := openproof_mtr &
[ INPUT [ RELS <! [ PRED "name", LBL #h1, ARG0 #x2, CARG #carg ] !>,
	  HCONS <! !> ],
  OUTPUT [ RELS <! [ PRED named_rel, LBL #h1 & handle, ARG0 #x2 & ref-ind, 
		     CARG #carg ] !>,
	   HCONS <! !> ],
  FLAGS.EQUAL < #x2 > ].

;; "cube"
;;
pred_noun_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h2, ARG0 #e3, ARG1 ref-ind & #x4 ] !>,  
  OUTPUT.RELS <! [ LBL #h2, PRED _be_v_id_rel, 
		   ARG0 #e3 & event & [ E [ TENSE present, ASPECT.PRF - ] ],
		   ARG1 #x4, ARG2 #x5 ],
	         [ LBL handle, ARG0 ref-ind & #x5 ] !> ].

;; "large"
;;
adj_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h2, ARG0 #e3, ARG1 ref-ind & #x4 ] !>, 
  OUTPUT.RELS <! [ LBL #h2, ARG1 #x4,
		   ARG0 #e3 & 
		       event & [ E [ TENSE present, ASPECT.PRF - ] ] ] !>,
  FLAGS.EQUAL < #x4 > ].

;; "samesize"
;;
same_noun_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5 ] !>, 
  OUTPUT.RELS <! [ PRED _be_v_id_rel, LBL #h1, 
		   ARG0 #e3 &  [ E [ TENSE present, ASPECT [ PRF -, PROGR - ]]],
		   ARG1 #x4, ARG2 #x6 ],
	         [ LBL #h2, ARG0 ref-ind & #x6 & [ PNG.PN 3s ] ],
		 [ PRED "_same_a_as_rel", LBL #h2, 
		   ARG0 event & #e7 & [ E.TENSE untensed ], ARG1 #x6 ],
		 [ PRED comp_equal_rel, LBL #h2, ARG0 [ E.TENSE untensed ],
		   ARG1 #e7, ARG2 #x5 ] !> ].

;; "samecol", "samerow"
;;
same_loc_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5 ] !>, 
  OUTPUT.RELS <! [ PRED _in_p_rel, LBL #h1, ARG0 #e3, ARG1 #x4, ARG2 #x6 ],
	         [ LBL #h2, ARG0 ref-ind & #x6 & [ PNG.PN 3s ] ],
	         [ PRED "_same_a_as_rel", LBL #h2, 
		   ARG0 event & #e7 & [ E.TENSE untensed ], ARG1 #x6 ],
	         [ PRED comp_equal_rel, LBL #h2, ARG0 [ E.TENSE untensed ],
		   ARG1 #e7, ARG2 #x5 ] !> ].

openproof_addquant_mtr := openproof_mtr &
[ OUTPUT [ RELS.LIST < [ LBL #h1 ], [ RSTR #h2 ], ... >, 
	   HCONS <! qeq & [ HARG #h2, LARG #h1 ] !> ] ].


;; "rightof"
;;
loc_of_op_gpr := openproof_addquant_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5 ] !>, 
  OUTPUT.RELS <! [ LBL #h2 & handle, ARG0 #x6 ],
	         [ PRED _the_q_rel, LBL handle, ARG0 #x6 & ref-ind ],
		 [ PRED _to_p_rel, LBL #h1, ARG0 #e3, ARG1 #x4, ARG2 #x6 ],
		 [ PRED _of_p_rel, LBL #h2, ARG0 event, 
		   ARG1 #x6, ARG2 ref-ind & #x5 ] !>,
  FLAGS.EQUAL < #x4, #x5 > ].

;; "backof"
;;
prep_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, ARG2 ref-ind & #x5] !>,
  OUTPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 #x4, ARG2 #x5 ] !>,
  FLAGS.EQUAL < #x4, #x5 > ].

;; "between"
;;
prep_threearg_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5, ARG3 ref-ind & #x6  ] !>, 
  OUTPUT.RELS <! [ PRED _and_c_rel, LBL handle, ARG0 conj_ref-ind & #x7, 
		   L-INDEX #x5, R-INDEX #x6 ],
		 [ LBL #h1, ARG0 #e3, ARG1 #x4, ARG2 #x7 ] !> ].


;; "larger"
;;
compar_adj_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5 ] !>, 
  OUTPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 #x4 ],
	         [ PRED comp_rel, LBL #h1, 
		   ARG0 event & [ E [ TENSE untensed, ASPECT no_aspect ] ],
		   ARG1 #e3, ARG2 #x5 ] !>,
  FLAGS.EQUAL < #h1 > ].

;; Add quantifiers
;;
add_quant_mtr := openproof_mtr &
[ CONTEXT.RELS <! [ LBL handle & #h1, ARG0 #x2 & ref-ind ] !>,
  FILTER.HCONS <! qeq & [ LARG #h1 ] !>,
  OUTPUT [ RELS <! [ LBL handle, ARG0 #x2, RSTR handle & #h5, BODY handle ] !>,
	   HCONS <! qeq & [ HARG handle & #h5, LARG #h1 ] !> ],
  FLAGS.SUBSUME < #x2 > ].


;; Conjunctions
;;
conj_op_mtr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1 & handle, ARG0 #i2 & individual, 
		  L-INDEX #i3 & individual, R-INDEX #i4 & individual ] !>,
  OUTPUT.RELS <! [ LBL #h1 & handle, ARG0 #i2, L-INDEX #i3, R-INDEX #i4] !> ].

;; Add left and right handles for conj-rels with event arguments
;;
add_conjunction_handles_mtr := openproof_mtr &
[ CONTEXT.RELS <! [ LBL #h1 & handle, ARG0 event & #e2 ],
		  [ LBL #h3 & handle, ARG0 event & #e4 ] !>,
  INPUT.RELS <! [ PRED conj_rel & #pred, LBL #h5, 
		  ARG0 #e6 & [ E [ ASPECT.PRF -, TENSE present ], SF prop ], 
		  L-INDEX #e2, R-INDEX #e4, L-HNDL individual, 
		  R-HNDL individual ] !>,
  OUTPUT [ RELS <! [ PRED #pred, LBL #h5, ARG0 #e6, L-INDEX #e2, R-INDEX #e4,
		   L-HNDL #h10 & handle, R-HNDL #h11 & handle ] !>,
	   HCONS <! qeq & [ HARG #h10, LARG #h1 ], 
		    qeq & [ HARG #h11, LARG #h3 ] !> ] ].

adjust_neg_conj_index_mtr := openproof_mtr &
[ CONTEXT [ RELS <! [ PRED neg_rel, LBL handle, ARG0 event, 
		      ARG1 #h10 & handle ],
		    [ LBL #h11 & handle, ARG0 event ] !>,
	    HCONS <! qeq & [ HARG #h10, LARG #h11 ] !> ],
  INPUT.RELS <! [ PRED conj_rel & #pred, LBL #h5, ARG0 #e6,
		  L-HNDL #h7, R-HNDL #h8 ] !>,
  OUTPUT.RELS <! [ PRED #pred, LBL #h5 & handle, ARG0 #e6,
		   L-HNDL #h7 & handle, R-HNDL #h8 & handle ] !> ].

adjust_neg_conj_index_left_mtr := adjust_neg_conj_index_mtr &
[ CONTEXT.RELS <! [ ARG0 #e1 & event ], [ ARG0 #e2 & event ] !>,
  INPUT.RELS <! [ L-INDEX #e1, R-INDEX #e3 & event ] !>,
  OUTPUT.RELS <! [ L-INDEX #e2, R-INDEX #e3 ] !> ].

adjust_neg_conj_index_right_mtr := adjust_neg_conj_index_mtr &
[ CONTEXT.RELS <! [ ARG0 #e1 & event ], [ ARG0 #e2 & event ] !>,
  INPUT.RELS <! [ LBL #h1, L-INDEX #e3 & event, R-INDEX #e1 ] !>,
  OUTPUT.RELS <! [ LBL #h1, L-INDEX #e3, R-INDEX #e2 ] !> ].

negation_op_mtr := openproof_mtr &
[ CONTEXT.RELS <! [ LBL handle & #h1, ARG0 event & #e2 ] !>,
  INPUT.RELS <! [ PRED "not", LBL #h3, ARG0 #e1, ARG1 #e2 ] !>,
  OUTPUT [ RELS <! [ PRED neg_rel, LBL #h3 & handle, 
		     ARG0 #e1 & event & [ E.TENSE untensed ],
		     ARG1 #h4 & handle ] !>,
 	   HCONS <! qeq & [ HARG #h4, LARG #h1 ] !> ],
  FLAGS.EQUAL < #e1, #e2 > ].

;; if-then
;;
if_then_cond_mtr := openproof_mtr &
[ CONTEXT.RELS <! [ LBL #h5, ARG0 #e3 ],
		  [ LBL #h6, ARG0 #e4 ] !>,
  INPUT.RELS <! [ PRED "if", LBL #h1, ARG0 #e2, L-INDEX #e3, R-INDEX #e4 ] !>,
  OUTPUT [ RELS <! [ PRED "_if_x_then_rel", LBL #h1, 
		     ARG0 #e2 & event & [ E.TENSE untensed ], 
		     ARG1 #h7, ARG2 #h8 ],
		   [ PRED "_then_a_1_rel", LBL #h10, 
		     ARG0 event & [ E.TENSE untensed ], ARG1 #h11 ] !>,
	   HCONS <! qeq & [ HARG #h7, LARG #h10 ],
		    qeq & [ HARG #h11, LARG #h6 ],
		    qeq & [ HARG #h8, LARG #h5 ] !> ] ].

;; Accommodate variant input with L-INDEX, R-INDEX
;;
if_and_only_if_mtr := openproof_mtr &
[ CONTEXT.RELS <! [ LBL #h5, ARG0 #e3 ],
		  [ LBL #h6, ARG0 #e4 ] !>,
  INPUT [ RELS <! [ PRED "iff", LBL #h1, ARG0 #e2, L-INDEX #e3, 
		    R-INDEX #e4 ] !> ],
  OUTPUT [ RELS <! [ PRED "_if+and+only+if_x_1_rel", LBL #h1, 
		     ARG0 #e2 & event & [ E.TENSE untensed ], 
		     ARG1 #h7, ARG2 #h8 ] !>,
	   HCONS <! qeq & [ HARG #h7, LARG #h5 ],
		    qeq & [ HARG #h8, LARG #h6 ] !> ] ].


;;;; OpenProof paraphrase rule types

;; Coord subj: When given two clauses where the subjects differ but the
;; VPs are identical, discard the second identical verbal conjunct and create a 
;; conjoined subject NP whose conj's PRED is the same as the sentence conj PRED.
;;
;; A and B are large
;;
basic_coord_subj_onearg_op_gpr := monotonic_omtr &
[ CONTEXT.RELS.LIST < [ PRED named_rel, ARG0 ref-ind & #x3 ],
                      [ ARG0 ref-ind & #x6 ],
		      [ PRED quant_rel, ARG0 #x6 ], ... >,
  INPUT [ HOOK.INDEX #index,
	  RELS.LIST < 
		  [ LBL handle, ARG0 #e2 & event & [ E.TENSE present ],
		    ARG1 #x3 & ref-ind, PRED #pred ],
                  [ LBL handle, ARG0 #e5 & event  & [ E.TENSE present ], 
		    ARG1 #x6 & ref-ind, PRED #pred ],
	   	  [ PRED conj_rel, LBL handle, ARG0 #e10 & event,
		    L-INDEX #e2, R-INDEX #e5, L-HNDL #h21, R-HNDL #h22 ], ... >,
	  HCONS.LIST < qeq & [ HARG #h21 ], qeq & [ HARG #h22 ], ... > ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS.LIST <
		   [ LBL handle, ARG0 #e10 & event &
                     [ E [ ASPECT.PRF -, TENSE present ], SF prop ],
		     ARG1 #x10, PRED #pred ],
		   [ PRED udef_q_rel, LBL handle, ARG0 #x10 & conj_ref-ind,
		     RSTR handle & #h11, BODY handle ],
                   [ PRED conj_rel, LBL handle & #h12, ARG0 #x10 & [ PNG.PN 3 ],
                     L-INDEX #x3 & ref-ind & [ PNG [ PN 3s ] ],
		     R-INDEX #x6 & ref-ind ], ... >,
	   HCONS <! qeq & [ HARG #h11, LARG #h12 ] !> ],
  FLAGS.SUBSUME < #x3, #x6, ... > ].

;; The INPUT..[ARG2 handle] is a hack to prevent this rule from applying to 
;; two-arg predications.
;;
basic_coord_subj_onearg_pos_op_gpr := basic_coord_subj_onearg_op_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ] !>,
  FILTER.RELS <! [ PRED comp_rel, LBL #h1 ] !>,
  INPUT [ RELS <! [ LBL #h1, ARG2 handle ], [ LBL #h2 ], [ LBL #h3 ] !>,
          HCONS <! qeq & [ LARG #h1 ], qeq & [ LARG #h2 ] !> ],
  OUTPUT.RELS <! [ LBL #h3 ], [ ], [ ] !>,
  FLAGS.SUBSUME < semarg, semarg > ].

coord_subj_onearg_pos_op_gpr := basic_coord_subj_onearg_pos_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED #cpred ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED #cpred ] !> ].

coord_subj_onearg_pos_nary_op_gpr := basic_coord_subj_onearg_pos_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED implicit_conj_rel ] !> ].

;; "A and B are not large"
;;
basic_coord_subj_onearg_neg_op_gpr := basic_coord_subj_onearg_op_gpr &
[ CONTEXT.HCONS <! qeq & [ HARG #h3, LARG #h1 ] !>,
  FILTER.RELS <! [ PRED comp_rel, LBL #h1 ] !>,
  INPUT [ RELS <! [ LBL #h1, ARG2 handle ], [ LBL #h2 & handle ], 
                  [ LBL #h20 & handle ], 
		  [ PRED neg_rel, LBL #h10 & handle, ARG0 #e1, 
		    ARG1 #h3 & handle ],
		  [ PRED neg_rel, LBL #h11 & handle, ARG1 #h4 & handle ] !>,
	  HCONS <! qeq & [ LARG #h10 ], qeq & [ LARG #h11 ], 
	           qeq & [ HARG #h4, LARG #h2 ] !> ],
  OUTPUT.RELS <! [ LBL #h1 & handle ], [ ], [ ],
	         [ PRED neg_rel, LBL #h20, ARG0 #e1, ARG1 #h3 & handle ] !>,
  FLAGS.SUBSUME < semarg, semarg > ].

coord_subj_onearg_neg_op_gpr := basic_coord_subj_onearg_neg_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], 
                [ PRED #cpred ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ],
                [ PRED #cpred ], [ ] !> ].

coord_subj_onearg_neg_nary_op_gpr := basic_coord_subj_onearg_neg_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], 
                [ PRED implicit_conj_rel ], [ ] !> ].

;; Two-argument common predicates with coord subj
;;   B and D are smaller than C.
;;   B and D are cubes
;;
basic_coord_subj_twoarg_op_gpr := basic_coord_subj_onearg_op_gpr &
[ CONTEXT.RELS.LIST < [ ], [ ], [ ],
		      [ PRED named_rel, ARG0 #x7, CARG #carg ], ... >,
  FILTER [ RELS <! [ PRED neg_rel, ARG1 #h10 ] !>,
	   HCONS <! qeq & [ HARG #h10 ] !> ],
  INPUT [ RELS.LIST < [ ], [ ], [ ],
		      [ PRED named_rel, ARG0 ref-ind & #x8, CARG #carg ],
		      [ PRED proper_q_rel, LBL handle, ARG0 #x8, 
			RSTR handle & #h20, BODY handle ], ... >,
	  HCONS.LIST < qeq, qeq, qeq & [ HARG #h20 ], ... > ],
   FLAGS.SUBSUME < semarg, semarg, #x7, #x8 > ].

;; B and D are in back of C.
;;
coord_subj_twoarg_op_gpr := basic_coord_subj_twoarg_op_gpr &
[ FILTER.HCONS <! qeq & [ LARG #h1 ] !>,
  INPUT [ RELS.LIST < [ ], [ ], [ LBL #h1 ], ... >,
	  HCONS <! qeq, qeq, qeq !> ] ].

basic_coord_subj_twoarg_pos_op_gpr := coord_subj_twoarg_op_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ARG0 #x1 ] !>,
  INPUT.RELS <! [ ARG2 #x1 ], [ ARG2 #x2 ], [ LBL #h2 ], [ ARG0 #x2 ], [ ] !>,
  OUTPUT.RELS <! [ LBL #h2, ARG2 #x1 ], [ ], [ ] !> ].

coord_subj_twoarg_pos_op_gpr := basic_coord_subj_twoarg_pos_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel ], [ PRED proper_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED #cpred ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED #cpred ] !> ].

coord_subj_twoarg_pos_nary_op_gpr := basic_coord_subj_twoarg_pos_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ], [ PRED udef_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED _and_c_rel ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED implicit_conj_rel ] !> ].

basic_coord_subj_compar_op_gpr := coord_subj_twoarg_op_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ARG0 #x7 ] !>,
  INPUT.RELS <! [ LBL #h1 ],
                [ ARG0 #e5 & event ], [ LBL #h2 ],
		[ ARG0 #x8 ], [ ], 
		[ PRED comp_rel, ARG1 #e5, ARG2 #x8 ], 
		[ PRED comp_rel, LBL handle & #h1, ARG0 #e1, ARG2 #x7 ] !>,
  OUTPUT.RELS <! [ LBL #h2, ARG0 #e2 ], [ ], [ ],
 		 [ PRED comp_rel, LBL #h2, ARG0 #e1, ARG1 #e2, ARG2 #x7 ] !> ].

coord_subj_compar_op_gpr := basic_coord_subj_compar_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel ], [ PRED proper_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED #cpred ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED #cpred ], [ ] !> ].

coord_subj_compar_nary_op_gpr := basic_coord_subj_compar_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ], [ PRED udef_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED _and_c_rel ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED implicit_conj_rel ], [ ] !> ].

basic_coord_subj_twoarg_neg_op_gpr := basic_coord_subj_twoarg_op_gpr &
[ CONTEXT [ RELS <! [ ], [ ], [ ], [ ARG0 #x1 ] !>,
	    HCONS <! qeq & [ HARG #h3, LARG #h1 ] !> ],
  FILTER.HCONS <! qeq & [ LARG #h10 ] !>,
  INPUT [ RELS <! [ LBL #h1 ], [ LBL #h2, ARG2 #x2 ], [ LBL #h10 ], 
		  [ ARG0 #x2 ], [ ],
		  [ PRED neg_rel, ARG0 #e1, ARG1 #h3 ],
		  [ PRED neg_rel, ARG1 #h4 ] !>,
	  HCONS <! qeq, qeq, qeq, qeq & [ HARG #h4, LARG #h2 ] !> ],
  OUTPUT.RELS <! [ LBL #h1, ARG2 #x1 ], [ ], [ ],
	         [ PRED neg_rel, LBL #h10, ARG0 #e1, ARG1 #h3 ] !> ].

coord_subj_twoarg_neg_op_gpr := basic_coord_subj_twoarg_neg_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel ], [ PRED proper_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED #cpred ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED #cpred ], [ ] !> ].

coord_subj_twoarg_neg_nary_op_gpr := basic_coord_subj_twoarg_neg_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ], [ PRED udef_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED _and_c_rel ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED implicit_conj_rel ], [ ] !> ].


;; B and D are cubes
;; B and D are not cubes
;;
coord_subj_twoarg_noprop_op_gpr := basic_coord_subj_onearg_op_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ] !>,
  INPUT [ RELS.LIST < [ ARG2 #x7 ], [ ARG2 #x8 ], [ ],
		  [ PRED #pred, ARG0 ref-ind & #x8 ],
		  [ PRED udef_a_q_rel, LBL handle, ARG0 #x8, 
		    RSTR handle & #h20, BODY handle ],
		  [ PRED "~._n_" & #pred, LBL handle & #h4, ARG0 ref-ind & #x7],
		  [ PRED udef_a_q_rel, LBL #h2 & handle, ARG0 #x7, RSTR #h21, 
		    BODY #h22 ], ... >,
	  HCONS.LIST < qeq, qeq, qeq & [ HARG #h20 ], ... > ],
  OUTPUT.RELS.LIST < [ LBL handle, ARG1.PNG.PN #pn, ARG2 #x7 & [ PNG.PN #pn ] ],
		     [ ], [ ],
		     [ PRED #pred, LBL #h4, ARG0 #x7 ],
		     [ PRED udef_a_q_rel, LBL #h2, ARG0 #x7, 
		       RSTR #h21, BODY #h22 ], ... >,
  FLAGS.SUBSUME < semarg, semarg, #x7, #x8 > ].

;; B and D are cubes
;;
bsc_crd_subj_twoarg_noprop_pos_op_gpr := coord_subj_twoarg_noprop_op_gpr &
[ FILTER [ RELS <! [ PRED neg_rel, ARG1 #h1 ] !>,
	   HCONS <! qeq & [ HARG #h1, LARG #h3 ] !> ],
  INPUT [ RELS <! [ ], [ LBL #h3 ], [ LBL #h2 ], [ ], [ ], [ ], [ ] !>,
	  HCONS <! qeq, qeq, qeq !> ],
  OUTPUT.RELS <! [ LBL #h2 ], [ ], [ ] !> ].

coord_subj_twoarg_noprop_pos_op_gpr := bsc_crd_subj_twoarg_noprop_pos_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel ], [ PRED proper_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED #cpred ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED #cpred ] !> ].

coord_subj_twoarg_noprop_nary_op_gpr := bsc_crd_subj_twoarg_noprop_pos_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ], [ PRED udef_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED conj_rel ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED implicit_conj_rel ] !> ].


;; B and D are not cubes
;;
bsc_coord_subj_twoarg_noprop_neg_gpr := coord_subj_twoarg_noprop_op_gpr &
[ CONTEXT.HCONS <! qeq & [ HARG #h3, LARG #h1 ] !>,
  FILTER [ RELS <! [ PRED neg_rel, ARG1 #h20 ] !>,
	   HCONS <! qeq & [ HARG #h20, LARG #h10 ] !> ],
  INPUT [ RELS <! [ LBL #h1 ], [ LBL #h2 ], [ LBL #h10 ], [ ], [ ], [ ], [ ],
		  [ PRED neg_rel, ARG0 #e1, ARG1 #h3 ],
		  [ PRED neg_rel, ARG1 #h4 ] !>,
	  HCONS <! qeq, qeq, qeq, qeq & [ HARG #h4, LARG #h2 ] !> ],
  OUTPUT.RELS <! [ LBL #h1 ], [ ], [ ], [ ], [ ],
	         [ PRED neg_rel, LBL #h10, ARG0 #e1, ARG1 #h3 ] !> ].

coord_subj_twoarg_noprop_neg_gpr := bsc_coord_subj_twoarg_noprop_neg_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel ], [ PRED proper_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED #cpred ], [ ], [ ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED #cpred ], [ ], [ ], [ ] !> ].

coord_subj_twoarg_noprop_neg_nary_gpr := bsc_coord_subj_twoarg_noprop_neg_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ], [ PRED udef_q_rel ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED _and_c_rel ], [ ], [ ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED implicit_conj_rel ], [ ], [ ], [ ] !> ].


;; A and B are between C and D
;;
basic_coord_subj_threearg_op_gpr := basic_coord_subj_twoarg_op_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ARG0 #x1 ],
		  [ PRED _and_c_rel, ARG0 #x8 & conj_ref-ind, 
		    L-INDEX #x1 & ref-ind, R-INDEX #x9 & ref-ind ],
		  [ PRED named_rel, ARG0 #x9, CARG #carg ] !>,
  FILTER.HCONS <! qeq & [ LARG #h30 ] !>,
  INPUT [ RELS <! [ PRED _between_p_rel, ARG2 #x8 ], [ ARG2 #x13 ], 
		  [ LBL #h30 ], [ ARG0 #x11 & ref-ind ], [ ],
	   	  [ PRED _and_c_rel, ARG0 #x13 & conj_ref-ind, 
		    L-INDEX #x11, R-INDEX #x12 ],
		  [ PRED udef_q_rel, ARG0 #x13, RSTR handle & #h21 ],
		  [ PRED named_rel, ARG0 ref-ind & #x12, CARG #carg ],
		  [ PRED proper_q_rel, ARG0 #x12, RSTR handle & #h20 ] !>,
	  HCONS <! qeq, qeq, qeq, qeq & [ HARG #h20 ], qeq & [ HARG #h21 ] !> ],
  OUTPUT.RELS <! [ LBL #h30 ], [ ], [ ] !> ].

coord_subj_threearg_op_gpr := basic_coord_subj_threearg_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel ], [ PRED proper_q_rel ], [], [], [] !>,
  INPUT.RELS <! [ ], [ ], [ PRED #cpred ], [ ], [ ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED #cpred ] !> ].

coord_subj_threearg_nary_op_gpr := basic_coord_subj_threearg_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ], [ PRED udef_q_rel ], [ ], [ ], [ ] !>,
  INPUT.RELS <! [ ], [ ], [ PRED _and_c_rel ], [ ], [ ], [ ], [ ], [ ], [ ] !>,
  OUTPUT.RELS <! [ ], [ ], [ PRED implicit_conj_rel ] !> ].


;; Common subj in coord Ss: note that need to drop the qeqs for L-HNDL, R-HNDL
;; when doing VP coord.  REVIEW.
;; B is smaller than C and (is) larger than D.
;;
basic_coord_vp_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ ARG0 event & #e1 & [ E.TENSE present ], ARG1 #x1 ],
		  [ ARG0 #x1 & ref-ind ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED conj_rel & #pred1, LBL #h14, ARG0 #e7, L-INDEX #e1, 
		    R-INDEX #e2, L-HNDL #h10 & handle, R-HNDL #h11 & handle ],
		  [ ARG0 #x2 & ref-ind ],
		  [ PRED quant_rel, ARG0 #x2, RSTR #h20 ],
		  [ PRED #pred2, LBL #h4, ARG0 event & #e2, ARG1 #x2 ] !>,
	  HCONS <! qeq & [ HARG #h20 ], 
		   qeq & [ HARG #h10, LARG #h12 ],
		   qeq & [ HARG #h11, LARG #h13 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED #pred1, LBL #h14, ARG0 #e7, L-INDEX #e1, R-INDEX #e2,
		     L-HNDL #h12, R-HNDL #h13 ],
		   [ PRED #pred2, LBL #h4, ARG0 #e2, ARG1 #x1 ] !>,
	   HCONS <! !> ],
  FLAGS.SUBSUME < #e2, #x1, #x2, ... > ].

coord_vp_onearg_op_gpr := basic_coord_vp_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel, CARG #carg ] !>,
  FILTER.RELS <! [ PRED "_the+case_a_1_rel" ] !>,
  INPUT.RELS <! [], [ PRED named_rel, CARG #carg ], [], [ ARG2 handle ] !>,
  FLAGS.SUBSUME < semarg, semarg, semarg > ].

coord_vp_twoarg_op_gpr := basic_coord_vp_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED named_rel, CARG #carg ] !>,
  FILTER.RELS <! [ PRED "_the+case_a_1_rel" ] !>,
  INPUT.RELS <! [], [ PRED named_rel, CARG #carg ], [], 
	        [ ARG2 #x3 & ref-ind ] !>,
  OUTPUT.RELS <! [], [ ARG2 #x3 ] !>,
  FLAGS.SUBSUME < semarg, semarg, semarg, #x3 > ].

;; B and C are large and (they) are not small.
;;
coord_vp_prosubj_onearg_op_gpr := basic_coord_vp_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ] !>,
  FILTER.RELS <! [ PRED "_both_a_1_rel" ] !>,
  INPUT.RELS <! [], [ PRED pron_rel ], [], [ ARG2 handle ] !>,
  FLAGS.SUBSUME < semarg, semarg, semarg > ].

coord_vp_prosubj_twoarg_op_gpr := basic_coord_vp_op_gpr &
[ CONTEXT.RELS <! [ ], [ PRED conj_rel ] !>,
  FILTER.RELS <! [ PRED "_both_a_1_rel" ] !>,
  INPUT.RELS <! [], [ PRED pron_rel ], [], 
	        [ ARG2 #x3 & ref-ind ] !>,
  OUTPUT.RELS <! [], [ ARG2 #x3 ] !>,
  FLAGS.SUBSUME < semarg, semarg, semarg, #x3 > ].


;; A is larger than B and C
;; ? A is in front of B and C
;;
basic_coord_pred_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED named_rel, ARG0 ref-ind, CARG #carg ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS.LIST <
                  [ PRED #vpred, LBL #h1 & handle, ARG2 #x2 & ref-ind ],
		  [ PRED #vpred, LBL #h4 & handle, ARG2 #x3 & ref-ind ],
		  [ PRED conj_rel & #cpred, L-HNDL #h10, R-HNDL #h11 ],
		  [ PRED named_rel, ARG0 #x4 & ref-ind, CARG #carg ],
		  [ PRED proper_q_rel, ARG0 #x4, RSTR #h20 ], ... >,
	  HCONS <! qeq & [ HARG #h10, LARG #h1 ], 
		   qeq & [ HARG #h11, LARG #h4 ],
		   qeq & [ HARG #h20 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS.LIST <
		   [ PRED #vpred, ARG2 #x6 ],
		   [ PRED conj_rel & #cpred, LBL handle & #h5, ARG0 #x6, 
		     L-INDEX #x2, R-INDEX #x3 ],
		   [ PRED udef_q_rel, LBL handle, ARG0 #x6 & ref-ind,
		      RSTR #h21, BODY handle ], ... >,
 	   HCONS <! qeq & [ HARG #h21, LARG #h5 ] !> ],
  FLAGS.EQUAL < #x6, #x2, #x3 > ].

;; A is larger than B and C
;;
coord_pred_comp_op_gpr := basic_coord_pred_op_gpr &
[ CONTEXT.RELS <! [ ARG0 #x1 & ref-ind ] !>,
  INPUT.RELS <! [ PRED comp_rel, LBL #h1 & handle, ARG0 #e2 & event ], 
	        [ PRED comp_rel, LBL #h2 & handle ], 
	        [ LBL #h3 & handle, ARG0 #e1 & event ], 
	        [ ARG0 #x2 & ref-ind ], [ ],
	        [ PRED "~._a_" & #pred, LBL #h1, ARG1 #x1 ],
	        [ PRED "~._a_", LBL #h2, ARG1 #x2 ] !>,
  OUTPUT.RELS <! [ LBL #h3, ARG0 #e2, ARG1 #e1 ], [ ], [ ],
	         [ PRED #pred, LBL #h3, ARG1 #x1,
		   ARG0 #e1 & [ E [ TENSE present, ASPECT.PRF - ] ] ] !> ].

basic_pro_subj_gpr := monotonic_omtr &
[ CONTEXT.RELS.LIST < [ ARG0 event & [ E.TENSE present ], ARG1 #x1 ],
		      [ ARG0 event & [ E.TENSE present ], ARG1 #x2 ],
		      [ ARG0 #x1 & ref-ind ],
		      [ PRED quant_rel & #qpred, ARG0 #x1 ], ... >,
  INPUT [ HOOK.INDEX #index,
	  RELS.LIST < [ LBL #h10, ARG0 #x2 & ref-ind ],
		    [ PRED #qpred, ARG0 #x2, RSTR #h20 ], ... > ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED pron_rel, LBL #h10, ARG0 #x2 ],
		   [ PRED pronoun_q_rel, LBL handle, ARG0 #x2, RSTR #h20 ] !>,
	   HCONS <! !> ],
  FLAGS.SUBSUME < #x2, ... > ].

pro_subj_gpr := basic_pro_subj_gpr &
[ CONTEXT.RELS.LIST < [ ], [ ],
		      [ PRED named_rel, CARG #carg ], ... >,
  INPUT.RELS <! [ PRED named_rel, ARG0.PNG.GEN neut, CARG #carg ], [ ] !>,
  FLAGS.SUBSUME < semarg > ].

subord_s_pro_subj_gpr := pro_subj_gpr &
[ CONTEXT [ RELS.LIST < [ ], [ ], [ ], [ ], [ ARG2 #h3 ], ... >,
	    HCONS.LIST < qeq & [ ],
		         qeq & [ HARG #h3 ], ... > ] ].

;; If B is a cube then it is large
;;
cond_s_pro_subj_gpr := subord_s_pro_subj_gpr &
[ CONTEXT [ RELS <! [ LBL #h2 & handle ], [ LBL #h4 & handle ], [ ], [ ],
		    [ PRED "_if_x_then_rel", ARG1 #h3 ],
		    [ PRED "_then_a_1_rel", LBL #h1, ARG1 #h5 ] !>,
	    HCONS <! qeq & [ HARG #h5, LARG #h4 ], [ LARG #h2 ],
		     qeq & [ HARG #h3, LARG #h1 ] !> ] ].

;; B is a cube only if it is large
;;
onlyif_s_pro_subj_gpr := subord_s_pro_subj_gpr &
[ CONTEXT [ RELS <! [ LBL #h2 ], [ LBL #h4 ], [ ], [ ],
		    [ ARG1 #h3 ] !>,
	    HCONS <! [ HARG #h3, LARG #h2 ], [ LARG #h4 ] !> ] ].

;; B is a cube if and only if it is large
;;
bicond_s_pro_subj_gpr := subord_s_pro_subj_gpr &
[ CONTEXT [ RELS <! [ LBL #h2 ], [ LBL #h4 ], [ ], [ ],
		  [ PRED "_if+and+only+if_x_1_rel" ] !>,
	    HCONS <! [ LARG #h2 ], [ LARG #h4 ] !> ] ].

;; Coord subj with pronoun
;;
pro_coord_subj_gpr := basic_pro_subj_gpr &
[ CONTEXT.RELS.LIST < [ ], [ ], 
		      [ PRED _and_c_rel, L-INDEX #x1, R-INDEX #x2 ], [ ],
		      [ PRED named_rel, ARG0 #x1, CARG #carg1 ],
		      [ PRED named_rel, ARG0 #x2, CARG #carg2 ], ... >,
  INPUT [ RELS <! [ PRED _and_c_rel, L-INDEX #x3, R-INDEX #x4 ], [ ],
		  [ PRED named_rel, ARG0 #x3, CARG #carg1 ],
		  [ PRED named_rel, ARG0 #x4, CARG #carg2 ], 
		  [ PRED proper_q_rel, ARG0 #x3, RSTR #h20 ],
		  [ PRED proper_q_rel, ARG0 #x4, RSTR #h21 ] !>,
	  HCONS <! qeq & [ HARG #h20 ], qeq & [ HARG #h21 ] !> ],
  OUTPUT.RELS.LIST < [ ARG0.PNG.PN 3p ], ... > ].

subord_s_pro_coord_subj_gpr := pro_coord_subj_gpr &
[ CONTEXT [ RELS.LIST < [ ], [ ], [ ], [ ], [ ], [ ],
			[ ARG2 #h3 ], ... >,
	    HCONS.LIST < qeq & [ ],
		         qeq & [ HARG #h3 ], ... > ] ].

;; If B and C are cubes then they are large
;
cond_s_pro_coord_subj_gpr := subord_s_pro_coord_subj_gpr &
[ CONTEXT [ RELS <! [ LBL #h2 & handle ], [ LBL #h4 & handle ], [ ], [ ],
		    [ ], [ ], [ PRED "_if_x_then_rel", ARG1 #h3 ],
		    [ PRED "_then_a_1_rel", LBL #h1, ARG1 #h5 ] !>,
	    HCONS <! qeq & [ HARG #h5, LARG #h4 ], [ LARG #h2 ],
		     qeq & [ HARG #h3, LARG #h1 ] !> ] ].

;; B and C are cubes only if they are large
;;
onlyif_s_pro_coord_subj_gpr := subord_s_pro_coord_subj_gpr &
[ CONTEXT [ RELS <! [ LBL #h2 ], [ LBL #h4 ], [ ], [ ], [ ], [ ],
		    [ PRED "_only+if_x_rel", ARG1 #h3 ] !>,
	    HCONS <! [ HARG #h3, LARG #h2 ], [ LARG #h4 ] !> ] ].

;; B and C are cubes if and only if they are large
;;
bicond_s_pro_coord_subj_gpr := subord_s_pro_coord_subj_gpr &
[ CONTEXT [ RELS <! [ LBL #h2 ], [ LBL #h4 ], [ ], [ ], [ ], [ ],
		  [ PRED "_if+and+only+if_x_1_rel" ] !>,
	    HCONS <! [ LARG #h2 ], [ LARG #h4 ] !> ] ].


;; B is in front of or smaller than C
;;
shared_dobj_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #h1, ARG0 event, ARG2 #x1 ],
		  [ PRED named_rel, ARG0 #x1 & ref-ind, CARG #carg ],
		  [ PRED conj_rel, L-HNDL #h1, R-HNDL #h2 ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED named_rel, ARG0 #x2 & ref-ind, CARG #carg ],
		  [ PRED proper_q_rel, ARG0 #x2, RSTR #h20 ],
		  [ PRED #pred, LBL #h2, ARG0 event & #e2, ARG1 #i3,
		    ARG2 #x2 ] !>,
	  HCONS <! qeq & [ HARG #h20 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED #pred, LBL #h2, ARG0 #e2, ARG1 #i3, ARG2 #x1 ] !>,
	   HCONS <! !> ],
  FLAGS.EQUAL < #e2, #x1, #x2 > ].

;; B is smaller than D or C
;;
shared_vp_comp_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED named_rel, ARG0 #x1 & ref-ind, CARG #carg ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED conj_rel & #cpred, LBL #h10, ARG0 #e11, 
		    L-HNDL #h12, R-HNDL #h13 ],
	        [ PRED named_rel, ARG0 #x2 & ref-ind, CARG #carg ],
	        [ PRED proper_q_rel, ARG0 #x2, RSTR #h20 ],
	        [ PRED "~._a_" & #apred, LBL #h1, ARG0 #e1, ARG1 #x1 ],
	        [ PRED #pred, LBL #h1, ARG0 #e8, ARG1 #e1, ARG2 #x3 & ref-ind ],
		[ PRED #apred, LBL #h2, ARG0 #e3, ARG1 #x2 ],
	        [ PRED #pred, LBL #h2, ARG0 event, ARG1 #e3,
		  ARG2 #x4 & ref-ind ] !>,
	  HCONS <! qeq & [ HARG #h20 ], qeq & [ HARG #h12, LARG #h1 ], 
		   qeq & [ HARG #h13, LARG #h2 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED #apred, LBL #h10, ARG1 #x1,
		     ARG0 #e11 & [ E [ TENSE present, ASPECT.PRF - ] ] ],
		   [ PRED #pred, LBL #h10, ARG0 #e8, ARG1 #e11, ARG2 #x16 ],
		   [ PRED #cpred, LBL #h15 & handle, ARG0 #x16 & ref-ind, 
		     L-INDEX #x3, R-INDEX #x4 ],
	           [ PRED udef_q_rel, LBL handle, ARG0 #x16 & ref-ind,
		      RSTR #h21, BODY handle ] !>,
	   HCONS <! qeq & [ HARG #h21, LARG #h15 ] !> ] ].

;; "B is in the same column as D or C"
;; (no, this is not scalable, but an experiment to see what changes are needed)
;;
shared_vp_same_n_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED named_rel, ARG0 #x1 & ref-ind, CARG #carg ],
		  [ PRED "~._n_" & #npred, LBL #h1, ARG0 #x10 ],
		  [ PRED "~._a_" & #apred, LBL #h1, ARG0 #e2, ARG1 #x10 ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED conj_rel & #cpred, LBL #h10, ARG0 #e11, 
		    L-HNDL #h12, R-HNDL #h13 ],
		[ PRED prep_rel & #ppred, LBL #h5, ARG1 #x1, ARG2 #x10 ],
		[ PRED #pred, LBL #h1, ARG0 #e4, ARG1 #e2, ARG2 #x11 ],
		[ PRED prep_rel & #ppred, LBL #h3, ARG1 #x2, ARG2 #x21 ],
	        [ PRED proper_q_rel, ARG0 #x2, RSTR #h20 ],
	        [ PRED named_rel, ARG0 #x2 & ref-ind, CARG #carg ],
		[ PRED quant_rel, ARG0 #x21, RSTR #h26 ],
		[ PRED #npred, LBL #h25, ARG0 #x21 ],
		[ PRED #apred, LBL #h25, ARG0 #e22 & [ E.TENSE untensed ], 
		  ARG1 #x21 ],
	        [ PRED #pred, LBL #h25, ARG1 #e22, ARG2 #x12 ] !>,
	  HCONS <! qeq & [ HARG #h20 ], qeq & [ HARG #h26 ], 
		   qeq & [ HARG #h12, LARG #h5 ], 
		   qeq & [ HARG #h13, LARG #h3 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED #ppred, LBL #h10, ARG1 #x1, ARG2 #x10,
		     ARG0 #e11 & [ E [ TENSE present, ASPECT.PRF - ] ] ],
		   [ PRED #pred, LBL #h1, ARG0 #e4, ARG1 #e2, ARG2 #x16 ],
		   [ PRED #cpred, LBL #h15 & handle, ARG0 #x16 & ref-ind, 
		     L-INDEX #x11 & ref-ind, R-INDEX #x12 ],
	           [ PRED udef_q_rel, LBL handle, ARG0 #x16,
		      RSTR #h21, BODY handle ] !>,
	   HCONS <! qeq & [ HARG #h21, LARG #h15 ] !> ] ].

;; "B is to the right of C and D"
;;
shared_vp_dir_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED named_rel, ARG0 #x1 & ref-ind, CARG #carg ],
		  [ PRED "~._n_" & #npred, LBL #h1, ARG0 #x10 & ref-ind ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED conj_rel & #cpred, LBL #h10, ARG0 #e11, 
		    L-HNDL #h12, R-HNDL #h13 ],
		[ PRED prep_rel & #ppred, LBL #h5, ARG1 #x1, ARG2 #x10 ],
		[ PRED #ppred2, LBL #h1, ARG0 #e4, ARG1 #x10, ARG2 #x11 ],
		[ PRED prep_rel & #ppred, LBL #h3, ARG1 #x2, ARG2 #x21 ],
	        [ PRED proper_q_rel, ARG0 #x2, RSTR #h20 ],
	        [ PRED named_rel, ARG0 #x2 & ref-ind, CARG #carg ],
		[ PRED quant_rel, ARG0 #x21, RSTR #h26 ],
		[ PRED #npred, LBL #h25, ARG0 #x21 ],
	        [ PRED #ppred2, LBL #h25, ARG1 #x21, ARG2 #x12 ] !>,
	  HCONS <! qeq & [ HARG #h20 ], qeq & [ HARG #h26 ], 
		   qeq & [ HARG #h12, LARG #h5 ], 
		   qeq & [ HARG #h13, LARG #h3 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED #ppred, LBL #h10, ARG1 #x1, ARG2 #x10,
		     ARG0 #e11 & [ E [ TENSE present, ASPECT.PRF - ] ] ],
		   [ PRED #ppred2, LBL #h1, ARG0 #e4, ARG1 #x10, ARG2 #x16 ],
		   [ PRED #cpred, LBL #h15 & handle, ARG0 #x16 & ref-ind, 
		     L-INDEX #x11 & ref-ind, R-INDEX #x12 ],
	           [ PRED udef_q_rel, LBL handle, ARG0 #x16,
		      RSTR #h21, BODY handle ] !>,
	   HCONS <! qeq & [ HARG #h21, LARG #h15 ] !> ] ].

;; A is between B and C or D and F
;;
shared_vp_threearg_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED named_rel, ARG0 #x1 & ref-ind, CARG #carg ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED conj_rel & #cpred, LBL #h10, ARG0 #e11, 
		    L-HNDL #h12, R-HNDL #h13 ],
	      [ PRED _between_p_rel, LBL #h5, ARG1 #x1, ARG2 #x10 ],
	      [ PRED _between_p_rel, LBL #h3, ARG1 #x2, ARG2 #x21 ],
	      [ PRED named_rel, ARG0 #x2 & ref-ind, CARG #carg ],
	      [ PRED quant_rel, ARG0 #x2, RSTR #h30 ] !>,
	  HCONS <! qeq & [ HARG #h12, LARG #h5 ], 
		   qeq & [ HARG #h13, LARG #h3 ],
		   qeq & [ HARG #h30 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED _between_p_rel, LBL #h10, ARG0 #e11, 
		     ARG1 #x1, ARG2 #x16 ],
		   [ PRED #cpred, LBL #h15 & handle, ARG0 #x16 & conj-ind, 
		     L-INDEX #x10 & conj-ind, R-INDEX #x21 & conj-ind ],
	           [ PRED udef_q_rel, LBL handle, ARG0 #x16,
		      RSTR #h21, BODY handle ] !>,
	   HCONS <! qeq & [ HARG #h21, LARG #h15 ] !> ],
  FLAGS.EQUAL < #x1 > ].

;; B is a cube or a tetrahedron
;;
shared_pred_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED named_rel, ARG0 ref-ind & #x1 ],
		  [ PRED "~._n_", ARG0 ref-ind & #x3 ],
		  [ PRED "~._n_", ARG0 ref-ind & #x4 ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED conj_rel & #cpred, LBL #h6, ARG0 #e9, 
		    L-INDEX #e5, R-INDEX #e6, L-HNDL individual ],
		  [ PRED #vpred, ARG0 event & #e5, ARG1 #x1, ARG2 #x3 ],
		  [ PRED #vpred, ARG0 event & #e6, ARG1 #x1, ARG2 #x4 ] !>,
	  HCONS <! !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED #vpred, LBL #h6, ARG1 #x1, ARG2 #x9,
		     ARG0 #e9 & [ E [ TENSE present, ASPECT.PRF - ] ] ],
		   [ PRED #cpred, LBL #h20, ARG0 #x9, L-INDEX #x3, R-INDEX #x4],
		   [ PRED udef_q_rel, LBL handle, ARG0 #x9 & ref-ind, 
		     RSTR #h21, BODY handle ] !>,
	   HCONS <! qeq & [ HARG #h21, LARG #h20 ] !> ] ].

;; "B and C are in the same row"
;;
and_same_op_mtr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED named_rel, LBL handle, ARG0 #x1 & ref-ind ],
                  [ PRED named_rel, LBL handle, ARG0 #x2 & ref-ind ] !>,
  FILTER.RELS <! [ PRED pron_rel ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS.LIST <  [ PRED "~._n_" & #pred, LBL #h30, ARG0 #x3 & ref-ind ],
		     [ PRED quant_rel & #qpred, LBL #h32, ARG0 #x3,
		       RSTR #h33, BODY #h34 ],
		     [ PRED "_same_a_as_rel", LBL #h31, ARG0 #e4, ARG1 #x3 ],
		     [ PRED comp_equal_rel, LBL #h6, ARG0 #e7, ARG1 #e4, 
		      ARG2 #x2 ], ... > ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS.LIST < [ PRED #pred, LBL #h30, ARG0 #x13 ],
		       [ PRED #qpred, LBL #h32, ARG0 #x13,RSTR #h33, BODY #h34],
		       [ PRED "_same_a_as_rel", LBL #h31, ARG0 #e4, ARG1 #x13 ],
		       [ PRED comp_equal_rel, LBL #h6, ARG0 #e7, ARG1 #e4 ],
		       [ PRED _and_c_rel, LBL #h7, 
			 ARG0 #x8 & ref-ind & [ PNG.PN 3p ], 
			 L-INDEX #x1, R-INDEX #x2 ],
		       [ PRED udef_q_rel, LBL handle, ARG0 #x8 & ref-ind, 
			 RSTR #h21, BODY handle ], ... >,
	   HCONS <! qeq & [ HARG #h21, LARG #h7 ] !> ] ].

and_same_loc_op_mtr := and_same_op_mtr &
[ CONTEXT.RELS <! [ ARG0 #x1 ], [ ] !>,
  INPUT.RELS <! [ ARG0 #x3 ], [ ], [ ], [ ],
	        [ PRED _in_p_rel, LBL #h5, ARG0 #e6, ARG1 #x1, ARG2 #x3 ] !>,
  OUTPUT.RELS <! [ ARG0 #x3 ], [ ], [ ], [ ], [ ARG0 #x8 ], [ ],
	         [ PRED _in_p_rel, LBL #h5, ARG0 #e6, ARG1 #x8, ARG2 #x3 ] !> ].
		   
and_same_size_op_mtr := and_same_op_mtr &
[ CONTEXT.RELS <! [ ARG0 #x1 ], [ ] !>,
  INPUT.RELS <! [ ARG0 #x3 ], [ ], [ ], [ ],
	        [ PRED _be_v_id_rel, LBL #h2, 
		  ARG0 event & #e4 & [ E.TENSE present ],
		  ARG1 #x1, ARG2 #x3 ] !>,
  OUTPUT.RELS <! [ ARG0 #x13 & ref-ind & [ PNG.PN 3p ] ], [ ], [ ], [ ],
	         [ ARG0 #x8 ], [ ],
	         [ PRED _be_v_id_rel, LBL #h2, ARG0 #e4, 
		   ARG1 #x8, ARG2 #x13 ] !> ].

;; "and" => "but"
;;
and_but_op_mtr := monotonic_mtr &
[ INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED _and_c_rel, LBL #h7, ARG0 #e8, L-INDEX #e6, 
		  R-INDEX #e4, L-HNDL handle & #h15, R-HNDL handle & #h11 ] !>],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED _but_c_rel, LBL #h7, ARG0 #e8, L-INDEX #e6, 
	           R-INDEX #e4, L-HNDL #h15, R-HNDL #h11  ] !> ] ].

and_neg_to_but_op_mtr := and_but_op_mtr &
[ CONTEXT [ RELS <! [ PRED neg_rel, LBL handle, ARG1 #h2 ],
		    [ LBL #h3, ARG0 #e4 & event ] !>,
  	    HCONS <! qeq & [ HARG #h2, LARG #h3 ] !> ],
  FILTER [ RELS <! [ PRED neg_rel, ARG1 #h20 ],
		   [ LBL #h21 & handle, ARG0 #e6 & event ] !>,
	   HCONS <! qeq & [ HARG #h20, LARG #h21 ] !> ],
  INPUT.RELS <! [ L-INDEX #e6, R-INDEX #e4 ] !> ].

;; A is larger than B but smaller than C.
;;
and_but_size_op_mtr := and_but_op_mtr &
[ CONTEXT.RELS <! [ ARG0 #e1 ], [ ARG0 #e2 ],
	          [ PRED comp_rel, ARG1 #e1 ],
		  [ PRED comp_rel, ARG1 #e2 ] !>,
  FILTER [ RELS <! [ PRED neg_rel, ARG1 #h1 ] !>,
	   HCONS <! qeq & [ HARG #h1 ] !> ],
  INPUT.RELS <! [ L-INDEX #e1, R-INDEX #e2 ] !> ].

;; B is in the same row as C but in the same column as D
;;
and_but_location_op_mtr := and_but_op_mtr &
[ CONTEXT.RELS <! [ ARG0 #e1 ], [ ARG0 #e2 ],
	          [ PRED prep_rel, ARG0 #e1 ],
		  [ PRED prep_rel, LBL #h2 & handle, ARG0 #e2 ] !>,
  FILTER [ RELS <! [ PRED neg_rel, ARG1 #h1 ] !>,
	   HCONS <! qeq & [ HARG #h1, LARG #h2 ] !> ],
  INPUT.RELS <! [ L-INDEX #e1, R-INDEX #e2 ] !> ].

and_but_front_back_op_mtr := and_but_op_mtr &
[ CONTEXT.RELS <! [ PRED prep_rel, ARG0 #e1, ARG2 #x3 ], 
		  [ PRED prep_rel, ARG0 #e2 ],
	          [ PRED named_rel, ARG0 #x3 ] !>,
  FILTER [ RELS <! [ PRED neg_rel, ARG1 #h1 ] !>,
	   HCONS <! qeq & [ HARG #h1 ] !> ],
  INPUT.RELS <! [ L-INDEX #e1, R-INDEX #e2 ] !> ].


;; "not" + "or" => "nor"
;;
neg_or_to_nor_op_mtr := monotonic_omtr &
[ INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED neg_rel, LBL #h1, ARG1 #h2 ],
		  [ PRED _or_c_rel, LBL #h7, ARG0 #e8, L-INDEX #e6 & event, 
		    R-INDEX #e4 & event, L-HNDL #h3 & handle, 
		    R-HNDL #h4 & handle ] !>,
  	  HCONS <! qeq & [ HARG #h2, LARG #h7 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED _nor_c_rel, LBL #h1, ARG0 #e8, L-INDEX #e6, 
		     R-INDEX #e4, L-HNDL #h3, R-HNDL #h4 ]!>,
	   HCONS <! !> ] ].

;; "it is not the case that ..."
;; 
not_the_case_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED neg_rel, ARG1 #h2 & handle ],
		  [ LBL #h3, ARG0.E.TENSE present ] !>,
  FILTER.RELS <! [ PRED conj_rel, L-INDEX event, L-HNDL #h20 ],
	         [ LBL #h20, ARG1 #x12 & ref-ind ],
	         [ ARG1 #x12 ] !>,
  INPUT [ HOOK.INDEX #index,
	  HCONS <! qeq & [ HARG #h2, LARG #h3 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED "_the+case_a_1_rel", LBL #h4 & handle, 
		     ARG0 event & [ E.TENSE untensed ],
		     ARG1 #h5 & handle ] !>,
	   HCONS <! qeq & [ HARG #h2, LARG #h4 ],
		    qeq & [ HARG #h5, LARG #h3 ] !> ] ].

;; "to the right or to the left of"
;;
shared_ppof_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED _to_p_rel, ARG1 #x1, ARG2 #x2 ],
		  [ LBL #h1, ARG0 #x2 ],
		  [ LBL #h1, PRED _of_p_rel, ARG1 #x2, ARG2 #x3 ],
		  [ PRED named_rel, ARG0 #x3, CARG #carg ],
		  [ PRED _to_p_rel, ARG1 #x1, ARG2 #x5 ],
		  [ PRED "~._n_", LBL #h6, ARG0 #x5 ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ LBL #h6, PRED _of_p_rel, ARG1 #x5, ARG2 #x7 ],
		  [ PRED named_rel, ARG0 #x7, CARG #carg ],
	          [ PRED quant_rel, ARG0 #x7, RSTR #h8 ] !>,
	  HCONS <! qeq & [ HARG #h8 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! !>,
	   HCONS <! !> ] ].

;; "to the right or left of"
;;
shared_to_the_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED "~._n_", LBL handle, ARG0 #x2 ],
		  [ PRED "~._n_", LBL #h6, ARG0 #x5 ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED conj_rel & #cpred2, LBL #h10, ARG0 #e11, 
		    L-INDEX #e12 & event, R-INDEX #e13 & event,
		    L-HNDL #h20, R-HNDL #h21 ],
		  [ PRED _to_p_rel, ARG0 #e12, ARG1 #x1, ARG2 #x2 ],
		  [ PRED _to_p_rel, ARG0 #e13, ARG1 #x1, ARG2 #x5 ],
		  [ PRED _the_q_rel, LBL #h7, ARG0 #x2, RSTR #h8, BODY #h9 ],
		  [ PRED _of_p_rel, LBL #h6, ARG0 #e8, ARG1 #x5, ARG2 #x3 ],
		  [ PRED quant_rel, LBL #h17, ARG0 #x5, RSTR #h18, BODY #h19]!>,
	  HCONS <! qeq & [ HARG #h20 ], qeq & [ HARG #h21 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED conj_rel & #cpred2, LBL #h14, ARG0 #x15 & ref-ind, 
		    L-INDEX #x2, R-INDEX #x5 ],
		   [ PRED _to_p_rel, LBL #h10, ARG1 #x1, ARG2 #x15, ARG0 #e11 & 
		     [ E [ ASPECT [ PRF - ], TENSE present ], SF prop ] ],
		   [ PRED _of_p_rel, LBL #h14, ARG0 #e8, ARG1 #x15, ARG2 #x3 ],
		   [ PRED _the_q_rel, LBL #h7, ARG0 #x15, RSTR #h16, BODY #h9],
		   [ PRED udef_q_rel, LBL #h17, ARG0 #x5, RSTR #h18, BODY #h19],
		   [ PRED udef_q_rel, LBL handle, ARG0 #x2, RSTR #h8, 
		     BODY handle ] !>,
	   HCONS <! qeq & [ HARG #h16, LARG #h14 ] !> ] ].

;; Coord and-S with semicolon + moreover
;;
coord_sent_semi_op_gpr := monotonic_omtr &
[ FILTER [ HCONS <! qeq & [ LARG #h14 ] !> ],
  CONTEXT [ RELS <! [ LBL #h10 & handle, ARG0 event & [ E.TENSE present ] ] !>,
	    HCONS <! qeq & [ HARG #h22 & handle, LARG #h10 ] !> ],
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED conj_rel, LBL handle & #h14, ARG0 #e10 & event, 
		  L-INDEX #e2 & event, R-INDEX #e5 & event, 
		  L-HNDL #h21 & handle, R-HNDL #h22 & handle ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED implicit_conj_rel, LBL handle & #h14, ARG0 #e10, 
		     L-INDEX #e2, R-INDEX #e5, L-HNDL #h21, 
		     R-HNDL #h4 & handle ],
	           [ LBL #h5 & handle, 
		     ARG0 event & [ E.TENSE untensed ], ARG1 #h22 ] !>,
	   HCONS <! qeq & [ HARG #h4, LARG #h5 ] !> ],
  FLAGS.EQUAL < #e2, #e5, #e10 > ].


;; "if-then" to "only if"
;;
if_then_to_only_if_gpr := monotonic_omtr &
[ FILTER.RELS <! [ PRED "_if_x_then_rel", LBL #h12 ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED "_if_x_then_rel", LBL #h1, ARG0 #e2, 
		    ARG1 #h7, ARG2 #h8 ],
		  [ PRED "_then_a_1_rel", LBL #h10, ARG1 #h11 ] !>,
	  HCONS <! qeq & [ HARG #h7, LARG #h10 ],
		   qeq & [ HARG #h11, LARG #h12 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ LBL #h1, ARG0 #e2, 
		    ARG1 #h8, ARG2 #h7 ] !>,
	   HCONS <! qeq & [ HARG #h7, LARG #h12 ] !> ],
  FLAGS.EQUAL < > ].

if_not_to_unless_gpr := monotonic_omtr &
[ INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED "_if_x_then_rel", LBL #h1, ARG0 #e2, ARG1 #h7 & handle,
		    ARG2 #h8 & handle ],
		  [ PRED "_then_a_1_rel", LBL #h10, ARG1 #h11 ],
		  [ PRED neg_rel, LBL #h13, ARG1 #h14 ] !>,
	  HCONS <! qeq & [ HARG #h7, LARG #h10 ],
		   qeq & [ HARG #h11, LARG #h12 ],
		   qeq & [ HARG #h8, LARG #h13 ],
		   qeq & [ HARG #h14, LARG #h15 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED "_unless_x_rel", LBL #h1, ARG0 #e2, ARG1 #h7, ARG2 #h8 ] !>,
	   HCONS <! qeq & [ HARG #h7, LARG #h12 ],
		    qeq & [ HARG #h8, LARG #h15 ] !> ],
  FLAGS.EQUAL < #h7, #h8 > ].

;; "iff" to "just in case"
;;
iff_to_just_in_case_gpr := monotonic_omtr &
[ INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED "_if+and+only+if_x_1_rel", LBL #h1 & handle, 
		  ARG0 #e2 & event, ARG1 #h7 & handle, ARG2 #h8 & handle ] !>],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED "_in+case_x_rel", LBL #h1, 
		   ARG0 #e2, ARG1 #h7, ARG2 #h8 ],
		 [ PRED "_just_x_deg_rel", LBL #h1, 
		   ARG0 event & [ E.TENSE untensed ], ARG1 #e2 ] !> ],
  FLAGS.EQUAL < > ].

;; "B is a large cube"
;;
basic_adj_and_predn_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED "~._n_", LBL #h6 & handle, ARG0 #x1 & ref-ind ],
		  [ PRED named_rel, ARG0 #x5, CARG #carg ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED "~._a_" & #apred, LBL handle, 
		    ARG0 event & [ E.TENSE tense ], ARG1 #x2 ],
		  [ PRED "~._v_" & #vpred, LBL handle, 
		    ARG0 event & [ E.TENSE tense ], ARG1 #x5, ARG2 #x1 ],
		  [ PRED _and_c_rel, LBL #h14, ARG0 #e2 & event,
		    L-INDEX event, R-INDEX event, L-HNDL #h10, R-HNDL #h11 ],
		  [ PRED named_rel, ARG0 #x2, CARG #carg ],
		  [ PRED proper_q_rel, ARG0 #x2, RSTR #h13 ] !>,
	  HCONS <! qeq & [ HARG #h10 ], qeq & [ HARG #h11 ], 
		   qeq & [ HARG #h13 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED #apred, LBL #h6, ARG0 event & [ E.TENSE untensed ],
		   ARG1 #x1 ], 
	         [ PRED #vpred, LBL #h14, 
		   ARG0 #e2 & [ E [ TENSE present, ASPECT.PRF - ] ],
		   ARG1 #x5, ARG2 #x1 ] !> ],
  FLAGS.EQUAL < #x1 > ].

adj_and_predn_gpr := basic_adj_and_predn_gpr &
[ INPUT.RELS <! [ ARG0 #e1 & event ], [ ARG0 #e2 & event ], 
	        [ L-INDEX #e1, R-INDEX #e2 ], [ ], [ ] !> ].

predn_and_adj_gpr := basic_adj_and_predn_gpr &
[ INPUT.RELS <! [ ARG0 #e2 & event ], [ ARG0 #e1 & event ], 
	        [ L-INDEX #e1, R-INDEX #e2 ], [ ], [ ] !> ].


basic_vp_ellipsis_gpr := monotonic_omtr &
[ CONTEXT.RELS.LIST < [ PRED #pred, ARG0 event ], ...>,
  FILTER.RELS <! [ PRED comp_rel, LBL #h1 ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS.LIST < [ PRED #pred, LBL #h1 & handle, ARG0 #e2 & event, 
			ARG1 #x3 & ref-ind ], ... > ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED ellipsis_ref_rel, LBL #h1, ARG0 #e2, ARG1 #x3 ] !> ]].

vp_ellipsis_if_pos_gpr := basic_vp_ellipsis_gpr &
[ CONTEXT [ RELS.LIST < [ LBL #h1 ], 
		    [ PRED "_if_x_then_rel", ARG1 #h2, ARG2 #h3 ],
		    [ PRED "_then_a_1_rel", LBL #h5, ARG1 #h6 ], ... >,
	    HCONS <! qeq & [ HARG #h2, LARG #h5 ], qeq & [ HARG #h6, LARG #h4 ],
		     qeq & [ HARG #h3, LARG #h1 ] !> ],
  INPUT.RELS.LIST < [ LBL #h4 ], ... > ].

vp_ellipsis_if_pos_onearg_gpr := vp_ellipsis_if_pos_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ] !>,
  INPUT [ RELS <! [ ARG2 handle ] !>,
	  HCONS <! !> ] ].

vp_ellipsis_if_neg_gpr := basic_vp_ellipsis_gpr &
[ CONTEXT [ RELS.LIST < [ LBL #h1 ], 
		    [ PRED "_if_x_then_rel", ARG1 #h2, ARG2 #h3 ],
		    [ PRED "_then_a_1_rel", LBL #h5, ARG1 #h6 ],
		    [ PRED neg_rel, LBL #h7, ARG1 #h8 ], ... >,
	    HCONS <! qeq & [ HARG #h2, LARG #h5 ], qeq & [ HARG #h6, LARG #h7 ],
		     qeq & [ HARG #h8, LARG #h4 ],
		     qeq & [ HARG #h3, LARG #h1 ] !> ],
  INPUT.RELS.LIST < [ LBL #h4 ], ... > ].

vp_ellipsis_if_neg_onearg_gpr := vp_ellipsis_if_neg_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ] !>,
  INPUT [ RELS <! [ ARG2 handle ] !>,
	  HCONS <! !> ] ].

vp_ellipsis_twoarg_gpr := basic_vp_ellipsis_gpr &
[ INPUT [ RELS.LIST < [ ARG2 #x10 ],
		      [ LBL #h9 & handle, ARG0 #x10 ], 
		      [ PRED quant_rel, ARG0 #x10, RSTR #h11 & handle ], ... >,
	  HCONS.LIST < qeq & [ HARG #h11, LARG #h9 ], ...  > ] ].

vp_ellipsis_if_pos_twoarg_comp_gpr := vp_ellipsis_if_pos_gpr & 
			  	      vp_ellipsis_twoarg_gpr &
[ CONTEXT.RELS <! [ LBL #h1 ], [ ], [ ], 
                  [ PRED #pred, ARG0 #x1 & ref-ind, CARG #carg ],
		  [ PRED quant_rel, ARG0 #x1 ],
		  [ PRED comp_rel, LBL #h1, ARG2 #x1 ] !>,
  INPUT [ RELS <! [ LBL #h2 ], [ PRED #pred, ARG0 #x3, CARG #carg ], [ ],
		  [ PRED comp_rel, LBL #h2, ARG2 #x3 ] !>,
	  HCONS <! qeq !> ] ].

vp_ellipsis_if_pos_twoarg_gpr := vp_ellipsis_if_pos_gpr & 
				 vp_ellipsis_twoarg_gpr &
[ CONTEXT.RELS <! [ ARG2 #x1 ], [ ], [ ], 
                  [ PRED #pred, ARG0 #x1 & ref-ind ],
		  [ PRED quant_rel, ARG0 #x1 ] !>,
  INPUT [ RELS.LIST < [ ], [ PRED #pred ], ... >,
	  HCONS <! qeq !> ] ].

vp_ellipsis_if_neg_twoarg_gpr := vp_ellipsis_if_neg_gpr &
				 vp_ellipsis_twoarg_gpr &
[ CONTEXT.RELS <! [ ARG2 #x1 ], [ ], [ ], [ ], 
                  [ PRED #pred, ARG0 #x1 & ref-ind ],
		  [ PRED quant_rel, ARG0 #x1 ] !>,
  INPUT [ RELS.LIST < [ ], [ PRED #pred ], ... >,
	  HCONS <! qeq !> ] ].

;; VP ellipsis with iff
;;
vp_ellipsis_iff_pos_gpr := basic_vp_ellipsis_gpr &
[ CONTEXT [ RELS.LIST < [ LBL #h1 ], 
		  [ PRED "_if+and+only+if_x_1_rel", ARG1 #h2, ARG2 #h3 ], ... >,
	    HCONS <! qeq & [ HARG #h2, LARG #h1 ],
		     qeq & [ HARG #h3, LARG #h4 ] !> ],
  INPUT.RELS.LIST < [ LBL #h4 ], ... > ].

vp_ellipsis_iff_pos_onearg_gpr := vp_ellipsis_iff_pos_gpr &
[ CONTEXT.RELS <! [ ], [ ] !>,
  INPUT [ RELS <! [ ARG2 handle ] !>,
	  HCONS <! !> ] ].

vp_ellipsis_iff_neg_gpr := basic_vp_ellipsis_gpr &
[ CONTEXT [ RELS.LIST < [ LBL #h1 ], 
		    [ PRED "_if+and+only+if_x_1_rel", ARG1 #h2, ARG2 #h3 ],
		    [ PRED neg_rel, LBL #h7, ARG1 #h8 ], ... >,
	    HCONS <! qeq & [ HARG #h2, LARG #h1 ],
		     qeq & [ HARG #h8, LARG #h4 ],
		     qeq & [ HARG #h3, LARG #h7 ] !> ],
  INPUT.RELS.LIST < [ LBL #h4 ], ... > ].

vp_ellipsis_iff_neg_onearg_gpr := vp_ellipsis_iff_neg_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ] !>,
  INPUT [ RELS <! [ ARG2 handle ] !>,
	  HCONS <! !> ] ].

vp_ellipsis_iff_pos_twoarg_comp_gpr := vp_ellipsis_iff_pos_gpr & 
			  	      vp_ellipsis_twoarg_gpr &
[ CONTEXT.RELS <! [ LBL #h1 ], [ ],
                  [ PRED #pred, ARG0 #x1 & ref-ind, CARG #carg ],
		  [ PRED quant_rel, ARG0 #x1 ],
		  [ PRED comp_rel, LBL #h1, ARG2 #x1 ] !>,
  INPUT [ RELS <! [ LBL #h2 ], [ PRED #pred, ARG0 #x3, CARG #carg ], [ ],
	          [ PRED comp_rel, LBL #h2, ARG2 #x3 ] !>,
	  HCONS <! qeq !> ] ].

vp_ellipsis_iff_pos_twoarg_gpr := vp_ellipsis_iff_pos_gpr & 
				 vp_ellipsis_twoarg_gpr &
[ CONTEXT.RELS <! [ ARG2 #x1 ], [ ],
                  [ PRED #pred, ARG0 #x1 & ref-ind ],
		  [ PRED quant_rel, ARG0 #x1 ] !>,
  INPUT [ RELS <! [ ], [ PRED #pred ], [ ] !>,
	  HCONS <! qeq !> ],
  FLAGS.EQUAL < #x1 > ].

vp_ellipsis_iff_neg_twoarg_gpr := vp_ellipsis_iff_neg_gpr &
				 vp_ellipsis_twoarg_gpr &
[ CONTEXT.RELS <! [ ARG2 #x1 ], [ ], [ ],
                  [ PRED #pred, ARG0 #x1 & ref-ind ],
		  [ PRED quant_rel, ARG0 #x1 ] !>,
  INPUT [ RELS <! [ ], [ PRED #pred ], [ ] !>,
	  HCONS <! qeq !> ] ].


vp_ellipsis_coord_pos_gpr := basic_vp_ellipsis_gpr &
[ CONTEXT [ RELS.LIST < [ LBL #h1 & handle, ARG0 #e6 ], 
    		        [ PRED conj_rel, LBL handle, L-INDEX #e6,
			  R-INDEX #e7,
			  L-HNDL #h2 & handle, R-HNDL #h3 & handle ], ... >,
	    HCONS.LIST < qeq & [ HARG #h2, LARG #h1 ], 
	                 qeq & [ HARG #h3, LARG #h4 ], ... > ],
  INPUT.RELS.LIST < [ LBL #h4 & handle, ARG0 #e7 ], ... > ].

;; The [ ARG2 handle ] is a hack to prevent this rule from applying to two-args.
;;
vp_ellipsis_coord_pos_onearg_gpr := vp_ellipsis_coord_pos_gpr &
[ CONTEXT [ RELS <! [ ARG2 handle ], [ ] !>,
            HCONS <! [ ], [ ] !> ],
  INPUT [ RELS <! [ ] !>,
          HCONS <! !> ] ].

basic_vp_ellipsis_coord_pos_twoarg_gpr := vp_ellipsis_coord_pos_gpr &
					  vp_ellipsis_twoarg_gpr &
[ CONTEXT [ RELS.LIST < [ ARG0.E.TENSE present, ARG1 ref-ind, 
			  ARG2 #x1 & ref-ind ],
			[ ], 
			[ PRED #pred, LBL #h5, ARG0 #x1 & ref-ind ],
			[ PRED quant_rel, ARG0 #x1, RSTR #h4 ], ... >,
	    HCONS <! qeq, qeq, qeq & [ HARG #h4, LARG #h5 ] !> ],
  INPUT.RELS.LIST < [ ARG0.E.TENSE present ], 
		    [ PRED #pred ], ... >,
  OUTPUT.HCONS <! !> ].

;; "B is a cube, and C is"
vp_ellipsis_coord_pos_twoarg_gpr := basic_vp_ellipsis_coord_pos_twoarg_gpr &
[ CONTEXT.RELS <! [ ], [ ], [ ], [ ] !>,
  INPUT [ RELS <! [ ], [ PRED "~._n_" ], [ ] !>,
	  HCONS <! qeq !> ] ].

;; "B is between C and D, and F is"
vp_ellipsis_coord_pos_twoconj_gpr := basic_vp_ellipsis_coord_pos_twoarg_gpr &
[ CONTEXT.RELS <! [ PRED _between_p_rel ], [ ], 
		  [ ARG0 conj_ref-ind, L-INDEX #x11, R-INDEX #x12 ], [ ],
		  [ PRED named_rel, ARG0 #x11, CARG #carg1 ],
		  [ PRED named_rel, ARG0 #x12, CARG #carg2 ] !>,
  INPUT [ RELS <! [ ], [ ARG0 conj_ref-ind, L-INDEX #x1, R-INDEX #x2 ], [ ],
		  [ ARG0 #x1 & ref-ind, CARG #carg1 ], 
	          [ PRED quant_rel, ARG0 #x1, RSTR #h10 ],
	          [ ARG0 #x2 & ref-ind, CARG #carg2 ], 
	          [ PRED quant_rel, ARG0 #x2, RSTR #h11 ] !>,
	  HCONS <! qeq, qeq & [ HARG #h10 ], qeq & [ HARG #h11 ] !> ] ].

;; Convert [A and [B and C]] to [[A and B] and C]
rebracket_coord_gpr := monotonic_omtr &
[ CONTEXT [ RELS <! [ LBL #h1, ARG0 event ], [ LBL #h2, ARG0 #e11 & event ] !>,
	    HCONS <! qeq & [ HARG #h7, LARG #h1 ],
		     qeq & [ HARG #h13, LARG #h2 ] !> ],
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED conj_rel & #pred1, LBL #h3, ARG0 #e4 & event, 
		    L-INDEX #e5 & event, R-INDEX #e10 & event, L-HNDL #h7, 
		    R-HNDL #h8 ],
                  [ PRED conj_rel & #pred2, LBL #h9, ARG0 #e10 & event, 
		    L-INDEX #e11 & event, R-INDEX #e12 & event, 
		    L-HNDL #h13, R-HNDL #h14 ] !>,
          HCONS <! qeq & [ HARG #h8, LARG #h9 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED conj_rel & #pred1, LBL #h9, ARG0 #e10, L-INDEX #e5, 
		     R-INDEX #e11, L-HNDL #h7, R-HNDL #h13 ],
                  [ PRED conj_rel & #pred2, LBL #h3, ARG0 #e4, L-INDEX #e10, 
		    R-INDEX #e12, L-HNDL #h20, R-HNDL #h14 ] !>,
           HCONS <! qeq & [ HARG #h20, LARG #h9 ] !> ],
  FLAGS.EQUAL < #e5, #e10 > ].

;; Drop `then' for non-coord consequent
drop_cond_then_mtr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED "_if_x_then_rel", ARG1 #h1 ],
	          [ LBL #h2, ARG0.E.TENSE present, ARG1 #x6 ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED "_then_a_1_rel", LBL #h3, ARG1 #h4 ] !>,
	  HCONS <! qeq & [ HARG #h1, LARG #h3 ],
		   qeq & [ HARG #h4, LARG #h2 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! !>,
  	   HCONS <! qeq & [ HARG #h1, LARG #h2 ] !> ],
  FLAGS.SUBSUME < #x6 > ].

;; "at least one of" for "A or B or C"
;;
basic_at_least_one_mtr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED implicit_conj_rel, ARG0 #x2 & ref-ind, R-INDEX #x1] !>,
  FILTER.RELS <! [ PRED part_of_rel ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED #pred, LBL #h3, ARG0 #e4 & event, ARG1 #x2, ARG2 #i2 ],
	        [ PRED _or_c_rel, LBL #h20, ARG0 #x1, L-INDEX #x15, 
		  R-INDEX #x16 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED #pred, LBL #h3, ARG0 #e4, 
		     ARG1 #x10 & ref-ind, ARG2 #i2 ],
		   [ PRED "_at+least_x_deg_rel", LBL #h11, 
		     ARG0.E.TENSE untensed, ARG1 semarg ],
		   [ PRED udef_q_rel, LBL #h11, ARG0 #x10, 
		     RSTR handle & #h12, BODY handle ],
		   [ PRED part_of_rel, LBL #h13, ARG0 #x10, ARG1 #x2 ],
		   [ PRED card_rel, LBL #h13, ARG0 event,
		     ARG1 #x10, CARG "1" ],
		   [ PRED _and_c_rel, LBL #h20, ARG0 #x1, 
		     L-INDEX #x15, R-INDEX #x16 ] !>,
	   HCONS <! qeq & [ HARG #h12, LARG #h13 ] !> ] ].

at_least_one_twoarg_mtr := basic_at_least_one_mtr &
[ INPUT.RELS <! [ ARG2 #x1 & ref-ind ], [ ] !>,
  OUTPUT.RELS.LIST < [ ARG2 #x1 ], ... >,
  FLAGS.SUBSUME < #x1 > ].

at_least_one_onearg_mtr := basic_at_least_one_mtr &
[ INPUT.RELS <! [ ARG2 handle ], [ ] !>,
  FLAGS.SUBSUME < > ].

;; "either B or C isn't" => "neither is"
either_neither_mtr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED conj_rel, R-INDEX #e1 ],
	          [ LBL #h2, ARG0 event & #e1, ARG1 #x2 & ref-ind ] !>,
  FILTER.RELS <! [ PRED "_the+case_a_1_rel" ] !>,
  INPUT [ HOOK.INDEX #index,
	  RELS <! [ PRED _or_c_rel, ARG0 #x2, L-INDEX #x3, R-INDEX #x4 ],
		  [ PRED udef_q_rel, ARG0 #x2, RSTR #h13 ],
		  [ PRED named_rel, ARG0 #x3 ],
		  [ PRED quant_rel, ARG0 #x3, RSTR #h5 ],
		  [ PRED named_rel, ARG0 #x4 ],
		  [ PRED quant_rel, ARG0 #x4, RSTR #h6 ],
		  [ PRED neg_rel, LBL #h10, ARG1 #h11 ] !>,
	  HCONS <! qeq & [ HARG #h5 ], qeq & [ HARG #h6 ], qeq & [ HARG #h13 ],
		   qeq & [ HARG #20, LARG #h10 ], 
		   qeq & [ HARG #h11, LARG #h2 ] !> ],
  OUTPUT [ HOOK.INDEX #index,
	   RELS <! [ PRED generic_entity_rel, LBL #h7, ARG0 #x2 & [ PNG.PN 3s]],
		   [ PRED _neither_q_rel, LBL handle, ARG0 #x2, RSTR #h8 ]!>,
  	   HCONS <! qeq & [ HARG #h8, LARG #h7 ],
		    qeq & [ HARG #20, LARG #h2 ] !> ] ].
