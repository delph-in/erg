a_parens_np := never_unify_le & [].
b_parens_np := never_unify_le & [].
c_parens_np := never_unify_le & [].
d_parens_np := never_unify_le & [].
b_period_np1 := never_unify_le & [].
c_period_np1 := never_unify_le & [].
d_period_np1 := never_unify_le & [].
e_period_np1 := never_unify_le & [].
f_period_np1 := never_unify_le & [].
d_comma_np1 := never_unify_le & [].
d_period_comma_np1 := never_unify_le & [].
r_comma_np1 := never_unify_le & [].
r_period_comma_np1 := never_unify_le & [].
also_root := never_unify_le & [].
also_adv2 := never_unify_le & [].
as_if_c := never_unify_le & [].
as_though_c := never_unify_le & [].
;be_c_is_neg_1 := never_unify_le & [].
;be_c_are_neg_1 := never_unify_le & [].
be_c_am := never_unify_le & [].
be_c_am_neg_1 := never_unify_le & [].
be_c_be := never_unify_le & [].
be_c_being := never_unify_le & [].
be_c_been := never_unify_le & [].
be_c_was := never_unify_le & [].
be_c_was_neg_1 := never_unify_le & [].
be_c_was_subj := never_unify_le & [].
be_c_was_neg_subj_1 := never_unify_le & [].
be_c_were := never_unify_le & [].
be_c_were_neg_1 := never_unify_le & [].
be_c_were_neg_subj_1 := never_unify_le & [].
be_c_were_subj := never_unify_le & [].
be_id_am := never_unify_le & [].
be_id_am_cx_2 := never_unify_le & [].
be_id_am_neg_1 := never_unify_le & [].
be_id_be := never_unify_le & [].
be_id_been := never_unify_le & [].
be_id_being := never_unify_le & [].
be_id_was := never_unify_le & [].
be_id_was_neg_1 := never_unify_le & [].
be_id_was_neg_subj_1 := never_unify_le & [].
be_id_was_subj := never_unify_le & [].
be_id_were := never_unify_le & [].
be_id_were_neg_1 := never_unify_le & [].
be_id_were_neg_subj_1 := never_unify_le & [].
be_id_were_subj := never_unify_le & [].
be_inv_are_cx := never_unify_le & [].
be_it_cop_been := never_unify_le & [].
be_it_cop_being := never_unify_le & [].
be_it_cop_was := never_unify_le & [].
be_it_cop_was_subj := never_unify_le & [].
by_pass_p := never_unify_le & [].
did1_neg_1 := never_unify_le & [].
do1_pos := never_unify_le & [].
does1_pos := never_unify_le & [].
do1_neg_1 := never_unify_le & [].
does1_neg_1 := never_unify_le & [].
did1_neg_1 := never_unify_le & [].
either_adv1 := never_unify_le & [].
for_c := never_unify_le & [].
for_prtcl := never_unify_le & [].
had_aux := never_unify_le & [].
had_aux_subj := never_unify_le & [].
has_aux := never_unify_le & [].
hasnt_aux_1 := never_unify_le & [].
have_aux_prp := never_unify_le & [].
have_bse_aux := never_unify_le & [].
have_fin_aux := never_unify_le & [].
have_fin_aux_neg_1 := never_unify_le & [].
however_adv2 := never_unify_le & [].
i_e_p1 := never_unify_le & [].
i_e_p2 := never_unify_le & [].
i_e_p3 := never_unify_le & [].
i_e_p4 := never_unify_le & [].
i_e_p5 := never_unify_le & [].
i_e_p6 := never_unify_le & [].
i_e_p7 := never_unify_le & [].
itself := never_unify_le & [].
like_c := never_unify_le & [].
medium_n1 := never_unify_le & [].
moreover_1 := never_unify_le & [].
moreover_root_post := never_unify_le & [].
provided_that_subord2 := never_unify_le & [].
themselves := never_unify_le & [].
themselves_adv := never_unify_le & [].
then_adv2 := never_unify_le & [].
then_adv4 := never_unify_le & [].
then_amod_adv1 := never_unify_le & [].
then_disc_post := never_unify_le & [].
will_aux_inv := never_unify_le & [].
will_aux_neg_1 := never_unify_le & [].
will_aux_pos := never_unify_le & [].

a_period_np1 := n_-_pn-neut_le &
 [ ORTH < "A" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE real_case,
	    LKEYS.KEYREL.CARG "A",
            PHON.ONSET voc ] ].

b_lower_np1 := n_-_pn-neut_le &
 [ ORTH < "B" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE real_case,
	    LKEYS.KEYREL.CARG "B",
            PHON.ONSET con ] ].

c_lower_np1 := n_-_pn-neut_le &
 [ ORTH < "C" >,
   SYNSEM [ LOCAL [ AGR.PNG.PN 3s,
		    CAT.HEAD.CASE real_case ],
            LKEYS.KEYREL.CARG "C",
            PHON.ONSET con ] ].

d_lower_np1 := n_-_pn-neut_le &
 [ ORTH < "D" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE real_case,
	    LKEYS.KEYREL.CARG "D",
            PHON.ONSET con ] ].

e_lower_np1 := n_-_pn-neut_le &
 [ ORTH < "E" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE real_case,
	    LKEYS.KEYREL.CARG "E",
            PHON.ONSET voc ] ].

f_lower_np1 := n_-_pn-neut_le &
 [ ORTH < "F" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE real_case,
	    LKEYS.KEYREL.CARG "F",
            PHON.ONSET voc ] ].

a_proper_rp_np1 := n_-_pn-neut_le &
 [ ORTH < "A)" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE no_case,
	    LKEYS.KEYREL.CARG "A",
            PHON.ONSET voc ] ].

b_lower_rp_np1 := n_-_pn-neut_le &
 [ ORTH < "B)" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE no_case,
	    LKEYS.KEYREL.CARG "B",
            PHON.ONSET con ] ].

c_lower_rp_np1 := n_-_pn-neut_le &
 [ ORTH < "C)" >,
   SYNSEM [ LOCAL [ CAT.HEAD.CASE no_case,
		    AGR.PNG.PN 3s ],
            LKEYS.KEYREL.CARG "C",
            PHON.ONSET con ] ].

d_lower_rp_np1 := n_-_pn-neut_le &
 [ ORTH < "D)" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE no_case,
	    LKEYS.KEYREL.CARG "D",
            PHON.ONSET con ] ].

e_lower_rp_np1 := n_-_pn-neut_le &
 [ ORTH < "E)" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE no_case,
	    LKEYS.KEYREL.CARG "E",
            PHON.ONSET voc ] ].

f_lower_rp_np1 := n_-_pn-neut_le &
 [ ORTH < "F)" >,
   SYNSEM [ LOCAL.CAT.HEAD.CASE no_case,
	    LKEYS.KEYREL.CARG "F",
            PHON.ONSET voc ] ].

also_adv1 := av_-_i-vp-x-only_le &
 [ ORTH < "also" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_also_a_1_rel",
            PHON.ONSET voc ] ].

be_c_is_cx_2 := v_prd_is-cx_le &
 [ ORTH < "'s" >,
   SYNSEM [ LOCAL.CAT.VAL.SUBJ.FIRST [ LOCAL [ CAT.HEAD partn &
							[ MINORS.MIN pron_rel ],
					      CONT.HOOK.INDEX non_conj_sement ],
				       LEX +,
				       MODIFD notmod ],
	    PHON.ONSET con ] ].

be_id_is_cx_2 := v_np_is-cx_le &
 [ ORTH < "'s" >,
   SYNSEM [ LOCAL.CAT.VAL [ SUBJ.FIRST [ LOCAL [ CAT.HEAD partn &
							[ MINORS.MIN pron_rel ],
					       CONT.HOOK.INDEX nonconj_ref-ind],
					 LEX +,
					 MODIFD notmod ],
			    COMPS.FIRST.--SIND.PNG.PN 3s ],
	    PHON.ONSET con ] ].

between := p_np_i_le &
 [ ORTH < "between" >,
   SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONJ.LCHEAD 
                                                    either_or_neither_or_cnil,
            LKEYS.KEYREL.PRED _between_p_rel,
            PHON.ONSET con ] ].

in_case := p_cp_s_le &
 [ ORTH < "in", "case" >,
   SYNSEM [ LOCAL.CAT [ POSTHD +,
			HEAD.MOD < [ PUNCT.RPUNCT no_punct ] > ],
            LKEYS.KEYREL.PRED "_in+case_x_rel",
            PHON.ONSET voc ] ].

be_id_are := v_np_are_le &
 [ ORTH < "are" >,
   SYNSEM [ LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.AGR.PNG.PN #pn,
                            COMPS.FIRST.LOCAL.AGR.PNG.PN #pn ],
	    PHON.ONSET voc ] ].

be_id_are_neg_1 := v_np_are-n_le &
 [ ORTH < "aren't" >,
   SYNSEM [ LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.AGR.PNG.PN #pn,
                            COMPS.FIRST.LOCAL.AGR.PNG.PN #pn ],
            PHON.ONSET voc ] ].

be_id_is := v_np_is_le &
 [ ORTH < "is" >,
   SYNSEM [ LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.AGR.PNG.PN #pn,
                            COMPS.FIRST.LOCAL.AGR.PNG.PN #pn ],
	    PHON.ONSET voc ] ].

be_id_is_cx := v_np_is-cx_le &
 [ ORTH < "s" >,
   SYNSEM [ LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.AGR.PNG.PN #pn,
                            COMPS.FIRST.LOCAL.AGR.PNG.PN #pn ],
	    PHON.ONSET voc ] ].

be_id_is_neg_1 := v_np_is-n_le &
 [ ORTH < "isn't" >,
   SYNSEM [ LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.AGR.PNG.PN #pn,
                            COMPS.FIRST.LOCAL.AGR.PNG.PN #pn ],
	    PHON.ONSET voc ] ].

fact_n2 := n_cp_c-optc_le &
 [ ORTH < "fact" >,
   SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD comp,
            LKEYS.KEYREL.PRED "_fact_n_1_rel",
            PHON.ONSET con ] ].

#|
if_subconj_unspec := p_cp_s-unsp_le &
 [ ORTH < "if" >,
   SYNSEM 
    [ LOCAL.CAT [ POSTHD -,
		  HEAD.MOD < [ LOCAL.CAT.MC +,
			       MODIFD notmod_or_rmod ] >,
		  VAL.COMPS < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN non_ellipt_rel,
					CONT.HOOK.XARG.PT notpro ] ] >],
      LKEYS.KEYREL.PRED "_if_x_then_rel",
      PHON.ONSET voc ] ].
|#
if_subconj_unspec := p_cp_s-unsp_le &
 [ ORTH < "if" >,
   SYNSEM 
    [ LOCAL.CAT [ POSTHD -,
		  VAL.COMPS < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN non_ellipt_rel,
					CONT.HOOK.XARG.PT notpro ] ] >],
      LKEYS.KEYREL.PRED "_if_x_then_rel",
      PHON.ONSET voc ] ].

if_subconj_anaph := p_cp_s-unsp_le &
 [ ORTH < "if" >,
   SYNSEM 
    [ LOCAL.CAT [ POSTHD -,
		  VAL.COMPS < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN non_ellipt_rel,
					CONT.HOOK.XARG.PT std ]] >],
      MODIFD.LPERIPH -,
      LKEYS.KEYREL.PRED "_if_x_then_rel",
      PHON.ONSET voc ] ].

if_subconj_unspec_post := p_cp_s-unsp_le &
 [ ORTH < "if" >,
   SYNSEM 
    [ LOCAL.CAT [ POSTHD +,
		  HEAD.MOD < [ MODIFD notmod_or_rmod,
			       LOCAL [ CAT.HEAD.MINORS.ALTMIN non_ellipt_rel,
				       CONT.HOOK.XARG.PT notpro ] ] > ],
      LKEYS.KEYREL.PRED "_if_x_then_rel",
      PHON.ONSET voc ] ].

if_and_only_if_subconj := p_cp_s-post_le &
 [ ORTH < "if", "and", "only", "if" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_if+and+only+if_x_1_rel",
	    LOCAL.CAT.HEAD.MOD < [ PUNCT.RPUNCT no_punct ] >,
            PHON.ONSET voc ] ].

nor_conj := c_xp_nor_le &
 [ ORTH < "nor" >,
   SYNSEM [ LOCAL [ CONJ lex-conj & [ CHEAD neither ],
                    CAT.VAL.COMPS.FIRST.LOCAL.CAT.MC na ],
            PHON.ONSET con ] ].

of_poss := p_np_i-nm-poss_le &
 [ ORTH < "of" >,
   SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM no_rel,
            LKEYS.KEYREL.PRED _of_p_rel,
            PHON.ONSET voc ] ].

only_if_subconj_1 := p_cp_s-rev_le &
 [ ORTH < "only", "if" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_only+if_x_rel",
            PHON.ONSET voc ] ].

provided_subord := p_cp_s-unsp_le &
 [ ORTH < "provided" >,
   SYNSEM 
    [ LOCAL.CAT [ POSTHD +,
		  HEAD.MOD < [ MODIFD notmod_or_rmod,
			       LOCAL [ CAT.HEAD.MINORS.ALTMIN non_ellipt_rel,
				       CONT.HOOK.XARG.PT notpro ] ] > ],
      LKEYS.KEYREL.PRED "_provided_x_rel",
      PHON.ONSET con ] ].

provided_that_subord := p_cp_s-unsp_le &
 [ ORTH < "provided", "that" >,
   SYNSEM 
    [ LOCAL.CAT [ POSTHD +,
		  HEAD.MOD < [ MODIFD notmod_or_rmod,
			       LOCAL [ CAT.HEAD.MINORS.ALTMIN non_ellipt_rel,
				       CONT.HOOK.XARG.PT notpro ] ] > ],
      LKEYS.KEYREL.PRED "_provided_x_rel",
      PHON.ONSET con ] ].

shape_n1 := n_-_mc-ed_le &
 [ ORTH < "shape" >,
   SYNSEM [ LOCAL.AGR.PNG.PN 3s,
	    LKEYS.KEYREL.PRED "_shape_n_1_rel",
            PHON.ONSET con ] ].

shape_pl_n1 := n_-_c-pl-ifl_le &
 [ ORTH < "shape" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_shape_n_1_rel",
            PHON.ONSET con ] ].

size_n1 := n_-_mc-ed_le &
 [ ORTH < "size" >,
   SYNSEM [ LOCAL.AGR.PNG.PN 3s,
	    LKEYS.KEYREL.PRED "_size_n_1_rel",
            PHON.ONSET con ] ].

size_pl_n1 := n_-_c-pl-ifl_le &
 [ ORTH < "size" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_size_n_1_rel",
            PHON.ONSET con ] ].

;; We have two entries for "the case": one for the EP introduced by paraphrase
;; rule as a variant of negation for atomic clauses, and the other for the
;; EP introduced during MRS 'inflation' for negated conjoined clauses, where
;; no alternative realization is possible for the negation.  We need to be
;; able to delete this latter if other paraphrase rules conspire to change
;; a clause conjunction into a single clause, as with "B is not a large cube" or
;; "A and B are not cubes".  Using two different PRED values avoids the loop
;; in paraphrase rule application where one rule adds and another deletes.
;;
the_case_a1 := aj_pp-cp_i-it-brdg_le &
 [ ORTH < "the", "case" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_the+case_a_1_rel",
            PHON.ONSET con ] ].

the_case_a2 := aj_pp-cp_i-it-brdg_le &
 [ ORTH < "the", "case" >,
   SYNSEM [ LKEYS.KEYREL.PRED "_the+case_a_2_rel",
            PHON.ONSET con ] ].

;; Block comma attaching, to avoid "if B is large, then, C is small"
then_adv3 := nonrs-nab &
 [ ORTH < "then" >,
   SYNSEM scopal_s_adverb_synsem &
          [ LOCAL [ CAT [ POSTHD -, 
	                  HEAD.MOD < [ LOCAL.CAT.MC bool ] > ],
	            CONJ cnil ],
	    PUNCT.RPUNCT comma_punct,
            LKEYS.KEYREL.PRED "_then_a_1_rel",
            PHON.ONSET con ] ].

unless := p_cp_s-unsp_le &
 [ ORTH < "unless" >,
   SYNSEM [ LOCAL.CAT.POSTHD +,
            LKEYS.KEYREL.PRED "_unless_x_rel",
            PHON.ONSET voc ] ].

both_adv1 := av_-_i-vp-x_le &
 [ ORTH < "both" >,
   SYNSEM 
   [ LOCAL.CAT.HEAD.MOD.FIRST.LOCAL [ CAT.VAL.SUBJ.FIRST.LOCAL.CONJ.LCHEAD cnil,
				      CONT.HOOK.INDEX non_conj_event ],
      LKEYS.KEYREL.PRED "_both_a_1_rel",
      PHON.ONSET con ] ].

;; Avoid default COMPS..CASE non_nom and instead require no_case to ensure
;; that parenthesized variants of the named entities appear as its complement,
;; as in "... and it (i.e., C) is large"
;;
i_e_p8 := basic_prep_word &
 [ ORTH < "(i.e.," >,
   SYNSEM trans_prep_synsem &
	  [ LOCAL [ CAT.VAL.COMPS < synsem & 
                                 [ LOCAL [ CAT nomp_cat_min &
					       [ HEAD.CASE no_case ],
                                           CONT.HOOK.INDEX non_expl-ind,
                                           CONJ cnil ],
				   OPT - ] >,
		    CONT.HOOK.INDEX.E.TENSE untensed ],
	    LKEYS.KEYREL.PRED _i+e_p_rel,
            PHON.ONSET voc ] ].

