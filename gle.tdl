;;; -*- Mode: tdl; Coding: utf-8; -*-

;;;
;;; generic lexical entries, i.e. entries that are not activated directly by
;;; orthography.  all generic entries are distinguished from native lexical
;;; entries by virtue of their [ ONSET unk_onset ].  generics are sub-divided
;;; into two sub-classes, named (somewhat unfortunately) `unknown' generics 
;;; and `generic' generics (that is `unk' and `gen', respectively).
;;;
;;; the former are designed for unknown words and activated on the basis of
;;; PoS tags, the latter correspond to named entities that are recognized by
;;; string-level properties during chart mapping (the equivalent of what in
;;; the YY tradition used to be `ersatz' lexical entries).  see the comments
;;; in `tmr.tdl' (token mapping) and `lfr.tdl' (lexical filtering) for further
;;; background.
;;;
;;; _fix_me_
;;; i believe nothing stands in our way of giving these entries a `meaningful'
;;; orthography now, e.g. something like "_generic_trans_verb_bse_", or so, for
;;; interactive testing (including the LKB).
;;;
;;; furthermore, i suspect we can now ditch the older `gle' entries, used for
;;; generation only, and instead use some of the entries below (those with a
;;; singleton RELS list, fully instantiated PRED, and underspecified CARG) in
;;; *generic-lexical-entries*.                                 (22-jan-09; oe)
;;;


;;;
;;; the first group of `unknown' generic entries, each for a specific PoS tag
;;;

generic_trans_verb_bse := v_np*_bse-unk_le &
  [ ORTH < "_generic_vb_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VB" ] > ].

generic_trans_verb_pres3sg := v_np*_pr-3s-unk_le &
  [ ORTH < "_generic_vbz_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBZ" ] > ].

generic_trans_verb_presn3sg := v_np*_pr-n3s-unk_le &
  [ ORTH < "_generic_vbp_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBP" ] > ].

generic_trans_verb_past := v_np*_pa-unk_le &
  [ ORTH < "_generic_vbd_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBD" ] > ].

generic_trans_verb_prp := v_np*_prp-unk_le &
  [ ORTH < "_generic_vbg_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBG" ] > ].

generic_trans_verb_psp := v_np*_psp-unk_le &
  [ ORTH < "_generic_vbn_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBN" ] > ].

generic_trans_verb_pas := v_-_pas-unk_le &
  [ ORTH < "_generic_vbn_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBN" ] > ].

generic_mass_noun := n_-_mc-unk_le &
  [ ORTH < "_generic_fw_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "FW" ] > ].

generic_mass_count_noun := n_-_mc-unk_le &
  [ ORTH < "_generic_nn_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "NN" ] > ].

generic_pl_noun := n_-_c-pl-unk_le &
  [ ORTH < "_generic_nns_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "NNS" ] > ].

genericname := n_-_pn-unk_le &
  [ ORTH < "_generic_nnp_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "NNP" ] > ].

genericname_pl := n_-_pn-unk_le &
  [ ORTH < "_generic_nnps_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "NNPS" ] > ].

generic_adj := aj_-_i-unk_le &
  [ ORTH < "_generic_jj_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "JJ" ] > ].

generic_adj_compar := aj_-_i-cmp-unk_le &
  [ ORTH < "_generic_jjr_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "JJR" ] > ].

generic_adj_superl := aj_-_i-sup-unk_le &
  [ ORTH < "_generic_jjs_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "JJS" ] > ].

generic_number := aj_-_i-crd-unk_le &
  [ ORTH < "_generic_cd_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "CD" ] > ].

generic_adverb := av_-_i-unk_le &
  [ ORTH < "_generic_rb_" >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "RB" ] > ].



;;;
;;; and the second group of `generic' named entities, activated by their +CLASS
;;; values, which get set in token mapping.  to avoid overlap with the unknown
;;; lexical entries, the token mapping rules make sure to `empty out' the PoS
;;; information whenever a named entity token is created.
;;;

generic_proper_ne := n_-_pn-gen_le &
  [ ORTH < "_generic_proper_ne_" >,
    TOKENS.+LIST < [ +CLASS proper_ne ] > ].

generic_pl_noun_ne := n_-_c-pl-gen_le &
  [ ORTH < "_generic_plur_ne_" >,
    TOKENS.+LIST < [ +CLASS plur_ne ] > ].

generic_pl_noun_2_ne := n_-_c-pl-gen_le &
  [ ORTH < "_generic_card_ne_", "'s" >,
    TOKENS.+LIST < [ +CLASS plur_ne ] > ].

generic_date_ne := n_-_day-crd-gen_le &
  [ ORTH < "_generic_date_ne_" >,
    TOKENS.+LIST < [ +CLASS date_ne ] > ].

generic_dom_card_ne := n_-_pn-dom-gen_le & 
  [ ORTH < "_generic_dom_card_ne_" >,
    TOKENS.+LIST < [ +CLASS dom_card_ne ] > ].

generic_dom_ord_ne := n_-_pn-dom-o-gen_le & 
  [ ORTH < "_generic_dom_ord_ne_" >,
    TOKENS.+LIST < [ +CLASS dom_ord_ne ] > ].

generic_dom_euro_ne := n_-_pn-dom-e-gen_le & 
  [ ORTH < "_generic_dom_euro_ne_" >,
    TOKENS.+LIST < [ +CLASS dom_card_ne ] > ].

generic_year_ne := n_-_pn-yoc-gen_le &
  [ ORTH < "_generic_year_ne_" >,
    TOKENS.+LIST < [ +CLASS year_ne ] > ].

generic_meas_np_ne := n_-_meas-gen_le &
  [ ORTH < "_generic_meas_np_ne_" >,
    TOKENS.+LIST < [ +CLASS meas_ne ] > ].

generic_meas_n_ne := n_-_meas-n-gen_le &
  [ ORTH < "_generic_meas_noun_ne_" >,
    TOKENS.+LIST < [ +CLASS meas_noun_ne ] > ].

generic_time_noun_ne := n_np_pn-hour-gen_le &
  [ ORTH < "_generic_time_ne_" >,
    TOKENS.+LIST < [ +CLASS time_ne ] > ].

generic_card_ne := aj_-_i-crd-gen_le &
  [ ORTH < "_generic_card_ne_" >,
    TOKENS.+LIST < [ +CLASS card_ne ] > ].

generic_ord_ne := aj_-_i-ord-gen_le &
  [ ORTH < "_generic_ord_ne" >,
    TOKENS.+LIST < [ +CLASS ord_ne ] > ].

generic_fract_ne := aj_-_i-frct-gen_le &
  [ ORTH < "_generic_fract_ne_" >,
    TOKENS.+LIST < [ +CLASS frct_ne ] > ].

;;;
;;; finally, for use in generation only, a few uninflected generics: unlike in
;;; parsing, these generics allow the use of standard orthographemic rules, as
;;; the input to the generator will determine inflection in terms of variable
;;; properties (plural on nouns, for example; or past tense on verbs).  to keep
;;; these entries out of the way in parsing, they have a +CLASS value that is
;;; incompatible with actual input tokens.
;;;
gen_generic_noun := n_-_mc-ns-g_le &
 [ ORTH < "_gen_generic_noun_" >,
   TOKENS.+LIST < [ +CLASS no_class ] > ].

gen_generic_verb := v_np*_unk_le &
 [ ORTH < "_gen_generic_verb_" >,
   TOKENS.+LIST < [ +CLASS no_class ] > ].
