;;; -*- Mode: tdl; Coding: utf-8; -*-

;;;
;;; generic lexical entries, i.e. entries that are not activated directly by
;;; orthography.  all generic entries are distinguished from native lexical
;;; entries by virtue of their [ ONSET unk_onset ].  generics are sub-divided
;;; into two sub-classes, named (somewhat unfortunately) `unknown' generics 
;;; and `generic' generics (that is `unk' and `gen', respectively).
;;;
;;; the former are designed for unknown words and activated on the basis of
;;; PoS tags, the latter correspond to named entities that are recognized by
;;; string-level properties during chart mapping (the equivalent of what in
;;; the YY tradition used to be `ersatz' lexical entries).  see the comments
;;; in `tmr.tdl' (token mapping) and `lfr.tdl' (lexical filtering) for further
;;; background.
;;;
;;; _fix_me_
;;; i believe nothing stands in our way of giving these entries a `meaningful'
;;; orthography now, e.g. something like "_generic_trans_verb_bse_", or so, for
;;; interactive testing (including the LKB).
;;;
;;; furthermore, i suspect we can now ditch the older `gle' entries, used for
;;; generation only, and instead use some of the entries below (those with a
;;; singleton RELS list, fully instantiated PRED, and underspecified CARG) in
;;; *generic-lexical-entries*.                                 (22-jan-09; oe)
;;;


;;;
;;; the first group of `unknown' generic entries, each for a specific PoS tag
;;;

generic_trans_verb_bse := v_np*_bse-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VB" ] > ].

generic_trans_verb_pres3sg := v_np*_pr-3s-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBZ" ] > ].

generic_trans_verb_presn3sg := v_np*_pr-n3s-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBP" ] > ].

generic_trans_verb_past := v_np*_pa-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBD" ] > ].

generic_trans_verb_psp := v_np*_psp-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBN" ] > ].

generic_trans_verb_prp := v_np*_prp-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBG" ] > ].

generic_trans_verb_pas := v_-_pas-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "VBN" ] > ].

generic_mass_count_noun := n_-_mc-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "NN" ] > ].

generic_mass_noun := n_-_mc-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "FW" ] > ].

generic_pl_noun := n_-_c-pl-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "NNS" ] > ].

genericname := n_-_pn-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "NNP" ] > ].

genericname_pl := n_-_pn-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "NNPS" ] > ].

generic_adj := aj_-_i-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "JJ" ] > ].

generic_adj_compar := aj_-_i-cmp-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "JJR" ] > ].

generic_adj_superl := aj_-_i-sup-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "JJS" ] > ].

generic_adverb := av_-_i-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "RB" ] > ].

generic_number := aj_-_i-crd-unk_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +TNT.+TAGS.FIRST "CD" ] > ].


;;;
;;; and the second group of `generic' named entities, activated by their +CLASS
;;; values, which get set in token mapping.  to avoid overlap with the unknown
;;; lexical entries, the token mapping rules make sure to `empty out' the PoS
;;; information whenever a named entity token is created.
;;;

generic_proper_ne := n_-_pn-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS proper_ne ] > ].

generic_pl_noun_ne := n_-_c-pl-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS plur_ne ] > ].

generic_date_ne := n_-_day-crd-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS date_ne ] > ].

generic_dom_ne := n_-_pn-dom-gen_le & 
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS dom_ne ] > ].

generic_year_ne := n_-_pn-yoc-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS year_ne ] > ].

;;
;; _fix_me_
;; if all cardinals can be measure NEs too, why not underspecify their +CLASS,
;; i.e. have only one `n_-_meas-gen_le' instance of class `card_or_meas_ne', or
;; similar.  but what about native cardinals then?  if it were universally the
;; case that cardinals and measure nouns always co-occur, could there maybe be
;; a productive pumping rule instead?                           (21-jan-09; oe)
;;
generic_meas_noun_ne := n_-_meas-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS meas_ne ] > ].

generic_meas_noun_ne2 := n_-_meas-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS card_ne ] > ].

generic_time_noun_ne := n_np_pn-hour-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS time_ne ] > ].

generic_card_ne := aj_-_i-crd-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS card_ne ] > ].

generic_ord_ne := aj_-_i-ord-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS ord_ne ] > ].

generic_fract_ne := aj_-_i-frct-gen_le &
  [ STEM < *top* >,
    TOKENS.+LIST < [ +CLASS frct_ne ] > ].

