;;; Hey, emacs(1), this is -*- Mode: TDL; Package: LKB; -*- got it?

quantifier_qeq := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #x ] >,
  INPUT.RELS < [ PRED quantifier_mark, LBL #h1, ARGD #x ],
               [ PRED #pred, LBL #h1, ARG0 #x ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred,
                    LBL #h1, ARG0 #x & x, RSTR #h2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ] ].

;;;
;;; _fix_me_
;;; the (silly) way transfer variables for constants (including PRED) work, the
;;; inherited constraint on the predicate is not effective, and hence we need to
;;; make sure ARGL is actually present.                          (29-nov-15; oe)
;;;
#|
intersective_gra := monotonic_mtr &
[ CONTEXT.RELS < [ PRED scopal_mark, LBL #h0 & [ SCRATCH one ], 
                   ARGD #i, ARGE #e ] >,
  INPUT.RELS < [ PRED #pred, LBL [ SCRATCH two], ARGD #e, ARGL #h1 & h ] >,
  OUTPUT.RELS < [ PRED #pred, LBL #h0, ARGD #i, ARGL #h1 ] >,
  FLAGS.EQUAL < #h1 > ].
|#

scopal_arg1 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg1_mark, LBL #h1, ARGD #i1 ],
               [ PRED #pred, LBL #h1, ARG0 #i1,
                 ARG1 #i0, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, ARG0 #i1,
                    ARG1 #h2, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_arg2 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg2_mark, LBL #h1, ARGD #i1 ],
               [ PRED #pred, LBL #h1, ARG0 #i1,
                 ARG1 #u0, ARG2 #i0, ARG3 #u1, ARG4 #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, ARG0 #i1,
                    ARG1 #u0, ARG2 #h2, ARG3 #u1, ARG4 #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_arg3 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg3_mark, LBL #h1, ARGD #i1 ],
               [ PRED #pred, LBL #h1, ARG0 #i1,
                 ARG1 #u0, ARG2 #u1, ARG3 #i0, ARG4 #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, ARG0 #i1,
                    ARG1 #u0, ARG2 #u1, ARG3 #h2, ARG4 #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_arg4 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg4_mark, LBL #h1, ARGD #i1 ],
               [ PRED #pred, LBL #h1, ARG0 #i1,
                 ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #i0 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, ARG0 #i1,
                    ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #h2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_l-hndl := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_l-hndl_mark, LBL #h1, ARGD #i1 ],
               [ PRED #pred, LBL #h1, ARG0 #i1, 
                 L-HNDL #i0, L-INDEX #u0, R-HNDL #u1, R-INDEX #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, ARG0 #i1, 
                    L-HNDL #h2, L-INDEX #u0, R-HNDL #u1, R-INDEX #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_r-hndl := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_r-hndl_mark, LBL #h1, ARGD #i1 ],
               [ PRED #pred, LBL #h1, ARG0 #i1, 
                 L-HNDL #u0, L-INDEX #u1, R-HNDL #i0, R-INDEX #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, ARG0 #i1, 
                    L-HNDL #u0, L-INDEX #u1, R-HNDL #h2, R-INDEX #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

;;;
;;; in equating labels of intersective modifiers, ordering is important: in a
;;; structure like ‘really old dog’, we need to equate the label of ‘dog’ with
;;; its head first, to then equate the label of ‘really’ with the (new) label
;;; of ‘old’.  thus, the intersective modifier rules guard against attachment
;;; to heads that themselves bear an ‘intersective’ mark still, and we need to
;;; iterate this group of rules until a fixpoint is reached.  –most likely, the
;;; above is no longer true, as we now explicitly propagate the target label in
;;; ‘clusters’ of intersective modifiers.
;;;
;;; we need to guard against equating labels with a quantifier (which will have
;;; the same ARG0 as its nominal relation); possibly we should go back to using
;;; BV on quantifiers (as is the case in the EDS), and rename at the end of the
;;; day?  for now, put a special mark on the label of quantifiers (while other
;;; marks tends to go on the distinguished variable).
;;;
;;; _fix_me_
;;; introducing (potentially) large numbers of unbound arguments in the default
;;; transfer set-up yields (a) many rule applications (which is not problematic)
;;; and (b) spurious ordering ambiguity, e.g. which ARG4 to ditch first.  there
;;; may well be a mechanism to deal with the latter already, if only one knew a 
;;; little more about the LOGON transfer formalism.              (19-nov-15; oe)
;;;

intersective_modifier := monotonic_mtr &
[ INPUT.RELS < [ PRED intersective_mark, LBL #h0, 
                 ARGD #e, ARGL #h1 & [ SCRATCH one ] ],
               [ PRED #pred, LBL #h0 & [ SCRATCH two ], ARG0 #e,
                 ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #u3, CARG anti ] >,
  FILTER.RELS < [ PRED intersective_mark, LBL #h, ARGD #i ] >,
  OUTPUT.RELS < [ PRED #pred, LBL #h1, ARG0 #e,
                  ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #u3 ] > ].

intersective_modifier_carg := monotonic_mtr &
[ INPUT.RELS < [ PRED intersective_mark, LBL #h0, 
                 ARGD #e, ARGL #h1 & [ SCRATCH one ] ],
               [ PRED #pred, LBL #h0 & [ SCRATCH two ], ARG0 #e,
                 ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #u3, CARG #carg ] >,
  FILTER.RELS < [ PRED intersective_mark, LBL #h, ARGD #i ] >,
  OUTPUT.RELS < [ PRED #pred, LBL #h1, ARG0 #e,
                  ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #u3, CARG #carg ] > ].

