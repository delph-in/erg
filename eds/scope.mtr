;;; Hey, emacs(1), this is -*- Mode: TDL; Package: LKB; -*- got it?

quantifier_qeq := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #x ] >,
  INPUT.RELS < [ PRED quantifier_mark, LBL #h1, ARGM #x ],
               [ PRED #pred, LBL #h1, ARG0 #x, BODY #h3 & h ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, ARG0 #x & x, RSTR #h2, BODY #h3 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ] ].

;;;
;;; _fix_me_
;;; introducing (potentially) large numbers of unbound arguments in the default
;;; transfer set-up leads (a) many rule applications (which seems unproblematic)
;;; and (b) spurious ordering ambiguity, e.g. which ARG4 to ditch first.  there
;;; may well be a mechanism to deal with the latter already, if only one knew a 
;;; little more about the LOGON transfer formalism.              (19-nov-15; oe)
;;;
intersective_arg1 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h & [ SCRATCH one ], ARG0 #i ] >,
  INPUT.RELS < [ PRED intersective_modifier_mark, LBL #h0, ARGM #e ],
               [ PRED #pred, LBL [ SCRATCH two ], 
                 ARG0 #e, ARG1 #i & i, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
  FILTER.RELS < [ PRED intersective_modifier_mark, LBL #h, ARGM #i ] >,
  OUTPUT.RELS < [ PRED #pred, LBL #h, 
                  ARG0 #e, ARG1 #i, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
  FLAGS.SUBSUME < #i > ].

scopal_arg1 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg1_mark, LBL #h1, ARGM #i1 ],
               [ PRED #pred, LBL #h1, 
                 ARG0 #i1, ARG1 #i0, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, 
                    ARG0 #i1,  ARG1 #h2, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_arg2 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg2_mark, LBL #h1, ARGM #i1 ],
               [ PRED #pred, LBL #h1, 
                 ARG0 #i1, ARG1 #u0, ARG2 #i0, ARG3 #u1, ARG4 #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, 
                    ARG0 #i1,  ARG1 #u0, ARG2 #h2, ARG3 #u1, ARG4 #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_arg3 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg3_mark, LBL #h1, ARGM #i1 ],
               [ PRED #pred, LBL #h1, 
                 ARG0 #i1, ARG1 #u0, ARG2 #u1, ARG3 #i0, ARG4 #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, 
                    ARG0 #i1,  ARG1 #u0, ARG2 #u1, ARG3 #h2, ARG4 #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_arg4 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg4_mark, LBL #h1, ARGM #i1 ],
               [ PRED #pred, LBL #h1, 
                 ARG0 #i1, ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #i0 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, 
                    ARG0 #i1,  ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #h2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

unbound_arg1 := monotonic_mtr &
[ INPUT.RELS < [ ARG1 #u & u & [ DITCH - ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG1 [ DITCH + ] ] >,
  FLAGS.EQUAL < #u > ].

unbound_arg2 := monotonic_mtr &
[ INPUT.RELS < [ ARG2 #u & u & [ DITCH - ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG2 [ DITCH + ] ] >,
  FLAGS.EQUAL < #u > ].

unbound_arg3 := monotonic_mtr &
[ INPUT.RELS < [ ARG3 #u & u & [ DITCH - ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG3 [ DITCH + ] ] >,
  FLAGS.EQUAL < #u > ].

unbound_arg4 := monotonic_mtr &
[ INPUT.RELS < [ ARG4 #u & u & [ DITCH - ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG4 [ DITCH + ] ] >,
  FLAGS.EQUAL < #u > ].

unmark := elision_mtr &
[ INPUT.RELS < [ PRED mark ] > ].
