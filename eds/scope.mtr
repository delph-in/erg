;;; Hey, emacs(1), this is -*- Mode: TDL; Package: LKB; -*- got it?

quantifier_qeq := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #x ] >,
  INPUT.RELS < [ PRED quantifier_mark, LBL #h1, ARGM #x ],
               [ PRED #pred, LBL #h1, ARG0 #x ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred,
                    LBL #h1, ARG0 #x & x, RSTR #h2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ] ].

;;;
;;; in equating labels of intersective modifiers, ordering is important: in a
;;; structure like ‘really old dog’, we need to equate the label of ‘dog’ with
;;; its head first, to then equate the label of ‘really’ with the (new) label
;;; of ‘old’.  thus, the intersective modifier rules guard against attachment
;;; to heads that themselves bear an ‘intersective’ mark still, and we need to
;;; iterate this group of rules until a fixpoint is reached.
;;;
;;;
;;; we need to guard against equating labels with a quantifier (which will have
;;; the same ARG0 as its nominal relation); possibly we should go back to using
;;; BV on quantifiers (as is the case in the EDS), and rename at the end of the
;;; day?
;;;
;;; _fix_me_
;;; introducing (potentially) large numbers of unbound arguments in the default
;;; transfer set-up yields (a) many rule applications (which is not problematic)
;;; and (b) spurious ordering ambiguity, e.g. which ARG4 to ditch first.  there
;;; may well be a mechanism to deal with the latter already, if only one knew a 
;;; little more about the LOGON transfer formalism.              (19-nov-15; oe)
;;;
intersective_arg1 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h & [ MARK ordinary, SCRATCH one ], ARG0 #i ] >,
  INPUT.RELS < [ PRED intersective_arg1_mark, LBL #h0, ARGM #e ],
               [ PRED #pred, LBL #h0 & [ SCRATCH two ], 
                 ARG0 #e, ARG1 #i & i, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
  FILTER.RELS < [ PRED intersective_mark, LBL #h, ARGM #i ] >,
  OUTPUT.RELS < [ PRED #pred, LBL #h, 
                  ARG0 #e, ARG1 #i, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
  FLAGS.SUBSUME < #i > ].

intersective_arg2 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h & [ MARK ordinary, SCRATCH one ], ARG0 #i ] >,
  INPUT.RELS < [ PRED intersective_arg2_mark, LBL #h0, ARGM #e ],
               [ PRED #pred, LBL #h0 & [ SCRATCH two ], 
                 ARG0 #e, ARG1 #u0, ARG2 #i & i, ARG3 #u1, ARG4 #u2 ] >,
  FILTER.RELS < [ PRED intersective_mark, LBL #h, ARGM #i ] >,
  OUTPUT.RELS < [ PRED #pred, LBL #h, 
                  ARG0 #e, ARG1 #u0, ARG2 #i, ARG3 #u1, ARG4 #u2 ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "intersective_arg1" ] ].

scopal_arg1 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg1_mark, LBL #h1, ARGM #i1 ],
               [ PRED #pred, LBL #h1, 
                 ARG0 #i1, ARG1 #i0, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, 
                    ARG0 #i1,  ARG1 #h2, ARG2 #u0, ARG3 #u1, ARG4 #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_arg2 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg2_mark, LBL #h1, ARGM #i1 ],
               [ PRED #pred, LBL #h1, 
                 ARG0 #i1, ARG1 #u0, ARG2 #i0, ARG3 #u1, ARG4 #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, 
                    ARG0 #i1,  ARG1 #u0, ARG2 #h2, ARG3 #u1, ARG4 #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_arg3 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg3_mark, LBL #h1, ARGM #i1 ],
               [ PRED #pred, LBL #h1, 
                 ARG0 #i1, ARG1 #u0, ARG2 #u1, ARG3 #i0, ARG4 #u2 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, 
                    ARG0 #i1,  ARG1 #u0, ARG2 #u1, ARG3 #h2, ARG4 #u2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

scopal_arg4 := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0, ARG0 #i0 & i ] >,
  INPUT.RELS < [ PRED scopal_arg4_mark, LBL #h1, ARGM #i1 ],
               [ PRED #pred, LBL #h1, 
                 ARG0 #i1, ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #i0 ] >,
  FILTER.HCONS < qeq & [ LARG #h0 ] >,
  OUTPUT [ RELS < [ PRED #pred, LBL #h1, 
                    ARG0 #i1,  ARG1 #u0, ARG2 #u1, ARG3 #u2, ARG4 #h2 ] >,
           HCONS < qeq & [ HARG #h2, LARG #h0 ] > ],
  FLAGS.SUBSUME < #i0 > ].

unbound_arg1 := monotonic_mtr &
[ INPUT.RELS < [ ARG1 #u & u & [ DITCH - ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG1 [ DITCH + ] ] >,
  FLAGS.EQUAL < #u > ].

unbound_arg2 := monotonic_mtr &
[ INPUT.RELS < [ ARG2 #u & u & [ DITCH - ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG2 [ DITCH + ] ] >,
  FLAGS.EQUAL < #u > ].

unbound_arg3 := monotonic_mtr &
[ INPUT.RELS < [ ARG3 #u & u & [ DITCH - ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG3 [ DITCH + ] ] >,
  FLAGS.EQUAL < #u > ].

unbound_arg4 := monotonic_mtr &
[ INPUT.RELS < [ ARG4 #u & u & [ DITCH - ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG4 [ DITCH + ] ] >,
  FLAGS.EQUAL < #u > ].

unmark := elision_mtr &
[ INPUT.RELS < [ PRED mark ] > ].
