;;; Hey, emacs(1), this is -*- Mode: TDL; Package: LKB; -*- got it?

;;;
;;; in general, our strategy is to put various marks on distinguished variables
;;; (ARG0s), but for quantifiers we rather use the LBL instead, as they share
;;; the distinguished variable of their nominal relation, whereas their label
;;; remains by construction (of scope underspecification in ERSs) unbound.
;;; 
quantifier_mark := monotonic_mtr &
[ INPUT.RELS < [ PRED "~_q$", LBL #h0, ARG0 #x ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h0, ARGD #x ] >,
  OUTPUT.RELS < +copy+ & [ LBL [ MARK quantifier ], ARG0 [ MARK none ] ],
                [ PRED quantifier_mark, LBL #h0, ARGD #x ] > ].

discourse_mark := monotonic_mtr &
[ INPUT.RELS < [  PRED "~_d$", ARG0 [ MARK test ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK discourse ] ] > ].


;;;
;;; to detect intersective modifiers, we traverse the argument links from the
;;; top of the structure, effectively coloring all EPs that participate in the
;;; top-level proposition, which we call the ‘spine’.  any remaining EPs that
;;; take spinal EPs as their arguments, we treat as intersective modifers, i.e.
;;; mark them for label sharing with their heads.  we these are identified, we
;;; need to recurse into intersective modifier propositions, i.e. re-run both
;;; parts of the coloring process—until a fixpoint is reached.  quantifier EPs
;;; are excluded from this process, by virtue of bearing a mark already.
;;;
;;; as a side-effect of walking the spine, we can also identify scopal argument
;;; positions, at least in a fully connected structure: the ERG will only use
;;; events as arguments to intersective modifiers and, thus, other arguments of
;;; the event type must be converted to scopal sub-ordination.  conversely, we
;;; take advantage of the lack of scopal modifiers on instance variables.  with
;;; these assumptions at least, it actually appears possible to properly deal
;;; with intersective modifiers and various types of scopal arguments, without
;;; use of the ERG SEM-I.  for increased robustness (to structures that fail to
;;; ensure full connectivity), we should also identify scopal arguments based
;;; on what is recorded in the SEM-I; however, ‘polymorphic’ predicates that
;;; allow both scopal and non-scopal values for a specific role will probably
;;; challenge that approach (at least as long as we want fully deterministic
;;; rewriting).  maybe just as well dan has so far resisted the encouragment
;;; (by, among others, emily and myself) to increase such polymorphism in the
;;; ERG semantics.
;;;
;;; _fix_me_ 
;;; we still need to deal adequately with sub-ordinated intersective modifiers
;;; (‘the dog i believe barked is fierce’), i.e. equate the top sub-ordinating
;;; label rather than the local top of the relative clause;  presumably, we can
;;; ‘push’ the intersective mark upwards through a chain of propositional
;;; sub-ordination.                                             (19-nov-15; oe)
;;;
null_spine_mark := monotonic_mtr &
[ INPUT.RELS < [ ARG0 [ MARK test ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK none ] ] > ].

index_spine_mark := monotonic_mtr &
[ CONTEXT.INDEX #i,
  INPUT.RELS < [ ARG0 #i & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] > ].

top_spine_mark := monotonic_mtr &
[ CONTEXT [ TOP #h0,
            HCONS < qeq & [ HARG #h0, LARG #h1 ] > ],
  INPUT.RELS < [ LBL #h1, ARG0 [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] > ].

;;;
;;; intersective modifiers can be scopally sub-ordinated, e.g. in a relative
;;; clause like ‘the dog that she believes barked is fierce.’  in these cases,
;;; the equating of labels (between the modifier and its head) needs to apply
;;; at the top-most sub-ordinating level, i.e. in our example, ‘believe’ ends
;;; up sharing the label of ‘dog’.
;;;
scopal_1gra_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ PRED intersective_mark, 
                   ARGD #e & e & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none, TENSE tensed ], ARG1 #e ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg1_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS.EQUAL < #e > ].

scopal_2gra_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ PRED intersective_mark, 
                   ARGD #e & e & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none, TENSE tensed ], ARG2 #e ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg2_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS.EQUAL < #e > ].

scopal_3gra_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ PRED intersective_mark, 
                   ARGD #e & e & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none, TENSE tensed ], ARG3 #e ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg3_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS.EQUAL < #e > ].

scopal_4gra_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ PRED intersective_mark, 
                   ARGD #e & e & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none, TENSE tensed ], ARG4 #e ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg4_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS.EQUAL < #e > ].

scopal_arg1_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h, ARG0 #i & [ MARK spine ], ARG1 #e & e ] >,
  INPUT.RELS < [ ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg1_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS.EQUAL < #e > ].

arg1_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], ARG1 #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGD #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

scopal_arg2_spine_mark := monotonic_mtr &
[ CONTEXT.RELS <  [ LBL #h, ARG0 #i & [ MARK spine ], ARG2 #e & e ] >,
  INPUT.RELS < [ ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg2_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS [ EQUAL < #e >,
          CALL "scopal_arg1_spine_mark" ] ].

arg2_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], ARG2 #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGD #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

scopal_arg3_spine_mark := monotonic_mtr &
[ CONTEXT.RELS <  [ LBL #h, ARG0 #i & [ MARK spine ], ARG3 #e & e ] >,
  INPUT.RELS < [ ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg3_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS [ EQUAL < #e >,
          CALL "scopal_arg1_spine_mark" ] ].

arg3_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], ARG3 #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGD #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

scopal_arg4_spine_mark := monotonic_mtr &
[ CONTEXT.RELS <  [ LBL #h, ARG0 #i & [ MARK spine ], ARG4 #e & e ] >,
  INPUT.RELS < [ ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg4_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS [ EQUAL < #e >,
          CALL "scopal_arg1_spine_mark" ] ].

arg4_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], ARG4 #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGD #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

scopal_l-hndl_spine_mark := monotonic_mtr &
[ CONTEXT.RELS <  [ LBL #h, ARG0 #i & [ MARK spine ], L-HNDL #e & e ] >,
  INPUT.RELS < [ ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_l-hndl_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS [ EQUAL < #e >,
          CALL "scopal_arg1_spine_mark" ] ].

l-index_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], L-INDEX #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGD #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

scopal_r-hndl_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h, ARG0 #i & [ MARK spine ], R-HNDL #e & e ] >,
  INPUT.RELS < [ ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_r-hndl_mark, LBL #h, ARGD #i, ARGE #e ] >,
  FLAGS [ EQUAL < #e >,
          CALL "scopal_arg1_spine_mark" ] ].

r-index_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], R-INDEX #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGD #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

#|
scopal_arg1_mark := scopal_arg1_mtr &
[ CONTEXT.RELS < [ PRED "~(?:plus|times)_rel" ], ... > ].
|#

;;;
;;; now, onwards to the detection of (what better be) intersective modifiers
;;;

intersective_arg1_mark := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0 & [ MARK none ], ARG0 #i0 & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h1, ARG0 #i1 & [ MARK none ], ARG1 #i0 & i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED intersective_arg1_mark, LBL #h1, ARGD #i1, ARGL #h0 ] >,
  FLAGS [ SUBSUME < #i0 >,
          CALL "scopal_1gra_spine_mark" ] ].

intersective_arg2_mark := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0 & [ MARK none ], ARG0 #i0 & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h1, ARG0 #i1 & [ MARK none ], ARG2 #i0 & i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED intersective_arg2_mark, LBL #h1, ARGD #i1, ARGL #h0 ] >,
  FLAGS [ SUBSUME < #i0 >,
          CALL "scopal_1gra_spine_mark" ] ].

intersective_arg3_mark := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0 & [ MARK none ], ARG0 #i0 & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h1, ARG0 #i1 & [ MARK none ], ARG3 #i0 & i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED intersective_arg3_mark, LBL #h1, ARGD #i1, ARGL #h0 ] >,
  FLAGS [ SUBSUME < #i0 >,
          CALL "scopal_1gra_spine_mark" ] ].

intersective_arg4_mark := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0 & [ MARK none ], ARG0 #i0 & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h1, ARG0 #i1 & [ MARK none ], ARG4 #i0 & i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED intersective_arg4_mark, LBL #h1, ARGD #i1, ARGL #h0 ] >,
  FLAGS [ SUBSUME < #i0 >,
          CALL "scopal_1gra_spine_mark" ] ].

intersective_discourse_mark := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h0 & [ MARK none, SCRATCH one ], ARG0 #i0 ],
                 [ LBL #h1 & [ SCRATCH two ],
                   ARG0 #i1 & [ MARK discourse ], ARG1 #i0 & i ] >,
  FILTER.RELS < [ PRED intersective_arg1_mark, LBL #h1, ARGD #i1, ARGL #h0 ] >,
  OUTPUT.RELS < [ PRED intersective_arg1_mark, LBL #h1, ARGD #i1, ARGL #h0 ] >,
  FLAGS.SUBSUME < #i0 > ].

;;;
;;; we might have seen ‘chains’ of intersective modifiers, hence need to make
;;; sure they all end up equating their label with the actual head.
;;;
intersective_cluster := monotonic_mtr &
[ CONTEXT.RELS < [ PRED intersective_mark, LBL #h0, ARGL #h1 ] >,
  INPUT.RELS < [ PRED #pred, LBL #h2, ARGD #i, ARGL #h0 & h ] >,
  OUTPUT.RELS < [ PRED #pred, LBL #h2, ARGD #i, ARGL #h1 ] >,
  FLAGS.EQUAL < #h0 > ].

;;;
;;; (at this point) mainly to exemplify another possible approach: ‘lexically’
;;; driven rules, e.g. for scopal operators or generally any scopal arguments.
;;;
not_mark := scopal_arg1_mtr &
[ CONTEXT.RELS < [ PRED neg_rel ], ... > ].
