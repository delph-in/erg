;;; Hey, emacs(1), this is -*- Mode: TDL; Package: LKB; -*- got it?

;;;
;;; in general, our strategy is to put various marks on distinguished variables
;;; (ARG0s), but for quantifiers we rather use the LBL instead, as they share
;;; the distinguished variable of their nominal relation, whereas their label
;;; remains by construction (of scope underspecification in ERSs) unbound.
;;; 
quantifier_mark := monotonic_mtr &
[ INPUT.RELS < [ PRED "~_q_rel$", LBL #h0, ARG0 #x ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h0, ARGM #x ] >,
  OUTPUT.RELS < +copy+ & [ LBL [ MARK quantifier ], ARG0 [ MARK none ] ],
                [ PRED quantifier_mark, LBL #h0, ARGM #x ] > ].

discourse_mark := monotonic_mtr &
[ INPUT.RELS < [  PRED "~_d_rel$", ARG0 [ MARK test ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK discourse ] ] > ].


;;;
;;; to detect intersective modifiers, we traverse the argument links from the
;;; top of the structure, effectively coloring all EPs that participate in the
;;; top-level proposition, which we call the ‘spine’.  any remaining EPs that
;;; take spinal EPs as their arguments, we treat as intersective modifers, i.e.
;;; mark them for label sharing with their heads.  we these are identified, we
;;; need to recurse into intersective modifier propositions, i.e. re-run both
;;; parts of the coloring process—until a fixpoint is reached.  quantifier EPs
;;; are excluded from this process, by virtue of bearing a mark already.
;;;
;;; as a side-effect of walking the spine, we can also identify scopal argument
;;; positions, at least in a fully connected structure: the ERG will only use
;;; events as arguments to intersective modifiers and, thus, other arguments of
;;; the event type must be converted to scopal sub-ordination.  conversely, we
;;; take advantage of the lack of scopal modifiers on instance variables.  with
;;; these assumptions at least, it actually appears possible to properly deal
;;; with intersective modifiers and various types of scopal arguments, without
;;; use of the ERG SEM-I.  for increased robustness (to structures that fail to
;;; ensure full connectivity), we should also identify scopal arguments based
;;; on what is recorded in the SEM-I; however, ‘polymorphic’ predicates that
;;; allow both scopal and non-scopal values for a specific role will probably
;;; challenge that approach (at least as long as we want fully deterministic
;;; rewriting).  maybe just as well dan has so far resisted the encouragment
;;; (by, among others, emily and myself) to increase such polymorphism in the
;;; ERG semantics.
;;;
;;; _fix_me_ 
;;; we still need to deal adequately with sub-ordinated intersective modifiers
;;; (‘the dog i believe barked is fierce’), i.e. equate the top sub-ordinating
;;; label rather than the local top of the relative clause;  presumably, we can
;;; ‘push’ the intersective mark upwards through a chain of propositional
;;; sub-ordination.                                             (19-nov-15; oe)
;;;
null_spine_mark := monotonic_mtr &
[ INPUT.RELS < [ ARG0 [ MARK test ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK none ] ] > ].

index_spine_mark := monotonic_mtr &
[ CONTEXT.INDEX #i,
  INPUT.RELS < [ ARG0 #i & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] > ].

top_spine_mark := monotonic_mtr &
[ CONTEXT [ TOP #h0,
            HCONS < qeq & [ HARG #h0, LARG #h1 ] > ],
  INPUT.RELS < [ LBL #h1, ARG0 [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] > ].

scopal_arg1_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ LBL #h, ARG0 #i & [ MARK spine ], ARG1 #e & e ] >,
  INPUT.RELS < [ ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg1_mark, LBL #h, ARGM #i ] >,
  FLAGS.EQUAL < #e > ].

arg1_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], ARG1 #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGM #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

scopal_arg2_spine_mark := monotonic_mtr &
[ CONTEXT.RELS <  [ LBL #h, ARG0 #i & [ MARK spine ], ARG2 #e & e ] >,
  INPUT.RELS < [ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg2_mark, LBL #h, ARGM #i ] >,
  FLAGS [ EQUAL < #e >,
          CALL "scopal_arg1_spine_mark" ] ].

arg2_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], ARG2 #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGM #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

scopal_arg3_spine_mark := monotonic_mtr &
[ CONTEXT.RELS <  [ LBL #h, ARG0 #i & [ MARK spine ], ARG3 #e & e ] >,
  INPUT.RELS < [ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg3_mark, LBL #h, ARGM #i ] >,
  FLAGS [ EQUAL < #e >,
          CALL "scopal_arg1_spine_mark" ] ].

arg3_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], ARG3 #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGM #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

scopal_arg4_spine_mark := monotonic_mtr &
[ CONTEXT.RELS <  [ LBL #h, ARG0 #i & [ MARK spine ], ARG4 #e & e ] >,
  INPUT.RELS < [ARG0 #e & [ MARK none ] ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED scopal_arg4_mark, LBL #h, ARGM #i ] >,
  FLAGS [ EQUAL < #e >,
          CALL "scopal_arg1_spine_mark" ] ].

arg4_spine_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 [ MARK spine ], ARG4 #i & i ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i & [ MARK none ] ] >,
  FILTER.RELS < [ PRED quantifier_mark, LBL #h, ARGM #i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ] >,
  FLAGS [ SUBSUME < #i >,
          CALL "scopal_arg1_spine_mark" ] ].

intersective_arg1_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 #i0 & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i1 & [ MARK none ], ARG1 #i0 & i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED intersective_arg1_mark, LBL #h, ARGM #i1 ] >,
  FLAGS [ SUBSUME < #i0 >,
          CALL "scopal_arg1_spine_mark" ] ].

intersective_arg2_mark := monotonic_mtr &
[ CONTEXT.RELS < [ ARG0 #i0 & [ MARK spine ] ] >,
  INPUT.RELS < [ LBL #h, ARG0 #i1 & [ MARK none ], ARG2 #i0 & i ] >,
  OUTPUT.RELS < +copy+ & [ ARG0 [ MARK spine ] ],
                [ PRED intersective_arg2_mark, LBL #h, ARGM #i1 ] >,
  FLAGS [ SUBSUME < #i0 >,
          CALL "scopal_arg1_spine_mark" ] ].

intersective_discourse_mark := monotonic_mtr &
[ CONTEXT.RELS < [ LBL [ SCRATCH one ], ARG0 #i0 ],
                 [ LBL #h & [ SCRATCH two ],
                   ARG0 #i1 & [ MARK discourse ], ARG1 #i0 & i ] >,
  FILTER.RELS < [ PRED intersective_arg1_mark, LBL #h, ARGM #i1 ] >,
  OUTPUT.RELS < [ PRED intersective_arg1_mark, LBL #h, ARGM #i1 ] >,
  FLAGS.SUBSUME < #i0 > ].

not_mark := scopal_arg1_mtr &
[ CONTEXT.RELS < [ PRED neg_rel ], ... > ].
