;;; -*- Mode: tdl; Coding: utf-8; -*-

;;;
;;; token mapping is the process of inspecting and re-arranging input tokens,
;;; i.e. a lattice of structured objects (feature structures), to best match
;;; the expectations of the grammar proper.  the general mechnism is described
;;; by Adolphs, et al. (2008); see:
;;;
;;;   http://www.lrec-conf.org/proceedings/lrec2008/summaries/349.html
;;;
;;; as of August 2008, we are assuming an initial tokenization that is (mostly)
;;; compatible to Penn Treebank (PTB) conventions; this may or may not turn out
;;; to be a good idea, but if nothing else it makes the core parser compatible
;;; with a wide variety of existing tools and pre-processing approaches.  for a
;;; critical (and subjective) discussion of some tokenization issues, see:
;;;
;;;  http://lingpipe-blog.com/2008/06/26/the-curse-of-intelligent-tokenization/
;;;
;;; in the process of token mapping, we move from a PTB-compatible tokenization
;;; to an ERG-compatible one: specifically, many punctuation marks are attached
;;; as prefixes or suffixes on other tokens.  the process is broken down into a
;;; number of (more or less) distinct phases, viz.
;;;
;;; - decoration: filling in missing or underspecified token properties.
;;; - normalization: anything the (ideal) tokenizer _should_ have done.
;;; - NE recognition: surface-based identification of URLs, numbers, et al.
;;; - token combination: re-attach punctuation marks and contracted forms.
;;; - sandwiched punctuation
;;; - PoS explosion: multiply out alternate PoS readings
;;; - PoS reduction: prune overlapping PoS readings
;;;
;;; we hope we have (now) arrived at a relatively stable inventory of token
;;; properties, of which some typically are only introduced in token mapping;
;;; these are ONSET, PRED, CARG.  however, in principle a tokenizer might pass
;;; in any of these properties, or they could be introduced very early in the
;;; rewrite process.  hence, all rules must make sure to always preserve all
;;; token information.
;;;

;;
;; some tokenizers (e.g. the one of acrolinx) already distinguish a number of
;; token classes.  our REPP tokenizer, however, does not; so, determine class
;; values here, if need be.  with acrolinx, we might have to map their naming
;; scheme into our type hierarchy, on the other hand.
;;
#|
numeric_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:digit:]]+/" ] >,
  +OUTPUT < [ +CLASS numeric ] > ].

alphabetic+upper_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:upper:]]+/" ] >,
  +OUTPUT < [ +CLASS alphabetic+upper ] > ].

alphabetic+lower_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:lower:]]+/" ] >,
  +OUTPUT < [ +CLASS alphabetic+lower ] > ].

alphabetic+capitalized+mixed_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:upper:]][[:alpha:]]+/" ] >,
  +OUTPUT < [ +CLASS alphabetic+capitalized+mixed ] > ].

alphabetic+non_capitalized+mixed_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:lower:]][[:alpha:]]+/" ] >,
  +OUTPUT < [ +CLASS alphabetic+non_capitalized+mixed ] > ].

alphanumeric+upper_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:upper:][:digit:]]+/" ] >,
  +OUTPUT < [ +CLASS alphanumeric+upper ] > ].

alphanumeric+lower_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:lower:][:digit:]]+/" ] >,
  +OUTPUT < [ +CLASS alphanumeric+lower ] > ].

alphanumeric+capitalized+mixed_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:upper:]][[:alnum:]]+/" ] >,
  +OUTPUT < [ +CLASS alphanumeric+capitalized+mixed ] > ].

alphanumeric+non_capitalized+mixed_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:lower:][:digit:]][[:alnum:]]+/" ] >,
  +OUTPUT < [ +CLASS alphanumeric+non_capitalized+mixed ] > ].

non_alphanumeric_tmr := token_class_tmt &
[ +OUTPUT < [ +CLASS non_alphanumeric ] > ].

;;
;; in case we are running without a PoS tagger, or something went wrong in the
;; creation of token AVMs from our input (in one form or another), make sure to
;; fully annul part-of-speech information.
;;
null_tnt_tmr := inpmap-rule &
[ +INPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
             +PRED #pred, +CARG #carg, +ID #id, +FROM #from, +TO #to,
             +TNT [ +TAGS < "FOO", ... > ] ] >,
  +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
              +PRED #pred, +CARG #carg, +ID #id, +FROM #from, +TO #to, 
              +TNT null_tnt ] > ].
|#

;;;
;;; lightweight NEs: form-driven generic entries (formerly `ersatz' entries)
;;;

;;;
;;; Email addresses
;;;

; |danf@stanford.edu|
email-ne-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM
	       "/<?[-a-zA-ZÅåØøÆæ0-9_]{2,}@[-a-zA-ZÅåØøÆæ0-9._]{2,}>?/" ] >,
  +OUTPUT  < [ +CLASS email_ne ] > ].

;;;
;;; URLs
;;;

; |http://www.emmtee.net| and |http : //www.emmtee.net|
url-ne-1-rule := inpmap-ne-31-rule &
  [ +INPUT   < [ +FORM "/(\\(?[<\[]?http)/" ],
	       [ +FORM ":" ],
	       [ +FORM "/(//[-.A-Za-zÅåØøÆæ0-9/_~]+[\]>]?\\)?)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}:${I3:+FORM:1}",
		 +CLASS url_ne ] > ].

; |<www.emmtee.net>|
url-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/<?www\\.[a-zA-ZÅåØøÆæ0-9.?%/_\\-~]+>?/" ] >,
  +OUTPUT  < [ +CLASS url_ne ] > ].

; |<emmtee.net>|
url-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/<?[a-zA-ZÅåØøÆæ]{2,}\\.[a-zA-ZÅåØøÆæ]{2,}>?/" ] >,
  +OUTPUT  < [ +CLASS url_ne ] > ].

; |lingo.stanford.edu|
url-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM 
      "/<?[a-zA-ZÅåØøÆæ]{2,}\\.[a-zA-ZÅåØøÆæ]{2,}\\.[a-zA-ZÅåØøÆæ]{2,}>?/" ] >,
  +OUTPUT  < [ +CLASS url_ne ] > ].

; |<http://emmtee.net>|
; with sandwiched colon, currently not used
url-ne-5-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[<\[]?http:?//.*[\]>]?/" ] >,
  +OUTPUT  < [ +CLASS url_ne ] > ].

;;;
;;; File names
;;;

; |/etc/config|
file-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/\\/[a-zA-Z0-9]+\\/(.*)/" ] >,
  +OUTPUT  < [ +CLASS file_ne ] > ].


;;;
;;; times
;;;

; |10:25pm| (tokenizer separates |:|)
time-ne-1-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-2]?[0-9])/" ],
	     [ +FORM "/(:)/" ],
	     [ +FORM "/([0-5][0-9]([aApP][mM])?)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS time_ne ] > ].

;;;
;;; Ratios
;;;

; |1:1000|
ratio-ne-1-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-9]{1,3})/" ],
             [ +FORM "/(:)/" ],
             [ +FORM "/([0-9]+)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; |1:100,000|
ratio-ne-2-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-9]{1,3})/" ],
             [ +FORM "/(:)/" ],
             [ +FORM "/([0-9]{1,3},[0-9]{3})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; |1:1,000,000|
ratio-ne-3-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-9]{1,3})/" ],
             [ +FORM "/(:)/" ],
             [ +FORM "/([0-9]{1,3},[0-9]{3},[0-9]{3})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS meas_ne ] > ].   

;;;
;;; Numerals
;;;

; |23|
num-or-dom-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-2]?[0-9]/" ] >,
  +OUTPUT  < [ +CLASS card_or_dom_ne ] > ].

; |2005|
num-or-year-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/(mid-)?[0-9]{3,4}/" ] >,
  +OUTPUT  < [ +CLASS card_or_year_ne ] > ].

; |850| |-20|
numeral-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |23,000| or European |23.000|
numeral-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]{1,3}[,.][0-9]{3}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |23,000,000| or |23.000.000|
numeral-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]{1,3}[,.][0-9]{1,3}[,.][0-9]{3}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |23,000.00| |23,000.-|
numeral-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]{1,3}[,.][0-9]{3}[,.]([0-9]{2}|-)/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |.52|
numeral-ne-5-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]*[.][0-9]+/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

;;;
;;; Section numbers
;;;

; |3.2.4|
section-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+\\.[0-9]+\\.[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].   

;;;
;;; Fractions
;;;

; |2/3|
fraction-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,2}\/[0-9]{1,3}/" ] >,
  +OUTPUT  < [ +CLASS frct_ne ] > ].   

; with space
; |2 1/3|
fraction-ne-2-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([0-9]+)/" ],
  	     [ +FORM "/([0-9]{1,2}\/[0-9]{1,3})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1} {I2:+FORM:1}",
	       +CLASS card_ne ] > ].

;;;
;;; Dates
;;;

; |12-12-2005| |12/12/2005| |12-12-05| |12/12/05|
date-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,2}[-/][0-9]{1,2}[-/][0-9]{2,4}/" ] >,
  +OUTPUT  < [ +CLASS date_ne ] > ].   

; |12-2005| |12/05| |12-05| |12/05|
date-ne-2-rule := inpmap-ne-11-opt-rule &
[ +CONTEXT < [ +FORM "/[0-9]{1,2}[-/][0-9]{2,4}/" ] >,
  +OUTPUT  < [ +CLASS date_ne ] > ].   

;;;
;;; reduced year names; possibly another case where, in full generality, we
;;; would have to be able to strip off the leading apostrophe first and later, 
;;; in the token-level part, introduce a tokenization alternative, re-uniting
;;; the apostrophe and two-digit year.
;;;

; |'06|
year-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/'[0-9][0-9]/" ] >,
  +OUTPUT  < [ +CLASS year_ne ] > ].   

; |1992-94| |2005-2008|
year-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{4}-[0-9]{2,4}/" ] >,
  +OUTPUT  < [ +CLASS year_ne ] > ].   

;;;
;;; Phone numbers
;;;

; |(415) 555-1212|
phone-us-ne-1-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/(\\(?[0-9]{3}\\)?)/" ],
	     [ +FORM "/([0-9]{3}-[0-9]{4})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1} ${I2:+FORM:1}",
	       +CLASS phone_ne ] > ].   

; |(415)555-1212|
phone-us-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/\\([0-9]{3}\\)[0-9]{3}-[0-9]{4}/" ] >,
  +OUTPUT  < [ +CLASS phone_ne ] > ].   

; |555-1212|
phone-us-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{3}-[0-9]{4}/" ] >,
  +OUTPUT  < [ +CLASS phone_ne ] > ].   

; |23 23 23 23|
phone-eur-ne-1-rule := inpmap-ne-41-rule &
[ +INPUT   < [ +FORM "/([0-9]{2})/" ],
	     [ +FORM "/([0-9]{2})/" ],
	     [ +FORM "/([0-9]{2})/" ],
	     [ +FORM "/([0-9]{2})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1} ${I2:+FORM:1} ${I3:+FORM:1} ${I4:+FORM:1}",
	       +CLASS phone_ne ] > ].   

;;;
;;; Numerical ranges
;;;

; |23-25|
range-num-or-dom-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-2]?[0-9]-[0-2]?[0-9]/" ] >,
  +OUTPUT  < [ +CLASS card_or_dom_ne ] > ].   

; |50-60|
range-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,3}[.]?-[0-9]{1,3}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].   

; |2-3.4| and European |2-3,4| 
range-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,3}-[0-9]{1,3}[.,][0-9]{1,2}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].   

; |2.5-3.4| and European |2,5-3,4| 
range-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,3}[.,][0-9]{1,2}-[0-9]{1,3}[.,][0-9]{1,2}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].   

; |IV-VII|
range-ne-4-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([IV]+)-/" ],
             [ +FORM "/([IV]+)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS card_ne ] > ].   

;;;
;;; Decades
;;;

; |1950s|
decade-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/(mid-)?1[0-9][0-9]0[sS]/" ] >,
  +OUTPUT  < [ +CLASS plur_ne ] > ].   

; |50s|
decade-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]0[sS]/" ] >,
  +OUTPUT  < [ +CLASS plur_ne ] > ].   

; |1950's|
decade-ne-3-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/(1[0-9][0-9]0)/" ],
	     [ +FORM "/('[sS])/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS plur_ne ] > ].   

; |50's|
decade-ne-4-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([0-9]0)/" ],
	     [ +FORM "/('[sS])/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS plur_ne ] > ].   

;;;
;;; Ordinal numbers
;;;

; day-of-month or ordinal
; |21st| |22nd| |23rd| |24th|
ordinal-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/([1,2]?1st|[1,2]?2nd|[1,2]?3rd|[1,2]?[4567890]th)/" ] >,
  +OUTPUT  < [ +CLASS ord_or_dom_ne ] > ].

; |221st| |222nd| |223rd| |224th|
ordinal-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/([0-9]*1st|[0-9]*2nd|[0-9]*3rd|[0-9]*[4567890]th)/" ] >,
  +OUTPUT  < [ +CLASS ord_ne ] > ].

; day-of-month or ordinal
; |24 th|
ordinal-ne-3-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([1,2]?[4567890])/" ],
	     [ +FORM "/(th)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS ord_or_dom_ne ] > ].

; |224 th|
ordinal-ne-4-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([0-9]*[4567890])/" ],
	     [ +FORM "/(th)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS ord_ne ] > ].


;;;
;;; Alphanumeric identifiers
;;;

; |ABC123DEF|
alphanum-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]*[a-zA-ZÅåØøÆæ]+[0-9]+[a-zA-ZÅåØøÆæ0-9]*/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |22(B)| |22B|
alphanum-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+\\(?[A-ZÅØÆ]+[A-ZÅØÆ0-9]*\\)?/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |B.25| |IL-10| |IL/10|
alphanum-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]*[A-ZÅØÆ]+[-./][A-ZÅØÆ]*[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |123-45-6789|
alphanum-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,4}[-][0-9]{1,4}[-][0-9]{1,4}/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |22-b|
alphanum-ne-5-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+[-][a-zA-ZÅåØøÆæ]/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

;;;
;;; Measure NPs
;;;

; |25cm|
measure-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+([mM'\"kK]|cm|mm|σ|(º[CF]?))/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].

; |25.5cm|
measure-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+[,.][0-9]+([mM'\"kK]|cm|mm|σ|(º[CF]?))/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].

; |1:1000m|
measure-ne-3-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-9]{1,3})/" ],
             [ +FORM "/(:)/" ],
             [ +FORM "/([0-9]+([mM'\"kK]|cm|mm|σ|(º[CF]?)))/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; DPF 01-sept-08 FIX
; Segmentation violation when parsing "$20-$30 arrives"
;
; |$20-$30|
#|
measure-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/\\$[0-9]+-\\$[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].
|#

; |$20 - $30|
measure-ne-5-rule := inpmap-ne-51-rule &
[ +INPUT   < [ +FORM "$" ],
	     [ +FORM "/([0-9]+)/" ],
	     [ +FORM "-" ],
	     [ +FORM "$" ],
	     [ +FORM "/([0-9]+)/" ] >,
  +OUTPUT  < [ +FORM "\$${I2:+FORM:1}-\$${I5:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; |US$20|
measure-ne-6-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/US\\$[0-9]/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].

; |US $20|
measure-ne-7-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/US/" ],
	     [ +FORM "/\\$[0-9]/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS meas_ne ] > ].

; DPF 15-sept-08 - Now using separate :xml preprocessor module
#|
;;;
;;; Normalize surviving XML punctuation marks
;;;

xml-mdash-rule := inpmap-rule &
  [ +CONTEXT < >,
    +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(&mdash;)([A-Za-zÅåØøÆæ0-9]*)/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt ],
    	       [ +FORM "-", +TNT #tnt ],
	       [ +FORM "${I1:+FORM:3}", +TNT #tnt ] > ].

xml-mdash2-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(& mdash;)([A-Za-zÅåØøÆæ0-9]*)/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt ],
    	       [ +FORM "-", +TNT #tnt ],
	       [ +FORM "${I1:+FORM:3}", +TNT #tnt ] > ].

xml-ndash-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(&ndash;)([A-Za-zÅåØøÆæ0-9]*)/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt ],
    	       [ +FORM "-", +TNT #tnt ],
	       [ +FORM "${I1:+FORM:3}", +TNT #tnt ] > ].

xml-ndash2-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(& ndash;)([A-Za-zÅåØøÆæ0-9]*)/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt ],
    	       [ +FORM "-", +TNT #tnt ],
	       [ +FORM "${I1:+FORM:3}", +TNT #tnt ] > ].

xml-rsquote-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(&rsquo; s)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'s" ] > ].

xml-rsquote2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(& rsquo; s)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'s" ] > ].

xml-rsquote3-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(\)(rquote s)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'s" ] > ].

xml-rsquote4-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(rquote s)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'s" ] > ].

xml-rsquotepl-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(&rsquo;)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'" ] > ].

xml-rsquotepl2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(& rsquo;)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'" ] > ].

xml-rsquotepl3-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(\)(rquote)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'" ] > ].

xml-rsquotepl4-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(rquote)/"] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'" ] > ].

xml-rsquotepl5-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(\)(rquote)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'" ] > ].

xml-rsquotepl6-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(\222)" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'" ] > ].

xml-rdquote-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)&rdquo;([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"" ] > ].

xml-rdquote2-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)&/", +TNT #tnt ],
	       [ +FORM "/rdquo;([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"${I2:+FORM:1}", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

xml-rdquote3-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)\“([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"${I1:+FORM:2}" ] > ].

xml-rdquote4-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)\”([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"${I1:+FORM:2}" ] > ].

xml-rdquote5-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)â€œ([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"${I1:+FORM:2}" ] > ].

xml-rdquote6-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)â€�([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"${I1:+FORM:2}" ] > ].

xml-rdquote7-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)”/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"" ] > ].

xml-ldquote-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/&ldquo;([A-Za-zÅåØøÆæ0-9]+)([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "\"${I1:+FORM:1}${I1:+FORM:2}" ] > ].

xml-ldquote2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/& ldquo;([A-Za-zÅåØøÆæ0-9]+)([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "\"${I1:+FORM:1}${I1:+FORM:2}" ] > ].

xml-ldquote3-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/“([A-Za-zÅåØøÆæ0-9]+)([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "\"${I1:+FORM:1}${I1:+FORM:2}" ] > ].

xml-quot-init-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/&quot;([A-Za-zÅåØøÆæ0-9&]+)([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "\"${I1:+FORM:1}${I1:+FORM:2}" ] > ].

xml-quot2-init-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/&/" ],
	       [ +FORM "/quot;([A-Za-zÅåØøÆæ0-9&]+)([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "\"${I2:+FORM:1}${I2:+FORM:2}" ] >,
    +POSITION "I1<I2" ].

xml-quot-final-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([\"A-Za-zÅåØøÆæ0-9\.]+)([.\?!,;\":\)]*)&quot;/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"" ] > ].

xml-quot2-final-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([\"A-Za-zÅåØøÆæ0-9\.]+)([.\?!,;\":\)]*)&/" ],
               [ +FORM "/quot;/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"" ] >,
    +POSITION "I1<I2" ].

xml-vertbar-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)¦" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ] > ].

xml-apos-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)&apos;/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'" ] > ].

xml-apos2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)& apos;/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}'" ] > ].

xml-amp-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/&amp;/" ] >,
    +OUTPUT  < [ +FORM "&" ] > ].

xml-amp2-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/&/" ],
               [ +FORM "/amp;/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "&", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

xml-percnt-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)&percnt;/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}%" ] > ].

xml-percnt2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)& percnt;/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}%" ] > ].

xml-bull-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/&bull;/" ] >,
    +OUTPUT  < [ +FORM "" ] > ].

xml-bull2-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/&/" ],
    	       [ +FORM "/bull;/" ] >,
    +OUTPUT  < [ +FORM "" ] >,
    +POSITION "I1<I2" ].

xml-sol-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/&sol;/" ] >,
    +OUTPUT  < [ +FORM "/" ] > ].

xml-sol2-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/&/" ],
    	       [ +FORM "/sol;/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "/", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

xml-deg-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([0-9]+)&/" ], 
	       [ +FORM "/deg;/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}º", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

xml-deg2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([0-9]+)°/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}º" ] > ].

xml-u0020-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/\u0020/" ] >,
    +OUTPUT  < > ].

xml-unichar1-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/�/" ] >,
    +OUTPUT  < [ +FORM ":"] > ].

xml-unichar2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/�/" ] >,
    +OUTPUT  < [ +FORM "-"] > ].

xml-unichar3-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/�/" ] >,
    +OUTPUT  < [ +FORM "-"] > ].

xml-unichar4-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/∼/" ] >,
    +OUTPUT  < [ +FORM "~"] > ].

xml-unichar5-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/Þ/" ] >,
    +OUTPUT  < > ].

xml-unichar6-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/¤/" ] >,
    +OUTPUT  < > ].

xml-emph-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/<emph>/" ] >,
    +OUTPUT  < > ].

xml-emph2-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/</" ],
    	       [ +FORM "/emph/" ],
	       [ +FORM "/>/" ] >,
    +OUTPUT  < >,
    +POSITION "I1<I2<I3" ].

xml-emph3-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/</emph>/" ] >,
    +OUTPUT  < > ].

xml-emph4-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/</" ],
    	       [ +FORM "//emph/" ],
	       [ +FORM "/>/" ] >,
    +OUTPUT  < >,
    +POSITION "I1<I2<I3" ].

xml-emph5-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/< emph etype= \" bold \" >/" ] >,
    +OUTPUT  < > ].

xml-emph6-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/< emph etype= \" boldital \" >/" ] >,
    +OUTPUT  < > ].

xml-linebr-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/<linebrk/>/" ] >,
    +OUTPUT  < > ].

xml-linebr2-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/</" ],
    	       [ +FORM "/linebrk//" ],
	       [ +FORM "/>/" ] >,
    +OUTPUT  < >,
    +POSITION "I1<I2<I3" ].

xml-dotfill-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/</" ],
    	       [ +FORM "/dotfill/", +TNT #tnt ],
	       [ +FORM "/>/" ] >,
    +OUTPUT  < [ +FORM "threedot", +TNT #tnt ] >,
    +POSITION "I1<I2<I3" ].

;;;
;;; Correct spurious formatting character sequences
;;;

xml-charseq1-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "\*" ], [ +FORM "\*" ], [ +FORM "h", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM ".", +TNT #tnt ] >,
    +POSITION "I1<I2<I3" ].

xml-charseq2-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "\*" ], [ +FORM "\*" ], [ +FORM "f" ], [ +FORM "/([A-Za-zÅåØøÆæ0-9,.\?]+)/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I4:+FORM:1}", +TNT #tnt ] >,
    +POSITION "I1<I2<I3<I4" ].

xml-charseq3-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/``\\./" ] >,
    +OUTPUT  < [ +FORM "."] > ].

xml-charseq4-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "," ], [ +FORM ",", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM ",", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

xml-charseq5-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "\*", +FROM #from ], [ +FORM "\*" ], [ +FORM "h", +TNT #tnt, +TO #to ] >,
    +OUTPUT  < [ +FORM ";", +TNT #tnt, +FROM #from, +TO #to ] >,
    +POSITION "I1<I2<I3" ].

xml-charseq6-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "\*", +FROM #from ], [ +FORM "\*" ], [ +FORM "f", +TNT #tnt, +TO #to ] >,
    +OUTPUT  < [ +FORM " ", +TNT #tnt, +FROM #from, +TO #to ] >,
    +POSITION "I1<I2<I3" ].
|#

strip-char1-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9.\?!\)]+)( )/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ] > ].

strip-char2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/( )([A-Za-zÅåØøÆæ0-9.\?!\)]+)( )/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; Replace |«| and |»| with |"|
;;;
euro-quote-left-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/«([a-zA-ZÅåØøÆæ0-9ÅåØøÆæ']*)([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "\"${I1:+FORM:1}${I1:+FORM:2}" ] > ].

euro-quote-right-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9ÅåØøÆæ.\?']*)»([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"${I1:+FORM:2}" ] > ].

euro-quote-both-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/«([a-zA-ZÅåØøÆæ0-9ÅåØøÆæ']+)»([.\?!,;\":\)]*)/" ] >,
    +OUTPUT  < [ +FORM "\"${I1:+FORM:1}\"${I1:+FORM:2}" ] > ].

;;;
;;; separate hash sign from right-adjacent number(s)
;;;
hash-num-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/(#)([0-9])+/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
       	       [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; separate multiple dots from left host
;;;
separate-dots-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(\\.{3,})/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
	       [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; Replace three or more dots with token 'threedot '
;;;
threedot-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/(['`\"])?\\.{3,}/" ] >,
    +OUTPUT  < [ +FORM "threedot" ] > ].

threedot-rule-2 := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "threedot", +TNT #tnt ], 
	       [ +FORM "/\\.{2,}/" ] >,
    +OUTPUT  < [ +FORM "threedot", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; replace two dots with hyphen - used for ranges as in |26 .. 62|
;;;
twodot-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/\\.\\./" ] >,
    +OUTPUT  < [ +FORM "twodot" ] > ].

;;;
;;; Replace separator line of equal signs with a period.
;;;
equalsigns-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/={3,}/" ] >,
    +OUTPUT  < [ +FORM "." ] > ].

;;;
;;; Catch asterisks used for emphasis
;;;

asterisk-emphasis-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "\*" ], [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)\\*/", +TNT #tnt ]>,
    +OUTPUT  < [ +FORM "${I2:+FORM:1}", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Only for robust EC, VM: drop commas (sentence-final, pauses, etc)
;;;
;final-comma-rule := inpmap-x11-rule &
;  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9'\\.]+),/" ] >,
;    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ] > ].

;;;
;;; Replace – with -
;;;

norm-hyphen-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)–([a-zA-ZÅåØøÆæ0-9]*)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}-${I1:+FORM:2}" ] > ].

;;;
;;; Separate funny punctuation with whitespace on either side from the
;;; preceding and following word(s).
;;; Includes =#$%~\(§§
;;;

punct-right-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)([=#$%~\(§§])+/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ],
    	       [ +FORM "${I1:+FORM:2}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] > ].

punct-left-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([=#$%~+*\)§§]+)([a-zA-ZÅåØøÆæ0-9]+)/", +TNT #tnt,
	         +ONSET #onset, +CLASS #class ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ],
               [ +FORM "${I1:+FORM:2}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] > ].

;;;
;;; DPF 18-oct-06 - Temporarily replace |+| with |plus| for PET tokenizer bug
;;;
plus-plus-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/\\+/" ] >,
    +OUTPUT  < [ +FORM "plus" ] > ].

;;;
;;; For now, simplify punctuation clusters found in subordinate quoted Ss, as
;;; in "Who arrived?, she asked"  since current suffixing machinery doesn't
;;; produce result.  Also for "... two hrs., ..." FIX
;;;
punct-cluster-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)[.?!](,)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

;;;
;;; Also simplify awkward clause-final clusters
;;;

punct-cluster2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*)([:\\]])([.?])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:3}" ] > ].

punct-cluster3-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*)([\"\)])([:])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

punct-cluster4-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*),/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ],
      	       [ +FORM "/([.?])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

punct-cluster5-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*)([.\?])([\)])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

; Eliminate spurious second comma
punct-cluster6-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*),/", +TNT #tnt ], [ +FORM "," ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1},", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

; Eliminate quotes with threedots: |cats...'|
punct-cluster7-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "threedot", +TNT #tnt ], [ +FORM "/['\"]/" ] >,
    +OUTPUT  < [ +FORM "threedot", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

punct-cluster8-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/['`\"]/" ], [ +FORM "threedot", +TNT #tnt ]>,
    +OUTPUT  < [ +FORM "threedot", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Eliminate spaces for pair of double quotes when space on both sides
;;;

quote-pair-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"])/" ],
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)([.?]*)/", 
		 +TNT #tnt, +ONSET #onset, +CLASS #class ],
	       [ +FORM "/([\"])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I2:+FORM:2}${I3:+FORM:1}",
		 +TNT #tnt, +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2<I3" ].

;;;
;;; Add one more hack for sentence-final double-quote, where we've already
;;; swallowed the padded final space
;;;
final-doubleq-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/(\")([.?!])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

;;;
;;; Add white space to the right of squished commas and colons
;;; except for numbers on both sides (but separate e.g. |2-day| and |V-neck|)
;;; Same for periods between capital letters: "D.B. Smith", "2.Kim"
;;; Add white space on both sides for forward slash
;;;
squished-punct1-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
 "/([\(\*]*)([a-zA-ZÅåØøÆæ\\-]+)([,:])([a-zA-ZÅåØøÆæ@.\\-]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct2-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
		 "/([\(]*)([0-9]+)([,:])([a-zA-ZÅåØøÆæ]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct3-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM 
   "/([\(]*)([0-9.]+)(-)([a-zA-ZÅåØøÆæ][a-zA-ZÅåØøÆæ-]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct4a-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
   "/([\(\*]*)([a-zA-ZαβΔÅåØøÆæ']+)([-,:\/])([a-zA-ZÅåØøÆæ']+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

; Allow digits and "s" to right of dash, for eg "mid-1900s" and "mid-1900's"
squished-punct4b-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
            "/([\(\*]*)([a-zA-ZαβΔÅåØøÆæ]+)([,:-])([0-9']+)s([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}s${I1:+FORM:5}" ] > ].

squished-punct5-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
                 "/([\(]*)([a-zA-ZÅåØøÆæ]+)([,:])([0-9]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "$${I1:+FORM:1}{I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct6-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM 
        "/([\(]*)([A-ZÅØ0-9]+)(\\.)([A-ZÅØ+])(\\.)([A-ZÅØ]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
    	       [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ],
               [ +FORM "${I1:+FORM:6}${I1:+FORM:7}" ] > ].

squished-punct7-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([A-ZÅØ0-9]+)(\\.)([A-ZÅØ]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

; Replace squished slash with double slash token which is limited to
; lexical conjunction.
squished-punct9-rule := inpmap-x13-rule &
[ +INPUT   < [ +FORM 
	 "/([\(]*)([a-zA-ZÅåØøÆæ-]+)([→/])([a-zA-ZÅåØøÆæ-]+)([.\?!,;\":\)]*)/",
	       +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "//" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct10-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([a-zA-ZÅåØøÆæ]+)(/)/", +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ] > ].

squished-punct11-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([0-9]+)(/)([a-zA-ZÅåØøÆæ]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct12-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([a-zA-ZÅåØøÆæ]=)(/)([0-9]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct13-rule := inpmap-x14-rule &
  [ +INPUT   < [ +FORM 
     "/([\(]*)([a-zA-ZÅåØøÆæ]+)(-)(a)(-)([a-zA-Z0-9ÅåØøÆæ]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ],
    	       [ +FORM "${I1:+FORM:6}${I1:+FORM:7}" ] > ].

squished-punct15-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
	"/([\(\"]*)([a-zA-Z0-9ÅåØøÆæ]+)(-)([a-zA-ZÅåØøÆæ-]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

;;;
;;; Eliminate space for double quote when space on both sides
;;;

quote-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"])/", +FROM #from ],
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)([.?]*)/", +ID #id, +TO #to, 
		 +TNT #tnt, +ONSET #onset, +CLASS #class & stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I2:+FORM:2}",
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

double_lquote-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/``/", +FROM #from ],
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9'\)\-]+)([.?,]*)/", +ID #id, 
	         +TO #to, +TNT #tnt, +ONSET #onset, +CLASS #class & stdorth ]>,
    +OUTPUT  < [ +FORM "\"${I2:+FORM:1}${I2:+FORM:2}", +ID #id, +FROM #from,
		 +TO #to, +TNT #tnt, +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

double_lquote-space-rule-2 := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/``([a-zA-ZÅåØøÆæ0-9'\)\-]+)([.?,]*)/",
	         +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "\"${I1:+FORM:1}${I1:+FORM:2}" ] > ].

double_rquote-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,!]*)/", 
		 +ID #id, +FROM #from, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & stdorth ],
	       [ +FORM "/''([.?,\)]*)/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"${I2:+FORM:1}", 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

double_rquote-space-b-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,]*)/", 
		 +ID #id, +FROM #from, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & stdorth ],
	       [ +FORM "/([.;,'!\?\\]\)]+)/" ],
	       [ +FORM "/''/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I2:+FORM:1}\"", 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & stdorth ] >,
    +POSITION "I1<I2<I3" ].

double_rquote-space-c-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,]*)''/", 
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"" ] > ].

double_rquote-space-d-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)\\.?''([.?,\)]+)/", 
	         +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"${I1:+FORM:2}" ] > ].

double_rquote-space-e-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([.?,]+)''/", +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"" ] > ].

double_rquote-space-2-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,]*)/", 
		 +ID #id, +FROM #from, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & stdorth ],
	       [ +FORM "/\"/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"", 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & stdorth ] >,
    +POSITION "I1<I2" ].

;;; 
;;; Add proper name entry for italicized tokens
;;;

; |''chatterbot''|
italics-1a-rule := inpmap-rule &
   [ +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/(.*)/",
		+TNT #tnt, +ID #id, +CLASS #class ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
     +OUTPUT  < [ +FORM "${I2:+FORM:1}",
		  +CLASS italics_ne, 
		  +TNT null_tnt, +ID #id, +FROM #from, +TO #to ],
		[ +FORM "${I2:+FORM:1}",
		  +CLASS #class,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "I1<I2<I3, O1=O2" ].

; |''(chatterbot)''|
italics-1b-rule := inpmap-rule &
   [ +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/(\\()/" ],
	      [ +FORM "/(.*)/",
		+TNT #tnt, +ID #id, +CLASS #class ],
	      [ +FORM "/(\\))/" ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
     +OUTPUT  < [ +FORM "${I2:+FORM:1}${I3:+FORM:1}${I4:+FORM:1}",
		  +CLASS italics_ne, 
		  +TNT null_tnt, +ID #id, +FROM #from, +TO #to ],
		[ +FORM "${I2:+FORM:1}${I3:+FORM:1}${I4:+FORM:1}",
		  +CLASS #class,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "I1<I2<I3<I4<I5, O1=O2" ].

; |''chatter bot"|
italics-2a-rule := inpmap-rule &
 [ +CONTEXT < [ +FORM "/(.*)/",
		+TNT #tnt1, +ID #id1, +CLASS #class1 ],
	      [ +FORM "/(.*)/",
		+TNT #tnt2, +ID #id2, +CLASS #class2 ] >,
     +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
    +OUTPUT < [ +FORM "${C1:+FORM:1} ${C2:+FORM:1}",
		+CLASS italics_ne, 
		+TNT null_tnt, +ID #id2, +FROM #from, +TO #to ] >,
   +POSITION "I1<C1<C2<I2" ].

; |''(chatter bot)"|
italics-2b-rule := inpmap-rule &
 [ +CONTEXT < [ +FORM "/(.*)/",
		+TNT #tnt1, +ID #id1, +CLASS #class1 ],
	      [ +FORM "/(.*)/",
		+TNT #tnt2, +ID #id2, +CLASS #class2 ] >,
     +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/(\\()/" ],
	      [ +FORM "/(\\))/" ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
    +OUTPUT < [ +FORM "${I2:+FORM:1}${C1:+FORM:1} ${C2:+FORM:1}${I3:+FORM:1}",
		+CLASS italics_ne, 
		+TNT null_tnt, +ID #id2, +FROM #from, +TO #to ] >,
   +POSITION "I1<I2<C1<C2<I3<I4" ].

; Remove stranded italics quotes (around three or more tokens)
;
; For some reason, can't just delete this token - all following tokens also
; get deleted
#|
delete-italics-left-rule := inpmap-rule &
   [ +INPUT < [ +FORM "/“/" ] >,
     +OUTPUT <  > ].
|#

delete-italics-left-rule := inpmap-rule &
   [ +INPUT  < [ +FORM "“", +FROM #from ],
	       [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +TO #to, +TNT #tnt ] >,
     +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >,
   +POSITION "I1<I2" ].


delete-italics-right-rule := inpmap-rule &
   [ +INPUT  < [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TNT #tnt ],
	       [ +FORM "”", +TO #to ] >,
     +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >,
   +POSITION "I1<I2" ].

; This should maybe be done instead in wiki.fsr
;
; |played[,]|
bracketed-comma-rule := inpmap-rule &
   [ +INPUT < [ +FORM "[" ],
	      [ +FORM ",", +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ],
	      [ +FORM "]" ] >,
     +OUTPUT < [ +FORM ",", +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >, 
     +POSITION "I1<I2<I3" ].

;;;
;;; re-combine punctuation marks with adjacent tokens, based on directionality
;;; of punctuation marks, e.g. opening vs. closing quotes and brackets.  doing
;;; one such re-combination at a time is sufficient, as each rewrite rule will
;;; apply as many times as it possibly can, seeing its own output from earlier
;;; applications.
;;;
prefix_punctuation_tmr := inpmap-rule &
  [ +INPUT   < [ +FORM "/([[({“‘“]+)/",
                 +FROM #from ],
               [ +FORM "/(.+)/",
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
                 +TO #to, +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
                 +FROM #from, +TO #to, +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;
;; _fix_me_
;; there is a special case here: |'| following a token ending in |s| could be a
;; possessive marker (which should remain a token in its own right), or could 
;; be a closing single quote.  in principle, the same is true for |"|, but the
;; `feet' measure unit, possibly, will have been detected during NE recognition
;; earlier.  in either case, we would need a way of keeping a separate |'| in
;; the chart, and also re-combine it with the preceding token.  (14-sep-08; oe)
;;
suffix_punctuation_tmr := inpmap-rule &
  [ +INPUT   < [ +FORM "/(.+)/",
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
                 +FROM #from, +TNT #tnt ],
               [ +FORM "/([])}”\"’”,;.!?#]+)/",
                 +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
                 +FROM #from, +TO #to, +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Eliminate spurious space preceding and following most punctuation marks
;;; This includes removal of spaces introduced around punctuation in 
;;; tokenization step.
;;;


space-punct-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/(.*)/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
		 +FROM #from ],
               [ +FORM "/([.;,'!\?\\]\)]+)/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
		 +FROM #from, +TO #to ] >,
    +POSITION "I1<I2" ].

paren-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\(\\[])/" ],
	       [ +FORM "/([\"]*)([a-zA-ZÅåØøÆæ0-9:;,.!\"\?\/]+)([\\]\)]*)/", 
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
		 +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I2:+FORM:2}${I2:+FORM:3}",
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
		 +TNT #tnt ] >,
    +POSITION "I1<I2" ].

quote-qmark-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9\*\\]\"\-\/,]+)/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ],
               [ +FORM "/([\"])/" ],
	       [ +FORM "/([\?])/" ]>,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}", +TNT #tnt,
 		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +POSITION "I1<I2<I3" ].

;;;
;;; Eliminate any string-initial stranded punctuation (from faulty segmentatn)
;;;
stranded-punct-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([;,.!\)\?\\*]+)/" ],
               [ +FORM "/([a-zA-ZÅåØøÆæ0-9\\-\?]+)/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +OUTPUT  < [ +FORM "${I2:+FORM:1}", +TNT #tnt,
 		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +POSITION "I1<I2" ].

solitary-punct-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9!.\)\\-\?]+)/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ], 
               [ +FORM "/([;,.!\)\\*]+)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +POSITION "I1<I2" ].

;;;
;;; Parenthetical plurals - remove parens
;;;
paren-plural-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ]*)\\(s\\)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}s" ] > ].

;;;
;;; Add white space to left of ( and [
;;;
space-lbrack-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([\(\[])/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ],
    	       [ +FORM "${I1:+FORM:2}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] > ].
;;;
;;; Add white space around colon if sandwiched with following alphanumeric
;;; (but not e.g. |http://...| and not ratios with numbers on both sides)
;;;
squished-punct16-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([:])([a-zA-ZÅåØøÆæ]+)/", 
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}" ] > ].

squished-punct17-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ.]+)([:])([a-zA-ZÅåØøÆæ0-9]+)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}" ] > ].

;;;
;;; And add white space to the left of colon when followed by white space:
;;;
squished-punct18-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([:])/", +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; And the variants with surrounding punctuation
;;;
squished-punct19-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ]+)([,/])([a-zA-ZÅåØøÆæ]+)([.?!,;])/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

squished-punct20-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([0-9]+)([,/])([a-zA-ZÅåØøÆæ]+)([.?!,;])/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

squished-punct21-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ])([,/])([0-9])([.?!,;])/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

;;;
;;; Add space to left of left paren and to right of right paren
;;;

squished-punct22-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
      "/([\(]*)([a-zA-ZÅåØøÆæ]+)([\(\[])([a-zA-ZÅåØøÆæ0-9]+)([.\?!,;\":\)]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct23-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
     "/([\(]*)([a-zA-ZÅåØøÆæ]+)([\\]\)])([a-zA-ZÅåØøÆæ0-9]+)([.\?!,;\":\)]*)/",
                 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct24-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([—])([a-zA-ZÅåØøÆæ]+)([.?,]*)/",
		 +CLASS stdorth ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "---" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

;;;
;;; apostrophes are a bit tricky: generally, we want to separate leading and 
;;; trailing single quotes from adjacent word material, so that they become a
;;; separate token (e.g. |abrams'| --> |abrams '|); the possessive |'s|, on 
;;; the other hand, we want to separate but then consider a single token.
;;;
apostrophe-s-1-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(\"]?)([a-zA-XÅåØøÆæ0-9]+[sS])'/",
		 +ONSET con_or_voc ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "'" ] > ].

apostrophe-s-2-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(\"]?)([a-zA-XÅåØøÆæ0-9.]+)'[sS]/",
		 +ONSET con_or_voc ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "'s" ] > ].

apostrophe-s-3-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(\"]?)([a-zA-XÅåØøÆæ0-9]+)'[sS]([.?!,;\"])/", 
		 +ONSET con_or_voc ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "'s${I1:+FORM:3}" ] > ].

;;;
;;; split off other contracted auxiliaries
;;;
contracted-aux-ll-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(\"]?)([A-Za-zÅåØøÆæ]+)('ll|'LL)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ], 
	       [ +FORM "${I1:+FORM:3}" ] > ].

contracted-aux-d-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(\"]?)([A-Za-zÅåØøÆæ]+)('[dD])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ], 
	       [ +FORM "${I1:+FORM:3}" ] > ].

contracted-aux-ve-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(\"]?)([A-Za-zÅåØøÆæ]+)('ve|'VE)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ], 
	       [ +FORM "${I1:+FORM:3}" ] > ].

contracted-aux-m-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(\"]?)([A-Za-zÅåØøÆæ]+)('[mM])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ], 
	       [ +FORM "${I1:+FORM:3}" ] > ].

contracted-aux-re-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(\"]?)([A-Za-zÅåØøÆæ]+)('re|'RE)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ], 
	       [ +FORM "${I1:+FORM:3}" ] > ].

;;;
;;; PTB repairs
;;;

contracted-neg-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ]+)/", +TNT #tnt ], [ +FORM "/n't([.\?!,;:\\-]*)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}n't${I2:+FORM:1}", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Remove space after initial "O'" and "L'"
;;;
space-after-o-l-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([lLoO])'/", +TNT #tnt ], 
	       [ +FORM "/([a-zA-ZÅåØøÆæ]+)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}'${I2:+FORM:1}", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Replace left and right angle marks with variant, to avoid communication 
;;; troubles among preprocessor, [incr tsdb()], and PET.
;;;
leftangle-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/< /" ] >,
    +OUTPUT  < [ +FORM "leftangle " ] > ].

rightangle-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/ >/" ] >,
    +OUTPUT  < [ +FORM " rightangle" ] > ].

;;;
;;;  Squished compounds
;;;

split-compound-1-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/(back)(country)/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt ], [ +FORM "${I1:+FORM:2}", +TNT #tnt ] > ].

;;;
;;; Irregular spelling rules
;;;

#|
lie-rule := inpmap-x11-rule &
  [ +CONTEXT < [ +FORM "lay"] >,
    +OUTPUT  < [ +LEXID "$lie_v3",
		 +INFLR "$past_verb_orule" ] > ].

put-rule := inpmap-x11-rule &
  [ +CONTEXT < [ +FORM "put"] >,
    +OUTPUT  < [ +STEM "put",
		 +INFLR "$past_verb_orule" ] > ].
|#

;;;
;;; Assign +CLASS for words with leading uppercase, so we keep these unknowns.
;;; But for now, not on sentence initial words.
;;;

mixed-case-proper-1-rule := inpmap-rule &
   [ +CONTEXT < [ ] >,
     +INPUT < [ +FORM "/([A-ZÅØ])([A-Za-zÅåØøÆæ0-9,.\?]*)/",
		+TNT #tnt & [ +TAGS.FIRST "NNP" ],
		+ID #id, +FROM #from, +TO #to ] >,
     +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}",
		  +CLASS initcap,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "C1<I1" ].

mixed-case-proper-2-rule := inpmap-rule &
   [ +CONTEXT < [ ] >,
     +INPUT < [ +FORM "/([A-ZÅØ])([A-Za-zÅåØøÆæ0-9,.\?]*)/",
		+TNT #tnt & [ +TAGS.REST.FIRST "NNP" ],
		+ID #id, +FROM #from, +TO #to ] >,
     +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}",
		  +CLASS initcap,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "C1<I1" ].

;;;
;;; Make everything remaining be lower case - see GG
;;;

lower-case-rule := inpmap-011-rule &
   [ +INPUT   < [ +FORM "/(.*[A-ZÄÖÜØÅ].*)/" ] > ,
     +OUTPUT  < [ +FORM "${lc(I1:+FORM:1)}" ] > ].

;;;
;;; Spelling correction
;;;

everytime-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "everytime"] >,
    +OUTPUT  < [ +FORM "every" ],
	       [ +FORM "time" ] > ].

dont-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "dont"] >,
    +OUTPUT  < [ +FORM "don't" ] > ].

wont-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "wont"] >,
    +OUTPUT  < [ +FORM "won't" ] > ].

recieve-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "recieve"] >,
    +OUTPUT  < [ +FORM "receive" ] > ].

labled-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "labled"] >,
    +OUTPUT  < [ +FORM "labeled" ] > ].

didnt-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "didn;t"] >,
    +OUTPUT  < [ +FORM "didn't" ] > ].

didnt-rule-2 := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "didn;", +TNT #tnt],
	       [ +FORM "t"]>,
    +OUTPUT  < [ +FORM "didn't", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; at this point, we multiply out PoS values on all tokens, where for each
;;; original token as many additional tokens are created (in the same chart
;;; cell) as there are PoS readings.  at this point, we start distinguishing
;;; between tokens that activate native lexical entries (LEs), vs. those that
;;; activate generic LEs.  in the token universe, this distinction is made by
;;; virtue of +ONSET, with unk_onset reserved for generic LEs.  the two sets
;;; do not overlap, i.e. for a single original token with two PoS readings, we
;;; end up with a total of three new tokens.  the pair of rules below resembles
;;; a recursive function, terminating once the PoS list has been reduced to 
;;; a singleton element.  form-based named entities identified earlier avoid
;;; this kind of PoS multiplication because they have already emptied out their
;;; PoS list.
;;;

recurse-tnt-rule := inpmap-012-rule &
  [ +INPUT   < [ +FORM #form ,
                 +TNT.+TAGS [ FIRST #tag , REST #tagrest & *cons* ],
                 +TNT.+PRBS [ FIRST #prb , REST #prbrest & *cons* ] ] > ,
    +OUTPUT  < [ +FORM #form,
		 +ONSET unk_onset,
                 +TNT.+TAGS < #tag >,
                 +TNT.+PRBS < #prb > ] ,
               [ +FORM #form,
                 +TNT.+TAGS #tagrest,
                 +TNT.+PRBS #prbrest ] > ,
    +POSITION "O1=O2" ].

terminate-tnt-rule := inpmap-012-rule &
  [ +INPUT   < [ +FORM #form,
                 +TNT.+TAGS < #tag >,
                 +TNT.+PRBS < #prb > ] >,
    +OUTPUT  < [ +FORM #form,
		 +ONSET unk_onset,
                 +TNT.+TAGS < #tag >,
                 +TNT.+PRBS < #prb > ] ,
               [ +FORM #form,
		 +ONSET con_or_voc,
                 +TNT.+TAGS < >,
                 +TNT.+PRBS < > ] >,
    +POSITION "O1=O2" ].

;;;
;;; with singleton PoS readings multiplied out in each chart cell, we can prune
;;; undesirable alternatives, e.g. a foreign word reading when there also is a
;;; common noun.
;;; _fix_me_
;;; should we eventually want to include the PoS probabilities as a feature in
;;; parse selection, this kind of pruning should disappear: a high-probability
;;; FW, say, should not be bullied out by an unlike NN.         (31-aug-08; oe)
;;;

filter-dup-fw-token := inpmap-rule &
  [ +CONTEXT < [ +TNT.+TAGS < "NN" > ] >,
    +INPUT   < [ +TNT.+TAGS < "FW" > ] >,
    +OUTPUT  < >,
    +POSITION "I1=C1" ].

filter-dup-nnp-token := inpmap-rule &
  [ +CONTEXT < [ +TNT.+TAGS < "NN" > ] >,
    +INPUT   < [ +TNT.+TAGS < "NNP" > ] >,
    +OUTPUT  < >,
    +POSITION "I1=C1" ].

filter-dup-nnps-token := inpmap-rule &
  [ +CONTEXT < [ +TNT.+TAGS < "NNP" > ] >,
    +INPUT   < [ +TNT.+TAGS < "NNPS" > ] >,
    +OUTPUT  < >,
    +POSITION "I1=C1" ].

assign-default-class := inpmap-rule &  
  [ +INPUT   < [ +FORM #form,
		 +CLASS noclass, +PRED #pred, +ONSET #onset,
                 +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
    +OUTPUT  < [ +FORM #form,
		 +CLASS loweralpha, +PRED #pred, +ONSET #onset,
                 +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].


;;; Would like to be able to assign +PRED value based on +FORM, but the
;;; software does not seem to currently allow reference to input's +FORM
;;; in value for +PRED.  So for now, put in place-holder +PRED strings
;;; for each POS variety of unknown word.

#|
assign-semantics-nn := inpmap-rule &  
  [ +INPUT   < [ +FORM #form & "/([a-zA-Z0-9]+)/",
		 +CLASS #class & stdorth, +ONSET #onset & unk_onset, +ID #id,
                 +TNT #tnt & [ +TAGS < "NN" > ], +FROM #from, +TO #to ] >,
    +OUTPUT  < [ +FORM #form,
		 +CLASS #class, +PRED "_${I1:+FORM:1}_n_rel", +ONSET #onset,
                 +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].
|#


assign-semantics-nn := inpmap-rule &  
  [ +INPUT   < [ +FORM #form,
		 +CLASS #class & stdorth, +ONSET #onset & unk_onset, +ID #id,
                 +TNT #tnt & [ +TAGS < "/(NN|FW)/" > ], +FROM #from, +TO #to ]>,
    +OUTPUT  < [ +FORM #form,
		 +CLASS #class, +PRED "unknown_n_rel", +ONSET #onset,
                 +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].

assign-semantics-v := inpmap-rule &  
  [ +INPUT   < [ +FORM #form,
		 +CLASS #class & stdorth, +ONSET #onset & unk_onset, +ID #id,
                 +TNT #tnt & [ +TAGS < "/VB[A-Z]*/" > ], +FROM #from, +TO #to]>,
    +OUTPUT  < [ +FORM #form,
		 +CLASS #class, +PRED "unknown_v_rel", +ONSET #onset,
                 +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].

assign-semantics-a := inpmap-rule &  
  [ +INPUT   < [ +FORM #form,
		 +CLASS #class & stdorth, +ONSET #onset & unk_onset, +ID #id,
                 +TNT #tnt & [ +TAGS < "/(JJ|JJR|JJS|RB)/" > ], +FROM #from, +TO #to]>,
    +OUTPUT  < [ +FORM #form,
		 +CLASS #class, +PRED "unknown_a_rel", +ONSET #onset,
                 +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].

assign-semantics-pn := inpmap-rule &  
  [ +INPUT   < [ +FORM #form, +PRED #pred,
		 +CLASS #class & stdorth, +ONSET #onset & unk_onset, +ID #id,
                 +TNT #tnt & [ +TAGS < "/(NNP|NNPS|CD)/" > ], +FROM #from, +TO #to ] >,
    +OUTPUT  < [ +FORM #form,
		 +CLASS #class, +PRED #pred, +ONSET #onset,
                 +TNT #tnt, +ID #id, +FROM #from, +TO #to,
		 +CARG #form ] > ].

