;;; -*- Mode: tdl; Coding: utf-8; -*-

;;;
;;; token mapping is the process of inspecting and re-arranging input tokens,
;;; i.e. a lattice of structured objects (feature structures), to best match
;;; the expectations of the grammar proper.  the general mechnism is described
;;; by Adolphs, et al. (2008); see:
;;;
;;;   http://www.lrec-conf.org/proceedings/lrec2008/summaries/349.html
;;;
;;; as of August 2008, we are assuming an initial tokenization that is (mostly)
;;; compatible to Penn Treebank (PTB) conventions; this may or may not turn out
;;; to be a good idea, but if nothing else it makes the core parser compatible
;;; with a wide variety of existing tools and pre-processing approaches.  for a
;;; critical (and subjective) discussion of some tokenization issues, see:
;;;
;;;  http://lingpipe-blog.com/2008/06/26/the-curse-of-intelligent-tokenization/
;;;
;;; in the process of token mapping, we move from a PTB-compatible tokenization
;;; to an ERG-compatible one: specifically, many punctuation marks are attached
;;; as prefixes or suffixes on other tokens.  the process is broken down into a
;;; number of (more or less) distinct phases, viz.
;;;
;;; - decoration: filling in missing or underspecified token properties.
;;; - normalization: anything the (ideal) tokenizer _should_ have done.
;;; - NE recognition: surface-based identification of URLs, numbers, et al.
;;; - token combination: re-attach punctuation marks and contracted forms.
;;; - sandwiched punctuation
;;; - PoS explosion: multiply out alternate PoS readings
;;; - PoS reduction: prune overlapping PoS readings
;;;
;;; we hope we have (now) arrived at a relatively stable inventory of token
;;; properties, of which some typically are only introduced in token mapping;
;;; these are ONSET, PRED, CARG.  however, in principle a tokenizer might pass
;;; in any of these properties, or they could be introduced very early in the
;;; rewrite process.  hence, all rules must make sure to always preserve all
;;; token information.
;;;

;;
;; some tokenizers (e.g. the one of acrolinx) already distinguish a number of
;; token classes.  our REPP tokenizer, however, does not; so, determine class
;; values here, if need be.  with acrolinx, we might have to map their naming
;; scheme into our type hierarchy, on the other hand.
;;
numeric_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:digit:]]+/" ] >,
  +OUTPUT < [ +CLASS numeric ] > ].

alphabetic+upper_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:upper:]]+/" ] >,
  +OUTPUT < [ +CLASS alphabetic+upper ] > ].

alphabetic+lower_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:lower:]]+/" ] >,
  +OUTPUT < [ +CLASS alphabetic+lower ] > ].

alphabetic+capitalized+mixed_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:upper:]][[:alpha:]]+/" ] >,
  +OUTPUT < [ +CLASS alphabetic+capitalized+mixed ] > ].

alphabetic+non_capitalized+mixed_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:lower:]][[:alpha:]]+/" ] >,
  +OUTPUT < [ +CLASS alphabetic+non_capitalized+mixed ] > ].

alphanumeric+upper_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:upper:][:digit:]]+/" ] >,
  +OUTPUT < [ +CLASS alphanumeric+upper ] > ].

alphanumeric+lower_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:lower:][:digit:]]+/" ] >,
  +OUTPUT < [ +CLASS alphanumeric+lower ] > ].

alphanumeric+capitalized+mixed_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:upper:]][[:alnum:]]+/" ] >,
  +OUTPUT < [ +CLASS alphanumeric+capitalized+mixed ] > ].

alphanumeric+non_capitalized+mixed_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:lower:][:digit:]][[:alnum:]]+/" ] >,
  +OUTPUT < [ +CLASS alphanumeric+non_capitalized+mixed ] > ].

non_alphanumeric_tmr := token_class_tmt &
[ +OUTPUT < [ +CLASS non_alphanumeric ] > ].

;;
;; in case we are running without a PoS tagger, or something went wrong in the
;; creation of token AVMs from our input (in one form or another), make sure to
;; fully annul part-of-speech information.
;;
null_tnt_tmr := inpmap-rule &
[ +INPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
             +PRED #pred, +CARG #carg, +ID #id, +FROM #from, +TO #to,
             +TNT [ +TAGS < "FOO", ... > ] ] >,
  +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
              +PRED #pred, +CARG #carg, +ID #id, +FROM #from, +TO #to, 
              +TNT null_tnt ] > ].

;;;
;;; lightweight NEs: form-driven generic entries (formerly `ersatz' entries)
;;;

;;;
;;; email addresses
;;;

;;
;; any valid DNS string, prefixed by address, with optional angle brackets
;;
email_ne_tmr := ne_tmt &
[ +INPUT < [ +FORM
             "/<?[[:alnum:]._-]+@[[:alnum:]_-]+(\\.[[:alnum:]_-]+)+>?/" ] >,
  +OUTPUT < [ +CLASS email_ne ] > ].

;;;
;;; URLs
;;;

;;
;; any valid DNS string, prefixed by `http://', with optional angle brackets
;;
url_ne_1_tmr := ne_tmt &
[ +INPUT < [ +FORM "/<?http://[[:alnum:]_-]+(\\.[[:alnum:]_-]+)+>?/" ] >,
  +OUTPUT < [ +CLASS url_ne ] > ].

;;
;; any valid DNS string, prefixed by `www', with optional angle brackets
;;
url_ne_2_tmr := ne_tmt &
[ +INPUT < [ +FORM "/<?www(\\.[[:alnum:]_-]+)+>?/" ] >,
  +OUTPUT < [ +CLASS url_ne ] > ].

;;
;; any valid DNS string, with obligatory angle brackets
;;
url_ne_3_tmr := ne_tmt &
[ +INPUT < [ +FORM "/<[[:alnum:]_-]+(\\.[[:alnum:]_-]+)+>/" ] >,
  +OUTPUT < [ +CLASS url_ne ] > ].


;;;
;;; File names
;;;

; |/etc/config|
file-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/\\/[a-zA-Z0-9]+\\/(.*)/" ] >,
  +OUTPUT  < [ +CLASS file_ne ] > ].


;;;
;;; times
;;;

; |10:25pm| (tokenizer separates |:|)
time-ne-1-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-2]?[0-9])/" ],
	     [ +FORM "/(:)/" ],
	     [ +FORM "/([0-5][0-9]([aApP][mM])?)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS time_ne ] > ].

;;;
;;; Ratios
;;;

; |1:1000|
ratio-ne-1-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-9]{1,3})/" ],
             [ +FORM "/(:)/" ],
             [ +FORM "/([0-9]+)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; |1:100,000|
ratio-ne-2-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-9]{1,3})/" ],
             [ +FORM "/(:)/" ],
             [ +FORM "/([0-9]{1,3},[0-9]{3})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; |1:1,000,000|
ratio-ne-3-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-9]{1,3})/" ],
             [ +FORM "/(:)/" ],
             [ +FORM "/([0-9]{1,3},[0-9]{3},[0-9]{3})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS meas_ne ] > ].   

;;;
;;; Numerals
;;;

; |23|
num-or-dom-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-2]?[0-9]/" ] >,
  +OUTPUT  < [ +CLASS card_or_dom_ne ] > ].

; |2005|
num-or-year-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/(mid-)?[0-9]{3,4}/" ] >,
  +OUTPUT  < [ +CLASS card_or_year_ne ] > ].

; |850| |-20|
numeral-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |23,000| or European |23.000|
numeral-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]{1,3}[,.][0-9]{3}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |23,000,000| or |23.000.000|
numeral-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]{1,3}[,.][0-9]{1,3}[,.][0-9]{3}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |23,000.00| |23,000.-|
numeral-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]{1,3}[,.][0-9]{3}[,.]([0-9]{2}|-)/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |.52|
numeral-ne-5-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]*[.][0-9]+/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

;;;
;;; Section numbers
;;;

; |3.2.4|
section-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+\\.[0-9]+\\.[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].   

;;;
;;; Fractions
;;;

; |2/3|
fraction-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,2}\/[0-9]{1,3}/" ] >,
  +OUTPUT  < [ +CLASS frct_ne ] > ].   

; with space
; |2 1/3|
fraction-ne-2-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([0-9]+)/" ],
  	     [ +FORM "/([0-9]{1,2}\/[0-9]{1,3})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1} {I2:+FORM:1}",
	       +CLASS card_ne ] > ].

;;;
;;; Dates
;;;

; |12-12-2005| |12/12/2005| |12-12-05| |12/12/05|
date-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,2}[-/][0-9]{1,2}[-/][0-9]{2,4}/" ] >,
  +OUTPUT  < [ +CLASS date_ne ] > ].   

; |12-2005| |12/05| |12-05| |12/05|
date-ne-2-rule := inpmap-ne-11-opt-rule &
[ +CONTEXT < [ +FORM "/[0-9]{1,2}[-/][0-9]{2,4}/" ] >,
  +OUTPUT  < [ +CLASS date_ne ] > ].   

;;;
;;; reduced year names; possibly another case where, in full generality, we
;;; would have to be able to strip off the leading apostrophe first and later, 
;;; in the token-level part, introduce a tokenization alternative, re-uniting
;;; the apostrophe and two-digit year.
;;;

; |'06|
year-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/'[0-9][0-9]/" ] >,
  +OUTPUT  < [ +CLASS year_ne ] > ].   

; |1992-94| |2005-2008|
year-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{4}-[0-9]{2,4}/" ] >,
  +OUTPUT  < [ +CLASS year_ne ] > ].   

;;;
;;; Phone numbers
;;;

; |(415) 555-1212|
phone-us-ne-1-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/(\\(?[0-9]{3}\\)?)/" ],
	     [ +FORM "/([0-9]{3}-[0-9]{4})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1} ${I2:+FORM:1}",
	       +CLASS phone_ne ] > ].   

; |(415)555-1212|
phone-us-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/\\([0-9]{3}\\)[0-9]{3}-[0-9]{4}/" ] >,
  +OUTPUT  < [ +CLASS phone_ne ] > ].   

; |555-1212|
phone-us-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{3}-[0-9]{4}/" ] >,
  +OUTPUT  < [ +CLASS phone_ne ] > ].   

; |23 23 23 23|
phone-eur-ne-1-rule := inpmap-ne-41-rule &
[ +INPUT   < [ +FORM "/([0-9]{2})/" ],
	     [ +FORM "/([0-9]{2})/" ],
	     [ +FORM "/([0-9]{2})/" ],
	     [ +FORM "/([0-9]{2})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1} ${I2:+FORM:1} ${I3:+FORM:1} ${I4:+FORM:1}",
	       +CLASS phone_ne ] > ].   

;;;
;;; Numerical ranges
;;;

; |23-25|
range-num-or-dom-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-2]?[0-9]-[0-2]?[0-9]/" ] >,
  +OUTPUT  < [ +CLASS card_or_dom_ne ] > ].   

; |50-60|
range-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,3}[.]?-[0-9]{1,3}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].   

; |2-3.4| and European |2-3,4| 
range-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,3}-[0-9]{1,3}[.,][0-9]{1,2}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].   

; |2.5-3.4| and European |2,5-3,4| 
range-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,3}[.,][0-9]{1,2}-[0-9]{1,3}[.,][0-9]{1,2}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].   

; |IV-VII|
range-ne-4-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([IV]+)-/" ],
             [ +FORM "/([IV]+)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS card_ne ] > ].   

;;;
;;; Decades
;;;

; |1950s|
decade-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/(mid-)?1[0-9][0-9]0[sS]/" ] >,
  +OUTPUT  < [ +CLASS plur_ne ] > ].   

; |50s|
decade-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]0[sS]/" ] >,
  +OUTPUT  < [ +CLASS plur_ne ] > ].   

; |1950's|
decade-ne-3-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/(1[0-9][0-9]0)/" ],
	     [ +FORM "/('[sS])/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS plur_ne ] > ].   

; |50's|
decade-ne-4-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([0-9]0)/" ],
	     [ +FORM "/('[sS])/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS plur_ne ] > ].   

;;;
;;; Ordinal numbers
;;;

; day-of-month or ordinal
; |21st| |22nd| |23rd| |24th|
ordinal-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/([1,2]?1st|[1,2]?2nd|[1,2]?3rd|[1,2]?[4567890]th)/" ] >,
  +OUTPUT  < [ +CLASS ord_or_dom_ne ] > ].

; |221st| |222nd| |223rd| |224th|
ordinal-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/([0-9]*1st|[0-9]*2nd|[0-9]*3rd|[0-9]*[4567890]th)/" ] >,
  +OUTPUT  < [ +CLASS ord_ne ] > ].

; day-of-month or ordinal
; |24 th|
ordinal-ne-3-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([1,2]?[4567890])/" ],
	     [ +FORM "/(th)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS ord_or_dom_ne ] > ].

; |224 th|
ordinal-ne-4-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([0-9]*[4567890])/" ],
	     [ +FORM "/(th)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS ord_ne ] > ].


;;;
;;; Alphanumeric identifiers
;;;

; |ABC123DEF|
alphanum-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]*[a-zA-ZÅåØøÆæ]+[0-9]+[a-zA-ZÅåØøÆæ0-9]*/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |22(B)| |22B|
alphanum-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+\\(?[A-ZÅØÆ]+[A-ZÅØÆ0-9]*\\)?/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |B.25| |IL-10| |IL/10|
alphanum-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]*[A-ZÅØÆ]+[-./][A-ZÅØÆ]*[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |123-45-6789|
alphanum-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,4}[-][0-9]{1,4}[-][0-9]{1,4}/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |22-b|
alphanum-ne-5-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+[-][a-zA-ZÅåØøÆæ]/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

;;;
;;; Measure NPs
;;;

; |25cm|
measure-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+([mM'\"kK]|cm|mm|σ|(º[CF]?))/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].

; |25.5cm|
measure-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+[,.][0-9]+([mM'\"kK]|cm|mm|σ|(º[CF]?))/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].

; |1:1000m|
measure-ne-3-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-9]{1,3})/" ],
             [ +FORM "/(:)/" ],
             [ +FORM "/([0-9]+([mM'\"kK]|cm|mm|σ|(º[CF]?)))/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; DPF 01-sept-08 FIX
; Segmentation violation when parsing "$20-$30 arrives"
;
; |$20-$30|
#|
measure-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/\\$[0-9]+-\\$[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].
|#

; |$20 - $30|
measure-ne-5-rule := inpmap-ne-51-rule &
[ +INPUT   < [ +FORM "$" ],
	     [ +FORM "/([0-9]+)/" ],
	     [ +FORM "-" ],
	     [ +FORM "$" ],
	     [ +FORM "/([0-9]+)/" ] >,
  +OUTPUT  < [ +FORM "\$${I2:+FORM:1}-\$${I5:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; |US$20|
measure-ne-6-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/US\\$[0-9]/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].

; |US $20|
measure-ne-7-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/US/" ],
	     [ +FORM "/\\$[0-9]/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS meas_ne ] > ].


strip-char1-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9.\?!\)]+)( )/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ] > ].

strip-char2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/( )([A-Za-zÅåØøÆæ0-9.\?!\)]+)( )/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; separate multiple dots from left host
;;;
separate-dots-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(\\.{3,})/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
	       [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; Replace separator line of equal signs with a period.
;;;
equalsigns-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/={3,}/" ] >,
    +OUTPUT  < [ +FORM "." ] > ].

;;;
;;; Catch asterisks used for emphasis
;;;
;; _fix_me_
;; i would consider the *bold* and _italics_ conventions part of ASCII mark-up,
;; so presumably this could move into a REPP module, where (like in wiki mode)
;; we need a way of inserting tokens that mark segments as emphasized or so.
;;                                                              (17-sep-08; oe)
asterisk-emphasis-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "\*" ], 
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)\\*/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I2:+FORM:1}", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Only for robust EC, VM: drop commas (sentence-final, pauses, etc)
;;;
;final-comma-rule := inpmap-x11-rule &
;  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9'\\.]+),/" ] >,
;    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ] > ].

;;;
;;; Separate funny punctuation with whitespace on either side from the
;;; preceding and following word(s).
;;; Includes =#$%~\(§§
;;;

punct-right-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)([=#$%~\(§§])+/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ],
    	       [ +FORM "${I1:+FORM:2}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] > ].

punct-left-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([=#$%~+*\)§§]+)([a-zA-ZÅåØøÆæ0-9]+)/", +TNT #tnt,
	         +ONSET #onset, +CLASS #class ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ],
               [ +FORM "${I1:+FORM:2}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] > ].

;;;
;;; DPF 18-oct-06 - Temporarily replace |+| with |plus| for PET tokenizer bug
;;;
;; _fix_me_
;; i wonder why this should be necessary; how to reproduce the problem?  then
;; i would be prepared to debug it in PET.                     (17-sep-08; oe)
plus-plus-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/\\+/" ] >,
    +OUTPUT  < [ +FORM "plus" ] > ].

;;;
;;; For now, simplify punctuation clusters found in subordinate quoted Ss, as
;;; in "Who arrived?, she asked"  since current suffixing machinery doesn't
;;; produce result.  Also for "... two hrs., ..." FIX
;;;
punct-cluster-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)[.?!](,)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

;;;
;;; Also simplify awkward clause-final clusters
;;;

punct-cluster2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*)([:\\]])([.?])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:3}" ] > ].

punct-cluster3-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*)([\"\)])([:])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

punct-cluster4-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*),/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ],
      	       [ +FORM "/([.?])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

punct-cluster5-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*)([.\?])([\)])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

; Eliminate spurious second comma
punct-cluster6-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*),/", +TNT #tnt ], [ +FORM "," ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1},", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Eliminate spaces for pair of double quotes when space on both sides
;;;

quote-pair-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"])/" ],
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)([.?]*)/", 
		 +TNT #tnt, +ONSET #onset, +CLASS #class ],
	       [ +FORM "/([\"])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I2:+FORM:2}${I3:+FORM:1}",
		 +TNT #tnt, +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2<I3" ].

;;;
;;; Add one more hack for sentence-final double-quote, where we've already
;;; swallowed the padded final space
;;;
final-doubleq-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/(\")([.?!])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

;;;
;;; Add white space to the right of squished commas and colons
;;; except for numbers on both sides (but separate e.g. |2-day| and |V-neck|)
;;; Same for periods between capital letters: "D.B. Smith", "2.Kim"
;;; Add white space on both sides for forward slash
;;;
squished-punct1-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
 "/([\(\*]*)([a-zA-ZÅåØøÆæ\\-]+)([,:])([a-zA-ZÅåØøÆæ@.\\-]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct2-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
		 "/([\(]*)([0-9]+)([,:])([a-zA-ZÅåØøÆæ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct3-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM 
   "/([\(]*)([0-9.]+)(-)([a-zA-ZÅåØøÆæ][a-zA-ZÅåØøÆæ-]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct4a-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
   "/([\(\*]*)([a-zA-ZαβΔÅåØøÆæ']+)([-,:\/])([a-zA-ZÅåØøÆæ']+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

; Allow digits and "s" to right of dash, for eg "mid-1900s" and "mid-1900's"
squished-punct4b-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
            "/([\(\*]*)([a-zA-ZαβΔÅåØøÆæ]+)([,:-])([0-9']+)s([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}s${I1:+FORM:5}" ] > ].

squished-punct5-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
                 "/([\(]*)([a-zA-ZÅåØøÆæ]+)([,:])([0-9]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "$${I1:+FORM:1}{I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct6-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM 
        "/([\(]*)([A-ZÅØ0-9]+)(\\.)([A-ZÅØ+])(\\.)([A-ZÅØ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
    	       [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ],
               [ +FORM "${I1:+FORM:6}${I1:+FORM:7}" ] > ].

squished-punct7-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([A-ZÅØ0-9]+)(\\.)([A-ZÅØ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

; Replace squished slash with double slash token which is limited to
; lexical conjunction.
squished-punct9-rule := inpmap-x13-rule &
[ +INPUT   < [ +FORM 
	 "/([\(]*)([a-zA-ZÅåØøÆæ-]+)([→/])([a-zA-ZÅåØøÆæ-]+)([.\?!,;\":\)]*)/",
	       +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "//" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct10-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([a-zA-ZÅåØøÆæ]+)(/)/", +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ] > ].

squished-punct11-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([0-9]+)(/)([a-zA-ZÅåØøÆæ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct12-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([a-zA-ZÅåØøÆæ]=)(/)([0-9]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct13-rule := inpmap-x14-rule &
  [ +INPUT   < [ +FORM 
     "/([\(]*)([a-zA-ZÅåØøÆæ]+)(-)(a)(-)([a-zA-Z0-9ÅåØøÆæ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ],
    	       [ +FORM "${I1:+FORM:6}${I1:+FORM:7}" ] > ].

squished-punct15-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
	"/([\(\"]*)([a-zA-Z0-9ÅåØøÆæ]+)(-)([a-zA-ZÅåØøÆæ-]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

;;;
;;; Eliminate space for double quote when space on both sides
;;;

quote-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"])/", +FROM #from ],
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)([.?]*)/", +ID #id, +TO #to, 
		 +TNT #tnt, +ONSET #onset, +CLASS #class & non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I2:+FORM:2}",
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

double_lquote-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/``/", +FROM #from ],
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9'\)\-]+)([.?,]*)/", +ID #id, 
	         +TO #to, +TNT #tnt, +ONSET #onset, +CLASS #class & non_ne ]>,
    +OUTPUT  < [ +FORM "\"${I2:+FORM:1}${I2:+FORM:2}", +ID #id, +FROM #from,
		 +TO #to, +TNT #tnt, +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

double_lquote-space-rule-2 := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/``([a-zA-ZÅåØøÆæ0-9'\)\-]+)([.?,]*)/",
	         +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "\"${I1:+FORM:1}${I1:+FORM:2}" ] > ].

double_rquote-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,!]*)/", 
		 +ID #id, +FROM #from, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ],
	       [ +FORM "/''([.?,\)]*)/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"${I2:+FORM:1}", 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

double_rquote-space-b-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,]*)/", 
		 +ID #id, +FROM #from, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ],
	       [ +FORM "/([.;,'!\?\\]\)]+)/" ],
	       [ +FORM "/''/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I2:+FORM:1}\"", 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ] >,
    +POSITION "I1<I2<I3" ].

double_rquote-space-c-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,]*)''/", 
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"" ] > ].

double_rquote-space-d-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)\\.?''([.?,\)]+)/", 
	         +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"${I1:+FORM:2}" ] > ].

double_rquote-space-e-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([.?,]+)''/", +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"" ] > ].

double_rquote-space-2-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,]*)/", 
		 +ID #id, +FROM #from, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ],
	       [ +FORM "/\"/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"", 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ] >,
    +POSITION "I1<I2" ].

;;; 
;;; Add proper name entry for italicized tokens
;;;
;; _fix_me_
;; with the :wiki REPP module, these should not come in with actual quotes.
;; we should discuss our general approach to feeding mark-up information into
;; the grammar, where i had toyed with the idea of introducing extra tokens
;; (e.g. <i> .. </i>, possibly using a different syntax), because these can
;; apply to more than a word or two.  in that setup, the syntax would have to
;; put things together (which in principle could just mean building a right-
;; branching binary tree, say for foreign-language quotes), and the presence
;; of use/mention mark-up would trigger the conversion to something NP-like.
;;                                                             (17-sep-08; oe)
; |''chatterbot''|
italics-1a-rule := inpmap-rule &
   [ +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/(.*)/",
		+TNT #tnt, +ID #id, +CLASS #class ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
     +OUTPUT  < [ +FORM "${I2:+FORM:1}",
		  +CLASS italics_ne, 
		  +TNT null_tnt, +ID #id, +FROM #from, +TO #to ],
		[ +FORM "${I2:+FORM:1}",
		  +CLASS #class,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "I1<I2<I3, O1=O2" ].

; |''(chatterbot)''|
italics-1b-rule := inpmap-rule &
   [ +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/(\\()/" ],
	      [ +FORM "/(.*)/",
		+TNT #tnt, +ID #id, +CLASS #class ],
	      [ +FORM "/(\\))/" ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
     +OUTPUT  < [ +FORM "${I2:+FORM:1}${I3:+FORM:1}${I4:+FORM:1}",
		  +CLASS italics_ne, 
		  +TNT null_tnt, +ID #id, +FROM #from, +TO #to ],
		[ +FORM "${I2:+FORM:1}${I3:+FORM:1}${I4:+FORM:1}",
		  +CLASS #class,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "I1<I2<I3<I4<I5, O1=O2" ].

; |''chatter bot"|
italics-2a-rule := inpmap-rule &
 [ +CONTEXT < [ +FORM "/(.*)/",
		+TNT #tnt1, +ID #id1, +CLASS #class1 ],
	      [ +FORM "/(.*)/",
		+TNT #tnt2, +ID #id2, +CLASS #class2 ] >,
     +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
    +OUTPUT < [ +FORM "${C1:+FORM:1} ${C2:+FORM:1}",
		+CLASS italics_ne, 
		+TNT null_tnt, +ID #id2, +FROM #from, +TO #to ] >,
   +POSITION "I1<C1<C2<I2" ].

; |''(chatter bot)"|
italics-2b-rule := inpmap-rule &
 [ +CONTEXT < [ +FORM "/(.*)/",
		+TNT #tnt1, +ID #id1, +CLASS #class1 ],
	      [ +FORM "/(.*)/",
		+TNT #tnt2, +ID #id2, +CLASS #class2 ] >,
     +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/(\\()/" ],
	      [ +FORM "/(\\))/" ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
    +OUTPUT < [ +FORM "${I2:+FORM:1}${C1:+FORM:1} ${C2:+FORM:1}${I3:+FORM:1}",
		+CLASS italics_ne, 
		+TNT null_tnt, +ID #id2, +FROM #from, +TO #to ] >,
   +POSITION "I1<I2<C1<C2<I3<I4" ].

; Remove stranded italics quotes (around three or more tokens)
;
; For some reason, can't just delete this token - all following tokens also
; get deleted
#|
delete-italics-left-rule := inpmap-rule &
   [ +INPUT < [ +FORM "/“/" ] >,
     +OUTPUT <  > ].
|#

delete-italics-left-rule := inpmap-rule &
   [ +INPUT  < [ +FORM "“", +FROM #from ],
	       [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +TO #to, +TNT #tnt ] >,
     +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >,
   +POSITION "I1<I2" ].


delete-italics-right-rule := inpmap-rule &
   [ +INPUT  < [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TNT #tnt ],
	       [ +FORM "”", +TO #to ] >,
     +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >,
   +POSITION "I1<I2" ].

; This should maybe be done instead in wiki.fsr
;
; |played[,]|
bracketed-comma-rule := inpmap-rule &
   [ +INPUT < [ +FORM "[" ],
	      [ +FORM ",", +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ],
	      [ +FORM "]" ] >,
     +OUTPUT < [ +FORM ",", +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >, 
     +POSITION "I1<I2<I3" ].

;;;
;;; re-combine punctuation marks with adjacent tokens, based on directionality
;;; of punctuation marks, e.g. opening vs. closing quotes and brackets.  doing
;;; one such re-combination at a time is sufficient, as each rewrite rule will
;;; apply as many times as it possibly can, seeing its own output from earlier
;;; applications.
;;;
prefix_punctuation_tmr := inpmap-rule &
  [ +INPUT   < [ +FORM "/([[({“‘]+)/",
                 +FROM #from ],
               [ +FORM "/(.+)/",
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
                 +TO #to, +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
                 +FROM #from, +TO #to, +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;
;; _fix_me_
;; there is a special case here: |'| following a token ending in |s| could be a
;; possessive marker (which should remain a token in its own right), or could 
;; be a closing single quote.  in principle, the same is true for |"|, but the
;; `feet' measure unit, possibly, will have been detected during NE recognition
;; earlier.  in either case, we would need a way of keeping a separate |'| in
;; the chart, and also re-combine it with the preceding token.  (14-sep-08; oe)
;;
suffix_punctuation_tmr := inpmap-rule &
  [ +INPUT   < [ +FORM "/(.+)/",
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
                 +FROM #from, +TNT #tnt ],
               [ +FORM "/([])}”\"’,;.!?]+)/",
                 +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
                 +FROM #from, +TO #to, +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Eliminate any string-initial stranded punctuation (from faulty segmentatn)
;;;
stranded-punct-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([;,.!\)\?\\*]+)/" ],
               [ +FORM "/([a-zA-ZÅåØøÆæ0-9\\-\?]+)/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +OUTPUT  < [ +FORM "${I2:+FORM:1}", +TNT #tnt,
 		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +POSITION "I1<I2" ].

solitary-punct-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9!.\)\\-\?]+)/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ], 
               [ +FORM "/([;,.!\)\\*]+)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +POSITION "I1<I2" ].

;;;
;;; Parenthetical plurals - remove parens
;;;
paren-plural-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ]*)\\(s\\)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}s" ] > ].

;;;
;;; Add white space to left of ( and [
;;;
space-lbrack-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([\(\[])/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ],
    	       [ +FORM "${I1:+FORM:2}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] > ].
;;;
;;; Add white space around colon if sandwiched with following alphanumeric
;;; (but not e.g. |http://...| and not ratios with numbers on both sides)
;;;
squished-punct16-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([:])([a-zA-ZÅåØøÆæ]+)/", 
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}" ] > ].

squished-punct17-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ.]+)([:])([a-zA-ZÅåØøÆæ0-9]+)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}" ] > ].

;;;
;;; And add white space to the left of colon when followed by white space:
;;;
squished-punct18-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([:])/", +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; And the variants with surrounding punctuation
;;;
squished-punct19-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ]+)([,/])([a-zA-ZÅåØøÆæ]+)([.?!,;])/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

squished-punct20-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([0-9]+)([,/])([a-zA-ZÅåØøÆæ]+)([.?!,;])/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

squished-punct21-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ])([,/])([0-9])([.?!,;])/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

;;;
;;; Add space to left of left paren and to right of right paren
;;;

squished-punct22-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
      "/([\(]*)([a-zA-ZÅåØøÆæ]+)([\(\[])([a-zA-ZÅåØøÆæ0-9]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct23-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
     "/([\(]*)([a-zA-ZÅåØøÆæ]+)([\\]\)])([a-zA-ZÅåØøÆæ0-9]+)([.\?!,;\":\)]*)/",
                 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct24-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([—])([a-zA-ZÅåØøÆæ]+)([.?,]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "---" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

;;;
;;; Remove space after initial "O'" and "L'"
;;;
space-after-o-l-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([lLoO])'/", +TNT #tnt ], 
	       [ +FORM "/([a-zA-ZÅåØøÆæ]+)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}'${I2:+FORM:1}", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Replace left and right angle marks with variant, to avoid communication 
;;; troubles among preprocessor, [incr tsdb()], and PET.
;;;
leftangle-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/< /" ] >,
    +OUTPUT  < [ +FORM "leftangle " ] > ].

rightangle-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/ >/" ] >,
    +OUTPUT  < [ +FORM " rightangle" ] > ].

;;;
;;; Assign +CLASS for words with leading uppercase, so we keep these unknowns.
;;; But for now, not on sentence initial words.
;;;

mixed-case-proper-1-rule := inpmap-rule &
   [ +CONTEXT < [ ] >,
     +INPUT < [ +FORM "/([A-ZÅØ])([A-Za-zÅåØøÆæ0-9,.\?]*)/",
		+TNT #tnt & [ +TAGS.FIRST "NNP" ],
		+ID #id, +FROM #from, +TO #to ] >,
     +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}",
		  +CLASS capitalized-non-initial,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "C1<I1" ].

mixed-case-proper-2-rule := inpmap-rule &
   [ +CONTEXT < [ ] >,
     +INPUT < [ +FORM "/([A-ZÅØ])([A-Za-zÅåØøÆæ0-9,.\?]*)/",
		+TNT #tnt & [ +TAGS.REST.FIRST "NNP" ],
		+ID #id, +FROM #from, +TO #to ] >,
     +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}",
		  +CLASS capitalized-non-initial,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "C1<I1" ].

;;
;; finally, convert everything to lower case, for lexical look-up in PET
;;
lower_case_tmr := inpmap-011-rule &
[ +INPUT < [ +FORM "/(.*[[:upper:]].*)/" ] > ,
  +OUTPUT < [ +FORM "${lc(I1:+FORM:1)}" ] > ].

;;;
;;; Spelling correction
;;;

everytime-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "everytime"] >,
    +OUTPUT  < [ +FORM "every" ],
	       [ +FORM "time" ] > ].

dont-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "dont"] >,
    +OUTPUT  < [ +FORM "don't" ] > ].

wont-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "wont"] >,
    +OUTPUT  < [ +FORM "won't" ] > ].

recieve-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "recieve"] >,
    +OUTPUT  < [ +FORM "receive" ] > ].

labled-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "labled"] >,
    +OUTPUT  < [ +FORM "labeled" ] > ].

didnt-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "didn;t"] >,
    +OUTPUT  < [ +FORM "didn't" ] > ].

didnt-rule-2 := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "didn;", +TNT #tnt],
	       [ +FORM "t"]>,
    +OUTPUT  < [ +FORM "didn't", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; at this point, we multiply out PoS values on all tokens, where for each
;;; original token as many additional tokens are created (in the same chart
;;; cell) as there are PoS readings.  at this point, we start distinguishing
;;; between tokens that activate native lexical entries (LEs), vs. those that
;;; activate generic LEs.  in the token universe, this distinction is made by
;;; virtue of +ONSET, with unk_onset reserved for generic LEs.  the two sets
;;; do not overlap, i.e. for a single original token with two PoS readings, we
;;; end up with a total of three new tokens.  the pair of rules below resembles
;;; a recursive function, terminating once the PoS list has been reduced to 
;;; a singleton element.  form-based named entities identified earlier avoid
;;; this kind of PoS multiplication because they have already emptied out their
;;; PoS list.
;;;

recurse-tnt-rule := inpmap-012-rule &
  [ +INPUT   < [ +FORM #form ,
                 +TNT.+TAGS [ FIRST #tag , REST #tagrest & *cons* ],
                 +TNT.+PRBS [ FIRST #prb , REST #prbrest & *cons* ] ] > ,
    +OUTPUT  < [ +FORM #form,
		 +ONSET unk_onset,
                 +TNT.+TAGS < #tag >,
                 +TNT.+PRBS < #prb > ] ,
               [ +FORM #form,
                 +TNT.+TAGS #tagrest,
                 +TNT.+PRBS #prbrest ] > ,
    +POSITION "O1=O2" ].

terminate-tnt-rule := inpmap-012-rule &
  [ +INPUT   < [ +FORM #form,
                 +TNT.+TAGS < #tag >,
                 +TNT.+PRBS < #prb > ] >,
    +OUTPUT  < [ +FORM #form,
		 +ONSET unk_onset,
                 +TNT.+TAGS < #tag >,
                 +TNT.+PRBS < #prb > ] ,
               [ +FORM #form,
		 +ONSET con_or_voc,
                 +TNT.+TAGS < >,
                 +TNT.+PRBS < > ] >,
    +POSITION "O1=O2" ].

;;;
;;; with singleton PoS readings multiplied out in each chart cell, we can prune
;;; undesirable alternatives, e.g. a foreign word reading when there also is a
;;; common noun.  also, ditch PoS readings with very low probability, and ones
;;; for which no PoS-activated generic entries exist anyway.
;;;
;;; _fix_me_
;;; should we eventually want to include the PoS probabilities as a feature in
;;; parse selection, this kind of pruning should disappear: a high-probability
;;; FW, say, should not be bullied out by an unlike NN.         (31-aug-08; oe)
;;;

tnt_ditch_unlikely_tmr := inpmap-rule &
[ +INPUT < [ +TNT.+PRBS < "/0?\\.0.*/" > ] >,
  +OUTPUT < > ].

tnt_ditch_function_tmr := inpmap-rule &
[ +INPUT < [ +TNT.+TAGS 
             < "/CC|DT|EX|IN|MD|PDT|POS|PRP\\$?|RP|TO|UH|WDT|WP|WRB/" > ] >,
  +OUTPUT < > ].

tnt_ditch_punctuation_tmr := inpmap-rule &
[ +INPUT < [ +TNT.+TAGS < "/\\$|#|``|''|\\(|\\)|,|\\.|:/" > ] >,
  +OUTPUT < > ].

tnt_filter_dup_fw_tmr := inpmap-rule &
[ +CONTEXT  < [ +TNT.+TAGS < "NN" > ] >,
  +INPUT    < [ +TNT.+TAGS < "FW" > ] >,
  +OUTPUT   < >,
  +POSITION "I1=C1" ].

tnt_filter_dup_nnp_tmr := inpmap-rule &
[ +CONTEXT  < [ +TNT.+TAGS < "/FW|NN/" > ] >,
  +INPUT    < [ +TNT.+TAGS < "NNP" > ] >,
  +OUTPUT   < >,
  +POSITION "I1=C1" ].

tnt_filter_dup_nnps_tmr := inpmap-rule &
[ +CONTEXT  < [ +TNT.+TAGS < "NNP" > ] >,
  +INPUT    < [ +TNT.+TAGS < "NNPS" > ] >,
  +OUTPUT   < >,
  +POSITION "I1=C1" ].

;;
;; now done upon entry to token mapping, along a three-dimensional hierarchy.
;; _fix_me_
;; but many of the earlier rules still `leak', i.e. do not always copy +CLASS
;; (or +PRED, +CARG, and others), hence once again make sure to force a +CLASS
;; value that will keep this token out of the way of generic entries.
;;                                                             (17-sep-08; oe)
assign-default-class := inpmap-rule &  
[ +INPUT   < [ +FORM #form, +ONSET #onset,
	       +CLASS noclass, +PRED #pred, +CARG #carg,
	       +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >,
  +OUTPUT  < [ +FORM #form, +ONSET #onset,
	       +CLASS non_alphanumeric, +PRED #pred, +CARG #carg,
	       +ID #id, +FROM #from, +TO #to, +TNT #tnt ] > ].

;;; Would like to be able to assign +PRED value based on +FORM, but the
;;; software does not seem to currently allow reference to input's +FORM
;;; in value for +PRED.  So for now, put in place-holder +PRED strings
;;; for each POS variety of unknown word.

#|
assign-semantics-nn := inpmap-rule &  
[ +INPUT   < [ +FORM #form & "/([a-zA-Z0-9]+)/",
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "NN" > ], +FROM #from, +TO #to ] >,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED "_${I1:+FORM:1}_n_rel", +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].
|#

assign-semantics-nn := inpmap-rule &  
[ +INPUT   < [ +FORM #form,
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "/(NN|FW)/" > ], +FROM #from, +TO #to ]>,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED "unknown_n_rel", +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].

assign-semantics-v := inpmap-rule &  
[ +INPUT   < [ +FORM #form,
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "/VB[A-Z]*/" > ], +FROM #from, +TO #to]>,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED "unknown_v_rel", +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].

assign-semantics-a := inpmap-rule &  
[ +INPUT   < [ +FORM #form,
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "/(JJ|JJR|JJS|RB)/" > ], 
	       +FROM #from, +TO #to]>,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED "unknown_a_rel", +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].

assign-semantics-pn := inpmap-rule &  
[ +INPUT   < [ +FORM #form, +PRED #pred,
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "/(NNP|NNPS|CD)/" > ], 
	       +FROM #from, +TO #to ] >,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED #pred, +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to, +CARG #form ] > ].

