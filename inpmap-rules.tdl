;;; -*- Mode: tdl; Coding: utf-8; -*-

;;;
;;; token mapping is the process of inspecting and re-arranging input tokens,
;;; i.e. a lattice of structured objects (feature structures), to best match
;;; the expectations of the grammar proper.  the general mechnism is described
;;; by Adolphs, et al. (2008); see:
;;;
;;;   http://www.lrec-conf.org/proceedings/lrec2008/summaries/349.html
;;;
;;; as of August 2008, we are assuming an initial tokenization that is (mostly)
;;; compatible to Penn Treebank (PTB) conventions; this may or may not turn out
;;; to be a good idea, but if nothing else it makes the core parser compatible
;;; with a wide variety of existing tools and pre-processing approaches.  for a
;;; critical (and subjective) discussion of some tokenization issues, see:
;;;
;;;  http://lingpipe-blog.com/2008/06/26/the-curse-of-intelligent-tokenization/
;;;
;;; in the process of token mapping, we move from a PTB-compatible tokenization
;;; to an ERG-compatible one: specifically, many punctuation marks are attached
;;; as prefixes or suffixes on other tokens.  the process is broken down into a
;;; number of (more or less) distinct phases, viz.
;;;
;;; - normalization: anything the (ideal) tokenizer _should_ have done.
;;; - NE recognition: surface-based identification of URLs, numbers, et al.
;;; - decoration: filling in missing or underspecified token properties.
;;; - token combination: re-attach punctuation marks and contracted forms.
;;; - sandwiched punctuation
;;; - PoS explosion: multiply out alternate PoS readings
;;; - PoS reduction: prune overlapping PoS readings
;;;
;;; we hope we have (now) arrived at a relatively stable inventory of token
;;; properties, of which some typically are only introduced in token mapping;
;;; these are ONSET, PRED, CARG.  however, in principle a tokenizer might pass
;;; in any of these properties, or they could be introduced very early in the
;;; rewrite process.  hence, all rules must make sure to always preserve all
;;; token information.
;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; correct tokenization `damage', inherited from the PTB conventions.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;; convert (PTB-style) ASCII directional quotes to UniCode characters
;;
opening_double_quote := one_one_form_tmt &
[ +INPUT < [ +FORM "``" ] >,
  +OUTPUT < [ +FORM "“" ] > ].
           
closing_double_quote := one_one_form_tmt &
[ +INPUT < [ +FORM "''" ] >,
  +OUTPUT < [ +FORM "”" ] > ].
           

;;
;; {|do| |has| |wo| ...} |n't| --> {|don't| |hasn't| |won't| 
;;
contracted_negation_tmr := token_mapping_rule &
[ +INPUT < [ +FORM "/([[:alpha:]]+)/", 
             +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
             +FROM #from, +TNT #tnt ],
           [ +FORM "/(n't|N'T)/",
             +TO #to ] >,
  +OUTPUT < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
              +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
              +FROM #from, +TO #to, +TNT #tnt ] >,
  +POSITION "I1<I2" ].



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; lightweight NEs: form-driven generic entries (formerly `ersatz' entries)
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;
;;; email addresses
;;;

;;
;; any valid DNS string, prefixed by address, with optional angle brackets
;;
email_ne_tmr := ne_tmt &
[ +INPUT < [ +FORM
             "/<?[[:alnum:]._-]+@[[:alnum:]_-]+(\\.[[:alnum:]_-]+)+>?/" ] >,
  +OUTPUT < [ +CLASS email_ne ] > ].

;;;
;;; uniform resource locators (URLs)
;;;

;;
;; any valid DNS string, prefixed by `http://', with optional angle brackets
;;
url_ne_1_tmr := ne_tmt &
[ +INPUT < [ +FORM "/<?http://[[:alnum:]_-]+(\\.[[:alnum:]_-]+)+>?/" ] >,
  +OUTPUT < [ +CLASS url_ne ] > ].

;;
;; any valid DNS string, prefixed by `www', with optional angle brackets
;;
url_ne_2_tmr := ne_tmt &
[ +INPUT < [ +FORM "/<?www(\\.[[:alnum:]_-]+)+>?/" ] >,
  +OUTPUT < [ +CLASS url_ne ] > ].

;;
;; any valid DNS string, with obligatory angle brackets
;;
url_ne_3_tmr := ne_tmt &
[ +INPUT < [ +FORM "/<[[:alnum:]_-]+(\\.[[:alnum:]_-]+)+>/" ] >,
  +OUTPUT < [ +CLASS url_ne ] > ].

;;;
;;; file names
;;;

;;
;; fully-qualified Un*x style, starting with a slash, e.g. |/etc/config|.  
;;
;; _fix_me_
;; we require a minimum of two components, such that |/etc| by itself will not
;; match.  maybe we should allow these too but create an ambiguity here, i.e.
;; output two tokens, one [ CLASS file_ne }, the other [ CLASS non_ne ]?
;;                                                              (19-sep-08; oe)
;;
file_ne_tmr := ne_tmt &
[ +INPUT < [ +FORM "/(/[[:alnum:]._-]+){2,}/?/" ] >,
  +OUTPUT < [ +CLASS file_ne ] > ].


;;;
;;; time-of-day expressions: |9am|, |11:45pm|, |20:15|
;;;

;;
;; an |am| or |pm| suffix unambiguously indicates a time expression.  we also
;; grab all tokens of the form `H:M' where `H' and `M' are numbers in the right
;; ranges.
;;
;; _fix_me_
;; i wonder about `mix in a ratio of 1:15', which the second rule below would
;; consider a time-of-day expression.  should we approach those case with more
;; `optional' NE rules, i.e. ones outputting two tokens?  or should we rather
;; introduce an abstraction over `time_ne' and `ratio_ne', such that a single
;; token can activate multiple lexical entries?  once we get regular expression
;; matching for lexical instantiation (peter is working on that), in principle,
;; we could just drop `time_ne_2_tmr', make `time_ne_ a sub-type of `ratio_ne',
;; and put the `H:M' regular expression into the generic lexical entry.  with
;; great power comes great responsibility :-).                 (19-sep-08; oe)
;;                       
time_ne_1_tmr := ne_tmt &
[ +INPUT < [ +FORM "/(0?[0-9]|1[0-2])(:[0-5][0-9])?([aApP][mM])/" ] >,
  +OUTPUT  < [ +CLASS time_ne ] > ].

time_ne_2_tmr := ne_tmt &
[ +INPUT < [ +FORM "/(0?[0-9]|1[0-9]|2[0-4]):[0-5][0-9]/" ] >,
  +OUTPUT  < [ +CLASS time_ne ] > ].

;;;
;;; ratios: |1:1000|, |1:100,000|, et al.
;;;

;;
;; we make the conservative assumption that the first element not exceed three
;; digits and not have leading zeros.
;;
ratio_ne_1_tmr := ne_tmt &
[ +INPUT < [ +FORM "/[1-9][0-9]{0,2}:[1-9][0-9]*/" ] >,
  +OUTPUT < [ +CLASS meas_ne ] > ].   

ratio_ne_2_tmr := ne_tmt &
[ +INPUT < [ +FORM "/[1-9][0-9]{0,2}:[1-9][0-9]{2}(,[0-9]{1,3})*/" ] >,
  +OUTPUT < [ +CLASS meas_ne ] > ].   

;;;
;;; Numerals
;;;

;;
;; days of the month: |1| -- |9|, |10| -- |29|, |30|, and |31|
;;
num_or_dom_nt_tmr := ne_tmt &
[ +INPUT < [ +FORM "/([1-9]|[1-2][0-9]|3[01])/" ] >,
  +OUTPUT < [ +CLASS card_or_dom_ne ] > ].

; |2005|
num-or-year-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/(mid-)?[0-9]{3,4}/" ] >,
  +OUTPUT  < [ +CLASS card_or_year_ne ] > ].

; |850| |-20|
numeral-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |23,000| or European |23.000|
numeral-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]{1,3}[,.][0-9]{3}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |23,000,000| or |23.000.000|
numeral-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]{1,3}[,.][0-9]{1,3}[,.][0-9]{3}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |23,000.00| |23,000.-|
numeral-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]{1,3}[,.][0-9]{3}[,.]([0-9]{2}|-)/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

; |.52|
numeral-ne-5-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/-?[0-9]*[.][0-9]+/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].

;;;
;;; Section numbers
;;;

; |3.2.4|
section-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+\\.[0-9]+\\.[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].   

;;;
;;; Fractions
;;;

; |2/3|
fraction-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,2}\/[0-9]{1,3}/" ] >,
  +OUTPUT  < [ +CLASS frct_ne ] > ].   

; with space
; |2 1/3|
fraction-ne-2-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([0-9]+)/" ],
  	     [ +FORM "/([0-9]{1,2}\/[0-9]{1,3})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1} {I2:+FORM:1}",
	       +CLASS card_ne ] > ].

;;;
;;; Dates
;;;

; |12-12-2005| |12/12/2005| |12-12-05| |12/12/05|
date-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,2}[-/][0-9]{1,2}[-/][0-9]{2,4}/" ] >,
  +OUTPUT  < [ +CLASS date_ne ] > ].   

; |12-2005| |12/05| |12-05| |12/05|
date-ne-2-rule := inpmap-ne-11-opt-rule &
[ +CONTEXT < [ +FORM "/[0-9]{1,2}[-/][0-9]{2,4}/" ] >,
  +OUTPUT  < [ +CLASS date_ne ] > ].   

;;;
;;; reduced year names; possibly another case where, in full generality, we
;;; would have to be able to strip off the leading apostrophe first and later, 
;;; in the token-level part, introduce a tokenization alternative, re-uniting
;;; the apostrophe and two-digit year.
;;;

; |'06|
year-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/'[0-9][0-9]/" ] >,
  +OUTPUT  < [ +CLASS year_ne ] > ].   

; |1992-94| |2005-2008|
year-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{4}-[0-9]{2,4}/" ] >,
  +OUTPUT  < [ +CLASS year_ne ] > ].   

;;;
;;; Phone numbers
;;;

; |(415) 555-1212|
phone-us-ne-1-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/(\\(?[0-9]{3}\\)?)/" ],
	     [ +FORM "/([0-9]{3}-[0-9]{4})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1} ${I2:+FORM:1}",
	       +CLASS phone_ne ] > ].   

; |(415)555-1212|
phone-us-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/\\([0-9]{3}\\)[0-9]{3}-[0-9]{4}/" ] >,
  +OUTPUT  < [ +CLASS phone_ne ] > ].   

; |555-1212|
phone-us-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{3}-[0-9]{4}/" ] >,
  +OUTPUT  < [ +CLASS phone_ne ] > ].   

; |23 23 23 23|
phone-eur-ne-1-rule := inpmap-ne-41-rule &
[ +INPUT   < [ +FORM "/([0-9]{2})/" ],
	     [ +FORM "/([0-9]{2})/" ],
	     [ +FORM "/([0-9]{2})/" ],
	     [ +FORM "/([0-9]{2})/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1} ${I2:+FORM:1} ${I3:+FORM:1} ${I4:+FORM:1}",
	       +CLASS phone_ne ] > ].   

;;;
;;; Numerical ranges
;;;

; |23-25|
range-num-or-dom-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-2]?[0-9]-[0-2]?[0-9]/" ] >,
  +OUTPUT  < [ +CLASS card_or_dom_ne ] > ].   

; |50-60|
range-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,3}[.]?-[0-9]{1,3}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].   

; |2-3.4| and European |2-3,4| 
range-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,3}-[0-9]{1,3}[.,][0-9]{1,2}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].   

; |2.5-3.4| and European |2,5-3,4| 
range-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,3}[.,][0-9]{1,2}-[0-9]{1,3}[.,][0-9]{1,2}/" ] >,
  +OUTPUT  < [ +CLASS card_ne ] > ].   

;;
;; _fix_me_
;; nowadays a single token.                                     (19-sep-08; oe)
;;
; |IV-VII|
range-ne-4-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([IV]+)-/" ],
             [ +FORM "/([IV]+)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS card_ne ] > ].   

;;;
;;; Decades
;;;

; |1950s|
decade-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/(mid-)?1[0-9][0-9]0[sS]/" ] >,
  +OUTPUT  < [ +CLASS plur_ne ] > ].   

; |50s|
decade-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]0[sS]/" ] >,
  +OUTPUT  < [ +CLASS plur_ne ] > ].   

; |1950's|
decade-ne-3-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/(1[0-9][0-9]0)/" ],
	     [ +FORM "/('[sS])/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS plur_ne ] > ].   

; |50's|
decade-ne-4-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([0-9]0)/" ],
	     [ +FORM "/('[sS])/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS plur_ne ] > ].   

;;;
;;; Ordinal numbers
;;;

; day-of-month or ordinal
; |21st| |22nd| |23rd| |24th|
ordinal-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/([1,2]?1st|[1,2]?2nd|[1,2]?3rd|[1,2]?[4567890]th)/" ] >,
  +OUTPUT  < [ +CLASS ord_or_dom_ne ] > ].

; |221st| |222nd| |223rd| |224th|
ordinal-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/([0-9]*1st|[0-9]*2nd|[0-9]*3rd|[0-9]*[4567890]th)/" ] >,
  +OUTPUT  < [ +CLASS ord_ne ] > ].

;;
;; _fix_me_
;; are the following two rules really legitimate orthography?  if they occur
;; in mis-speled text, we should maybe move them into a separate fix-up set
;; (and ignore for right now).                                 (19-sep-08; oe)
;;
; day-of-month or ordinal
; |24 th|
ordinal-ne-3-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([1,2]?[4567890])/" ],
	     [ +FORM "/(th)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS ord_or_dom_ne ] > ].

; |224 th|
ordinal-ne-4-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/([0-9]*[4567890])/" ],
	     [ +FORM "/(th)/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS ord_ne ] > ].


;;;
;;; Alphanumeric identifiers
;;;

; |ABC123DEF|
alphanum-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]*[a-zA-ZÅåØøÆæ]+[0-9]+[a-zA-ZÅåØøÆæ0-9]*/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |22(B)| |22B|
alphanum-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+\\(?[A-ZÅØÆ]+[A-ZÅØÆ0-9]*\\)?/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |B.25| |IL-10| |IL/10|
alphanum-ne-3-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]*[A-ZÅØÆ]+[-./][A-ZÅØÆ]*[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |123-45-6789|
alphanum-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]{1,4}[-][0-9]{1,4}[-][0-9]{1,4}/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

; |22-b|
alphanum-ne-5-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+[-][a-zA-ZÅåØøÆæ]/" ] >,
  +OUTPUT  < [ +CLASS proper_ne ] > ].

;;;
;;; Measure NPs
;;;

; |25cm|
measure-ne-1-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+([mM'\"kK]|cm|mm|σ|(º[CF]?))/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].

; |25.5cm|
measure-ne-2-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/[0-9]+[,.][0-9]+([mM'\"kK]|cm|mm|σ|(º[CF]?))/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].

;;
;; _fix_me_
;; nowadays a single token.                                     (19-sep-08; oe)
;;
; |1:1000m|
measure-ne-3-rule := inpmap-ne-31-rule &
[ +INPUT   < [ +FORM "/([0-9]{1,3})/" ],
             [ +FORM "/(:)/" ],
             [ +FORM "/([0-9]+([mM'\"kK]|cm|mm|σ|(º[CF]?)))/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I3:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; DPF 01-sept-08 FIX
; Segmentation violation when parsing "$20-$30 arrives"
;
; |$20-$30|
#|
measure-ne-4-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/\\$[0-9]+-\\$[0-9]+/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].
|#

; |$20 - $30|
measure-ne-5-rule := inpmap-ne-51-rule &
[ +INPUT   < [ +FORM "$" ],
	     [ +FORM "/([0-9]+)/" ],
	     [ +FORM "-" ],
	     [ +FORM "$" ],
	     [ +FORM "/([0-9]+)/" ] >,
  +OUTPUT  < [ +FORM "\$${I2:+FORM:1}-\$${I5:+FORM:1}",
	       +CLASS meas_ne ] > ].   

; |US$20|
measure-ne-6-rule := inpmap-ne-11-rule &
[ +INPUT   < [ +FORM "/US\\$[0-9]/" ] >,
  +OUTPUT  < [ +CLASS meas_ne ] > ].

; |US $20|
measure-ne-7-rule := inpmap-ne-21-rule &
[ +INPUT   < [ +FORM "/US/" ],
	     [ +FORM "/\\$[0-9]/" ] >,
  +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
	       +CLASS meas_ne ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; now with NEs out of our way, this would be a good time for adjustments to
;;; tokenization: introduce additional token boundaries (e.g. for hyphens and 
;;; slashes) and maybe some robustness rules for `sandwiched' punctuation.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; some tokenizers (e.g. the one of acrolinx) already distinguish a number of
;;; token classes.  our REPP tokenizer, however, does not; so, determine class
;;; values here, if need be.  with acrolinx, we might have to map their naming
;;; scheme into our type hierarchy, on the other hand.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

numeric_class_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:digit:]]+/" ] >,
  +OUTPUT < [ +CLASS numeric ] > ].

alphabetic_class_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:alpha:]]+/" ] >,
  +OUTPUT < [ +CLASS alphabetic ] > ].

alphanumeric_class_tmr := token_class_tmt &
[ +INPUT < [ +FORM "/[[:alnum:]_-]+/" ] >,
  +OUTPUT < [ +CLASS alphanumeric ] > ].

non_alphanumeric_class_tmr := token_class_tmt &
[ +OUTPUT < [ +CLASS non_alphanumeric ] > ].

;;
;; further decorate the token class with information about (a) sentence-initial
;; initial position and (b) capitalization.  because these are attributes of
;; +CLASS (and there is no way of overwriting), we play a nasty trick on +CARG,
;; viz. utilize it as a `scratch' slot to prevent cyclic rule applications.  we
;; (kind of assume) that no external tokenizer will pass in +CARG values, and
;; if it did, the worst that would happen is that the rules below cannot fire.
;;
non_initial_tmr := token_case_tmt &
[ +CONTEXT < [] >,
  +INPUT < [ +CARG anti_string ] >,
  +OUTPUT < [ +CLASS [ +INITIAL - ], +CARG non_string ] >,
  +POSITION "C1<I1" ].

initial_tmr := token_case_tmt &
[ +INPUT < [ +CARG anti_string ] >,
  +OUTPUT < [ +CLASS #class & [ +INITIAL + ], +CARG non_string ] > ].

lower_tmr := token_case_tmt &
[ +INPUT < [ +FORM "/[[:lower:][:digit:]_-]+/", 
             +CARG non_string ] >,
  +OUTPUT < [ +CLASS [ +CASE lower ], 
              +CARG anti_string ] > ].

upper_tmr := token_case_tmt &
[ +INPUT < [ +FORM "/[[:upper:][:digit:]_-]+/", 
             +CARG non_string ] >,
  +OUTPUT < [ +CLASS [ +CASE upper ], 
              +CARG anti_string ] > ].
  
capitalized_tmr := token_case_tmt &
[ +INPUT < [ +FORM "/[[:upper:]][[:alnum:]_-]+/", 
             +CARG non_string ] >,
  +OUTPUT < [ +CLASS [ +CASE capitalized+mixed ],
              +CARG anti_string ] > ].

non_capitalized_tmr := token_case_tmt &
[ +INPUT < [ +FORM "/[[:lower:][:digit:]][[:alnum:]_-]+/", 
             +CARG non_string ] >,
  +OUTPUT < [ +CLASS [ +CASE non_capitalized+mixed ],
              +CARG anti_string ] > ].

;;
;; in case we are running without a PoS tagger, or something went wrong in the
;; creation of token AVMs from our input (in one form or another), make sure to
;; fully annul part-of-speech information.
;;
null_tnt_tmr := token_mapping_rule &
[ +INPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
             +PRED #pred, +CARG #carg, +ID #id, +FROM #from, +TO #to,
             +TNT [ +TAGS < anti_string, ... > ] ] >,
  +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
              +PRED #pred, +CARG #carg, +ID #id, +FROM #from, +TO #to, 
              +TNT null_tnt ] > ].


;;
;; _fix_me_
;; this appear to target non-breaking spaces; now treated in the :xml module.
;; i believe the following two rules can go.                   (19-sep-08; oe)
;;
strip-char1-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9.\?!\)]+)( )/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ] > ].

strip-char2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/( )([A-Za-zÅåØøÆæ0-9.\?!\)]+)( )/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; separate multiple dots from left host
;;;
separate-dots-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ0-9]+)(\\.{3,})/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
	       [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; Replace separator line of equal signs with a period.
;;;
equalsigns-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/={3,}/" ] >,
    +OUTPUT  < [ +FORM "." ] > ].

;;;
;;; Catch asterisks used for emphasis
;;;
;; _fix_me_
;; i would consider the *bold* and _italics_ conventions part of ASCII mark-up,
;; so presumably this could move into a REPP module, where (like in wiki mode)
;; we need a way of inserting tokens that mark segments as emphasized or so.
;;                                                              (17-sep-08; oe)
asterisk-emphasis-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "\*" ], 
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)\\*/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I2:+FORM:1}", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Only for robust EC, VM: drop commas (sentence-final, pauses, etc)
;;;
;final-comma-rule := inpmap-x11-rule &
;  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9'\\.]+),/" ] >,
;    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ] > ].

;;;
;;; Separate funny punctuation with whitespace on either side from the
;;; preceding and following word(s).
;;; Includes =#$%~\(§§
;;;
;;
;; _fix_me_
;; the following two rules seem to want to adjust (or fix-up) tokenization.  i
;; would suggest taking them out, for the time being, and eventually doing any
;; adjustments to tokenization that are required upon entry to token mapping;
;; in a separate, optional rule set.                           (19-sep-08; oe)
;;
punct-right-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)([=#$%~\(§§])+/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ],
    	       [ +FORM "${I1:+FORM:2}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] > ].

punct-left-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([=#$%~+*\)§§]+)([a-zA-ZÅåØøÆæ0-9]+)/", +TNT #tnt,
	         +ONSET #onset, +CLASS #class ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ],
               [ +FORM "${I1:+FORM:2}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] > ].

;;;
;;; DPF 18-oct-06 - Temporarily replace |+| with |plus| for PET tokenizer bug
;;;
;; _fix_me_
;; i wonder why this should be necessary; how to reproduce the problem?  then
;; i would be prepared to debug it in PET.                     (17-sep-08; oe)
plus-plus-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/\\+/" ] >,
    +OUTPUT  < [ +FORM "plus" ] > ].

;;;
;;; For now, simplify punctuation clusters found in subordinate quoted Ss, as
;;; in "Who arrived?, she asked"  since current suffixing machinery doesn't
;;; produce result.  Also for "... two hrs., ..." FIX
;;;
;; _fix_me_
;; all of the following rules (with the exception of `punct-cluster4-rule')
;; cannot really be effective at this point: punctuation marks are separated
;; into individual tokens, i.e. a cluster would have to be a sequence of
;; tokens.  is it actually still true that the suffixing machinery fails on
;; these?  can we (at least temporarily) take out the entire block?
;;                                                             (17-sep-08; oe)
punct-cluster-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)[.?!](,)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

;;;
;;; Also simplify awkward clause-final clusters
;;;

punct-cluster2-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*)([:\\]])([.?])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:3}" ] > ].

punct-cluster3-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*)([\"\)])([:])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

punct-cluster4-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*),/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ],
      	       [ +FORM "/([.?])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

punct-cluster5-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*)([.\?])([\)])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

; Eliminate spurious second comma
punct-cluster6-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9]*),/", +TNT #tnt ], [ +FORM "," ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1},", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Eliminate spaces for pair of double quotes when space on both sides
;;;
;; _fix_me_
;; now subsumed by the punctuation prefix and suffix rules.     (19-sep-08; oe)
;;
quote-pair-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"])/" ],
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)([.?]*)/", 
		 +TNT #tnt, +ONSET #onset, +CLASS #class ],
	       [ +FORM "/([\"])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I2:+FORM:2}${I3:+FORM:1}",
		 +TNT #tnt, +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2<I3" ].

;;;
;;; Add one more hack for sentence-final double-quote, where we've already
;;; swallowed the padded final space
;;;
;; _fix_me_
;; the quote mark and period would be separate tokens, at this point.  also,
;; the rule just seems to concatenate the two input groups again, so i wonder
;; how it actually changes anything?                           (19-sep-08; oe)
;;
final-doubleq-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/(\")([.?!])/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ] > ].

;;;
;;; Add white space to the right of squished commas and colons
;;; except for numbers on both sides (but separate e.g. |2-day| and |V-neck|)
;;; Same for periods between capital letters: "D.B. Smith", "2.Kim"
;;; Add white space on both sides for forward slash
;;;
;; _fix_me_
;; now we are getting to a very interesting section: adjusting tokenization
;; further.  i admit i am sceptical of the (large) family of `squished' rules.
;; but we certainly still need to define our position on hyphens, slashes, and
;; non-affix punctuation marks (e.g. |:|) that occur sandwiched (except for a
;; named entity, of course).  breaking at hyphens and slashes (which the PTB
;; did not, hence the REPP component does not) in some configurations seems a
;; necessity, but then i would like to have all changes to tokenization early
;; in the pipeline (though after at least those NEs that can contain hyphens
;; and slashes).  the squished colon or comma rules, on the other hand, seem
;; to be of a different nature, fixing non-standard inputs.  initially, can
;; we put these aside (segregate them into a separate file, say), and come back
;; to robustness rules for tokenziation once we have the foundations stable?
;;                                                             (19-sep-08; oe)
squished-punct1-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
 "/([\(\*]*)([a-zA-ZÅåØøÆæ\\-]+)([,:])([a-zA-ZÅåØøÆæ@.\\-]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct2-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
		 "/([\(]*)([0-9]+)([,:])([a-zA-ZÅåØøÆæ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct3-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM 
   "/([\(]*)([0-9.]+)(-)([a-zA-ZÅåØøÆæ][a-zA-ZÅåØøÆæ-]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct4a-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
   "/([\(\*]*)([a-zA-ZαβΔÅåØøÆæ']+)([-,:\/])([a-zA-ZÅåØøÆæ']+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

; Allow digits and "s" to right of dash, for eg "mid-1900s" and "mid-1900's"
squished-punct4b-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
            "/([\(\*]*)([a-zA-ZαβΔÅåØøÆæ]+)([,:-])([0-9']+)s([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}s${I1:+FORM:5}" ] > ].

squished-punct5-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
                 "/([\(]*)([a-zA-ZÅåØøÆæ]+)([,:])([0-9]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "$${I1:+FORM:1}{I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct6-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM 
        "/([\(]*)([A-ZÅØ0-9]+)(\\.)([A-ZÅØ+])(\\.)([A-ZÅØ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
    	       [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ],
               [ +FORM "${I1:+FORM:6}${I1:+FORM:7}" ] > ].

squished-punct7-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([A-ZÅØ0-9]+)(\\.)([A-ZÅØ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

; Replace squished slash with double slash token which is limited to
; lexical conjunction.
squished-punct9-rule := inpmap-x13-rule &
[ +INPUT   < [ +FORM 
	 "/([\(]*)([a-zA-ZÅåØøÆæ-]+)([→/])([a-zA-ZÅåØøÆæ-]+)([.\?!,;\":\)]*)/",
	       +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "//" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct10-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([a-zA-ZÅåØøÆæ]+)(/)/", +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ] > ].

squished-punct11-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([0-9]+)(/)([a-zA-ZÅåØøÆæ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct12-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([a-zA-ZÅåØøÆæ]=)(/)([0-9]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct13-rule := inpmap-x14-rule &
  [ +INPUT   < [ +FORM 
     "/([\(]*)([a-zA-ZÅåØøÆæ]+)(-)(a)(-)([a-zA-Z0-9ÅåØøÆæ]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
    	       [ +FORM "${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ],
    	       [ +FORM "${I1:+FORM:6}${I1:+FORM:7}" ] > ].

squished-punct15-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
	"/([\(\"]*)([a-zA-Z0-9ÅåØøÆæ]+)(-)([a-zA-ZÅåØøÆæ-]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

;;;
;;; Eliminate space for double quote when space on both sides
;;;
;;
;; _fix_me_
;; the following seems wrong: we use a straight quote only for closing quotes,
;; and the re-attachment should be subsumed by the `suffix' rule below.  can
;; we eliminate (or put aside) the entire `quote' section?     (19-sep-08; oe)  
;;                   
quote-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"])/", +FROM #from ],
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9]+)([.?]*)/", +ID #id, +TO #to, 
		 +TNT #tnt, +ONSET #onset, +CLASS #class & non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}${I2:+FORM:2}",
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

double_lquote-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/``/", +FROM #from ],
	       [ +FORM "/([a-zA-ZÅåØøÆæ0-9'\)\-]+)([.?,]*)/", +ID #id, 
	         +TO #to, +TNT #tnt, +ONSET #onset, +CLASS #class & non_ne ]>,
    +OUTPUT  < [ +FORM "\"${I2:+FORM:1}${I2:+FORM:2}", +ID #id, +FROM #from,
		 +TO #to, +TNT #tnt, +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

double_lquote-space-rule-2 := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/``([a-zA-ZÅåØøÆæ0-9'\)\-]+)([.?,]*)/",
	         +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "\"${I1:+FORM:1}${I1:+FORM:2}" ] > ].

double_rquote-space-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,!]*)/", 
		 +ID #id, +FROM #from, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ],
	       [ +FORM "/''([.?,\)]*)/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"${I2:+FORM:1}", 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class ] >,
    +POSITION "I1<I2" ].

double_rquote-space-b-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,]*)/", 
		 +ID #id, +FROM #from, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ],
	       [ +FORM "/([.;,'!\?\\]\)]+)/" ],
	       [ +FORM "/''/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I2:+FORM:1}\"", 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ] >,
    +POSITION "I1<I2<I3" ].

double_rquote-space-c-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,]*)''/", 
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"" ] > ].

double_rquote-space-d-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)\\.?''([.?,\)]+)/", 
	         +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"${I1:+FORM:2}" ] > ].

double_rquote-space-e-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([.?,]+)''/", +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}\"" ] > ].

double_rquote-space-2-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([\"a-zA-ZÅåØøÆæ0-9\-]+)([.?,]*)/", 
		 +ID #id, +FROM #from, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ],
	       [ +FORM "/\"/", +TO #to ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}\"", 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt,
		 +ONSET #onset, +CLASS #class & non_ne ] >,
    +POSITION "I1<I2" ].

;;; 
;;; Add proper name entry for italicized tokens
;;;
;; _fix_me_
;; with the :wiki REPP module, these should not come in with actual quotes.
;; we should discuss our general approach to feeding mark-up information into
;; the grammar, where i had toyed with the idea of introducing extra tokens
;; (e.g. <i> .. </i>, possibly using a different syntax), because these can
;; apply to more than a word or two.  in that setup, the syntax would have to
;; put things together (which in principle could just mean building a right-
;; branching binary tree, say for foreign-language quotes), and the presence
;; of use/mention mark-up would trigger the conversion to something NP-like.
;;                                                             (17-sep-08; oe)
; |''chatterbot''|
italics-1a-rule := inpmap-rule &
   [ +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/(.*)/",
		+TNT #tnt, +ID #id, +CLASS #class ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
     +OUTPUT  < [ +FORM "${I2:+FORM:1}",
		  +CLASS italics_ne, 
		  +TNT null_tnt, +ID #id, +FROM #from, +TO #to ],
		[ +FORM "${I2:+FORM:1}",
		  +CLASS #class,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "I1<I2<I3, O1=O2" ].

; |''(chatterbot)''|
italics-1b-rule := inpmap-rule &
   [ +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/(\\()/" ],
	      [ +FORM "/(.*)/",
		+TNT #tnt, +ID #id, +CLASS #class ],
	      [ +FORM "/(\\))/" ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
     +OUTPUT  < [ +FORM "${I2:+FORM:1}${I3:+FORM:1}${I4:+FORM:1}",
		  +CLASS italics_ne, 
		  +TNT null_tnt, +ID #id, +FROM #from, +TO #to ],
		[ +FORM "${I2:+FORM:1}${I3:+FORM:1}${I4:+FORM:1}",
		  +CLASS #class,
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "I1<I2<I3<I4<I5, O1=O2" ].

; |''chatter bot"|
italics-2a-rule := inpmap-rule &
 [ +CONTEXT < [ +FORM "/(.*)/",
		+TNT #tnt1, +ID #id1, +CLASS #class1 ],
	      [ +FORM "/(.*)/",
		+TNT #tnt2, +ID #id2, +CLASS #class2 ] >,
     +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
    +OUTPUT < [ +FORM "${C1:+FORM:1} ${C2:+FORM:1}",
		+CLASS italics_ne, 
		+TNT null_tnt, +ID #id2, +FROM #from, +TO #to ] >,
   +POSITION "I1<C1<C2<I2" ].

; |''(chatter bot)"|
italics-2b-rule := inpmap-rule &
 [ +CONTEXT < [ +FORM "/(.*)/",
		+TNT #tnt1, +ID #id1, +CLASS #class1 ],
	      [ +FORM "/(.*)/",
		+TNT #tnt2, +ID #id2, +CLASS #class2 ] >,
     +INPUT < [ +FORM "/“/", +FROM #from ],
	      [ +FORM "/(\\()/" ],
	      [ +FORM "/(\\))/" ],
	      [ +FORM "/[”\"]/", +TO #to ] >,
    +OUTPUT < [ +FORM "${I2:+FORM:1}${C1:+FORM:1} ${C2:+FORM:1}${I3:+FORM:1}",
		+CLASS italics_ne, 
		+TNT null_tnt, +ID #id2, +FROM #from, +TO #to ] >,
   +POSITION "I1<I2<C1<C2<I3<I4" ].

; Remove stranded italics quotes (around three or more tokens)
;;
;; _fix_me_
;; these quotes need not be italics (in fact, should not be that).  take for
;; example (simplified from CB): |the "stable" kernel branch|.  REPP works out
;; the directionality of the quotes, so we see |the “stable" kernel branch|.
;; the current rules end up attaching the closing quote to the following token
;; (the faulty `quote-space-rule' above), and the opening quote is discarded
;; by `delete-italics-left-rule'.  once again, i would suggest fewer rules for
;; the current (fine-tuning and debugging phase).              (21-sep-08; oe)
;;
; For some reason, can't just delete this token - all following tokens also
; get deleted
#|
delete-italics-left-rule := inpmap-rule &
   [ +INPUT < [ +FORM "/“/" ] >,
     +OUTPUT <  > ].
|#

delete-italics-left-rule := inpmap-rule &
   [ +INPUT  < [ +FORM "“", +FROM #from ],
	       [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +TO #to, +TNT #tnt ] >,
     +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >,
   +POSITION "I1<I2" ].


delete-italics-right-rule := inpmap-rule &
   [ +INPUT  < [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TNT #tnt ],
	       [ +FORM "”", +TO #to ] >,
     +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >,
   +POSITION "I1<I2" ].

; This should maybe be done instead in wiki.fsr
;
; |played[,]|
bracketed-comma-rule := inpmap-rule &
   [ +INPUT < [ +FORM "[" ],
	      [ +FORM ",", +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ],
	      [ +FORM "]" ] >,
     +OUTPUT < [ +FORM ",", +ONSET #onset, +CLASS #class,
		 +PRED #pred, +CARG #carg, 
		 +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >, 
     +POSITION "I1<I2<I3" ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; re-combine punctuation marks with adjacent tokens, based on directionality
;;; of punctuation marks, e.g. opening vs. closing quotes and brackets.  doing
;;; one such re-combination at a time is sufficient, as each rewrite rule will
;;; apply as many times as it possible can, seeing its own output from earlier
;;; applications.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;; but first, preserve the current (non-punctuated) from in +CARG, for later
;; reference, e.g. in constructing +PRED values for generics.  NE rules have
;; done this already, hence make sure to not overwrite existing +CARGSs.
;;
default_carg_tmr := token_mapping_rule &
[ +INPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
             +PRED #pred, +CARG anti_string,
             +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >,
  +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
              +PRED #pred, +CARG #form,
              +ID #id, +FROM #from, +TO #to, +TNT #tnt ] > ].

prefix_punctuation_tmr := token_mapping_rule &
[ +INPUT < [ +FORM "/([[({“‘]+)/",
             +FROM #from ],
           [ +FORM "/(.+)/",
             +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
             +TO #to, +TNT #tnt ] >,
  +OUTPUT < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
             +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
             +FROM #from, +TO #to, +TNT #tnt ] >,
  +POSITION "I1<I2" ].

;;
;; _fix_me_
;; there is a special case here: |'| following a token ending in |s| could be a
;; possessive marker (which should remain a token in its own right), or could 
;; be a closing single quote.  in principle, the same is true for |"|, but the
;; `feet' measure unit, possibly, will have been detected during NE recognition
;; earlier.  in either case, we would need a way of keeping a separate |'| in
;; the chart, and also re-combine it with the preceding token.  (14-sep-08; oe)
;;
suffix_punctuation_tmr := token_mapping_rule &
[ +INPUT < [ +FORM "/(.+)/",
             +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
             +FROM #from, +TNT #tnt ],
           [ +FORM "/([])}”\"’,;.!?]+)/",
             +TO #to ] >,
  +OUTPUT < [ +FORM "${I1:+FORM:1}${I2:+FORM:1}",
              +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg, 
              +FROM #from, +TO #to, +TNT #tnt ] >,
  +POSITION "I1<I2" ].


;;;
;;; Eliminate any string-initial stranded punctuation (from faulty segmentatn)
;;;
stranded-punct-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([;,.!\)\?\\*]+)/" ],
               [ +FORM "/([a-zA-ZÅåØøÆæ0-9\\-\?]+)/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +OUTPUT  < [ +FORM "${I2:+FORM:1}", +TNT #tnt,
 		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +POSITION "I1<I2" ].

solitary-punct-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9!.\)\\-\?]+)/", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ], 
               [ +FORM "/([;,.!\)\\*]+)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] >,
    +POSITION "I1<I2" ].

;;;
;;; Parenthetical plurals - remove parens
;;;
paren-plural-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/([A-Za-zÅåØøÆæ]*)\\(s\\)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}s" ] > ].

;;
;; _fix_me_
;; i believe everything from here on downto `space-after-o-l-rule' is another
;; family of tokenization adjustment rules.  most seem to aim for robustness,
;; but again i think they are in the wrong place: if we are to correct faulty
;; tokenization, we should do it early on, such that everything else works the
;; way it does anyway.  for example, splitting off |(| at this point (after we
;; have re-attached prefix and suffix punctuation marks already) would mean we
;; risk ending up with |(| as a token of its own, or we would have to re-run
;; the combination rules for prefix and suffix punctuation.  can we take out
;; this block for the time being, and return to robustness once we have things
;; stable for properly typed inputs, e.g. CB and WeScience?    (20-sep-08; oe)
;;
;;;
;;; Add white space to left of ( and [
;;;
space-lbrack-rule := inpmap-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([\(\[])/", +TNT #tnt ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ],
    	       [ +FORM "${I1:+FORM:2}", +TNT #tnt,
		 +ONSET #onset, +CLASS #class, +PRED #pred, +CARG #carg ] > ].
;;;
;;; Add white space around colon if sandwiched with following alphanumeric
;;; (but not e.g. |http://...| and not ratios with numbers on both sides)
;;;
squished-punct16-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([:])([a-zA-ZÅåØøÆæ]+)/", 
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}" ] > ].

squished-punct17-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ.]+)([:])([a-zA-ZÅåØøÆæ0-9]+)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}" ] > ].

;;;
;;; And add white space to the left of colon when followed by white space:
;;;
squished-punct18-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([:])/", +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "${I1:+FORM:2}" ] > ].

;;;
;;; And the variants with surrounding punctuation
;;;
squished-punct19-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ]+)([,/])([a-zA-ZÅåØøÆæ]+)([.?!,;])/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

squished-punct20-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([0-9]+)([,/])([a-zA-ZÅåØøÆæ]+)([.?!,;])/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

squished-punct21-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ])([,/])([0-9])([.?!,;])/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

;;;
;;; Add space to left of left paren and to right of right paren
;;;

squished-punct22-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
      "/([\(]*)([a-zA-ZÅåØøÆæ]+)([\(\[])([a-zA-ZÅåØøÆæ0-9]+)([.\?!,;\":\)]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct23-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM 
     "/([\(]*)([a-zA-ZÅåØøÆæ]+)([\\]\)])([a-zA-ZÅåØøÆæ0-9]+)([.\?!,;\":\)]*)/",
                 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}${I1:+FORM:3}" ],
               [ +FORM "${I1:+FORM:4}${I1:+FORM:5}" ] > ].

squished-punct24-rule := inpmap-x13-rule &
  [ +INPUT   < [ +FORM "/([a-zA-ZÅåØøÆæ0-9.]+)([—])([a-zA-ZÅåØøÆæ]+)([.?,]*)/",
		 +CLASS non_ne ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}" ],
    	       [ +FORM "---" ],
               [ +FORM "${I1:+FORM:3}${I1:+FORM:4}" ] > ].

;;;
;;; Remove space after initial "O'" and "L'"
;;;
space-after-o-l-rule := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "/([\(]*)([lLoO])'/", +TNT #tnt ], 
	       [ +FORM "/([a-zA-ZÅåØøÆæ]+)/" ] >,
    +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}'${I2:+FORM:1}", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;
;;; Replace left and right angle marks with variant, to avoid communication 
;;; troubles among preprocessor, [incr tsdb()], and PET.
;;;
;; _fix_me_
;; are these still necessary?
;;
leftangle-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/< /" ] >,
    +OUTPUT  < [ +FORM "leftangle " ] > ].

rightangle-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "/ >/" ] >,
    +OUTPUT  < [ +FORM " rightangle" ] > ].

;;;
;;; Assign +CLASS for words with leading uppercase, so we keep these unknowns.
;;; But for now, not on sentence initial words.
;;;
;; _fix_me_
;; once we avoid leakage of +CLASS information underway, we should no longer
;; have to do the following two rules (looking at +TAGS.REST.FIRST is hardly
;; pretty anyway).                                             (20-sep-08; oe)
;;
mixed-case-proper-1-rule := inpmap-rule &
   [ +CONTEXT < [ ] >,
     +INPUT < [ +FORM "/([A-ZÅØ])([A-Za-zÅåØøÆæ0-9,.\?]*)/",
		+TNT #tnt & [ +TAGS.FIRST "NNP" ],
		+ID #id, +FROM #from, +TO #to ] >,
     +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}",
		  +CLASS [ +INITIAL -, +CASE capitalized ],
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "C1<I1" ].

mixed-case-proper-2-rule := inpmap-rule &
   [ +CONTEXT < [ ] >,
     +INPUT < [ +FORM "/([A-ZÅØ])([A-Za-zÅåØøÆæ0-9,.\?]*)/",
		+TNT #tnt & [ +TAGS.REST.FIRST "NNP" ],
		+ID #id, +FROM #from, +TO #to ] >,
     +OUTPUT  < [ +FORM "${I1:+FORM:1}${I1:+FORM:2}",
		  +CLASS [ +INITIAL -, +CASE capitalized ],
		  +TNT #tnt, +ID #id, +FROM #from, +TO #to ] >,
     +POSITION "C1<I1" ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; finally, convert everything to lower case, for lexical look-up in PET
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

downcase_tmr := one_one_form_tmt &
[ +INPUT < [ +FORM "/(.*[[:upper:]].*)/" ] > ,
  +OUTPUT < [ +FORM "${lc(I1:+FORM:1)}" ] > ].

;;;
;;; Spelling correction
;;;
;; _fix_me_
;; these should move up towards the beginning of token mapping, such that (for
;; example, they can also do their work when there is punctuation around them.
;;                                                             (20-sep-08; oe)
everytime-rule := inpmap-x12-rule &
  [ +INPUT   < [ +FORM "everytime"] >,
    +OUTPUT  < [ +FORM "every" ],
	       [ +FORM "time" ] > ].

dont-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "dont"] >,
    +OUTPUT  < [ +FORM "don't" ] > ].

wont-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "wont"] >,
    +OUTPUT  < [ +FORM "won't" ] > ].

recieve-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "recieve"] >,
    +OUTPUT  < [ +FORM "receive" ] > ].

labled-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "labled"] >,
    +OUTPUT  < [ +FORM "labeled" ] > ].

didnt-rule := inpmap-x11-rule &
  [ +INPUT   < [ +FORM "didn;t"] >,
    +OUTPUT  < [ +FORM "didn't" ] > ].

didnt-rule-2 := inpmap-x21-rule &
  [ +INPUT   < [ +FORM "didn;", +TNT #tnt],
	       [ +FORM "t"]>,
    +OUTPUT  < [ +FORM "didn't", +TNT #tnt ] >,
    +POSITION "I1<I2" ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; at this point, we multiply out PoS values on all tokens, where for each
;;; original token as many additional tokens are created (in the same chart
;;; cell) as there are PoS readings.  at this point, we start distinguishing
;;; between tokens that activate native lexical entries (LEs), vs. those that
;;; activate generic LEs.  in the token universe, this distinction is made by
;;; virtue of +ONSET, with unk_onset reserved for generic LEs.  the two sets
;;; do not overlap, i.e. for a single original token with two PoS readings, we
;;; end up with a total of three new tokens.  the pair of rules below resembles
;;; a recursive function, terminating once the PoS list has been reduced to 
;;; a singleton element.  form-based named entities identified earlier avoid
;;; this kind of PoS multiplication because they have already emptied out their
;;; PoS list.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;; even though we originally made sure all tokens had a fully specified +TNT
;; value, intervening rules could have `leaked' PoS information.  if so, once
;; again, fully annul the +TNT value.
;;
tnt_default_tmr := one_one_tmt &
[ +INPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
             +PRED #pred, +CARG #carg, +TNT [ +TAGS < anti_string, ... > ] ] >,
  +OUTPUT < [ +FORM #form, +ONSET #onset, +CLASS #class,
              +PRED #pred, +CARG #carg, +TNT null_tnt ] > ].

tnt_recurse_rule := token_mapping_rule &
[ +INPUT < [ +FORM #form, +ONSET anti_onset,
             +CLASS #class, +PRED #pred, +CARG #carg,
             +ID #id, +FROM #from, +TO #to,
             +TNT [ +TAGS < #tag . #tags & *cons* >,
                    +PRBS < #prb . #prbs & *cons* > ] ] > ,
  +OUTPUT < [ +FORM #form, +ONSET unk_onset,
              +CLASS #class, +PRED #pred, +CARG #carg,
              +ID #id, +FROM #from, +TO #to,
              +TNT [ +TAGS < #tag >, +PRBS < #prb > ] ],
            [ +FORM #form,
              +CLASS #class, +PRED #pred, +CARG #carg,
              +ID #id, +FROM #from, +TO #to,
              +TNT [ +TAGS #tags, +PRBS #prbs ] ] > ,
  +POSITION "O1=O2" ].

tnt_terminate_tmr := token_mapping_rule &
[ +INPUT < [ +FORM #form, +ONSET anti_onset,
             +CLASS #class, +PRED #pred, +CARG #carg,
             +ID #id, +FROM #from, +TO #to,
             +TNT [ +TAGS < #tag >, +PRBS < #prb > ] ] > ,
  +OUTPUT < [ +FORM #form, +ONSET unk_onset,
              +CLASS #class, +PRED #pred, +CARG #carg,
              +ID #id, +FROM #from, +TO #to,
              +TNT [ +TAGS < #tag >, +PRBS < #prb > ] ],
            [ +FORM #form, +ONSET con_or_voc,
              +CLASS #class, +PRED #pred, +CARG #carg,
              +ID #id, +FROM #from, +TO #to,
              +TNT null_tnt ] >,
  +POSITION "O1=O2" ].

;;;
;;; with singleton PoS readings multiplied out in each chart cell, we can prune
;;; undesirable alternatives, e.g. a foreign word reading when there also is a
;;; common noun.  also, ditch PoS readings with very low probability, and ones
;;; for which no PoS-activated generic entries exist anyway (function words).
;;;
;;; _fix_me_
;;; should we eventually want to include the PoS probabilities as a feature in
;;; parse selection, this kind of pruning should disappear: a high-probability
;;; FW, say, should not be bullied out by an unlike NN.         (31-aug-08; oe)
;;;

tnt_ditch_unlikely_tmr := token_mapping_rule &
[ +INPUT < [ +TNT.+PRBS < "/0?\\.0.*/" > ] >,
  +OUTPUT < > ].

tnt_ditch_function_1_tmr := token_mapping_rule &
[ +INPUT < [ +TNT.+TAGS < "/CC|DT|EX|IN|MD|PDT|POS|PRP\\$?|RB[RS]/" > ] >,
  +OUTPUT < > ].

tnt_ditch_function_2_tmr := token_mapping_rule &
[ +INPUT < [ +TNT.+TAGS < "/RP|TO|UH|WDT|WP|WRB/" > ] >,
  +OUTPUT < > ].

tnt_ditch_function_3_tmr := token_mapping_rule &
[ +INPUT < [ +TNT.+TAGS < "\\$|#|``|''|\\(|\\)|,|\\.|:/" > ] >,
  +OUTPUT < > ].

;;
;; _fix_me_
;; experimentally, also ditch PoS information on punctuation-only tokens.  we
;; appear to get noun and adjective readings for n- and m-dashes, which hardly
;; can do us any good.                                         (24-sep-08; oe)
;;
tnt_ditch_punctuation_tmr := token_mapping_rule &
[ +INPUT < [ +FORM "/[[:punct:]]+/", +TNT.+TAGS *cons* ] >,
  +OUTPUT < > ].

tnt_filter_dup_fw_tmr := token_mapping_rule &
[ +CONTEXT  < [ +TNT.+TAGS < "NN" > ] >,
  +INPUT    < [ +TNT.+TAGS < "FW" > ] >,
  +OUTPUT   < >,
  +POSITION "I1=C1" ].

tnt_filter_dup_nnp_tmr := token_mapping_rule &
[ +CONTEXT  < [ +TNT.+TAGS < "/FW|NN/" > ] >,
  +INPUT    < [ +TNT.+TAGS < "NNP" > ] >,
  +OUTPUT   < >,
  +POSITION "I1=C1" ].

tnt_filter_dup_nnps_tmr := token_mapping_rule &
[ +CONTEXT  < [ +TNT.+TAGS < "NNP" > ] >,
  +INPUT    < [ +TNT.+TAGS < "NNPS" > ] >,
  +OUTPUT   < >,
  +POSITION "I1=C1" ].

;;
;; now done upon entry to token mapping, along a three-dimensional hierarchy.
;; _fix_me_
;; but many of the earlier rules still `leak', i.e. do not always copy +CLASS
;; (or +PRED, +CARG, and others), hence once again make sure to force a +CLASS
;; value that will keep this token out of the way of generic entries.
;;                                                             (17-sep-08; oe)
assign-default-class := inpmap-rule &  
[ +INPUT   < [ +FORM #form, +ONSET #onset,
	       +CLASS noclass, +PRED #pred, +CARG #carg,
	       +ID #id, +FROM #from, +TO #to, +TNT #tnt ] >,
  +OUTPUT  < [ +FORM #form, +ONSET #onset,
	       +CLASS non_alphanumeric, +PRED #pred, +CARG #carg,
	       +ID #id, +FROM #from, +TO #to, +TNT #tnt ] > ].


;;; Would like to be able to assign +PRED value based on +FORM, but the
;;; software does not seem to currently allow reference to input's +FORM
;;; in value for +PRED.  So for now, put in place-holder +PRED strings
;;; for each POS variety of unknown word.

#|
assign-semantics-nn := inpmap-rule &  
[ +INPUT   < [ +FORM #form & "/([a-zA-Z0-9]+)/",
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "NN" > ], +FROM #from, +TO #to ] >,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED "_${I1:+FORM:1}_n_rel", +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].
|#

assign-semantics-nn := inpmap-rule &  
[ +INPUT   < [ +FORM #form,
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "/(NN|FW)/" > ], +FROM #from, +TO #to ]>,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED "unknown_n_rel", +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].

assign-semantics-v := inpmap-rule &  
[ +INPUT   < [ +FORM #form,
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "/VB[A-Z]*/" > ], +FROM #from, +TO #to]>,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED "unknown_v_rel", +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].

assign-semantics-a := inpmap-rule &  
[ +INPUT   < [ +FORM #form,
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "/(JJ|JJR|JJS|RB)/" > ], 
	       +FROM #from, +TO #to]>,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED "unknown_a_rel", +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to ] > ].

assign-semantics-pn := inpmap-rule &  
[ +INPUT   < [ +FORM #form, +PRED #pred,
	       +CLASS #class & non_ne, +ONSET #onset & unk_onset, +ID #id,
	       +TNT #tnt & [ +TAGS < "/(NNP|NNPS|CD)/" > ], 
	       +FROM #from, +TO #to ] >,
  +OUTPUT  < [ +FORM #form,
	       +CLASS #class, +PRED #pred, +ONSET #onset,
	       +TNT #tnt, +ID #id, +FROM #from, +TO #to, +CARG #form ] > ].

