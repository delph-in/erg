;;; -*- mode: fundamental; coding: iso-8859-1; indent-tabs-mode: t; -*-

;;;
;;; first shot at a finite-state language for preprocessing, normalization, and
;;; tokenization in LKB grammars.  requires LKB version after 1-feb-03.  note
;;; that the syntax is rigid: everything starting in column 2 (i.e. right after
;;; the rule type marker) is used as the match pattern until the first `\t'
;;; (tabulator sign); one or more tabulator sign are considered the separator
;;; between the matching pattern and the replacement, but other whitespace will
;;; be considered part of the patterns.  empty lines or lines with a semicolon
;;; in column 1 (i.e. in place of the rule type marker, this is not Lisp) will
;;; be ignored.
;;;
;;; rules are applied in order and, in the case of substitution rules, each see
;;; the output of the previous iteration.  token-level augmentation rules (the
;;; `+' type, for now) are different in that they add an alternative for the 
;;; token but the original form remains in the input buffer for subsequent rule
;;; applications (i.e. the alternative is _not_ visible to further rules).

;;;
;;; preprocessor rules versioning; auto-maintained upon CVS check-in.
;;; 
@$Date$

;;;
;;; tokenization pattern: after normalization, the string will be broken up at
;;; each occurrence of this pattern; the pattern match itself is deleted.
;;;
:[ \t]+

;;;
;;; string rewrite rules: all matches, over the entire string, are replaced by
;;; the right-hand side; grouping (using `(' and `)') in the pattern) and group
;;; references (`\1' for the first group, et al.) carry over part of the match.
;;;

;;;
;;; pad the full string with trailing and leading whitespace; makes matches for
;;; word boundaries a little easier down the road.
!^(.+)$					 \1 

;;;
;;; separate hash sign from right-adjacent number(s)
;;;
!(#|\()([0-9])				\1 \2

;;;
;;; replace multiple punctuation marks with only the last one
!([?!.])[?!.]+		 		\1

;;;
;;; for now, separate all parentheses with whitespace on either side from the
;;; preceding and following material.
!([()])				 \1 

;;;
;;; for now, separate all punctuation with whitespace on either side from the
;;; preceding and following word(s).
!([-.?!:;,#]) 				 \1 
! ([-.?!:;,])				 \1 

;;;
;;; add white space on either side of squished commas, hyphens, colons
!([-,:])				 \1 

;;;
;;; do the same for hyphen, colon as in "7-10" "X:Y"
!([-:])					 \1 

;;;
;;; do the same for forward slash if not numeric as in "dogs/cats"
!([a-z])(/)([a-z])				\1 \2 \3

;;;
;;; apostrophes are a bit tricky: generally, we want to separate leading and 
;;; trailing single quotes from adjacent word material, so that they become a
;;; separate token (e.g. |abrams'| --> |abrams '|); the possesive |'s|, on the
;;; other hand, we want to separate but then consider a single token.
;;;
!' 					 ' 
!([^ ])'s 				\1 's 

;;; Contracted auxiliaries:
!([^ ])'ll 				\1 'll 
!([^ ])'d 				\1 'd 
!([^ ])'ve 				\1 've 
!([^ ])'m 				\1 'm 
!([^ ])'re 				\1 're 

;;;
;;; For now, throw away punctuation analogous to what we used to do for the LKB
;;; and PET.
;;;
! \.!\?;,\(\) 				 

;;;
;;; from here on, token-specific rules, i.e. the pattern has to match the full
;;; string of the token (implicit `^' and ~$' anchoring).  three types of rules
;;; for now: (i) substitution (`-'), replacing the token with the right-hand
;;; side match, (ii) augmentation (`+'), adding an alternative spelling for the
;;; token, and ersatzing (`^'), effectively a substitution but recording what
;;; the original string was for later retrieval (to be implementend :-).
;;;
-recieve				receive
-recieves				receives
-recieved				received
-recieving				receiving

-recived				received
-reeived				received
-receieved				received
-orderd					ordered
-ordereed				ordered
-recweipt				receipt
-goin					going
-oing					going
-goint					going
-wht					what
-cutomers				customers
-nrmally				normally
-orderc					orders
-happend				happened
-happned				happened
-hoiw					how
-ordrer					order
-teh					the
-didn;t					didn't
-have't					haven't
-everyting				everything
-inqueries				inquiries
-awsome					awesome
-undersrtand				understand
!eventhough				even though
!suppoesedto				supposed to
!-wha't					what 's
-whethere				whether
-has't					hasn't
-acceped				accepted
-corrctly				correctly
-appriciated				appreciated
-inconvinience				inconvenience
-degital				digital
-plaese					please
-pleasae				please
-vacatation				vacation
-detexctor				detector
-hepl					help
-adrres					address
-tks					thanks
-trackionn				tracking
-dlay					delay
-expcet					expect
-sometning				something
-thorugh				through
-cna					can
-waitin					waiting
-lapto					laptop
-loptap					laptop
-nubmer					number
-numer					number
-agao					ago
-orde					order
-mey					my
-knhow					know
-vio					vaio
-tring					trying
-ericcson				ericson
-erickson				ericson
-delyaed				delayed
-arived					arrived
-hans't					hasn't
-worng					wrong
-ther					there
-USPC					USPS

+fo					of
+stats					status
+youn					you
+th					the
+it 's					its
+you					your

^[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}		DateErsatz
^[0-9]{1,2}/[0-9]{1,2}/[0-9]{2}		DateErsatz
^[0-9]{1,2}/[0-9]{4}			DateErsatz
^[0-9]{1,2}/[0-9]{2}			DateErsatz

^[0-9]*[A-Z]+[0-9]+			IdentifierErsatz
^[0-9]+[A-Z]+[0-9]*			IdentifierErsatz

^[0-9]{1}				OneDigitErsatz
^[0-9]{2}				TwoDigitErsatz
^[0-9]{3}				ThreeDigitErsatz
^[0-9]{4}				FourDigitErsatz
^[0-9]{5}				FiveDigitErsatz
^[0-9]{6}				SixDigitErsatz
^[0-9]{7}				SevenDigitErsatz
^[0-9]{8}				EightDigitErsatz
^[0-9]{9}				NineDigitErsatz
^[0-9]{10}				TenDigitErsatz
^[0-9]{11}				ElevenDigitErsatz
^[0-9]{12}				TwelveDigitErsatz
^[0-9]{13,}				ThirteenPlusDigitErsatz

