;;; Hey, emacs(1), this is -*- Mode: TDL; Coding: utf-8; -*- got it?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; ERG Semantic Interface (SEM-I); Version 1.0 (17-mar-16; oe & danf)
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;
;;; the hierarchy of variable types: these are (pretty) close to universal.
;;;
variables:

  u.
  i < u.
  p < u.
  h < p.
  e < i : PERF bool, PROGR bool, MOOD bool, TENSE tense, SF sf.
  x < i & p : DIV bool, IND bool, GEND gender, PERS person, NUM number, PT pt.


;;;
;;; now for the range of valid variable properties, minimal variable type for
;;; which a property is appropriate, and value constraint(s).
;;;
properties:

  bool.
  + < bool.
  - < bool.

  tense.
  tensed < tense.
  past < tensed.
  pres < tensed.
  fut < tensed.
  untensed < tense.

  mood.
  subjunctive < mood.
  indicative < mood.

  gender.
  m-or-f < gender.
  m < m-or-f.
  f < m-or-f.
  n < gender.

  number.
  sg < number.
  pl < number.

  person.
  1 < person.
  2 < person.
  3 < person.

  pt.
  refl < pt.
  std < pt.
  zero < pt.

  sf.
  prop-or-ques < sf.
  prop < prop-or-ques.
  ques < prop-or-ques.
  comm < sf.


;;;
;;; a quick summary of the inventory of valid role names and value constraints,
;;; if any (RSTR, for example, will always be handle-valued).
;;;
roles:

  ARG0 : i.
  ARG1 : u.
  ARG2 : u.
  ARG3 : u.
  ARG4 : h.
  ARG : u.
  BODY : h.
  CARG : string.
  L-HNDL : u.
  L-INDEX : i.
  R-HNDL : u.
  R-INDEX : i.
  RSTR : h.


;;;
;;; finally, the main ‘predicates’ section: for each valid semantic predicate,
;;; one or more entries detailing the range of admissible roles, constraints on
;;; role values (in terms of variable types), and additional variable property
;;; restrictions, if any.
;;;
predicates:

  ;;
  ;; a few manually-maintained entries that do not come out of the automatic
  ;; SEM-I creation in the LKB (yet).  primarily abstract relation types that
  ;; we want to expose, even though there is no lexical entry or rule that has
  ;; this exact predicate in its semantics.  we should be doing something about
  ;; hierarchical relations among predicates too, obviously, but getting these
  ;; out of the LKB automatically will require a bit more thinking and work.
  ;;                                                            (27-sep-06; oe)
  ;;

  ;;
  ;; to have something to play with: an abstraction over various constructions
  ;; that express an underspecified two-place relation between two instances,
  ;; e.g.  ‘the orchestra performance’, ‘the orchestra's performance’, ‘the
  ;; performance of the orchestra’.  it may of course not always be the case
  ;; that all variants generated from these abstractions are grammatical and
  ;; close paraphrases, and use of ‘nn’ would have to be paired with suitable
  ;; quantifier abstractions, but this seems a potentially useful device for
  ;; providers of generator inputs, nevertheless.  without changes to the
  ;; grammar-internal hierarchy, we should be able to make this work now!
  ;;
  ;; _fix_me_
  ;; in 1214, ‘poss’ is a sub-type to ‘of_p’, and by default both make it into
  ;; the core SEM-I.  when we discussed this bit in an earlier ESD meeting, we
  ;; thought we wanted these two reversed (and deprecate ‘of_p’, which is only
  ;; used in ‘April 16’, and might as well be ‘poss’).  not quite sure what is
  ;; the best thing to do for this release; i believe we could in principle
  ;; use the patching alias to rename (i.e. swap) these two, but i struggle to
  ;; say with confidence whether that should just work for the generator?
  ;;                                                            (16-apr-16; oe)
  nn : ARG0 e, ARG1 x, ARG2 x.
  poss < nn.
  compound < nn.

  ;;
  ;; a hierarchy of quantifiers, partly drawn from the grammar-internal type
  ;; hierarchy, partly stipulated manually (e.g. adding entries and renaming
  ;; some of the internal types; see ‘patches.lisp’ for details).
  ;;
  abstract_q : ARG0 x, BODY h, RSTR h.
  exist_q < abstract_q.
  universal_q < abstract_q.

include: core.smi
