;;; Hey, emacs(1), this is -*- Mode: TDL; Coding: utf-8; -*- got it?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; ERG Semantic Interface (SEM-I)
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;
;;; the `signature' section: all there is to know about hierarchical relations
;;; holding among SEM-I entries.
;;;

signature:

  ;;
  ;; the hierarchy of variable types: these are (pretty) close to universal 
  ;;
  u := top.
  i := u.
  p := u.
  h := p.
  e := i.
  x := i & p.

  ;;
  ;; the various sub-hierarchies for variable properties; some shared across
  ;; sets of grammars, some language- or grammar-specific
  ;;
  bool := top.
  + := bool.
  - := bool.

  tense := top.
  tensed := tense.
  past := tensed.
  non-past := tensed.
  pres := non-past.
  fut := non-past.
  untensed := tense.

  mood := top.
  subjunctive := mood.
  indicative := mood.

  gender := top.
  m-or-f := gender.
  m := m-or-f.
  f := m-or-f.
  n := gender.

  num := top.
  sg := num.
  pl := num.

  pers := top.
  1 := pers.
  2 := pers.
  3 := pers.

  prontype := top.
  refl := prontype.
  std := prontype.
  zero := prontype.

  iforce := top.
  prop-or-ques := iforce.
  prop := prop-or-ques.
  ques := prop-or-ques.
  comm := iforce.
  like-iforce := prop-or-ques.

;;;
;;; now for the range of valid variable properties, minimal variable type for
;;; which a property is appropriate, and value constraint(s).
;;;
properties:

  DIV [x] : bool
  IND [x] : bool
  PERF [e] : bool
  PROGR [e] : bool
  MOOD [e] :  mood
  TENSE [e] : tense
  GEND [x] : gender
  PERS [x] : pers
  NUM [x] : num
  PRONTYPE [x] : prontype
  SF [e] : iforce

;;;
;;; a quick summary of the inventory of valid role names and value constraints,
;;; if any (RSTR, for example, will always be handle-valued).
;;;
roles:

  ARG0 : i
  ARG1 : u
  ARG2 : u
  ARG3 : u
  ARG4 : h
  ARG : u
  BODY : h
  CARG : symbol string
  L-HNDL : u
  L-INDEX : i
  R-HNDL : u
  R-INDEX : i
  RSTR : h

;;;
;;; finally, the main `predicates' section: for each valid semantic predicate,
;;; one or more entries detailing the range of admissible roles, constraints on
;;; role values (in terms of variable types), and additional variable property
;;; restrictions, if any.
;;;
predicates:

  ;;
  ;; a few manually-maintained entries that do not come out of the automatic
  ;; SEM-I creation in the LKB (yet).  primarily abstract relation types that
  ;; we want to expose, even though there is no lexical entry or rule that has
  ;; this exact predicate in its semantics.  we should be doing something about
  ;; hierarchical relations among predicates too, obviously, but getting these
  ;; out of the LKB automatically will require a bit more thinking and work.
  ;;                                                            (27-sep-06; oe)
  ;;

  ;;
  ;; in the auto-generated `core.smi', this one comes out with two variants, of
  ;; which the nominal one [ ARG0 x ], lacks L-HNDL and R-HNDL. (19-oct-06; oe)
  ;;
  implicit_conj : ARG0 x, L-HNDL u, L-INDEX i, R-HNDL u, R-INDEX i.

  implicit_q : ARG0 x, BODY h, RSTR h.
  quant : ARG0 x, BODY h, RSTR h.
  ; supertype of def_q, udef_q, _a_q, some-any_q
  def_udef_some_a_q : ARG0 x, BODY h, RSTR h.
  ; supertype of def_q, udef_q, _a_q
  def_udef_a_q : ARG0 x, BODY h, RSTR h.

  def_q : ARG0 x, BODY h, RSTR h.
  idiom_q : ARG0 x, BODY h, RSTR h.

  ; temp or nontemp 'in, on, at' plus loc_nonsp
  unspec_loc : ARG0 i, ARG1 u, ARG2 u.
  ; nonspecific locative: temp or nontemp
  loc_nonsp : ARG0 i, ARG1 u, ARG2 u.
  ; temp or nontemp 'in, on, at'
  loc_sp : ARG0 i, ARG1 u, ARG2 u.
  ; nontemp 'in, on, at' plus loc_nonsp
  nontemp_sp_or_nonsp : ARG0 i, ARG1 u, ARG2 u.
  ; nontemp 'in, on, at'
  nontemp_loc_sp : ARG0 i, ARG1 u, ARG2 u.
  ; temp 'in, on, at' plus loc_nonsp
  temp_sp_or_nonsp : ARG0 i, ARG1 u, ARG2 u.
  ; temp 'in, on, at'
  temp_loc_sp : ARG0 i, ARG1 u, ARG2 u.

  ; 'can' or 'be able to'
  can_able : ARG0 e, ARG1 h.
  ; compound or 'of' 
  compound_or_prep : ARG0 i, ARG1 u, ARG2 u.

include: core.smi
