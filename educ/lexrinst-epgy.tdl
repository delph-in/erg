;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2005
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see LICENSE for conditions
;;;
;;;  lexrinst.tdl
;;;
;;;  Instances of lexical rules defined in lexrules.tdl
;;;
;;;  Created: Ann Copestake, 30-Sept-97
;;;
;;;  $Id: lexrinst.tdl 6565 2009-05-24 08:05:14Z danf $

;; Letter set hack for robust inflectional rules that should never match on
;; pattern, so only the irregular forms of these (in irregs-educ) ever apply
;;
%(letter-set (!( \())

v_aux-sb-inv_dlr := sai &
  [ RNAME lsai ].

v_cond-inv_dlr := cond_sai &
  [ RNAME csai ].

v_aux-advadd_dlr := adv_addition &
  [ RNAME ladv ].

;;; Tempted to block ellipsis, but not consistently marked.
;;; e.g. `Jerome did'
v_aux-ell-ref_dlr := vp_ellipsis_ref &
  [ SYNSEM.MODIFD.RPERIPH +,
    RNAME lver ].

; v_aux-ell-xpl_dlr := vp_ellipsis_expl &
;  [ RNAME lvex ].

v_aux-cx-noinv_dlr := contracted_aux_noninv_lr &
  [ RNAME lcx ].

;vgering := vger_ing &
;  [ RNAME lvgr ].

;; Prevent gerunds from appearing as heads of N-N compounds
;; e.g. |Kim is in the attic hunting for mice|
v_nger-intr_dlr := intrans_nominal_gerund &
  [ SYNSEM.MODIFD.LPERIPH +,
    RNAME lngi ].

v_nger-pp_dlr := intrans_pp_nominal_gerund &
  [ SYNSEM.MODIFD.LPERIPH +,
    RNAME lngp ].

;; DPF 2013-03-21 - Note that LPERIPH + here prevents e.g. |tadpole hunting|.
;; FIX?
v_nger-tr_dlr := trans_nominal_gerund &
  [ SYNSEM.MODIFD.LPERIPH +,
    RNAME lngt ].

n_det-mnth_dlr := month_det_lr &
  [ RNAME lmd ].

n_det-wkdy_dlr := weekday_det_lr &
  [ RNAME lwd ].

j_att_dlr := attr_adj_lr &
  [ RNAME lja ].

v_j-nb-intr_dlr := attr_verb_part_lr &
  [ RNAME ljv ].

v_j-nb-prp-tr_dlr := attr_verb_part_tr_lr &
  [ RNAME ljvt ].

v_j-nb-pas-tr_dlr := attr_verb_part_psv_lr &
  [ RNAME ljvp ].

v_j-nb-pas-ptcl_dlr := attr_verb_part_ptcl_psv_lr &
  [ RNAME ljvr ].

v_j-nme-intr_dlr := attr_verb_part_intr_namemod_lr &
  [ RNAME ljvn ].

v_j-nme-tr_dlr := attr_verb_part_tr_namemod_lr &
  [ RNAME ljnt ].

det_prt-of-agr_dlr := part_ppof_agr_constr &
  [ RNAME lpca ].

det_prt-of-nagr_dlr := part_ppof_noagr_constr &
  [ RNAME lpcn ].

det_prt-nocmp_dlr := part_nocomp_constr &
  [ RNAME lpn ].

v_np-prtcl_dlr := NP_particle_lr &
  [ RNAME lnpp ].

v_dat_dlr := dative_shift_lr &
  [ RNAME ldat ].

j_n-minut_dlr := minute_prep_lr &
  [ RNAME lmin ].

;;v_aux-tag_dlr := tag &
;;  [ RNAME ltag ].

;j_enough_dlr := enough_addition &
;  [ RNAME leno ].

j_tough_dlr := tough_adj_lr &
  [ RNAME ltgh ].

n_bipart_dlr := bipart_lr &
  [ RNAME lbpt ].

;w_italics_dlr := foreign_lr &
;  [ RNAME lfw ].

v_inv-quot_dlr := inverted_quote_lr &
  [ RNAME linq ].

n_n-ed_odlr := 
%suffix (* ed) (!ty !tied) (e ed) (!t!v!c !t!v!c!ced) 
noun_adj_lr &
  [ ND-AFF +,
    RNAME lnj ].

;; Disable for educ, but leave defined for irregs
j_n-pre_odlr := 
%prefix (* neverunify)
pre_noun_adj_lr &
  [ ND-AFF +,
    RNAME ljnp ].

v_v-re_dlr := 
%prefix (* re) (* re-) 
verb_prefix_rule &
 [ ND-AFF +,
   RNAME lre,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_re-_a_again_rel" ] !> ].

v_v-pre_dlr := 
%prefix (* pre) (* pre-) 
verb_prefix_rule &
 [ ND-AFF +,
   RNAME lpre,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_pre-_a_ante_rel" ] !> ].

v_v-co_dlr := 
%prefix (* co-) 
verb_prefix_rule &
 [ ND-AFF +,
   RNAME lco,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

v_v-mis_dlr := 
%prefix (* mis) (* mis-) 
verb_prefix_rule &
 [ ND-AFF +,
   RNAME lmis,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_mis-_a_error_rel" ] !> ].

;;;
;;; _fix_me_
;;; to make this rule functional, token mapping would have to not separate off
;;; |co-| (in `derivational_prefix_tmr').  however, doing that would then mean
;;; that either (a) we provide a prefixation rule for other parts of speech too
;;; (`co-author', maybe `co-educational') or minimally adjust existing lexical
;;; entries (currently MWEs); or (b) that we create a token-level ambiguity; i
;;; hesitate doing the latter.  but maybe it would not be so bad, in the end?
;;; the same problem applies to other derivational rules, of course.
;;;                                                             (13-mar-09; oe)
v_v-un_dlr := 
%prefix (* un) (* un-) 
verb_prefix_rule &
 [ ND-AFF +,
   RNAME lunv,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_un-_a_rvrs_rel" ] !> ].

v_v-counter_dlr := 
%prefix (* counter) (* counter-) 
verb_prefix_rule &
 [ ND-AFF +,
   RNAME lctv,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_counter-_a_anti_rel" ] !> ].

; <type val="v_v-over_dlr">
; <description>Verb with |over-| prefix           
; <ex>He over-built the porch.
; <nex>
; <todo>
; </type>
v_v-over_dlr := 
%prefix (* over) (* over-) 
v_v-over_rule &
 [ ND-AFF +,
   RNAME lctv,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_over-_a_1_rel" ] !> ].

; <type val="v_v-out_dlr">
; <description>Verb with |out-| prefix           
; <ex>He out-played his opponent.
; <nex>
; <todo>
; </type>
v_v-out_dlr := 
%prefix (* out) (* out-) 
v_v-out_rule &
 [ ND-AFF +,
   RNAME lotv,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_out-_a_1_rel" ] !> ].

; <type val="v_v-self_dlr">
; <description>Verb with |self-| prefix           
; <ex>He was self-insured.
; <nex>
; <todo>
; </type>
v_v-self_dlr := 
%prefix (* self) (* self-) 
v_v-self_rule &
 [ ND-AFF +,
   RNAME lotv,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_self-_a_1_rel" ] !> ].

; <type val="n_n-co_dlr">
; <description>Noun with |co-| prefix           
; <ex>Our co-teacher arrived.
; <nex>
; <todo>
; </type>
n_n-co_dlr := 
%prefix (* co) (* co-)
n_n-co_rule &
 [ ND-AFF +,
   RNAME lnco,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

; <type val="n_n-co-ni_dlr">
; <description>Noun with |co-| prefix, non-inflecting
; <ex>Our co-derivatives group arrived.
; <nex>
; <todo>
; </type>
n_n-co-ni_dlr := 
%prefix (* co) (* co-)
n_n-co-ni_rule &
 [ ND-AFF +,
   RNAME lncon,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

; <type val="n_n-counter_dlr">
; <description>Noun with |counter-| prefix           
; <ex>The counter-proposal arrived.
; <nex>
; <todo>
; </type>
n_n-counter_dlr := 
%prefix (* counter) (* counter-) 
n_n-counter_rule &
 [ ND-AFF +,
   RNAME lctn,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_counter-_a_anti_rel" ] !> ].

; <type val="n_n-counter-ni_dlr">
; <description>Noun with |counter-| prefix, non-inflecting
; <ex>The counter-narcotics team arrived.
; <nex>
; <todo>
; </type>
n_n-counter-ni_dlr := 
%prefix (* counter) (* counter-) 
n_n-counter-ni_rule &
 [ ND-AFF +,
   RNAME lctnn,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_counter-_a_anti_rel" ] !> ].

; <type val="j_j-co_dlr">
; <description>Adjective with |co-| prefix           
; <ex>The co-educational hall opened.
; <nex>
; <todo>
; </type>
j_j-co_dlr := 
%prefix (* co-) (* co) 
j_j-co_rule &
 [ ND-AFF +,
   RNAME ljco,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

; <type val="j_j-un_dlr">
; <description>Adjective with |un-| prefix           
; <ex>The unhappy cat arose.
; <nex>
; <todo>
; </type>
j_j-un_dlr := 
%prefix  (* un-) (* un)
j_j-un_rule &
 [ ND-AFF +,
   RNAME lunj,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_un-_a_neg_rel" ] !> ].

;;; From arboretum/mal-inflr.tdl

;; Disagreement rules, one for each direction.  Pair synsem with
;; "wrong" forms: The dog bark/the dogs barks.
;;
;; Constrain this one to only apply to pronominal subject, to avoid spurious
;; analysis using both this rule and the mal_plur_noun_irule
;; DPF 25-jun-10 - But we also want to catch e.g. "my knees hurts", so let's
;; try blocking --BARE +, to avoid the above spuriosity.
;; Also block clauses headed by such verbs from undergoing cl_np-wh_c rule
;; DPF 2013-05-10 - But [NORM no_rel] prevents conjoined robust forms, as in
;; |people arrives and arises|.  So remove, and monitor.
;;
non_third_sg_fin_v_rbst :=
%suffix (!s !ss) (!ss !ssses) (ss sses) (!ty !ties) (ch ches) (sh shes) (x xes) (z zes)
lex_rule_infl_affixed &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL non_third_sg_fin_verb &
	[ CAT [ HEAD.--MALN3SG +,
		VAL.SUBJ < [ LOCAL.CAT.HEAD [ --BARE -,
					    MINORS.MIN nonpart_nom_rel ] ] > ]],
  RNAME mn3s ].

;; DPF 2010-08-16 - Block subject extraction, to avoid spurious analysis for
;; "What do Kim and Abrams ..."
;;
third_sg_fin_v_rbst := lex_rule_infl_affixed &
[ GENRE robust,
  ND-AFF -,
  ORTH #stem,
  DTR [ ORTH #stem,
	SYNSEM.LOCAL.CAT [ HEAD.--MAL3SG +,
	                   VAL.SUBJ < expressed_synsem &
				      [ LOCAL.AGR.PNG.PN 3s,
					PUNCT.RPUNCT no_punct ] > ] ],
  SYNSEM.LOCAL third_sg_fin_verb,
  RNAME m3s ].

;; DPF 10-May-04 - We take plural marking on noun as intended (not to be
;; corrected), so only have one mal infl-rule for nouns to correct 
;; 'two dog bark' to 'two dogs bark'.  We will need a statistical preference 
;; mechanism to choose one of the two possible corrections for 'dog bark':
;; either 'dogs bark' or 'a/the dog barks'.  But have to have both, since
;; 'he bark' should presumably get corrected to 'he barks' (not 'they bark').
;; DPF 07-feb-10 - Changed DTR..MIN norm_nom_rel to reg_nom_rel, so it also
;; applies to measure nouns, as in "they ran twenty six mile."
;; Note that CASE on dtr must be nom to avoid spurious ambiguity for e.g.
;; direct objects where there is no constraint on number.
;; DPF 30-mar-10 - Restrict this to only apply when the determiner is overt, 
;; to avoid spurious ambiguity for e.g. "she told her brother borrow her book"
;; where `brother' formerly got made a plural.  So now we assume that number
;; on nouns is as the writer intended, unless there is a determiner present,
;; which might indicate competing number, as in "most thing are important"
;; the verb to match robustly when needed.
;; DPF 07-apr-10 - But still getting too much spurious ambiguity, as in
;; "His soup is".  So restrict further to just deictic dets for now.
;;
plur_noun_irule_rbst := lex_rule_infl_affixed &
[ GENRE robust,
  ND-AFF -,
  ORTH #stem,
  SYNSEM.LOCAL.CAT.HEAD.--BARE +,
  DTR [ ORTH #stem,
	SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN reg_nom_rel,
				  CASE nom ],
			   VAL.SPR < canonical_synsem &
				     [ --MIN demonstrative_q_rel ] > ] ],
  SYNSEM.LOCAL plur_noun,
  RNAME mpln ].


; For |Kim, Abrams(,) and Browne|
w_paren_comma-nf_plr :=
%suffix (!. !.\(,\))
punctuation_comma_rule.

v_prp-nf_olr := never_unify_le.

j_vp_bse_dlr_rbst := adj_vp_bse_mal_lr &
  [ RNAME ljvb ].

;; For e.g. |informations|
;;
n_pl-mass_olr_rbst :=
%suffix (!s !ss) (!ss !ssses) (es eses) (ss sses) (!ty !ties) (ch ches) (sh shes) (x xes) (z zes)
lex_rule_plural_mass &
[ ND-AFF +,
  RNAME lplm ].

;; Block robust comma, to avoid spurious analysis of "the cat, arrived."
w_comma-nf_plr :=
%suffix (!. !.,)
punctuation_comma_informal_rule &
 [ SYNSEM.LOCAL.CAT.HEAD no_head,
   RNAME lpcr ].

;; For wrong regular past inflection of irregular verbs (|buyed| for |bought|)
;;
v_pst_olr_rbst :=
%suffix (!( nevermatch)
v_pst_inflrule &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL past_or_subj_verb,
  RNAME lvptr ].

v_psp_olr_rbst :=
%suffix (!( nevermatch)
v_psp_inflrule &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL psp_verb,
  RNAME lvppr ].

v_pas_odlr_rbst := 
%suffix (!( nevermatch)
v_pas-norm_lexrule &
  [ GENRE robust,
    ND-AFF +,
    DTR.SYNSEM trans_subst &
               [ LOCAL [ CAT.VAL.COMPS [ FIRST [ LOCAL.CONT #objcont,
                                                 --SIND #objind,
                                                 NONLOC #ononloc ],
                                         REST #comps ] ],
                 LKEYS.KEYREL #keyrel ],
    SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT #objcont,
					  --SIND #objind,
					  NONLOC #ononloc ] >,
				 COMPS.REST #comps ] ],
                     CONT [ HOOK.XARG #objind ] ],
             LKEYS.KEYREL #keyrel ],
  RNAME lvpar ].

v_pas-p_odlr_rbst := 
%suffix (!( nevermatch)
prep_passive_verb_lr &
[ GENRE robust,
  ND-AFF +,
  RNAME lvper ].

v_pas-p-t_odlr_rbst := 
%suffix (!( nevermatch)
prep_passive_trans_verb_lr &
[ GENRE robust,
  ND-AFF +,
  RNAME lvpfr ].

v_pas-prt-t_odlr_rbst := 
%suffix (!( nevermatch)
prep_passive_ptcl_verb_lr &
[ GENRE robust,
  ND-AFF +,
  RNAME lvpgr ].

v_pas-dat_odlr_rbst := 
%suffix (!( nevermatch)
basic_passive_verb_lr &
  [ GENRE robust,
    ND-AFF +,
    DTR [ SYNSEM basic_ditrans_subst &
		 [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind, 
					      NONLOC #snonloc ] >,
				     COMPS < [ LOCAL.CONT #objcont,
					       --SIND #objind,
					       NONLOC #ononloc ],
					     #npcomp > ] ],
		   LKEYS.KEYREL #keyrel ] ],
    SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT #objcont,
					  --SIND #objind,
					  NONLOC #ononloc ] >,
				 COMPS < #npcomp,
                                       synsem & 
                                       [ LOCAL local &
                                         [ CAT [ HEAD prep & 
                                                   [ MINORS.MIN _by_p_cm_rel ],
                                                 VAL [ SUBJ < >,
                                                       SPR *olist*,
                                                       COMPS < > ] ],
                                           CONT.HOOK.INDEX #subjind ],
                                         NONLOC #snonloc,
                                         OPT + ] > ] ],
		     CONT [ HOOK.XARG #objind ] ],
             LKEYS.KEYREL #keyrel ],
  RNAME lvdpr ].

v_pas-cp_odlr_rbst := 
%suffix (!( nevermatch)
v_pas-cp_lexrule &
  [ GENRE robust,
    ND-AFF +,
    DTR.SYNSEM cp_passivable_verb &
               [ LOCAL.CAT.VAL [ COMPS #comps,
                                 KCMP #kcmp ] ],
    SYNSEM passive_atrans_synsem &
           [ LOCAL.CAT [ VAL [ COMPS.REST #comps,
			       KCMP #kcmp ] ] ],
    RNAME lvcpr ].

v_prp_olr_rbst :=
%suffix (!( nevermatch)
v_prp_inflrule &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL prp_verb,
  RNAME lvprr ].

v_3s-fin_olr_rbst :=
%suffix (!( nevermatch)
v_3s-fin_inflrule &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL third_sg_fin_verb,
  RNAME lvsgr ].
