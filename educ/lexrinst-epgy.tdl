;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2016
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see LICENSE for conditions
;;;
;;;  lexrinst.tdl
;;;
;;;  Instances of lexical rules defined in lexrules.tdl
;;;
;;;  Created: Ann Copestake, 30-Sept-97
;;;
;;;  $Id: lexrinst.tdl 7043 2009-09-03 18:26:55Z oe $

; <type val="v_aux-sb-inv_dlr">
; <description>Subject-auxiliary inversion      
; <ex>Did they arrive?           
; <nex>
; <todo>
; </type>
v_aux-sb-inv_dlr := sai_nonell_lexrule &
  [ RNAME lsai ].

; <type val="v_aux-sb-inv-ell_dlr">
; <description>Subject-auxiliary inversion with elided verbs
; <ex>Did they?
; <nex>
; <todo>
; </type>
v_aux-sb-inv-ell_dlr := sai_ell_lexrule &
  [ RNAME lsaie ].

; <type val="v_cond-inv_dlr">
; <description>Conditional inversion
; <ex>Had he left, we'd have left.
; <nex>
; <todo>
; </type>
v_cond-inv_dlr := cond_sai &
  [ RNAME csai ].

; <type val="v_aux-advadd_dlr">
; <description>Addition of adverb as complement 
; <ex>They did not arrive.       
; <nex>
; <todo>
; </type>
v_aux-advadd_dlr := adv_addition &
  [ RNAME ladv ].

;;?? comment out
; <type val="v_aux-neg-ell_dlr">
; <description>Elided VP with negation
; <ex>They would not.       
; <nex>
; <todo>
; </type>
v_aux-neg-ell_dlr := adv_add_neg_ellipt &
  [ RNAME lnav ].

; <type val="v_aux-ell-ref_dlr">
; <description>Elided VP compl, referentl subj  
; <ex>He did.                    
; <nex>
; <todo>
; </type>
v_aux-ell-ref_dlr := vp_ellipsis_ref &
  [ RNAME lver ].

; <type val="v_aux-ell-xpl_dlr">
; <description>Elided VP compl, expletive subj  
; <ex>It did.                    
; <nex>
; <todo>
; </type>
v_aux-ell-xpl_dlr := vp_ellipsis_expl &
  [ RNAME lvex ].

; <type val="v_aux-cx-noinv_dlr">
; <description>Contracted auxiliary, no subject-auxiliary inversion      
; <ex>Kim'll arrive.
; <nex> Kim'll.
; <todo>
; </type>
v_aux-cx-noinv_dlr := contracted_aux_noninv_lr &
  [ RNAME lcx ].

; <type val="v_nger-intr_dlr">
; <description>Nominal gerund of intrans verb   
; <ex>Leaving was easy.          
; <nex>
; <todo>
; </type>
v_nger-intr_dlr := intrans_nominal_gerund &
  [ RNAME lngi ].

; <type val="v_nger-pp_dlr">
; <description>Nominal gerund of PP-comp verb   
; <ex>Relying on Kim was wrong.  
; <nex>
; <todo>
; </type>
v_nger-pp_dlr := intrans_pp_nominal_gerund &
  [ RNAME lngp ].

; <type val="v_nger-tr_dlr">
; <description>Nominal gerund of trans verb     
; <ex>The hiring of Kim was OK.  
; <nex>
; <todo>
; </type>
v_nger-tr_dlr := trans_nominal_gerund &
  [ RNAME lngt ].

; <type val="n_det-mnth_dlr">
; <description>Month name as determiner         
; <ex>July tenth arrived.        
; <nex>
; <todo>
; </type>
n_det-mnth_dlr := month_det_lr &
  [ RNAME lmd ].

; <type val="n_det-wkdy_dlr">
; <description>Weekday name as determiner       
; <ex>We arrived Sunday morning. 
; <nex>
; <todo>
; </type>
n_det-wkdy_dlr := weekday_det_lr &
  [ RNAME lwd ].

; <type val="n_det-wkdy_dlr">
; <description>Weekday name as determiner       
; <ex>We arrived Sunday morning. 
; <nex>
; <todo>
; </type>
n_dom-ppof_dlr := dom_ppof_lr &
  [ RNAME ldp ].

; <type val="j_att_dlr">
; <description>Attrib adj from trans pred adj   
; <ex>A similar cat arrived.     
; <nex>
; <todo>
; </type>
j_att_dlr := attr_adj_lr &
  [ RNAME lja ].

; <type val="v_j-nb-intr_dlr">
; <description>Attrib adj from intrans verb     
; <ex>The sleeping cat stirred.  
; <nex>
; <todo>
; </type>
v_j-nb-intr_dlr := attr_verb_part_lr &
  [ RNAME ljv ].


; <type val="v_j-nb-prp-tr_dlr">
; <description>Attr adj from trans prp verb     
; <ex>The admiring crowd ran.    
; <nex>
; <todo>
; </type>
v_j-nb-prp-tr_dlr := attr_verb_part_tr_lr &
  [ RNAME ljvt ].

; <type val="v_j-nb-pas-tr_dlr">
; <description>Attr adj from trans passive verb 
; <ex>The hired consultant left. 
; <nex>
; <todo>
; </type>
v_j-nb-pas-tr_dlr := attr_verb_part_psv_lr &
  [ RNAME ljvp ].

; <type val="v_j-nb-pas-ptcl_dlr">
; <description>Attr adj from passive verb+selPP
; <ex>The hoped for consultant left. 
; <nex>
; <todo>
; </type>
v_j-nb-pas-ptcl_dlr := attr_verb_part_ptcl_psv_lr &
  [ RNAME ljvr ].

; <type val="v_j-nme-intr_dlr">
; <description>Attr adj from intr verb, nme mod, passive participle
; <ex>The respected Abrams won.    
; <nex>
; <todo>
; </type>
v_j-nme-intr_dlr := attr_verb_part_intr_namemod_lr &
  [ RNAME ljvn ].

; <type val="v_j-nme-intr-prp_dlr">
; <description>Attr adj from intr verb, nme mod, pres participle
; <ex>The smiling Abrams won.    
; <nex>
; <todo>
; </type>
v_j-nme-intr-prp_dlr := attr_verb_part_intr_namemod_prp_lr &
  [ RNAME ljvnp ].

; <type val="v_j-nme-tr_dlr">
; <description>Attr adj from trns verb, nme mod, passive participle
; <ex>Our admired Abrams smiled. 
; <nex>
; <todo>
; </type>
v_j-nme-tr_dlr := attr_verb_part_tr_namemod_lr &
  [ RNAME ljnt ].

; <type val="v_j-nme-tr-prp_dlr">
; <description>Attr adj from trns verb, nme mod, pres participle 
; <ex>Our winning Abrams smiled. 
; <nex>
; <todo>
; </type>
v_j-nme-tr-prp_dlr := attr_verb_part_tr_namemod_prp_lr &
  [ RNAME ljntp ].

; <type val="det_prt-of-agr_dlr">
; <description>Partitive NP, PP-of, num agrmt   
; <ex>Some of us are ready.      
; <nex>
; <todo>
; </type>
det_prt-of-agr_dlr := part_ppof_agr_constr &
  [ RNAME lpca ].

; <type val="det_prt-of-nagr_dlr">
; <description>Partitive NP, PP-of, no agrmt    
; <ex>Each of us is ready        
; <nex>
; <todo>
; </type>
det_prt-of-nagr_dlr := part_ppof_noagr_constr &
  [ RNAME lpcn ].

; <type val="det_prt-nocmp_dlr">
; <description>Partitive NP, no PP complement   
; <ex>Most arrived. part_nocomp  
; <nex>
; <todo>
; </type>
det_prt-nocmp_dlr := part_nocomp_constr &
  [ RNAME lpn ].

; <type val="v_np-prtcl_dlr">
; <description>Particle-NP reordering           
; <ex>He looked the answer up.   
; <nex>
; <todo>
; </type>
v_np-prtcl_dlr := NP_particle_lr &
  [ RNAME lnpp ].

; <type val="v_dat_dlr">
; <description>Dative shift alternation         
; <ex>They gave the book to him. 
; <nex>
; <todo>
; </type>
v_dat_dlr := dative_shift_lr &
  [ RNAME ldat ].

; <type val="v_it-cp-vp_dlr">
; <description>it-subj Verb+NP to CP or VP comp
; <ex>It annoyed B that we left.
; <nex>
; <todo>
; </type>
v_it-cp-vp_dlr := verb_it_cp_vp_lr &
  [ RNAME lvcv ].

; <type val="j_n-minut_dlr">
; <description>Integer as minute name           
; <ex>Ten sixteen is too late.   
; <nex>
; <todo>
; </type>
j_n-minut_dlr := minute_noprep_lr &
  [ RNAME lmin ].

; <type val="j_n-minut-p_dlr">
; <description>Integer as minute name with PP comp
; <ex>Sixteen to ten is too late.   
; <nex>
; <todo>
; </type>
j_n-minut-p_dlr := minute_prep_lr &
  [ RNAME lminp ].

; <type val="n_n-hour_dlr">
; <description>hour plus NP complement
; <ex>Ten sixteen is too late.   
; <nex>
; <todo>
; </type>
n_n-hour_dlr := hour_np_lr &
  [ RNAME lhour ].

;; EDUC: exclude
#|
; <type val="v_aux-tag_dlr">
; <description>Tag question auxiliary           
; <ex>He arrived, didn't he?     
; <nex>
; <todo>
; </type>
v_aux-tag_dlr := tag &
  [ RNAME ltag ].
|#

; <type val="j_enough_dlr">
; <description>Adj no-comps plus enough-compl
; <ex>A big enough cat arrived.
; <nex>
; <todo>
; </type>
j_enough_dlr := enough_addition_nocomps &
  [ RNAME leno ].

; <type val="j_enough-wc_dlr">
; <description>Adj w/comps plus enough-compl
; <ex>A happy enough cat arrived.
; <nex>
; <todo>
; </type>
j_enough-wc_dlr := enough_addition_wcomp &
  [ RNAME lenc ].

; <type val="j_tough_dlr">
; <description>Tough-adj alternation
; <ex>B is tough to admire.
; <nex>
; <todo>
; </type>
j_tough_dlr := tough_adj_lr &
  [ RNAME ltgh ].

#|
; <type val="j_r-i_odlr">
; <description>Adjective to adverb, intersective only
; <ex>Kim arrived slowly.
; <nex>
; <todo>
; </type>
j_r-i_odlr := 
%suffix (* ly) (!ty !tily)
adj_to_adv_lr &
  [ ND-AFF +,
    DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < synsem & [ LOCAL int_mod_local ] >,
    SYNSEM.LOCAL.CAT.HEAD.MOD < synsem & [ LOCAL int_mod_local ] >,
    RNAME ljri ].
|#

; <type val="n_bipart_dlr">
; <description>Relax bipartite constraint       
; <ex>The scissors isn't sharp.  
; <nex>
; <todo>
; </type>
n_bipart_dlr := bipart_lr &
  [ RNAME lbpt ].

;; EDUC: exclude
#|
; <type val="w_italics_dlr">
; <description>Italicized word made into NP     
; <ex>Some say /windshield/.     
; <nex>
; <todo>
; </type>
w_italics_dlr := foreign_lr &
  [ RNAME lfw ].
|#

; <type val="v_inv-quot_dlr">
; <description>Main verb inversion for quoting  
; <ex>He left, said Kim.         
; <nex>
; <todo>
; </type>
v_inv-quot_dlr := inverted_quote_lr &
  [ RNAME linq ].

;; Block to avoid spurious ambiguity as in |We allow to sleep|
; <type val="v_cp-frag_dlr">
; <description>Verbs of saying with fragment substituted for CP complement
; <ex>Yes, said Kim.         
; <nex>
; <todo>
; </type>
;v_cp-frag_dlr := cp_frag_lr &
;  [ RNAME lcpf ].

; <type val="n_n-ed_odlr">
; <description>Noun with |-ed| suffix as adj    
; <ex>Long-eared sheep slept.    
; <nex>
; <todo>
; </type>
n_n-ed_odlr := 
%suffix (* ed) (!ty !tied) (e ed) (!t!v!c !t!v!c!ced) 
noun_adj_lr &
  [ ND-AFF +,
    RNAME lnj ].

; <type val="j_n-pre_odlr">
; <description>pre- prefix on nouns
; <ex>The pre-war period endured.
; <nex>
; <todo>
; </type>
j_n-pre_odlr := 
%prefix (* pre) (* pre-) 
pre_noun_adj_lr &
  [ ND-AFF +,
    RNAME ljnp ].

; <type val="v_v-re_dlr">
; <description>Verb with |re-| prefix           
; <ex>He re-tied his shoe.       
; <nex>
; <todo>
; </type>
v_v-re_dlr := 
%prefix (* re) (* re-) 
v_v-re_rule &
 [ ND-AFF +,
   RNAME lre,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_re-_a_again_rel" ] !> ].

; <type val="v_v-pre_dlr">
; <description>Verb with |pre-| prefix          
; <ex>He pre-signed the check.   
; <nex>
; <todo>
; </type>
v_v-pre_dlr := 
%prefix (* pre) (* pre-) 
v_v-pre_rule &
 [ ND-AFF +,
   RNAME lpre,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_pre-_a_ante_rel" ] !> ].

; <type val="v_v-mis_dlr">
; <description>Verb with |mis-| prefix          
; <ex>He mis-tied his shoe.      
; <nex>
; <todo>
; </type>
v_v-mis_dlr := 
%prefix (* mis) (* mis-) 
v_v-mis_rule &
 [ ND-AFF +,
   RNAME lmis,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_mis-_a_error_rel" ] !> ].

;;;
;;; _fix_me_
;;; to make this rule functional, token mapping would have to not separate off
;;; |co-| (in `derivational_prefix_tmr').  however, doing that would then mean
;;; that either (a) we provide a prefixation rule for other parts of speech too
;;; (`co-author', maybe `co-educational') or minimally adjust existing lexical
;;; entries (currently MWEs); or (b) that we create a token-level ambiguity; i
;;; hesitate doing the latter.  but maybe it would not be so bad, in the end?
;;; the same problem applies to other derivational rules, of course.
;;;                                                             (13-mar-09; oe)
; <type val="v_v-co_dlr">
; <description>Verb with |co-| prefix           
; <ex>He co-wrote the paper.     
; <nex>
; <todo>
; </type>
v_v-co_dlr := 
%prefix (* co-) (* co)
v_v-co_rule &
 [ ND-AFF +,
   RNAME lco,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

; <type val="v_v-un_dlr">
; <description>Verb with |un-| prefix           
; <ex>He untied his shoe.
; <nex>
; <todo>
; </type>
v_v-un_dlr := 
%prefix (* un) (* un-) 
v_v-un_rule &
 [ ND-AFF +,
   RNAME lunv,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_un-_a_rvrs_rel" ] !> ].

; <type val="v_v-counter_dlr">
; <description>Verb with |counter-| prefix           
; <ex>He counter-signed the bill.
; <nex>
; <todo>
; </type>
v_v-counter_dlr := 
%prefix (* counter) (* counter-) 
v_v-counter_rule &
 [ ND-AFF +,
   RNAME lctv,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_counter-_a_anti_rel" ] !> ].

; <type val="v_v-over_dlr">
; <description>Verb with |over-| prefix           
; <ex>He over-built the porch.
; <nex>
; <todo>
; </type>
v_v-over_dlr := 
%prefix (* over) (* over-) 
v_v-over_rule &
 [ ND-AFF +,
   RNAME lovtv,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_over-_a_1_rel" ] !> ].

; <type val="v_v-out_dlr">
; <description>Verb with |out-| prefix           
; <ex>He out-played his opponent.
; <nex>
; <todo>
; </type>
v_v-out_dlr := 
%prefix (* out) (* out-) 
v_v-out_rule &
 [ ND-AFF +,
   RNAME lotv,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_out-_a_1_rel" ] !> ].

; <type val="v_v-self_dlr">
; <description>Verb with |self-| prefix           
; <ex>He was self-insured.
; <nex>
; <todo>
; </type>
v_v-self_dlr := 
%prefix (* self) (* self-) 
v_v-self_rule &
 [ ND-AFF +,
   RNAME lsfv,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_self-_a_1_rel" ] !> ].

; <type val="v_v-cross_dlr">
; <description>Verb with |cross-| prefix           
; <ex>He cross-examined the witness.
; <nex>
; <todo>
; </type>
v_v-cross_dlr := 
%prefix (* cross) (* cross-) 
v_v-cross_rule &
 [ ND-AFF +,
   RNAME lcsv,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_cross-_a_1_rel" ] !> ].

; <type val="n_n-co_dlr">
; <description>Noun with |co-| prefix           
; <ex>Our co-teacher arrived.
; <nex>
; <todo>
; </type>
n_n-co_dlr := 
%prefix (* co) (* co-)
n_n-co_rule &
 [ ND-AFF +,
   RNAME lnco,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

; <type val="n_n-co-ni_dlr">
; <description>Noun with |co-| prefix, non-inflecting
; <ex>Our co-derivatives group arrived.
; <nex>
; <todo>
; </type>
n_n-co-ni_dlr := 
%prefix (* co) (* co-)
n_n-co-ni_rule &
 [ ND-AFF +,
   RNAME lncon,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

; <type val="n_n-counter_dlr">
; <description>Noun with |counter-| prefix           
; <ex>The counter-proposal arrived.
; <nex>
; <todo>
; </type>
n_n-counter_dlr := 
%prefix (* counter) (* counter-) 
n_n-counter_rule &
 [ ND-AFF +,
   RNAME lctn,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_counter-_a_anti_rel" ] !> ].

; <type val="n_n-counter-ni_dlr">
; <description>Noun with |counter-| prefix, non-inflecting
; <ex>The counter-narcotics team arrived.
; <nex>
; <todo>
; </type>
n_n-counter-ni_dlr := 
%prefix (* counter) (* counter-) 
n_n-counter-ni_rule &
 [ ND-AFF +,
   RNAME lctnn,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_counter-_a_anti_rel" ] !> ].

; <type val="n_n-mini_dlr">
; <description>Noun with |mini-| prefix           
; <ex>The mini-car arrived.
; <nex>
; <todo>
; </type>
n_n-mini_dlr := 
%prefix (* mini) (* mini-) 
n_n-mini_rule &
 [ ND-AFF +,
   RNAME lctn,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_mini-_a_1_rel" ] !> ].

; <type val="n_n-mini-ni_dlr">
; <description>Noun with |mini-| prefix, non-inflecting
; <ex>The mini-car transporter arrived.
; <nex>
; <todo>
; </type>
n_n-mini-ni_dlr := 
%prefix (* mini) (* mini-) 
n_n-mini-ni_rule &
 [ ND-AFF +,
   RNAME lctnn,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_mini-_a_1_rel" ] !> ].

; <type val="j_j-co_dlr">
; <description>Adjective with |co-| prefix           
; <ex>The co-educational hall opened.
; <nex>
; <todo>
; </type>
j_j-co_dlr := 
%prefix (* co-) (* co) 
j_j-co_rule &
 [ ND-AFF +,
   RNAME ljco,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

; <type val="j_j-un_dlr">
; <description>Adjective with |un-| prefix           
; <ex>The unhappy cat arose.
; <nex>
; <todo>
; </type>
j_j-un_dlr := 
%prefix  (* un-) (* un)
j_j-un_rule &
 [ ND-AFF +,
   RNAME lunj,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_un-_a_neg_rel" ] !> ].

; <type val="j_j-non_dlr">
; <description>Adjective with |non| prefix           
; <ex>The nonlinear solution failed.
; <nex>
; <todo>
; </type>
j_j-non_dlr := 
%prefix  (* non)
j_j-non_rule &
 [ ND-AFF +,
   RNAME lnnj,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED neg_rel ] !> ].

;;; From arboretum/mal-inflr.tdl

;; Disagreement rules, one for each direction.  Pair synsem with
;; "wrong" forms: The dog bark/the dogs barks.
;;
;; Constrain this one to only apply to pronominal subject, to avoid spurious
;; analysis using both this rule and the mal_plur_noun_irule
;; DPF 25-jun-10 - But we also want to catch e.g. "my knees hurts", so let's
;; try blocking --BARE +, to avoid the above spuriosity.
;; Also block clauses headed by such verbs from undergoing cl_np-wh_c rule
;; DPF 2013-05-10 - But [NORM no_rel] prevents conjoined robust forms, as in
;; |people arrives and arises|.  So remove, and monitor.
;;
non_third_sg_fin_v_rbst :=
%suffix (!s !ss) (!ss !ssses) (ss sses) (!ty !ties) (ch ches) (sh shes) (x xes) (z zes)
lex_rule_infl_affixed &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL non_third_sg_fin_verb &
	[ CAT [ HEAD.--MALN3SG +,
		VAL.SUBJ < [ LOCAL.CAT.HEAD [ --BARE -,
					    MINORS.MIN nonpart_nom_rel ] ] > ]],
  RNAME mn3s ].

;; DPF 2010-08-16 - Block subject extraction, to avoid spurious analysis for
;; "What do Kim and Abrams ..."
;; DPF 2017-09-06 -Block time NPs as subjects, to avoid robust analysis for
;; |ten grow in the garden|
;;
third_sg_fin_v_rbst := lex_rule_infl_affixed &
[ GENRE robust,
  ND-AFF -,
  ORTH #stem,
  DTR [ ORTH #stem,
	SYNSEM.LOCAL.CAT [ HEAD.--MAL3SG +,
	                   VAL.SUBJ < expressed_synsem &
				      [ LOCAL.AGR.PNG.PN 3s,
					--SIND.SORT entity,
					PUNCT.RPUNCT no_punct ] > ] ],
  SYNSEM.LOCAL third_sg_fin_verb,
  RNAME m3s ].

;; DPF 10-May-04 - We take plural marking on noun as intended (not to be
;; corrected), so only have one mal infl-rule for nouns to correct 
;; 'two dog bark' to 'two dogs bark'.  We will need a statistical preference 
;; mechanism to choose one of the two possible corrections for 'dog bark':
;; either 'dogs bark' or 'a/the dog barks'.  But have to have both, since
;; 'he bark' should presumably get corrected to 'he barks' (not 'they bark').
;; DPF 07-feb-10 - Changed DTR..MIN norm_nom_rel to reg_nom_rel, so it also
;; applies to measure nouns, as in "they ran twenty six mile."
;; Note that CASE on dtr must be nom to avoid spurious ambiguity for e.g.
;; direct objects where there is no constraint on number.
;; DPF 30-mar-10 - Restrict this to only apply when the determiner is overt, 
;; to avoid spurious ambiguity for e.g. "she told her brother borrow her book"
;; where `brother' formerly got made a plural.  So now we assume that number
;; on nouns is as the writer intended, unless there is a determiner present,
;; which might indicate competing number, as in "most thing are important"
;; the verb to match robustly when needed.
;; DPF 07-apr-10 - But still getting too much spurious ambiguity, as in
;; "His soup is".  So restrict further to just deictic dets for now.
;;
plur_noun_irule_rbst := lex_rule_infl_affixed &
[ GENRE robust,
  ND-AFF -,
  ORTH #stem,
  SYNSEM.LOCAL [ CAT.HEAD.--BARE +,
		 AGR.PNG png-reg ],
  DTR [ ORTH #stem,
	SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN reg_nom_rel,
				  CASE nom ],
			   VAL.SPR < canonical_synsem &
				     [ --MIN demonstrative_q_rel ] > ] ],
  SYNSEM.LOCAL plur_noun,
  RNAME mpln ].


; For |Kim, Abrams(,) and Browne|
w_paren_comma-nf_plr :=
%suffix (!. !.\(,\))
punctuation_comma_rule.

;; For sandwiched comma: |the tall,green tree|
w_comma-sdwch_plr := never_unify_rule.
w_comma-sdwch_plr_rbst :=
%suffix (!q !q⸴)
punctuation_comma_sandwich_rule &
 [ RNAME lpcs,
   GENRE robust ].

v_prp-nf_olr := never_unify_le.

j_vp_bse_dlr_rbst := adj_vp_bse_mal_lr &
  [ RNAME ljvb ].

;; For e.g. |informations|
;;
n_pl-mass_olr_rbst :=
%suffix (!s !ss) (!ss !ssses) (es eses) (ss sses) (!ty !ties) (ch ches) (sh shes) (x xes) (z zes)
lex_rule_plural_mass &
[ ND-AFF +,
  RNAME lplm ].

;; Block robust comma, to avoid spurious analysis of "the cat, arrived."
w_comma-nf_plr :=
%suffix (!. !.,)
punctuation_comma_informal_rule &
 [ SYNSEM.LOCAL.CAT.HEAD no_head,
   RNAME lpcr ].

;; For wrong regular past inflection of irregular verbs (|buyed| for |bought|)
;;
v_pst_olr_rbst :=
%suffix (!( nevermatch)
v_pst_inflrule &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL past_or_subj_verb & [ CAT.HEAD.--MALPAST + ],
  RNAME lvptr ].

v_psp_olr_rbst :=
%suffix (!( nevermatch)
v_psp_inflrule &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL psp_verb,
  RNAME lvppr ].

v_pas_odlr_rbst := 
%suffix (!( nevermatch)
v_pas-norm_lexrule &
  [ GENRE robust,
    ND-AFF +,
    DTR.SYNSEM trans_subst &
               [ LOCAL [ CAT.VAL.COMPS [ FIRST [ LOCAL.CONT #objcont,
                                                 --SIND #objind,
                                                 NONLOC #ononloc ],
                                         REST #comps ] ],
                 LKEYS.KEYREL #keyrel ],
    SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT #objcont,
					  --SIND #objind,
					  NONLOC #ononloc ] >,
				 COMPS.REST #comps ] ],
                     CONT [ HOOK.XARG #objind ] ],
             LKEYS.KEYREL #keyrel ],
  RNAME lvpar ].

v_pas-p_odlr_rbst := 
%suffix (!( nevermatch)
prep_passive_verb_lr &
[ GENRE robust,
  ND-AFF +,
  RNAME lvper ].

v_pas-p-t_odlr_rbst := 
%suffix (!( nevermatch)
prep_passive_trans_verb_lr &
[ GENRE robust,
  ND-AFF +,
  RNAME lvpfr ].

v_pas-prt-t_odlr_rbst := 
%suffix (!( nevermatch)
prep_passive_ptcl_verb_lr &
[ GENRE robust,
  ND-AFF +,
  RNAME lvpgr ].

v_pas-dat_odlr_rbst := 
%suffix (!( nevermatch)
basic_passive_verb_lr &
  [ GENRE robust,
    ND-AFF +,
    DTR [ SYNSEM basic_ditrans_subst &
		 [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind, 
					      NONLOC #snonloc ] >,
				     COMPS < [ LOCAL.CONT #objcont,
					       --SIND #objind,
					       NONLOC #ononloc ],
					     #npcomp > ] ],
		   LKEYS.KEYREL #keyrel ] ],
    SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT #objcont,
					  --SIND #objind,
					  NONLOC #ononloc ] >,
				 COMPS < #npcomp,
                                       synsem & 
                                       [ LOCAL local &
                                         [ CAT [ HEAD prep & 
                                                   [ MINORS.MIN _by_p_cm_rel ],
                                                 VAL [ SUBJ < >,
                                                       SPR *olist*,
                                                       COMPS < > ] ],
                                           CONT.HOOK.INDEX #subjind ],
                                         NONLOC #snonloc,
                                         OPT + ] > ] ],
		     CONT [ HOOK.XARG #objind ] ],
             LKEYS.KEYREL #keyrel ],
  RNAME lvdpr ].

v_pas-cp_odlr_rbst := 
%suffix (!( nevermatch)
v_pas-cp_lexrule &
  [ GENRE robust,
    ND-AFF +,
    DTR.SYNSEM cp_passivable_verb &
               [ LOCAL.CAT.VAL [ COMPS #comps,
                                 KCMP #kcmp ] ],
    SYNSEM passive_atrans_synsem &
           [ LOCAL.CAT [ VAL [ COMPS.REST #comps,
			       KCMP #kcmp ] ] ],
    RNAME lvcpr ].

v_prp_olr_rbst :=
%suffix (!( nevermatch)
v_prp_inflrule &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL prp_verb,
  RNAME lvprr ].

v_3s-fin_olr_rbst :=
%suffix (!( nevermatch)
v_3s-fin_inflrule &
[ GENRE robust,
  ND-AFF +,
  SYNSEM.LOCAL third_sg_fin_verb,
  RNAME lvsgr ].
