;;; -*- Mode: tdl; Coding: utf-8; -*-

;; The three small blue flowers are growing in the flower pot.

;; "flower in the pot" => "flower"
;; "flower pot" => "pot"
mod_phrase_deletion := np_deletion_omtr &
[ FILTER.RELS <! [ LBL #h1, ARG1 #x2 ] !>,
  CONTEXT.RELS <! [ PRED "~._[nv]_", LBL #lbl, ARG0 #i1 & individual ] !>,
  INPUT.RELS <! [ PRED "~._n_", LBL #h1, ARG0 #x2 & ref-ind ],
		[ PRED quant_rel, ARG0 #x2 ],
	        [ LBL #lbl & handle, ARG0 #e2, ARG1 #i1, ARG2 #x2 ] !>,
  OUTPUT.RELS <! !>,
  FLAGS.EQUAL < #x2, #h1 > ].

;; "small flower" => "flower"
;; "three flowers" => "flowers"
;;
;; DPF 2013-10-16 - The [ARG2 event] on the input rel is a trick to block
;; applicability to two-argument modifiers such as compound_rel, taking
;; advantage of there being no predications that take an ARG2 of type event.
;; The alternative would be to restrict by PRED value, somehow including
;; "*_a_*" and card_rel but excluding compound_rel.  Or have two or more
;; rules to enumerate the permissible PRED values.
;; 
mod_word_deletion := monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #lbl,
  	       	    ARG0 #x1 & ref-ind ] !>,
  INPUT.RELS <! [ LBL #lbl,
                  ARG0 #e2 & event & [ E.TENSE untensed ],
                  ARG1 #x1, ARG2 event  ] !>,
  OUTPUT.RELS <! !>,
  FLAGS.EQUAL < #e2, #lbl > ].

;; "the flowers" => "flowers"
determiner_deletion := monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #lbl,
  	       	    ARG0 #x1 & ref-ind ] !>,
  INPUT.RELS <! [ PRED explicit_q_rel,
                  LBL #h2, ARG0 #x1 & [ PNG.PN 3p ], RSTR #h3 & handle,
		  BODY #h4 & handle ] !>,
  OUTPUT.RELS <! [ PRED implicit_q_rel,
		   LBL #h2 & handle, ARG0 #x1, RSTR #h3, BODY #h4 ] !>,
  FLAGS.EQUAL < #lbl, #h2 > ].


;; "the flowers" => "they"
pronoun_subst := monotonic_omtr &
[ INPUT.RELS <! [ PRED "~._n_", LBL #h1, ARG0 #x1 & ref-ind & 
		                                    [ PNG [ PN 3,
							    GEN neut ] ] ],
                [ PRED quant_rel, LBL #h2 & handle, ARG0 #x1,
		  RSTR #h3 & handle, BODY #h4 & handle ] !>,
  OUTPUT.RELS <! [ PRED pron_rel, LBL #h1, ARG0 #x1 & [ PRONTYPE std_pron ] ],
                 [ PRED pronoun_q_rel, LBL #h2, ARG0 #x1, RSTR #h3, 
		   BODY #h4 ] !> ].


;; "are growing" => "are"
verb_ellipsis := monotonic_omtr &
[ INPUT.RELS <! [ PRED "~._v_", LBL #h1, ARG0 #e2, ARG1 #x3 ] !>,
  OUTPUT.RELS <! [ PRED ellipsis_ref_rel, LBL #h1, ARG0 #e2 & [ E.ASPECT.PROGR - ],
		   ARG1 #x3 ] !>,
  FLAGS.EQUAL < #e2, #h1 > ].


#|
;;; Verbs - full lexical congruence

start_commence := verb_mtr &
[ INPUT.RELS <! [ PRED "_start_v_cause_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_commence_v_1_rel" ] !> ].

shower_bathe := verb_mtr &
[ INPUT.RELS <! [ PRED "_shower_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_bathe_v_1_rel" ] !> ].

bathe_wash := verb_mtr &
[ INPUT.RELS <! [ PRED "_bathe_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_wash_v_1_rel" ] !> ].

;;; Verbs - object restriction

make_cook := verb_mtr &
[ CONTEXT.RELS <! [ PRED "_breakfast_n_1_rel",
  	            ARG0 #x1 ] !>,
  INPUT.RELS <! [ PRED "_make_v_1_rel",
                  ARG2 #x1 ] !>,
  OUTPUT.RELS <! [ PRED "_cook_v_1_rel" ] !> ].

|#

