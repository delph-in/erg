;;; -*- Mode: tdl; Coding: utf-8; -*-

;; The three small blue flowers are growing in the flower pot.

;; "spicy food" => "food that is spicy"
;;
mod_word_rel_clause := monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #lbl,
  	       	    ARG0 #x1 & ref-ind ] !>,
  INPUT.RELS <! [ LBL #lbl,
                  ARG0 #e2 & event & [ E.TENSE untensed ],
                  ARG1 #x1, ARG2 event  ] !>,
  OUTPUT.RELS <! +copy+ & [ ARG0.E [ TENSE present, ASPECT [ PRF - ] ] ] !>,
  FLAGS.EQUAL < #e2, #lbl > ].

;; "flower in the pot" => "flower"
;; "flower pot" => "pot"
mod_phrase_deletion := np_deletion_omtr &
[ FILTER.RELS <! [ LBL #h1, ARG1 #x2 ] !>,
  CONTEXT.RELS <! [ PRED "~._[nv]_", LBL #lbl, ARG0 #i1 & individual ] !>,
  INPUT.RELS <! [ PRED "~._n_", LBL #h1, ARG0 #x2 & ref-ind ],
		[ PRED quant_rel, ARG0 #x2 ],
	        [ LBL #lbl & handle, ARG0 #e2 & [ E.TENSE untensed ], 
		  ARG1 #i1, ARG2 #x2 ] !>,
  OUTPUT.RELS <! !>,
  FLAGS.EQUAL < #x2, #h1 > ].

;; "small flower" => "flower"
;; "three flowers" => "flowers"
;;
;; DPF 2013-10-16 - The [ARG2 event] on the input rel is a trick to block
;; applicability to two-argument modifiers such as compound_rel, taking
;; advantage of there being no predications that take an ARG2 of type event.
;; The alternative would be to restrict by PRED value, somehow including
;; "*_a_*" and card_rel but excluding compound_rel.  Or have two or more
;; rules to enumerate the permissible PRED values.
;; 
mod_word_deletion := monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #lbl, ARG0 #i1 & individual ] !>,
  INPUT.RELS <! [ LBL #lbl, ARG0 #e2 & event & [ E.TENSE untensed ],
                  ARG1 #i1, ARG2 event  ] !>,
  OUTPUT.RELS <! !>,
  FLAGS.EQUAL < #e2, #lbl > ].

;; "the flowers" => "flowers"
determiner_deletion := quantifier_substitution_omtr &
[ INPUT.RELS <! [ PRED explicit_q_rel ] !>,
  OUTPUT.RELS <! [ PRED implicit_q_rel ] !> ].

;; "both flowers" => "the flowers"
both_the_subst := quantifier_substitution_omtr &
[ INPUT.RELS <! [ PRED _both_q_rel ] !>,
  OUTPUT.RELS <! [ PRED _the_q_rel ] !> ].

;; "both flowers" => "both (of) the flowers"


;; "the flowers" => "they"
pronoun_subst := monotonic_omtr &
[ FILTER.RELS <! [ LBL #h1, ARG1 #x2 ] !>,
  INPUT.RELS <! [ PRED "~._n_", LBL #h1, 
		  ARG0 #x1 & ref-ind & [ PNG [ PN 3, GEN neut ] ] ],
                [ PRED quant_rel, LBL #h2 & handle, ARG0 #x1,
		  RSTR #h3 & handle, BODY #h4 & handle ] !>,
  OUTPUT.RELS <! [ PRED pron_rel, LBL #h1, ARG0 #x1 & [ PT std ] ],
                 [ PRED pronoun_q_rel, LBL #h2, ARG0 #x1, RSTR #h3, 
		   BODY #h4 ] !> ].


;; "are growing" => "are"
verb_ellipsis := monotonic_omtr &
[ INPUT.RELS <! [ PRED "~._v_", LBL #h1, ARG0 #e2, ARG1 #x3 ] !>,
  OUTPUT.RELS <! [ PRED ellipsis_ref_rel, LBL #h1, 
		   ARG0 #e2 & [ E.ASPECT.PROGR - ], ARG1 #x3 ] !>,
  FLAGS.EQUAL < #e2, #h1 > ].

prog_nonprog := monotonic_omtr &
[ INPUT.RELS <! [ PRED "~._v_", ARG0 #e2 & [ E.ASPECT.PROGR + ] ] !>,
  OUTPUT.RELS <! +copy+ & [ ARG0.E.ASPECT.PROGR - ] !>,
  FLAGS.EQUAL < #e2 > ].

like_enjoy := verb_mtr &
[ INPUT.RELS <! [ PRED "_like_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_enjoy_v_1_rel" ] !> ].

like_love := verb_mtr &
[ INPUT.RELS <! [ PRED "_like_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_love_v_1_rel" ] !> ].


#|
;;; Verbs - full lexical congruence

start_commence := verb_mtr &
[ INPUT.RELS <! [ PRED "_start_v_cause_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_commence_v_1_rel" ] !> ].

shower_bathe := verb_mtr &
[ INPUT.RELS <! [ PRED "_shower_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_bathe_v_1_rel" ] !> ].

bathe_wash := verb_mtr &
[ INPUT.RELS <! [ PRED "_bathe_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_wash_v_1_rel" ] !> ].

;;; Verbs - object restriction

make_cook := verb_mtr &
[ CONTEXT.RELS <! [ PRED "_breakfast_n_1_rel",
  	            ARG0 #x1 ] !>,
  INPUT.RELS <! [ PRED "_make_v_1_rel",
                  ARG2 #x1 ] !>,
  OUTPUT.RELS <! [ PRED "_cook_v_1_rel" ] !> ].

|#

