;;; -*- Mode: tdl; Coding: utf-8; -*-

;;; Verbs: near-equivalence
;;
like_enjoy := word_mtr &
[ INPUT.RELS <! [ PRED "_like_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_enjoy_v_1_rel" ] !> ].

like_love := word_mtr &
[ INPUT.RELS <! [ PRED "_like_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_love_v_1_rel" ] !> ].

agentless_passive := agentless_passive_omtr.
dative_deletion := dative_obj_deletion_omtr.

drop_cause := causative-inchoative_omtr &
[ INPUT.RELS.LIST < [ PRED "_drop_v_cause_rel" ], ... >,
  OUTPUT.RELS <! [ PRED "_drop_v_1_rel" ] !> ].

break_cause := causative-inchoative_omtr &
[ INPUT.RELS.LIST < [ PRED "_break_v_cause_rel" ], ... >,
  OUTPUT.RELS <! [ PRED "_break_v_1_rel" ] !> ].

drop_fall := word_mtr &
[ INPUT.RELS <! [ PRED "_drop_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_fall_v_1_rel" ] !> ].

travel_go := word_mtr &
[ INPUT.RELS <! [ PRED "_travel_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_go_v_1_rel" ] !> ].

drive_go := word_mtr &
[ INPUT.RELS <! [ PRED "_drive_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_go_v_1_rel" ] !> ].

eat_have := word_mtr &
[ INPUT.RELS <! [ PRED "_eat_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_have_v_1_rel" ] !> ].

buy_get := word_mtr &
[ INPUT.RELS <! [ PRED "_buy_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_get_v_1_rel" ] !> ].

house_home := word_mtr &
[ INPUT.RELS <! [ PRED "_house_n_of_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_home_n_of-n_rel" ] !> ].

pizza_food := word_mtr &
[ INPUT.RELS <! [ PRED "_pizza_n_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_food_n_1_rel", ARG0.SORT nonhuman ] !> ].

;;; Verbs - object restriction
;;
make_cook_br := word_mtr &
[ CONTEXT.RELS <! [ PRED "_breakfast_n_1_rel", ARG0 #x1 ] !>,
  INPUT.RELS <! [ PRED "_make_v_1_rel", ARG2 #x1 ] !>,
  OUTPUT.RELS <! [ PRED "_cook_v_1_rel" ] !> ].

make_cook_dn := word_mtr &
[ CONTEXT.RELS <! [ PRED "_dinner_n_1_rel", ARG0 #x1 ] !>,
  INPUT.RELS <! [ PRED "_make_v_1_rel", ARG2 #x1 ] !>,
  OUTPUT.RELS <! [ PRED "_cook_v_1_rel" ] !> ].

make_cook_steak := word_mtr &
[ CONTEXT.RELS <! [ PRED "_steak_n_1_rel", ARG0 #x1 ] !>,
  INPUT.RELS <! [ PRED "_make_v_1_rel", ARG2 #x1 ] !>,
  OUTPUT.RELS <! [ PRED "_cook_v_1_rel" ] !> ].

make_build_fort := word_mtr &
[ CONTEXT.RELS <! [ PRED "_fort_n_1_rel", ARG0 #x1 ] !>,
  INPUT.RELS <! [ PRED "_make_v_1_rel", ARG2 #x1 ] !>,
  OUTPUT.RELS <! [ PRED "_build_v_1_rel" ] !> ].

steak_meat := word_mtr &
[ INPUT.RELS <! [ PRED "_steak_n_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_meat_n_1_rel" ] !> ].


;; "spicy food" => "food that is spicy"
;;
mod_word_rel_clause := norm_monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #lbl,
		    ARG0 #x1 & ref-ind ] !>,
  INPUT.RELS <! [ LBL #lbl,
		  PRED "~._a_",
                  ARG0 #e2 & event & [ E.TENSE untensed ],
                  ARG1 #x1, ARG2 event  ] !>,
  OUTPUT.RELS <! +copy+ & [ ARG0.E [ TENSE present, ASPECT [ PRF - ] ] ] !>,
  FLAGS.EQUAL < #e2, #lbl > ].

;; "small flower" => "flower"
;; "three flowers" => "flowers"
;;
;; DPF 2013-10-16 - The [ARG2 event] on the input rel is a trick to block
;; applicability to two-argument modifiers such as compound_rel, taking
;; advantage of there being no predications that take an ARG2 of type event.
;; The alternative would be to restrict by PRED value, somehow including
;; "*_a_*" and card_rel but excluding compound_rel.  Or have two or more
;; rules to enumerate the permissible PRED values.
;; 
mod_word_deletion := norm_monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #lbl, ARG0 #i1 & individual ] !>,
  INPUT.RELS <! [ LBL #lbl, ARG0 #e2 & event & [ E.TENSE untensed ],
                  ARG1 #i1, ARG2 event  ] !>,
  OUTPUT.RELS <! !>,
  FLAGS.EQUAL < #e2, #lbl > ].


;; "flower in the pot" => "flower"
;; "flower pot" => "pot"
mod_phrase_deletion := np_deletion_omtr &
[ FILTER.RELS <! [ LBL #h1, ARG1 #x2 ] !>,
  CONTEXT.RELS <! [ LBL #lbl, ARG0 #i1 & individual ] !>,
  INPUT [ HOOK.INDEX #ind,
	  RELS <! [ LBL #h1, ARG0 #x2 & ref-ind ],
		[ PRED quant_rel, ARG0 #x2 ],
	        [ LBL #lbl & handle, ARG0 #e2 & [ E.TENSE untensed ], 
		  ARG1 #i1, ARG2 #x2 ] !> ],
  OUTPUT [ HOOK.INDEX #ind,
	   RELS <! !> ],
  FLAGS.SUBSUME < #x2, #h1 > ].

;; "Wednesday night" => "Wednesday"
morning_deletion := day_part_deletion_omtr &
 [ INPUT.RELS.LIST.FIRST.PRED "_morning_n_of_rel" ].

afternoon_deletion := day_part_deletion_omtr &
 [ INPUT.RELS.LIST.FIRST.PRED "_afternoon_n_of_rel" ].

evening_deletion := day_part_deletion_omtr &
 [ INPUT.RELS.LIST.FIRST.PRED "_evening_n_of_rel" ].

night_deletion := day_part_deletion_omtr &
 [ INPUT.RELS.LIST.FIRST.PRED "_night_n_of_rel" ].

appos_deletion := np_deletion_omtr &
[ FILTER.RELS <! [ LBL #h1, ARG1 #x2 ] !>,
  INPUT [ HOOK.INDEX #ind,
	  RELS <! [ PRED "~._n_", LBL #h1, ARG0 #x2 & ref-ind ],
		[ PRED quant_rel, ARG0 #x2 ],
	        [ PRED appos_rel, ARG2 #x2 ] !>],
  OUTPUT [ HOOK.INDEX #ind,
	   RELS <! !> ],
  FLAGS.SUBSUME < #x2, #h1 > ].

;; "his flowers" => "the flowers"
poss_deletion := possessive_deletion_omtr &
[ INPUT [ HOOK.INDEX #ind,
	  RELS.LIST.FIRST.PRED def_explicit_q_rel ],
  OUTPUT [ HOOK.INDEX #ind,
	   RELS <! [ PRED _the_q_rel ] !> ] ].

;; "the flowers" => "flowers"
determiner_deletion_pl := quantifier_substitution_omtr &
[ INPUT [ HOOK.INDEX #ind,
	  RELS <! [ PRED explicit_q_rel, ARG0.PNG.PN 3p ] !> ],
  OUTPUT [ HOOK.INDEX #ind,
	   RELS <! [ PRED implicit_q_rel ] !> ] ].

determiner_deletion_ms := quantifier_substitution_omtr &
[ INPUT [ HOOK.INDEX #ind,
	  RELS <! [ PRED explicit_q_rel, ARG0 [ PNG.PN 3s, IND - ] ] !> ],
  OUTPUT [ HOOK.INDEX #ind,
	   RELS <! [ PRED implicit_q_rel, ARG0.IND bool ] !> ] ].

;; "both flowers" => "the flowers"
;; ? "both flowers" => "both (of) the flowers"
;;
both_the_subst := quantifier_substitution_omtr &
[ INPUT [ HOOK.INDEX #ind,
	  RELS <! [ PRED _both_q_rel ] !> ],
  OUTPUT [ HOOK.INDEX #ind,
	   RELS <! [ PRED _the_q_rel ] !> ] ].

;; "in the summer" => "in summer"
the_season_subst := quantifier_substitution_omtr &
[ CONTEXT.RELS <! [ PRED season_rel ] !>,
  INPUT [ HOOK.INDEX #ind,
	  RELS <! [ PRED _the_q_rel ] !> ],
  OUTPUT [ HOOK.INDEX #ind,
	   RELS <! [ PRED udef_q_rel, ARG0.IND - ] !> ] ].

;; "the flowers" => "they", "the book" => "it"
;; DPF 2015-04-03 - Divided into two rules, one for singular that preserves
;; GEN, and one for plural that drops gender, so we can still generate with
;; |they, them, their| with GEN unspecified.
;;
pronoun_sg_subst := pronoun_substitution_omtr &
[ INPUT.RELS.LIST < [ PRED "~._n_", ARG0.PNG.PN sg ], ... >,
  OUTPUT.RELS.LIST < [ ARG0.IND bool ], ... > ].

;; Drop gender for plurals
pronoun_pl_subst := pronoun_substitution_omtr &
[ INPUT.RELS.LIST < [ PRED "~._n_", ARG0.PNG.PN pl ], ... >,
  OUTPUT.RELS.LIST < [ ARG0 [ PNG.GEN real_gender, IND bool ] ], ... > ].

;; family: they
pronoun_grp_subst := pronoun_substitution_omtr &
[ INPUT.RELS.LIST < [ PRED "_family_n_of_rel", ARG0.PNG.PN sg ], ... >,
  OUTPUT.RELS.LIST < [ ARG0 [ PNG [ PN 3p, GEN real_gender ], IND bool ] ], ... > ].

pronoun_name_subst := norm_monotonic_omtr &
[ FILTER.RELS <! [ PRED compound_rel, LBL #h1 ] !>,
  INPUT.RELS <! [ PRED named_rel, LBL #h1, 
		  ARG0 #x1 & ref-ind & [ PNG.PN 3, PT std ] ],
                [ PRED quant_rel, LBL #h2 & handle, ARG0 #x1,
		  RSTR #h3 & handle, BODY #h4 & handle ] !>,
  OUTPUT.RELS <! [ PRED pron_rel, LBL #h1, ARG0 #x1 & [ PT std ] ],
                 [ PRED pronoun_q_rel, LBL #h2, ARG0 #x1, RSTR #h3, 
		   BODY #h4 ] !>,
  FLAGS.EQUAL < #h1 > ].

;; "are growing" => "are"
verb_ellipsis := norm_monotonic_omtr &
[ INPUT.RELS <! [ PRED "~._v_", LBL #h1, ARG0 #e2, ARG1 #x3 ] !>,
  OUTPUT.RELS <! [ PRED ellipsis_ref_rel, LBL #h1, 
		   ARG0 #e2 & [ E.ASPECT.PROGR - ], ARG1 #x3 ] !>,
  FLAGS.EQUAL < #e2, #h1 > ].

;; "in the garden" => "there"
locative_anaphora := norm_monotonic_omtr &
[ INPUT.RELS <! [ PRED nontemp_prep_rel, LBL #h1, ARG0 #e2, 
                  ARG1 #i3, ARG2 #x4 ],
                [ PRED "~._n_", LBL #h7, ARG0 #x4 ],
		[ PRED def_or_proper_q_rel, ARG0 #x4, RSTR #h5, BODY #h6 ] !>,
  OUTPUT.RELS <! [ PRED loc_nonsp_rel, LBL #h1, ARG0 #e2, ARG1 #i3, ARG2 #x8 ],
                [ PRED place_n_rel, LBL #h7, ARG0 #x8  ],
		[ PRED def_implicit_q_rel, ARG0 #x8, RSTR #h5, BODY #h6 ],
		[ PRED _there_a_1_rel, LBL #h7, 
		  ARG0 event & 
		       [ E [ TENSE untensed, ASPECT [ PROGR -, PRF - ] ] ],
		  ARG1 #x8 ] !> ].

prog_nonprog := norm_monotonic_omtr &
[ INPUT.RELS <! [ PRED "~._v_", ARG0 #e2 & [ E.ASPECT.PROGR + ] ] !>,
  OUTPUT.RELS <! +copy+ & [ ARG0.E.ASPECT.PROGR - ] !>,
  FLAGS.EQUAL < #e2 > ].

#|
;;; Verbs - full lexical congruence

start_commence := word_mtr &
[ INPUT.RELS <! [ PRED "_start_v_cause_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_commence_v_1_rel" ] !> ].

shower_bathe := word_mtr &
[ INPUT.RELS <! [ PRED "_shower_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_bathe_v_1_rel" ] !> ].

bathe_wash := word_mtr &
[ INPUT.RELS <! [ PRED "_bathe_v_1_rel" ] !>,
  OUTPUT.RELS <! [ PRED "_wash_v_1_rel" ] !> ].

|#

