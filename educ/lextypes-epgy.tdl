; Block proper names from taking determiners

_the_q_prop_rel := _the_q_rel & proper_q_rel.
mal_bare_div_q_rel := implicit_q_rel.

;; DPF 2018-03-06 - The +CASE requirement prevents even parsing proper names 
;; that are lower case: too brittle, so undo.
#|
norm_n_proper_lexent := reg_n_proper_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED named_rel,
    	     LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.ALTMIN 
	                                    _the_q_prop_rel ] > ],
    INFLECTD -,
    TOKENS.+LAST.+CLASS.+CASE capitalized ].
|#
norm_n_proper_lexent := reg_n_proper_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED named_rel,
    	     LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.ALTMIN 
	                                    _the_q_prop_rel ] > ],
    INFLECTD - ].

n_-_c-fem_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN fem ].

n_-_c-msc_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN masc ].

;; child, puppy
n_-_c-ugen_le := n_intr_lex_entry.

;; night
n_-_c-dpt-df-sg_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

n_pp_c-of_lexent := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

n_pp_c-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

n_pp_c-ns-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

; teacher
n_pp_c-of-anim_le := n_pp_c-of_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN animate ].

;; sister
n_pp_c-of-fem_le := n_pp_c-of_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN fem ].

;; brother
n_pp_c-of-msc_le := n_pp_c-of_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN masc ].

;; Assign default neut gender to avoid spurious paraphrases
;; DPF 2017-09-05 - But this prevents relative clauses with "who" for lots of
;; nouns, so comment out, and let's find a better way to avoid generating
;; unwanted paraphrases wrt gender.
;;
#|
n_-_c_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_-_c-ed_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_-_mc-ed_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_pp_mc-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_-_mc_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].
|#

; Also hour names
;; DPF 2016-06-25 - Motive for this redef not clear.
;;
n_-_pn-hour_le := abstr_hour_word &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < unexpressed >,
                             COMPS < #kcmp >,
			     KCMP #kcmp ],
             LEX - ] ].

n_-_m-def_le_mal :=  n_-_m-def_lexent &
  [ GENRE robust ].

;; Enable paraphrase of |in the summer| as |in summer|, where latter undergoes
;; the mass infl rule which stamps [GEN neut] on.
;;
n_-_m-ssn-spr_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

; Considered blocking days of week from appearing as NP-adv
; but conflict between Strand3.C and sentencelist.C:
; "*Jenny plays chess Tuesday." but "She goes Saturdays."
;
;n_-_c-day_lexent := basic_n_intr_temp_lexent &
;  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN dofw_rel,
;                                       ALTMIN quant_or_wh_rel ],
;                         VAL.SPR < synsem > ],
;             MODIFD notmod,
;             LKEYS.ALTKEYREL.PRED quant_or_wh_rel ] ].

; Special class for "Mr." etc, since we exclude normal nouns as titles
n_-_c-pre-ttl_le := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD [ MINORS [ MIN pre_title_rel,
                              	         NORM norm_rel ],
                                --BARE - ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

;; For wrong prep, as in |the reason of the mistake|
;;
n_pp_c_le_rbst := n_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
		   CONT [ RELS <! relation !>,
			  HCONS <! !> ] ],
    GENRE robust ].

n_pp_m_le_rbst := noun_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
           [ LOCAL [ CAT [ HEAD.--MALCM -,
			   VAL.COMPS < [ OPT - ] > ],
	   	     CONT [ RELS <! relation !>,
			    HCONS <! !> ] ],
             MODIFD notmod ],
    GENRE robust ].

;; Block robust regular plural rule for nouns like |people|
;; 
n_pp_c-pl_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT.RELS <! reg_diadic_nom_relation !>,
		   AGR.PNG png-irreg ] ].

;; Allow nouns to decline the robust a/an + mass-noun rule
noun :+ [ --MALCM bool ].

d_-_sg-nmd-mal_le := basic_det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_unk ] >,
    GENRE robust ].

; "an information", "a homework"
;; DPF 2018-03-16 - Tried removing SPEC..--BARE + since this blocked robust 
;; analysis of |she gave him an advice|.  But we have to prevent ordinery
;; n_-_mc_le nouns from combining with this det.
;;
d_-_m-c_mal_lexent := det_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
			 VAL.SPEC < [ LOCAL [ CAT.HEAD [ --BARE +,
							 --MALCM + ],
					      AGR [ PNG.PN 3s,
						    DIV + ] ] ] > ],
	     NONLOC.QUE 0-dlist ],
    GENRE robust ].

d_-_m-c-mal-a_le := d_-_m-c_mal_lexent &
 [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con ] > ].

d_-_m-c-mal-an_le := d_-_m-c_mal_lexent &
 [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc ] > ].

;; DPF 2017-09-24 - Redefine to remove identity of XARG and pron's ARG0,
;; because this conflicts with the use of XARG on the dtr in the np_adv rule
;; to impose matching tense constraints for e.g. |arose last year|.
;;
det_poss_lexent := basic_det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			        [ PRED pron_rel,
			  	  ARG0 [ PT std ] ] !> ].


adj_equi_bse_mal_synsem := basic_adj_equi_synsem & 
  [ LOCAL [ CAT [ HEAD adj,
		  VAL [ SPR.FIRST synsem &
				  [ --MIN more_or_very_deg_rel,
				    LOCAL.CAT.HS-LEX #hslex ],
			COMPS < [ LOCAL [ CAT.HEAD.VFORM bse,
					  CONT [ HOOK.LTOP #vhand ] ] ] > ],
		  HS-LEX #hslex ],
	    CONT [ RELS <! adj_relation !>,
		   HCONS <! qeq & [ HARG #hand,
				    LARG #vhand ] !> ] ],
    MODIFD notmod,
    LKEYS.KEYREL.ARG2 handle & #hand ].

adj_vp_bse_mal_lr := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM reg_adj_equi_synsem &
	         [ LOCAL [ CAT [ HEAD #head,
				 VAL [ SUBJ #subj,
				       SPR #spr,
				       SPCMPS #spcmps ] ],
                           CTXT #ctxt ],
		   NONLOC #non-local,
		   MODIFD #modif ] ],
    SYNSEM adj_equi_bse_mal_synsem &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL [ SUBJ #subj,
				SPR #spr,
				SPCMPS #spcmps ] ],
		    CTXT #ctxt ],
	    NONLOC #non-local,
	    MODIFD #modif ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    GENRE robust ].

;; Block noun-noun compounds such as |movie five times|
;; DPF 2017-12-22 - But we want |the other five times|, and the adj-adjn rule
;; needs the head to be LPERIPH na, so allow |movie five times| for now.
;;
;adj_bare_unspecified_card_lexent := basic_adj_bare_unspecified_card_lexent &
;  [ SYNSEM.MODIFD.LPERIPH bool ].

; Remove COMPS..--BARE - since we want to flag "She is good student"
;; DPF 2015-04-22 - Add unif of PNG.PN for subj and comp, to block spurious
;; analysis of |they are late school|.  We'll also have to make adjustment to
;; group nouns like "team" so their INDEX.PNG.PN can be either sg or pl, even
;; though AGR..PN is 3s.
;; DPF 2016-07-15 - Re 2015-04-22: But this also blocks |these trips are a
;; good excuse to avoid work|.  So let's try matching AGR..IND instead, and 
;; adjust lexical entries for `idea, excuse, suggestion' etc so their INDEX..IND
;; is distinct from AGR..IND.
;; DPF 2016-12-02 - Re 2016-07-15: But this blocks |my favorite subject is math|
;; so let's give up on fiddling with PN or IND identity, and instead notice that
;; the problem is with modification of |school| here, since we also want to
;; block |*Kim attends good school|.  
;; DPF 2017-05-17 - Block extraction to avoid spurious analysis for e.g.
;; |I spotted a lizard it was awesome|
;; DPF 2017-08-17 - Re 2017-05-17: But this blocks use of identity copula in
;; relative clauses, as in |the student who is the president|.  So instead
;; constrain the complement's SLASH.
;; DPF 2018-03-06 - Re 2017-08-17: But we want extraction for |we revealed it
;; for what it was|.  So let's instead settle for signaling that depictive
;; |... awesome| as robust.
;;
be_id := be_verb &
  [ SYNSEM aux_np_verb &
     [ LOCAL [ CONT [ HOOK.INDEX #event,
		      RELS.LIST.FIRST.ARG0 #event ],
	       CAT [ VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
			   COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
			                               XARG non_event ]] > ]]],
       LKEYS.KEYREL [ LBL #ltop,
		      PRED _be_v_id_rel ] ] ].

; From auxverbs - Restrict number on COMPS for singular identity copula.
; Also prevent bare-sg NP subjects
;; DPF 13-03-14 - But blocking bare subjs prevents robust analysis of e.g.
;; |cat is a furry animal|  So remove, and let's see what happens.
be_id_pos := be_id &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.TAM.ASPECT.PROGR - ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

;; Match TAM on complement and head, to enable matching of tenses in clauses
;;
cm_np-vp_that_le :+
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM #tam,
		       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.TAM #tam ] ].

;; Undo this 3s constraint since we want e.g. |the population is 4 million|
#|
v_np_is_le := be_is_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3s ] > ].
|#

;; Remove GENRE nonformal so we can generate contracted forms even with
;; root_strict.  Also constrain COMPS.FIRST to canonical_synsem so we avoid
;; generating stranded contractions like |Here he's|, even though this also
;; means we won't generate |Where's Kim?|.
;;
contracted_aux_word := word &
  [ INFLECTD na,
    ALTS [ VPELLIP -,
           SQPNCT -,
	   CSAI - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST canonical_synsem ].

; Add COMPS..--BARE - here to avoid spurious analysis for e.g.
; |the team's goalie kept running|
v_np_is-cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.--BARE -,
					   AGR.PNG.PN sg ] ] > ].

v_np_are_le := be_are_lex_entry & be_id_pos.

v_np_are-cx_le := be_are_lex_entry & be_id_pos & contracted_aux_word.

;; DPF 2018-02-15 - Can't simply require sg NP complement, since we also want
;; |when I was ten|.
#|
v_np_was_le := be_was_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN sg ] > ].
|#
v_np_was_le := be_was_lex_entry & be_id_pos.

v_np_wre_le := be_were_lex_entry & be_id_pos.

;; Avoid misanalysis in possessive NPs such as |in the cat 's mouth|
;;
basic_loc_inv_be_word := loc_inv_verb_word &
  [ INFLECTD +,
    SYNSEM loc_inv_be_synsem &
	     [ LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CAT.HEAD.--BARE - ] ] ].

;; Block APs as subjects
;;
loc_inv_be_word := basic_loc_inv_be_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD -,
				  TAM.MOOD indicative ],
			   VAL [ SUBJ < [ LOCAL [ CAT.HEAD v_or_p,
			                        CONT.HOOK [ LTOP #ltop,
                                                          INDEX #ind &
                                                             [ E.TENSE tense ],
                                                          XARG #xarg ] ] ] >,
				 COMPS < [ --SIND #xarg ] > ],
			   POSTHD - ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #ind & [ SF prop-or-ques ],
				   XARG #xarg ],
			    RELS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

; From syntax.tdl

;; Restrict nonhead to MIN pre_title_rel.
;;
np_title_cmpnd_phr := basic_np_title_cmpnd_phr &
  [ HD-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR < [ OPT - ] >,
			  CONT.HOOK [ LTOP #lbl,
			              INDEX.PNG.GEN #gen ] ],
    NH-DTR.SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN pre_title_rel,
    			  CONT.HOOK.INDEX.PNG.GEN #gen ],
    C-CONT.RELS.LIST.FIRST.LBL #lbl ].


; Exclude reflesives as non-heads: |*They themselves|
;; DPF 2014-01-21 - But now we want to allow these, in Grade 7.
#|
basic_appos_np_phr := norm_appos_phr &
  [ HD-DTR.SYNSEM.MODIFD.RPERIPH bool,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN nonpro_rel,
			      VAL.SPR *olist* ],
    C-CONT [ RELS <! relation !>,
             HCONS <! !> ] ].
|#


;; Block "a Sunday" but allow "next Tuesday"
;; Note that this blocks items in StrandG_2-4 such as
;; "The fair is on a Saturday."
;; So maybe reconsider?
;; Yes, undo, since we also want "on the last Tuesday in May"
;;
;;n_-_c-dow_le := n_-_c-day_lexent &
;;  [ SYNSEM [ LKEYS.KEYREL.PRED dofw_rel,
;;             LOCAL.CAT.VAL.SPR < [ --MIN impl_or_proper_q_rel ] > ] ].

;; DPF 2017-09-27 - Add boolean UNSP-TENSE for modals such as |should| which
;; are unmarked for tense, but don't want to combine with robust subord or
;; clause-taking verbs to trigger tense mismatch in clauses.
;; DPF 2017-09-28 - Also added IRR-TENSE so we can trigger robust |we had went|
;; but not for |we had arrived|.
;; DPF 2017-12-20 - Added SAME-PAST for verbs such as "cut, hit", so we can
;; avoid triggering mismatched tense with modifiers such as "yesterday".
;;
tam :+
 [ UNSP-TENSE bool,
   IRR-TENSE bool,
   SAME-PAST bool ].

;; DPF 2017-09-27 - Mark these as unmarked for tense, so the robust past tense
;; verbs taking nonpast-tense-CPs don't spuriously combine with these, as in
;; |we felt he would arrive|
v_vp_mdl-p-unsp_le := modal_pos_lex_ent &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD.TAM.UNSP-TENSE +,
    ALTS.CSAI - ].

v_vp_mdl-p-cx_le := modal_pos_indic_lexent & contracted_aux_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.UNSP-TENSE + ].

v_vp_mdl-p-sv_le := modal_pos_lex_ent &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD.TAM.UNSP-TENSE + ].

v_vp_mdl-n-sv_le := modal_verb_word & generic_modal_neg & 
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.UNSP-TENSE +,
		       VAL.COMPS.FIRST canonical_or_unexpressed ] ].

v_vp_mdl-n-untns_le := va_modal_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.UNSP-TENSE +,
		       VAL.COMPS.FIRST canonical_or_unexpressed ] ].

; Add feature for blocking mal-3sg and mal-n3sg, and also mal-past
;
vc_add :+ [ --MAL3SG bool,
            --MALN3SG bool,
	    --MALPAST bool ].

; Change CASE from obliq to non_obliq to block "to home"
n_-_ad-pl-nomod_le := norm_np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
				CASE non_obliq,
				--BARE - ],
		     CONT.HOOK.INDEX [ SORT place,
				       PNG.GEN neut ] ],
	     MODIFD.RPERIPH + ] ].

; Related: relax constraint on complement of `from' to still get `from now on'
p_np-ptcl_i_le := p_ditrans_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT nomp_cat_nonnom_min,
                                             CONT.HOOK.INDEX index ] ],
                                   [ LOCAL [ CAT.VAL.COMPS < synsem >,
                                             CONT.HOOK.LTOP #ltop ],
                                     NONLOC non-local_none,
                                     LEX + ] >,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! relation !>,
                          HCONS <! !> ] ] ].



; Restrict normal transitives missing object to --MAL3SG + to prevent
; these from appearing in conjoined verb phrases, avoiding spurious ambiguity
; for e.g. "Kim buys and sells books"
; DPF 19-feb-10 - Also constrain to SLASH 0-dlist, to avoid mis-analysis for
; e.g. `Mark brought the [cookies he made for] his class.'
; DPF 19-apr-10 - --COMPKEY is hack to prevent attrib-adj LR, as in 
; "Mariah is making pasta"
v_-_le_rbst := main_verb & 
  [ SYNSEM unerg_verb &
           [ LOCAL.CAT.HEAD [ --MAL3SG + ],
	     NONLOC.SLASH 0-dlist,
	     LKEYS.--COMPKEY selected_rel ],
    ALTS.NGER -,
    GENRE robust ].

; e.g. 'tell'
; Exclude robust 3sg in CP complement, to avoid competing treatment for e.g.
; `she told her brother borrow her book'.
v_cp_le_rbst := main_verb & 
  [ SYNSEM cp_intrans_verb &
           [ LOCAL.CAT [ VAL.COMPS < [ LOCAL.CAT.HEAD.--MAL3SG -,
				       NONLOC.SLASH 0-dlist ] > ] ],
    GENRE robust ].

; e.g. `know': |*we know where is the restaurant|
v_cp_fin-inf-q-mc_le_rbst := main_verb & 
  [ SYNSEM cp_ques_fin_inf_mc_verb,
    GENRE robust ].

; e.g. 'tell him borrow her book'
v_np-vp_bse_le_rbst := main_verb_mliszt & 
  [ SYNSEM obj_equi_bse_verb,
    GENRE robust ].

; e.g. `This lets the cat to enter'
v_np-vp_oeq_le_rbst := main_verb & 
  [ SYNSEM obj_equi_verb,
    GENRE robust ].

; 'She enables to win.'
; Missing direct object
;
v_vp_seq_le_rbst := main_verb & 
  [ SYNSEM subj_equi_verb,
    GENRE robust ].

; (ERB 2003-10-23) For subject equi verbs, with the infinitival
; marker "to" dropped

; 'She wants win.'
v_vp_seq-bse_le_rbst := main_verb_mliszt & 
  [ SYNSEM subj_equi_bse_verb,
    GENRE robust ].

ssr_bse_verb := verb_synsem & ssr_subst & bse_intrans_subst &
  [ LOCAL [ CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		      KCMP.LOCAL.CONT.HOOK [ LTOP #chand ] ],
	    CONT [ HOOK [ LTOP #ltop ],
		   RELS <! #keyrel !>,
		   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg1_relation & #keyrel & [ ARG1 handle & #arghand ] ].

ssr_bse_noimp_verb := ssr_bse_verb & 
  [ LOCAL.CAT.HEAD.VFORM fin_or_non_fin ].

;; Missing |to| for raising: |they tend win.|
v_vp_ssr-nimp_le_rbst := main_verb & 
  [ SYNSEM ssr_bse_noimp_verb,
    GENRE robust ].

;; |she enjoys to swim|
v_vp_seq-prp_le_rbst := main_verb & 
  [ SYNSEM subj_equi_verb,
    GENRE robust ].

;; |she is done to sing|
aj_vp_i-seq-prp_le_rbst := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel,
    GENRE robust ].

;; DPF 2018-03-07 - Need to block robust bare singular for second complement,
;; as in |Mario saves the baby mouse.|   But we want |we gave him an advice|
;; so instead of --BARE, use --BARED -.
;;
ditrans_verb :+
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL.CAT.HEAD.--BARED - ] > ].

ditrans_only_verb :+
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL.CAT.HEAD.--BARED - ] > ].


; 'ask' - block dative shift
v_np-np*_nodat_le := main_verb & 
  [ SYNSEM ditrans_only_verb & 
	   [ LOCAL.CAT [ VAL.COMPS < [ OPT - ], [ OPT + ] > ] ] ].

; `like' - block bare-sg objects:
; |I didn't like tadpole hunting|
;;
v_np-prd_oeq-ntr-x_le := main_verb_mliszt & 
  [ SYNSEM obj_equi_non_trans_prd_verb &
	   [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.--BARE -,
	     LKEYS [ --OCOMPKEY #ocmin,
		     --+OCOMPKEY #ocmin ] ] ].

; Restrict dtrs to --MAL3SG - to avoid robust intranstives as conjuncts.
;; DPF 13-03-14 - But this blocks flagging of subj-verb agrmt errors as in 
;; |he arise and arrives|.  So remove, and hope for better parse ranking.
#|
basic_v_coord_phr := basic_verbal_coord_phr &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                MINORS #mins,
                                --ADDIN #addin ],
                         VAL [ SUBJ < synsem &
				    [ LOCAL [ CAT #cat,
					      AGR #agr ],
				      NONLOC #nonloc,
				      --SIND #sind,
				      OPT #opt ] >,
			       SPR #spr ] ],
		   CONT.HOOK.XARG #xarg ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                          TAM.MOOD #mood,
                                          --ADDIN #addin & [ ADDPN #pn ],
					  --MAL3SG - ],
                                   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						OPT #opt ] >,
					 SPR #spr ] ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                          TAM.MOOD #mood,
                                          MINORS #mins,
					  --ADDIN.ADDPN #pn,
					  --MAL3SG - ],
				   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						OPT #opt ] >,
					 SPR #spr ] ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    C-CONT.HCONS <! !> ].
|#

;; Allow robust pre-modifiers like 'today'

av_-_i-vp-pr_le_rbst := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                    MOD < [ LOCAL.CAT.HEAD verb &
				                           [ VFORM fin ],
                                            MODIFD.LPERIPH na_or_- ] > ],
                       POSTHD - ],
    GENRE robust ].

;; Correcting |we almost have arrived| by normally blocking these on aux VPs
av_-_i-vp-pr_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.AUX - ].

av_-_i-vp-pr-aux-nfin_le := av_-_i-vp-pr_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD verb &
						   [ AUX +,
						     VFORM non_fin ] ].

;; |we already have arrived|
av_-_i-pr-aux_le_rbst := av_-_i-vp-pr_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD.FIRST.LOCAL.CAT.HEAD verb &
						     [ AUX +,
						       VFORM fin ],
			    MINORS.NORM norm_rel ],
    GENRE robust ].

;; Post-head adv used pre-head: |the cat was bad treated|
av_-_i-po-pr_le_rbst := av_-_i-vp-pr_lexent &
  [ GENRE robust ].

; Allow robust post-VP adverbs: "He sang bad"
;
av_-_i-vp-po_mal_lexent := int_vp_adverb_word & 
  [ SYNSEM [ LOCAL.CAT [ HEAD adv_nonmob & 
                              [ MINORS.MIN adv_rel,
				MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
					MODIFD.RPERIPH na_or_- ] > ],
			 POSTHD + ],
             MODIFD hasmod ],
    GENRE robust ].

;; For |good/bad|, which need special handling
av_-_i-vp-po_le_mal := av_-_i-vp-po_mal_lexent.
av_-_i-vp-po_le_rbst := av_-_i-vp-po_mal_lexent.


; restrict to only VP mods
av_-_i-vp-po-nmb_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob & 
                            [ MINORS.MIN adv_rel,
                              MOD < [ LOCAL.CAT.HEAD verb,
                                      MODIFD.RPERIPH na_or_- ] > ],
                       POSTHD + ] ].

;; Allow robust comparative specifier with comparative adverb: |more faster|
;;
av_-_i-vp-cmp_le_rbst := basic_adverb_word &
  [ SYNSEM intersect_vp_adverb_synsem &
           [ LOCAL.CAT [ VAL.SPR.FIRST [ --MIN more_deg_rel,
					 OPT - ],
			 POSTHD + ] ],
    GENRE robust ].

;; For adjectives with -ly suffixes easly mistaken for adverbs: |friendly|
av_-_i-vp-adj_le_rbst := av_-_i-vp_lexent &
 [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD verb &
					       [ MINORS.ALTMIN non_ellipt_rel ],
   GENRE robust ].

;; Same for comparative adjectives: |more shorter|
;;
aj_-_i-cmp_le_rbst := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
		       VAL.SPR.FIRST expressed_synsem &
				     [ --MIN more_deg_rel ] ],
    GENRE robust ].

;; Wrong form for comparative: |gooder|
;;
aj_pp_i-cmp_le_rbst := norm_adj_comp_lexent &
  [ GENRE robust ].

;; DPF 2017-09-21
;; Block these in non-subject position to enable mal-rule analysis of
;; |he brought many good news for us|

#|
aj_-_i-many_le := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL [ AGR.PNG.PN 3p,
					    CONT.HOOK.INDEX.IND + ],
				    MODIFD.LPERIPH - ] >,
			    CASE nom ] ].

partitive_num_nocomp_rule := partitive_num_nocomp_phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.CASE #case ] > ].
|#

;; DPF 2017-09-26 - Prevent spurious robust analysis of |a few cats|
aj_-_i-many_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.--BARE - ].

;; Add robust type for |many news, many information|
;; Added HEAD.--BARE + to prevent |many fish|
;;
aj_-_i-many_le_rbst := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < expressed_synsem &
				  [ LOCAL [ AGR [ PNG.PN 3s,
						  DIV + ],
					    CAT.HEAD.--NOSUFF - ],
				    MODIFD.LPERIPH na_or_- ] > ],
    GENRE robust ].

;; Make COMPS..HEAD be reg_adv to allow |he did well|
;;
adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
			    [ LOCAL 
			      [ CAT [ HEAD reg_adv &
                                       [ MOD < [ LOCAL intersective_mod ] > ],
                                      VAL [ SPR *olist*,
                                            COMPS < > ],
				      POSTHD + ],
                                CONT.HOOK [ LTOP #hand,
                                            INDEX #event ] ],
                              NONLOC.REL 0-dlist,
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

;; Allow no punct on left dtr
np_city_state_phr := norm_np_name_cmpnd_phr &
  [ SYNSEM [ MODIFD notmod,
	     PUNCT [ LPUNCT #lpunct,
		     RPUNCT #rpunct,
		     RCLSTR #rclstr ] ],
    HD-DTR.SYNSEM [ MODIFD notmod & [ LPERIPH + ],
		    LOCAL [ CAT [ HEAD.MINORS.MIN named_np_or_num_rel,
				  VAL.SPR < [ OPT - ] > ],
			    CONT.HOOK.LTOP #hdltop ] ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN named_np_or_num_rel,
						NORM norm_rel ],
				  VAL.SPR.FIRST.LOCAL.CAT.HEAD adv ],
			    CONT.HOOK.INDEX.SORT entity ],
		    MODIFD notmod_or_rmod,
                    PUNCT [ LPUNCT lparen_or_dq_or_no_punct,
			    RPUNCT comma_or_no_punct ] ],
    C-CONT [ RELS <! [ PRED compound_rel,
		       LBL #hdltop ] !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    ARGS < [ SYNSEM.PUNCT.LPUNCT #lpunct ],
           [ SYNSEM.PUNCT [ RPUNCT #rpunct,
                            RCLSTR #rclstr ] ] > ].

;d_-_the-mal_le := d_-_the_lexent &
;  [ GENRE robust ].

;; Add rels for lexicalized adverb phrases
_at+home_p_rel := miscprep_rel.
_to+bed_p_rel := miscprep_rel.
_out+of+bed_p_rel := miscprep_rel.
_day+to+day_p_rel := miscprep_rel.
_day+by+day_p_rel := miscprep_rel.
_during+break_p_rel := miscprep_rel.
_above+ground_p_rel := miscprep_rel.
_face+to+face_p_rel := miscprep_rel.


;; Add hack empty rel for "mop clean the floor"
_clean_a_sel_rel := selected_adj_rel.

;; Constrain to non-nominative, to avoid spurious analysis of e.g.
;; "what do Kim and Abrams ..."

n_-_pr-fr_le := n_freerel_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE non_nom,
                   CONT.RELS.LIST.FIRST.PRED free_relative_q_rel,
		   AGR.PNG.PN 3s ] ].

;; Constrain "what" to singular, to avoid spurious analysis of 
;; "what do Kim and Abrams ..."
n_-_pr-wh_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s ].

;; DPF 2017-10-07 - Don't see what this change was for, but it lost constraint
;; on the complement NP being saturated, which meant losing non-local constraints.
;;
;p_np_ptcl-of_le := p_prtcl_lexent &
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.--BARE - ] > ].

; Prevent analysis for "with her cousins"
p_np-np_s-ncop_le := noncqrs-nab &
  [ SYNSEM subconj_with_np_np_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN #pn ],
	                           [ LOCAL.AGR.PNG.PN #pn ] > ] ].

;; DPF 2017-09-23 - Prevent (pre-)modif of VPs, to avoid spurious robust 
;; analysis of |while she was [babysitting she] fed food to the baby.
;;
subconj_synsem := subconj_cp_synsem & 
  [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.VAL.SUBJ *anti_list*,
		VAL.COMPS < [ LOCAL [ CAT s_cat_unspec & 
					[ MC -,
					  HEAD verb & [ VFORM fin_or_imp ] ],
				      CONT.HOOK.INDEX.SF prop-or-comm ],
			      --SIND.E.TENSE real_tense ] > ] ].

;; DPF 2017-09-21 - Require tense in main and subord clauses to match
;; |She was serious when she tells us the story|

p_cp_s_le := subconj_word &
  [ SYNSEM subconj_ind_synsem &
	   [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE nonpast,
			 VAl.COMPS < [ LOCAL.CAT s_cat_fin ] > ] ] ].

p_cp_s-past_le := subconj_word &
  [ SYNSEM subconj_ind_synsem &
	   [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE past,
			 VAl.COMPS < [ LOCAL.CAT s_cat_fin &
						 [ HEAD.TAM.TENSE past ]]>]]].
p_cp_s_le_rbst := subconj_word &
  [ SYNSEM subconj_ind_synsem &
	   [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM [ TENSE past,
							     UNSP-TENSE - ],
			 VAl.COMPS < [ LOCAL.CAT s_cat_fin &
					     [ HEAD.TAM [ TENSE nonpast,
							  UNSP-TENSE - ]]]>]],
    GENRE robust].


p_cp_s-notop_le := subconj_word &
  [ SYNSEM subconj_synsem & 
     [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE nonpast,
		   VAL [ SPR < [ --MIN just_only_notvery_deg_rel ] >,
			 COMPS < [ LOCAL.CAT.HEAD [ CASE obliq,
						    VFORM fin ] ] > ]]]].

p_cp_s-notop-past_le := subconj_word &
  [ SYNSEM subconj_synsem & 
     [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE past,
		   VAL [ SPR < [ --MIN just_only_notvery_deg_rel ] >,
			 COMPS < [ LOCAL.CAT.HEAD [ CASE obliq,
						    VFORM fin,
						    TAM.TENSE past ] ] > ]]]].

p_cp_s-notop_le_rbst := subconj_word &
  [ SYNSEM subconj_synsem & 
     [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM [ TENSE past,
						       UNSP-TENSE - ],
		   VAL [ SPR < [ --MIN just_only_notvery_deg_rel ] >,
			 COMPS < [ LOCAL.CAT.HEAD [ CASE obliq,
						    VFORM fin,
						    TAM [ TENSE nonpast,
							  UNSP-TENSE - ]]] >]]],
    GENRE robust ].


p_cp_s-unsp_le := subconj_word &
  [ SYNSEM subconj_synsem &
    [ LOCAL.CAT [ HEAD [ PRD -,
			 MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE nonpast ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS < [ LOCAL.CAT.HEAD [ VFORM fin ] ] > ]]]].

p_cp_s-unsp-past_le := subconj_word &
  [ SYNSEM subconj_synsem &
    [ LOCAL.CAT [ HEAD [ PRD -,
			 MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE past ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS < [ LOCAL.CAT.HEAD [ VFORM fin,
						   TAM.TENSE past ] ] > ]]]].

p_cp_s-unsp_le_rbst := subconj_word &
  [ SYNSEM subconj_synsem &
    [ LOCAL.CAT [ HEAD [ PRD -,
			 MOD.FIRST.LOCAL.CAT.HEAD.TAM [ TENSE past,
							UNSP-TENSE - ] ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS < [ LOCAL.CAT.HEAD [ VFORM fin,
						   TAM [ TENSE nonpast,
							 UNSP-TENSE - ]]] > ]]],
    GENRE robust ].

mal_v_inf_cp_comp_le := main_verb_mliszt &
   [ SYNSEM mal_v_inf_cp_comp_verb &
       [ LOCAL.CAT [ VAL.COMPS < [ OPT - ] > ] ],
     GENRE robust ].

mal_va_does_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN 3s ] ] >,
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

va_doesnt_neg_pres_le_rbst := do_aux_neg_pres & 
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ.FIRST.LOCAL.CAT.HEAD.--BARE +,
                   AGR.PNG png & [ PN 3s ] ],
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

va_dont_neg_pres_le_rbst := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ],
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

mal_va_do_fin_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN -3s ] ] >,
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

mal_va_has_le := has_aux_lex_ent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_va_have_fin_le := have_fin_aux_lex_ent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

v_vp_has-n_le_rbst := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL [ AGR.PNG.PN -3s,
            	   CAT.VAL.COMPS.FIRST expressed_synsem ],
    ALTS.VPELLIP -,
    GENRE robust ].

v_vp_have-f-n_le_rbst := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3s,
             	   CAT.VAL.COMPS.FIRST expressed_synsem ],
    ALTS.VPELLIP -,
    GENRE robust ].

#|
mal_vc_there_synsem := there_cop_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST expressed_synsem &
                              [ LOCAL.CAT.HEAD.MINORS 
					      [ MIN non_temp_nom_rel,
					        ALTMIN def_udef_some_a_no_q_rel,
						NORM no_rel ] ] ].
|#
;; Restricted COMPS..MIN from non_temp_nom_rel to norm_nom_rel in order to
;; exclude numbers as in |there are eight|
;;
mal_vc_there_synsem := there_cop_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST expressed_synsem &
                              [ LOCAL.CAT.HEAD.MINORS 
					      [ MIN norm_nom_rel,
					        ALTMIN def_udef_some_a_no_q_rel,
						NORM no_rel ] ] ].

mal_vc_there_is_le := vc_there_are_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem &
           [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX nonconj_ref-ind &
							     [ PNG.PN 3p,
	                                                       DIV + ] ] ].

mal_vc_there_are_le := vc_there_is_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem ].

mal_vc_there_was_le := vc_there_were_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem &
           [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.AGR nonconj_ref-ind &
							     [ DIV + ] ] ].

mal_vc_there_were_le := vc_there_was_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem &
	  [ LOCAL.CAT.HEAD.--MAL3SG + ] ].

v_np-xp_is-n_le_rbst := be_are_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

v_np-xp_are-n_le_rbst := be_is_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

v_np-xp_was-n_le_rbst := be_were_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

v_np-xp_were-n_le_rbst := be_was_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

;; DPF 2012-08-17 - Removed SLASH 0-dlist from SUBJ for these, since we
;; want |the bear who are admired|.  Maybe we'll recall why this was added.

mal_vc_prd_is_le := vc_prd_are_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST expressed_synsem & 
                                    [ LOCAL.AGR [ PNG.PN 3p,
				                  DIV + ] ],
    GENRE robust ].

;; Added SUBJ..MIN norm_nom_rel to avoid use in |three are on the table|
mal_vc_prd_are_le := vc_prd_is_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
                                            AGR.PNG.PN sg ],
    GENRE robust ].

mal_vc_prd_was_le := vc_prd_were_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST expressed_synsem & 
    				    [ LOCAL.AGR [ PNG.PN 3p,
    				                  DIV + ] ],
    GENRE robust ].

mal_vc_prd_were_le := vc_prd_was_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT [ HEAD.--MAL3SG +,
                       VAL.SUBJ.FIRST.LOCAL.AGR.PNG.PN sg ],
    GENRE robust ].

; Treat robust "be" and "been" as VFORM prp, so they trigger the robust
; subj-head rule which needs to avoid allowing ordinary base form verbs
; (identical to non-3sg) and ordinary past participles (identical to 
; past tense).
mal_vc_prd_be_le := vc_prd_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_np_be_le := vc_np_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_prd_been_le := vc_prd_been_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_np_been_le := vc_np_been_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

#|
;; Not used
mal_det_div_le := det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.MIN
                                                     just_only_deg_rel ] >,
                     AGR.PNG.PN 3s ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s ],
                                 DIV + ],
	     MODIFD hasmod ],
    GENRE robust ].
|#

; 'they/that'
#|
mal_n_deictic_pro_le := n_deictic_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p,
                                           GEN neut ] ] ].
|#

mal_det_pl_le := det_pl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAt.HEAD.--BARE -,
    GENRE robust ].

mal_n_plur_ppcomp_le := n_plur_ppcomp_lexent &
  [ GENRE robust ].

; (ERB 2003-10-17) For verbs like "allow" taking a CP[to]
; complement with the PRO bound to arbitrary reference.  Regenerate
; with gerunds instead.  (Might need another class where we
; regenerate with an inserted pronoun "one", if there are verbs
; that show up in this pattern but can't take gerund complements.)

; (ERB 2003-10-17) This is going to be a fairly strange verb type.  I
; can't think of any true English verbs off hand that take an
; infinitival CP complement and allow arbitrary control of the subject
; of that complement.  Furthermore, this type is also putting in some
; extra semantics, in order to allow the right string to come back
; from the generator.  So, we're not inheriting from the usual places
; in the hierarchy.  For example, main_verb is constrained to have a
; single element RELSs list.  main_verb_mliszt will do, though,
; although this isn't what it was intended for. Likewise, I don't
; think any of the linking types lower in the hierarchy will do what
; we want.  Took some constraints from subj_equi_inf_lt to try to
; restrict what can show up as the complement.

; (ERB 2003-10-23) Can't currently generate with these entries,
; and I don't know why.  Can generate from the produced MRS at all,
; in fact.  The MRS produced isn't the same as the MRS for the target,
; because of gerunds are built from progressives and therefore have
; a different value for PROGR.  (There are some other mismatches,
; but they are compatible, so maybe it would work otherwise.)
; While we might consider changing the analysis of gerunds, I
; think the main conclusion to draw is that we will need some kind
; of a transfer component.  Maybe put everything there rather than
; trying to map from mal-formed syntax to well-formed semantics in
; the grammar itself?  If not everything, how to decide when to do
; which?

mal_v_inf_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & basic_two_arg & 
			  norm_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  abstract_quant_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].
	   
#|
mal_v_inf_from_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & 
			       basic_two_arg & norm_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  abstract_quant_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].
|#

_they+that_q_mal_rel :< demonstrative_q_rel.

;; Mal NI (but not CE) rules, for lack of do support:

mal_adv_addition := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.AUX - ].

mal_sai_synsem := basic_sai_synsem & 
  [ LOCAL.CAT.HEAD.AUX - ].

; (ERB 2003-08-15) sai seems to be constraining its input
; to be INV +, rather than AUX +.  So, moving that constraint down
; to sai, and putting the opposite thing on mal_sai.
; (ERB 2003-08-15) Adding AUX - to DTR to keep auxiliaries out
; of this mal-rule.

mal_sai := basic_sai &
  [ SYNSEM mal_sai_synsem,
    DTR.SYNSEM.LOCAL.CAT.HEAD [ AUX -,
				INV - ] ].

mal_finvp_rule := basic_unary_phrase & rule &
  [ INFLECTD +,
    GENRE robust,
    SYNSEM [ LOCAL [ CAT [ HEAD frag,
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
                           MC + ],
                     CONJ cnil ],
             NONLOC non-local_none ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VFORM fin,
                                                  INV - ],
                                    VAL [ SUBJ < unexpressed_reg >,
                                          COMPS *olist* ] ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX #event,
                                          XARG #arg0 ],
                              AGR.PNG #png ],
                      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                  REL 0-dlist,
                                  QUE 0-dlist ] ],
	     GENRE robust ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event ],
             RELS <! [ PRED _they+that_q_mal_rel,
                     ARG0 #arg0 & ref-ind & 
                          [ PNG #png & [ PN 3p,
                                         GEN neut ] ],
                     RSTR #rhand ],
                   [ LBL #nhand,
                     PRED generic_nom_rel,
                     ARG0 #arg0 ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !> ] ].
             
;; Block misanalysis of imperatives as VP fragments, as in "put the book here"
;; (via [--MAL3SG +].
frag_vp_rule := frag_verbal_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN norm_rel,
                                       VFORM non_bse,
                                       TAM.MOOD ind_or_modal_subj,
                                       MOD *cons*,
				       --MAL3SG + ],
                                VAL.SUBJ < synsem &
                                           [ LOCAL.CAT.HEAD noun,
                                             --SIND non_expl-ind,
					     NONLOC.SLASH 0-dlist ] > ] ] >,
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].


frag_vp_fin_3sg_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD [ AUX -,
                                       TAM #tam & [ TENSE present ],
				       --ADDIN [ ADDTAM #tam,
				                 ADDPN #pn ] ],
                            AGR.PNG.PN #pn & 3s ] ] > ].

frag_vp_fin_past_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ AUX -,
                                     TAM #tam & [ TENSE past ],
                                     --ADDIN.ADDTAM #tam ] ] > ].

frag_vp_fin_aux_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.AUX + ] > ].


;; DPF 2017-12-23 - Enable blocking of frag analysis for |how happy he is|
;;
frag_adj_rule :+
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
		      NONLOC non-local_none ] ] >  ].

frag_pp_ind_rule :+
  [ ARGS < [ SYNSEM.NONLOC non-local_none ] >  ].

;; Block the application of this rule, to avoid spurious analyses for e.g.
;; |the pie-eating contest|
;; DPF 2012-11-20 - But we need it in general for e.g. |the covered-up plate|
;;
#|
punctuation_hyphen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT hyphen_sgl & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT.HEAD no_head,
	              PUNCT [ LPUNCT #lpunct & no_punct,
                              RPUNCT no_punct &
                                     [ PSF #pred ],
                              RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre,
    RNAME "LPHR" ].
|#

#|
;; Block this rule, to avoid ambiguity: |The neighbors' is by the tree.|
;; DPF 16-01-14 - But we'll need this for more general input, and don't add
;; much ambiguity in the single-sentence composition by keeping it.
;;
punctuation_sqright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT sq_punct & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT.HEAD no_head,
	              PUNCT [ LPUNCT #lpunct & no_punct,
                              RPUNCT comma_or_clause_or_no_punct &
                                     [ PSF #pred ],
                              RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre ].
|#

;; Prevent comma marking on spr, as in "most of all, pizza tastes great"
head_spec_phrase :+
  [ NH-DTR.SYNSEM.PUNCT.RPUNCT no_punct ].

;; Constrain to exclude gerunds with subjects, as in spurious analysis of
;; "what was kim doing yesterday?"

#|
subjh_nonmc_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin_or_bse,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD verbal,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD n_or_v ].
|#
subjh_nonmc_rule := subjh_rule_decl & head_subj_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin_or_bse,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD verbal,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD n_or_v ].

;; Constrain to SF prop-or-like: if want question, have to supply question mark
;;
subjh_mc_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                  TAM indic_tam ],
                           MC + ],
                     CONT.HOOK.INDEX.SF #pred & prop-or-like ],
             PUNCT.RPUNCT.PSF #pred ] ].

subjh_mc_ques_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                  TAM indic_tam ],
                           MC + ],
                     CONT.HOOK.INDEX.SF #pred & ques ],
             PUNCT.RPUNCT clause_punct & [ PSF #pred ] ] ].

;; DPF 2017-10-06 - Replaced ALTMIN udef_q_rel with quant_rel, so we can also 
;; get robust |we admire old one|
bare_np_sg_phrase_robust := basic_bare_np_sg_phrase_robust &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN quant_rel ].


#|
;; Enrich this rule to propagate dtr's MOD..--BARE value to SPEC, in order to
;; constrain robust "all" as in "all pizza"
;;
num_det_rule :+ 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.--BARE #b ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.--BARE #b ] > ] > ].
|#

#|
double_det_rule := head_valence_phrase & head_final & rule &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT #cat,
                     CONJ cnil ],
             NONLOC #nonloc,
	     MODIFD #modif,
             LEX #lex ],
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT #cat & [ HEAD det ],
                              CONT.HOOK #hdhook,
                              CONJ cnil ],
                      NONLOC #nonloc,
                      MODIFD #modif,
                      LEX #lex ] ],
    NH-DTR [ SYNSEM lex_synsem &
                   [ LOCAL [ CAT.HEAD det,
                             CONT.HOOK.INDEX #nhindex,
                             CONJ cnil ],
                     NONLOC non-local_none,
                     LKEYS.KEYREL.RSTR #rstr ] ],
    C-CONT [ HOOK #hdhook,
             RELS <! arg0_relation &
                     [ LBL #nhand,
                       PRED generic_nom_rel,
                       ARG0 #nhindex ],
                     arg1_relation &
                     [ PRED ellipsis_rel,
                       ARG1 #nhindex ] !>,
	     HCONS <! qeq & [ HARG #rstr,
                              LARG #nhand ] !> ],
    GENRE robust ].
|#

; "One books"
mal_num_det_rule_1 := basic_num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL [ AGR.PNG.PN 3p,
					  CONT.HOOK.INDEX.PNG.PN 3p,
    			      	          CAT.HEAD.MINORS.NORM 
					                 norm_or_no_rel ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL.AGR.PNG.PN 3s ] >,
				     MINORS.NORM norm_rel ] ] >,
    GENRE robust ].

; "Twenty book"
;; DPF 2017-12-22 - Changed from SPEC..AGR..PN to SPEC..INDEX..PN, in order to
;; also catch |two third of the cats|
;;
mal_num_det_rule_2 := num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL [ CONT.HOOK.INDEX.PNG.PN 3s,
					  CAT.HEAD [ --BARE +,
						     MINORS.NORM 
					                 norm_or_no_rel ] ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.PNG.PN 3p ] > ] >,
    GENRE robust ].

;; Plural det with singular count noun (all, several, many, more, most)
;; as in |all cat arose|
;; But block this one for temporal nouns as in |all year|
;;
aj_-_i-one_le_rbst := aj_-_i-one_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS [ ALTMIN no_rel,
					   NORM no_rel ],
				  MOD < [ LOCAL [ CAT [ HEAD.--BARE +,
				                        VAL.SPR < unexpressed > ],
						  CONT.HOOK.INDEX 
						      [ DIV -,
							SORT entity ] ],
					  LEX - ] > ],
			   VAL.COMPS *synnull* ] ],
	     MODIFD.LPERIPH + ],
    GENRE robust ].

;; Stop |one flower| from getting robust bare-sg analysis
aj_-_i-one_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.--BARE - ].

;; DPF 13-03-14 - Drop the requirement for MOD's SPR to be explicit, so we can
;; robustly parse |we admire best performer|.  This means we won't catch
;; erroneous |we admire best performers|.  FIX someday?
;;
#|
aj_-_i-sup_le := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
    [ LOCAL [ CAT [ HEAD superl_adj & [ MINORS.ALTMIN superl_rel,
                                         MOD < [ LOCAL.CAT.HEAD.MINORS.ALTMIN
                                                   explicit_q_rel ] > ],
                    VAL.SPR.FIRST.--MIN ord_or_very_rel ],
              CONT.RELS <! relation, relation !> ],
      LKEYS.ALTKEYREL.PRED superl_rel ] ].

aj_-_i-sup_le := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
    [ LOCAL [ CAT [ HEAD superl_adj & [ MINORS.ALTMIN superl_rel ],
                    VAL.SPR.FIRST.--MIN ord_or_very_rel ],
              CONT.RELS <! relation, relation !> ],
      LKEYS.ALTKEYREL.PRED superl_rel ] ].
|#

;; Prevent non-robust |admire best one|
num_noun_phrase := basic_num_noun_phrase &
  [ SYNSEM.MODIFD lmod & [ LPERIPH + ] ].

;; Allow robust |dentists office|
aj_-_i-cmpd_le_rbst := aj_-_i-cmpd_lexent &
  [ GENRE robust ].

; Block clefts:
; But this also blocks |It is after the sun goes down|
#|
be_nv := be_verb &
  [ SYNSEM nv_cop_verb &
	   [ LOCAL.CONT [ HOOK.INDEX #event,
			  RELS.LIST.FIRST.ARG0 #event ] ],
    ALTS.VPELLIP -,
    GENRE robust ].
|#
;; Block inversion with `be' taking CP complement
be_nv := be_verb &
  [ SYNSEM nv_cop_verb &
	   [ LOCAL [ CAT.HEAD [ INV - ],
		     CONT [ HOOK.INDEX #event,
			    RELS.LIST.FIRST.ARG0 #event ] ] ],
    ALTS.VPELLIP - ].

#|
;; In lextypes.tdl
;; Remove SORT non-time-sort constraint to allow 
;; |the morning is the best part of the day|
n_-_c-ns_le := basic_intr_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT.HOOK.INDEX.PNG.GEN neut ] ].
|#

;; Add extra subtype of non_obliq case to impose constraint on abstract noun
;; |man| as in |man's best friend|
genitive := non_obliq.

;; Prevent mal-det and mal-adj (e.g. "all") from spurious robust analyses
n_-_mc_le :+ 
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].


;; Block robust plural rule from applying to e.g. "north"
#|
;; CoNLL
n_-_c-dir_le := n_-_mc-ntoj_lexent &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
           [ LOCAL.CAT.HEAD.--BARE -,
	     MODIFD.LPERIPH + ] ].

n_-_c-dir_le := n_-_mc-ntoj_lexent &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
           [ LOCAL.CAT.HEAD.--BARE - ] ].
|#

;; Add idiomatic noun type to ensure idiomatic cooccurrences such as 
;; |give a speech| while PET still does not enforce idioms
idiom_nom_rel := reg_nom_rel.
idiom_modable_nom_rel := idiom_nom_rel & modable_nom_rel.
;; These two used with mal-entry for ditransitives to block mal-parse for
;; |gave a speech| where "speech" entry is [--MIN alt_idiom_nom_rel] indicating
;; that it has an alternative idiomatic (light-verb-friendly) entry.
non_idiom_nom_rel := norm_nom_rel.
alt_idiom_nom_rel := norm_nom_rel.

n_-_c-idm_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN idiom_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_m-idm_le := noun_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ MODIFD notmod,
	     LOCAL.CAT.HEAD.MINORS.MIN idiom_nom_rel,
	     LKEYS.KEYREL reg_nom_relation ] ].

#|
;; For doubled nouns like "beach beach"
;; (Chart mapping for `educ' should add LPERIPH bool to the second of two 
;; repeated words, to prevent a normal noun-noun compound analysis, leaving
;; this robust compound rule analysis.
noun_n_cmpnd_phr_doubled := basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM basic_lex_synsem &
		  [ MODIFD notmod & [ LPERIPH bool ],
		    PUNCT.LPUNCT dq_or_no_punct,
		    LKEYS.KEYREL.PRED #pred ],
    NH-DTR [ SYNSEM lex_synsem &
	  	    [ LKEYS.KEYREL.PRED #pred ],
	     INFLECTD na_or_- ],
    GENRE robust ].

noun_n_cmpnd_rule_mal := binary_rule_right_to_left & noun_n_cmpnd_phr_doubled.
|#

;; In order to distinguish transparent irregular plurals like |trout|, to
;; block them in the robust N-N-compound-plural rule, we add types 
;; cat_infl_suff and cat_infl_nosuff 

basic_noun :+ [ --NOSUFF bool ].
cat_infl_suff := cat.
cat_infl_nosuff := cat &
  [ HEAD.--NOSUFF + ].

n_-_c-pl_le :+ [ SYNSEM.LOCAL.CAT cat_infl_nosuff ].
n_-_c-pl-def_le :+ [ SYNSEM.LOCAL.CAT cat_infl_nosuff ].

;; mal-entry for |they arrived in 1920s|
n_-_c-pl-gen_le_mal := n_-_c-pl-gen_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST unexpressed,
    GENRE robust ].

;; For |the gardens dog|
;; Block this rule for |his cats cat toys| via INFLECTD on hd-dtr.
;; And block for |he makes his children breakfast| via LOCAL sing_or_plur_noun
;; so we can also get robust |the cousins brothers|. But this prevents 
;; |cats food|, so instead mark |breakfast| with LPERIPH to block here.
;; DPF 2017-10-03 - Generalize HD-DTR..RPERIPH from na to na_or_+ to allow
;; robust analysis of |Kids brains develop|
;; DPF 2017-10-03 - Constrain hd-dtr HEAD basic_noun to exclude |cars honking|
;; Also constrain nonhd to nonconj: |[chocolate sprinkles and ten] candles|
;; DPF 2017-10-04 - Further constrain head dtr to be basic_lex_synsem to
;; block |snakes [bite classmates]|
;; DPF 2018-02-15 - Changed SYNSEM..LPERIPH from na to +, to prevent these
;; appearing as heads of larger compounds, as in |Anita rides horses|
;;
noun_n_cmpnd_pl_mal := binary_rule_right_to_left & basic_noun_n_cmpnd_phr &
  [ SYNSEM.MODIFD.LPERIPH +,
    HD-DTR [ INFLECTD +,
	     SYNSEM basic_lex_synsem &
		    [ LOCAL [ CAT.HEAD basic_noun &
			               [ MINORS.MIN non_temp_nom_rel ] ],
		      MODIFD notmod & [ LPERIPH -,
					RPERIPH na_or_+ ],
		      PUNCT.LPUNCT dq_or_no_punct ] ],
    NH-DTR [ INFLECTD +,
             SYNSEM lex_synsem &
	            [ LOCAL [ CAT cat_infl_suff &
				  [ HEAD.--BARE - ],
		              CONT.HOOK.INDEX nonconj_ref-ind & [ PNG.PN 3p ],
			      AGR.PNG.PN 3p ],
		      PUNCT.RPUNCT dq_or_no_punct ] ],
    GENRE robust ].


;; Don't want |can arise| as NP-VP
#|
bare_np_prd_phrase := reg_bare_np_phrase &
  [ SYNSEM.LOCAL.AGR.DIV -,
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun & [ CASE nom ],
				  VAL.SPR.FIRST unexpressed_reg ] ] ] > ].
|#

alts :+ [ PLMASS bool ].

;; For robust plural of mass nouns
;;
lex_rule_plural_mass := lex_rule_basic & word_or_infl_rule &
  [ INFLECTD +,
    KEY-ARG #keyarg,   
    SYNSEM mass_or_count_synsem &
	   [ LOCAL [ CAT #cat & [ HEAD noun_or_ttl,
				  VAL.SPR < synsem &
					    [ LOCAL.AGR [ PNG.PN 3p,
							  DIV + ] ] > ],
		     CONT #cont,
		     CONJ #conj,
		     CTXT #ctxt,
		     ARG-S #arg-s ],
	     NONLOC #nonloc,
	     OPT #opt,
	     --MIN #min,
	     --SIND #sind,
	     LEX #lex,
	     MODIFD #modifd,
	     PHON #phon,
	     PUNCT #punct,
	     LKEYS #lkeys ],
    ARGS < #dtr >,
    DTR #dtr & [ INFLECTD -,
                 KEY-ARG #keyarg,   
		 ALTS.PLMASS +,
                 SYNSEM basic_mass_noun_synsem &
			[ LOCAL [ CAT #cat,
				  CONT #cont,
				  CONJ #conj,
				  CTXT #ctxt,
				  AGR [ PNG.PN 3s,
					DIV + ],
				  ARG-S #arg-s ],
			  NONLOC #nonloc,
			  OPT #opt,
			  --MIN #min,
			  --SIND #sind,
			  LEX #lex,
			  MODIFD #modifd,
			  PHON #phon,
			  PUNCT #punct,
			  LKEYS #lkeys ] ],
    C-CONT.RELS <! !>,
    GENRE robust ].

;; Prevent these from undergoing bare-sg-rbst rule
;unsp_mass_or_count_synsem :+
;  [ LOCAL.CAT.HEAD.--BARE - ].

basic_mass_or_count_synsem :+
  [ LOCAL.CAT.HEAD.--BARE - ].

;; Since bare-sg-NP keeps AGR as 3s, change the following type to allow either
;; sg or plur NP comps, as in |we human| for |we humans|, but restrict to IND +
;; to avoid |[we rented ice] skates|

pro_wcomps_plur_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL [ COMPS 
                      < [ LOCAL [ CAT [ HEAD basic_noun & 
                                        [ MINORS 
					    [ MIN nonpro_rel,
					      ALTMIN both_all_udef_q_rel ] ],
					VAL [ SPR *olist*,
					      SUBJ < >,
					      COMPS < >,
					      SPEC < anti_synsem_min > ] ],
				  CONT.HOOK.INDEX #cind & nonconj_ref-ind,
				  AGR [ PNG.PN 3,
					IND + ] ],
			  NONLOC non-local_none,
			  OPT - ] > ],
            CONT [ HOOK.INDEX #ind & [ IND + ],
                   RELS <! [ LBL #lbl ], relation & #altkeyrel,
			   #alt2keyrel & [ LBL #lbl,
					   PRED appos_rel,
					   ARG0.E.TENSE no_tense,
					   ARG1 #ind,
					   ARG2 #cind ] !> ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    ALT2KEYREL #alt2keyrel ] ].

;; Missing apostrophe for contraction of "it is"
be_is_mal_lex_entry := nonc-h &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < anti_synsem_min >,
			       COMPS < synsem & [ OPT - ], ... >,
			       SPCMPS < > ],
			 HEAD [ VFORM fin,
				PRD -,
				INV -,
				TAM tam &
				      [ TENSE present,
					ASPECT.PRF -,
					MOOD subjunctive ] ],
			 POSTHD + ],
		   AGR.PNG png & [ PN 3s ],
		   CONT psoa &
		       [ HOOK.XARG #xarg & ref-ind & [ PNG.PN 3s ],
		         RELS.LIST < [ PRED pron_rel,
				       LBL #nhand,
				       ARG0 #xarg ],
				     [ PRED pronoun_q_rel,
				       ARG0 #xarg,
				       RSTR #rhand ], ... >,
			 HCONS <! qeq & [ HARG #rhand,
					  LARG #nhand ] !> ] ],
    ALTS.CSAI -,
    GENRE robust ].

v_prd_its-mal_le := be_is_mal_lex_entry &
  [ SYNSEM prd_aux_verb_ssr &
	   [ LOCAL [ CAT [ HEAD [ TAM #tam ],
			   VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.TAM #tam,
						   CONT.HOOK.LTOP #ltop ] ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation, relation !> ] ],
	     LKEYS.KEYREL.PRED be_v_prd_rel ] ].

v_np_its-mal_le := be_is_mal_lex_entry &
  [ SYNSEM aux_np_verb &
	   [ LOCAL [ CAT [ HEAD [ TAM.ASPECT.PROGR - ],
			   VAL.COMPS < [ LOCAL.CAT.HEAD.--BARE - ] > ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #event ],
			    RELS <! relation, relation, #keyrel !> ] ],
	     LKEYS.KEYREL #keyrel &
		          [ LBL #ltop,
			    ARG0 #event,
			    PRED _be_v_id_rel ] ] ].

;; For |have went ...|
;; FIX: block this for ordinary -ed past participles, presumably by splitting
;; the infl rule similarly to the split for reg and irreg plurals.
;; DPF 2017-09-06 - Added COMPS..--MALPAST - to enable preventing
;; unwanted double-robust analysis for |she had eaten|
;;
psp_aux_verb_mal_ssr := basic_have_aux_verb_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT vp_cat &
					[ HEAD verb &
					       [ VFORM fin,
						 TAM #tam & [ TENSE past,
							      IRR-TENSE + ],
						 --ADDIN.ADDTAM #tam,
						 --MALPAST - ],
					  VAL.SUBJ < [ LOCAL.CAT.HEAD noun ] >],
				    CONJ cnil ],
			    OPT - ] > ].

psp_aux_verb_mal_word := aux_verb_word &
  [ INFLECTD +,
    SYNSEM psp_aux_verb_mal_ssr &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD -,
				  TAM indic_tam ],
			   POSTHD +,
			   VAL [ SUBJ < synsem & 
					[ LOCAL [ CAT nomp_cat_nom_min,
						  CONJ cnil ],
					  OPT - ] >,
				 COMPS < canonical_synsem &
					 [ LOCAL.CONT.HOOK.LTOP #hand ] > ] ],
		     CONT psoa &
			  [ HOOK.LTOP #hand,
			    RELS <! !>,
			    HCONS <! !> ] ] ],
    GENRE robust,
    ALTS.CSAI - ].

v_vp_has-mal_le := psp_aux_verb_mal_word &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.AGR.PNG png & [ PN 3s ] ] > ].

v_vp_have-mal_le := psp_aux_verb_mal_word &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.AGR.PNG png & [ PN -3s ] ] > ].

v_vp_had-mal_le := psp_aux_verb_mal_word &
  [ INFLECTD + ].

v_np_are-n_le_rbst := v_np_are-n_lexent &
  [ GENRE robust ].

v_np_is-n_le_rbst := v_np_is-n_lexent & 
  [ GENRE robust ].

v_np_was-n_le_rbst := v_np_was-n_lexent &  
  [ GENRE robust ].

v_np_wre-n_le_rbst := v_np_wre-n_lexent &
  [ GENRE robust ].

; For e.g. "went the store"
; Add NORM no_rel to block v_mod rule for e.g. "went to visit her house"
v_np_pp_le_rbst := main_verb & 
  [ SYNSEM np_non_trans_verb &
     [ LOCAL.CAT [ HEAD.MINORS.NORM no_rel,
		   VAL.COMPS < canonical_synsem &
			       [ OPT -,
				 LOCAL.CAT.HEAD noun &
				     [ --BARE - ],
				 PUNCT.RPUNCT comma_or_clause_or_no_punct ] >]],
    GENRE robust ].

;; Constrain to singular unknown names, to avoid spurious for e.g. |Pistorius|
n_-_pn-gen_le := basic_n_proper_lexent & generic_ne_lex_entry &
  [ INFLECTD -,
    SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN named_np_rel,
			   VAL.SPR < [ --MIN _the_q_prop_rel ] > ],
		     AGR.PNG.PN 3s ],
	     MODIFD.LPERIPH na_or_+,
	     LKEYS.KEYREL [ PRED named_rel ] ] ].

;; Constrain to not capitalized, to avoid spurious entry for e.g. |Mom|
;;
n_-_mc-unk_le := n_-_mc-unk_lexent & norm_unknown_word &
  [ TOKENS.+LAST.+CLASS.+CASE non_capitalized ].

;; Hack to accommodate |would rather VP than X|
;;
ssr_vp_pp_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
	   [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                        INDEX #subj ] ] >,
	     COMPS < [ LOCAL [ CAT [ HEAD verbal & [ VFORM bse ],
                                     VAL [ SUBJ < synsem >,
					   COMPS < > ] ],
                               CONT.HOOK.XARG #subj ],
                       OPT - ],
		     synsem &
		     [ --MIN _than_p_compar_rel,
                       LOCAL [ CAT basic_pp_cat & 
                                   [ HEAD.MOD < > ],
                               CONJ cnil ],
		       OPT - ] > ],
            CONT.HOOK.LTOP #ltop ] ].

;; For |would rather|
;; Removed, since have better analysis now.
#|
ssr_vp_pp_verb := verb_synsem & ssr_vp_pp_subst & ssr_expr_lt.
v_vp-pp_ssr_le := main_verb_mliszt & 
  [ SYNSEM ssr_vp_pp_verb ].
|#

v_vp_mdl-p-cx_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.UNSP-TENSE + ].

; For e.g. |It affected to Kim| with spurious prep
v_pp_np_le_rbst := main_verb & 
  [ SYNSEM empty_prep_intrans_verb &
	     [ LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ],
    GENRE robust ].

;; For wrong prep marker, as in |abide to|
v_pp_e_le_rbst := main_verb & 
  [ SYNSEM empty_prep_intrans_verb &
	   [ LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ],
    GENRE robust ].

;; For wrong prep marker as in |allocated it of Kim|
v_np-pp_e_le_rbst := main_verb & 
  [ SYNSEM empty_prep_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < [ OPT - ], [ OPT - ] > ],
             LKEYS [ --OCOMPKEY #ocmin,
                     --+OCOMPKEY #ocmin ] ],
    GENRE robust ].

;; Wrong prep marker for adjectives: |*He was bored of it|
aj_pp_i_le_rbst := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
                       VAL.COMPS.FIRST.OPT - ],
    GENRE robust ].

;; DPF 2017-09-12 - Exclude malrule for 3sg, to avoid spurious robust analysis
;; for |It is important that he respect the rules|
;;
aj_pp-cp_i-it_le := reg_adj_atrans_cp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT -,
                                   LOCAL.CAT.HEAD.--MAL3SG - ] > ].


; DPF 04-aug-10 - Block free relatives via NH-DTR..HEAD value
;; DPF 2017-04-03 - Restrict to MC + to avoid use in e.g.
;; |he was in the theater seat sleeping|

subjh_nonfin_robust_rule := subjh_rule_basic & head_subj_phrase &
			    non_rel_clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb & 
				[ VFORM non_pas,
				  TAM indic_tam & [ ASPECT.PRF - ] ],
			   MC + ],
                     CONT.HOOK.INDEX.SF #pred ],
	     NONLOC.SLASH 0-dlist,
             PUNCT.RPUNCT.PSF #pred ],
    HD-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #hdtop,
				    INDEX #hdind ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD noun,
		    PUNCT.RPUNCT pair_or_no_punct ],
    C-CONT [ HOOK [ LTOP #hdtop,
                    INDEX #hdind ],
             RELS <! !>,
             HCONS <! !> ],
    GENRE robust ].

; DPF 22-nov-07 - For now, don't allow bare-sg NPs as subjects here, to
; avoid too much ambiguity - maybe FIX later, if this is too restrictive
;
subjh_robust_rule := subjh_rule_decl & basic_head_subj_phrase & clause &
  [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin,
                              TAM indic_tam & [ TENSE present ],
			      CASE non_nom ],
                       MC + ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN non_ellipt_rel,
				  VAL.SUBJ < canonical_synsem &
                                       [ LOCAL [ CAT #cat,
                                                 CONT #cont,
                                                 CONJ #conj,
                                                 CTXT #ctxt ],
                                         NONLOC #nonloc,
					 --SIND ref-ind & #sind,
                                         OPT #opt,
                                         LEX #lex,
                                         MODIFD #modifd,
                                         PHON #phon,
                                         PUNCT #punct ] > ],
			    CONT.HOOK.INDEX non_conj_event ],
                    NONLOC.SLASH 0-dlist ],
    NH-DTR.SYNSEM [ LOCAL [ CAT #cat & [ HEAD noun & 
					      [ --BARE -,
						MINORS.ALTMIN 
						       non_freerel_q_rel ] ],
			    CONT #cont,
                            CONJ #conj,
                            CTXT #ctxt ],
                    NONLOC #nonloc,
		    --SIND #sind,
                    OPT #opt,
                    LEX #lex,
                    MODIFD #modifd,
                    PHON #phon,
                    PUNCT #punct & [ PNCTPR ppair,
 		                     RPUNCT pair_or_no_punct ] ],
    GENRE robust ].
                          
subjh_robust_3s_v_rule := subjh_robust_rule &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s,
    HD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG.PN 3s ] >,
    NH-DTR.SYNSEM.LOCAL.AGR.PNG.PN -3s ].

subjh_robust_n3s_v_rule := subjh_robust_rule &
  [ SYNSEM.LOCAL.AGR.PNG.PN -3s,
    HD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG.PN -3s ] >,
    NH-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3s ].

;; DPF 2017-09-06 - Robust rule with comma-marked subject
;;
subjh_mc_cma_rule := subjh_rule_decl & basic_head_subj_phrase & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verbal &
				[ VFORM fin,
                                  TAM indic_tam,
				  PRD -,
				  CASE non_nom ],
			   VAL.SPR *olist*,
                           MC + ],
                     CONT.HOOK [ INDEX.SF #pred ] ],
	     NONLOC.SLASH 0-dlist,
             PUNCT.RPUNCT.PSF #pred ],
   HD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #synsem >,
   NH-DTR.SYNSEM #synsem & [ PUNCT [ PNCTPR no_ppair,
                      	 	      RPUNCT comma_punct ] ],
   GENRE robust ].


;; Relax GENRE constraint so we can generate sentence-initial PPs without
;; commas.
;; DPF 17-10-04 - Let's stamp MODIFD lmod on mother to avoid these as right 
;; dtrs in run-on comma robust rule
;;
filler_head_rule_non_wh_infgen := filler_head_rule_non_wh &
  [ SYNSEM.MODIFD lmod,
    HD-DTR.SYNSEM.LEX -,
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD non_noun_or_adv &
				   [ MINORS [ MIN independent_rel,
				              ALTMIN non_ellipt_rel ] ],
		    PUNCT.RPUNCT no_punct ] ].


#|
;; For CoNLL, keep comma as separate token
pt_-_comma_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT comma_or_rbc_punct ].

pt_-_semicolon_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT basic_semicol_punct ].
|#

;; For erroneous VP passives of intransitives as in |the fish were died|
;; (Repair is to drop preceding copula)
v_-_psv-post_le_rbst := norm_basic_main_verb &
  [ SYNSEM passive_unerg_synsem &
	   [ LOCAL.CAT [ POSTHD + ] ],
    INFLECTD +,
    GENRE robust ].

;; For erroneous VP passives of intransitives used prenominally: |the died fish|
;; (Repair is to rephrase as relative clause: |the fish that died|)
v_-_psv-pre_le_rbst := norm_basic_main_verb &
  [ SYNSEM passive_unerg_synsem &
	   [ LOCAL.CAT [ POSTHD - ] ],
    INFLECTD +,
    GENRE robust ].

;; Block depictives headed by |being that ...|, to favor |human being| as item
v_cp_being_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

;; Block reduced relative |being that|, for same reason
;; DPF 16-01-13 - But this prevents pre-S modifiers, as in "being a cat, she 
;; complained."  So undo, and see if still need help in getting |human being|.
;;
#|
v_np_being_le :+
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST expressed_synsem ].
|#

;; Flag wrong double plurals: e.g. |polices|
n_-_c-pl_le_rbst := n_intr_infl_lex_entry &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
					       DIV + ] ] >,
		   CONT.HOOK.INDEX [ PNG.PN 3p,
				     DIV + ] ],
    GENRE robust ].

; Intransitive used as causative: |this deteriorates the problem|
v_np_caus_le_rbst := main_verb & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < canonical_synsem &
				   [ OPT -,
				     LOCAL.CAT.HEAD noun &
					 [ --BARE -,
					   CASE acc ],
				     PUNCT.RPUNCT clause_or_no_punct ] > ] ],
    GENRE robust ].

;; Ditransitives like `give' used as simple transitives
;; DPF 2017-09-27 - To prevent spurious robust analysis of
;; |Cathy handed a rock to Caleb|, restrict NP comp to notmod_or_lmod.
;;
v_np_ditrans_le_rbst := main_verb & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < [ --MIN non_idiom_nom_rel,
	                               MODIFD notmod_or_lmod,
	                               OPT - ] > ] ],
    GENRE robust ].

v_np_cp_le_rbst := main_verb & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < [ OPT - ] > ] ],
    GENRE robust ].

;; Double negation
;
av_-_s-not_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD negadv &
                       [ MOD < [ LOCAL.CAT [ HEAD verb_or_frag &
						  [ VFORM non_fin ],
                                             VAL.SUBJ < synsem_min > ],
				 --SIND.SF prop-or-ques ] > ] ] ].


adv_addition :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS [ FIRST.LOCAL.CAT.NEGPOL #negp,
                                 REST.FIRST.LOCAL.CAT.NEGPOL #negp ] ].

;; Change NEGPOL to -, where negation-sensitive elements are either + (marking
;; overt negation and hence not permissible in scope of negation), or - (marking
;; a polarity-sensitive element that needs to be in scope of negation or
;; similar polarity context).
;;
d_-_prt_le := pdet_word_nonque &
  [ SYNSEM.LOCAL.CAT.NEGPOL - ].

;; |do you have any more question?|
;; DPF 2017-09-23 - But prevent these from partitive rule, to avoid spurious
;; ambig. as in |cyborgs won the most|.
;;
d_-_prt-plm_le_rbst := det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ --MIN just_only_deg_rel,
                                     LEX + ] >,
                     AGR.DIV - ],
             LKEYS.KEYREL [ ARG0.DIV -,
			    PRED explicit_quant_agr_q_rel ],
             MODIFD hasmod ],
    GENRE robust ].

;; Stop trying to do neg-polarity hastily: was blocking e.g.
;; |we achieved nothing in our life|
#|
basic_unary_phrase :+
  [ SYNSEM.LOCAL.CAT.NEGPOL #negp,
    ARGS.FIRST.SYNSEM.LOCAL.CAT.NEGPOL #negp ].

basic_head_mod_phrase_simple :+
  [ SYNSEM.LOCAL.CAT.NEGPOL #negp,
    HD-DTR.SYNSEM.LOCAL.CAT.NEGPOL #hnegp,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.NEGPOL #hnegp,
                              NEGPOL #negp ] ].

np_coord_top_rule :+
  [ SYNSEM.LOCAL.CAT.NEGPOL #negp,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.NEGPOL #negp ].
|#

;; Removed [NEGPOL -] on mother.
bare_npq_phrase := norm_unary_phrase &
  [ INFLECTD #infl,
    SYNSEM synsem &
           [ LOCAL [ CAT [ HEAD #head,
                           HC-LEX #hclex,
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < synsem_min &
				       [ --MIN just_only_deg_rel,
                                         LOCAL [ CAT [ HEAD adv,
						       VAL.SPR *unexplist* ],
                                                 CONT.HOOK.LTOP #ltop ],
                                         OPT + ] >,
				 SPCMPS < > ],
                           MC na ],
                     AGR ref-ind &
                         [ PNG #png,
			   DIV #div ],
                     CONJ #conj,
		     CTXT #ctxt ],
             NONLOC #nonloc,
	     LEX #lex,
             MODIFD #modif & [ RPERIPH + ] ],
    ARGS < [ INFLECTD #infl,
	     SYNSEM 
             [ LOCAL [ CAT [ HEAD #head & partn,
                             HC-LEX #hclex,
                             VAL [ SUBJ *olist*,
                                   COMPS < >,
                                   SPR < unexpressed &
					 [ LOCAL.CONT.HOOK.LTOP #ltop,
					   NONLOC.QUE 0-dlist,
					   OPT - ], ... > ] ],
                       AGR [ PNG #png,
			     DIV #div ],
                       CONJ #conj & cnil,
                       CONT.HOOK [ INDEX #index,
				   XARG #xarg ],
		       CTXT #ctxt ],
               NONLOC #nonloc,
	       LEX #lex,
	       MODIFD #modif & [ RPERIPH na_or_+ ],
	       PUNCT.LPUNCT pair_or_no_punct ] ] >,
    C-CONT [ HOOK [ INDEX #index,
		    XARG #xarg ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; Since we're trying to do without robust commas, adjust the adj-N types

adj_n_int_phrase := adj_head_int_phrase &
  [ HD-DTR [ SYNSEM [ LOCAL.CAT [ HEAD basic_nom_or_ttl,
				  VAL [ SPR.FIRST 
					   [ LOCAL.CAT.HEAD.MINORS.MIN #min,
					     --MIN #min & quant_rel ],
					COMPS < > ] ],
		      PHON.ONSET #onset ],
	     INFLECTD #infl ],
    NH-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ PHON.ONSET #onset ] >,
				    VAL.SUBJ *synlist* ],
			      CONT.HOOK.INDEX event & 
			                      [ E [ TENSE no_tense,
			                            ASPECT [ PROGR bool,
							     PRF - ] ] ] ],
                      LEX +,
		      PUNCT.RPUNCT comma_or_rbc_or_hyphen_or_pair_or_no_punct ],
             INFLECTD + ],
    INFLECTD #infl ].

adj_n_phrase := adj_n_int_phrase &
  [ HD-DTR [ SYNSEM.MODIFD notmod_or_rmod,
	     INFLECTD bool ] ].

;; Since we're not using nonformal comma, change here
adj_adjn_phrase := adj_n_int_phrase &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.HEAD nom_or_ttl,
                    MODIFD lmod & [ LPERIPH na_or_-,
				    RPERIPH na_or_- ] ],
    NH-DTR.SYNSEM .PUNCT.RPUNCT comma_or_hyphen_or_pair_or_no_punct ].

;; Block pre-VP modif, as in |she had [[eaten before she] [had her dinner]]|
subconj_prdp_v_init_phrase := subconj_prdp_init_phr &
  [ SYNSEM.LOCAL.CAT [ POSTHD -,
		       HEAD.MOD.FIRST.LOCAL.CAT.VAL.SPR < > ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD verb & [ VFORM pas_or_prp ] ] > ].

;; Add subtypes of appos_rel so we can use paraphrase rule to reverse the
;; order of args to generate both |Kim the teacher| and |the teacher Kim|
appos_norm_rel := appos_rel.
appos_rev_rel := appos_rel.

;; Tried excluding |the eye of him|
;; but this also loses |the weight of it|, so don't
;p_np_i-nm-poss_lexent :+
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN basic_nonpro_rel ] > ].

;; DPF 2016-06-25 - Prevent robust 'he' from appearing in |K is taller than he|
p_np_ptcl-ngap_le :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.NORM norm_rel ].

;; DPF 2017-09-12 - Make complement COMPS < > , to avoid spurious robust parse
;; for |two of them ordered pumpkin pie|
;;
minute_prep_lr := basic_minute_lex_rule &
 [ SYNSEM minute_noun_wcomp_synsem &
          [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.VAL.COMPS < > ] ].

;; DPF 2017-05-17 - Allow comma or no punct, so we can detect run-ons such as
;; |I spotted a lizard it was awesome.|  
;; DPF 2017-08-09 - Re 2017-05-17: But this leads to several false positives
;; such as for |She brought pictures of her China trip.|  So require comma.
;; 
run_on_coord_comma_rule := basic_run_on_coord_rule &
 [ LCONJ-DTR.SYNSEM phr_synsem &
		    [ LOCAL.CAT.HEAD verb,
		      PUNCT.RPUNCT comma_punct ],
   RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD verb_or_conj-s,
                            CONJ cnil ],
   GENRE nonformal ].

;; DPF 2017-09-26 - Add ALTS feature to allow us to mark some robust lexemes
;; as lacking a comma, as in S-initial adv in |last we read the book|.
alts :+ [ CMA bool ].

punctuation_comma_rule :+
 [ ARGS < [ ALTS.CMA + ] > ].

;; DPF 2017-09-28 - Add ALTS feature to allow blocking of tense-matching
;; past-tense inflectional rule.
;;
alts :+ [ TNS-ID bool ].

;; DPF 2017-09-29 - Abuse the ALTS attribute here to allow blocking of certain
;; adjectives to avoid spurious use of the subord-adj-lex rule, as in
;; |There are five fifth graders between fifteen and twenty feet tall.|
;; DPF 2017-09-30 - But this won't work, since ALTS is not an attribute of
;; phrases, and adjectives with an optional complement have to first
;; undergo the optcomp rule, which loses ALTS.  So instead, make it a HEAD
;; feature of adj.

adj :+ [ --SBRD luk ].

;; Add --MAL3SG constraint (hack) to prevent spurious robust intrans in
;; |buys and sells books|
v_coord_phr :+
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.--MAL3SG - ].

;; |Morning is the best time of the day|
n_-_m-nocnh-nspr_le :+
  [ ALTS.PLMASS - ].

;; Add UNSP-TENSE - to mod, to prevent this rule from applying to coord of
;; mal-subord PPs, as in |we arise if we win or if we lose|
;; But we also use this rule for coordinating degree adverbs as in
;; |more and more confident|, where the MOD is empty. So undo.
;;
;pp_coord_top_phr :+
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.UNSP-TENSE + ].

;; Propagate UNSP-TENSE value from dtr to complementizer as in
;; |I wondered if I would win|
;;
basic_sor_compl_word :+
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.UNSP-TENSE #ut,
		       VAL.KCMP.LOCAL.CAT.HEAD.TAM.UNSP-TENSE #ut ] ].

;; DPF 2017-10-02 - Restrict CASE to acc to avoid |to long|
grad_n := partn_mobile & [ CASE acc ].

;; Avoid |I arrived, [[then I arose] ...]|
av_-_dc-like-po_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.MODIFD notmod_or_rmod ].

av_-_dg-jo_le :+
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAT.HEAD.--BARE - ].

n_pp_c-dir_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

;; |my favorite was the lions|
;; This is too strong, since it prevents robust analysis of |we admired old one|.
;;
;partn :+
;  [ --BARE - ].

;; Enable blocking of |with my friends fun|
subconj_with_synsem :+
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL.CAT.HEAD.MOD.FIRST.OPT + ] > ].

;; Needed for robust `neither' as in |neither brothers|
;;
_neither_q-agr_rel := explicit_quant_agr_q_rel & universal_q_rel.

;; Misspelled adj
aj_-_i_le_rbst := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel,
    GENRE robust ].

;; DPF 2018-02-20 - Default value of --SBRD is bool to prevent these as lexical
;; depictives: |*They arrived beautiful|
;;
aj_-_i_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    --SBRD bool ] ].

aj_pp_i_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    --SBRD bool ] ].

aj_pp_i-er_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS [ MIN norm_adj_rel,
				     ALTMIN comp_er_rel ],
			    --SBRD bool ] ].

;; Allow lexical depictives: |they arrived drunk|
aj_-_i-sbrd_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    --SBRD na ] ].

aj_pp_i-sbrd_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    --SBRD na ] ].

aj_pp_i-er-sbrd_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS [ MIN norm_adj_rel,
				     ALTMIN comp_er_rel ],
			    --SBRD na ] ].

; Block unwanted robust for |it smelled disgusting|
aj_-_i-prd_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.--SBRD - ].

;; Block |being|
intrans_nominal_gerund :+
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN non_ellipt_rel ].

;; Specialize pron_rel
_i_n_pron_rel := pron_rel.
_you_n_pron_rel := pron_rel.
_he_n_pron_rel := pron_rel.
_she_n_pron_rel := pron_rel.
_he-she_n_pron_rel := pron_rel.
_it_n_pron_rel := pron_rel.
_we_n_pron_rel := pron_rel.
_they_n_pron_rel := pron_rel.

n_-_pr-he_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-he_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-her_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-hers_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-him-her_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he-she_n_pron_rel ].
n_-_pr-hers-his_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he-she_n_pron_rel ].
n_-_pr-herself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-him_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-himself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-his_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-i_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-i_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-it_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _it_n_pron_rel ].
n_-_pr-it_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _it_n_pron_rel ].
n_-_pr-itself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _it_n_pron_rel ].
n_-_pr-me_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-mine_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-myself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-ours_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].
n_-_pr-ourslves_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].
n_-_pr-she_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-she_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-theirs_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-them_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-themself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-themslves_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-they_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-they_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-you_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].
n_-_pr-you_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].
n_-_pr-yours_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].
n_-_pr-yourself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].
n_-_pr-yourslves_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].
n_-_pr-we_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].
n_-_pr-we_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].

n_-_pr-i-me_le_mal := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.CASE no_case,
			 VAL.SPR < [ --MIN no_rel ] > ],
	     MODIFD.RPERIPH +,
	     LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
				 DIV -,
				 PT std ] ] ].

;; Block as subconj_prd, as in |we arrived felt boring|, both for normal rule
;; and for robust one.  But can't make these NORM no_rel, since the copula
;; wants NORM norm_rel.
;;
aj_-_i-spobl_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.--SBRD - ].

;; Block partitives with robust 3sg verb rule, since number on partitives is
;; often underspecified.
;;
basic_part_constr :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].
;; And the same for possessive pronouns including "his".
n_poss_pro_lexent :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

;; DPF 2018-03-16 - Add --VNEG bool to enable notice of negated VPs, so we can
;; for example block |he can not leave| in the intended sense.
verbal :+
  [ --VNEG bool ].

robust_nom_rel := nom_rel.
;; DPF 2018-03-16 - Add type for adjectives used as count nouns:
;; |fishing is a fun for me|
n_-_c-adj_le_rbst := basic_intr_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN robust_nom_rel,
    GENRE robust ].

;; |the fifty words composition|
;;
noun_n_cmpnd_mnp_mal_rule := binary_rule_right_to_left & 
			     basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM abstr_lex_synsem & 
		  [ MODIFD notmod_or_lmod,
		    PUNCT.LPUNCT dq_or_no_punct ],
    NH-DTR [ INFLECTD +,
	     SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN meas_nom_rel,
					   --BARE - ],
				    VAL.SPR.FIRST.OPT - ],
			      CONT.HOOK.INDEX nonconj_ref-ind & [ PNG.PN 3p ] ],
		      MODIFD notmod_or_lmod,
		      PUNCT.RPUNCT rbc_or_hyphen_or_pair_or_no_punct ] ],
   GENRE robust ].

;; Predicative adj used attributively
;;
aj_-_i-att_le_rbst := reg_adj_word &
  [ SYNSEM basic_attr_adj_synsem,
    GENRE robust ].

;; |important anything|
;; Need RPERIPH + to avoid in |mixed everything together in ...|
;; And added HS-LEX + to prevent robust |something arose| while still getting
;; robust |important something arose|.
;;
n_-_m-mod_le_rbst := basic_noun_word &
  [ INFLECTD +,
    SYNSEM basic_unsp_common_noun_synsem &
	   [ LOCAL [ CAT [ HEAD noun &
				[ MINORS [ MIN norm_nom_rel,
					   NORM norm_rel ],
				  MOD < > ],
			   VAL [ SPR.FIRST unexpressed,
				 SUBJ < >,
				 COMPS < > ],
			   MC na,
			   HS-LEX + ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #agr & [ PNG png & [ PN 3s ],
						  DIV +,
						  IND - ] ],
			    RELS <! reg_nom_relation & [ LBL #ltop ]  !>,
			    HCONS <! !>, ICONS <! !> ],
		     CONJ cnil,
		     AGR #agr ],
	     NONLOC non-local_none,
	     MODIFD notmod & [ RPERIPH + ] ],
    GENRE robust ].

; |Kim is very taller|
av_-_dg-m_le_rbst := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
		       VAL.SPEC.FIRST.LOCAL.CAT.HEAD basic_adj ],
    GENRE robust ].

; |Kim is much happy|
av_-_dg-v_le_rbst := av_-_dg-v_lexent &
  [ GENRE robust ].

; |We went to Olympics|
n_-_c-nm-pl_le_rbst := n_intr_named_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.NORM norm_rel,
			   VAL.SPR.FIRST unexpressed ],
		     CONT.HOOK.INDEX.PNG.PN 3p ],
	     PUNCT no_punctuation_min ],
    GENRE robust ].

;; |ten times as larger|
;; Let's restrict this to predicative APs for now, to avoid spurious coord as
;; in |bigger and prettier house|
lex_rule_compar_equative := lex_rule_basic & word_or_infl_rule &
  [ ORTH #orth,
    INFLECTD +,
    KEY-ARG #keyarg,   
    SYNSEM [ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN comp_er_rel,
					MOD #mod,
					PRD + ],
			   VAL [ SPR < synsem &
					   [ --MIN comp_as_too_degree_rel,
					     OPT -,
					     LOCAL.CAT.VAL.SPR *olist* ] >,
			         SUBJ #subj,
			         COMPS < >,
			         SPEC #spec ] ],
		     CONT #cont,
		     CONJ #conj,
		     CTXT #ctxt,
		     AGR #agr,
		     ARG-S #arg-s ],
	     NONLOC #nonloc,
	     OPT #opt,
	     --MIN #min,
	     --SIND #sind,
	     LEX #lex,
	     MODIFD #modifd,
	     PHON #phon,
	     PUNCT #punct,
	     LKEYS #lkeys ],
    ARGS < #dtr >,
    DTR #dtr & [ ORTh #orth,
		 KEY-ARG #keyarg,   
		 SYNSEM [ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN comp_rel,
						     MOD #mod ],
					VAL [ SPR.FIRST [ OPT +,
							  --MIN much_deg_rel ],
					      SUBJ #subj,
					      SPEC #spec,
					      COMPS.FIRST.--MIN 
						     _than_p_compar_rel ] ],
				  CONT #cont,
				  CONJ #conj,
				  CTXT #ctxt,
				  AGR #agr,
				  ARG-S #arg-s ],
			  NONLOC #nonloc,
			  OPT #opt,
			  --MIN #min,
			  --SIND #sind,
			  LEX #lex,
			  MODIFD #modifd,
			  PHON #phon,
			  PUNCT #punct,
			  LKEYS #lkeys ] ],
    C-CONT.RELS <! !>,
    GENRE robust ].

av_pp_dg-as_le_rbst := que_word &
  [ SYNSEM as_degree_spec_synsem,
    GENRE robust ].

;; Block det to avoid spurious analysis for |such much rice|
;;
aj_-_i-much_lexent := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ AGR [ PNG.PN 3s,
						DIV + ],
					  CAT.VAL.SPR.FIRST unexpressed ] ] > ].

;; |we ran one and a half mile|
aj_np_i-frct-one_le_rbst := aj_np_i-frct-one_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.AGR.PNG.PN 3s,
    GENRE robust ].

;; |we would rather take a train than went by bus|
vp_coord_asym_top_phr_mal := basic_v_coord_phr & basic_top_coord_event_rule &
			     top_coord_rule & xp_coord_phr & verbal_coord_phr &
  [ SYNSEM.LOCAL [ CAT.HEAD.VFORM non_fin,
		   AGR.PNG #png ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ VFORM non_fin,
				      PRD - ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD [ VFORM fin,
					AUX -,
					PRD -,
					--MALN3SG - ],
			     AGR.PNG #png ],

   C-CONT.RELS <! !>,
   GENRE robust ].

;; |it is sure that we will win|
aj_pp-cp_i-it_le_rbst := reg_adj_atrans_cp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
    GENRE robust ].

c_-_so-on_le_rbst := et_conj_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _so+on_c_rel,
				ARG1 conj-ind ] !>,
    GENRE robust ].

;; block |[and so] on|
conj_mod_int_phrase :+
  [ NH-DTR.SYNSEM.MODIFD notmod ].

_place_a_sel_rel := selected_adj_rel.

;; Use for |by (the) bus/car/train|
transport_sort := nontime.

n_-_c-transp_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL.ARG0.SORT transport_sort ] ].

n_pp_c-of-transp_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN diadic_nom_rel,
		     CONT.HOOK.INDEX.SORT transport_sort ],
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

;; Prevent robust analysis of |they are warm-blooded, not cold-blooded|
n-adj_phrase :+
  [ SYNSEM.LOCAL.CAT.HEAD.--SBRD na ].