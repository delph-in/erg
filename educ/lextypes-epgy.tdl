; Block proper names from taking determiners

_the_q_prop_rel := proper_q_rel.
mal_bare_div_q_rel := implicit_q_rel.

norm_n_proper_lexent := reg_n_proper_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED named_rel,
    	     LOCAL.CAT.VAL.SPR < [ --MIN _the_q_prop_rel ] > ],
    INFLECTD - ].

;; Assign default neut gender to avoid spurious paraphrases
n_-_c_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_-_c-fem_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN fem ].

n_-_c-msc_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN masc ].

;; child, puppy
n_-_c-ugen_le := n_intr_lex_entry.

;; night
n_-_c-dpt-df-sg_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

n_pp_c-of_lexent := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

n_pp_c-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

n_pp_c-ns-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

; teacher
n_pp_c-of-anim_le := n_pp_c-of_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN animate ].

;; sister
n_pp_c-of-fem_le := n_pp_c-of_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN fem ].

;; brother
n_pp_c-of-msc_le := n_pp_c-of_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN masc ].

n_-_c-ed_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_-_mc-ed_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_pp_mc-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_-_mc_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

; Also hour names
;; DPF 2016-06-25 - Motive for this redef not clear.
;;
n_-_pn-hour_le := abstr_hour_word &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < unexpressed >,
                             COMPS < #kcmp >,
			     KCMP #kcmp ],
             LEX - ] ].

n_-_m-def_le_mal :=  n_-_m-def_lexent &
  [ GENRE robust ].

;; Enable paraphrase of |in the summer| as |in summer|, where latter undergoes
;; the mass infl rule which stamps [GEN neut] on.
;;
n_-_m-ssn-spr_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

; Considered blocking days of week from appearing as NP-adv
; but conflict between Strand3.C and sentencelist.C:
; "*Jenny plays chess Tuesday." but "She goes Saturdays."
;
;n_-_c-day_lexent := basic_n_intr_temp_lexent &
;  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN dofw_rel,
;                                       ALTMIN quant_or_wh_rel ],
;                         VAL.SPR < synsem > ],
;             MODIFD notmod,
;             LKEYS.ALTKEYREL.PRED quant_or_wh_rel ] ].

; Special class for "Mr." etc, since we exclude normal nouns as titles
n_-_c-pre-ttl_le := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD [ MINORS [ MIN pre_title_rel,
                              	         NORM norm_rel ],
                                --BARE - ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

;; For wrong prep, as in |the reason of the mistake|
;;
n_pp_c_le_rbst := n_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
		   CONT [ RELS <! relation !>,
			  HCONS <! !> ] ],
    GENRE robust ].

n_pp_m_le_rbst := noun_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
           [ LOCAL [ CAT [ HEAD.--MALCM -,
			   VAL.COMPS < [ OPT - ] > ],
	   	     CONT [ RELS <! relation !>,
			    HCONS <! !> ] ],
             MODIFD notmod ],
    GENRE robust ].

;; Block robust regular plural rule for nouns like |people|
;; 
n_pp_c-pl_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT.RELS <! reg_diadic_nom_relation !>,
		   AGR.PNG png-irreg ] ].

;; Allow nouns to decline the robust a/an + mass-noun rule
noun :+ [ --MALCM bool ].

d_-_sg-nmd-mal_le := basic_det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_unk ] >,
    GENRE robust ].

; "an information", "a homework"
d_-_m-c_mal_lexent := det_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                           VAL.SPEC < [ LOCAL.CAT.HEAD [ --BARE +,
							 --MALCM + ] ] > ],
                     AGR [ PNG.PN 3s,
		           DIV + ] ],
             NONLOC.QUE 0-dlist ],
    GENRE robust ].

d_-_m-c-mal-a_le := d_-_m-c_mal_lexent &
 [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con ] > ].

d_-_m-c-mal-an_le := d_-_m-c_mal_lexent &
 [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc ] > ].

adj_equi_bse_rbst_synsem := basic_adj_equi_synsem & 
  [ LOCAL [ CAT [ HEAD adj,
		  VAL [ SPR.FIRST synsem &
				  [ --MIN more_or_very_deg_rel,
				    LOCAL.CAT.HS-LEX #hslex ],
			COMPS < [ LOCAL [ CAT.HEAD.VFORM bse,
					  CONT [ HOOK.LTOP #vhand ] ] ] > ],
		  HS-LEX #hslex ],
	    CONT [ RELS <! adj_relation !>,
		   HCONS <! qeq & [ HARG #hand,
				    LARG #vhand ] !> ] ],
    MODIFD notmod,
    LKEYS.KEYREL.ARG2 handle & #hand ].

adj_vp_bse_mal_lr := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM reg_adj_equi_synsem &
	         [ LOCAL [ CAT [ HEAD #head,
				 VAL [ SUBJ #subj,
				       SPR #spr,
				       SPCMPS #spcmps ] ],
                           CTXT #ctxt ],
		   NONLOC #non-local,
		   MODIFD #modif ] ],
    SYNSEM adj_equi_bse_rbst_synsem &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL [ SUBJ #subj,
				SPR #spr,
				SPCMPS #spcmps ] ],
		    CTXT #ctxt ],
	    NONLOC #non-local,
	    MODIFD #modif ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    GENRE robust ].

;; Block noun-noun compounds such as |movie five times|
;;
adj_bare_unspecified_card_lexent := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM.MODIFD.LPERIPH bool ].

; Remove COMPS..--BARE - since we want to flag "She is good student"
;; DPF 2015-04-22 - Add unif of PNG.PN for subj and comp, to block spurious
;; analysis of |they are late school|.  We'll also have to make adjustment to
;; group nouns like "team" so their INDEX.PNG.PN can be either sg or pl, even
;; though AGR..PN is 3s.
;; DPF 2016-07-15 - Re 2015-04-22: But this also blocks |these trips are a
;; good excuse to avoid work|.  So let's try matching AGR..IND instead, and 
;; adjust lexical entries for `idea, excuse, suggestion' etc so their INDEX..IND
;; is distinct from AGR..IND.
;; DPF 2016-12-02 - Re 2016-07-15: But this blocks |my favorite subject is math|
;; so let's give up on fiddling with PN or IND identity, and instead notice that
;; the problem is with modification of |school| here, since we also want to
;; block |*Kim attends good school|.  
;; DPF 2017-05-17 - Block extraction to avoid spurious analysis for e.g.
;; |I spotted a lizard it was awesome|
;; DPF 2017-08-17 - Re 2017-05-17: But this blocks use of identity copula in
;; relative clauses, as in |the student who is the president|.  So instead
;; constrain the complement's SLASH.
;;
be_id := be_verb &
  [ SYNSEM aux_np_verb &
     [ LOCAL [ CONT [ HOOK.INDEX #event,
		      RELS.LIST.FIRST.ARG0 #event ],
	       CAT [ VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
			   COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop,
			             NONLOC.SLASH 0-dlist ] > ] ] ],
       LKEYS.KEYREL [ LBL #ltop,
		      PRED _be_v_id_rel ] ] ].

; From auxverbs - Restrict number on COMPS for singular identity copula.
; Also prevent bare-sg NP subjects
;; DPF 13-03-14 - But blocking bare subjs prevents robust analysis of e.g.
;; |cat is a furry animal|  So remove, and let's see what happens.
be_id_pos := be_id &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.TAM.ASPECT.PROGR - ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

;; Undo this 3s constraint since we want e.g. |the population is 4 million|
#|
v_np_is_le := be_is_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3s ] > ].
|#
v_np_is_le := be_is_lex_entry & be_id_pos.

;; Remove GENRE nonformal so we can generate contracted forms even with
;; root_strict.  Also constrain COMPS.FIRST to canonical_synsem so we avoid
;; generating stranded contractions like |Here he's|, even though this also
;; means we won't generate |Where's Kim?|.
;;
contracted_aux_word := word &
  [ INFLECTD na,
    ALTS [ VPELLIP -,
           SQPNCT -,
	   CSAI - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST canonical_synsem ].

; Add COMPS..--BARE - here to avoid spurious analysis for e.g.
; |the team's goalie kept running|
v_np_is-cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.--BARE -,
					   AGR.PNG.PN 3s ] ] > ].

v_np_are_le := be_are_lex_entry & be_id_pos.

v_np_are-cx_le := be_are_lex_entry & be_id_pos & contracted_aux_word.

v_np_was_le := be_was_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3s ] > ].

v_np_wre_le := be_were_lex_entry & be_id_pos.

;; Avoid misanalysis in possessive NPs such as |in the cat 's mouth|
;;
basic_loc_inv_be_word := loc_inv_verb_word &
  [ INFLECTD +,
    SYNSEM loc_inv_be_synsem &
	     [ LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CAT.HEAD.--BARE - ] ] ].

;; Block APs as subjects
;;
loc_inv_be_word := basic_loc_inv_be_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD -,
				  TAM.MOOD indicative ],
			   VAL [ SUBJ < [ LOCAL [ CAT.HEAD v_or_p,
			                        CONT.HOOK [ LTOP #ltop,
                                                          INDEX #ind &
                                                             [ E.TENSE tense ],
                                                          XARG #xarg ] ] ] >,
				 COMPS < [ --SIND #xarg ] > ],
			   POSTHD - ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #ind & [ SF prop-or-ques ],
				   XARG #xarg ],
			    RELS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

; From syntax.tdl

;; Restrict nonhead to MIN pre_title_rel.
;;
np_title_cmpnd_phr := basic_np_title_cmpnd_phr &
  [ HD-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR < [ OPT - ] >,
			  CONT.HOOK [ LTOP #lbl,
			              INDEX.PNG.GEN #gen ] ],
    NH-DTR.SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN pre_title_rel,
    			  CONT.HOOK.INDEX.PNG.GEN #gen ],
    C-CONT.RELS.LIST.FIRST.LBL #lbl ].


; Exclude reflesives as non-heads: |*They themselves|
;; DPF 2014-01-21 - But now we want to allow these, in Grade 7.
#|
basic_appos_np_phr := norm_appos_phr &
  [ HD-DTR.SYNSEM.MODIFD.RPERIPH bool,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN nonpro_rel,
			      VAL.SPR *olist* ],
    C-CONT [ RELS <! relation !>,
             HCONS <! !> ] ].
|#


;; Block "a Sunday" but allow "next Tuesday"
;; Note that this blocks items in StrandG_2-4 such as
;; "The fair is on a Saturday."
;; So maybe reconsider?
;; Yes, undo, since we also want "on the last Tuesday in May"
;;
;;n_-_c-dow_le := n_-_c-day_lexent &
;;  [ SYNSEM [ LKEYS.KEYREL.PRED dofw_rel,
;;             LOCAL.CAT.VAL.SPR < [ --MIN impl_or_proper_q_rel ] > ] ].

; Block clefts:
; But this also blocks |It is after the sun goes down|
#|
be_nv := be_verb &
  [ SYNSEM nv_cop_verb &
	   [ LOCAL.CONT [ HOOK.INDEX #event,
			  RELS.LIST.FIRST.ARG0 #event ] ],
    ALTS.VPELLIP -,
    GENRE robust ].
|#

; Add feature for blocking mal-3sg and mal-n3sg
;
vc_add :+ [ --MAL3SG bool,
            --MALN3SG bool ].

; Change CASE from obliq to non_obliq to block "to home"
n_-_ad-pl-nomod_le := norm_np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
				CASE non_obliq,
				--BARE - ],
		     CONT.HOOK.INDEX [ SORT place,
				       PNG.GEN neut ] ],
	     MODIFD.RPERIPH + ] ].

; Block as direct objects, to avoid spurious reading for e.g.
; "What was he doing yesterday?"
n_-_ad-time_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN time_n_rel,
                              CASE nom_or_obliq ],
                   CONT.HOOK.INDEX.SORT time ] ].

; Related: relax constraint on complement of `from' to still get `from now on'
p_np-ptcl_i_le := p_ditrans_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT nomp_cat_nonnom_min,
                                             CONT.HOOK.INDEX index ] ],
                                   [ LOCAL [ CAT.VAL.COMPS < synsem >,
                                             CONT.HOOK.LTOP #ltop ],
                                     NONLOC non-local_none,
                                     LEX + ] >,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! relation !>,
                          HCONS <! !> ] ] ].



; Restrict normal transitives missing object to --MAL3SG + to prevent
; these from appearing in conjoined verb phrases, avoiding spurious ambiguity
; for e.g. "Kim buys and sells books"
; DPF 19-feb-10 - Also constrain to SLASH 0-dlist, to avoid mis-analysis for
; e.g. `Mark brought the [cookies he made for] his class.'
; DPF 19-apr-10 - --COMPKEY is hack to prevent attrib-adj LR, as in 
; "Mariah is making pasta"
v_-_le_rbst := main_verb & 
  [ SYNSEM unerg_verb &
           [ LOCAL.CAT.HEAD [ --MAL3SG + ],
	     NONLOC.SLASH 0-dlist,
	     LKEYS.--COMPKEY selected_rel ],
    GENRE robust ].

;; DPF 2017-04-03 - Added COMPS..MOD..MODIFD.RPERIPH constraint to prevent 
;; robust analysis of |the milk went bad|.
;;
v_adv_le := norm_basic_main_verb &
  [ SYNSEM adv_verb & 
      [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MOD.FIRST.MODIFD.RPERIPH + ],
    INFLECTD - ].

; e.g. 'tell'
; Exclude robust 3sg in CP complement, to avoid competing treatment for e.g.
; `she told her brother borrow her book'.
v_cp_le_rbst := main_verb & 
  [ SYNSEM cp_intrans_verb &
           [ LOCAL.CAT [ VAL.COMPS < [ LOCAL.CAT.HEAD.--MAL3SG -,
				       NONLOC.SLASH 0-dlist ] > ] ],
    GENRE robust ].

; e.g. 'tell him borrow her book'
v_np-vp_bse_le_rbst := main_verb_mliszt & 
  [ SYNSEM obj_equi_bse_verb,
    GENRE robust ].

; e.g. `This lets the cat to enter'
v_np-vp_oeq_le_rbst := main_verb & 
  [ SYNSEM obj_equi_verb,
    GENRE robust ].

; 'She enables to win.'
; Missing direct object
;
v_vp_seq_le_rbst := main_verb & 
  [ SYNSEM subj_equi_verb,
    GENRE robust ].

; (ERB 2003-10-23) For subject equi verbs, with the infinitival
; marker "to" dropped

; 'She wants win.'
v_vp_seq-bse_le_rbst := main_verb_mliszt & 
  [ SYNSEM subj_equi_bse_verb,
    GENRE robust ].

ssr_bse_verb := verb_synsem & ssr_subst & bse_intrans_subst & basic_two_arg &
  [ LOCAL [ CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		      KCMP.LOCAL.CONT.HOOK [ LTOP #chand ] ],
	    CONT [ HOOK [ LTOP #ltop ],
		   RELS <! #keyrel !>,
		   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg1_relation & #keyrel & [ ARG1 handle & #arghand ] ].

ssr_bse_noimp_verb := ssr_bse_verb & 
  [ LOCAL.CAT.HEAD.VFORM fin_or_non_fin ].

;; Missing |to| for raising: |they tend win.|
v_vp_ssr-nimp_le_rbst := main_verb & 
  [ SYNSEM ssr_bse_noimp_verb,
    GENRE robust ].


; 'ask' - block dative shift
v_np-np*_nodat_le := main_verb & 
  [ SYNSEM ditrans_only_verb & 
	   [ LOCAL.CAT [ VAL.COMPS < [ OPT - ], [ OPT + ] > ] ] ].

; `like' - block bare-sg objects:
; |I didn't like tadpole hunting|
v_np-prd_oeq-ntr-x_le := main_verb_mliszt & 
  [ SYNSEM obj_equi_non_trans_prd_verb &
	   [ LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CAT.HEAD.--BARE - ],
	     LKEYS [ --OCOMPKEY #ocmin,
                     --+OCOMPKEY #ocmin ] ] ].

; Restrict dtrs to --MAL3SG - to avoid robust intranstives as conjuncts.
;; DPF 13-03-14 - But this blocks flagging of subj-verb agrmt errors as in 
;; |he arise and arrives|.  So remove, and hope for better parse ranking.
#|
basic_v_coord_phr := basic_verbal_coord_phr &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                MINORS #mins,
                                --ADDIN #addin ],
                         VAL [ SUBJ < synsem &
				    [ LOCAL [ CAT #cat,
					      AGR #agr ],
				      NONLOC #nonloc,
				      --SIND #sind,
				      OPT #opt ] >,
			       SPR #spr ] ],
		   CONT.HOOK.XARG #xarg ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                          TAM.MOOD #mood,
                                          --ADDIN #addin & [ ADDPN #pn ],
					  --MAL3SG - ],
                                   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						OPT #opt ] >,
					 SPR #spr ] ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                          TAM.MOOD #mood,
                                          MINORS #mins,
					  --ADDIN.ADDPN #pn,
					  --MAL3SG - ],
				   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						OPT #opt ] >,
					 SPR #spr ] ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    C-CONT.HCONS <! !> ].
|#

;; Allow robust pre-modifiers like 'today'

av_-_i-vp-pr_le_rbst := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                    MOD < [ LOCAL.CAT.HEAD verb &
				                           [ VFORM fin ],
                                            MODIFD.LPERIPH na_or_- ] > ],
                       POSTHD - ],
    GENRE robust ].

; Allow robust post-VP adverbs: "He sang bad"
;
av_-_i-vp-po_le_rbst := int_vp_adverb_word & 
  [ SYNSEM [ LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                      MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                              MODIFD.RPERIPH na_or_- ] > ],
                         POSTHD + ],
             MODIFD hasmod ],
    GENRE robust ].

; restrict to only VP mods
av_-_i-vp-po-nmb_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob & 
                            [ MINORS.MIN adv_rel,
                              MOD < [ LOCAL.CAT.HEAD verb,
                                      MODIFD.RPERIPH na_or_- ] > ],
                       POSTHD + ] ].

;; Allow robust comparative specifier with comparative adverb: |more faster|
;;
av_-_i-vp-cmp_le_rbst := basic_adverb_word &
  [ SYNSEM intersect_vp_adverb_synsem &
           [ LOCAL.CAT [ VAL.SPR.FIRST [ --MIN more_deg_rel,
					 OPT - ],
			 POSTHD + ] ],
    GENRE robust ].

;; Same for comparative adjectives: |more shorter|

aj_-_i-cmp_le_rbst := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
		       VAL.SPR.FIRST expressed_synsem &
				     [ --MIN more_deg_rel ] ],
    GENRE robust ].

;; Make COMPS..HEAD be reg_adv to allow |he did well|
;;
adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
			    [ LOCAL 
			      [ CAT [ HEAD reg_adv &
                                       [ MOD < [ LOCAL intersective_mod ] > ],
                                      VAL [ SPR *olist*,
                                            COMPS < > ],
				      POSTHD + ],
                                CONT.HOOK [ LTOP #hand,
                                            INDEX #event ] ],
                              NONLOC.REL 0-dlist,
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

;; Allow no punct on left dtr

np_city_state_phr := norm_np_name_cmpnd_phr &
  [ HD-DTR.SYNSEM [ MODIFD notmod & [ LPERIPH + ],
		    LOCAL.CAT [ HEAD.MINORS.MIN named_np_or_num_rel,
				VAL.SPR < [ OPT - ] > ] ],
    NH-DTR.SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN named_city_rel,
					      NORM norm_rel ],
			    AGR.PNG.PN 3s ],
                    PUNCT [ LPUNCT no_punct,
			    RPUNCT comma_or_no_punct ] ],
    C-CONT.RELS <! [ PRED compound_rel ], [ PRED proper_q_rel ] !> ].

d_-_the-mal_le := d_-_the_lexent &
  [ GENRE robust ].

;; Add rels for lexicalized adverb phrases
_at+home_p_rel := miscprep_rel.
_to+bed_p_rel := miscprep_rel.
_out+of+bed_p_rel := miscprep_rel.
_day+to+day_p_rel := miscprep_rel.
_day+by+day_p_rel := miscprep_rel.
_during+break_p_rel := miscprep_rel.
_above+ground_p_rel := miscprep_rel.
_face+to+face_p_rel := miscprep_rel.


;; Add hack empty rel for "mop clean the floor"
_clean_a_sel_rel := selected_adj_rel.

;; Constrain to non-nominative, to avoid spurious analysis of e.g.
;; "what do Kim and Abrams ..."

n_-_pr-fr_le := n_freerel_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE non_nom,
                   CONT.RELS.LIST.FIRST.PRED free_relative_q_rel,
		   AGR.PNG.PN 3s ] ].

;; Constrain "what" to singular, to avoid spurious analysis of 
;; "what do Kim and Abrams ..."
n_-_pr-wh_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s ].

p_np_ptcl-of_le := p_prtcl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.--BARE - ] > ].

; Prevent analysis for "with her cousins"
p_np-np_s-ncop_le := noncqrs-nab &
  [ SYNSEM subconj_with_np_np_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN #pn ],
	                           [ LOCAL.AGR.PNG.PN #pn ] > ] ].

mal_v_inf_cp_comp_le := main_verb_mliszt &
   [ SYNSEM mal_v_inf_cp_comp_verb &
       [ LOCAL.CAT [ VAL.COMPS < [ OPT - ] > ] ],
     GENRE robust ].

mal_va_does_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN 3s ] ] >,
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

va_doesnt_neg_pres_le_rbst := do_aux_neg_pres & 
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ.FIRST.LOCAL.CAT.HEAD.--BARE +,
                   AGR.PNG png & [ PN 3s ] ],
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

va_dont_neg_pres_le_rbst := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ],
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

mal_va_do_fin_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN -3s ] ] >,
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

mal_va_has_le := has_aux_lex_ent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_va_have_fin_le := have_fin_aux_lex_ent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

v_vp_has-n_le_rbst := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL [ AGR.PNG.PN -3s,
            	   CAT.VAL.COMPS.FIRST expressed_synsem ],
    ALTS.VPELLIP -,
    GENRE robust ].

v_vp_have-f-n_le_rbst := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3s,
             	   CAT.VAL.COMPS.FIRST expressed_synsem ],
    ALTS.VPELLIP -,
    GENRE robust ].

#|
mal_vc_there_synsem := there_cop_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST expressed_synsem &
                              [ LOCAL.CAT.HEAD.MINORS 
					      [ MIN non_temp_nom_rel,
					        ALTMIN def_udef_some_a_no_q_rel,
						NORM no_rel ] ] ].
|#
;; Restricted COMPS..MIN from non_temp_nom_rel to norm_nom_rel in order to
;; exclude numbers as in |there are eight|
;;
mal_vc_there_synsem := there_cop_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST expressed_synsem &
                              [ LOCAL.CAT.HEAD.MINORS 
					      [ MIN norm_nom_rel,
					        ALTMIN def_udef_some_a_no_q_rel,
						NORM no_rel ] ] ].

mal_vc_there_is_le := vc_there_are_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem ].

mal_vc_there_are_le := vc_there_is_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem ].

mal_vc_there_was_le := vc_there_were_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem ].

mal_vc_there_were_le := vc_there_was_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem &
	  [ LOCAL.CAT.HEAD.--MAL3SG + ] ].

v_np-xp_is-n_le_rbst := be_are_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

v_np-xp_are-n_le_rbst := be_is_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

v_np-xp_was-n_le_rbst := be_were_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

v_np-xp_were-n_le_rbst := be_was_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

;; DPF 2012-08-17 - Removed SLASH 0-dlist from SUBJ for these, since we
;; want |the bear who are admired|.  Maybe we'll recall why this was added.

mal_vc_prd_is_le := vc_prd_are_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST expressed_synsem & 
                                    [ LOCAL.AGR.PNG.PN 3p ],
    GENRE robust ].

;; Added SUBJ..MIN norm_nom_rel to avoid use in |three are on the table|
mal_vc_prd_are_le := vc_prd_is_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
                                            AGR.PNG.PN sg ],
    GENRE robust ].

mal_vc_prd_was_le := vc_prd_were_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.AGR.PNG.PN 3p,
    GENRE robust ].

mal_vc_prd_were_le := vc_prd_was_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT [ HEAD.--MAL3SG +,
                       VAL.SUBJ.FIRST.LOCAL.AGR.PNG.PN sg ],
    GENRE robust ].

; Treat robust "be" and "been" as VFORM prp, so they trigger the robust
; subj-head rule which needs to avoid allowing ordinary base form verbs
; (identical to non-3sg) and ordinary past participles (identical to 
; past tense).
mal_vc_prd_be_le := vc_prd_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_np_be_le := vc_np_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_prd_been_le := vc_prd_been_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_np_been_le := vc_np_been_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

#|
;; Not used
mal_det_div_le := det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.MIN
                                                     just_only_deg_rel ] >,
                     AGR.PNG.PN 3s ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s ],
                                 DIV + ],
	     MODIFD hasmod ],
    GENRE robust ].
|#

; 'they/that'
#|
mal_n_deictic_pro_le := n_deictic_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p,
                                           GEN neut ] ] ].
|#

mal_det_pl_le := det_pl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAt.HEAD.--BARE -,
    GENRE robust ].

mal_n_plur_ppcomp_le := n_plur_ppcomp_lexent &
  [ GENRE robust ].

; (ERB 2003-10-17) For verbs like "allow" taking a CP[to]
; complement with the PRO bound to arbitrary reference.  Regenerate
; with gerunds instead.  (Might need another class where we
; regenerate with an inserted pronoun "one", if there are verbs
; that show up in this pattern but can't take gerund complements.)

; (ERB 2003-10-17) This is going to be a fairly strange verb type.  I
; can't think of any true English verbs off hand that take an
; infinitival CP complement and allow arbitrary control of the subject
; of that complement.  Furthermore, this type is also putting in some
; extra semantics, in order to allow the right string to come back
; from the generator.  So, we're not inheriting from the usual places
; in the hierarchy.  For example, main_verb is constrained to have a
; single element RELSs list.  main_verb_mliszt will do, though,
; although this isn't what it was intended for. Likewise, I don't
; think any of the linking types lower in the hierarchy will do what
; we want.  Took some constraints from subj_equi_inf_lt to try to
; restrict what can show up as the complement.

; (ERB 2003-10-23) Can't currently generate with these entries,
; and I don't know why.  Can generate from the produced MRS at all,
; in fact.  The MRS produced isn't the same as the MRS for the target,
; because of gerunds are built from progressives and therefore have
; a different value for PROGR.  (There are some other mismatches,
; but they are compatible, so maybe it would work otherwise.)
; While we might consider changing the analysis of gerunds, I
; think the main conclusion to draw is that we will need some kind
; of a transfer component.  Maybe put everything there rather than
; trying to map from mal-formed syntax to well-formed semantics in
; the grammar itself?  If not everything, how to decide when to do
; which?

mal_v_inf_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & basic_two_arg & 
			  norm_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  abstract_quant_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].
	   
#|
mal_v_inf_from_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & 
			       basic_two_arg & norm_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  abstract_quant_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].
|#

_they+that_q_mal_rel :< demonstrative_q_rel.

;; Mal NI (but not CE) rules, for lack of do support:

mal_adv_addition := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.AUX - ].

mal_sai_synsem := basic_sai_synsem & 
  [ LOCAL.CAT.HEAD.AUX - ].

; (ERB 2003-08-15) sai seems to be constraining its input
; to be INV +, rather than AUX +.  So, moving that constraint down
; to sai, and putting the opposite thing on mal_sai.
; (ERB 2003-08-15) Adding AUX - to DTR to keep auxiliaries out
; of this mal-rule.

mal_sai := basic_sai &
  [ SYNSEM mal_sai_synsem,
    DTR.SYNSEM.LOCAL.CAT.HEAD [ AUX -,
				INV - ] ].

mal_finvp_rule := basic_unary_phrase & rule &
  [ INFLECTD +,
    GENRE robust,
    SYNSEM [ LOCAL [ CAT [ HEAD frag,
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
                           MC + ],
                     CONJ cnil ],
             NONLOC non-local_none ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VFORM fin,
                                                  INV - ],
                                    VAL [ SUBJ < unexpressed_reg >,
                                          COMPS *olist* ] ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX #event,
                                          XARG #arg0 ],
                              AGR.PNG #png ],
                      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                  REL 0-dlist,
                                  QUE 0-dlist ] ],
	     GENRE robust ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event ],
             RELS <! [ PRED _they+that_q_mal_rel,
                     ARG0 #arg0 & ref-ind & 
                          [ PNG #png & [ PN 3p,
                                         GEN neut ] ],
                     RSTR #rhand ],
                   [ LBL #nhand,
                     PRED generic_nom_rel,
                     ARG0 #arg0 ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !> ] ].
             
;; Block misanalysis of imperatives as VP fragments, as in "put the book here"
;; (via [--MAL3SG +].
frag_vp_rule := frag_verbal_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN norm_rel,
                                       VFORM non_bse,
                                       TAM.MOOD ind_or_modal_subj,
                                       MOD *cons*,
				       --MAL3SG + ],
                                VAL.SUBJ < synsem &
                                           [ LOCAL.CAT.HEAD noun,
                                             --SIND non_expl-ind,
					     NONLOC.SLASH 0-dlist ] > ] ] >,
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].


frag_vp_fin_3sg_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD [ AUX -,
                                       TAM #tam & [ TENSE present ],
				       --ADDIN [ ADDTAM #tam,
				                 ADDPN #pn ] ],
                            AGR.PNG.PN #pn & 3s ] ] > ].

frag_vp_fin_past_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ AUX -,
                                     TAM #tam & [ TENSE past ],
                                     --ADDIN.ADDTAM #tam ] ] > ].

frag_vp_fin_aux_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.AUX + ] > ].




;; Block the application of this rule, to avoid spurious analyses for e.g.
;; |the pie-eating contest|
;; DPF 2012-11-20 - But we need it in general for e.g. |the covered-up plate|
;;
#|
punctuation_hyphen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT hyphen_sgl & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT.HEAD no_head,
	              PUNCT [ LPUNCT #lpunct & no_punct,
                              RPUNCT no_punct &
                                     [ PSF #pred ],
                              RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre,
    RNAME "LPHR" ].
|#

#|
;; Block this rule, to avoid ambiguity: |The neighbors' is by the tree.|
;; DPF 16-01-14 - But we'll need this for more general input, and don't add
;; much ambiguity in the single-sentence composition by keeping it.
;;
punctuation_sqright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT sq_punct & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT.HEAD no_head,
	              PUNCT [ LPUNCT #lpunct & no_punct,
                              RPUNCT comma_or_clause_or_no_punct &
                                     [ PSF #pred ],
                              RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre ].
|#

;; Prevent comma marking on spr, as in "most of all, pizza tastes great"
head_spec_phrase :+
  [ NH-DTR.SYNSEM.PUNCT.RPUNCT no_punct ].

;; Constrain to exclude gerunds with subjects, as in spurious analysis of
;; "what was kim doing yesterday?"

#|
subjh_nonmc_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin_or_bse,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD verbal,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD n_or_v ].
|#
subjh_nonmc_rule := subjh_rule_decl & head_subj_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin_or_bse,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD verbal,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD n_or_v ].

;; Constrain to SF prop-or-like: if want question, have to supply question mark
;;
subjh_mc_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                  TAM indic_tam ],
                           MC + ],
                     CONT.HOOK.INDEX.SF #pred & prop-or-like ],
             PUNCT.RPUNCT.PSF #pred ] ].

#|
mal_bare_np_sg_phrase := generic_bare_np_phrase &
  [ SYNSEM [ LOCAL [ AGR [ DIV -,
			   PNG.PN 3s ],
                     CAT.HEAD.MINORS.ALTMIN implicit_q_rel ],
             MODIFD #modif ],
    ARGS < [ SYNSEM 
	     [ LOCAL [ AGR [ DIV -,
			     PNG.PN 3s ],
		       CAT [ VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.MIN udef_q_rel]>,
			     HEAD [ MINORS.MIN non_temp_or_nonday_nbar_rel,
				    --BARE + ] ] ],
	       MODIFD #modif & [ LPERIPH na_or_- ] ],
	     INFLECTD + ] >,
    C-CONT.RELS <! [ PRED mal_bare_div_q_rel ] !>,
    GENRE robust ].

mal_bare_np_sg_rule := rule & mal_bare_np_sg_phrase.
|#

#|
;; Enrich this rule to propagate dtr's MOD..--BARE value to SPEC, in order to
;; constrain robust "all" as in "all pizza"
;;
num_det_rule :+ 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.--BARE #b ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.--BARE #b ] > ] > ].
|#

#|
double_det_rule := head_valence_phrase & head_final & rule &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT #cat,
                     CONJ cnil ],
             NONLOC #nonloc,
	     MODIFD #modif,
             LEX #lex ],
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT #cat & [ HEAD det ],
                              CONT.HOOK #hdhook,
                              CONJ cnil ],
                      NONLOC #nonloc,
                      MODIFD #modif,
                      LEX #lex ] ],
    NH-DTR [ SYNSEM lex_synsem &
                   [ LOCAL [ CAT.HEAD det,
                             CONT.HOOK.INDEX #nhindex,
                             CONJ cnil ],
                     NONLOC non-local_none,
                     LKEYS.KEYREL.RSTR #rstr ] ],
    C-CONT [ HOOK #hdhook,
             RELS <! arg0_relation &
                     [ LBL #nhand,
                       PRED generic_nom_rel,
                       ARG0 #nhindex ],
                     arg1_relation &
                     [ PRED ellipsis_rel,
                       ARG1 #nhindex ] !>,
	     HCONS <! qeq & [ HARG #rstr,
                              LARG #nhand ] !> ],
    GENRE robust ].
|#

; "One books"
mal_num_det_rule_1 := num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL [ AGR.PNG.PN 3p,
    			      	          CAT.HEAD.MINORS.NORM 
					                 norm_or_no_rel ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL.AGR.PNG.PN 3s ] >,
				     MINORS.NORM norm_rel ] ] >,
    GENRE robust ].

; "Twenty book"
mal_num_det_rule_2 := num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL [ AGR.PNG.PN 3s,
					  CAT.HEAD [ --BARE +,
						     MINORS.NORM 
					                 norm_or_no_rel ] ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.PNG.PN 3p ] > ] >,
    GENRE robust ].

;; Plural det with singular count noun (all, several, many, more, most)
;; as in |all cat arose|
;;
aj_-_i-one_le_rbst := aj_-_i-one_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS [ ALTMIN no_rel,
					   NORM no_rel ],
				  MOD < [ LOCAL [ CAT [ VAL.SPR < unexpressed >,
							HEAD.--BARE + ],
						  CONT.HOOK.INDEX.DIV - ],
					  LEX - ] > ],
			   VAL.COMPS *synnull* ] ],
	     MODIFD.LPERIPH + ],
    GENRE robust ].

;; DPF 13-03-14 - Drop the requirement for MOD's SPR to be explicit, so we can
;; robustly parse |we admire best performer|.  This means we won't catch
;; erroneous |we admire best performers|.  FIX someday?
;;
#|
aj_-_i-sup_le := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
    [ LOCAL [ CAT [ HEAD superl_adj & [ MINORS.ALTMIN superl_rel,
                                         MOD < [ LOCAL.CAT.HEAD.MINORS.ALTMIN
                                                   explicit_q_rel ] > ],
                    VAL.SPR.FIRST.--MIN ord_or_very_rel ],
              CONT.RELS <! relation, relation !> ],
      LKEYS.ALTKEYREL.PRED superl_rel ] ].
|#
aj_-_i-sup_le := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
    [ LOCAL [ CAT [ HEAD superl_adj & [ MINORS.ALTMIN superl_rel ],
                    VAL.SPR.FIRST.--MIN ord_or_very_rel ],
              CONT.RELS <! relation, relation !> ],
      LKEYS.ALTKEYREL.PRED superl_rel ] ].

;; Allow robust |dentists office|
aj_-_i-cmpd_le_rbst := aj_-_i-cmpd_lexent &
  [ GENRE robust ].

;; Block inversion with `be' taking CP complement
be_nv := be_verb &
  [ SYNSEM nv_cop_verb &
	   [ LOCAL [ CAT.HEAD [ INV - ],
		     CONT [ HOOK.INDEX #event,
			    RELS.LIST.FIRST.ARG0 #event ] ] ],
    ALTS.VPELLIP - ].

#|
;; In lextypes.tdl
;; Remove SORT non-time-sort constraint to allow 
;; |the morning is the best part of the day|
n_-_c-ns_le := basic_intr_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT.HOOK.INDEX.PNG.GEN neut ] ].
|#

;; Add extra subtype of non_obliq case to impose constraint on abstract noun
;; |man| as in |man's best friend|
genitive := non_obliq.

#|
;; Prevent mal-det and mal-adj (e.g. "all") from spurious robust analyses
n_-_mc_le :+ 
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].
|#


;; Block robust plural rule from applying to e.g. "north"
#|
;; CoNLL
n_-_c-dir_le := n_-_mc-ntoj_lexent &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
           [ LOCAL.CAT.HEAD.--BARE -,
	     MODIFD.LPERIPH + ] ].

n_-_c-dir_le := n_-_mc-ntoj_lexent &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
           [ LOCAL.CAT.HEAD.--BARE - ] ].
|#

;; Add idiomatic noun type to ensure idiomatic cooccurrences such as 
;; |give a speech| while PET still does not enforce idioms
idiom_nom_rel := reg_nom_rel.
idiom_modable_nom_rel := idiom_nom_rel & modable_nom_rel.
;; These two used with mal-entry for ditransitives to block mal-parse for
;; |gave a speech| where "speech" entry is [--MIN alt_idiom_nom_rel] indicating
;; that it has an alternative idiomatic (light-verb-friendly) entry.
non_idiom_nom_rel := norm_nom_rel.
alt_idiom_nom_rel := norm_nom_rel.

n_-_c-idm_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN idiom_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_m-idm_le := noun_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ MODIFD notmod,
	     LOCAL.CAT.HEAD.MINORS.MIN idiom_nom_rel,
	     LKEYS.KEYREL reg_nom_relation ] ].

#|
;; For doubled nouns like "beach beach"
;; (Chart mapping for `educ' should add LPERIPH bool to the second of two 
;; repeated words, to prevent a normal noun-noun compound analysis, leaving
;; this robust compound rule analysis.
noun_n_cmpnd_phr_doubled := basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM basic_lex_synsem &
		  [ MODIFD notmod & [ LPERIPH bool ],
		    PUNCT.LPUNCT dq_or_no_punct,
		    LKEYS.KEYREL.PRED #pred ],
    NH-DTR [ SYNSEM lex_synsem &
	  	    [ LKEYS.KEYREL.PRED #pred ],
	     INFLECTD na_or_- ],
    GENRE robust ].

noun_n_cmpnd_rule_rbst := binary_rule_right_to_left & noun_n_cmpnd_phr_doubled.
|#

;; In order to distinguish transparent irregular plurals like |trout|, to
;; block them in the robust N-N-compound-plural rule, we add types 
;; cat_infl_suff and cat_infl_nosuff 

cat_infl_suff := cat.
cat_infl_nosuff := cat.

n_-_c-pl_le :+ [ SYNSEM.LOCAL.CAT cat_infl_nosuff ].
n_-_c-pl-def_le :+ [ SYNSEM.LOCAL.CAT cat_infl_nosuff ].


;; For |the gardens dog|
;;
noun_n_cmpnd_pl_mal := binary_rule_right_to_left & basic_noun_n_cmpnd_phr &
  [ SYNSEM.MODIFD.LPERIPH na,
    HD-DTR.SYNSEM [ MODIFD notmod & [ RPERIPH na ],
		    LOCAL.CAT.HEAD.--BARE +,
		    PUNCT.LPUNCT dq_or_no_punct ],
    NH-DTR [ INFLECTD +,
             SYNSEM lex_synsem &
	            [ LOCAL [ CAT cat_infl_suff &
				  [ HEAD.--BARE - ],
			      AGR.PNG.PN 3p ] ] ],
    GENRE robust ].


;; Don't want |can arise| as NP-VP
#|
bare_np_prd_phrase := reg_bare_np_phrase &
  [ SYNSEM.LOCAL.AGR.DIV -,
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun & [ CASE nom ],
				  VAL.SPR.FIRST unexpressed_reg ] ] ] > ].
|#

alts :+ [ PLMASS bool ].

;; For robust plural of mass nouns
;;
lex_rule_plural_mass := lex_rule_basic & word_or_infl_rule &
  [ INFLECTD +,
    KEY-ARG #keyarg,   
    SYNSEM mass_or_count_synsem &
	   [ LOCAL [ CAT #cat & [ HEAD noun_or_ttl & [ --BARE - ],
				  VAL.SPR < synsem &
					    [ LOCAL.AGR [ PNG.PN 3p,
							  DIV + ] ] > ],
		     CONT #cont,
		     CONJ #conj,
		     CTXT #ctxt,
		     ARG-S #arg-s ],
	     NONLOC #nonloc,
	     OPT #opt,
	     --MIN #min,
	     --SIND #sind,
	     LEX #lex,
	     MODIFD #modifd,
	     PHON #phon,
	     PUNCT #punct,
	     LKEYS #lkeys ],
    ARGS < #dtr >,
    DTR #dtr & [ INFLECTD -,
                 KEY-ARG #keyarg,   
		 ALTS.PLMASS +,
                 SYNSEM basic_mass_noun_synsem &
			[ LOCAL [ CAT #cat,
				  CONT #cont,
				  CONJ #conj,
				  CTXT #ctxt,
				  AGR [ PNG.PN 3s,
					DIV + ],
				  ARG-S #arg-s ],
			  NONLOC #nonloc,
			  OPT #opt,
			  --MIN #min,
			  --SIND #sind,
			  LEX #lex,
			  MODIFD #modifd,
			  PHON #phon,
			  PUNCT #punct,
			  LKEYS #lkeys ] ],
    C-CONT.RELS <! !>,
    GENRE robust ].


;; Since bare-sg-NP keeps AGR as 3s, change the following type to allow either
;; sg or plur NP comps, as in |we human| for |we humans|

pro_wcomps_plur_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL [ COMPS 
                      < [ LOCAL [ CAT [ HEAD basic_noun & 
                                        [ MINORS 
					    [ MIN nonpro_rel,
					      ALTMIN both_all_udef_q_rel ] ],
					VAL [ SPR *olist*,
					      SUBJ < >,
					      COMPS < >,
					      SPEC < anti_synsem_min > ] ],
				  CONT.HOOK.INDEX #cind & nonconj_ref-ind,
				  AGR.PNG.PN 3 ],
                           OPT - ] > ],
            CONT [ HOOK.INDEX #ind,
                   RELS <! [ LBL #lbl ], relation & #altkeyrel,
			   #alt2keyrel & [ LBL #lbl,
					   PRED appos_rel,
					   ARG0.E.TENSE no_tense,
					   ARG1 #ind,
					   ARG2 #cind ] !> ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    ALT2KEYREL #alt2keyrel ] ].


#|
;; Temporary, from lexrules.tdl

;; DPF 2012-08-21 - Identified --ADDIN on mother and dtr, to avoid spurious
;; analysis with mismatched subj-verb agreement, as in |she turn in homework|.
;; Sigh.

NP_particle_lr := lex_rule &
 [ ORTH #orth,
   ALTS.NPPART +,
   DTR [ ORTH #orth,
         SYNSEM generic_NP_particle_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod,
				 --ADDIN #addin ],
                          POSTHD #ph,
			  VAL [ SUBJ #subj,
                                COMPS < [ OPT #opt2,
                                          NONLOC #nloc2 ] .
                                        < [ OPT #opt1,
                                            --MIN #cmin,
                                            NONLOC #nloc1 ] . #comps > > ],
                          MC #mc,
                          HC-LEX #hclex  ],
		    CONT.HOOK #hook,
		    CTXT #ctxt ],
	    NONLOC #nonlocal,
            LKEYS #lkeys ] ],
   SYNSEM generic_particle_NP_verb &
          [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod,
				 --ADDIN #addin ],
                          POSTHD #ph,
                          VAL [ SUBJ #subj,
                                COMPS < [ OPT #opt1,
                                          --MIN #cmin,
                                          NONLOC #nloc1 ] . 
                                        < canonical_synsem & 
                                          [ OPT #opt2,
                                            NONLOC #nloc2 ] . #comps > > ],
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT.HOOK #hook,
                    CTXT #ctxt ],
            NONLOC #nonlocal,
            LKEYS #lkeys ],
   C-CONT [ RELS <! !>,
            HCONS <! !> ] ].
|#

;; Missing apostrophe for contraction of "it is"
be_is_mal_lex_entry := nonc-h &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < anti_synsem_min >,
			       COMPS < synsem & [ OPT - ], ... >,
			       SPCMPS < > ],
			 HEAD [ VFORM fin,
				PRD -,
				INV -,
				TAM indic_tam &
				      [ TENSE present,
					ASPECT.PRF -,
					MOOD indicative ] ],
			 POSTHD + ],
		   AGR.PNG png & [ PN 3s ],
		   CONT psoa &
		       [ HOOK.XARG #xarg & ref-ind & [ PNG.PN 3s ],
		         RELS.LIST < [ PRED pron_rel,
				       LBL #nhand,
				       ARG0 #xarg ],
				     [ PRED pronoun_q_rel,
				       ARG0 #xarg,
				       RSTR #rhand ], ... >,
			 HCONS <! qeq & [ HARG #rhand,
					  LARG #nhand ] !> ] ],
    ALTS.CSAI -,
    GENRE robust ].

v_prd_its-mal_le := be_is_mal_lex_entry &
  [ SYNSEM prd_aux_verb_ssr &
	   [ LOCAL [ CAT [ HEAD [ TAM #tam ],
			   VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.TAM #tam,
						   CONT.HOOK.LTOP #ltop ] ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation, relation !> ] ],
	     LKEYS.KEYREL.PRED be_v_prd_rel ] ].

v_np_its-mal_le := be_is_mal_lex_entry &
  [ SYNSEM aux_np_verb &
	   [ LOCAL [ CAT [ HEAD [ TAM.ASPECT.PROGR - ],
			   VAL.COMPS < [ LOCAL.CAT.HEAD.--BARE - ] > ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #event ],
			    RELS <! relation, relation, #keyrel !> ] ],
	     LKEYS.KEYREL #keyrel &
		          [ LBL #ltop,
			    ARG0 #event,
			    PRED _be_v_id_rel ] ] ].

;; For |have went ...|
;; FIX: block this for ordinary -ed past participles
psp_aux_verb_mal_ssr := basic_have_aux_verb_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT vp_cat &
					[ HEAD verb &
					       [ VFORM fin,
						 TAM.TENSE past ],
					  VAL.SUBJ < [ LOCAL.CAT.HEAD noun ] >],
				    CONJ cnil ],
			    OPT - ] > ].

psp_aux_verb_mal_word := aux_verb_word &
  [ INFLECTD +,
    SYNSEM psp_aux_verb_mal_ssr &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD -,
				  TAM indic_tam ],
			   POSTHD +,
			   VAL [ SUBJ < synsem & 
					[ LOCAL [ CAT nomp_cat_nom_min,
						  CONJ cnil ],
					  OPT - ] >,
				 COMPS < canonical_synsem &
					 [ LOCAL.CONT.HOOK.LTOP #hand ] > ] ],
		     CONT psoa &
			  [ HOOK.LTOP #hand,
			    RELS <! !>,
			    HCONS <! !> ] ] ],
    GENRE robust,
    ALTS.CSAI - ].

v_vp_has-mal_le := psp_aux_verb_mal_word &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.AGR.PNG png & [ PN 3s ] ] > ].

v_vp_have-mal_le := psp_aux_verb_mal_word &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.AGR.PNG png & [ PN -3s ] ] > ].

v_vp_had-mal_le := psp_aux_verb_mal_word &
  [ INFLECTD + ].

v_np_are-n_le_rbst := v_np_are-n_lexent &
  [ GENRE robust ].

v_np_is-n_le_rbst := v_np_is-n_lexent & 
  [ GENRE robust ].

v_np_was-n_le_rbst := v_np_was-n_lexent &  
  [ GENRE robust ].

v_np_wre-n_le_rbst := v_np_wre-n_lexent &
  [ GENRE robust ].

; For e.g. "went the store"
; Add COMPS..CASE acc to block v_mod rule for e.g. "went to visit her house"
v_np_pp_le_rbst := main_verb & 
  [ SYNSEM np_trans_verb &
     [ LOCAL.CAT [ VAL.COMPS < canonical_synsem &
			       [ OPT -,
				 LOCAL.CAT.HEAD noun &
				     [ --BARE -,
				       CASE acc ],
				 PUNCT.RPUNCT comma_or_clause_or_no_punct ] >]],
    GENRE robust ].

;; Constrain to singular unknown names, to avoid spurious for e.g. |Pistorius|
n_-_pn-gen_le := basic_n_proper_lexent & generic_ne_lex_entry &
  [ INFLECTD -,
    SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN named_np_rel,
		     AGR.PNG.PN 3s ],
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL [ PRED named_rel ] ] ].

;; Constrain to not capitalized, to avoid spurious entry for e.g. |Mom|
;;
n_-_mc-unk_le := n_-_mc-unk_lexent & norm_unknown_word &
  [ TOKENS.+LAST.+CLASS.+CASE non_capitalized ].

;; Hack to accommodate |would rather VP than X|
;;
ssr_vp_pp_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
	   [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                        INDEX #subj ] ] >,
	     COMPS < [ LOCAL [ CAT [ HEAD verbal & [ VFORM bse ],
                                     VAL [ SUBJ < synsem >,
					   COMPS < > ] ],
                               CONT.HOOK.XARG #subj ],
                       OPT - ],
		     synsem &
		     [ --MIN _than_p_compar_rel,
                       LOCAL [ CAT basic_pp_cat & 
                                   [ HEAD.MOD < > ],
                               CONJ cnil ],
		       OPT - ] > ],
            CONT.HOOK.LTOP #ltop ] ].

ssr_vp_pp_verb := verb_synsem & ssr_vp_pp_subst & ssr_expr_lt.

v_vp-pp_ssr_le := main_verb_mliszt & 
  [ SYNSEM ssr_vp_pp_verb ].

v_p_le_infl_rbst := norm_basic_main_verb & 
  [ INFLECTD +,
    SYNSEM particle_verb &
	   [ LOCAL past_or_subj_verb,
	     LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ],
    GENRE robust ].

; For e.g. |It affected to Kim| with spurious prep
v_pp_np_le_rbst := main_verb & 
  [ SYNSEM empty_prep_intrans_verb &
	     [ LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ],
    GENRE robust ].

;; For wrong prep marker, as in |abide to|
v_pp_e_le_rbst := main_verb & 
  [ SYNSEM empty_prep_intrans_verb &
	   [ LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ],
    GENRE robust ].

;; For wrong prep marker as in |allocated it of Kim|
v_np-pp_e_le_rbst := main_verb & 
  [ SYNSEM empty_prep_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < [ OPT - ], [ OPT - ] > ],
             LKEYS [ --OCOMPKEY #ocmin,
                     --+OCOMPKEY #ocmin ] ],
    GENRE robust ].


; DPF 04-aug-10 - Block free relatives via NH-DTR..HEAD value
;; DPF 2017-04-03 - Restrict to MC + to avoid use in e.g.
;; |he was in the theater seat sleeping|

subjh_nonfin_robust_rule := subjh_rule_basic & head_subj_phrase &
			    non_rel_clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb & 
				[ VFORM non_pas,
				  TAM indic_tam & [ ASPECT.PRF - ] ],
			   MC + ],
                     CONT.HOOK.INDEX.SF #pred ],
	     NONLOC.SLASH 0-dlist,
             PUNCT.RPUNCT.PSF #pred ],
    HD-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #hdtop,
				    INDEX #hdind ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD noun,
		    PUNCT.RPUNCT pair_or_no_punct ],
    C-CONT [ HOOK [ LTOP #hdtop,
                    INDEX #hdind ],
             RELS <! !>,
             HCONS <! !> ],
    GENRE robust ].

; DPF 22-nov-07 - For now, don't allow bare-sg NPs as subjects here, to
; avoid too much ambiguity - maybe FIX later, if this is too restrictive
;
subjh_robust_rule := subjh_rule_decl & basic_head_subj_phrase & clause &
  [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin,
                              TAM indic_tam & [ TENSE present ] ],
                       MC + ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN non_ellipt_rel,
				  VAL.SUBJ < canonical_synsem &
                                       [ LOCAL [ CAT #cat,
                                                 CONT #cont,
                                                 CONJ #conj,
                                                 CTXT #ctxt ],
                                         NONLOC #nonloc,
					 --SIND ref-ind & #sind,
                                         OPT #opt,
                                         LEX #lex,
                                         MODIFD #modifd,
                                         PHON #phon,
                                         PUNCT #punct ] > ],
			    CONT.HOOK.INDEX non_conj_event ],
                    NONLOC.SLASH 0-dlist ],
    NH-DTR.SYNSEM [ LOCAL [ CAT #cat & [ HEAD noun & 
					      [ --BARE -,
						MINORS.ALTMIN 
						       non_freerel_q_rel ] ],
			    CONT #cont,
                            CONJ #conj,
                            CTXT #ctxt ],
                    NONLOC #nonloc,
		    --SIND #sind,
                    OPT #opt,
                    LEX #lex,
                    MODIFD #modifd,
                    PHON #phon,
                    PUNCT #punct & [ RPUNCT pair_or_no_punct ] ],
    GENRE robust ].
                          
subjh_robust_3s_v_rule := subjh_robust_rule &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s,
    HD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG.PN 3s ] >,
    NH-DTR.SYNSEM.LOCAL.AGR.PNG.PN -3s ].

subjh_robust_n3s_v_rule := subjh_robust_rule &
  [ SYNSEM.LOCAL.AGR.PNG.PN -3s,
    HD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG.PN -3s ] >,
    NH-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3s ].

;; Relax GENRE constraint so we can generate sentence-initial PPs without
;; commas.
;;
filler_head_rule_non_wh_infgen := filler_head_rule_non_wh &
  [ HD-DTR.SYNSEM.LEX -,
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD non_noun_or_adv &
				   [ MINORS [ MIN independent_rel,
				              ALTMIN non_ellipt_rel ] ],
		    PUNCT.RPUNCT no_punct ] ].


#|
;; For CoNLL, keep comma as separate token
pt_-_comma_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT comma_or_rbc_punct ].

pt_-_semicolon_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT basic_semicol_punct ].
|#

;; For erroneous VP passives of intransitives as in |the fish were died|
;; (Repair is to drop preceding copula)
v_-_psv-post_le_rbst := norm_basic_main_verb &
  [ SYNSEM passive_unerg_synsem &
	   [ LOCAL.CAT [ POSTHD + ] ],
    INFLECTD +,
    GENRE robust ].

;; For erroneous VP passives of intransitives used prenominally: |the died fish|
;; (Repair is to rephrase as relative clause: |the fish that died|)
v_-_psv-pre_le_rbst := norm_basic_main_verb &
  [ SYNSEM passive_unerg_synsem &
	   [ LOCAL.CAT [ POSTHD - ] ],
    INFLECTD +,
    GENRE robust ].

;; Block depictives headed by |being that ...|, to favor |human being| as item
v_cp_being_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

;; Block reduced relative |being that|, for same reason
;; DPF 16-01-13 - But this prevents pre-S modifiers, as in "being a cat, she 
;; complained."  So undo, and see if still need help in getting |human being|.
;;
#|
v_np_being_le :+
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST expressed_synsem ].
|#

;; Flag wrong double plurals: e.g. |polices|
n_-_c-pl_le_rbst := n_intr_infl_lex_entry &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
					       DIV + ] ] >,
		   CONT.HOOK.INDEX [ PNG.PN 3p,
				     DIV + ] ],
    GENRE robust ].

; Intransitive used as causative: |this deteriorates the problem|
v_np_caus_le_rbst := main_verb & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < canonical_synsem &
				   [ OPT -,
				     LOCAL.CAT.HEAD noun &
					 [ --BARE -,
					   CASE acc ],
				     PUNCT.RPUNCT clause_or_no_punct ] > ] ],
    GENRE robust ].

;; Ditransitives like `give' used as simple transitives
;;
v_np_ditrans_le_rbst := main_verb & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < [ --MIN non_idiom_nom_rel,
	                               OPT - ] > ] ],
    GENRE robust ].

;; Double negation
;
av_-_s-not_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD negadv &
                       [ MOD < [ LOCAL.CAT [ HEAD verb_or_frag &
						  [ VFORM non_fin ],
                                             VAL.SUBJ < synsem_min > ],
				 --SIND.SF prop-or-ques ] > ] ] ].


adv_addition :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS [ FIRST.LOCAL.CAT.NEGPOL #negp,
                                 REST.FIRST.LOCAL.CAT.NEGPOL #negp ] ].

;; Change NEGPOL to -, where negation-sensitive elements are either + (marking
;; overt negation and hence not permissible in scope of negation), or - (marking
;; a polarity-sensitive element that needs to be in scope of negation or
;; similar polarity context).
;;
d_-_prt_le := pdet_word_nonque &
  [ SYNSEM.LOCAL.CAT.NEGPOL - ].

basic_unary_phrase :+
  [ SYNSEM.LOCAL.CAT.NEGPOL #negp,
    ARGS.FIRST.SYNSEM.LOCAL.CAT.NEGPOL #negp ].

basic_head_mod_phrase_simple :+
  [ SYNSEM.LOCAL.CAT.NEGPOL #negp,
    HD-DTR.SYNSEM.LOCAL.CAT.NEGPOL #hnegp,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.NEGPOL #hnegp,
                              NEGPOL #negp ] ].

np_coord_top_rule :+
  [ SYNSEM.LOCAL.CAT.NEGPOL #negp,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.NEGPOL #negp ].

;; Removed [NEGPOL -] on mother.
bare_npq_phrase := norm_unary_phrase &
  [ INFLECTD #infl,
    SYNSEM synsem &
           [ LOCAL [ CAT [ HEAD #head,
                           HC-LEX #hclex,
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < synsem_min &
				       [ --MIN just_only_deg_rel,
                                         LOCAL [ CAT.HEAD adv,
                                                 CONT.HOOK.LTOP #ltop ],
                                         OPT + ] > ],
                           MC na ],
                     AGR ref-ind &
                         [ PNG #png,
			   DIV #div ],
                     CONJ #conj ],
             NONLOC #nonloc,
	     LEX #lex,
             MODIFD #modif & [ RPERIPH + ] ],
    ARGS < [ INFLECTD #infl,
	     SYNSEM 
             [ LOCAL [ CAT [ HEAD #head & partn,
                             HC-LEX #hclex,
                             VAL [ SUBJ *olist*,
                                   COMPS < >,
                                   SPR < unexpressed &
					 [ LOCAL.CONT.HOOK.LTOP #ltop,
					   NONLOC.QUE 0-dlist,
					   OPT - ], ... > ] ],
                       AGR [ PNG #png,
			     DIV #div ],
                       CONJ #conj & cnil,
                       CONT.HOOK [ INDEX #index,
				   XARG #xarg ] ],
               NONLOC #nonloc,
	       LEX #lex,
	       MODIFD #modif,
	       PUNCT.LPUNCT pair_or_no_punct ] ] >,
    C-CONT [ HOOK [ INDEX #index,
		    XARG #xarg ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; Since we're trying to do without robust commas, adjust the adj-N types

adj_n_int_phrase := adj_head_int_phrase &
  [ HD-DTR [ SYNSEM [ LOCAL.CAT [ HEAD basic_nom_or_ttl,
				  VAL [ SPR.FIRST 
					   [ LOCAL.CAT.HEAD.MINORS.MIN #min,
					     --MIN #min & quant_rel ],
					COMPS < > ] ],
		      PHON.ONSET #onset ],
	     INFLECTD #infl ],
    NH-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ PHON.ONSET #onset ] >,
				    VAL.SUBJ *synlist* ],
			      CONT.HOOK.INDEX event & 
			                      [ E [ TENSE no_tense,
			                            ASPECT [ PROGR bool,
							     PRF - ] ] ] ],
                      LEX +,
		      PUNCT.RPUNCT comma_or_rbc_or_hyphen_or_pair_or_no_punct ],
             INFLECTD + ],
    INFLECTD #infl ].

adj_n_phrase := adj_n_int_phrase &
  [ HD-DTR [ SYNSEM.MODIFD notmod_or_rmod,
	     INFLECTD bool ] ].

;; Since we're not using nonformal comma, change here
adj_adjn_phrase := adj_n_int_phrase &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.HEAD nom_or_ttl,
                    MODIFD lmod & [ LPERIPH na_or_-,
				    RPERIPH na_or_- ] ],
    NH-DTR.SYNSEM .PUNCT.RPUNCT comma_or_hyphen_or_pair_or_no_punct ].

;; Block pre-VP modif, as in |she had [[eaten before she] [had her dinner]]|
subconj_prdp_v_init_phrase := subconj_prdp_init_phr &
  [ SYNSEM.LOCAL.CAT [ POSTHD -,
		       HEAD.MOD.FIRST.LOCAL.CAT.VAL.SPR < > ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD verb & [ VFORM pas_or_prp ] ] > ].

;; Add subtypes of appos_rel so we can use paraphrase rule to reverse the
;; order of args to generate both |Kim the teacher| and |the teacher Kim|
appos_norm_rel := appos_rel.
appos_rev_rel := appos_rel.

;; Tried excluding |the eye of him|
;; but this also loses |the weight of it|, so don't
;p_np_i-nm-poss_lexent :+
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN basic_nonpro_rel ] > ].

;; DPF 2016-06-25 - Prevent robust 'he' from appearing in |K is taller than he|
p_np_ptcl-ngap_le :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.NORM norm_rel ].

;; DPF 2017-05-17 - Allow comma or no punct, so we can detect run-ons such as
;; |I spotted a lizard it was awesome.|  
;; DPF 2017-08-09 - Re 2017-05-17: But this leads to several false positives
;; such as for |She brought pictures of her China trip.|  So require comma.
;; 
run_on_coord_comma_rule := basic_run_on_coord_rule &
 [ LCONJ-DTR.SYNSEM phr_synsem &
		    [ LOCAL.CAT.HEAD verb,
		      PUNCT.RPUNCT comma_punct ],
   RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD verb_or_conj-s,
                            CONJ cnil ],
   GENRE nonformal ].
