; Block proper names from taking determiners

_the_q_prop_rel := proper_q_rel.
mal_bare_div_q_rel := implicit_q_rel.

norm_n_proper_lexent := basic_n_proper_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED named_rel,
    	     LOCAL.CAT.VAL.SPR < [ --MIN _the_q_prop_rel ] > ],
    INFLECTD - ].

; Also hour names

n_-_pn-hour_le := basic_abstr_hour_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < unexpressed >,
                     CONT.RELS <! relation, relation !> ],
	     LKEYS.KEYREL.PRED numbered_hour_rel,
             LEX - ] ].

; Considered blocking days of week from appearing as NP-adv
; but conflict between Strand3.C and sentencelist.C:
; "*Jenny plays chess Tuesday." but "She goes Saturdays."
;
;n_-_c-day_lexent := basic_n_intr_temp_lexent &
;  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN dofw_rel,
;                                       ALTMIN quant_or_wh_rel ],
;                         VAL.SPR < synsem > ],
;             MODIFD notmod,
;             LKEYS.ALTKEYREL.PRED quant_or_wh_rel ] ].

; Special class for "Mr." etc, since we exclude normal nouns as titles
n_-_c-pre-ttl_le := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD [ MINORS [ MIN pre_title_rel,
                              	         NORM norm_rel ],
                                --BARE - ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

d_-_sg-nmd-mal_le := basic_det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_unk ] > ].

; "an information", "a homework"
d_-_m-c_mal_lexent := det_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                           VAL.SPEC < [ LOCAL.CAT.HEAD.--BARE + ] > ],
                     AGR [ PNG.PN 3s,
		           DIV + ] ],
             NONLOC.QUE 0-dlist ],
    GENRE robust ].

d_-_m-c-mal-a_le := d_-_m-c_mal_lexent &
 [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con ] > ].

d_-_m-c-mal-an_le := d_-_m-c_mal_lexent &
 [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc ] > ].

; From auxverbs - Restrict number on COMPS for singular identity copula.
; Also prevent bare-sg NP subjects

be_id_pos := be_id &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.TAM.ASPECT.PROGR -,
    	     	           VAL.SUBJ.FIRST.LOCAL.CAT.HEAD.--BARE - ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

v_np_is_le := be_is_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3s ] > ].

v_np_is-cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3s ] > ].

v_np_are_le := be_are_lex_entry & be_id_pos.

v_np_are-cx_le := be_are_lex_entry & be_id_pos & contracted_aux_word.

v_np_was_le := be_was_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3s ] > ].

v_np_wre_le := be_were_lex_entry & be_id_pos.

; Block APs as subjects

loc_inv_be_word := loc_inv_verb_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				PRD -,
                                TAM.MOOD indicative ],
                         VAL [ SUBJ < [ LOCAL [ CAT.HEAD prep_or_modnp,
			                        CONT.HOOK [ LTOP #ltop,
                                                          INDEX #ind &
                                                             [ E.TENSE tense ],
                                                          XARG #xarg ] ] ] >,
                               COMPS < [ --SIND #xarg ] > ],
                         POSTHD - ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #ind & [ SF prop-or-ques ],
				   XARG #xarg ],
			    RELS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

; From syntax.tdl

; Restrict nonhead to MIN pre_title_rel.
np_title_cmpnd_phr := norm_np_name_cmpnd_phr &
  [ HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN named_rel,
				  VAL.SPR *olist* ],
			    AGR.PNG.PN #pn ],
		    MODIFD.LPERIPH + ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN pre_title_rel,
						NORM norm_rel ],
				  VAL.SPR < unexpressed > ],
			    AGR.PNG.PN #pn ],
		    PUNCT [ LPUNCT dq_or_sq_or_no_punct,
			    RPUNCT dq_or_sq_or_no_punct ] ],
    C-CONT.RELS <! [ PRED compound_name_rel ], [ PRED udef_q_rel ] !> ].

; Exclude reflesives as non-heads: |*They themselves|
basic_appos_np_phr := basic_appos_phr &
  [ HD-DTR.SYNSEM.MODIFD.RPERIPH bool,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN nonpro_rel,
			      VAL.SPR *olist* ],
    C-CONT [ RELS <! relation !>,
             HCONS <! !> ] ].


;; Block "a Sunday" but allow "next Tuesday"
;; Note that this blocks items in StrandG_2-4 such as
;; "The fair is on a Saturday."
;; So maybe reconsider?
;; Yes, undo, since we also want "on the last Tuesday in May"
;;
;;n_-_c-dow_le := n_-_c-day_lexent &
;;  [ SYNSEM [ LKEYS.KEYREL.PRED dofw_rel,
;;             LOCAL.CAT.VAL.SPR < [ --MIN impl_or_proper_q_rel ] > ] ].

; Block clefts:
; But this also blocks |It is after the sun goes down|
#|
be_nv := be_verb &
  [ SYNSEM nv_cop_verb &
	   [ LOCAL.CONT [ HOOK.INDEX #event,
			  RELS.LIST.FIRST.ARG0 #event ] ],
    ALTS.VPELLIP -,
    GENRE robust ].
|#

; Add feature for blocking mal-3sg

vc_add :+ [ --MAL3SG bool ].

; Allow WH pronouns to be modified by PPs
pron_nonlocal_rel := basic_pron_rel & nonpro_rel.

; Change CASE from obliq to non_obliq to block "to home"
n_-_ad-pl-nomod_le := norm_np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
				CASE non_obliq,
				--BARE - ],
		     CONT.HOOK.INDEX.SORT place ],
	     MODIFD.RPERIPH + ] ].

; Block as direct objects, to avoid spurious reading for e.g.
; "What was he doing yesterday?"
n_-_ad-time_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN time_n_rel,
                              CASE nom_or_obliq ],
                   CONT.HOOK.INDEX.SORT time ] ].


; Add lex-entry for "in bed" to sidestep PET's failure to do idiom check
_in+bed_p_rel := miscprep_rel.
_out+of+bed_p_rel := miscprep_rel.
_to+bed_p_rel := dir_rel.
_above+ground_p_rel := miscprep_rel.
_at+home_p_rel := miscprep_rel.
_during+break_p_rel := miscprep_rel.

; Remove COMPS..--BARE - since we want to flag "She is good student"
be_id := be_verb &
  [ SYNSEM id_cop_verb &
	   [ LOCAL [ CONT [ HOOK.INDEX #event,
  			    RELS.LIST.FIRST.ARG0 #event ] ],
             LKEYS.KEYREL.PRED _be_v_id_rel ] ].

; Restrict normal transitives missing object to --MAL3SG + to prevent
; these from appearing in conjoined verb phrases, avoiding spurious ambiguity
; for e.g. "Kim buys and sells books"
; DPF 19-feb-10 - Also constrain to SLASH 0-dlist, to avoid mis-analysis for
; e.g. `Mark brought the [cookies he made for] his class.'
; DPF 19-apr-10 - --COMPKEY is hack to prevent attrib-adj LR, as in 
; "Mariah is making pasta"
v_-_le_rbst := main_verb & 
  [ SYNSEM unerg_verb &
           [ LOCAL.CAT.HEAD.--MAL3SG +,
	     NONLOC.SLASH 0-dlist,
	     LKEYS.--COMPKEY selected_rel ],
    GENRE robust ].

; e.g. 'tell'
; Exclude robust 3sg in CP complement, to avoid competing treatment for e.g.
; `she told her brother borrow her book'.
v_cp_le_rbst := main_verb & 
  [ SYNSEM cp_intrans_verb &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.--MAL3SG -,
	                             NONLOC.SLASH 0-dlist ] > ],
    GENRE robust ].

; e.g. 'tell him borrow her book'
v_np-vp_bse_le_rbst := main_verb_mliszt & 
  [ SYNSEM obj_equi_bse_verb,
    GENRE robust ].

; e.g. `This lets the cat to enter'
v_np-vp_oeq_le_rbst := main_verb & 
  [ SYNSEM obj_equi_verb,
    GENRE robust ].

; 'She enables to win.'
; Missing direct object
;
v_vp_seq_le_rbst := main_verb & 
  [ SYNSEM subj_equi_verb,
    GENRE robust ].

; (ERB 2003-10-23) For subject equi verbs, with the infinitival
; marker "to" dropped

; 'She wants win.'
v_vp_seq-bse_le_rbst := main_verb_mliszt & 
  [ SYNSEM subj_equi_bse_verb,
    GENRE robust ].

; 'ask' - block dative shift
v_np-np*_nodat_le := main_verb & 
  [ SYNSEM ditrans_only_verb & 
	   [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ OPT + ] > ] ].

; Restrict dtrs to --MAL3SG - to avoid robust intranstives as conjuncts.
basic_v_coord_phr := basic_verbal_coord_phr &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                MINORS #mins,
                                --ADDIN #addin ],
                         VAL.SUBJ < synsem &
				    [ LOCAL [ CAT #cat,
					      AGR #agr ],
				      NONLOC #nonloc,
				      --SIND #sind,
				      OPT #opt ] > ],
                   CONT.HOOK.XARG #xarg ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                          TAM.MOOD #mood,
                                          --ADDIN #addin & [ ADDPN #pn ],
					  --MAL3SG - ],
                                   VAL.SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						OPT #opt ] > ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                          TAM.MOOD #mood,
                                          MINORS #mins,
					  --ADDIN.ADDPN #pn,
					  --MAL3SG - ],
				   VAL.SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						OPT #opt ] > ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    C-CONT.HCONS <! !> ].

;; Allow robust pre-modifiers like 'today'

av_-_i-vp-pr_le_rbst := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                    MOD < [ LOCAL.CAT.HEAD verb &
				                           [ VFORM fin ],
                                            MODIFD.LPERIPH na_or_- ] > ],
                       POSTHD - ],
    GENRE robust ].

; Allow robust post-VP adverbs: "He sang bad"
;
av_-_i-vp-po_le_rbst := int_vp_adverb_word & 
  [ SYNSEM [ LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                      MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                              MODIFD.RPERIPH na_or_- ] > ],
                         POSTHD + ],
             MODIFD hasmod ],
    GENRE robust ].

; restrict to only VP mods
av_-_i-vp-po-nmb_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob & 
                            [ MINORS.MIN adv_rel,
                              MOD < [ LOCAL.CAT.HEAD verb,
                                      MODIFD.RPERIPH na_or_- ] > ],
                       POSTHD + ] ].


;; Make COMPS..HEAD be reg_adv to allow |he did well|
;;
adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
			    [ LOCAL 
			      [ CAT [ HEAD reg_adv &
                                       [ MOD < [ LOCAL intersective_mod ] > ],
                                      VAL [ SPR *olist*,
                                            COMPS < > ],
				      POSTHD + ],
                                CONT.HOOK [ LTOP #hand,
                                            INDEX #event ] ],
                              NONLOC.REL 0-dlist,
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

;; Allow no punct on left dtr

np_city_state_phr := norm_np_name_cmpnd_phr &
  [ HD-DTR.SYNSEM [ MODIFD notmod & [ LPERIPH + ],
		    LOCAL.CAT [ HEAD.MINORS.MIN named_np_or_num_rel,
				VAL.SPR < [ OPT - ] > ] ],
    NH-DTR.SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN named_city_rel,
					      NORM norm_rel ],
			    AGR.PNG.PN 3s ],
                    PUNCT [ LPUNCT no_punct,
			    RPUNCT comma_or_no_punct ] ],
    C-CONT.RELS <! [ PRED compound_name_rel ], [ PRED proper_q_rel ] !> ].

d_-_the-mal_le := d_-_the_lexent &
  [ GENRE robust ].

;; Add hack empty rel for "mop clean the floor"
_clean_a_sel_rel := selected_adj_rel.

;; Constrain to non-nominative, to avoid spurious analysis of e.g.
;; "what do Kim and Abrams ..."

n_-_pr-fr_le := n_freerel_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE non_nom,
                   CONT.RELS.LIST.FIRST.PRED free_relative_q_rel,
		   AGR.PNG.PN 3s ] ].

;; Constrain "what" to singular, to avoid spurious analysis of 
;; "what do Kim and Abrams ..."
n_-_pr-wh_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s ].

p_np_ptcl-of_le := p_prtcl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.--BARE - ] > ].

; Prevent analysis for "with her cousins"
p_np-np_s-ncop_le := noncqrs-nab &
  [ SYNSEM subconj_with_np_np_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN #pn ],
	                           [ LOCAL.AGR.PNG.PN #pn ] > ] ].

mal_v_inf_cp_comp_le := main_verb_mliszt &
   [ SYNSEM mal_v_inf_cp_comp_verb &
       [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ],
     GENRE robust ].

mal_va_does_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN 3s ] ] >,
    GENRE robust ].

mal_va_doesnt_neg_pres_le := do_aux_neg_pres & 
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN 3s ],
    GENRE robust ].

mal_va_dont_neg_pres_le := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ],
    GENRE robust].

mal_va_do_fin_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN -3s ] ] >,
    GENRE robust].

mal_va_has_le := has_aux_lex_ent &
  [ GENRE robust ].

mal_va_have_fin_le := have_fin_aux_lex_ent &
  [ GENRE robust ].

mal_v_vp_has-n_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG.PN -3s,
    GENRE robust ].

mal_v_vp_have-f-n_le := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s,
    GENRE robust ].

mal_vc_there_synsem := there_cop_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS 
					      [ ALTMIN def_udef_some_a_q_rel,
						NORM no_rel ] ].
mal_vc_there_is_le := vc_there_are_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem ].

mal_vc_there_are_le := vc_there_is_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem ].

mal_vc_there_was_le := vc_there_were_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem ].

mal_vc_there_were_le := vc_there_was_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    SYNSEM mal_vc_there_synsem ].

mal_v_np-xp_is-n_le := be_are_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

mal_v_np-xp_are-n_le := be_is_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

mal_v_np-xp_was-n_le := be_were_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

mal_v_np-xp_were-n_le := be_was_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

mal_vc_prd_is_le := vc_prd_are_lexent &
  [ ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST expressed_synsem &
                                    [ NONLOC.SLASH 0-dlist ],
    GENRE robust ].

mal_vc_prd_are_le := vc_prd_is_lexent &
  [ ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.NONLOC.SLASH 0-dlist,
    GENRE robust ].

mal_vc_prd_was_le := vc_prd_were_lexent &
  [ ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.NONLOC.SLASH 0-dlist,   
    GENRE robust ].

mal_vc_prd_were_le := vc_prd_was_lexent &
  [ ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.NONLOC.SLASH 0-dlist,
    GENRE robust ].

; Treat robust "be" and "been" as VFORM prp, so they trigger the robust
; subj-head rule which needs to avoid allowing ordinary base form verbs
; (identical to non-3sg) and ordinary past participles (identical to 
; past tense).
mal_vc_prd_be_le := vc_prd_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM prp,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_np_be_le := vc_np_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM prp,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_prd_been_le := vc_prd_been_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM prp,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_np_been_le := vc_np_been_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM prp,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_det_div_le := det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.MIN
                                                     just_only_deg_rel ] >,
                     AGR.PNG.PN 3s ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s ],
                                 DIV + ],
	     MODIFD hasmod ],
    GENRE robust ].

; 'they/that'
mal_n_deictic_pro_le := n_deictic_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p,
                                           GEN neut ] ] ].

mal_det_pl_le := det_pl_lexent &
  [ GENRE robust ].

mal_n_plur_ppcomp_le := n_plur_ppcomp_lexent &
  [ GENRE robust ].

d_-_sg-a-a-mal_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_voc ] >,
    GENRE robust ].

d_-_the-mal_le := d_-_the_lexent &
  [ GENRE robust ].

; (ERB 2003-10-17) For verbs like "allow" taking a CP[to]
; complement with the PRO bound to arbitrary reference.  Regenerate
; with gerunds instead.  (Might need another class where we
; regenerate with an inserted pronoun "one", if there are verbs
; that show up in this pattern but can't take gerund complements.)

; (ERB 2003-10-17) This is going to be a fairly strange verb type.  I
; can't think of any true English verbs off hand that take an
; infinitival CP complement and allow arbitrary control of the subject
; of that complement.  Furthermore, this type is also putting in some
; extra semantics, in order to allow the right string to come back
; from the generator.  So, we're not inheriting from the usual places
; in the hierarchy.  For example, main_verb is constrained to have a
; single element RELSs list.  main_verb_mliszt will do, though,
; although this isn't what it was intended for. Likewise, I don't
; think any of the linking types lower in the hierarchy will do what
; we want.  Took some constraints from subj_equi_inf_lt to try to
; restrict what can show up as the complement.

; (ERB 2003-10-23) Can't currently generate with these entries,
; and I don't know why.  Can generate from the produced MRS at all,
; in fact.  The MRS produced isn't the same as the MRS for the target,
; because of gerunds are built from progressives and therefore have
; a different value for PROGR.  (There are some other mismatches,
; but they are compatible, so maybe it would work otherwise.)
; While we might consider changing the analysis of gerunds, I
; think the main conclusion to draw is that we will need some kind
; of a transfer component.  Maybe put everything there rather than
; trying to map from mal-formed syntax to well-formed semantics in
; the grammar itself?  If not everything, how to decide when to do
; which?

mal_v_inf_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & basic_two_arg & 
			  basic_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  quant_or_wh_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].
	   
mal_v_inf_from_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & 
			       basic_two_arg & basic_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  quant_or_wh_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].

_they+that_q_mal_rel :< demonstrative_q_rel.

;; Mal NI (but not CE) rules, for lack of do support:

mal_adv_addition := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.AUX - ].

mal_sai_synsem := basic_sai_synsem & 
  [ LOCAL.CAT.HEAD.AUX - ].

; (ERB 2003-08-15) sai seems to be constraining its input
; to be INV +, rather than AUX +.  So, moving that constraint down
; to sai, and putting the opposite thing on mal_sai.

; (ERB 2003-08-15) Adding AUX - to DTR to keep auxiliaries out
; of this mal-rule.

mal_sai := basic_sai &
  [ SYNSEM mal_sai_synsem,
    DTR.SYNSEM.LOCAL.CAT.HEAD [ AUX -,
				INV - ] ].

mal_finvp_rule := basic_unary_phrase & rule &
  [ INFLECTD +,
    GENRE robust,
    SYNSEM [ LOCAL [ CAT [ HEAD frag,
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
                           MC + ],
                     CONJ cnil ],
             NONLOC non-local_none ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VFORM fin,
                                                  INV - ],
                                    VAL [ SUBJ < unexpressed_reg >,
                                          COMPS *olist* ] ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX #event,
                                          XARG #arg0 ],
                              AGR.PNG #png ],
                      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                  REL 0-dlist,
                                  QUE 0-dlist ] ],
	     GENRE robust ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event ],
             RELS <! [ PRED _they+that_q_mal_rel,
                     ARG0 #arg0 & ref-ind & 
                          [ PNG #png & [ PN 3p,
                                         GEN neut ] ],
                     RSTR #rhand ],
                   [ LBL #nhand,
                     PRED generic_nom_rel,
                     ARG0 #arg0 ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !> ] ].
             
frag_vp_fin_3sg_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD [ AUX -,
                                       TAM #tam & [ TENSE present ],
				       --ADDIN [ ADDTAM #tam,
				                 ADDPN #pn ] ],
                            AGR.PNG.PN #pn & 3s ] ] > ].

frag_vp_fin_past_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ AUX -,
                                     TAM #tam & [ TENSE past ],
                                     --ADDIN.ADDTAM #tam ] ] > ].

frag_vp_fin_aux_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.AUX + ] > ].




;; Block the application of this rule, to avoid spurious analyses for e.g.
;; |the pie-eating contest|
punctuation_hyphen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT hyphen_sgl & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT.HEAD no_head,
	              PUNCT [ LPUNCT #lpunct & no_punct,
                              RPUNCT no_punct &
                                     [ PSF #pred ],
                              RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre,
    RNAME "LPHR" ].

;; Block this rule, to avoid ambiguity: |The neighbors' is by the tree.|
punctuation_sqright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT sq_punct & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT.HEAD no_head,
	              PUNCT [ LPUNCT #lpunct & no_punct,
                              RPUNCT comma_or_clause_or_no_punct &
                                     [ PSF #pred ],
                              RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre,
    RNAME "LPSR" ].

;; Constrain to exclude gerunds with subjects, as in spurious analysis of
;; "what was kim doing yesterday?"

subjh_nonmc_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin_or_bse,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD verbal,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD n_or_v ].

;; Constrain to SF prop-or-comm: if want question, have to supply question mark
;;
subjh_mc_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                  TAM indic_tam ],
                           MC + ],
                     CONT.HOOK.INDEX.SF #pred & prop-or-comm ],
             PUNCT.RPUNCT.PSF #pred ] ].

mal_bare_np_sg_phrase := generic_bare_np_phrase &
  [ SYNSEM [ LOCAL [ AGR [ DIV -,
			   PNG.PN 3s ],
                     CAT.HEAD.MINORS.ALTMIN implicit_q_rel ],
             MODIFD #modif ],
    ARGS < [ SYNSEM [ LOCAL [ AGR [ DIV -,
                                    PNG.PN 3s ],
                              CAT [ VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.MIN udef_q_rel ] >,
                                    HEAD [ MINORS.MIN non_temp_nbar_rel,
					   --BARE + ] ] ],
                      MODIFD #modif & [ LPERIPH na_or_- ] ] ] >,
    C-CONT.RELS <! [ PRED mal_bare_div_q_rel ] !>,
    GENRE robust ].

mal_bare_np_sg_rule := rule & mal_bare_np_sg_phrase.

double_det_rule := head_valence_phrase & head_final & rule &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT #cat,
                     CONJ cnil ],
             NONLOC #nonloc,
	     MODIFD #modif,
             LEX #lex ],
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT #cat & [ HEAD det ],
                              CONT.HOOK #hdhook,
                              CONJ cnil ],
                      NONLOC #nonloc,
                      MODIFD #modif,
                      LEX #lex ] ],
    NH-DTR [ SYNSEM lex_synsem &
                   [ LOCAL [ CAT.HEAD det,
                             CONT.HOOK.INDEX #nhindex,
                             CONJ cnil ],
                     NONLOC non-local_none,
                     LKEYS.KEYREL.RSTR #rstr ] ],
    C-CONT [ HOOK #hdhook,
             RELS <! arg0_relation &
                     [ LBL #nhand,
                       PRED generic_nom_rel,
                       ARG0 #nhindex ],
                     arg1_relation &
                     [ PRED ellipsis_rel,
                       ARG1 #nhindex ] !>,
	     HCONS <! qeq & [ HARG #rstr,
                              LARG #nhand ] !> ],
    GENRE robust ].

; "One books"
mal_num_det_rule_1 := num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL [ AGR.PNG.PN 3p,
    			      	          CAT.HEAD.MINORS.NORM 
					                 norm_or_no_rel ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.PNG.PN 3s ] > ] >,
    GENRE robust ].

; "Twenty book"
mal_num_det_rule_2 := num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL [ AGR.PNG.PN 3s,
    			      	          CAT.HEAD.MINORS.NORM 
					                 norm_or_no_rel ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.HEAD.--BARE +,
						   AGR.PNG.PN 3p ] ] > ] >,
    GENRE robust ].

