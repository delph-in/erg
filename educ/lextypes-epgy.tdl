; Block proper names from taking determiners
;; DPF 2018-10-01 - Also allow possessive pronouns: |my BMW|

_the_q_prop_or_no_rel := predsort.
no_rel := non_freerel_rel & non_conj_rel & event_or_degree_or_no_rel &
          nonaux_event_rel & quantity_or_no_rel & norm_or_no_rel &
	  non_pronoun_q_or_no_rel & _the_q_prop_or_no_rel.
_the_q_prop_rel := _the_q_rel & proper_q_rel & _the_q_prop_or_no_rel.
;; Also allow |Lucy's English|
poss_rel := of_p_rel & dofw_or_poss_q_rel & comp_or_poss_rel &
	    _the_q_prop_or_no_rel.

norm_proper_q_rel := proper_q_rel.
mal_bare_div_q_rel := implicit_q_rel.

proper_np_phrase :+
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN norm_proper_q_rel ].

;; Distinguish pronominal vs. nonpronominal NPs.
basic_n_proper_lexent :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PT notpro ].

;; DPF 2018-03-06 - The +CASE requirement prevents even parsing proper names 
;; that are lower case: too brittle, so undo.
#|
norm_n_proper_lexent := reg_n_proper_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED named_rel,
    	     LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.ALTMIN 
	                                    _the_q_prop_rel ] > ],
    INFLECTD -,
    TOKENS.+LAST.+CLASS.+CASE capitalized ].
|#
norm_n_proper_lexent := reg_n_proper_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED named_rel,
    	     LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.ALTMIN 
	                                    _the_q_prop_or_no_rel ] > ],
    INFLECTD - ].

n_-_c-fem_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN fem ].

n_-_c-msc_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN masc ].

;; child, puppy
n_-_c-ugen_le := n_intr_lex_entry.

;; night
n_-_c-dpt-df-sg_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

n_pp_c-of_lexent := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

n_pp_c-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

n_pp_c-ns-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN neut ].

; teacher
n_pp_c-of-anim_le := n_pp_c-of_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN animate ].

;; sister
n_pp_c-of-fem_le := n_pp_c-of_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN fem ].

;; brother
n_pp_c-of-msc_le := n_pp_c-of_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN masc ].

;; Assign default neut gender to avoid spurious paraphrases
;; DPF 2017-09-05 - But this prevents relative clauses with "who" for lots of
;; nouns, so comment out, and let's find a better way to avoid generating
;; unwanted paraphrases wrt gender.
;;
#|
n_-_c_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_-_c-ed_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_-_mc-ed_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_pp_mc-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].

n_-_mc_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.GEN neut,
                                   SORT nonhuman ] ].
|#

; Also hour names
;; DPF 2016-06-25 - Motive for this redef not clear.
;; DPF 2018-11-23 - Block robust bare-sg.
;;
n_-_pn-hour_le := abstr_hour_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ --BARE -,
				--NUM + ],
                         VAL [ SPR < unexpressed >,
                               COMPS < #kcmp >,
			       KCMP #kcmp ] ],
             LEX - ] ].

;n_-_m-def_le_mal :=  n_-_m-def_lexent &
;  [ GENRE robust ].

;; Enable paraphrase of |in the summer| as |in summer|, where latter undergoes
;; the mass infl rule which stamps [GEN neut] on.
;;
n_-_m-ssn-spr_le :+
  [ SYNSEM.LOCAL [ CAT.HEAD.--BARE -,
		   CONT.HOOK.INDEX.PNG.GEN neut ] ].

; Considered blocking days of week from appearing as NP-adv
; but conflict between Strand3.C and sentencelist.C:
; "*Jenny plays chess Tuesday." but "She goes Saturdays."
;
;n_-_c-day_lexent := basic_n_intr_temp_lexent &
;  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN dofw_rel,
;                                       ALTMIN quant_or_wh_rel ],
;                         VAL.SPR < synsem > ],
;             MODIFD notmod,
;             LKEYS.ALTKEYREL.PRED quant_or_wh_rel ] ].

; Special class for "Mr." etc, since we exclude normal nouns as titles
n_-_c-pre-ttl_le := basic_basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ MODIFD notmod & [ LPERIPH na ],
             LOCAL [ CAT [ HEAD [ MINORS [ MIN pre_title_rel,
					   NORM norm_rel ],
				  --BARE - ],
			   VAL.SPR < [ --MIN abstract_q_rel ] > ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].


;; For wrong prep, as in |the reason of the mistake|
;;
n_pp_c_le_rbst := n_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
		   CONT [ RELS <! relation !>,
			  HCONS <! !> ] ],
    GENRE robust ].

n_pp_m_le_rbst := noun_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
           [ LOCAL [ CAT [ HEAD.--MALCM -,
			   VAL.COMPS < [ OPT - ] > ],
	   	     CONT [ RELS <! relation !>,
			    HCONS <! !> ] ],
             MODIFD notmod ],
    GENRE robust ].

;; Block robust regular plural rule for nouns like |people|
;; 
n_pp_c-pl_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT.RELS <! reg_diadic_nom_relation !>,
		   AGR.PNG png-irreg ] ].

;; Record mal-case for pronouns
;; Also mal-plural compound
;; DPF 2019-03-26 - Also generic proper name, to avoid robust proper |the|
nominal :+ [ --MALCASE bool,
	     --MALAGR luk,
	     --MALPLCPD bool,
	     --GENPROP bool ].

;; Block |An Alfred|
det_sg_nomod_lexent :+
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.--MIN non_proper_rel ].

;; Allow nouns to decline the robust a/an + mass-noun rule
basic_nom_or_ttl :+ [ --MALCM bool ].

d_-_sg-nmd-mal_le := basic_det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_unk ] >,
    GENRE robust ].

; "an information", "a homework"
;; DPF 2018-03-16 - Tried removing SPEC..--BARE + since this blocked robust 
;; analysis of |she gave him an advice|.  But we have to prevent ordinery
;; n_-_mc_le nouns from combining with this det.
;; DPF 2019-04-10 - Generalize ONSET to con_or_voc so we can also get misuse
;; of article with mass nouns where onset is also wrong, as in 
;; |we made an great progress|.
;;
#|
d_-_m-c_mal_lexent := det_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
			 VAL.SPEC < [ LOCAL [ CAT.HEAD [ --BARE +,
							 --MALCM + ],
					      AGR [ PNG.PN 3s,
						    DIV + ] ],
				      PHON.ONSET con_or_voc ] > ],
	     NONLOC.QUE 0-dlist ],
    GENRE robust ].
|#
d_-_m-c_mal_lexent := det_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
			 VAL.SPEC < [ LOCAL [ CAT.HEAD [ --MALCM + ],
					      AGR [ PNG.PN 3s,
						    DIV + ] ],
				      PHON.ONSET con_or_voc ] > ],
	     NONLOC.QUE 0-dlist ],
    GENRE robust ].

;; DPF 2019-04-10 - Generalize ONSET to con_or_voc so we can even get misuse
;; of article with mass nouns where onset is also wrong, as in 
;; |we made an great progress|.
;;
d_-_m-c-mal-a_le := d_-_m-c_mal_lexent.
d_-_m-c-mal-an_le := d_-_m-c_mal_lexent.

;; DPF 2017-09-24 - Redefine to remove identity of XARG and pron's ARG0,
;; because this conflicts with the use of XARG on the dtr in the np_adv rule
;; to impose matching tense constraints for e.g. |arose last year|.
;; DPF 2018-04-03 - Undid this change so we can get 
;; |we made up our minds what to eat| with reflexive idiom, noting that we
;; can still get robust |will arise last year|
#|
det_poss_lexent := basic_det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			        [ PRED pron_rel,
			  	  ARG0 [ PT std ] ] !> ].
|#

;; DPF 2018-11-14 - Add --POSSRBST so specific nouns such as |all| (as in
;; |we gave it our all|) can exclude robust poss for |we all|
;; DPF 2019-06-06 - Added --SBRDFRG to block fragment for |as he said, we arise|
;; DPF 2019-07-31 - Added --MALSPELL to prevent e.g. robust |back and forth|
;; DPF 2019-08-14 - Added --PASSNOBY to allow blocking of robust no-by passive
;;
head :+
  [ --POSSRBST bool,
    --SBRDFRG bool,
    --MALSPELL bool,
    --PASSNOBY bool ].

det_poss_lexent :+
 [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN def_poss_q_rel,
		  	     --POSSRBST #pr ],
		      VAL.SPEC.FIRST.LOCAL.CAT.HEAD.--POSSRBST #pr ] ].

adj_equi_bse_mal_synsem := basic_adj_equi_synsem & 
  [ LOCAL [ CAT [ HEAD adj,
		  VAL [ SPR.FIRST synsem &
				  [ --MIN more_or_very_deg_rel,
				    LOCAL.CAT.HS-LEX #hslex ],
			COMPS < [ LOCAL [ CAT.HEAD.VFORM bse,
					  CONT [ HOOK.LTOP #vhand ] ] ] > ],
		  HS-LEX #hslex ],
	    CONT [ RELS <! adj_relation !>,
		   HCONS <! qeq & [ HARG #hand,
				    LARG #vhand ] !> ] ],
    MODIFD notmod,
    LKEYS.KEYREL.ARG2 handle & #hand ].

adj_vp_bse_mal_lr := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM reg_adj_equi_synsem &
	         [ LOCAL [ CAT [ HEAD #head,
				 VAL [ SUBJ #subj,
				       SPR #spr,
				       SPCMPS #spcmps ] ],
                           CTXT #ctxt ],
		   NONLOC #non-local,
		   MODIFD #modif ] ],
    SYNSEM adj_equi_bse_mal_synsem &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL [ SUBJ #subj,
				SPR #spr,
				SPCMPS #spcmps ] ],
		    CTXT #ctxt ],
	    NONLOC #non-local,
	    MODIFD #modif ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    GENRE robust ].

;; Block noun-noun compounds such as |movie five times|
;; DPF 2017-12-22 - But we want |the other five times|, and the adj-adjn rule
;; needs the head to be LPERIPH na, so allow |movie five times| for now.
;;
;adj_bare_unspecified_card_lexent := basic_adj_bare_unspecified_card_lexent &
;  [ SYNSEM.MODIFD.LPERIPH bool ].

; Remove COMPS..--BARE - since we want to flag "She is good student"
;; DPF 2015-04-22 - Add unif of PNG.PN for subj and comp, to block spurious
;; analysis of |they are late school|.  We'll also have to make adjustment to
;; group nouns like "team" so their INDEX.PNG.PN can be either sg or pl, even
;; though AGR..PN is 3s.
;; DPF 2016-07-15 - Re 2015-04-22: But this also blocks |these trips are a
;; good excuse to avoid work|.  So let's try matching AGR..IND instead, and 
;; adjust lexical entries for `idea, excuse, suggestion' etc so their INDEX..IND
;; is distinct from AGR..IND.
;; DPF 2016-12-02 - Re 2016-07-15: But this blocks |my favorite subject is math|
;; so let's give up on fiddling with PN or IND identity, and instead notice that
;; the problem is with modification of |school| here, since we also want to
;; block |*Kim attends good school|.  
;; DPF 2017-05-17 - Block extraction to avoid spurious analysis for e.g.
;; |I spotted a lizard it was awesome|
;; DPF 2017-08-17 - Re 2017-05-17: But this blocks use of identity copula in
;; relative clauses, as in |the student who is the president|.  So instead
;; constrain the complement's SLASH.
;; DPF 2018-03-06 - Re 2017-08-17: But we want extraction for |we revealed it
;; for what it was|.  So let's instead settle for signaling that depictive
;; |... awesome| as robust.
;; DPF 2019-06-05 - Add hack feature --COPID + so we can block purposive to-VP
;; attachment in |it is a good time to disappear|.
;;
be_id := be_verb &
  [ SYNSEM aux_np_verb &
     [ LOCAL [ CONT [ HOOK.INDEX #event,
		      RELS.LIST.FIRST.ARG0 #event ],
	       CAT [ HEAD.--COPID +,
	             VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
			   COMPS < [ LOCAL 
			   	      [ CAT.HEAD.--MALCASE -,
			   	        CONT.HOOK [ LTOP #ltop,
			                            XARG non_event ]]] > ]]],
       LKEYS.KEYREL [ LBL #ltop,
		      PRED _be_v_id_rel ] ] ].

; From auxverbs - Restrict number on COMPS for singular identity copula.
; Also prevent bare-sg NP subjects
;; DPF 13-03-14 - But blocking bare subjs prevents robust analysis of e.g.
;; |cat is a furry animal|  So remove, and let's see what happens.
;; DPF 2019-04-24 - Add COMPS..--MALAGR - to avoid robust |they are children|.
be_id_pos := be_id &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.TAM.ASPECT.PROGR -,
			   VAL.COMPS.FIRST.LOCAL.CAT.HEAD.--MALAGR na_or_- ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

;; Match TAM on complement and head, to enable matching of tenses in clauses
;; 2018-09-13 - Block bare-sg analysis for |I know that book is boring|
;;
cm_np-vp_that_le :+
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM #tam,
		       VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.TAM #tam,
		                               CONT.HOOK.XARG.--BARESG - ] ] ].

;; Undo this 3s constraint since we want e.g. |the population is 4 million|
#|
v_np_is_le := be_is_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3s ] > ].
|#

;; Remove GENRE nonformal so we can generate contracted forms even with
;; root_strict.  Also constrain COMPS.FIRST to canonical_synsem so we avoid
;; generating stranded contractions like |Here he's|, even though this also
;; means we won't generate |Where's Kim?|.
;;
contracted_aux_word := word &
  [ INFLECTD na,
    ALTS [ VPELLIP -,
           SQPNCT -,
	   CSAI - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST canonical_synsem ].

; Add COMPS..--BARE - here to avoid spurious analysis for e.g.
; |the team's goalie kept running|
v_np_is-cx_le := be_is_lex_entry & be_id_pos & contracted_aux_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.--BARE -,
					   AGR.PNG.PN sg ] ] > ].

v_np_are_le := be_are_lex_entry & be_id_pos.

v_np_are-cx_le := be_are_lex_entry & be_id_pos & contracted_aux_word.

;; DPF 2018-02-15 - Can't simply require sg NP complement, since we also want
;; |when I was ten|.
#|
v_np_was_le := be_was_lex_entry & be_id_pos &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN sg ] > ].
|#
v_np_was_le := be_was_lex_entry & be_id_pos.

v_np_wre_le := be_were_lex_entry & be_id_pos.

;; Avoid misanalysis in possessive NPs such as |in the cat 's mouth|
;;
basic_loc_inv_be_word := loc_inv_verb_word &
  [ INFLECTD +,
    SYNSEM loc_inv_be_synsem &
	     [ LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CAT.HEAD.--BARE - ] ] ].

;; Block APs as subjects
;;
loc_inv_be_word := basic_loc_inv_be_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD -,
				  TAM.MOOD indicative ],
			   VAL [ SUBJ < [ LOCAL [ CAT.HEAD v_or_p,
			                        CONT.HOOK [ LTOP #ltop,
                                                          INDEX #ind &
                                                             [ E.TENSE tense ],
                                                          XARG #xarg ] ] ] >,
				 COMPS < [ --SIND #xarg ] > ],
			   POSTHD - ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #ind & [ SF prop-or-ques ],
				   XARG #xarg ],
			    RELS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

; From syntax.tdl

;; Restrict nonhead to MIN pre_title_rel.
;; DPF 2018-03-30 - But this blocks e.g. |game 6|, so reconsider and FIX
;;
#|
np_title_cmpnd_phr := basic_np_title_cmpnd_phr &
  [ HD-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR < [ OPT - ] >,
			  CONT.HOOK [ LTOP #lbl,
			              INDEX.PNG.GEN #gen ] ],
    NH-DTR.SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN pre_title_rel,
    			  CONT.HOOK.INDEX.PNG.GEN #gen ],
    C-CONT.RELS.LIST.FIRST.LBL #lbl ].
|#
;; DPF 2018-11-23 - Block |work Keren|
;;
np_title_cmpnd_phr :+
  [ HD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN #gen,
    NH-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN #gen ].



; Exclude reflesives as non-heads: |*They themselves|
;; DPF 2014-01-21 - But now we want to allow these, in Grade 7.
#|
basic_appos_np_phr := norm_appos_phr &
  [ HD-DTR.SYNSEM.MODIFD.RPERIPH bool,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN nonpro_rel,
			      VAL.SPR *olist* ],
    C-CONT [ RELS <! relation !>,
             HCONS <! !> ] ].
|#


;; Block "a Sunday" but allow "next Tuesday"
;; Note that this blocks items in StrandG_2-4 such as
;; "The fair is on a Saturday."
;; So maybe reconsider?
;; Yes, undo, since we also want "on the last Tuesday in May"
;;
;;n_-_c-dow_le := n_-_c-day_lexent &
;;  [ SYNSEM [ LKEYS.KEYREL.PRED dofw_rel,
;;             LOCAL.CAT.VAL.SPR < [ --MIN impl_or_proper_q_rel ] > ] ].

;; Add strange E.SAME-PAST + to block robust |Tuesday next week|
n_-_c-dow_le := n_-_c-day_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED dofw_rel,
	     LOCAL [ CAT.HEAD.--BARE -,
		     CONT.HOOK.INDEX.E.SAME-PAST + ],
             MODIFD notmod_or_rmod ] ].


;; DPF 2017-09-27 - Add boolean UNSP-TENSE for modals such as |should| which
;; are unmarked for tense, but don't want to combine with robust subord or
;; clause-taking verbs to trigger tense mismatch in clauses.
;; DPF 2017-09-28 - Also added IRR-TENSE so we can trigger robust |we had went|
;; but not for |we had arrived|.
;; DPF 2017-12-20 - Added SAME-PAST for verbs such as "cut, hit", so we can
;; avoid triggering mismatched tense with modifiers such as "yesterday".
;;
tam :+
 [ UNSP-TENSE bool,
   IRR-TENSE bool,
   SAME-PAST bool ].

;; DPF 2017-09-27 - Mark these as unmarked for tense, so the robust past tense
;; verbs taking nonpast-tense-CPs don't spuriously combine with these, as in
;; |we felt he would arrive|
v_vp_mdl-p-unsp_le := modal_pos_lex_ent &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD.TAM.UNSP-TENSE +,
    ALTS.CSAI - ].

v_vp_mdl-p-cx_le := modal_pos_indic_lexent & contracted_aux_word &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.UNSP-TENSE + ].

v_vp_mdl-p-sv_le := modal_pos_lex_ent &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD.TAM.UNSP-TENSE + ].

v_vp_mdl-n-sv_le := modal_verb_word & generic_modal_neg & 
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.UNSP-TENSE +,
		       VAL.COMPS.FIRST canonical_or_unexpressed ] ].

v_vp_mdl-n-untns_le := va_modal_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.UNSP-TENSE +,
		       VAL.COMPS.FIRST canonical_or_unexpressed ] ].

; Add feature for blocking mal-3sg and mal-n3sg, and also mal-past
; Also identify modal verbs, so we can avoid robust |We wish he would stay|
vc_add :+ [ --MAL3SG bool,
            --MALN3SG bool,
	    --MALPAST bool,
	    --MODAL bool ].

; Change CASE from obliq to non_obliq to block "to home"
n_-_ad-pl-nomod_le := norm_np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
				CASE non_obliq,
				--BARE - ],
		     CONT.HOOK.INDEX [ SORT place,
				       PNG.GEN neut ] ],
	     MODIFD.RPERIPH + ] ].

; Related: relax constraint on complement of `from' to still get `from now on'
p_np-ptcl_i_le := p_ditrans_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT nomp_cat_nonnom_min,
                                             CONT.HOOK.INDEX index ] ],
                                   [ LOCAL [ CAT.VAL.COMPS < synsem >,
                                             CONT.HOOK.LTOP #ltop ],
                                     NONLOC non-local_none,
                                     LEX + ] >,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! relation !>,
                          HCONS <! !> ] ] ].



ssr_bse_verb := verb_synsem & ssr_subst & bse_intrans_subst &
  [ LOCAL [ CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		      KCMP.LOCAL.CONT.HOOK [ LTOP #chand ] ],
	    CONT [ HOOK [ LTOP #ltop ],
		   RELS <! #keyrel !>,
		   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg1_relation & #keyrel & [ ARG1 handle & #arghand ] ].

ssr_bse_noimp_verb := ssr_bse_verb & 
  [ LOCAL.CAT.HEAD.VFORM fin_or_non_fin ].

;; |she is done to sing|
;; but not |she is too busy to sing|
aj_vp_i-seq-prp_le_rbst := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
                       VAL.SPR.FIRST.--MIN very_deg_rel ],
    GENRE robust ].

;; |Kim is capable to do that|
aj_vp_i-seq-pp_le_rbst := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel,
    GENRE robust ].

;; For adverbs mistakenly used as attrib adjectives, need lexical rule
;; FIX

;; DPF 2018-03-07 - Need to block robust bare singular for second complement,
;; as in |Mario saves the baby mouse.|   But we want |we gave him an advice|
;; so instead of --BARE, use --BARED -.
;; DFP 2019-11-06 - This general constraint is too strong, since it prevents
;; analysis of |He leaves tourists profound impression.|  So let's instead
;; impose the restriction just on the verb "save" for now.
;;
#|
ditrans_verb :+
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL.CAT.HEAD.--BARED - ] > ].

ditrans_only_verb :+
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL.CAT.HEAD.--BARED - ] > ].
|#


; Restrict dtrs to --MAL3SG - to avoid robust intranstives as conjuncts.
;; DPF 13-03-14 - But this blocks flagging of subj-verb agrmt errors as in 
;; |he arise and arrives|.  So remove, and hope for better parse ranking.
#|
basic_v_coord_phr := basic_verbal_coord_phr &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                MINORS #mins,
                                --ADDIN #addin ],
                         VAL [ SUBJ < synsem &
				    [ LOCAL [ CAT #cat,
					      AGR #agr ],
				      NONLOC #nonloc,
				      --SIND #sind,
				      OPT #opt ] >,
			       SPR #spr ] ],
		   CONT.HOOK.XARG #xarg ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                          TAM.MOOD #mood,
                                          --ADDIN #addin & [ ADDPN #pn ],
					  --MAL3SG - ],
                                   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						OPT #opt ] >,
					 SPR #spr ] ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                          TAM.MOOD #mood,
                                          MINORS #mins,
					  --ADDIN.ADDPN #pn,
					  --MAL3SG - ],
				   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						OPT #opt ] >,
					 SPR #spr ] ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    C-CONT.HCONS <! !> ].
|#

;; Block spurious application in ordinary multi-part coord
basic_v_coord_top_noconj_phr :+
  [ ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX non_conj_event ], 
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX non_conj_event ] > ].

;; Allow robust pre-modifiers like 'today'

av_-_i-vp-pr_le_rbst := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
				    --ADVADJ -,
                                    MOD < [ LOCAL.CAT.HEAD verb &
				                           [ VFORM fin ],
                                            MODIFD.LPERIPH na_or_- ] > ],
                       POSTHD - ],
    GENRE robust ].

;; Correcting |we almost have arrived| by normally blocking these on aux VPs
av_-_i-vp-pr_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.AUX - ].

av_-_i-vp-pr-aux-nfin_le := av_-_i-vp-pr_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD verb &
						   [ AUX +,
						     VFORM non_fin ] ].

;; |we already have arrived|
av_-_i-pr-aux_le_rbst := av_-_i-vp-pr_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD.FIRST.LOCAL.CAT.HEAD verb &
						     [ AUX +,
						       VFORM fin ],
			    --ADVADJ -,
			    MINORS.NORM norm_rel ],
    GENRE robust ].

;; Post-head adv used pre-head: |the cat was bad treated|
;; Can't restrict MOD..HEAD to verb, since we need it for 
;; |the bad-treated pets| where `treated' has been converted to adj.
;;
av_-_i-po-pr_le_rbst := av_-_i-vp-pr_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD.FIRST.LOCAL.CAT.HEAD v_or_a,
			    --ADVADJ - ],
    GENRE robust ].

; Allow robust post-VP adverbs: "He sang bad"
;
av_-_i-vp-po_mal_lexent := int_vp_adverb_word & 
  [ SYNSEM [ LOCAL.CAT [ HEAD adv_nonmob & 
                              [ MINORS.MIN adv_rel,
				--ADVADJ -,
				MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
					MODIFD.RPERIPH na_or_- ] > ],
			 POSTHD + ],
             MODIFD hasmod ],
    GENRE robust ].

;; For |good/bad|, which need special handling
av_-_i-vp-po_le_mal := av_-_i-vp-po_mal_lexent.
av_-_i-vp-po_le_rbst := av_-_i-vp-po_mal_lexent.


; restrict to only VP mods
av_-_i-vp-po-nmb_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob & 
                            [ MINORS.MIN adv_rel,
                              MOD < [ LOCAL.CAT.HEAD verb &
			                     [ MINORS.ALTMIN non_ellipt_rel ],
                                      MODIFD.RPERIPH na_or_- ] > ],
                       POSTHD + ] ].

;; Avoid misanalysis of |this problem is hard|
av_-_i-vp-po_le :+
 [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN non_ellipt_rel].

;; Allow robust comparative specifier with comparative adverb: |more faster|
;;
av_-_i-vp-cmp_le_rbst := basic_adverb_word &
  [ SYNSEM intersect_vp_adverb_synsem &
           [ LOCAL.CAT [ VAL.SPR.FIRST [ --MIN more_deg_rel,
					 OPT - ],
			 HEAD.--ADVADJ -,
			 POSTHD + ] ],
    GENRE robust ].

;; For adjectives with -ly suffixes easly mistaken for adverbs: 
;; |friendly, leisurely|
av_-_i-vp-adj_le_rbst := av_-_i-vp_lexent &
 [ SYNSEM.LOCAL.CAT.HEAD [ MOD.FIRST.LOCAL.CAT.HEAD verb &
					       [ MINORS.ALTMIN non_ellipt_rel ],
			   --ADVADJ - ],
   GENRE robust ].

;; |we very admire her|
av_-_i-vp-dg_le_rbst := av_-_i-vp_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD verb & 
						   [ VFORM fin_or_inf_or_imp ],
				    MODIFD notmod_or_rmod ] >,
		       POSTHD - ],
    GENRE robust ].

; Block robust |better than losing|
aj_pp_i-cmp_le := norm_adj_comp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.NORM norm_rel ].

;; Same for comparative adjectives: |more shorter|
;;
aj_-_i-cmp_le_rbst := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
		       VAL.SPR.FIRST expressed_synsem &
				     [ --MIN more_deg_rel,
				       OPT - ] ],
    GENRE robust ].

;; Wrong form for comparative: |gooder|
;;
aj_pp_i-cmp_le_rbst := norm_adj_comp_lexent &
  [ GENRE robust ].

;; DPF 2017-09-21
;; Block these in non-subject position to enable mal-rule analysis of
;; |he brought many good news for us|

#|
aj_-_i-many_le := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL [ AGR.PNG.PN 3p,
					    CONT.HOOK.INDEX.IND + ],
				    MODIFD.LPERIPH - ] >,
			    CASE nom ] ].

partitive_num_nocomp_rule := partitive_num_nocomp_phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.CASE #case ] > ].
|#

;; Block robust |some are|
partitive_noun_nocomp_synsem :+
  [ LOCAL.CAT.HEAD.--BARE - ].

;; DPF 2017-09-26 - Prevent spurious robust analysis of |a few cats|
;aj_-_i-many_le :+
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.--BARE - ].

;; Add robust type for |many news, many information|
;; Added HEAD.--BARE + to prevent |many fish|
;;
aj_-_i-many_le_rbst := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < expressed_synsem &
				  [ LOCAL [ AGR [ PNG.PN 3s,
						  DIV + ],
					    CAT.HEAD.--NOSUFF - ],
				    MODIFD.LPERIPH na_or_- ] > ],
    GENRE robust ].

;; Make COMPS..HEAD be reg_adv to allow |he did well|
;;
adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
			    [ LOCAL 
			      [ CAT [ HEAD reg_adv &
                                       [ MOD < [ LOCAL intersective_mod &
						[ CONT.HOOK.INDEX #event ]] > ],
				      VAL [ SPR *olist*,
                                            COMPS < > ],
				      POSTHD + ],
                                CONT.HOOK.LTOP #hand ],
                              NONLOC.REL 0-dlist,
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

;; Allow no punct on left dtr
np_city_state_phr := norm_np_name_cmpnd_phr &
  [ SYNSEM [ MODIFD notmod,
	     PUNCT [ LPUNCT #lpunct,
		     RPUNCT #rpunct,
		     RCLSTR #rclstr ] ],
    HD-DTR.SYNSEM [ MODIFD notmod & [ LPERIPH + ],
		    LOCAL [ CAT [ HEAD.MINORS.MIN named_np_or_num_rel,
				  VAL.SPR < [ OPT - ] > ],
			    CONT.HOOK.LTOP #hdltop ] ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN named_np_or_num_rel,
						NORM norm_rel ],
				  VAL.SPR.FIRST.LOCAL.CAT.HEAD adv ],
			    CONT.HOOK.INDEX.SORT entity ],
		    MODIFD notmod_or_rmod,
                    PUNCT [ LPUNCT lparen_or_dq_or_no_punct,
			    RPUNCT comma_or_no_punct ] ],
    C-CONT [ RELS <! [ PRED compound_rel,
		       LBL #hdltop ] !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    ARGS < [ SYNSEM.PUNCT.LPUNCT #lpunct ],
           [ SYNSEM.PUNCT [ RPUNCT #rpunct,
                            RCLSTR #rclstr ] ] > ].

;d_-_the-mal_le := d_-_the_lexent &
;  [ GENRE robust ].

;; Add rels for lexicalized adverb phrases
_above+ground_p_rel := miscprep_rel.
_at+anywhere_p_rel := miscprep_rel.
_at+home_p_rel := miscprep_rel.
_at+there_p_rel := miscprep_rel.
;; For {from branch by branch|
_by_p_nbar_rel := prep_mod_rel.
_day+to+day_p_rel := miscprep_rel.
_day+by+day_p_rel := miscprep_rel.
_during+break_p_rel := miscprep_rel.
_face+to+face_p_rel := miscprep_rel.
_in+anytime_p_rel := miscprep_rel.
_in+everyday_p_rel := miscprep_rel.
_in+home_p_rel := miscprep_rel.
;; For {from branch on branch|
_on_p_nbar_rel := prep_mod_rel.
_out+of+bed_p_rel := miscprep_rel.
_to+bed_p_rel := miscprep_rel.
_to+home_p_rel := miscprep_rel.
_up+and+down_p_rel := dir_rel.
_upside+down_p_rel := miscprep_rel.

_longer_n_1_rel := time_n_rel.

;; Add hack empty rel for "mop clean the floor"
_clean_a_sel_rel := selected_adj_rel.
;; Also for |they took part in|, |they took advantage on|
_in_p_mal-sel_rel := selected_prep_rel.
_on_p_mal-sel_rel := selected_prep_rel.

;; Constrain to non-nominative, to avoid spurious analysis of e.g.
;; "what do Kim and Abrams ..."
;; DPF 2018-03-29 - But this blocks |what we liked best was Rome|.  So remove
;; CASE, but leave agreement constraint.
;; DPF 2019-01-17 - But singular blocks |what he likes are cats and dogs|,
;; so remove this too.
#|
n_-_pr-fr_le := n_freerel_pro_lexent &
  [ SYNSEM.LOCAL [ CONT.RELS.LIST.FIRST.PRED free_relative_q_rel,
		   AGR.PNG.PN 3s ] ].
|#

;; Avoid robust bare plural for |who|
n_wh_pro_lexent :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

;; Constrain "what" to singular, to avoid spurious analysis of 
;; "what do Kim and Abrams ..."
;; 2019-06-20 - But this blocks |Victories are what impress Kim|, so
;; find another way to block above.
#|
n_-_pr-wh_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s ].
|#

;; DPF 2017-10-07 - Don't see what this change was for, but it lost constraint
;; on the complement NP being saturated, which meant losing non-local constraints.
;;
;p_np_ptcl-of_le := p_prtcl_lexent &
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.--BARE - ] > ].

; Prevent analysis for "with her cousins"
p_np-np_s-ncop_le := noncqrs-nab &
  [ SYNSEM subconj_with_np_np_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN #pn ],
	                           [ LOCAL.AGR.PNG.PN #pn ] > ] ].

;; DPF 2017-09-23 - Prevent (pre-)modif of VPs, to avoid spurious robust 
;; analysis of |while she was [babysitting she] fed food to the baby.
;;
subconj_synsem := subconj_cp_synsem & 
  [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.VAL.SUBJ *anti_list*,
		VAL.COMPS < [ LOCAL [ CAT s_cat_unspec & 
					[ MC -,
					  HEAD verb & [ VFORM fin_or_imp ] ],
				      CONT.HOOK.INDEX.SF prop-or-comm ],
			      --SIND.E.TENSE real_tense ] > ] ].

;; Preserve TAM.TENSE of complement on head, so e.g. robust post-subconj "and"
;; can avoid attaching to |while S |
subconj_word :+
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.TENSE #tense,
		       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.TAM.TENSE #tense ] ].

;; DPF 2017-09-21 - Require tense in main and subord clauses to match
;; |She was serious when she tells us the story|

p_cp_s_le := subconj_word &
  [ SYNSEM subconj_ind_synsem &
	   [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE nonpast,
			 VAl.COMPS < [ LOCAL.CAT s_cat_fin ] > ] ] ].

p_cp_s-past_le := subconj_word &
  [ SYNSEM subconj_ind_synsem &
	   [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE past,
			 VAl.COMPS < [ LOCAL.CAT s_cat_fin &
						 [ HEAD.TAM.TENSE past ]]>]]].
p_cp_s_le_rbst := subconj_word &
  [ SYNSEM subconj_ind_synsem &
	   [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM [ TENSE past,
							     UNSP-TENSE - ],
			 VAl.COMPS < [ LOCAL.CAT s_cat_fin &
					     [ HEAD.TAM [ TENSE nonpast,
							  UNSP-TENSE - ]]]>]],
    GENRE robust].

;; For at least |because|, allow with mismatched tenses
p_cp_s-tns_le := subconj_word &
  [ SYNSEM subconj_ind_synsem &
	   [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM [ TENSE past,
							     UNSP-TENSE - ],
			 VAl.COMPS < [ LOCAL.CAT s_cat_fin &
					     [ HEAD.TAM [ TENSE nonpast,
							  UNSP-TENSE - ]]]>]] ].

;; For nonformal |till, til, 'til|
p_cp_s-notop_le_nf_rbst := subconj_word &
  [ SYNSEM subconj_synsem & 
           [ LOCAL.CAT.VAL [ SPR < [ --MIN just_only_notvery_deg_rel ] >,
			     COMPS < [ LOCAL.CAT.HEAD [ CASE obliq,
							VFORM fin ] ] > ] ],
    GENRE robust ].

p_cp_s-notop_le := subconj_word &
  [ SYNSEM subconj_synsem & 
     [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE nonpast,
		   VAL [ SPR < [ --MIN just_only_notvery_deg_rel ] >,
			 COMPS < [ LOCAL.CAT.HEAD [ CASE obliq,
						    VFORM fin ] ] > ]]]].

p_cp_s-notop-past_le := subconj_word &
  [ SYNSEM subconj_synsem & 
     [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE past,
		   VAL [ SPR < [ --MIN just_only_notvery_deg_rel ] >,
			 COMPS < [ LOCAL.CAT.HEAD [ CASE obliq,
						    VFORM fin,
						    TAM.TENSE past ] ] > ]]]].

p_cp_s-notop_le_rbst := subconj_word &
  [ SYNSEM subconj_synsem & 
     [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM [ TENSE past,
						       UNSP-TENSE - ],
		   VAL [ SPR < [ --MIN just_only_notvery_deg_rel ] >,
			 COMPS < [ LOCAL.CAT.HEAD [ CASE obliq,
						    VFORM fin,
						    TAM [ TENSE nonpast,
							  UNSP-TENSE - ]]] >]]],
    GENRE robust ].


p_cp_s-unsp_le := subconj_word &
  [ SYNSEM subconj_synsem &
    [ LOCAL.CAT [ HEAD [ PRD -,
			 MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE nonpast ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS < [ LOCAL.CAT.HEAD [ VFORM fin ] ] > ]]]].

p_cp_s-unsp-past_le := subconj_word &
  [ SYNSEM subconj_synsem &
    [ LOCAL.CAT [ HEAD [ PRD -,
			 MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE past ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS < [ LOCAL.CAT.HEAD [ VFORM fin,
						   TAM.TENSE past ] ] > ]]]].

p_cp_s-unsp_le_rbst := subconj_word &
  [ SYNSEM subconj_synsem &
    [ LOCAL.CAT [ HEAD [ PRD -,
			 MOD.FIRST expressed_synsem &
			           [ LOCAL.CAT.HEAD.TAM [ TENSE past,
							  UNSP-TENSE - ] ] ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS < [ LOCAL.CAT.HEAD [ VFORM fin,
						   TAM [ TENSE nonpast,
							 UNSP-TENSE - ]]] > ]]],
    GENRE robust ].

mal_v_inf_cp_comp_le := main_verb_mliszt &
   [ SYNSEM mal_v_inf_cp_comp_verb &
       [ LOCAL.CAT [ VAL.COMPS < [ OPT - ] > ] ],
     GENRE robust ].

mal_va_does_le := do_pres & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN 3s ] ] >,
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

va_doesnt_neg_pres_le_rbst := do_aux_neg_pres & 
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ.FIRST.LOCAL.CAT.HEAD.--BARE +,
                   AGR.PNG png & [ PN 3s ] ],
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

va_dont_neg_pres_le_rbst := do_aux_neg_pres &
  [ SYNSEM.LOCAL.AGR.PNG png & [ PN -3s ],
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

mal_va_do_fin_le := do_pres &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ --SIND.PNG png & [ PN -3s ] ] >,
    ALTS [ VPELLIP -,
	   ADVADD - ],
    GENRE robust ].

mal_va_has_le := has_aux_lex_ent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_va_have_fin_le := have_fin_aux_lex_ent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

v_vp_has-n_le_rbst := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL [ AGR.PNG.PN -3s,
            	   CAT.VAL.COMPS.FIRST expressed_synsem ],
    ALTS.VPELLIP -,
    GENRE robust ].

v_vp_have-f-n_le_rbst := have_aux_neg_lex_entry & have_pres & 
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3s,
             	   CAT.VAL.COMPS.FIRST expressed_synsem ],
    ALTS.VPELLIP -,
    GENRE robust ].

;; Add parent def_udef_some_a_no_q_rel to enable mal-there-cop as in
;; |there are two cat|
;;
num_q_rel := num_or_demon_q_rel & indef_or_num_q_rel &
	     both_all_udef_q_rel & meas_or_numq_rel &
	     def_udef_some_a_no_q_rel.

;; Restricted COMPS..MIN from non_temp_nom_rel to norm_nom_rel in order to
;; exclude numbers as in |there are eight|
;; DPF 2018-10-02 - COMPS..NORM no_rel prevents |there are a bad thing| since 
;; `thing' is norm_rel.  So remove, monitor, and FIX?
;;
mal_vc_there_synsem := there_cop_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST expressed_synsem &
                              [ LOCAL.CAT.HEAD.MINORS 
			         [ MIN norm_nom_rel,
				   ALTMIN def_udef_some_a_no_q_rel ] ] ].

mal_vc_there_is_le := vc_there_are_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    INFLECTD +,
    SYNSEM mal_vc_there_synsem &
           [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX nonconj_ref-ind &
							     [ PNG.PN 3p,
	                                                       DIV + ] ] ].

mal_vc_there_are_le := vc_there_is_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    INFLECTD +,
    SYNSEM mal_vc_there_synsem ].

mal_vc_there_was_le := vc_there_were_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    INFLECTD +,
    SYNSEM mal_vc_there_synsem &
           [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.AGR nonconj_ref-ind &
							     [ DIV + ] ] ].

mal_vc_there_were_le := vc_there_was_lexent &
  [ GENRE robust,
    ALTS.VPELLIP -,
    INFLECTD +,
    SYNSEM mal_vc_there_synsem &
	  [ LOCAL.CAT.HEAD.--MAL3SG + ] ].

v_np-xp_is-n_le_rbst := be_are_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

v_np-xp_are-n_le_rbst := be_is_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

v_np-xp_was-n_le_rbst := be_were_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

v_np-xp_were-n_le_rbst := be_was_neg_contr_lex_entry & be_th_cop_neg &
  [ GENRE robust ].

;; DPF 2012-08-17 - Removed SLASH 0-dlist from SUBJ for these, since we
;; want |the bear who are admired|.  Maybe we'll recall why this was added.
;; DPF 2019-04-10 - Removed SUBJ..DIV + since this prevents 
;; |You and I is arising|.

mal_vc_prd_is_le := vc_prd_are_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST expressed_synsem & 
                                    [ LOCAL.AGR.PNG.PN pl ],
    GENRE robust ].

;; Added SUBJ..MIN norm_nom_rel to avoid use in |three are on the table|
;; DPF 2018-03-29 - But this blocks robust |he are tall|, so instead
;; constrain via --NUM.
;; Removed SUBJ.--BARE + since it blocks |the style are different|, so
;; to block robust |three are happy| with np-num, constrain to RPERIPH na_or_-.
;; DPF 2018-11-07 Re 2018-03-29: But mass nouns are RPERIPH +, so we don't get
;; robust |information are available|.  At present, number NPs and mass nouns 
;; are not very different, so we may need to add some hack property to numbers
;; to block them with pred copula.  Let's see how often ranking fails and FIX.
;; DPF 2019-09-14 - Make SUBJ.._BARE bool, to exclude free relatives as in
;; |what attract tourists are ...|
;;
mal_vc_prd_are_le := be_pres_lex_entry & be_cop_pos &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL [ CAT [ VAL.SUBJ.FIRST [ LOCAL [ AGR.PNG png-reg & [ PN 3s ],
						  CAT.HEAD [ --NUM -,
							     --NOSUFF -,
							     --BARE bool ] ],
					  --SIND.SORT entity-or-nomevent ],
			 HEAD.--MAL3SG + ],
		   AGR.PNG png & [ PN 3s ] ],
    GENRE robust ].

mal_vc_prd_was_le := vc_prd_were_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST expressed_synsem & 
    				    [ LOCAL.AGR [ PNG.PN pl,
    				                  DIV + ] ],
    GENRE robust ].

mal_vc_prd_were_le := vc_prd_was_lexent &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL.CAT [ HEAD.--MAL3SG +,
                       VAL.SUBJ.FIRST [ LOCAL [ AGR.PNG.PN sg,
						CAT.HEAD [ --NUM -,
						           --NOSUFF - ] ],
					--SIND.SORT entity,
					MODIFD.LPERIPH bool ] ],
    GENRE robust ].

; Treat robust "be" and "been" as VFORM prp, so they trigger the robust
; subj-head rule which needs to avoid allowing ordinary base form verbs
; (identical to non-3sg) and ordinary past participles (identical to 
; past tense).
mal_vc_prd_be_le := vc_prd_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM fin,
			    --MAL3SG + ],
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_np_be_le := vc_np_be_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_prd_been_le := vc_prd_been_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

mal_vc_np_been_le := vc_np_been_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin,
    INFLECTD +,
    ALTS.VPELLIP -,
    GENRE robust ].

#|
;; Not used
mal_det_div_le := det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.MIN
                                                     just_only_deg_rel ] >,
                     AGR.PNG.PN 3s ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s ],
                                 DIV + ],
	     MODIFD hasmod ],
    GENRE robust ].
|#

; 'they/that'
#|
mal_n_deictic_pro_le := n_deictic_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p,
                                           GEN neut ] ] ].
|#

mal_det_pl_le := det_pl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAt.HEAD.--BARE -,
    GENRE robust ].

mal_n_plur_ppcomp_le := n_plur_ppcomp_lexent &
  [ GENRE robust ].

; (ERB 2003-10-17) For verbs like "allow" taking a CP[to]
; complement with the PRO bound to arbitrary reference.  Regenerate
; with gerunds instead.  (Might need another class where we
; regenerate with an inserted pronoun "one", if there are verbs
; that show up in this pattern but can't take gerund complements.)

; (ERB 2003-10-17) This is going to be a fairly strange verb type.  I
; can't think of any true English verbs off hand that take an
; infinitival CP complement and allow arbitrary control of the subject
; of that complement.  Furthermore, this type is also putting in some
; extra semantics, in order to allow the right string to come back
; from the generator.  So, we're not inheriting from the usual places
; in the hierarchy.  For example, main_verb is constrained to have a
; single element RELSs list.  main_verb_mliszt will do, though,
; although this isn't what it was intended for. Likewise, I don't
; think any of the linking types lower in the hierarchy will do what
; we want.  Took some constraints from subj_equi_inf_lt to try to
; restrict what can show up as the complement.

; (ERB 2003-10-23) Can't currently generate with these entries,
; and I don't know why.  Can generate from the produced MRS at all,
; in fact.  The MRS produced isn't the same as the MRS for the target,
; because of gerunds are built from progressives and therefore have
; a different value for PROGR.  (There are some other mismatches,
; but they are compatible, so maybe it would work otherwise.)
; While we might consider changing the analysis of gerunds, I
; think the main conclusion to draw is that we will need some kind
; of a transfer component.  Maybe put everything there rather than
; trying to map from mal-formed syntax to well-formed semantics in
; the grammar itself?  If not everything, how to decide when to do
; which?

mal_v_inf_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & basic_two_arg & 
			  norm_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  abstract_quant_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].
	   
#|
mal_v_inf_from_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & 
			       basic_two_arg & norm_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  abstract_quant_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].
|#

_they+that_q_mal_rel := demonstrative_q_rel.

;; Mal NI (but not CE) rules, for lack of do support:

mal_adv_addition := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.AUX - ].

mal_sai_synsem := basic_sai_synsem & 
  [ LOCAL.CAT.HEAD.AUX - ].

; (ERB 2003-08-15) sai seems to be constraining its input
; to be INV +, rather than AUX +.  So, moving that constraint down
; to sai, and putting the opposite thing on mal_sai.
; (ERB 2003-08-15) Adding AUX - to DTR to keep auxiliaries out
; of this mal-rule.

mal_sai := basic_sai &
  [ SYNSEM mal_sai_synsem,
    DTR.SYNSEM.LOCAL.CAT.HEAD [ AUX -,
				INV - ] ].

mal_finvp_rule := basic_unary_phrase & rule &
  [ INFLECTD +,
    GENRE robust,
    SYNSEM [ LOCAL [ CAT [ HEAD frag,
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
                           MC + ],
                     CONJ cnil ],
             NONLOC non-local_none ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VFORM fin,
                                                  INV - ],
                                    VAL [ SUBJ < unexpressed_reg >,
                                          COMPS *olist* ] ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX #event,
                                          XARG #arg0 ],
                              AGR.PNG #png ],
                      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                  REL 0-dlist,
                                  QUE 0-dlist ] ],
	     GENRE robust ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event ],
             RELS <! [ PRED _they+that_q_mal_rel,
                     ARG0 #arg0 & ref-ind & 
                          [ PNG #png & [ PN 3p,
                                         GEN neut ] ],
                     RSTR #rhand ],
                   [ LBL #nhand,
                     PRED generic_nom_rel,
                     ARG0 #arg0 ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !> ] ].
             
;; Block misanalysis of imperatives as VP fragments, as in "put the book here"
;; (via [--MAL3SG +].
frag_vp_rule := frag_verbal_rule &
  [ SYNSEM.LOCAL.CAT.POSTHD +,
    ARGS < [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN norm_rel,
                                       VFORM non_bse,
                                       TAM.MOOD ind_or_modal_subj,
                                       MOD *cons*,
				       --MAL3SG + ],
                                VAL.SUBJ < synsem &
                                           [ LOCAL.CAT.HEAD noun,
                                             --SIND non_expl-ind,
					     NONLOC.SLASH 0-dlist ] > ] ] >,
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].


frag_vp_fin_3sg_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD [ AUX -,
                                       TAM #tam & [ TENSE present ],
				       --ADDIN [ ADDTAM #tam,
				                 ADDPN #pn ] ],
                            AGR.PNG.PN #pn & 3s ] ] > ].

frag_vp_fin_past_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ AUX -,
                                     TAM #tam & [ TENSE past ],
                                     --ADDIN.ADDTAM #tam ] ] > ].

frag_vp_fin_aux_rule := frag_vp_fin_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ AUX +,
                                     MINORS.MIN aux_event_rel ] ] > ].


;; DPF 2017-12-23 - Enable blocking of frag analysis for |how happy he is|
;;
frag_adj_rule :+
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
		      NONLOC non-local_none ] ] >  ].

frag_pp_ind_rule :+
  [ ARGS < [ SYNSEM.NONLOC non-local_none ] >  ].

;; Block the application of this rule, to avoid spurious analyses for e.g.
;; |the pie-eating contest|
;; DPF 2012-11-20 - But we need it in general for e.g. |the covered-up plate|
;;
#|
punctuation_hyphen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT hyphen_sgl & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT.HEAD no_head,
	              PUNCT [ LPUNCT #lpunct & no_punct,
                              RPUNCT no_punct &
                                     [ PSF #pred ],
                              RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre,
    RNAME "LPHR" ].
|#

#|
;; Block this rule, to avoid ambiguity: |The neighbors' is by the tree.|
;; DPF 16-01-14 - But we'll need this for more general input, and don't add
;; much ambiguity in the single-sentence composition by keeping it.
;;
punctuation_sqright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT sq_punct & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT.HEAD no_head,
	              PUNCT [ LPUNCT #lpunct & no_punct,
                              RPUNCT comma_or_clause_or_no_punct &
                                     [ PSF #pred ],
                              RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre ].
|#

;; Prevent comma marking on spr, as in "most of all, pizza tastes great"
head_spec_phrase :+
  [ NH-DTR.SYNSEM.PUNCT.RPUNCT no_punct ].

;; Constrain to exclude gerunds with subjects, as in spurious analysis of
;; "what was kim doing yesterday?"

#|
subjh_nonmc_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin_or_bse,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD verbal,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD n_or_v ].
|#
subjh_nonmc_rule := subjh_rule_decl & head_subj_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin_or_bse,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD verbal,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD n_or_v ].

;; Constrain to SF prop-or-like: if want question, have to supply question mark
;;
subjh_mc_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                  TAM indic_tam ],
                           MC + ],
                     CONT.HOOK.INDEX.SF #pred & prop-or-like ],
             PUNCT.RPUNCT.PSF #pred ] ].

subjh_mc_ques_rule := subjh_rule_decl & head_subj_phrase & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                  TAM indic_tam ],
                           MC + ],
                     CONT.HOOK.INDEX.SF #pred & ques ],
             PUNCT.RPUNCT clause_punct & [ PSF #pred ] ] ].

;; DPF 2017-10-06 - Replaced ALTMIN udef_q_rel with quant_rel, so we can also 
;; get robust |we admire old one|
bare_np_sg_phrase_robust := basic_bare_np_sg_phrase_robust &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.ALTMIN quant_rel,
                   CONT.HOOK.INDEX.--BARESG + ] ].

;; DPF 2018-09-13 - Enable avoiding bare-NP for |I know that book is boring|
;; DPF 2018-11-09 - Added DEF (definiteness) feature, so we can catch
;; |all of money|.
full_index :+
  [ --BARESG bool ].

;; DPF 2018-11-09 - Added DEF (definiteness) feature, so we can catch
;; |all of money|.
overt_non_expl-ind :+
  [ DEF bool ].

#|
;; Enrich this rule to propagate dtr's MOD..--BARE value to SPEC, in order to
;; constrain robust "all" as in "all pizza"
;;
num_det_rule :+ 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.--BARE #b ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.--BARE #b ] > ] > ].
|#

;; Enrich this rule to propagate dtr's MOD..--NOSUFF value to SPEC, in order to
;; constrain robust "many" as in "many fish"
;; DPF 2018-11-23 - Also preserve ARGS..MOD..MIN so we can block robust
;; |all morning|
;;
num_det_rule :+ 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD [ --NOSUFF #ns,
                                                   --MSCT #msct,
                                                   MINORS.MIN #min ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD 
                                                 [ --NOSUFF #ns,
                                                   --MSCT #msct,
                                                   MINORS.MIN #min ] ] > ] > ].

#|
double_det_rule := head_valence_phrase & head_final & rule &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT #cat,
                     CONJ cnil ],
             NONLOC #nonloc,
	     MODIFD #modif,
             LEX #lex ],
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT #cat & [ HEAD det ],
                              CONT.HOOK #hdhook,
                              CONJ cnil ],
                      NONLOC #nonloc,
                      MODIFD #modif,
                      LEX #lex ] ],
    NH-DTR [ SYNSEM lex_synsem &
                   [ LOCAL [ CAT.HEAD det,
                             CONT.HOOK.INDEX #nhindex,
                             CONJ cnil ],
                     NONLOC non-local_none,
                     LKEYS.KEYREL.RSTR #rstr ] ],
    C-CONT [ HOOK #hdhook,
             RELS <! arg0_relation &
                     [ LBL #nhand,
                       PRED generic_nom_rel,
                       ARG0 #nhindex ],
                     arg1_relation &
                     [ PRED ellipsis_rel,
                       ARG1 #nhindex ] !>,
	     HCONS <! qeq & [ HARG #rstr,
                              LARG #nhand ] !> ],
    GENRE robust ].
|#

; "One books"
mal_num_det_rule_1 := basic_num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL [ AGR.PNG.PN 3p,
					  CONT.HOOK.INDEX.PNG.PN 3p,
    			      	          CAT.HEAD [ MINORS.NORM 
					                 norm_or_no_rel,
						     --BARE - ] ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL.AGR.PNG.PN 3s ] >,
				     MINORS.NORM norm_rel ] ] >,
    GENRE robust ].

; "Twenty book"
;; DPF 2017-12-22 - Changed from SPEC..AGR..PN to SPEC..INDEX..PN, in order to
;; also catch |two third of the cats|
;; DPF 2018-10-02 - Removed SPEC..--BARE + so we can also trigger robust
;; |two class arrived|
;; DPF 2018-11-23 - But we still want to block robust |ten deer|, so add
;; SPEC..--NOSUFF -.  Also block robust |more time| with count `time'.
;;
mal_num_det_rule_2 := basic_num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL [ CONT.HOOK.INDEX.PNG.PN 3s,
					  CAT.HEAD 
					       [ MINORS [ MIN non_temp_nom_rel,
					                  NORM norm_or_no_rel ],
					         --NOSUFF - ] ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.PNG.PN 3p ] > ] >,
    GENRE robust ].

;; Plural det with singular count noun (all, several, many, more, most)
;; as in |all cat arose|
;; But block this one for temporal nouns as in |all year|
;; DPF 2018-10-01 - We'll have to treat `all' differently, since we do want the
;; error for |many/most/several/more year|.  So only `all' gets the SORT entity
;; constraint on its MOD..INDEX.
;; DPF 2018-10-01 - Changed MOD..HEAD.--BARE - to --NOSUFF - in order to still
;; block robust |many fish| while allowing robust |many day|.
;; DPF 2018-11-25 - Removed MOD..MIN non_temp_nom_rel, since we want e.g.
;; |many month passed|.  Also removed SPR < anti_synsem_min > since we want
;; |too many month passed|.  And since we can't use --NOSUFF - on mass-count
;; infl rule (we want robust |vision arrive|), but we want to avoid robust
;; |more food|,
;;
#|
aj_-_i-one_le_rbst := basic_aj_-_i-one_lexent &
  [ SYNSEM basic_one_num_synsem &
    [ LOCAL [ CAT [ HEAD [ MINORS [ ALTMIN no_rel,
			            NORM no_rel ],
			   MOD < [ LOCAL [ CAT [ HEAD [ --NOSUFF -,
							MINORS.MIN
							    non_temp_nom_rel ],
						 VAL.SPR < unexpressed>],
					   CONT.HOOK.INDEX.DIV - ],
				   LEX - ] > ],
		    VAL [ COMPS *synnull*,
			  SPR < anti_synsem_min >,
			  SPCMPS < > ] ] ],
      MODIFD.LPERIPH + ],
    GENRE robust ].
|#
aj_-_i-one_le_rbst := basic_aj_-_i-one_lexent &
  [ SYNSEM basic_one_num_synsem &
    [ LOCAL [ CAT [ HEAD [ MINORS [ ALTMIN no_rel,
			            NORM no_rel ],
			   MOD < [ LOCAL [ CAT [ HEAD [ --NOSUFF -,
			                                --MSCT - ],
						 VAL.SPR < unexpressed > ],
					   CONT.HOOK.INDEX.DIV - ],
				   LEX - ] > ],
		    VAL [ COMPS *synnull*,
		          SPR < [ LOCAL.CAT [ HEAD adv &
			                           [ MINORS.MIN degree_rel ],
					      VAL.SPR *olist* ] ] >,
			  SPCMPS < > ] ] ],
      MODIFD.LPERIPH + ],
    GENRE robust ].

;; Stop |one flower| from getting robust bare-sg analysis
aj_-_i-one_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.--BARE - ].

;; DPF 13-03-14 - Drop the requirement for MOD's SPR to be explicit, so we can
;; robustly parse |we admire best performer|.  This means we won't catch
;; erroneous |we admire best performers|.  FIX someday?
;;
#|
aj_-_i-sup_le := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
    [ LOCAL [ CAT [ HEAD superl_adj & [ MINORS.ALTMIN superl_rel,
                                         MOD < [ LOCAL.CAT.HEAD.MINORS.ALTMIN
                                                   explicit_q_rel ] > ],
                    VAL.SPR.FIRST.--MIN ord_or_very_rel ],
              CONT.RELS <! relation, relation !> ],
      LKEYS.ALTKEYREL.PRED superl_rel ] ].

aj_-_i-sup_le := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
    [ LOCAL [ CAT [ HEAD superl_adj & [ MINORS.ALTMIN superl_rel ],
                    VAL.SPR.FIRST.--MIN ord_or_very_rel ],
              CONT.RELS <! relation, relation !> ],
      LKEYS.ALTKEYREL.PRED superl_rel ] ].
|#

;; Prevent non-robust |admire best one|
;; DPF 2018-03-30 - But this blocks |game 6|, so reconsider and FIX?
;num_noun_phrase := basic_num_noun_phrase &
;  [ SYNSEM.MODIFD lmod & [ LPERIPH + ] ].

;; We need to know when an NP is a number, e.g. to avoid robust |ten grow|
supnoun :+
  [ --NOSUFF bool,
    --NUM bool ].

num_noun_rule :+
  [ SYNSEM.LOCAL.CAT.HEAD.--NUM + ].

;; Allow robust |dentists office|
;; Added MOD.FIRST expressed_synsem to block as partitive, as in
;; |the childrens smiled|
;;
aj_-_i-cmpd_le_rbst := aj_-_i-cmpd_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST expressed_synsem,
    GENRE robust ].

; Block clefts:
; But this also blocks |It is after the sun goes down|
#|
be_nv := be_verb &
  [ SYNSEM nv_cop_verb &
	   [ LOCAL.CONT [ HOOK.INDEX #event,
			  RELS.LIST.FIRST.ARG0 #event ] ],
    ALTS.VPELLIP -,
    GENRE robust ].
|#
;; Block inversion with `be' taking CP complement
;; Also block robust 3sg for complement
;; DPF 2019-11-04 - Change XARG.SORT from nonhuman-or-loc to qevent-or-loc, so
;; we can get |the suggestion is that we arise| but block |the cat is that we
;; arise|
be_nv := be_verb &
  [ SYNSEM nv_cop_verb &
	   [ LOCAL [ CAT [ HEAD [ INV - ],
			   VAL.COMPS.FIRST.LOCAL.CAT.HEAD.--MAL3SG - ],
		     CONT [ HOOK [ INDEX #event,
				   XARG.SORT qevent-or-loc ],
			    RELS.LIST.FIRST.ARG0 #event ] ] ],
    ALTS.VPELLIP - ].

#|
;; In lextypes.tdl
;; Remove SORT non-time-sort constraint to allow 
;; |the morning is the best part of the day|
n_-_c-ns_le := basic_intr_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT.HOOK.INDEX.PNG.GEN neut ] ].
|#

;; Add extra subtype of non_obliq case to impose constraint on abstract noun
;; |man| as in |man's best friend|
genitive := non_obliq.

;; Prevent mal-det and mal-adj (e.g. "all") from spurious robust analyses:
;; (--BARE -] for mal-adj, [--MALCM -] for mal-det
;;
mass_or_count_nocomp_synsem :+ 
  [ LOCAL.CAT.HEAD [ --BARE -,
		     --MALCM - ] ].

basic_mass_or_count_ppcomp_synsem :+
  [ LOCAL.CAT.HEAD [ --BARE -,
		     --MALCM - ] ].

;; This blocks robust |Tomorrow is first day| so comment out and CHECK.
#|
temp_noun_comp_two_arg_synsem :+
  [ LOCAL.CAT.HEAD [ --BARE -,
		     --MALCM - ] ].
|#

;; Block robust plural rule from applying to e.g. "north"
#|
;; CoNLL
n_-_c-dir_le := n_-_mc-ntoj_lexent &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
           [ LOCAL.CAT.HEAD.--BARE -,
	     MODIFD.LPERIPH + ] ].

n_-_c-dir_le := n_-_mc-ntoj_lexent &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
           [ LOCAL.CAT.HEAD.--BARE - ] ].
|#

;; Add idiomatic noun type to ensure idiomatic cooccurrences such as 
;; |give a speech| while PET still does not enforce idioms
idiom_nom_rel := reg_nom_rel.
idiom_modable_nom_rel := idiom_nom_rel & modable_nom_rel.
;; These two used with mal-entry for ditransitives to block mal-parse for
;; |gave a speech| where "speech" entry is [--MIN alt_idiom_nom_rel] indicating
;; that it has an alternative idiomatic (light-verb-friendly) entry.
non_idiom_nom_rel := norm_nom_rel.
alt_idiom_nom_rel := norm_nom_rel.

n_-_c-idm_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN idiom_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_m-idm_le := noun_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ MODIFD notmod,
	     LOCAL.CAT.HEAD.MINORS.MIN idiom_nom_rel,
	     LKEYS.KEYREL reg_nom_relation ] ].

#|
;; For doubled nouns like "beach beach"
;; (Chart mapping for `educ' should add LPERIPH bool to the second of two 
;; repeated words, to prevent a normal noun-noun compound analysis, leaving
;; this robust compound rule analysis.
noun_n_cmpnd_phr_doubled := basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM basic_lex_synsem &
		  [ MODIFD notmod & [ LPERIPH bool ],
		    PUNCT.LPUNCT dq_or_no_punct,
		    LKEYS.KEYREL.PRED #pred ],
    NH-DTR [ SYNSEM lex_synsem &
	  	    [ LKEYS.KEYREL.PRED #pred ],
	     INFLECTD na_or_- ],
    GENRE robust ].

noun_n_cmpnd_rule_mal := binary_rule_right_to_left & noun_n_cmpnd_phr_doubled.
|#

;; In order to distinguish transparent irregular plurals like |trout|, to
;; block them in the robust N-N-compound-plural rule, we add types 
;; cat_infl_suff and cat_infl_nosuff 
;; DPF 2018-11-25 - Added --MSCT to able to know when the underspecified
;; mass-count infl rule has applied, so we can for example avoid robust
;; |more food| but catch |more cat|.

basic_noun :+ [ --MSCT bool ].
cat_infl_suff := cat.
cat_infl_nosuff := cat &
  [ HEAD.--NOSUFF + ].

n_-_c-pl_le :+ [ SYNSEM.LOCAL.CAT cat_infl_nosuff ].
n_-_c-pl-def_le :+ [ SYNSEM.LOCAL.CAT cat_infl_nosuff ].

;; DPF 2018-11-09 - Add --NOSUFF + so we can avoid robust |more food| where
;; food is mass-or-count, so unmarked for DIV.
;; DPF 2018-11-25 - But this is too strong, since it prevents mass-count nouns 
;; with robust 3sg verbs as in |Vision return.|  So we add feature --MSCT to be
;; able to distinguish these.
;;
mass_count_noun :+
[ CAT.HEAD.--MSCT + ].

;; mal-entry for |they arrived in 1920s|
n_-_c-pl-gen_le_mal := n_-_c-pl-gen_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST unexpressed,
    GENRE robust ].

;; For |the gardens dog|
;; Block this rule for |his cats cat toys| via INFLECTD on hd-dtr.
;; And block for |he makes his children breakfast| via LOCAL sing_or_plur_noun
;; so we can also get robust |the cousins brothers|. But this prevents 
;; |cats food|, so instead mark |breakfast| with LPERIPH to block here.
;; DPF 2017-10-03 - Generalize HD-DTR..RPERIPH from na to na_or_+ to allow
;; robust analysis of |Kids brains develop|
;; DPF 2017-10-03 - Constrain hd-dtr HEAD basic_noun to exclude |cars honking|
;; Also constrain nonhd to nonconj: |[chocolate sprinkles and ten] candles|
;; DPF 2017-10-04 - Further constrain head dtr to be basic_lex_synsem to
;; block |snakes [bite classmates]|
;; DPF 2018-02-15 - Changed SYNSEM..LPERIPH from na to +, to prevent these
;; appearing as heads of larger compounds, as in |Anita rides horses|
;; DPF 2018-04-10 - Stamp --MALPLCPD + on the mother so we can block dative
;; verbs as in |he buys his cats toys|
;; DPF 2019-02-12 - Removed SYNSEM..SPR expressed_synsem since this blocked
;; robust |we admire kids parents|.
;;
noun_n_cmpnd_pl_mal := binary_rule_right_to_left & 
		       basic_basic_noun_n_cmpnd_phr &
  [ SYNSEM [ LOCAL.CAT.HEAD.--MALPLCPD +,
             MODIFD.LPERIPH + ],
    HD-DTR [ INFLECTD +,
	     SYNSEM basic_lex_synsem &
		    [ LOCAL [ CAT.HEAD basic_noun &
			               [ MINORS.MIN non_temp_nom_rel ] ],
		      MODIFD notmod & [ LPERIPH na_or_-,
					RPERIPH na_or_+ ],
		      PUNCT.LPUNCT dq_or_no_punct ] ],
    NH-DTR [ INFLECTD +,
             SYNSEM lex_synsem &
	            [ LOCAL [ CAT cat_infl_suff &
				  [ HEAD [ --BARE -,
					   --MALPLCPD + ] ],
		              CONT.HOOK.INDEX nonconj_ref-ind & [ PNG.PN 3p ],
			      AGR.PNG.PN 3p ],
		      PUNCT.RPUNCT dq_or_no_punct ] ],
    GENRE robust ].


;; Don't want |can arise| as NP-VP
#|
bare_np_prd_phrase := reg_bare_np_phrase &
  [ SYNSEM.LOCAL.AGR.DIV -,
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun & [ CASE nom ],
				  VAL.SPR.FIRST unexpressed_reg ] ] ] > ].
|#

; PLMASS for robust plural-mass
; AVIP for robust |easy to admire| => |easy admiring|
; COMPEQ for comparative as equative with "as" spr
; JROB for robust adj as |taste/tasty|, so we can avoid it when also adding
; a robust comma as in |... taste, smell, ...|
; DPRT - det-partitive, to block robust |[a lot] cats| from partitive rule
; MALPASS for no-by passive
; NONINITCAP for non-initial capitalization
alts :+ [ PLMASS bool,
          AVIP bool,
	  COMPEQ bool,
	  JROB bool,
          DPRT bool,
	  MALPASS bool,
	  NONINITCAP bool ].

;; For robust plural of mass nouns
;;
lex_rule_plural_mass := lex_rule_basic & word_or_infl_rule &
  [ INFLECTD +,
    KEY-ARG #keyarg,   
    SYNSEM mass_or_count_synsem &
	   [ LOCAL [ CAT #cat & [ HEAD noun_or_ttl,
				  VAL.SPR < synsem &
					    [ LOCAL.AGR [ PNG.PN 3p,
							  DIV + ] ] > ],
		     CONT #cont,
		     CONJ #conj,
		     CTXT #ctxt,
		     ARG-S #arg-s ],
	     NONLOC #nonloc,
	     OPT #opt,
	     --MIN #min,
	     --SIND #sind & [ --BARESG - ],
	     LEX #lex,
	     MODIFD #modifd,
	     PHON #phon,
	     PUNCT #punct,
	     LKEYS #lkeys ],
    ARGS < #dtr >,
    DTR #dtr & [ INFLECTD -,
                 KEY-ARG #keyarg,   
		 ALTS.PLMASS +,
                 SYNSEM basic_mass_noun_synsem &
			[ LOCAL [ CAT #cat,
				  CONT #cont,
				  CONJ #conj,
				  CTXT #ctxt,
				  AGR [ PNG.PN 3s,
					DIV + ],
				  ARG-S #arg-s ],
			  NONLOC #nonloc,
			  OPT #opt,
			  --MIN #min,
			  --SIND #sind,
			  LEX #lex,
			  MODIFD #modifd,
			  PHON #phon,
			  PUNCT #punct,
			  LKEYS #lkeys ] ],
    C-CONT.RELS <! !>,
    GENRE robust ].

;; Prevent these from undergoing bare-sg-rbst rule
;unsp_mass_or_count_synsem :+
;  [ LOCAL.CAT.HEAD.--BARE - ].

basic_mass_or_count_synsem :+
  [ LOCAL.CAT.HEAD.--BARE - ].

;; Since bare-sg-NP keeps AGR as 3s, change the following type to allow either
;; sg or plur NP comps, as in |we human| for |we humans|, but restrict to IND +
;; to avoid |[we rented ice] skates|

pro_wcomps_plur_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL [ COMPS 
                      < [ LOCAL [ CAT [ HEAD basic_noun & 
                                        [ MINORS 
					    [ MIN nonpro_rel,
					      ALTMIN both_all_udef_q_rel ] ],
					VAL [ SPR *olist*,
					      SUBJ < >,
					      COMPS < >,
					      SPEC < anti_synsem_min > ] ],
				  CONT.HOOK.INDEX #cind & nonconj_ref-ind,
				  AGR [ PNG.PN 3,
					IND + ] ],
			  NONLOC non-local_none,
			  OPT - ] > ],
            CONT [ HOOK.INDEX #ind & [ IND + ],
                   RELS <! [ LBL #lbl ], relation & #altkeyrel,
			   #alt2keyrel & [ LBL #lbl,
					   PRED appos_rel,
					   ARG0.E.TENSE no_tense,
					   ARG1 #ind,
					   ARG2 #cind ] !> ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    ALT2KEYREL #alt2keyrel ] ].

;; Missing apostrophe for contraction of "it is"
be_is_mal_lex_entry := nonc-h &
  [ INFLECTD +,
    ALTS.VPELLIP -,
    SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < anti_synsem_min >,
			       COMPS < synsem & [ OPT - ], ... >,
			       SPCMPS < > ],
			 HEAD [ VFORM fin,
				PRD -,
				INV -,
				TAM tam &
				      [ TENSE present,
					ASPECT.PRF -,
					MOOD subjunctive ] ],
			 POSTHD + ],
		   AGR.PNG png & [ PN 3s ],
		   CONT psoa &
		       [ HOOK.XARG #xarg & ref-ind & [ PNG.PN 3s ],
		         RELS.LIST < [ PRED pron_rel,
				       LBL #nhand,
				       ARG0 #xarg ],
				     [ PRED pronoun_q_rel,
				       ARG0 #xarg,
				       RSTR #rhand ], ... >,
			 HCONS <! qeq & [ HARG #rhand,
					  LARG #nhand ] !> ] ],
    ALTS.CSAI -,
    GENRE robust ].

v_prd_its-mal_le := be_is_mal_lex_entry &
  [ SYNSEM prd_aux_verb_ssr &
	   [ LOCAL [ CAT [ HEAD [ TAM #tam ],
			   VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.TAM #tam,
						   CONT.HOOK.LTOP #ltop ] ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation, relation !> ] ],
	     LKEYS.KEYREL.PRED be_v_prd_rel ] ].

v_np_its-mal_le := be_is_mal_lex_entry &
  [ SYNSEM aux_np_verb &
	   [ LOCAL [ CAT [ HEAD [ TAM.ASPECT.PROGR - ],
			   VAL.COMPS < [ LOCAL.CAT.HEAD.--BARE - ] > ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #event ],
			    RELS <! relation, relation, #keyrel !> ] ],
	     LKEYS.KEYREL #keyrel &
		          [ LBL #ltop,
			    ARG0 #event,
			    PRED _be_v_id_rel ] ] ].

;; For |have went ...|
;; FIX: block this for ordinary -ed past participles, presumably by splitting
;; the infl rule similarly to the split for reg and irreg plurals.
;; DPF 2017-09-06 - Added COMPS..--MALPAST - to enable preventing
;; unwanted double-robust analysis for |she had eaten|
;;
psp_aux_verb_mal_ssr := basic_have_aux_verb_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT vp_cat &
					[ HEAD verb &
					       [ VFORM fin,
						 TAM #tam & [ TENSE past,
							      IRR-TENSE + ],
						 --ADDIN.ADDTAM #tam,
						 --MALPAST - ],
					  VAL.SUBJ < [ LOCAL.CAT.HEAD noun ] >],
				    CONJ cnil ],
			    OPT - ] > ].

psp_aux_verb_mal_word := aux_verb_word &
  [ INFLECTD +,
    SYNSEM psp_aux_verb_mal_ssr &
	   [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  PRD -,
				  TAM indic_tam ],
			   POSTHD +,
			   VAL [ SUBJ < synsem & 
					[ LOCAL [ CAT nomp_cat_nom_min,
						  CONJ cnil ],
					  OPT - ] >,
				 COMPS < canonical_synsem &
					 [ LOCAL.CONT.HOOK.LTOP #hand ] > ] ],
		     CONT psoa &
			  [ HOOK.LTOP #hand,
			    RELS <! !>,
			    HCONS <! !> ] ] ],
    GENRE robust,
    ALTS.CSAI - ].

v_vp_has-mal_le := psp_aux_verb_mal_word &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.AGR.PNG png & [ PN 3s ] ] > ].

v_vp_have-mal_le := psp_aux_verb_mal_word &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem & 
				[ LOCAL.AGR.PNG png & [ PN -3s ] ] > ].

v_vp_had-mal_le := psp_aux_verb_mal_word &
  [ INFLECTD + ].

v_np_are-n_le_rbst := v_np_are-n_lexent &
  [ GENRE robust ].

v_np_is-n_le_rbst := v_np_is-n_lexent & 
  [ GENRE robust ].

v_np_was-n_le_rbst := v_np_was-n_lexent &  
  [ GENRE robust ].

v_np_wre-n_le_rbst := v_np_wre-n_lexent &
  [ GENRE robust ].


;; Constrain to singular unknown names, to avoid spurious for e.g. |Pistorius|
n_-_pn-gen_le := basic_n_proper_lexent & generic_ne_lex_entry &
  [ INFLECTD -,
    SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN named_np_rel,
    			          --GENPROP + ],
			   VAL.SPR < [ --MIN norm_proper_q_rel ] > ],
		     AGR.PNG.PN 3s ],
	     MODIFD.LPERIPH na_or_+,
	     LKEYS.KEYREL [ PRED named_rel ] ] ].

n_-_pn_le := n_proper_lexent &
  [ TOKENS.+LAST.+CLASS.+CASE capitalized ].

n_-_pn_le_nocap_rbst := n_proper_lexent &
  [ TOKENS.+LAST.+CLASS.+CASE non_capitalized,
    GENRE robust ].

n_-_c-nm_le_nocap_rbst := n_intr_named_lexent &
  [ SYNSEM.PUNCT no_punctuation_min,
    TOKENS.+LIST.FIRST.+CLASS.+CASE non_capitalized,
    GENRE robust ].

aj_-_i_le_nocap_rbst := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel,
    TOKENS.+LAST.+CLASS.+CASE non_capitalized,
    GENRE robust ].

n_np_c-month_le := n_np_c-month_lexent &
  [ ORTH.CLASS.+CASE capitalized ].

n_np_c-month_le_nocap_rbst := n_np_c-month_lexent &
  [ ORTH.CLASS.+CASE non_capitalized,
    GENRE robust ].

d_-_month_le := abstr_det_word &
  [ SYNSEM det_date_synsem &
	     [ LOCAL.CAT.HEAD.MINORS.ALTMIN mofy_rel ],
    ORTH.CLASS.+CASE capitalized ].

d_-_month_le_nocap_rbst := abstr_det_word &
  [ SYNSEM det_date_synsem &
	     [ LOCAL.CAT.HEAD.MINORS.ALTMIN mofy_rel ],
    ORTH.CLASS.+CASE non_capitalized,
    GENRE robust ].

n_-_m-hldy_le := basic_n_-_m-ssn_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN holiday_rel,
	     LKEYS.KEYREL.PRED holiday_rel ],
    TOKENS.+LAST.+CLASS.+CASE capitalized ].

n_-_m-hldy_le_nocap_rbst := n_-_m-ssn_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN holiday_rel,
	     LKEYS.KEYREL.PRED holiday_rel ],
    TOKENS.+LAST.+CLASS.+CASE non_capitalized,
    GENRE robust ].

;; Constrain to not capitalized, to avoid spurious entry for e.g. |Mom|
;;
n_-_mc-unk_le := n_-_mc-unk_lexent & norm_unknown_word &
  [ TOKENS.+LAST.+CLASS.+CASE non_capitalized ].

;; Hack to accommodate |would rather VP than X|
;;
ssr_vp_pp_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
	   [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                        INDEX #subj ] ] >,
	     COMPS < [ LOCAL [ CAT [ HEAD verbal & [ VFORM bse ],
                                     VAL [ SUBJ < synsem >,
					   COMPS < > ] ],
                               CONT.HOOK.XARG #subj ],
                       OPT - ],
		     synsem &
		     [ --MIN _than_p_compar_rel,
                       LOCAL [ CAT basic_pp_cat & 
                                   [ HEAD.MOD < > ],
                               CONJ cnil ],
		       OPT - ] > ],
            CONT.HOOK.LTOP #ltop ] ].

;; For |would rather|
;; Removed, since have better analysis now.
#|
ssr_vp_pp_verb := verb_synsem & ssr_vp_pp_subst & ssr_expr_lt.
v_vp-pp_ssr_le := main_verb_mliszt & 
  [ SYNSEM ssr_vp_pp_verb ].
|#

v_vp_mdl-p-cx_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.UNSP-TENSE + ].

; For e.g. |It affected to Kim| with spurious prep
v_pp_np_le_rbst := main_verb & 
  [ SYNSEM empty_prep_intrans_verb &
	     [ LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ],
    GENRE robust ].

;; For wrong prep marker, as in |abide to|
v_pp_e_le_rbst := main_verb & 
  [ SYNSEM empty_prep_intrans_verb &
	   [ LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ],
    GENRE robust ].

;; Wrong prep marker for adjectives: |*He was bored of it|
aj_pp_i_le_rbst := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
                       VAL.COMPS.FIRST.OPT - ],
    GENRE robust ].

;; DPF 2017-09-12 - Exclude malrule for 3sg, to avoid spurious robust analysis
;; for |It is important that he respect the rules|
;;
aj_pp-cp_i-it_le := reg_adj_atrans_cp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT -,
                                   LOCAL.CAT.HEAD.--MAL3SG - ] > ].


; DPF 04-aug-10 - Block free relatives via NH-DTR..HEAD value
;; DPF 2017-04-03 - Restrict to MC + to avoid use in e.g.
;; |he was in the theater seat sleeping|

subjh_nonfin_robust_rule := subjh_rule_basic & head_subj_phrase &
			    non_rel_clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb & 
				[ VFORM non_pas,
				  TAM indic_tam & [ ASPECT.PRF - ] ],
			   MC + ],
                     CONT.HOOK.INDEX.SF #pred ],
	     NONLOC.SLASH 0-dlist,
             PUNCT.RPUNCT.PSF #pred ],
    HD-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #hdtop,
				    INDEX #hdind ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD noun,
		    PUNCT.RPUNCT pair_or_no_punct ],
    C-CONT [ HOOK [ LTOP #hdtop,
                    INDEX #hdind ],
             RELS <! !>,
             HCONS <! !> ],
    GENRE robust ].

; DPF 22-nov-07 - For now, don't allow bare-sg NPs as subjects here, to
; avoid too much ambiguity - maybe FIX later, if this is too restrictive
;
subjh_robust_rule := subjh_rule_decl & basic_head_subj_phrase & clause &
  [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin,
                              TAM indic_tam & [ TENSE present ],
			      CASE non_nom ],
                       MC + ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN non_ellipt_rel,
				  VAL.SUBJ < canonical_synsem &
                                       [ LOCAL [ CAT #cat,
                                                 CONT #cont,
                                                 CONJ #conj,
                                                 CTXT #ctxt ],
                                         NONLOC #nonloc,
					 --SIND ref-ind & #sind,
                                         OPT #opt,
                                         LEX #lex,
                                         MODIFD #modifd,
                                         PHON #phon,
                                         PUNCT #punct ] > ],
			    CONT.HOOK.INDEX non_conj_event ],
                    NONLOC.SLASH 0-dlist ],
    NH-DTR.SYNSEM [ LOCAL [ CAT #cat & [ HEAD noun & 
					      [ --BARE -,
						MINORS.ALTMIN 
						       non_freerel_q_rel ] ],
			    CONT #cont,
                            CONJ #conj,
                            CTXT #ctxt ],
                    NONLOC #nonloc,
		    --SIND #sind,
                    OPT #opt,
                    LEX #lex,
                    MODIFD #modifd,
                    PHON #phon,
                    PUNCT #punct & [ PNCTPR ppair,
 		                     RPUNCT pair_or_no_punct ] ],
    GENRE robust ].
                          
subjh_robust_3s_v_rule := subjh_robust_rule &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s,
    HD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG.PN 3s ] >,
    NH-DTR.SYNSEM.LOCAL.AGR.PNG.PN -3s ].

subjh_robust_n3s_v_rule := subjh_robust_rule &
  [ SYNSEM.LOCAL.AGR.PNG.PN -3s,
    HD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG.PN -3s ] >,
    NH-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3s ].

;; DPF 2017-09-06 - Robust rule with comma-marked subject
;;
subjh_mc_cma_rule := subjh_rule_decl & basic_head_subj_phrase & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verbal &
				[ VFORM fin,
                                  TAM indic_tam,
				  PRD -,
				  CASE non_nom ],
			   VAL.SPR *olist*,
                           MC + ],
                     CONT.HOOK [ INDEX.SF #pred ] ],
	     NONLOC.SLASH 0-dlist,
             PUNCT.RPUNCT.PSF #pred ],
   HD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #synsem >,
   NH-DTR.SYNSEM #synsem & [ PUNCT [ PNCTPR no_ppair,
                      	 	      RPUNCT comma_punct ] ],
   GENRE robust ].


;; Relax GENRE constraint so we can generate sentence-initial PPs without
;; commas.
;; DPF 17-10-04 - Let's stamp MODIFD lmod on mother to avoid these as right 
;; dtrs in run-on comma robust rule
;;
filler_head_rule_non_wh_infgen := filler_head_rule_non_wh &
  [ SYNSEM.MODIFD lmod,
    HD-DTR.SYNSEM.LEX -,
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD non_noun_or_adv &
				   [ MINORS [ MIN independent_rel,
				              ALTMIN non_ellipt_rel ] ],
		    PUNCT.RPUNCT no_punct ] ].

;; DPF 19-10-31 - Also allow for commands, as in |In Paris, eat everything!|.
filler_head_rule_non_wh_edgen :+
  [ RNAME fhne,
    HD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-pol-ques-or-comm,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN independent_rel ].

#|
;; For CoNLL, keep comma as separate token
pt_-_comma_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT comma_or_rbc_punct ].

pt_-_semicolon_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT basic_semicol_punct ].
|#

;; For erroneous VP passives of intransitives as in |the fish were died|
;; (Repair is to drop preceding copula)
v_-_psv-post_le_rbst := norm_basic_main_verb &
  [ SYNSEM passive_unerg_synsem &
	   [ LOCAL.CAT [ POSTHD + ] ],
    INFLECTD +,
    GENRE robust ].

;; For erroneous VP passives of intransitives used prenominally: |the died fish|
;; (Repair is to rephrase as relative clause: |the fish that died|)
v_-_psv-pre_le_rbst := norm_basic_main_verb &
  [ SYNSEM passive_unerg_synsem &
	   [ LOCAL.CAT [ POSTHD - ] ],
    INFLECTD +,
    GENRE robust ].

;; Block depictives headed by |being that ...|, to favor |human being| as item
v_cp_being_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

;; Block reduced relative |being that|, for same reason
;; DPF 16-01-13 - But this prevents pre-S modifiers, as in "being a cat, she 
;; complained."  So undo, and see if still need help in getting |human being|.
;;
#|
v_np_being_le :+
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST expressed_synsem ].
|#

;; Flag wrong double plurals: e.g. |polices|
n_-_c-pl_le_rbst := n_intr_infl_lex_entry &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
					       DIV + ] ] >,
		   CONT.HOOK.INDEX [ PNG.PN 3p,
				     DIV + ] ],
    GENRE robust ].

;; Wrong singulars for pluralia tantum: |I expressed my thank|
;; DPF 2019-03-27 - Mark this to avoid also having robust non3sg verb, as for
;; |The children feed goats|
;; DPF 2019-04-10 - Generalize to mass or count, so we can also catch
;; |we admire firework| with missing article.
;;
basic_n_-_c-sg_le_mal := basic_n_intr_infl_lex_entry &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS [ MIN norm_nom_rel,
					   NORM norm_rel ],
				  --MALAGR +,
				  --BARE - ],
			   VAL.SPR < [ LOCAL.AGR [ PNG.PN 3s ] ] > ],
		     CONT.HOOK.INDEX [ PNG.PN 3s ] ],
	     MODIFD notmod ],
    GENRE robust ].

;; |the firework began|
;; LPERIPH prevents these as heads of compounds, as in |rivers surrounding|
n_-_c-sg_le_rbst := basic_n_-_c-sg_le_mal &
  [ SYNSEM.MODIFD.LPERIPH + ].

#|
;; |the children arises|
;;
n_-_c-sg-nom_le_rbst := basic_n_-_c-sg_le_mal &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom ].
|#

;; |he expressed his thank|
n_-_c-sg-nonnom_le_rbst := basic_n_-_c-sg_le_mal &
  [ SYNSEM [ LOCAL.CAT [ HEAD.CASE non_nom,
			 VAL.SPR.FIRST.--MIN def_explicit_q_rel ],
	     MODIFD.LPERIPH na ] ].

; Intransitive used as causative: |this deteriorates the problem|
v_np_caus_le_rbst := main_verb & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < canonical_synsem &
				   [ OPT -,
				     LOCAL.CAT.HEAD noun &
					 [ --BARE -,
					   CASE acc ],
				     PUNCT.RPUNCT clause_or_no_punct ] > ] ],
    GENRE robust ].

;; Ditransitives like `give' used as simple transitives
;; DPF 2017-09-27 - To prevent spurious robust analysis of
;; |Cathy handed a rock to Caleb|, restrict NP comp to notmod_or_lmod.
;;
v_np_ditrans_le_rbst := main_verb & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < [ --MIN non_idiom_nom_rel,
	                               MODIFD notmod_or_lmod,
	                               OPT - ] > ] ],
    GENRE robust ].

v_np_cp_le_rbst := main_verb & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < [ OPT - ] > ] ],
    GENRE robust ].

;; Double negation
;
av_-_s-not_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD negadv &
                       [ MOD < [ LOCAL.CAT [ HEAD verb_or_frag &
						  [ VFORM non_fin ],
                                             VAL.SUBJ < synsem_min > ],
				 --SIND.SF prop-or-ques ] > ] ] ].


adv_addition :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS [ FIRST.LOCAL.CAT.NEGPOL #negp,
                                 REST.FIRST.LOCAL.CAT.NEGPOL #negp ] ].

;; Change NEGPOL to -, where negation-sensitive elements are either + (marking
;; overt negation and hence not permissible in scope of negation), or - (marking
;; a polarity-sensitive element that needs to be in scope of negation or
;; similar polarity context).
;;
d_-_prt_le := pdet_word_nonque &
  [ SYNSEM.LOCAL.CAT.NEGPOL - ].

;; Block |one of the most cats|
pdet_word_nonque :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DEF - ].
d_-_prt-more_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DEF - ].
d_-_prt-pl-both_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DEF - ].
;; Allow |one of a great many cats|
d_-_prt-pl_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DEF + ].
;; Keep NORM visible, to distinguish |*one of cats| from |*one of several cats|
p_np_ptcl-of_le :+
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.NORM #norm,
			 VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.MINORS.NORM #norm,
						 AGR.DEF #def ] ],
		   AGR.DEF #def ] ].

;; Avoid robust |one of the cats|
d_-_the_lexent :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DEF + ].
;; Avoid robust |one of these cats|
det_pl_lexent :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DEF + ].
basic_det_poss_lexent :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DEF + ].

;; |do you have any more question?|
;; DPF 2017-09-23 - But prevent these from partitive rule, to avoid spurious
;; ambig. as in |cyborgs won the most|.
;;
d_-_prt-plm_le_rbst := det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ --MIN just_only_deg_rel,
                                     LEX + ] >,
                     AGR.DIV - ],
             LKEYS.KEYREL [ ARG0.DIV -,
			    PRED explicit_quant_agr_q_rel ],
             MODIFD hasmod ],
    GENRE robust ].

;; Stop trying to do neg-polarity hastily: was blocking e.g.
;; |we achieved nothing in our life|
#|
basic_unary_phrase :+
  [ SYNSEM.LOCAL.CAT.NEGPOL #negp,
    ARGS.FIRST.SYNSEM.LOCAL.CAT.NEGPOL #negp ].

basic_head_mod_phrase_simple :+
  [ SYNSEM.LOCAL.CAT.NEGPOL #negp,
    HD-DTR.SYNSEM.LOCAL.CAT.NEGPOL #hnegp,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.NEGPOL #hnegp,
                              NEGPOL #negp ] ].

np_coord_top_rule :+
  [ SYNSEM.LOCAL.CAT.NEGPOL #negp,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.NEGPOL #negp ].
|#

;; Removed [NEGPOL -] on mother.
bare_npq_phrase := basic_unary_phrase &
  [ INFLECTD #infl,
    SYNSEM synsem &
           [ LOCAL [ CAT [ HEAD #head,
                           HC-LEX #hclex,
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < synsem_min &
				       [ --MIN just_only_deg_rel,
                                         LOCAL [ CAT [ HEAD adv,
						       VAL.SPR *unexplist* ],
                                                 CONT.HOOK.LTOP #ltop ],
                                         OPT + ] >,
				 SPCMPS < > ],
                           MC na ],
                     AGR ref-ind &
                         [ PNG #png,
			   DIV #div ],
                     CONJ #conj,
		     CTXT #ctxt ],
             NONLOC #nonloc,
	     LEX #lex,
             MODIFD #modif,
	     PUNCT #punct ],
    ARGS < [ INFLECTD #infl,
	     SYNSEM 
             [ LOCAL [ CAT [ HEAD #head & partn,
                             HC-LEX #hclex,
                             VAL [ SUBJ *olist*,
                                   COMPS < >,
                                   SPR < unexpressed &
					 [ LOCAL.CONT.HOOK.LTOP #ltop,
					   NONLOC.QUE 0-dlist,
					   OPT - ], ... > ] ],
                       AGR [ PNG #png,
			     DIV #div ],
                       CONJ #conj & cnil,
                       CONT.HOOK [ INDEX #index,
				   XARG #xarg ],
		       CTXT #ctxt ],
               NONLOC #nonloc,
	       LEX #lex,
	       MODIFD #modif & [ RPERIPH na_or_+ ],
	       PUNCT #punct & [ LPUNCT lital_or_pair_or_comma_or_no_punct ] ] ] >,
    C-CONT [ HOOK [ INDEX #index,
		    XARG #xarg ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; Since we're trying to do without robust commas, adjust the adj-N types

adj_n_int_phrase := adj_head_int_phrase &
  [ HD-DTR [ SYNSEM [ LOCAL.CAT [ HEAD basic_nom_or_ttl,
				  VAL [ SPR.FIRST 
					   [ LOCAL.CAT.HEAD.MINORS.MIN #min,
					     --MIN #min & quant_rel ],
					COMPS < > ] ],
		      PHON.ONSET #onset ],
	     INFLECTD #infl ],
    NH-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ PHON.ONSET #onset ] >,
				    VAL.SUBJ *synlist* ],
			      CONT.HOOK.INDEX event & 
			                      [ E [ TENSE no_tense,
			                            ASPECT [ PROGR bool,
							     PRF - ] ] ] ],
                      LEX +,
		      PUNCT.RPUNCT comma_or_rbc_or_hyphen_or_pair_or_no_punct ],
             INFLECTD + ],
    INFLECTD #infl ].

adj_n_phrase := adj_n_int_phrase &
  [ HD-DTR [ SYNSEM.MODIFD notmod,
	     INFLECTD bool ] ].

;; Since we're not using nonformal comma, change here
adj_adjn_phrase := adj_n_int_phrase &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.HEAD nom_or_ttl,
                    MODIFD lmod & [ LPERIPH na_or_-,
				    RPERIPH na_or_- ] ],
    NH-DTR.SYNSEM .PUNCT.RPUNCT comma_or_hyphen_or_pair_or_no_punct ].

;; Block pre-VP modif, as in |she had [[eaten before she] [had her dinner]]|
subconj_prdp_v_init_phrase := subconj_prdp_init_phr &
  [ SYNSEM.LOCAL.CAT [ POSTHD -,
		       HEAD [ MOD.FIRST.LOCAL.CAT.VAL.SPR < >,
			      TAM.TENSE #tense ] ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD verb & [ VFORM pas_or_prp,
					    TAM.TENSE #tense ] ] > ].

;; Add subtypes of appos_rel so we can use paraphrase rule to reverse the
;; order of args to generate both |Kim the teacher| and |the teacher Kim|
appos_norm_rel := appos_rel.
appos_rev_rel := appos_rel.

;; Tried excluding |the eye of him|
;; but this also loses |the weight of it|, so don't
;p_np_i-nm-poss_lexent :+
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN basic_nonpro_rel ] > ].

;; DPF 2018-10-02 - Prevent modifier analysis of |all of the teacher|
p_np_i-nm-poss_lexent :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD non_partn ].

;; Exclude |and [out it] went|
p_np_i-nnm-nt_le :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.--MIN basic_nonpro_rel ].

;; DPF 2016-06-25 - Prevent robust 'he' from appearing in |K is taller than he|
;; DPF 2018-04-02 - But NORM norm_rel is too severe, also excluding |than today|
;; so use feature --MALCASE instead.
p_np_ptcl-ngap_le :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.--MALCASE - ].

;; DPF 2017-09-12 - Make complement COMPS < > , to avoid spurious robust parse
;; for |two of them ordered pumpkin pie|
;;
minute_prep_lr := basic_minute_lex_rule &
 [ SYNSEM minute_noun_wcomp_synsem &
          [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.VAL.COMPS < > ] ].

;; DPF 2017-05-17 - Allow comma or no punct, so we can detect run-ons such as
;; |I spotted a lizard it was awesome.|  
;; DPF 2017-08-09 - Re 2017-05-17: But this leads to several false positives
;; such as for |She brought pictures of her China trip.|  So require comma.
;; 
run_on_coord_punct_rule := basic_run_on_coord_rule &
 [ LCONJ-DTR.SYNSEM phr_synsem &
		    [ LOCAL.CAT.HEAD verb ],
   RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD verb_or_conj-s,
                            CONJ cnil ],
   ARGS < [ SYNSEM.LEX - ], 
	  [ SYNSEM [ LEX -,
	             LOCAL [ CAT.HEAD [ --MAL3SG -,
		      	      	        --MALPAST -,
					CASE nom ],
			     CONT.HOOK.INDEX.SF prop ] ] ] >,
   GENRE robust ].

run_on_coord_comma_rule := run_on_coord_punct_rule &
  [ LCONJ-DTR.SYNSEM.PUNCT.RPUNCT comma_punct,
    RCONJ-DTR.SYNSEM.PUNCT.LPUNCT lparen_or_dq_or_no_punct ].

run_on_coord_dash_rule := run_on_coord_punct_rule &
  [ LCONJ-DTR.SYNSEM.PUNCT.RPUNCT s_dash_punct,
    RCONJ-DTR.SYNSEM.PUNCT.LPUNCT lparen_or_dq_or_no_punct ].

;; DPF 2017-09-26 - Add ALTS feature to allow us to mark some robust lexemes
;; as lacking a comma, as in S-initial adv in |last we read the book|.
alts :+ [ CMA bool ].

punctuation_comma_rule :+
 [ ARGS < [ ALTS.CMA + ] > ].

;; DPF 2017-09-28 - Add ALTS feature to allow blocking of tense-matching
;; past-tense inflectional rule.
;;
alts :+ [ TNS-ID bool ].

;; DPF 2017-09-29 - Abuse the ALTS attribute here to allow blocking of certain
;; adjectives to avoid spurious use of the subord-adj-lex rule, as in
;; |There are five fifth graders between fifteen and twenty feet tall.|
;; DPF 2017-09-30 - But this won't work, since ALTS is not an attribute of
;; phrases, and adjectives with an optional complement have to first
;; undergo the optcomp rule, which loses ALTS.  So instead, make it a HEAD
;; feature of adj.
;; DPF 2018-04-07 - Added --IDIOMPART to prevent robust |made sure to leave|
;; DPF 2018-09-18 - Added --NOUNADJ to prevent robust |much fun|
;;
adj :+ [ --SBRD luk,
	 --IDIOMPART bool,
	 --NOUNADJ bool ].

;; Add --MAL3SG constraint (hack) to prevent spurious robust intrans in
;; |buys and sells books|
v_coord_phr :+
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.--MAL3SG - ].

;; |Morning is the best time of the day|
n_-_m-nocnh-nspr_le :+
  [ ALTS.PLMASS - ].

n_-_m-nocnh_le :+
  [ ALTS.PLMASS - ].

;; Add UNSP-TENSE - to mod, to prevent this rule from applying to coord of
;; mal-subord PPs, as in |we arise if we win or if we lose|
;; But we also use this rule for coordinating degree adverbs as in
;; |more and more confident|, where the MOD is empty. So undo.
;;
;pp_coord_top_phr :+
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.UNSP-TENSE + ].

;; Propagate UNSP-TENSE value from dtr to complementizer as in
;; |I wondered if I would win|
;;
basic_sor_compl_word :+
  [ SYNSEM.LOCAL.CAT [ HEAD [ TAM.UNSP-TENSE #ut,
                              --MODAL #modal ],
		       VAL.KCMP.LOCAL.CAT.HEAD [ TAM.UNSP-TENSE #ut,
		                                 --MODAL #modal ] ] ].

;; DPF 2017-10-02 - Restrict CASE to acc to avoid |to long|
grad_n := partn_mobile & [ CASE acc ].

;; Avoid |I like phones|
av_-_dc-like-pr_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD [ --MAL3SG -, --MALN3SG - ]].

;; Avoid |I arrived, [[then I arose] ...]|
av_-_dc-like-po_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.MODIFD notmod_or_rmod ].

av_-_dg-jo_le :+
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAT.HEAD.--BARE - ].

n_pp_c-dir_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

;; |my favorite was the lions|
;; This is too strong, since it prevents robust analysis of |we admired old one|.
;;
;partn :+
;  [ --BARE - ].

;; Enable blocking of |with my friends fun|
subconj_with_synsem :+
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL.CAT.HEAD.MOD.FIRST.OPT + ] > ].

;; Needed for robust `neither' as in |neither brothers|
;;
_neither_q-agr_rel := explicit_quant_agr_q_rel & universal_q_rel.

;; Misspelled adj
aj_-_i_le_rbst := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel,
    GENRE robust ].

;; DPF 2018-02-20 - Default value of --SBRD is bool to prevent these as lexical
;; depictives: |*They arrived beautiful|
;;
aj_-_i_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    --SBRD bool ] ].

aj_-_i-er_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS [ MIN norm_adj_rel,
			  	     ALTMIN comp_er_rel ],
			    --SBRD bool ] ].

aj_-_i-er-sbrd_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS [ MIN norm_adj_rel,
			  	     ALTMIN comp_er_rel ],
			    --SBRD na ] ].

aj_pp_i_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    --SBRD bool ] ].

aj_pp_i-er_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS [ MIN norm_adj_rel,
				     ALTMIN comp_er_rel ],
			    --SBRD bool ] ].

aj_pp_i-er-sbrd_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS [ MIN norm_adj_rel,
				     ALTMIN comp_er_rel ],
			    --SBRD na ] ].

;; Allow lexical depictives: |they arrived drunk|
aj_-_i-sbrd_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    --SBRD na ] ].

aj_pp_i-sbrd_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    --SBRD na ] ].

aj_pp_i-er-sbrd_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS [ MIN norm_adj_rel,
				     ALTMIN comp_er_rel ],
			    --SBRD na ] ].

; Block unwanted robust for |it smelled disgusting|
aj_-_i-prd_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.--SBRD - ].

aj_pp_i_le_rbst := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN norm_adj_rel,
			      --SBRD bool ],
		       VAL.COMPS.FIRST.OPT - ],
    GENRE robust ].

;; Block |being|
intrans_nominal_gerund :+
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN non_ellipt_rel ].


;; Specialize pron_rel
_i_n_pron_rel := pron_rel.
_you_n_pron_rel := pron_rel.
_he_n_pron_rel := pron_rel.
_she_n_pron_rel := pron_rel.
_he-she_n_pron_rel := pron_rel.
_it_n_pron_rel := pron_rel.
_we_n_pron_rel := pron_rel.
_they_n_pron_rel := pron_rel.

n_-_pr-he_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-he_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-her_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-hers_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-him-her_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he-she_n_pron_rel ].
n_-_pr-hers-his_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he-she_n_pron_rel ].
n_-_pr-herself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-him_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-himself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-his_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _he_n_pron_rel ].
n_-_pr-i_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-i_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-it_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _it_n_pron_rel ].
n_-_pr-it_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _it_n_pron_rel ].
n_-_pr-itself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _it_n_pron_rel ].
n_-_pr-me_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-mine_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-myself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _i_n_pron_rel ].
n_-_pr-ours_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].
n_-_pr-ourslves_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].
n_-_pr-she_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-she_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _she_n_pron_rel ].
n_-_pr-theirs_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-them_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-themself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-themslves_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-they_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-they_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _they_n_pron_rel ].
n_-_pr-us_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].
n_-_pr-us_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].
n_-_pr-we_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].
n_-_pr-we_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _we_n_pron_rel ].
n_-_pr-you_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].
n_-_pr-you_le_rbst :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].
n_-_pr-yours_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].
n_-_pr-yourself_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].
n_-_pr-yourslves_le :+
 [ SYNSEM.LKEYS.KEYREL.PRED _you_n_pron_rel ].

n_-_pr-i-me_le_mal := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.CASE no_case,
			 VAL.SPR < [ --MIN no_rel ] > ],
	     MODIFD.RPERIPH +,
	     LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
				 DIV -,
				 PT std ] ] ].

;; Block as subconj_prd, as in |we arrived felt boring|, both for normal rule
;; and for robust one.  But can't make these NORM no_rel, since the copula
;; wants NORM norm_rel.
;;
aj_-_i-spobl_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.--SBRD - ].

;; Block partitives with robust 3sg verb rule, since number on partitives is
;; often underspecified.
;;
basic_part_constr :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].
;; And the same for possessive pronouns including "his".
n_poss_pro_lexent :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

;; DPF 2018-03-16 - Add --VNEG bool to enable notice of negated VPs, so we can
;; for example block |he can not leave| in the intended sense.
;; DPF 2019-06-05 - Add --COPID so we can block purposive to-VP attachment in 
;; |it is a good time to disappear|.
;; DPF 2019-06-06 - Add --MALFIN to prevent |making him ate bananas| as subord
;; DPF 2019-06-06 - Add --NOCJCRD to prevent robust noconj-coord VP as left
;; member in larger VP coord.
;; DPF 2019-11-11 - Add --MALCOPBSE to prevent |be warm| using robust |be begin|
;;
verbal :+
  [ --VNEG bool,
    --COPID bool,
    --MALFIN bool,
    --NOCJCRD bool,
    --MALCOPBSE bool ].

robust_nom_rel := non_proper_rel.
;; DPF 2018-03-16 - Add type for adjectives used as count nouns:
;; |fishing is a fun for me|
n_-_c-adj_le_rbst := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN robust_nom_rel,
             MODIFD.RPERIPH + ],
    GENRE robust ].

;; |the fifty words composition|
;; But exclude |[two feet] [tall fence]| via LPERIPH na, since another error 
;; code catches wrong degree specifier.
;;
noun_n_cmpnd_mnp_mal_rule := binary_rule_right_to_left & 
			     basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM abstr_lex_synsem & 
		  [ MODIFD notmod_or_lmod & [ LPERIPH na ],
		    PUNCT.LPUNCT dq_or_no_punct ],
    NH-DTR [ INFLECTD +,
	     SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN meas_nom_rel,
					   --BARE - ],
				    VAL.SPR.FIRST synsem & [ OPT - ] ],
			      CONT.HOOK.INDEX nonconj_ref-ind & [ PNG.PN 3p ] ],
		      MODIFD notmod_or_lmod,
		      PUNCT.RPUNCT hyphen_or_pair_or_no_punct ] ],
   GENRE robust ].

;; Predicative adj used attributively
;;
aj_-_i-att_le_rbst := reg_adj_word &
  [ SYNSEM basic_attr_adj_synsem,
    GENRE robust ].

;; |important anything|
;; Need RPERIPH + to avoid in |mixed everything together in ...|
;; And added HS-LEX + to prevent robust |something arose| while still getting
;; robust |important something arose|.
;;
n_-_m-mod_lexent_mal := basic_noun_word &
  [ INFLECTD +,
    SYNSEM basic_unsp_common_noun_synsem &
	   [ LOCAL [ CAT [ HEAD noun &
				[ MINORS [ MIN norm_nom_rel,
					   NORM norm_rel ],
				  MOD < > ],
			   VAL [ SPR.FIRST unexpressed,
				 SUBJ < >,
				 COMPS < > ],
			   MC na,
			   HS-LEX + ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #agr & [ PNG png & [ PN 3s ],
						  DIV +,
						  IND - ] ],
			    RELS <! reg_nom_relation & [ LBL #ltop ]  !>,
			    HCONS <! !>, ICONS <! !> ],
		     CONJ cnil,
		     AGR #agr ],
	     NONLOC non-local_none,
	     MODIFD notmod & [ RPERIPH + ] ],
    GENRE robust ].

;; For |important anything| where the adj should follow the noun.
n_-_m-mod_le_rbst := n_-_m-mod_lexent_mal. 

;; For |we admire new school| where article is oblig
n_-_m-nomod_le_rbst := n_-_m-mod_lexent_mal. 

; |Kim is very taller|
av_-_dg-m_le_rbst := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
		       VAL.SPEC.FIRST.LOCAL.CAT.HEAD basic_adj ],
    GENRE robust ].

; |Kim is much happy|
;; DPF 2018-09-12 - Restrict to predicative adj, to avoid for 
;; |[so much good] food|
;; Also tried to use --SBRD + to avoid for |isn't much fun|, but too restrictive
;; since it also prevents |much tall|, so undo, and count on ranking to block.
;;
av_-_dg-v_le_rbst := av_-_dg-v_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAT.HEAD basic_adj & 
                                                   [ PRD + ],
    GENRE robust ].

; |We went to Olympics|
n_-_c-nm-pl_le_rbst := n_intr_named_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.NORM norm_rel,
			   VAL.SPR.FIRST unexpressed ],
		     CONT.HOOK.INDEX.PNG.PN 3p ],
	     PUNCT no_punctuation_min ],
    GENRE robust ].

;; |ten times as larger|
;; Let's restrict this to predicative APs for now, to avoid spurious coord as
;; in |bigger and prettier house|
lex_rule_compar_equative := lex_rule_basic & word_or_infl_rule &
  [ ORTH #orth,
    INFLECTD +,
    KEY-ARG #keyarg,   
    SYNSEM [ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN comp_er_rel,
					MOD #mod,
					PRD + ],
			   VAL [ SPR < synsem &
					   [ --MIN comp_as_too_degree_rel,
					     OPT -,
					     LOCAL.CAT.VAL.SPR *olist* ] >,
			         SUBJ #subj,
			         COMPS < >,
			         SPEC #spec ] ],
		     CONT #cont,
		     CONJ #conj,
		     CTXT #ctxt,
		     AGR #agr,
		     ARG-S #arg-s ],
	     NONLOC #nonloc,
	     OPT #opt,
	     --MIN #min,
	     --SIND #sind,
	     LEX #lex,
	     MODIFD #modifd,
	     PHON #phon,
	     PUNCT #punct,
	     LKEYS #lkeys ],
    ARGS < #dtr >,
    ALTS.COMPEQ +,
    DTR #dtr & [ ORTH #orth,
		 KEY-ARG #keyarg,   
		 ALTS.AVIP -,
		 SYNSEM [ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN comp_rel,
						     MOD #mod ],
					VAL [ SPR.FIRST [ OPT +,
							  --MIN much_deg_rel ],
					      SUBJ #subj,
					      SPEC #spec,
					      COMPS *olist* &
					      [ FIRST.--MIN 
						     _than_p_compar_rel ] ] ],
				  CONT #cont,
				  CONJ #conj,
				  CTXT #ctxt,
				  AGR #agr,
				  ARG-S #arg-s ],
			  NONLOC #nonloc,
			  OPT #opt,
			  --MIN #min,
			  --SIND #sind,
			  LEX #lex,
			  MODIFD #modifd,
			  PHON #phon,
			  PUNCT #punct,
			  LKEYS #lkeys ] ],
    C-CONT.RELS <! !>,
    GENRE robust ].

av_pp_dg-as_le_rbst := que_word &
  [ SYNSEM as_degree_spec_synsem,
    GENRE robust ].

;; |we ran one and a half mile|
aj_np_i-frct-one_le_rbst := aj_np_i-frct-one_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.AGR.PNG.PN 3s,
    GENRE robust ].

;; |we would rather take a train than went by bus|
;;
vp_coord_asym_top_phr_mal := basic_basic_v_coord_phr & top_coord_rule & 
			     basic_top_coord_event_rule & xp_coord_phr & 
			     norm_coord_phr &
  [ SYNSEM.LOCAL [ CAT.HEAD [ VFORM non_fin & #vform,
			      PRD - ],
		   AGR.PNG #png ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ VFORM #vform,
				      PRD - ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD [ VFORM fin_or_bse_or_prp,
					AUX -,
					--MALN3SG - ],
			     AGR.PNG #png ],

   C-CONT.RELS <! !>,
   GENRE robust ].

;; |it is sure that we will win|
aj_pp-cp_i-it_le_rbst := reg_adj_atrans_cp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
    GENRE robust ].

c_-_so-on_le_rbst := et_conj_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _so+on_c_rel,
				ARG1 conj-ind ] !>,
    GENRE robust ].

;; block |[and so] on|
conj_mod_int_phrase :+
  [ NH-DTR.SYNSEM.MODIFD notmod ].

_place_a_sel_rel := selected_adj_rel.

;; Use for |by (the) bus/car/train|
transport_sort := norm-entity-or-event & entity-or-nomevent.

n_-_c-transp_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL.ARG0.SORT transport_sort ] ].

n_pp_c-of-transp_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN diadic_nom_rel,
		     CONT.HOOK.INDEX.SORT transport_sort ],
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

;; Prevent robust analysis of |they are warm-blooded, not cold-blooded|
n-adj_phrase :+
  [ SYNSEM.LOCAL.CAT.HEAD.--SBRD na ].

;; For robust possessive compounds |the book's shop|
n_-_c-poss-cpd_le_rbst := n_intr_lex_entry &
  [ GENRE robust ].

av_-_s-cp_le_mal := basic_word &
  [ INFLECTD +,
    SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL [ CAT.HEAD [ MOD < [ LOCAL.CAT [ HEAD.INV -,
						    MC bool ] ] >,
				--ADVADJ -,
				MINORS.MIN adv_rel ],
		     CONT.RELS <! #keyrel !>,
		     CONJ cnil ],
	     NONLOC non-local_none,
	     PUNCT [ LPUNCT no_punct,
	             RPUNCT no_punct ],
	     LKEYS.KEYREL #keyrel ] ].

; |it was kind for/of kim to arise|
aj_pp-vp_i-for-it_le_rbst := norm_adj_word &
  [ SYNSEM reg_adj_atrans_synsem &
           [ LOCAL.CAT.VAL.COMPS.FIRST.OPT -,
	     LKEYS.--COMPKEY _for_p_sel_rel ],
    ALTS.TOUGH -,
    GENRE robust ].

;; Avoid spurious NP-NP for |he sent 20 dollars|
;; DPF 2018-11-23 - Block bare-NP to avoid robust |to share with my friends|
n_-_c-meas-nb_lexent :+
  [ SYNSEM.LOCAL.CAT [ HEAD.--BARE -,
		       VAL.SPR.FIRST expressed_synsem ] ].

; |under-developing area| => |under-developed|
aj_-_i-ing-ed_le_rbst := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    --SBRD bool ],
    GENRE robust ].


;; DPF 2018-03-30 - Constrain to infinitival VP, and get the dispreferred
;; -ing variant via lexical rule: |it was difficult making a choice|
aj_pp-vp_i-it_le :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.VFORM inf ] > ].

; Block from undergoing the robust lexical rule for |easy to arise| => |arising|
aj_pp-vp_i-it-unsp_le := norm_adj_word &
  [ SYNSEM reg_adj_atrans_synsem &
           [ LKEYS.--COMPKEY _for_p_sel_rel ],
    ALTS.AVIP - ].

; |it is difficult admiring Kim|
adj_vp_inf_prp_mal_lr := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM reg_adj_atrans_synsem &
	  	 [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.VFORM inf ] > ],
	  ALTS.AVIP + ],
    SYNSEM reg_adj_atrans_synsem &
	  	 [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.VFORM prp ] > ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    GENRE robust ].

;; |Kim is easy to talk to her|
adj_vp_inf_seq_mal_lr := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM reg_adj_atrans_synsem &
	  	 [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.VFORM inf ] > ] ],
    SYNSEM basic_adj_vpcomp_synsem &
	 [ LOCAL [ CAT [ HEAD adj & [ MINORS.MIN norm_adj_rel,
	                              MOD *anti_list*,
				      --SBRD - ],
			 VAL.COMPS < [ LOCAL [ CAT.HEAD.VFORM inf,
					       CONT.HOOK.LTOP #vhand ] ] > ],
		   CONT [ HOOK.XARG.PNG.GEN animate,
		          RELS <! relation !>,
			  HCONS <! qeq & [ HARG #hand,
					   LARG #vhand ] !>,
			  ICONS <! !> ] ],
	   MODIFD.LPERIPH -,
	   LKEYS.KEYREL.ARG1 handle & #hand ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    GENRE robust ].

; |given enough time _and_ we will finish|
av_-_dc-conj_le_rbst := adv_disc_like_lexent &
 [ SYNSEM.LOCAL.CAT 
     [ HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_or_no_punct,
		    LOCAL.CAT [ HEAD prep & [ TAM.TENSE untensed,
		                              MOD.FIRST.LOCAL scopal_mod ],
			        VAL.SPR < >,
		    	        POSTHD - ],
		    --MIN subord_rel ] >,
       POSTHD + ],
   GENRE robust ].

; |nothing is more important than read this book|
; Restrict to only complement of comparative adj to avoid robust
; |rather sing than read|, by imposing LPERIPH na on this prep.
;;
p_vp_ptcl-bse_le_rbst := p_vp_ptcl-ngap_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM bse,
	     MODIFD.LPERIPH na ],
    GENRE robust ].

; |what will he say is not known|
np_cp_wh_rule_mal := rule & basic_np_cp_wh_phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD.INV +,
                                VAL.SUBJ *anti_list* & *olist*,
                                MC + ] ] > ].

; Prevent yes-no as dtr in the above mal rule
yesno_phrase :+ 
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM no_rel ].

; adverb used as attrib adjective: |the widely use of the internet|
aj_-_i-adv_le_rbst := reg_adj_word &
  [ SYNSEM basic_attr_adj_synsem,
    GENRE robust ].

;; Avoid spurious ambig for |five hundred [words composition]|
n_nb_c-qt_le :+
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s ].

;; Exclude robust compar-equative LR for either dtr
;adj_coord_phr :+
;  [ LCONJ-DTR.ALTS.COMPEQ -,
;    RCONJ-DTR.ALTS.COMPEQ - ].

;; Block left-modif of CP complement, to avoid spurious ambig as in
;; |they saw the film long before, so they made up their minds|
p_cp_i-nmod_le :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.MODIFD notmod_or_rmod ].

;; Pull TAM feature E up to supertype, so we can impose constraints on tense
;; in np_adv construction in order to detect tense mismatch as in
;; |we will arrive yesterday|
ind_or_event_or_conj :+
  [ E tam_min ].

;; But then also constrain ref-ind to be E.TENSE no_tense, so we don't get
;; robust |event last Saturday|
ref-ind :+
  [ E.TENSE no_tense ].

;; Block robust singular as head
basic_appos_phr :+
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD.--BARED - ].

;; Avoid robust PP particle for ordinary verb-particle-NP as |take in the view|
;; But using CASE acc here is wrong because lexical PP particles are CASE obliq,
;; so we would lose |get together the crew|
#|
generic_NP_particle_subst :+
  [ LOCAL.CAT.VAL.COMPS.REST.FIRST.LOCAL.CAT.HEAD.CASE acc ].
particle_subst :+
  [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.CASE acc ].
prep_passive_synsem :+
  [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.CASE acc ].
|#

_clean_p_sel_rel := selected_prep_rel.

;; Block robust |he spoke quietly|
frag_int_adv_rule :+
  [ SYNSEM.LOCAL.CAT.POSTHD + ].

cp_frag_intrans_verb :+
  [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL [ CAT.POSTHD -,
				      CONJ cnil ] ].

;; Prevent robust v_np_pp from undergoing nominal gerund, via NORM norm_rel.
trans_nominal_gerund :+
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM norm_rel ].

;; Prevent robust adj_vp_inf_prp_mal_lr for |interesting to study|
tough_adj_lr :+
  [ DTR.ALTS.AVIP - ].

frag_pp_ind_rule :+
  [ SYNSEM.LOCAL.CAT.POSTHD + ].

reg_adj_cp_word :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF prop-or-comm ].

reg_adj_atrans_cp_word :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF prop-or-comm ].

p_cp_ptcl-gap_lexent :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD [ --MAL3SG -,
						      --MALN3SG - ] ].

p_cp_ptcl-npgap_le :+
 [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.NONLOC.SLASH <! [CAT.HEAD.CASE non_nom]!> ].

filler_head_fin_np_rel_rule :+
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.CASE non_obliq ].

;; DPF 2018-09-18 - Not clear what these constraints aimed to achieve, but
;; they get in the way of |Recess is a time to enjoy|, so comment out, and
;; CHECK.
#|
n_pp_mc-of-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_-_c-ed-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_-_c-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_-_c-ns-nocnh_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_-_c-sg-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_pp_c-ns-obl-agr_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_pp_c-ns-obl_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_pp_c-ns-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_pp_c-ns-nocnh_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_pp_c-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_-_m-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_-_mc-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_-_mc-ns-g_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_pp_mc-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
n_pp_c-gr-of-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].
|#

;; Avoid robust |they break plates|
frag_np_rule :+
  [ ARGS.FIRST.SYNSEM.LOCAL [ CAT.HEAD.--POSSRBST -,
			      CONT.HOOK.INDEX.SORT norm-entity-or-event ] ].

;; Add strange constraint AUX - to exclude robust "why" as in |we knew why to
;; arise|
filler_head_rule_wh_root :+
  [ NH-DTR.SYNSEM.LOCAL.CAT.HEAD.AUX - ].
filler_head_rule_wh_nr_fin :+
  [ NH-DTR.SYNSEM.LOCAL.CAT.HEAD.AUX - ].
filler_head_rule_wh_nr_inf :+
  [ NH-DTR.SYNSEM.LOCAL.CAT.HEAD.AUX + ].

; Block robust |look the best|
partitive_adj_lex_nocomp_rule :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARED + ].

c_xp_not-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL [ CONJ not-conj,
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD n_or_a_or_p_or_adv ] ].

;; Restrict to VP-modifying adverbs
frag_adv_rule :+
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.VAL.SUBJ *oblcons* ].

frag_sent_adv_rule :+
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST unexpressed ].

; Block in robust n-j-cmpnd rule for |place great|
n_pp_c-plc-of_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT place ].

;; Prevent misanalysis of |He gave his math students homework.|
;; and |he buys his cats cat toys|
;; Also exclude pronouns for second NP.
;;
ditrans_subst :+
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.--MALPLCPD - ],
			  [ LOCAL.CAT.HEAD.--MALPLCPD - ] > ].

np_coord_rule :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE #bare,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.--BARE #bare ].

;; Propagate CASE to mother so we can flag |me and him arrived|
;; Also propagate RPERIPH so we can block NP-N for |Leah and her class|
np_coord_top_eg_rule := np_coord_top_rule &
  [ SYNSEM [ LOCAL.CAT.HEAD.CASE #case,
             MODIFD.RPERIPH #rperiph ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    RCONJ-DTR.SYNSEM.MODIFD.RPERIPH #rperiph ].

;; Assign TENSE untensed to prevent these as ordinary CP complements for "ask"
;; DPF 2018-07-25 - Added NORM no_rel to prevent sentence |if we arise arose|
cm_np-vp_wh_le_mal := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD comp & [ TAM.TENSE untensed,
                                     MINORS.NORM no_rel ],
                       VAL [ SUBJ < >,
			     COMPS < [ LOCAL.CAT.HEAD.TAM indic_tam ] > ] ] ].

;; Prevent spurious analysis of |Leah and her class| as NP-N compound
np_n_cmpnd_phr :+
  [ NH-DTR.SYNSEM.MODIFD.RPERIPH bool ].

;; Prevent by_means_rbst as in |was amazed by everything|
;; DPF 2018-09-14 - But this blocks |don't teach me anything|.  Instead,
;; constrain SORT to entity-or-event.
n_generic_pro_lexent :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT entity-or-event ].

;; Block |the sign-up sheet| as mid-coord no-conj
nom_coord_mid_noconj_rule :+
  [ LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.--BARED -,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.--BARED - ].

np_coord_top_noconj_rule :+
  [ LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.--BARED -,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.--BARED - ].

;; DPF 2018-10-15

basic_initial_cap_rule := basic_lex_rule_supermost & word_or_punct_rule &
  [ SYNSEM abstr_lex_synsem & #synsem,
    KEY-ARG #keyarg,   
    DERIVED #derived & -,
    TOKENS #tokens,
    RNAME #rname,
    INFLECTD #infl,
    DTR #dtr,
    C-CONT.RELS <! !>,
    ORTH [ FIRST #first, REST #rest, FORM #form, FROM #from, TO #to,
    	   LB #lb, RB #rb, LD #ld, RD #rd,
	   CLASS [ +INITIAL -, +CASE #case ] ],
    ARGS < #dtr &
           [ KEY-ARG #keyarg,
	     SYNSEM #synsem,
	     DERIVED #derived,
	     TOKENS #tokens,
	     RNAME #rname,
	     INFLECTD #infl,
             ORTH [ FIRST #first, REST #rest, FORM #form, FROM #from, 
	            TO #to, LB #lb, RB #rb, LD #ld, RD #rd,
		    CLASS.+CASE #case ] ] > ].

initial_cap_rule := basic_initial_cap_rule.

missing_initial_cap_rule := initial_cap_rule &
  [ ARGS < [ ORTH.CLASS alphabetic & 
                        [ +INITIAL +, +CASE non_capitalized ] ] >,
    GENRE robust ].

has_initial_cap_rule := initial_cap_rule &
  [ ARGS < [ ORTH.CLASS non_ne & [ +INITIAL +, +CASE capitalized ],
             GENRE #genre ] >,
    ORTH.TOKCASE non_capitalized,
    GENRE #genre ].

has_noninitial_cap_rule := basic_initial_cap_rule &
  [ ARGS < [ ORTH [ CLASS alphabetic & 
                         [ +INITIAL -, +CASE capitalized ],
		    TOKCASE capitalized ],
	     ALTS.NONINITCAP + ] >,
    ORTH.TOKCASE non_capitalized,
    GENRE robust ].

named_entity_cap_rule := initial_cap_rule &
  [ ARGS < [ ORTH.CLASS named_entity & [ +INITIAL + ],
             GENRE #genre ] >,
    GENRE #genre ].

initial_numeric_rule := initial_cap_rule &
  [ ARGS < [ ORTH.CLASS numeric & [ +INITIAL + ],
             GENRE #genre ] >,
    GENRE #genre ].

;; Pull up attributes +INITIAL and +CASE.
regular_class :+
  [ +INITIAL luk,
    +CASE token_case ].

phrase :+
  [ ARGS.FIRST.ORTH.CLASS.+INITIAL - ].

;; DPF 2018-07-31 - Removed MOD.FIRST unexpressed so we can use the type to
;; prevent directional PPs from modifying nouns as in |stars into ...|
;; FIX someday?
;;
prep_intrans_dir_verb := twoarg_verb_synsem & basic_prep_intrans_subst &
                         prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < canonical_or_unexpressed &
			  [ --MIN dir_or_unsp_loc_rel,
                            LOCAL.CAT [ HEAD prep_or_modnp &
                                        [ MOD < [LOCAL.CAT.HEAD v_or_a_or_p]>],
					VAL [ SPR *olist*,
                                              COMPS < > ],
                                        MC na ] ] > ].

;; Assign default value [PT notpro].
noun_word :+
  [ SYNSEM.--SIND.PT notpro ].
noun_hclex_word :+
  [ SYNSEM.--SIND.PT notpro ].
n_numcomp_lexent :+
  [ SYNSEM.--SIND.PT notpro ].
n_pp_mc-of-lhc_lexent :+
  [ SYNSEM.--SIND.PT notpro ].
n_pp_c-of-lhc_le :+
  [ SYNSEM.--SIND.PT notpro ].
basic_n_intr_infl_lex_entry :+
  [ SYNSEM.--SIND.PT notpro ].
n_pred_lexent :+
  [ SYNSEM.--SIND.PT notpro ].
basic_np_sing_word :+
  [ SYNSEM.--SIND.PT notpro ].
basic_n_proper_lexent :+
  [ SYNSEM.--SIND.PT notpro ].
abstr_hour_word :+
  [ SYNSEM.--SIND.PT notpro ].
basic_n_day_part_lexent :+
  [ SYNSEM.--SIND.PT notpro ].
n_def_day_part_lexent :+
  [ SYNSEM.--SIND.PT notpro ].
noun_do_be_synsem :+
  [ --SIND.PT notpro ].

;; DPF 2019-01-17 - And remove XARG.PT zero here since it prevented |a week ago|
;;
aj_-_i-one-nmd_le := adj_one_prd_lexent &
"""
Adj, only 'one' cannot modify    
<ex>The cat weighs a kilo.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [ PHON.ONSET con_or_unk,
					  LOCAL.CAT.VAL.SPR.FIRST unexpressed,
					  --MIN abstr_meas_nom_rel ] >,
				  MINORS.ALTMIN no_rel ],
			   VAL.SPEC < [ PHON.ONSET con_or_unk ] > ] ],
	     MODIFD hasmod & [ LPERIPH na ] ] ].

;; Avoid robust by-means-time in |by waste|
n_-_mc-ns_lexent :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].

;; Prevent as head of compound for e.g. |fan hope|
n_pp_mc-of-ns-nochd_le := noun_word &
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
           [ LOCAL [ CAT.HEAD.MINORS.MIN reg_diadic_nom_rel,
		     CONT.HOOK.INDEX.SORT entity-or-qevent ],
	     MODIFD lmod & [ LPERIPH + ],
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_pp_mc-of-ns_le :+
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nontime-or-qevent ].

aj_pp_i-cmp-sme_le_rbst := aj_pp_i-cmp_lexent &
  [ SYNSEM 
   [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SPR < unexpressed > ] > ],
   GENRE robust ].

;; Plural: |ten cents per children|
;;
p_nb_i_le_rbst := p_nb_i_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.AGR.PNG.PN 3p,
    GENRE robust ].

;; For |Kim picked up him|
robust_particle_NP_verb := verb_synsem & basic_particle_NP_subst & 
                           particle_NP_lt &
  [ LOCAL.CAT.VAL.COMPS < [], [ --MIN basic_pron_rel ] > ].

NP_particle_lr_mal := basic_NP_particle_lr &
  [ SYNSEM robust_particle_np_verb,
    GENRE robust ].

;; Adj taking NP instead of PP
;; |Kim is close the desk|
;; block robust |close enough|
;; 
aj_np_i_le_rbst := aj_np_i_lexent &
  [ GENRE robust,
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun ].

;; Block robust |on the fourth of July|
;; Block robust |one of a group (of cats)|
n_pp_c-gr-of_le :+
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ CAT.HEAD.MINORS.ALTMIN
                                                   non_temp_nom_rel ],
		   AGR.DEF + ] ].

n_group_nocomp_lexent :+
  [ SYNSEM.LOCAL.AGR.DEF + ].


; Block robust |in costume|
basic_n_bare_lex_entry :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

; Block robust |on Wednesday night|
basic_n_day_part_lexent :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

;; Block robust |ate some|
n_-_c-approx_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

;; Block robust |from branch to branch|
p_np-pp_i-frm-to_le :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.--BARE - ].

;; DPF 2019-01-20 - Block |as possibly|
av_-_dg-cmp-so_le :+
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL 
                                                            intersective_mod ].

;; Block |reasons why humans|
x_xp_howabt-n-p_le :+
  [ SYNSEM.LOCAL.CAT.MC + ].

;; For |1st prize) like |1st place|
n_-_c-ord_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD [ MINORS [ MIN _place_n_1_rel,
			  	       ALTMIN abstract_q_rel ],
			      --BARE - ],
             LKEYS.KEYREL.ARG0.PNG.PN 3s ] ].

;; DPF 2019-04-17 - Remove `event' on ARG1 so we can allow adverbs in place
;; of prenominal adjectives.
;;
basic_int_adverb_synsem := basic_basic_adverb_synsem & isect_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.MC na_or_-,
				   CONT.HOOK.INDEX #index ],
			   NONLOC.QUE 0-dlist ] >,
    LKEYS.KEYREL.ARG1 #index ].

;; DPF 2019-04-22 - Enable lexical blocking of robust adverb-for-adjective rule.
;;
basic_adv :+
  [ --ADVADJ bool ].

adv_s_pre_lexent :+
  [ SYNSEM.LOCAL.CAT.HEAD.--ADVADJ - ].

basic_adv_refl_pro_lexent :+
  [ SYNSEM.LOCAL.CAT.HEAD.--ADVADJ - ].

av_-_i-vp-po-cmp_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.--ADVADJ - ].

av_-_i-vp-cmp_le :+ 
  [ SYNSEM.LOCAL.CAT.HEAD.--ADVADJ - ].

av_-_i-vp-dg_le_rbst :+ 
  [ SYNSEM.LOCAL.CAT.HEAD.--ADVADJ - ].

;; Allow pre-nom adverbs in place of adjectives
adv_noun_phrase := head_mod_phrase & binary_headed_phrase & head_final &
		   head_nexus_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL #val,
	     LEX #lex,
	     NONLOC #nonloc & [ SLASH 0-dlist ] ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD basic_noun,
				  VAL #val & [ COMPS < >,
					       SPR.FIRST expressed_synsem ] ],
			    CONT.HOOK #hook & [ LTOP #ltop,
			                        INDEX #index ] ],
		    LEX #lex,
		    NONLOC #nonloc ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD reg_adv &
				       [ MOD *cons* &
					     [ FIRST.LOCAL int_mod_local &
					         [ CONT.HOOK.INDEX #index ] ],
					 --ADVADJ + ],
				  VAL.COMPS < > ],
			    CONT.HOOK [ LTOP #ltop ] ],
		    LEX +,
		    NONLOC non-local_none ],
    C-CONT [ HOOK #hook,
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    GENRE robust ].

;; DPF 2019-04-26 - For words like "part" which we don't want to undergo
;; bare-NP rule unless they are premodified: robust |we admire small part of it|
;; but not robust |we admire part of it|
n_-_c-ns-part_le := norm_intr_lex_entry &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
	   	     CONT.HOOK.INDEX.SORT entity-or-qevent ],
	     MODIFD.LPERIPH + ] ].

;; DPF 2019-04-29 - Even though by constraining the gap to 3s we lose
;; |We bought what we thought were the right amounts|, we can catch robust
;; |what arrive quickly are the fast cars|
;;
n_-_pr-fr_le := n_freerel_pro_lexent &
  [ SYNSEM [ LOCAL [ CONT.RELS.LIST.FIRST.PRED free_relative_q_rel,
		     AGR.PNG.PN 3s ],
             NONLOC.SLASH <! [ AGR.PNG.PN 3s ] !> ] ].

;; DPF 2019-05-06 - Ignore this for robustness, allowing as grammatical
;; |what bother us most are grumpy students.|
;; 2019-06-20 - Add CASE nom to avoid these as complements of be, preps.
;;
n_-_pr-fr_le_rbst := n_freerel_pro_lexent &
  [ SYNSEM [ LOCAL [ CONT.RELS.LIST.FIRST.PRED free_relative_q_rel,
                     CAT.HEAD.CASE nom,
		     AGR.PNG.PN 3s ],
             NONLOC.SLASH <! [ CAT.HEAD.CASE nom,
			       AGR.PNG.PN 3p ] !> ],
    GENRE robust ].

n_-_pr-fr_le_ignore := n_freerel_pro_lexent &
  [ SYNSEM [ LOCAL [ CONT.RELS.LIST.FIRST.PRED free_relative_q_rel,
                     CAT.HEAD [ CASE nom,
				--BARE na ], 
		     AGR.PNG.PN 3 ],
             NONLOC.SLASH <! [ CAT.HEAD.CASE nom,
			       AGR.PNG.PN 3p ] !> ] ].

;; Allow for |what bothers us is cats and dogs|
n_-_pr-fr-agr_le := n_freerel_pro_lexent &
  [ SYNSEM [ LOCAL [ CONT.RELS.LIST.FIRST.PRED free_relative_q_rel,
		     AGR.PNG.PN 3p ],
             NONLOC.SLASH <! [ CAT.HEAD.CASE nom,
			       AGR.PNG.PN 3s ] !> ] ].

;; |if admire kim, we arrive|
;;
p_vp_bse_le_rbst := nonconj & non_affix_bearing &
  [ SYNSEM subconj_bse_synsem,
    GENRE robust ].

;; For |we made a lot progress| - missing "of"
_a+lot_q_rel := explicit_noagr_nodef_q_rel.

n_np_mc-a_le :+
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.--BARESG - ].


vp_fin_cat := vp_cat &
  [ HEAD [ VFORM fin,
           TAM #tam & [ SAME-PAST - ],
	   --ADDIN.ADDTAM #tam,
	   --MAL3SG -,
	   --MALPAST -,
	   PRD - ],
    VAL.SUBJ < synsem > ].

fin_nontrans_raising_subst := three_arg_raising_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem &
			  [ LOCAL [ CAT vp_fin_cat &
					[ HEAD.--ADDIN.ADDPN #pn ],
				    AGR.PNG.PN #pn & 3s,
				    CONJ cnil ],
                            OPT - ] > ].

sor_fin_subst := fin_nontrans_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem &
                          [ --SIND #subj & nonconj_ref-ind,
                            LOCAL.CAT.HEAD.--MALCASE -,
			    OPT - ], 
                          canonical_synsem &
			  [ LOCAL [ CAT [ HEAD.TAM.ASPECT.PRF -,
					  VAL.SUBJ 
					  < [ NONLOC [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ],
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

obj_equi_fin_verb := verb_synsem & sor_fin_subst & obj_equi_bse_lt &
  [ LOCAL.CAT.HEAD.--MALFIN + ].

subconj_prdp_v_init_phrase :+
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.--MALFIN - ].

n_or_a := n_or_v_or_a.

; |China people|
n_-_c-cpd_le_rbst := n_-_c-cpd_lexent &
  [ SYNSEM.MODIFD lmod & [ LPERIPH + ],
    ORTH.TOKCASE non_capitalized,
    GENRE robust ].

; |They suffered frem lack of money| - missing article
n_-_m-nodet_le_rbst := norm_noun_word &
  [ SYNSEM mass_noun_synsem,
    GENRE robust ].

;; Block for |Lucy's English|
n_-_c-pl-nocnh_le :+
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.POSS - ].


;; Block for NP fragments |It's great news that ...|
d_-_poss-its-mal_le :+
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAT.HEAD.--POSSRBST + ].

;; |Mr.Browne|, |Feb.3|
sandwich_period_abb_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT #punct & 
                 [ LPUNCT no_punct,
                   PAIRED no_ppair,
                   RPUNCT no_punct ],
    GENRE #genre,
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT.HEAD basic_noun,
                      PUNCT #punct ],
             GENRE #genre ] > ].  

;; Block robust plural for |Feb.|
n_np_c-month_lexent :+
  [ SYNSEM.LOCAL sing_noun ].

nbar_coord_rule :+
  [ ARGS.REST.FIRST.SYNSEM.LOCAL.CAT.HEAD.--MALSPELL - ].

;; DPF 2019-11-11 - Changed mother's COMPS..NORM from norm_rel to 
;; quantiy_or_no_rel, to exclude |stuffed when I left|.
no_by_passive_verb_lr_mal := basic_passive_verb_lr &
  [ DTR [ SYNSEM trans_subst &
	  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #subjind, 
				     NONLOC #snonloc ] >,
			    COMPS < [ LOCAL.CONT.HOOK.XARG #compxarg,
				      NONLOC #ononloc ] > ] ],
	  ALTS.MALPASS + ],
    SYNSEM.LOCAL.CAT [ HEAD.--PASSNOBY +,
		       VAL [ SUBJ < [ LOCAL.CONT.HOOK.XARG #compxarg,
				      NONLOC #ononloc ] >,
			     COMPS < [ LOCAL [ CAT [ HEAD basic_noun &
						      [ MINORS.NORM
						          quantity_or_no_rel ],
						     VAL.SPR *olist* ],
					       CONJ cnil,
					       CONT.HOOK.INDEX #subjind &
					                       [ SORT entity ]],
       			               PUNCT.LPUNCT lparen_or_dq_or_no_punct,
				       NONLOC #snonloc & [ SLASH 0-dlist ],
				       OPT - ] > ] ],
    ALTS.ATTRJ -,
    GENRE robust ].

;; -----------------------------------------------------------------------------
;; 2019-07-09 - Enable check for unwanted non-initial capitalization 

orthog :+
  [ TOKCASE token_case ].

generic_binary_phrase :+
  [ ORTH.TOKCASE #tokcase,
    ARGS.FIRST.ORTH.TOKCASE #tokcase ].

basic_binary_phrase :+
  [ ARGS < [ ],
           [ ORTH.TOKCASE non_capitalized ] > ].

basic_unary_phrase :+
  [ ORTH.TOKCASE #tokcase,
    ARGS.FIRST.ORTH.TOKCASE #tokcase ].

lex_rule_supermost :+
  [ ORTH.TOKCASE #tokcase,
    ARGS.FIRST.ORTH.TOKCASE #tokcase ].

attr_adj_lr :+
  [ ORTH.TOKCASE #tokcase,
    ARGS.FIRST.ORTH.TOKCASE #tokcase ].

bridge_class := alphanumeric.

;; DPF 2019-07-09 - Default transparent TOKCASE value for most lexical types,
;; whose instances are all non-capitalized.
;;
aux_verb_word_super :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_loc_inv_verb_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_main_verb_sans_key :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
ssr_particle_v_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_adverb_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
norm_adv_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_prep_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_noun_noaffix_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
noun_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_mc-ed-nocnh_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_plur_mwe_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
; basic_n_intr_infl_lex_entry :+
n_-_c-meas-noagr_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_c-pl-def_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_c-sg-ifl-nmd_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_c-pl-nom_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_c-sg-ifl_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_c-pl_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
norm_intr_lex_entry :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_c-nocpd_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
; intr_n_bare_lex_entry :+
basic_n_bare_lex_entry :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_c-poss_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_pred_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_np_sing_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
np_pl_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
np_word_no_aff :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-recip_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_poss_pro_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
personal_pro :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_np_pr-you_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_nb_pr-you_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-it_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_np_pr-us_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_np_pr-we_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_np_pr-it_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_np_pr-they_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_np_pr-them_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_pers_pro_acc_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-you_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-us_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-he_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-she_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-she-he_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-we_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-they_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pr-thou_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
norm_pronoun_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_adv_refl_pro_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_n_rel_pro_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_pp_pr-dei-3pl_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
adj_attr_intrans_que_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
aj_-_i-att-nsp_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
aj_-_i-prd-ndpt_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
intrans_adj_oddsem :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
adj_reg_equi_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
aj_-_i-wh_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
aj_-_i-nspr_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
aj_-_i-numspr_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_compar_superl_adj_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
aj_pp_i-cmp-wthr_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
aj_pp-vp-pp_i-cmp-it_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
adj_atrans_superl_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
aj_cp_such_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_ditrans_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_pp_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
pp_-_ptcl_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
pp_-_i-po_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_n-or-p_x_to_y_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
aj_pp_i-x-to-y_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
av_-_i-vp-x-now_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
pp_-_i-wh_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
pp_-_i-rel_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_np_negcond_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
d_-_rel_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_det_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
poss_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
pred_a_prep_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
free_rel_pro_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
free_rel_det_word_gen :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_n_poss_clitic_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
subconj_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_cp_gap-s_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_cp_cp-gap_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_cp_s-cln_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_cp_s-for_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_cp_s-ncop_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_np-np_s-ncop_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_vp_bse_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_vp_inf_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_vp_inf-or-s_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_prd_s_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_prd_s-v-p_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_np_s_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
p_adv_s_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
complementizer_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
cm_-_to_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_s_compl_phrase_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
root_marker_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
basic_adv_disc_like_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
av_-_dc-spch-pr_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
av_-_spfill_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
av_-_dc-pls_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
x_-_wh-the-hell_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
abstr_hour_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_pn-mealtm_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
; basic_n_day_part_lexent :+
n_-_c-dpt_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_day_part_ppcomp_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
; n_def_day_part_lexent :+
n_-_c-dpt-df-sg_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_-_meas-gen_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
norm_num_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_np_c_lexent :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_nb_c_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_nb_c-qt_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
n_nb_c-pro_le :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].
norm_adj_word :+
  [ ORTH.TOKCASE #tokcase,
    SYNSEM.PHON.ONSET.--TL.FIRST.+CLASS.+CASE #tokcase ].

;; Allow capitalized lexical entries to be rule dtrs without undergoing the
;; robust noninitcap lexical rule.
;;
basic_n_proper_lexent :+
  [ ORTH.TOKCASE non_capitalized ].
basic_n_intr_named_lexent :+
  [ ORTH.TOKCASE non_capitalized ].
n_numcomp_lexent :+
  [ ORTH.TOKCASE non_capitalized ].
np_word :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_pr-i_lexent :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_tt-post_le :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_tt-post-mwe_le :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_c-meas-nb_lexent :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_c-meas-abb_le :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_c-meas-spr_le :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_m-ssn-spr_le :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_c-nochd_lexent :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_c-day_lexent :+
  [ ORTH.TOKCASE non_capitalized ].
n_np_c-month_lexent :+
  [ ORTH.TOKCASE non_capitalized ].
abstr_n_day_of_month_lexent :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_m-hldy_le :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_c-pre-ttl_le :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_c-dpt-df-pl_le :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_c-dpt-cap_le :+
  [ ORTH.TOKCASE non_capitalized ].
n_-_c-pl-nocnh_le :+
  [ ORTH.TOKCASE non_capitalized ].

aj_-_i-cap_le :+
  [ ORTH.TOKCASE non_capitalized,
    TOKENS.+LAST.+CLASS.+CASE capitalized ].
n_-_c-nocnh-cap_le :+
  [ ORTH.TOKCASE non_capitalized,
    TOKENS.+LAST.+CLASS.+CASE capitalized ].
n_-_c-maycap_le :+
  [ ORTH.TOKCASE non_capitalized ].

;;------------------------------------------------------------------------------

; |It was good news he arrived.|
n_cp_m-nocmp_le_rbst := noun_word &
  [ SYNSEM mass_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
			 VAL [ COMPS.FIRST.LOCAL.CAT.HEAD verb,
			       SPR.FIRST.NONLOC.QUE 0-dlist ] ] ],
    GENRE robust ].

attr_verb_part_namemod_lr :+
  [ ARGS.FIRST.ALTS.MALPASS - ].

verbal_predp_coord_phr :+
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.--PASSNOBY - ],
	   [ SYNSEM.LOCAL.CAT.HEAD.--PASSNOBY - ] > ].

prd_trans_subst :+
  [ LOCAL.CAT.VAL.COMPS.REST.FIRST.LOCAL.CAT.HEAD.--PASSNOBY - ].

prd_non_trans_subst :+
  [ LOCAL.CAT.VAL.COMPS.REST.FIRST.LOCAL.CAT.HEAD.--PASSNOBY - ].

;; |Kim tried to arose|
cm_vp_to-fin_le_rbst := basic_to_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf,
                       VAL.COMPS < [ LOCAL [ CAT vp_fin_cat &
						  [ HEAD.--ADDIN.ADDPN #pn ],
					     AGR.PNG.PN #pn & 3s ] ] > ],
    GENRE robust ].

;; Reverse order of obj arguments, for mal |we took care the cat|
mal_ditrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
                  < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #obj2ind & non_expl-ind &
					     [ SORT entity-or-nomevent ] ] ],
		    [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #objind & non_expl-ind &
					[ SORT entity-or-nomevent ]]], ... >],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG1 non_expl-ind,
				     ARG2 #obj2ind,
                                     ARG3 #objind ] ].

mal_ditrans_only_verb := verb_synsem & ditrans_subst & mal_ditrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

;; We saw thousands pictures.
n_np_c_le_rbst := n_np_c_lexent &
  [ SYNSEM common_noun_npcomp_synsem &
           [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ],
    GENRE robust ]. 

;; DPF 2018-05-25 - Added NORM norm_rel to prevent these in v_mod to block
;; spurious ambiguity of e.g. |jump in trees|
;;
pp_-_i_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM norm_rel ].

;; To block nbar coord of |indifferent on the ouside and enthusiastic inside|
;;
n_pp_c-nocnh-nomod_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS [ MIN diadic_nom_rel,
					 NORM norm_rel ],
				--BARE - ],
		     CONT [ RELS <! relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     MODIFD rmod,
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

;; DPF 2019-10-01 - Treat "going to" like "will": semantically empty. And not
;; [TENSE future] because of conflict in |was going to|
;;
basic_quasimodal_verb_synsem := generic_modal_verb_super_synsem &
  [ LOCAL [ CAT [ HEAD [ MINORS.MIN _going+to_v_qmodal_rel,
			 TAM.TENSE real_tense ],
		  VAL [ COMPS.FIRST #comp & canonical_or_unexpressed &
				 [ LOCAL [ CAT.VAL.SUBJ.FIRST.OPT -,
					   CONT.HOOK.LTOP #ltop ] ],
			KCMP #comp ] ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! !>,
		   HCONS <! !> ] ],
    LKEYS.KEYREL [ LBL #ltop,
		   PRED will_modal_rel ] ].

generic_modal_verb_word := generic_modal_verb_word_super &
  [ SYNSEM generic_modal_verb_super_synsem ].

;; DPF 2019-10-01 - Enable regular cl-cl coord for |We arise. But they sleep.|
;; so we don't get an extra coord relation with the run-on.
;;
basic_basic_verbal_coord_phr := gen_coord_phr &
  [ SYNSEM [ LEX -,
             LOCAL.CAT [ HEAD verbal,
			 VAL.SPCMPS < >,
                         MC #mc ] ],
    LCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal,
				     MC #mc ],
			       CONT.HOOK.LTOP #ltop ],
		       NONLOC.SLASH.LIST *arglist*,
                       PUNCT.RPUNCT clause_or_semi_or_comma_or_no_punct ],
    RCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal,
				     MC #mc ],
			       CONT.HOOK.LTOP #ltop ],
		       NONLOC.SLASH.LIST *arglist* ] ].

basic_top_coord_rule := binary_rule_right_to_left & gen_coord_phr &
  [ SYNSEM [ LOCAL [ CONT.HOOK.INDEX #ind,
                     CONJ cnil & [ LCHEAD #left ] ],
             PUNCT [ LPUNCT #lpunct,
                     PAIRED #rpnctpr,
                     RPUNCT #rpunct ] ],
    LCONJ-DTR.SYNSEM [ LOCAL local & [ CONJ conj_min & #left ],
                       PUNCT [ LPUNCT #lpunct,
                               PNCTPR #pnctpr ] ],
    RCONJ-DTR.SYNSEM [ LOCAL local &
                       [ CONT.HOOK.INDEX #ind,
                         CONJ complex-conj & 
                              [ CHEAD #left,
                                CPUNCT #pnctpr ] ],
                       PUNCT [ LPUNCT lital_or_pair_or_no_punct,
                               RPUNCT #rpunct,
                               PAIRED #pnctpr,
                               PNCTPR #rpnctpr ] ],
    C-CONT.HOOK.INDEX #ind & conj-ind ].

s_coord_top_phr := basic_s_coord_top_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.INV #inv,
    LCONJ-DTR.SYNSEM [ LOCAL [ CAT.HEAD.INV #inv,
			       CONT.HOOK.INDEX.SF prop-or-comm ],
		       PUNCT.RPUNCT clause_or_semi_or_comma_or_no_punct ] ].

;; DPF 2019-11-08 - This unhappily blocks 
;; |Most obviously, not only are we late but we forgot the gift.|  So undo, and
;; check resutls.  FIX?
#|
av_-_dg-sup_lexent :+
  [ SYNSEM.MODIFD.LPERIPH na ].
|#

n_pp_c-nsnc-of-nochd_le := n_pp_c-nsnc-of_lexent &
  [ SYNSEM.MODIFD.LPERIPH + ].

;; |He was asked arise|
obj_equi_bse_trans_verb := verb_synsem & sor_bse_subst & obj_equi_bse_lt &
			   trans_subst.

;; |We will leave at now / at today|
pp_-_i-temp_le_rbst := pp_word &
 [ GENRE robust ].

;; Mal type for wrongly capitalized |The tea Festival|
;; NORM on hd-dtr blocks measure-NPs as in |dinner an hour|
;; SORT entity on head blocks |moment last summer|
;; SORT entity on non-head blocks |place great changes|
;;
noun_n_cmpnd_cap_rule := binary_rule_right_to_left & basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM abstr_lex_synsem & 
		  [ LKEYS.KEYREL.PRED named_n_rel,
		    LOCAL [ CAT.HEAD.MINORS.NORM norm_or_no_rel,
			    CONT.HOOK.INDEX.SORT entity ],
		    MODIFD notmod_or_lmod & [ LPERIPH bool ],
		    PUNCT.LPUNCT dq_or_no_punct ],
    NH-DTR [ INFLECTD na_or_-,
	     SYNSEM [ LOCAL.CONT.HOOK.INDEX nonconj_ref-ind &
					    [ SORT entity ],
		      PUNCT.RPUNCT hyphen_or_pair_or_no_punct ] ] ].

;; |We arrive on 4th May|
n_-_pn-dom-euro_le_rbst := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_euro_synsem,
    GENRE robust ].

;; Avoid robust |in summer|
n_-_c-ssn_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.--BARED - ].

;; Avoid |3rd July| as adj-noun
aj_-_i-ord-gen_le :+
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.--MIN non_temp_nonpro_rel ].