;; Delimiters (weak brackets)

;; These constraints enable the propagation and discharge of (weak) delimiters
;; of the kind introduced in token mapping for hyphens as in
;; |Santa Clara-based|.

;; Add features in ORTH for left and right delimiters (weak brackets), with
;; diff-list values.

orthog :+
  [ LB bracket_list,
    RB bracket_list,
    LD bracket_list,
    RD bracket_list ].

root_orth :+
  [ LB bracket_null, RB bracket_null,
    LD bracket_null, RD bracket_null ].

;; DPF 2013-06-20 - We have added support for introducing bracketing
;; and syntactic dependency constraints onto tokens in preprocessing,
;; recorded in their +TRAIT feature.  These constraints are propagated
;; here onto attributes of the feature structure which is visible to the
;; syntactic rules.
;;
;; The +LB (left bracket) and +RB (right bracket) attributes take as
;; value a (possibly empty) list of ctypes, elements in the hierarchy
;; of construction types defined in the file `ctypes.tdl'.  The basic
;; idea is that a well-formed phrase cannot cross brackets, and each
;; construction will unify its own ctype with that required by a
;; bracket pair (where the bracket ctype can be more or less
;; construction-specific.  Such bracket constraints could be supplied
;; by a preprocessor such as a named-entity recognizer or a chunk
;; parser.  At present we have two types of token-mapping rules that 
;; introduce brackets: (1) weak brackets to keep hyphenated expressions such 
;; as |snow-covered| together, avoiding spurious analyses that would
;; associate the left and right sides of the hyphen to different
;; phrases; and (2) some placeholder token-mapping rules for
;; named entities such as |[New York] [Stock Exchange]|, where eventually
;; we would expect to get these labeled bracketed expressions from some
;; external resource.
;; 
;; Propagate delimiters from tokens to ORTH, both for strong and weak brackets,
;; where the strong ones let us constrain constructions over a phrase based on
;; some external guidance, and the weak ones let us avoid boundaries at
;; hyphens, as in |sun-drenched| or |2-3|
;;
basic_word :+
  [ ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ],
    TOKENS [ +LIST.FIRST.+TRAIT [ +LB #lb, +LD #ld ],
	     +LAST.+TRAIT [ +RB #rb, +RD #rd ] ] ].

;; Lexical rules: identify delimiter constraints on dtr and mother

lex_rule_supermost :+
  [ ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ],
    ARGS.FIRST.ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ] ].

;; Unary phrases: identify delimiter constraints on dtr and mother.

norm_unary_phrase :+
  [ ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ],
    ARGS < [ ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ] ] > ].

n-adj_phrase :+
  [ ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ],
    ARGS < [ ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ] ] > ].

basic_npadv_mod_phrase :+
  [ ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ],
    ARGS < [ ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ] ] > ].


;; Normal headed binary phrases: block crossing of delimiter brackets, and
;; propagate from dtrs to mother.

no_inner_delim_phrase := phrase &
  [ ORTH [ LB #lb, RB #rb, LD #ld, RD #rd ],
    ARGS < [ ORTH [ LB #lb, RB bracket_null, 
                    LD #ld, RD bracket_null ] ],
	   [ ORTH [ LB bracket_null, RB #rb, 
	            LD bracket_null, RD #rd ] ] > ].

basic_head_initial :+ no_inner_delim_phrase.
binary_headed_phrase :+ no_inner_delim_phrase.
basic_head_filler_phrase :+ no_inner_delim_phrase.
basic_head_comp_or_marker_phrase :+ no_inner_delim_phrase.
basic_head_spec_phrase :+ no_inner_delim_phrase.
subjh_rule_basic :+ no_inner_delim_phrase.
basic_head_mod_phrase_simple :+ no_inner_delim_phrase.
n_n_cmpnd_phr :+ no_inner_delim_phrase.
noun_title_cmpnd_phr :+ no_inner_delim_phrase.
fw_sequence_left_phrase :+ no_inner_delim_phrase.
fw_sequence_right_phrase :+ no_inner_delim_phrase.
basic_run_on_rule :+ no_inner_delim_phrase.
min_coord_phr :+ no_inner_delim_phrase.
np_pred_phr :+ no_inner_delim_phrase.
binary_frag_rule :+ no_inner_delim_phrase.
bridge_binary_phrase :+ no_inner_delim_phrase.

;; Same for non-binary phrases: prevent crossing and propagate.

basic_ternary_phrase :+
  [ ORTH [ LB #lb,
	   RB #rb,
	   LD #ld,
	   RD #rd ],
    ARGS < [ ORTH [ LB #lb, RB bracket_null,
                    LD #ld, RD bracket_null ] ],
	   [ ORTH [ LB bracket_null, 
		    RB bracket_null,
		    LD bracket_null, 
		    RD bracket_null ] ],
	   [ ORTH [ LB bracket_null, RB #rb,
	            LD bracket_null, RD #rd ] ] > ].

basic_quad_phrase :+
  [ ORTH [ LB #lb,
	   RB #rb,
	   LD #ld,
	   RD #rd ],
    ARGS < [ ORTH [ LB #lb, RB bracket_null,
                    LD #ld, RD bracket_null ] ],
	   [ ORTH [ LB bracket_null, 
		    RB bracket_null,
		    LD bracket_null, 
		    RD bracket_null ] ],
	   [ ORTH [ LB bracket_null, 
		    RB bracket_null,
		    LD bracket_null, 
		    RD bracket_null ] ],
	   [ ORTH [ LB bracket_null, RB #rb,
	            LD bracket_null, RD #rd ] ] > ].

;; Special head_final binary phrases: Pull delimiters on dtrs outward to
;; left and right perimeters of mother, by appending values of dtrs.

perimeter_delims_phrase := phrase &
  [ ORTH [ LB [ LIST #lblist, LAST #lblast ],
	   RB [ LIST #rblist, LAST #rblast ],
	   LD [ LIST #ldlist, LAST #ldlast ], 
	   RD [ LIST #rdlist, LAST #rdlast ] ],
    ARGS < [ ORTH [ LB [ LIST #lblist, LAST #lbmid ], 
		    RB [ LIST #rblist, LAST #rbmid ],
		    LD [ LIST #ldlist, LAST #ldmid ],
		    RD [ LIST #rdlist, LAST #rdmid ] ] ], 
	   [ ORTH [ LB [ LIST #lbmid, LAST #lblast ],
		    RB [ LIST #rbmid, LAST #rblast ],
		    LD [ LIST #ldmid, LAST #ldlast ],
		    RD [ LIST #rdmid, LAST #rdlast ] ] ] > ]. 

basic_np_name_cmpnd_phr :+ perimeter_delims_phrase.
basic_n_v-or-adj_cmpnd_phr :+ perimeter_delims_phrase.
binary_measure_np_phrase :+ perimeter_delims_phrase.
num_noun_sequence_phrase :+ perimeter_delims_phrase.


;; Note: Also added constraints in roots.tdl, which cannot be included here.
