;;; Hey, emacs(1), this is -*- Mode: tdl; Coding: utf-8; -*- got it?

;;;
;;; Copyright (c) 2005 -- 2013 Dan Flickinger (danf@stanford.edu);
;;; copyright (c) 2005 -- 2013 Stephan Oepen (oe@ifi.uio.no);
;;; see `LICENSE' for conditions.
;;;

;;;
;;; first shot of minimal type hierarchy for paraphrasing transfer rules.
;;;

;;;
;;; minimal hierarchy of variable types, using the new (R)MRS naming scheme.
;;;

u := *top* & [ SCRATCH scratch ].
i := u.
p := u.
h := p.
e := i.
x := i & p.

;;;
;;; to check for `arity' in MTRs, maybe we need an `anti-'variable type
;;;
a := u.

;;;
;;; the scratch slot in variables: used during transfer to control application
;;; of rules, e.g. the rules that introduce selected preposition EPs in the ERG
;;; accomodation phase which would otherwise be cyclic, i.e. the rule would
;;; fire on its own output (since it does not consume anything).
;;;
scratch := *top*.
test := scratch.
complete := scratch.

flags := *top* &
[ OPTIONAL luk,
  EQUAL *list*,
  SUBSUME *list*,
  TRIGGER string,
  TRIGGER-CONSTRAINT *avm* ].

mrs_transfer_rule := *top* &
[ FILTER mrs,
  CONTEXT mrs,
  INPUT mrs,
  OUTPUT mrs,
  FLAGS flags ].

generator_rule := mrs_transfer_rule &
[ INPUT.RELS <! !> ].

monotonic_mtr := mrs_transfer_rule &
[ CONTEXT.HOOK.LTOP #h,
  INPUT.HOOK.LTOP #h,
  OUTPUT.HOOK.LTOP #h ].
  
monotonic_omtr := monotonic_mtr & optional_mtr.

optional_mtr := mrs_transfer_rule &
[ FLAGS.OPTIONAL + ].


basic_verb_mtr := monotonic_omtr &
[ INPUT.RELS.LIST < [ LBL #h1, 
                      ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5, ARG4 #x6 ], ...>,
  OUTPUT.RELS.LIST 
               < [ LBL #h1, 
                   ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5, ARG4 #x6 ], ... > ].

verb_mtr := basic_verb_mtr &
[ INPUT.RELS <! relation !> ].

verb_prtcl_cp_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG2 #h3 ], [ LBL #h5 ] !>,
	  HCONS <! qeq & [ HARG #h3, LARG #h5 ] !> ],
  OUTPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG1 #h3 ], relation !>,
	  HCONS <! qeq & [ HARG #h3, LARG #h5 ] !> ] ].

verb_np_prtcl_np_mtr := monotonic_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5 ] !>,
  OUTPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x5, ARG3 #x4 ] !> ]. 
                 
verb_prtcl_pp_ger_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ PRED quant_rel, ARG0 #x4 ],
                  [ PRED nom_rel, ARG0 #x4, ARG1 #h9 ],
                  [ LBL #h9, ARG2 #arg2, ARG3 #arg3, ARG4 #arg4 ] !> ],
  OUTPUT.RELS <! [ LBL #h1, ARG0 #e2,
                   ARG1 #x3, ARG2 #arg2, ARG3 #arg3, ARG4 #arg4 ],
                 [ LBL #h1, ARG1 #e2 ] !> ].

detlesspp_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1,
                    ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h7, ARG0 #x4 ],
                  [ PRED idiom_q_i_rel, ARG0 #x4, RSTR #h6 ] !>,
          HCONS <! qeq & [ HARG #h6, LARG #h7 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1,
                       ARG0 #e2, ARG1 #x3 ], ... > ].

detlesspp+adj_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1,
                    ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h7, ARG1 #x4 ],
                  [ LBL #h7, ARG0 #x4 ],
                  [ PRED udef_q_rel, ARG0 #x4, RSTR #h6 ] !>,
          HCONS <! qeq & [ HARG #h6, LARG #h7 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1,
                       ARG0 #e2, ARG1 #x3 ], ... > ].

light_verb_mtr := monotonic_mtr &
[ INPUT [ RELS.LIST < [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h6, ARG0 #x4 ],
                  [ ARG0 #x4, RSTR #h5 ], ... >,
          HCONS <! qeq & [ HARG #h5, LARG #h6 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1, ARG0 #e2, ARG1 #x3 ], ... > ].

np_deletion_omtr := monotonic_omtr &
[ INPUT [ RELS.LIST < [ PRED "~._n_", LBL #h1, ARG0 #x1 ],
		      [ PRED quant_rel, ARG0 #x1, RSTR #h2 ], ... >,
	  HCONS <! qeq & [ HARG #h2, LARG #h1 ] !> ],
  OUTPUT.HCONS <! !> ].

quantifier_substitution_omtr := monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #lbl,
  	       	    ARG0 #x1 & ref-ind ] !>,
  INPUT.RELS <! [ LBL #h2, ARG0 #x1 & [ IND + ], RSTR #h3 & handle,
		  BODY #h4 & handle ] !>,
  OUTPUT.RELS <! [ LBL #h2 & handle, ARG0 #x1, RSTR #h3, BODY #h4 ] !>,
  FLAGS.EQUAL < #lbl, #h2 > ].


;;;
;;; a few `special-purpose' types, transfer operators in a sense
;;;
+upcase+ := string.
+downcase+ := string.

;;;
;;; common types for generator trigger rules
;;;

arg0e_gtr := generator_rule &
[ CONTEXT [ RELS.LIST < [ ARG0 #e & event ], ... > ],
  FLAGS.EQUAL < #e, ... > ].

arg0e+1x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG1 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg >,
	  SUBSUME < #x > ] ].

arg0e+2x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG2 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg >,
	  SUBSUME < #x > ] ].

arg0e+3x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG3 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg >,
	  SUBSUME < #x > ] ].

arg0e+1h_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG1 #h & handle ], ... > ],
  FLAGS.EQUAL < semarg, #h > ].

arg0e+2h_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG2 #h & handle ], ... > ],
  FLAGS.EQUAL < semarg, #h > ].

arg0e+3h_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG3 #h & handle ], ... > ],
  FLAGS.EQUAL < semarg, #h > ].

;; DPF 2013-08-26 - Constrain #x to overt_non_expl-ind
arg0e+x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < relation & [ ARG0.E.TENSE real_tense ],
                        [ LBL #h, ARG0 #x & overt_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg, #h >,
	  SUBSUME < #x > ] ].

arg0e+xh_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < relation & [ ARG0.E.TENSE real_tense,
				     ARG2 handle & #h2 ],
                        [ LBL #h, ARG0 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg, #h, #h2 >,
	  SUBSUME < #x > ] ] .

arg0e+1x_be_gtr := arg0e+1x_gtr &
[ CONTEXT [ RELS <! [ ARG0.E #tam,
		      ARG1 #x ] !> ],
  FLAGS [ TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK [ INDEX.E #tam,
							XARG #x & [ PNG #png ]],
					    AGR.PNG #png ] ] ].

complementizer_gtr := generator_rule &
[ CONTEXT [ RELS <! [ PRED "~_[vnapj]_",
                      ARG0 non_expl ], 
                    [ ARG0 #e & event ] !> ],
  FLAGS.EQUAL < #e, ... > ].

compl_prop_gtr := complementizer_gtr &
[ CONTEXT [ RELS <! relation, [ ARG0 [ E.TENSE real_tense,
                                       SF prop ] ] !> ] ].

compl_prop_gtr1 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_prop_gtr2 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_prop_gtr3 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_prop_gtr4 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG4 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr := complementizer_gtr &
[ CONTEXT [ RELS <! relation, [ ARG0 [ E.TENSE real_tense,
                                       SF ques ] ] !> ] ].

compl_ques_gtr1 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr2 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr3 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr4 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG4 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_notense_gtr := complementizer_gtr &
[ CONTEXT.RELS <! relation, [ ARG0 [ E.TENSE no_tense,
                                     SF prop-or-ques ] ] !> ].

compl_notense_gtr1 := compl_notense_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_notense_gtr2 := compl_notense_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_notense_gtr3 := compl_notense_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_notense_gtr := complementizer_gtr &
[ CONTEXT.RELS <! relation, [ ARG0 [ E.TENSE no_tense,
                                     SF ques ] ] !> ].

compl_ques_notense_gtr1 := compl_ques_notense_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_notense_gtr2 := compl_ques_notense_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_notense_gtr3 := compl_ques_notense_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

#|
compl_like_gtr := complementizer_gtr &
[ CONTEXT.RELS <! relation, [ ARG0 [ E.TENSE real_tense,
                                     SF prop ] ] !> ].

compl_like_gtr1 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_like_gtr2 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_like_gtr3 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_like_gtr4 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG4 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].
|#

;;; Idiom rules

v_nbar_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind & #arg2 ],
                [ LBL handle,
                  ARG0 #arg2 ],
                [ PRED idiom_q_i_rel,
                  ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

v_nbar_plus_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 basic_non_expl-ind,
                    ARG2 ref-ind,
                    ARG3 ref-ind ],
                [ LBL handle,
                  ARG0 #arg2 ],
                [ ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

basic_v_nbar_pp_idiom_mtr := v_nbar_plus_pp_idiom_mtr &
  [ INPUT.RELS <! [ ARG2 ref-ind & #arg ],
		  [ ARG0 #arg ], relation !> ].

; For |take X into account|
v_np_detlesspp_idiom_mtr := v_nbar_plus_pp_idiom_mtr &
  [ INPUT.RELS <! [ ARG3 ref-ind & #arg ],
		  [ ARG0 #arg ], relation !> ].

v_nbar_pp_idiom_mtr := basic_v_nbar_pp_idiom_mtr &
  [ INPUT.RELS <! relation, relation, [ PRED idiom_q_i_rel ] !> ].

v_nbar-pl_pp_idiom_mtr := basic_v_nbar_pp_idiom_mtr &
  [ INPUT.RELS <! relation, relation, [ PRED udef_q_rel ] !> ].

v_np_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind & #arg2 ],
                [ LBL handle,
                  ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !>,
    FLAGS.EQUAL < #arg2 > ].

v_light_adj_idiom_mtr := monotonic_mtr &
  [ INPUT [ RELS <! [ ARG1 ref-ind,
                      ARG2 #arg ],
                    [ LBL #lbl ] !>,
	    HCONS <! qeq & [ HARG #arg, LARG #lbl ] !> ],
    OUTPUT.RELS <! !> ].

basic_v_np_xp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind ],
                  [ LBL handle ] !>,
    OUTPUT.RELS <! !> ].

v_np_xp_idiom_mtr := basic_v_np_xp_idiom_mtr &
  [ INPUT.RELS <! [ ARG2 #arg2, ARG3 ref-ind ],
		  [ ARG0 #arg2 ] !>,
    FLAGS.EQUAL < #arg2 > ].

v_np2_xp_idiom_mtr := basic_v_np_xp_idiom_mtr &
  [ INPUT.RELS <! [ ARG3 #arg3 & ref-ind ],
		  [ ARG0 #arg3 ] !>,
    FLAGS.EQUAL < #arg3 > ].

detless_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG2 ref-ind & #arg2 ],
                  [ LBL handle,
                    ARG0 #arg2 ],
                  [ PRED idiom_q_i_rel, ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

;; |point of view|
noun_detless_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 ref-ind,
                    ARG1 ref-ind & #arg1 ],
                  [ LBL handle,
                    ARG0 #arg1 ],
                  [ PRED idiom_q_i_rel, ARG0 #arg1 ] !>,
    OUTPUT.RELS <! !> ].


; wait one's turn
basic_v_reflnp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS.LIST 
	      < [ LBL handle & #vlbl,
		  ARG0 event,
		  ARG1 ref-ind & #varg1,
		  ARG2 ref-ind & #varg2 ],
		[ LBL handle & #lbl,
		  ARG0 #varg2 ],
		[ LBL #vlbl,
		  PRED id_rel,
		  ARG1 #varg1,
		  ARG2 #parg2 ],
		[ LBL #lbl,
		  PRED poss_rel,
		  ARG1 #varg2,
		  ARG2 #parg2 ], ... >,
    OUTPUT.RELS <! !> ].

v_reflnp_idiom_mtr := basic_v_reflnp_idiom_mtr &
  [ INPUT.RELS <! relation, relation, relation, relation !> ].

v_reflnp-pp_idiom_mtr := monotonic_mtr &
  [ INPUT [ RELS.LIST
	      < [ LBL handle & #vlbl,
		  ARG0 event,
		  ARG1 ref-ind & #varg1,
		  ARG2 ref-ind & #varg2 ],
		[ LBL handle & #lbl,
		  ARG0 #varg2 ],
		relation,
		[ LBL #vlbl,
		  PRED id_rel,
		  ARG1 #varg1,
		  ARG2 #parg2 ],
		[ LBL #lbl,
		  PRED poss_rel,
		  ARG1 #varg2,
		  ARG2 #parg2 ], ... > ],
    OUTPUT.RELS <! !> ].

v_reflnp-pp_seq_idiom_mtr := v_reflnp-pp_idiom_mtr &
 [ INPUT [ RELS <! [ ARG2 #varg2,
		     ARG3 #varg3 ],
		   relation, 
		   [ ARG0 #pparg2 ],
		   relation, 
		   relation, 
		   [ LBL handle & #plbl,
		     ARG1 #varg2,
		     ARG2 #pparg2 ] !>,
	   HCONS <! qeq & [ HARG #varg3,
			    LARG #plbl ] !> ] ].

v_reflnp-pp_seq2_idiom_mtr := v_reflnp-pp_idiom_mtr &
  [ INPUT.RELS <! [ LBL #vlbl,
		    ARG1 #varg1,
		    ARG3 #varg3 ],
		  relation,
		  [ LBL #nlbl,
		    ARG0 #varg3 ],
	          relation,
		  relation,
	          relation,
		[ LBL #vlbl,
		  PRED id_rel,
		  ARG1 #varg1,
		  ARG2 #parg2 ],
		[ LBL #nlbl,
		  PRED poss_rel,
		  ARG1 #varg3,
		  ARG2 #parg2 ] !> ].

;; "a taste of her own medicine"
np_poss_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle & #nlbl,
		    ARG0 ref-ind,
		    ARG1 #parg1 ],
		[ LBL handle & #nlbl2,
		  ARG0 #parg1 ],
		[ LBL #nlbl,
		  PRED id_rel,
		  ARG2 #parg2 ],
		[ LBL #nlbl2,
		  PRED poss_rel,
		  ARG1 #parg1,
		  ARG2 #parg2 ] !>,
    OUTPUT.RELS <! !> ].

classifier_noun_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    PRED quantum_n_of_rel,
                    ARG0 ref-ind,
                    ARG1 ref-ind & #arg1],
                  [ ARG0 #arg1 ] !>,
    OUTPUT.RELS <! !> ].

expletive_it_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ] !> ],
  FLAGS.TRIGGER "it" ].

; Exclude adverbs with same pred as it-adjectives
expletive_it_adj_gtr := expletive_it_gtr &
[ CONTEXT [ RELS <! [ ARG1 handle ] !> ] ].

expletive_is_adj_expl_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE present ] ] !> ],
  FLAGS.TRIGGER "be_c_is" ].

expletive_was_adj_expl_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE past ] ] !> ],
  FLAGS.TRIGGER "be_c_was" ].

expletive_be_adj_expl_gtr1 := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE future ] ] !> ],
  FLAGS.TRIGGER "be_c_be" ].

expletive_be_adj_expl_gtr2 := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE untensed ] ] !> ],
  FLAGS.TRIGGER "be_c_be" ].

expletive_been_adj_expl_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ PERF + ] ] !> ],
  FLAGS.TRIGGER "be_c_been" ].

; Copula trigger rule types
; Five rules for copula plus [ PROGR + ] verbs, with ref-ind in 
; ARG1,2,3, or handle in ARG1,2 (sentential subject of active -- passive
; treated separately).

be_cop_x1_rule := arg0e+1x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
		       ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ],
		       ARG1 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

be_cop_x2_rule := arg0e+2x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
		       ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ],
		       ARG2 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

be_cop_x3_rule := arg0e+3x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
		       ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ],
		       ARG3 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

; Special case for future-modal "going to" as in "He is going to leave."
be_cop_going+to_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED _going+to_v_qmodal_rel ] !> ] ].

; Exclude 'are, 'were' since expletive 'it' and sentential subjects are
; 3sg.
be_cop_h1_rule := arg0e+1h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
		       ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ] ] !> ] ].

be_cop_h2_rule := arg0e+2h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
		       ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ] ] !> ] ].

; Five rules for copula with passives: Either a message's PSV is
; coindexed with (1) a ref-ind (ARG 2,3) or (2) a handle (sentential subject 
; of passive verb, as ARG2) -- where the PSV attribute is unconstrained, allow
; both active and passive; or (3-4) context is a raising verb with a message
; argument (ARG1,2), as in "It was known that Kim won", where the PSV value 
; remains unbound since the syntactic subject is an expletive, invisible in MRS
; This latter case is unfortunate, since it means copulas will be introduced
; unnecessarily for lots of MRSs.
; So for the moment, we'll limit the damage by restricting these expletive
; subject passives to ones where there is no explicit 'by phrase', so we
; won't generate e.g. "It was known by everyone that Kim won".  Maybe no
; great loss for now.

; Here the FILTER rel prevents triggering when the event introducing the
; potentially passived argument is the ARG0 of a message whose PSV does not
; license that argument.  The #u also in FLAGS.EQUAL prevents this filter
; from being invoked if there is no value assigned in PSV, with the effect
; that an underspecified (or absent) PSV value will be compatible with
; this rule, so it will trigger.

be_cop_2x_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ],
                       ARG2 #x & event_or_index ] !> ],
   FLAGS [ EQUAL < semarg >,
           SUBSUME < #x >,
	   TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					     AGR.PNG #png ] ] ].

be_cop_3x_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ],
                       ARG3 #x & event_or_index ] !> ],
   FLAGS [ EQUAL < semarg >,
           SUBSUME < #x >,
	   TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					     AGR.PNG #png ] ] ].

be_cop_2h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative ] ],
                       ARG2 #h & handle ],
		     [ LBL #h,
		       PRED "~_v_",
		       ARG0.E.TENSE real_tense ] !> ],
   FLAGS.EQUAL < event, #h > ].

be_cop_3h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative ] ],
                       ARG3 #h & handle ],
		     [ LBL #h,
		       PRED "~_v_",
		       ARG0.E.TENSE real_tense ] !> ],
   FLAGS.EQUAL < event, #h > ].

#|
be_cop_expl_1h_psv_rule := arg0e+1h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].
|#

be_cop_expl_2h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ],
                       ARG1 #x & ref-ind,
                       ARG2 #h & handle ] !> ],
   FILTER.RELS <! [ ARG0 #x ] !>,
   FLAGS.EQUAL < semarg, #h > ].

be_cop_expl_3h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ],
                       ARG1 #x & ref-ind,
                       ARG3 #h & handle ] !> ],
   FILTER.RELS <! [ ARG0 #x ] !>,
   FLAGS.EQUAL < semarg, #h > ].

; Three rules for copula plus predicative PP or AP, with 3sg ref-ind ARG1,2,3
be_cop_prd_1x_rule := arg0e+1x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ],
		       ARG1 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK [ XARG #x & [ PNG #png ] ],
					   AGR.PNG #png ] ].

be_cop_prd_2x_rule := arg0e+2x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ],
		       ARG2 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

be_cop_prd_3x_rule := arg0e+3x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ],
		       ARG2 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

; Two similar rules for copula plus adjective with message argument as
; syntactic subject (again only ARG1,2 possible, and maybe even only ARG1).
; Again, exclude 'am, are, were'

be_cop_prd_1h_rule := arg0e+1h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

be_cop_prd_2h_rule := arg0e+2h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

; One rule for copula with purposive VP: 'Kim is to stay here.'
be_cop_inf_rule := generator_rule &
 [ CONTEXT.RELS <! [ PRED eventuality_rel ] !> ].

; One rule for tag questions with there-copula in main clause (hack to avoid
; spurious ambiguity).
be_cop_tag_th_expl_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED _be_v_there_rel ] !> ] ].

; One rule for VP ellipsis with there-copula (hack to avoid spurious ambig).
be_cop_ellip_th_expl_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED _be_v_there_rel ],
                     [ PRED ellipsis_expl_rel,
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

be_cop_ellip_rule := arg0e_gtr &
 [ CONTEXT.RELS <! [ PRED ellipsis_ref_rel,
                     ARG0.E.MOOD indicative,
		     ARG1 #x ] !>,
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].


;; Rules for copula 'were' with group nouns which are semantically NUM 3s
;; as in |a number of cats were arising/hired|
be_cop_were_group_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ TENSE past,
				  MOOD indicative ] ] ],
		     [ ARG0 basic_non_expl-ind & #x & [ PNG [ PN 3s ] ],
		       ARG1 basic_non_expl-ind & #arg & 
			    [ PNG [ PN -3s ] ] ] !> ],
   FLAGS [ EQUAL < semarg >,
	   SUBSUME < #x, #arg > ] ].

prep_particle_rule := generator_rule &
 [ CONTEXT [ RELS <! [ ARG2 #x & ref-ind ] !> ],
   FLAGS [ EQUAL < #x > ] ]. 

prep_particle_n_rule := generator_rule &
 [ CONTEXT [ RELS <! [ ARG1 #x & ref-ind ] !> ],
   FLAGS [ EQUAL < #x > ] ]. 

;; For OpenProof-specific entries (see end of `trigger.mtr')

be_cop_promote_ind_gtr := arg0e_gtr &
 [ CONTEXT.RELS <! [ ARG1 handle ] !>,
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL.CONT.HOOK.XARG it-ind ].

;; For educ rules
norm_monotonic_omtr := monotonic_omtr &
 [ INPUT.HOOK.INDEX #ind,
   OUTPUT.HOOK.INDEX #ind ].