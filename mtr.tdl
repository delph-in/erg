;;; Hey, emacs(1), this is -*- Mode: tdl; Coding: utf-8; -*- got it?

;;;
;;; Copyright (c) 2005 -- 2013 Dan Flickinger (danf@stanford.edu);
;;; copyright (c) 2005 -- 2013 Stephan Oepen (oe@ifi.uio.no);
;;; see `LICENSE' for conditions.
;;;

;;;
;;; first shot of minimal type hierarchy for paraphrasing transfer rules.
;;;

;;;
;;; minimal hierarchy of variable types, using the new (R)MRS naming scheme.
;;;

u := *top* & [ SCRATCH scratch ].
i := u.
p := u.
h := p.
e := i.
x := i & p.

;;;
;;; to check for `arity' in MTRs, maybe we need an `anti-'variable type
;;;
a := u.

;;;
;;; the scratch slot in variables: used during transfer to control application
;;; of rules, e.g. the rules that introduce selected preposition EPs in the ERG
;;; accomodation phase which would otherwise be cyclic, i.e. the rule would
;;; fire on its own output (since it does not consume anything).
;;;
scratch := *top*.
test := scratch.
complete := scratch.

flags := *top* &
[ OPTIONAL luk,
  EQUAL *list*,
  SUBSUME *list*,
  TRIGGER string ].

mrs_transfer_rule := *top* &
[ FILTER mrs,
  CONTEXT mrs,
  INPUT mrs,
  OUTPUT mrs,
  FLAGS flags ].

generator_rule := mrs_transfer_rule &
[ INPUT.RELS <! !> ].

monotonic_mtr := mrs_transfer_rule &
[ CONTEXT.HOOK.LTOP #h,
  INPUT.HOOK.LTOP #h,
  OUTPUT.HOOK.LTOP #h ].
  
monotonic_omtr := monotonic_mtr & optional_mtr.

optional_mtr := mrs_transfer_rule &
[ FLAGS.OPTIONAL + ].


basic_verb_mtr := monotonic_mtr &
[ INPUT.RELS.LIST < [ LBL #h1, 
                      ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5, ARG4 #x6 ], ...>,
  OUTPUT.RELS.LIST 
               < [ LBL #h1, 
                   ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5, ARG4 #x6 ], ... > ].

verb_mtr := basic_verb_mtr &
[ INPUT.RELS <! relation !> ].

verb_prtcl_cp_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG2 #h3 ], [ LBL #h5 ] !>,
	  HCONS <! qeq & [ HARG #h3, LARG #h5 ] !> ],
  OUTPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG1 #h3 ], relation !>,
	  HCONS <! qeq & [ HARG #h3, LARG #h5 ] !> ] ].

verb_np_prtcl_np_mtr := monotonic_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5 ] !>,
  OUTPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x5, ARG3 #x4 ] !> ]. 
                 
verb_prtcl_pp_ger_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ PRED quant_rel, ARG0 #x4 ],
                  [ PRED nom_rel, ARG0 #x4, ARG1 #h9 ],
                  [ LBL #h9, ARG2 #arg2, ARG3 #arg3, ARG4 #arg4 ] !> ],
  OUTPUT.RELS <! [ LBL #h1, ARG0 #e2,
                   ARG1 #x3, ARG2 #arg2, ARG3 #arg3, ARG4 #arg4 ],
                 [ LBL #h1, ARG1 #e2 ] !> ].

detlesspp_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1,
                    ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h7, ARG0 #x4 ],
                  [ PRED idiom_q_i_rel, ARG0 #x4, RSTR #h6 ] !>,
          HCONS <! qeq & [ HARG #h6, LARG #h7 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1,
                       ARG0 #e2, ARG1 #x3 ], ... > ].

detlesspp+adj_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1,
                    ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h7, ARG1 #x4 ],
                  [ LBL #h7, ARG0 #x4 ],
                  [ PRED udef_q_rel, ARG0 #x4, RSTR #h6 ] !>,
          HCONS <! qeq & [ HARG #h6, LARG #h7 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1,
                       ARG0 #e2, ARG1 #x3 ], ... > ].

light_verb_mtr := monotonic_mtr &
[ INPUT [ RELS.LIST < [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h6, ARG0 #x4 ],
                  [ ARG0 #x4, RSTR #h5 ], ... >,
          HCONS <! qeq & [ HARG #h5, LARG #h6 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1, ARG0 #e2, ARG1 #x3 ], ... > ].

;;;
;;; a few `special-purpose' types, transfer operators in a sense
;;;
+upcase+ := string.
+downcase+ := string.

;;;
;;; common types for generator trigger rules
;;;

arg0e_gtr := generator_rule &
[ CONTEXT [ RELS.LIST < [ ARG0 #e & event ], ... > ],
  FLAGS.EQUAL < #e, ... > ].

arg0e+1x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG1 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg >,
	  SUBSUME < #x > ] ].

arg0e+2x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG2 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg >,
	  SUBSUME < #x > ] ].

arg0e+3x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG3 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg >,
	  SUBSUME < #x > ] ].

arg0e+1h_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG1 #h & handle ], ... > ],
  FLAGS.EQUAL < semarg, #h > ].

arg0e+2h_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG2 #h & handle ], ... > ],
  FLAGS.EQUAL < semarg, #h > ].

arg0e+3h_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG3 #h & handle ], ... > ],
  FLAGS.EQUAL < semarg, #h > ].

arg0e+x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < relation & [ ARG0.E.TENSE real_tense ],
                        [ LBL #h, ARG0 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg, #h >,
	  SUBSUME < #x > ] ].

arg0e+xh_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < relation & [ ARG0.E.TENSE real_tense,
				     ARG2 handle & #h2 ],
                        [ LBL #h, ARG0 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg, #h, #h2 >,
	  SUBSUME < #x > ] ] .

complementizer_gtr := generator_rule &
[ CONTEXT [ RELS <! [ PRED "~_[vnapj]_",
                      ARG0 non_expl ], 
                    [ ARG0 #e & event ] !> ],
  FLAGS.EQUAL < #e, ... > ].

compl_prop_gtr := complementizer_gtr &
[ CONTEXT [ RELS <! relation, [ ARG0 [ E.TENSE real_tense,
                                       SF prop ] ] !> ] ].

compl_prop_gtr1 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_prop_gtr2 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_prop_gtr3 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_prop_gtr4 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG4 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr := complementizer_gtr &
[ CONTEXT [ RELS <! relation, [ ARG0 [ E.TENSE real_tense,
                                       SF ques ] ] !> ] ].

compl_ques_gtr1 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr2 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr3 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr4 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG4 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_notense_gtr := complementizer_gtr &
[ CONTEXT.RELS <! relation, [ ARG0 [ E.TENSE no_tense,
                                     SF prop-or-ques ] ] !> ].

compl_notense_gtr1 := compl_notense_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_notense_gtr2 := compl_notense_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_notense_gtr3 := compl_notense_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_notense_gtr := complementizer_gtr &
[ CONTEXT.RELS <! relation, [ ARG0 [ E.TENSE no_tense,
                                     SF ques ] ] !> ].

compl_ques_notense_gtr1 := compl_ques_notense_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_notense_gtr2 := compl_ques_notense_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_notense_gtr3 := compl_ques_notense_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

#|
compl_like_gtr := complementizer_gtr &
[ CONTEXT.RELS <! relation, [ ARG0 [ E.TENSE real_tense,
                                     SF prop ] ] !> ].

compl_like_gtr1 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_like_gtr2 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_like_gtr3 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_like_gtr4 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG4 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].
|#

;;; Idiom rules

v_nbar_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind & #arg2 ],
                [ LBL handle,
                  ARG0 #arg2 ],
                [ PRED idiom_q_i_rel,
                  ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

v_nbar_plus_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 basic_non_expl-ind,
                    ARG2 ref-ind,
                    ARG3 ref-ind ],
                [ LBL handle,
                  ARG0 #arg2 ],
                [ ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

basic_v_nbar_pp_idiom_mtr := v_nbar_plus_pp_idiom_mtr &
  [ INPUT.RELS <! [ ARG2 ref-ind & #arg ],
		  [ ARG0 #arg ], relation !> ].

; For |take X into account|
v_np_detlesspp_idiom_mtr := v_nbar_plus_pp_idiom_mtr &
  [ INPUT.RELS <! [ ARG3 ref-ind & #arg ],
		  [ ARG0 #arg ], relation !> ].

v_nbar_pp_idiom_mtr := basic_v_nbar_pp_idiom_mtr &
  [ INPUT.RELS <! relation, relation, [ PRED idiom_q_i_rel ] !> ].

v_nbar-pl_pp_idiom_mtr := basic_v_nbar_pp_idiom_mtr &
  [ INPUT.RELS <! relation, relation, [ PRED udef_q_rel ] !> ].

v_np_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind & #arg2 ],
                [ LBL handle,
                  ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !>,
    FLAGS.EQUAL < #arg2 > ].

v_light_adj_idiom_mtr := monotonic_mtr &
  [ INPUT [ RELS <! [ ARG1 ref-ind,
                      ARG2 handle & #lbl ],
                    [ LBL #albl ] !>,
            HCONS <! qeq & [ HARG #lbl,
                             LARG #albl ] !> ],
    OUTPUT.RELS <! !> ].

basic_v_np_xp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind ],
                  [ LBL handle ] !>,
    OUTPUT.RELS <! !> ].

v_np_xp_idiom_mtr := basic_v_np_xp_idiom_mtr &
  [ INPUT.RELS <! [ ARG2 #arg2, ARG3 ref-ind ],
		  [ ARG0 #arg2 ] !>,
    FLAGS.EQUAL < #arg2 > ].

v_np2_xp_idiom_mtr := basic_v_np_xp_idiom_mtr &
  [ INPUT.RELS <! [ ARG3 #arg3 & ref-ind ],
		  [ ARG0 #arg3 ] !>,
    FLAGS.EQUAL < #arg3 > ].

detless_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG2 ref-ind & #arg2 ],
                  [ LBL handle,
                    ARG0 #arg2 ],
                  [ PRED idiom_q_i_rel, ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

;; |point of view|
noun_detless_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 ref-ind,
                    ARG1 ref-ind & #arg1 ],
                  [ LBL handle,
                    ARG0 #arg1 ],
                  [ PRED idiom_q_i_rel, ARG0 #arg1 ] !>,
    OUTPUT.RELS <! !> ].


; wait one's turn
basic_v_reflnp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS.LIST 
	      < [ LBL handle & #vlbl,
		  ARG0 event,
		  ARG1 ref-ind & #varg1,
		  ARG2 ref-ind & #varg2 ],
		[ LBL handle & #lbl,
		  ARG0 #varg2 ],
		[ LBL #vlbl,
		  PRED id_rel,
		  ARG1 #varg1,
		  ARG2 #parg2 ],
		[ LBL #lbl,
		  PRED poss_rel,
		  ARG1 #varg2,
		  ARG2 #parg2 ], ... >,
    OUTPUT.RELS <! !> ].

v_reflnp_idiom_mtr := basic_v_reflnp_idiom_mtr &
  [ INPUT.RELS <! relation, relation, relation, relation !> ].

classifier_noun_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    PRED quantum_n_of_rel,
                    ARG0 ref-ind,
                    ARG1 ref-ind & #arg1],
                  [ ARG0 #arg1 ] !>,
    OUTPUT.RELS <! !> ].

expletive_it_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ] !> ],
  FLAGS.TRIGGER "it" ].

; Exclude adverbs with same pred as it-adjectives
expletive_it_adj_gtr := expletive_it_gtr &
[ CONTEXT [ RELS <! [ ARG1 handle ] !> ] ].

expletive_is_adj_expl_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE present ] ] !> ],
  FLAGS.TRIGGER "be_c_is" ].

expletive_was_adj_expl_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE past ] ] !> ],
  FLAGS.TRIGGER "be_c_was" ].

expletive_be_adj_expl_gtr1 := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE future ] ] !> ],
  FLAGS.TRIGGER "be_c_be" ].

expletive_be_adj_expl_gtr2 := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE untensed ] ] !> ],
  FLAGS.TRIGGER "be_c_be" ].

expletive_been_adj_expl_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ PERF + ] ] !> ],
  FLAGS.TRIGGER "be_c_been" ].

; Copula trigger rule types
; Five rules for copula plus [ PROGR + ] verbs, with ref-ind in 
; ARG1,2,3, or handle in ARG1,2 (sentential subject of active -- passive
; treated separately).

be_cop_x1_rule := arg0e+1x_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ] ] !> ] ].

be_cop_x2_rule := arg0e+2x_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ] ] !> ] ].

be_cop_x3_rule := arg0e+3x_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ] ] !> ] ].

; Special case for future-modal "going to" as in "He is going to leave."
be_cop_going+to_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED _going+to_v_qmodal_rel ] !> ] ].

; Exclude 'are, 'were' since expletive 'it' and sentential subjects are
; 3sg.
be_cop_h1_rule := arg0e+1h_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ] ] !> ] ].

be_cop_h2_rule := arg0e+2h_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ] ] !> ] ].

; Five rules for copula with passives: Either a message's PSV is
; coindexed with (1) a ref-ind (ARG 2,3) or (2) a handle (sentential subject 
; of passive verb, as ARG2) -- where the PSV attribute is unconstrained, allow
; both active and passive; or (3-4) context is a raising verb with a message
; argument (ARG1,2), as in "It was known that Kim won", where the PSV value 
; remains unbound since the syntactic subject is an expletive, invisible in MRS
; This latter case is unfortunate, since it means copulas will be introduced
; unnecessarily for lots of MRSs.
; So for the moment, we'll limit the damage by restricting these expletive
; subject passives to ones where there is no explicit 'by phrase', so we
; won't generate e.g. "It was known by everyone that Kim won".  Maybe no
; great loss for now.

; Here the FILTER rel prevents triggering when the event introducing the
; potentially passived argument is the ARG0 of a message whose PSV does not
; license that argument.  The #u also in FLAGS.EQUAL prevents this filter
; from being invoked if there is no value assigned in PSV, with the effect
; that an underspecified (or absent) PSV value will be compatible with
; this rule, so it will trigger.

be_cop_2x_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 #e & [ E [ MOOD indicative ] ],
                       ARG2 #x & event_or_index ],
                     [ PRED parg_d_rel,
                       ARG1 #e,
                       ARG2 #x ] !> ],
   FLAGS [ EQUAL < semarg >,
           SUBSUME < #x > ] ].

be_cop_3x_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 #e & [ E [ MOOD indicative ] ],
                       ARG3 #x & event_or_index ],
                     [ PRED parg_d_rel,
                       ARG1 #e,
                       ARG2 #x ] !> ],
   FLAGS [ EQUAL < semarg >,
           SUBSUME < #x > ] ].

be_cop_2h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ ARG0 #e & [ E [ MOOD indicative ] ],
                       ARG2 #h & handle ],
                     [ PRED parg_d_rel,
                       ARG1 #e ] !> ],
   FLAGS.EQUAL < event, #h > ].

be_cop_3h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ ARG0 #e & [ E [ MOOD indicative ] ],
                       ARG3 #h & handle ],
                     [ PRED parg_d_rel,
                       ARG1 #e ] !> ],
   FLAGS.EQUAL < event, #h > ].

#|
be_cop_expl_1h_psv_rule := arg0e+1h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].
|#

be_cop_expl_2h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 #e & [ E [ MOOD indicative ] ],
                       ARG1 #x & ref-ind,
                       ARG2 #h & handle ],
                     [ PRED parg_d_rel,
                       ARG1 #e,
                       ARG2 #h ] !> ],
   FILTER.RELS <! [ ARG0 #x ] !>,
   FLAGS.EQUAL < semarg, #h > ].

; Three rules for copula plus predicative PP or AP, with 3sg ref-ind ARG1,2,3
be_cop_prd_1x_rule := arg0e+1x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

be_cop_prd_2x_rule := arg0e+2x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

be_cop_prd_3x_rule := arg0e+3x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

; Two similar rules for copula plus adjective with message argument as
; syntactic subject (again only ARG1,2 possible, and maybe even only ARG1).
; Again, exclude 'am, are, were'

be_cop_prd_1h_rule := arg0e+1h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

be_cop_prd_2h_rule := arg0e+2h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

; One rule for copula with purposive VP: 'Kim is to stay here.'
be_cop_inf_rule := generator_rule &
 [ CONTEXT.RELS <! [ PRED eventuality_rel ] !> ].

; One rule for tag questions with there-copula in main clause (hack to avoid
; spurious ambiguity).
be_cop_tag_th_expl_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED _be_v_there_rel ] !> ] ].

; One rule for VP ellipsis with there-copula (hack to avoid spurious ambig).
be_cop_ellip_th_expl_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED _be_v_there_rel ],
                     [ PRED ellipsis_expl_rel,
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

be_cop_ellip_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED ellipsis_ref_rel,
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

prep_particle_rule := generator_rule &
 [ CONTEXT [ RELS <! [ ARG2 #x & ref-ind ] !> ],
   FLAGS [ EQUAL < #x > ] ]. 

prep_particle_n_rule := generator_rule &
 [ CONTEXT [ RELS <! [ ARG1 #x & ref-ind ] !> ],
   FLAGS [ EQUAL < #x > ] ]. 


