;;; Hey, emacs(1), this is -*- Mode: TDL; Package: LKB; -*- got it?

;;;
;;; first shot of minimal type hierarchy for paraphrasing transfer rules.
;;;

;;;
;;; minimal hierarchy of variable types, using the new (R)MRS naming scheme.
;;;

u := *top* & [ SCRATCH scratch ].
h := u.
i := u.
e := i.
x := i.

;;;
;;; to check for `arity' in MTRs, maybe we need an `anti-'variable type
;;;
a := u.

;;;
;;; the scratch slot in variables: used during transfer to control application
;;; of rules, e.g. the rules that introduce selected preposition EPs in the ERG
;;; accomodation phase which would otherwise be cyclic, i.e. the rule would
;;; fire on its own output (since it does not consume anything).
;;;
scratch := *top*.
test := scratch.
complete := scratch.

flags := *top* &
[ OPTIONAL luk,
  EQUAL *list*,
  SUBSUME *list*,
  TRIGGER string ].

mrs_transfer_rule := *top* &
[ FILTER mrs,
  CONTEXT mrs,
  INPUT mrs,
  OUTPUT mrs,
  FLAGS flags ].

generator_rule := mrs_transfer_rule &
[ INPUT.RELS <! !> ].

monotonic_mtr := mrs_transfer_rule &
[ CONTEXT.HOOK.LTOP #h,
  INPUT.HOOK.LTOP #h,
  OUTPUT.HOOK.LTOP #h ].
  
monotonic_omtr := monotonic_mtr & optional_mtr.

optional_mtr := mrs_transfer_rule &
[ FLAGS.OPTIONAL + ].


basic_verb_prtcl_mtr := monotonic_mtr &
[ INPUT.RELS.LIST < [ LBL #h1, 
                      ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5, ARG4 #x6 ],
                    [ LBL #h1, ARG1 #e2 ], ... >,
  OUTPUT.RELS.LIST 
               < [ LBL #h1, 
                   ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5, ARG4 #x6 ], ... > ].

verb_prtcl_mtr := basic_verb_prtcl_mtr &
[ INPUT.RELS.LIST < [ ARG2 #x4 ],
                    [ ARG2 #x4 ], ... > ].

verb_prtcl_cp_mtr := basic_verb_prtcl_mtr &
[ INPUT [ RELS <! [ ARG2 #harg ],
                  relation,
                  [ LBL #h2, PRED #pred, ARG1 #arg1, ARG2 #arg2, 
                    ARG3 #arg3, ARG4 #arg4 ] !> ],
  CONTEXT [ RELS <! [ LBL #harg, PRED prpstn_m_rel, MARG #marg ] !>,
            HCONS <! qeq & [ HARG #marg,
                             LARG #h2 ] !> ],
  OUTPUT.RELS <! relation,
                 [ LBL #h2, PRED #pred, ARG0 event & [ E.ASPECT.PROGR -, 
                                                       E.ASPECT.PERF - ],
                   ARG1 #arg1, ARG2 #arg2, ARG3 #arg3, ARG4 #arg4 ] !> ].
                 

;verb_prtcl_pp_mtr := basic_verb_prtcl_mtr &
;[ INPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5 ],
;                [ LBL #h1, ARG1 #e2 ],
;                [ LBL #h1, ARG1 #e2, ARG2 #x5 ] !>,
;  OUTPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5 ] !> ].
                 
verb_prtcl_pp_mtr := basic_verb_prtcl_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG3 #x5 ],
                [ LBL #h1, ARG1 #e2 ],
                [ LBL #h1, ARG1 #e2, ARG2 #x5 ] !> ].
                 
verb_np_prtcl_np_mtr := monotonic_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5 ],
                [ LBL #h1, ARG1 #e2 ] !>,
  OUTPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x5, ARG3 #x4 ],
                 [ LBL #h1, ARG1 #e2, ARG2 #x4 ] !> ]. 
                 
verb_prtcl_pp_ger_mtr := basic_verb_prtcl_mtr &
[ INPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h1, ARG1 #e2 ],
                  [ LBL #h1, ARG1 #e2, ARG2 #x4 ],
                  [ PRED quant_rel, ARG0 #x4 ],
                  [ PRED nom_rel, ARG0 #x4, ARG1 #h7 ],
                  [ LBL #h7, PRED prpstn_m_rel, MARG #h8 ],
                [ LBL #h9, PRED #pred, ARG2 #arg2, ARG3 #arg3, ARG4 #arg4 ] !>,
          HCONS <! qeq & [ HARG #h8,
                           LARG #h9 ] !> ],
  OUTPUT.RELS <! [ LBL #h1, PRED #pred, ARG0 #e2,
                   ARG1 #x3, ARG2 #arg2, ARG3 #arg3, ARG4 #arg4 ],
                 [ LBL #h1, ARG1 #e2 ] !> ].

detlesspp_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1,
                    ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h7, ARG0 #x4 ],
                  [ PRED idiom_q_rel, ARG0 #x4, RSTR #h6 ] !>,
          HCONS <! qeq & [ HARG #h6, LARG #h7 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1,
                       ARG0 #e2, ARG1 #x3 ], ... > ].

detlesspp+adj_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1,
                    ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h7, ARG1 #x4 ],
                  [ LBL #h7, ARG0 #x4 ],
                  [ PRED idiom_q_rel, ARG0 #x4, RSTR #h6 ] !>,
          HCONS <! qeq & [ HARG #h6, LARG #h7 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1,
                       ARG0 #e2, ARG1 #x3 ], ... > ].

light_verb_mtr := monotonic_mtr &
[ INPUT [ RELS.LIST < [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h6, ARG0 #x4, ARG1 #x7 ],
                  [ LBL #h6, ARG2 #x7 ],
                  [ ARG0 #x4, RSTR #h5 ], ... >,
          HCONS <! qeq & [ HARG #h5, LARG #h6 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x7 ], ... > ].

;;;
;;; a few `special-purpose' types, transfer operators in a sense
;;;
+upcase+ := string.
+downcase+ := string.

;;; Idiom rules

v_nbar_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind & #arg2 ],
                [ LBL handle,
                  ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

v_nbar_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind & #arg2,
                    ARG3 ref-ind & #arg3 ],
                [ LBL handle,
                  ARG0 #arg2 ],
                [ LBL handle,
                  ARG0 event,
                  ARG1 individual_min,
                  ARG2 #arg3 ] !>,
    OUTPUT.RELS <! !> ].

v_light_adj_idiom_mtr := monotonic_mtr &
  [ INPUT [ RELS <! [ ARG1 ref-ind,
                      ARG2 handle & #mlbl ],
                    [ LBL #lbl ],
                    [ LBL #mlbl,
                      PRED message_m_rel,
                      MARG #marg ] !>,
            HCONS <! qeq & [ HARG #marg,
                             LARG #lbl ] !> ],
    OUTPUT.RELS <! !> ].

expletive_it_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ] !> ],
  FLAGS.TRIGGER "it" ].

expletive_be_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ] !> ],
  FLAGS.TRIGGER "it" ].

v_arg1_basic_smtr := mrs_transfer_rule &
  [ CONTEXT [ HOOK [ LTOP handle & #vlbl ],
              RELS <! [ LBL handle & #vlbl,
                        ARG0 event & #event &
                            [ E [ TENSE past,
                                  MOOD indicative,
                                  ASPECT [ PERF -,
                                           PROGR - ] ] ],
                        ARG1 ref-ind & #arg1 ] !> ],
    INPUT [ RELS <! !> ],
    OUTPUT [ HOOK [ LTOP handle & #ltop,
                    INDEX event & #event ],
             RELS.LIST < [ PRED prpstn_m_rel,
                           LBL handle & #ltop,
                           MARG handle & #marg ],
                         [ PRED some_q_rel,
                           ARG0 ref-ind & #arg1,
                           RSTR handle & #rstr1 ],
                         [ PRED person_rel,
                           LBL handle & #nlbl1,
                           ARG0 ref-ind & #arg1 ], ... >,
             HCONS.LIST < qeq & [ HARG handle & #marg,
                                  LARG handle & #vlbl ],
                          qeq & [ HARG handle & #rstr1,
                                  LARG handle & #nlbl1 ], ... > ] ].
