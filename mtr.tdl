;;; Hey, emacs(1), this is -*- Mode: tdl; Coding: utf-8; -*- got it?

;;;
;;; Copyright (c) 2005 -- 2013 Dan Flickinger (danf@stanford.edu);
;;; copyright (c) 2005 -- 2013 Stephan Oepen (oe@ifi.uio.no);
;;; see `LICENSE' for conditions.
;;;

;;;
;;; first shot of minimal type hierarchy for paraphrasing transfer rules.
;;;

;;;
;;; minimal hierarchy of variable types, using the new (R)MRS naming scheme.
;;;

u := *top* & [ SCRATCH scratch ].
i := u.
p := u.
h := p.
e := i.
x := i & p.

;;;
;;; to check for `arity' in MTRs, maybe we need an `anti-'variable type
;;;
a := u.

;;;
;;; the scratch slot in variables: used during transfer to control application
;;; of rules, e.g. the rules that introduce selected preposition EPs in the ERG
;;; accomodation phase which would otherwise be cyclic, i.e. the rule would
;;; fire on its own output (since it does not consume anything).
;;;
scratch := *top*.
test := scratch.
complete := scratch.

flags := *top* &
[ OPTIONAL luk,
  EQUAL *list*,
  SUBSUME *list*,
  TRIGGER string,
  TRIGGER-CONSTRAINT *avm* ].

mrs_transfer_rule := *top* &
[ FILTER mrs,
  CONTEXT mrs,
  INPUT mrs,
  OUTPUT mrs,
  FLAGS flags ].

generator_rule := mrs_transfer_rule &
[ INPUT.RELS <! !> ].

monotonic_mtr := mrs_transfer_rule &
[ CONTEXT.HOOK.LTOP #h,
  INPUT.HOOK.LTOP #h,
  OUTPUT.HOOK.LTOP #h ].
  
monotonic_omtr := monotonic_mtr & optional_mtr.

optional_mtr := mrs_transfer_rule &
[ FLAGS.OPTIONAL + ].


basic_verb_mtr := monotonic_omtr &
[ INPUT.RELS.LIST < [ LBL #h1, 
                      ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5, ARG4 #x6 ], ...>,
  OUTPUT.RELS.LIST 
               < [ LBL #h1, 
                   ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5, ARG4 #x6 ], ... > ].

verb_mtr := basic_verb_mtr &
[ INPUT.RELS <! relation !> ].

verb_prtcl_cp_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG2 #h3 ], [ LBL #h5 ] !>,
	  HCONS <! qeq & [ HARG #h3, LARG #h5 ] !> ],
  OUTPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG1 #h3 ], relation !>,
	  HCONS <! qeq & [ HARG #h3, LARG #h5 ] !> ] ].

verb_np_prtcl_np_mtr := monotonic_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4, ARG3 #x5 ] !>,
  OUTPUT.RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x5, ARG3 #x4 ] !> ]. 
                 
verb_prtcl_pp_ger_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ PRED quant_rel, ARG0 #x4 ],
                  [ PRED nom_rel, ARG0 #x4, ARG1 #h9 ],
                  [ LBL #h9, ARG2 #arg2, ARG3 #arg3, ARG4 #arg4 ] !> ],
  OUTPUT.RELS <! [ LBL #h1, ARG0 #e2,
                   ARG1 #x3, ARG2 #arg2, ARG3 #arg3, ARG4 #arg4 ],
                 [ LBL #h1, ARG1 #e2 ] !> ].

detlesspp_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1,
                    ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h7, ARG0 #x4 ],
                  [ PRED idiom_q_i_rel, ARG0 #x4, RSTR #h6 ] !>,
          HCONS <! qeq & [ HARG #h6, LARG #h7 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1,
                       ARG0 #e2, ARG1 #x3 ], ... > ].

detlesspp+adj_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ LBL #h1,
                    ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h7, ARG1 #x4 ],
                  [ LBL #h7, ARG0 #x4 ],
                  [ PRED udef_q_rel, ARG0 #x4, RSTR #h6 ] !>,
          HCONS <! qeq & [ HARG #h6, LARG #h7 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1,
                       ARG0 #e2, ARG1 #x3 ], ... > ].

light_verb_mtr := monotonic_mtr &
[ INPUT [ RELS.LIST < [ LBL #h1, ARG0 #e2, ARG1 #x3, ARG2 #x4 ],
                  [ LBL #h6, ARG0 #x4 ],
                  [ ARG0 #x4, RSTR #h5 ], ... >,
          HCONS <! qeq & [ HARG #h5, LARG #h6 ] !> ],
  OUTPUT.RELS.LIST < [ LBL #h1, ARG0 #e2, ARG1 #x3 ], ... > ].

np_deletion_omtr := monotonic_omtr &
[ INPUT [ RELS.LIST < [ PRED "~._n_", LBL #h1, ARG0 #x1 ],
		      [ PRED quant_rel, ARG0 #x1, RSTR #h2 ], ... >,
	  HCONS <! qeq & [ HARG #h2, LARG #h1 ] !> ],
  OUTPUT.HCONS <! !> ].

quantifier_substitution_omtr := monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #lbl,
  	       	    ARG0 #x1 & ref-ind ] !>,
  INPUT.RELS <! [ LBL #h2, ARG0 #x1 & [ PNG.PN 3p ], RSTR #h3 & handle,
		  BODY #h4 & handle ] !>,
  OUTPUT.RELS <! [ LBL #h2 & handle, ARG0 #x1, RSTR #h3, BODY #h4 ] !>,
  FLAGS.EQUAL < #lbl, #h2 > ].

;;;
;;; a few `special-purpose' types, transfer operators in a sense
;;;
+upcase+ := string.
+downcase+ := string.

;;;
;;; common types for generator trigger rules
;;;

arg0e_gtr := generator_rule &
[ CONTEXT [ RELS.LIST < [ ARG0 #e & event ], ... > ],
  FLAGS.EQUAL < #e, ... > ].

arg0e+1x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG1 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg >,
	  SUBSUME < #x > ] ].

arg0e+2x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG2 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg >,
	  SUBSUME < #x > ] ].

arg0e+3x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG3 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg >,
	  SUBSUME < #x > ] ].

arg0e+1h_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG1 #h & handle ], ... > ],
  FLAGS.EQUAL < semarg, #h > ].

arg0e+2h_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG2 #h & handle ], ... > ],
  FLAGS.EQUAL < semarg, #h > ].

arg0e+3h_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < [ ARG3 #h & handle ], ... > ],
  FLAGS.EQUAL < semarg, #h > ].

;; DPF 2013-08-26 - Constrain #x to overt_non_expl-ind
arg0e+x_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < relation & [ ARG0.E.TENSE real_tense ],
                        [ LBL #h, ARG0 #x & overt_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg, #h >,
	  SUBSUME < #x > ] ].

arg0e+xh_gtr := arg0e_gtr &
[ CONTEXT [ RELS.LIST < relation & [ ARG0.E.TENSE real_tense,
				     ARG2 handle & #h2 ],
                        [ LBL #h, ARG0 #x & basic_non_expl-ind ], ... > ],
  FLAGS [ EQUAL < semarg, #h, #h2 >,
	  SUBSUME < #x > ] ] .

arg0e+1x_be_gtr := arg0e+1x_gtr &
[ CONTEXT [ RELS <! [ ARG0.E #tam,
		      ARG1 #x ] !> ],
  FLAGS [ TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK [ INDEX.E #tam,
							XARG #x & [ PNG #png ]],
					    AGR.PNG #png ] ] ].

complementizer_gtr := generator_rule &
[ CONTEXT [ RELS <! [ PRED "~_[vnapj]_",
                      ARG0 non_expl ], 
                    [ ARG0 #e & event ] !> ],
  FLAGS.EQUAL < #e, ... > ].

compl_prop_gtr := complementizer_gtr &
[ CONTEXT [ RELS <! relation, [ ARG0 [ E.TENSE real_tense,
                                       SF prop ] ] !> ] ].

compl_prop_gtr1 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_prop_gtr2 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_prop_gtr3 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_prop_gtr4 := compl_prop_gtr &
[ CONTEXT.RELS <! [ ARG4 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr := complementizer_gtr &
[ CONTEXT [ RELS <! relation, [ ARG0 [ E.TENSE real_tense,
                                       SF ques ] ] !> ] ].

compl_ques_gtr1 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr2 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr3 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_gtr4 := compl_ques_gtr &
[ CONTEXT.RELS <! [ ARG4 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_notense_gtr := complementizer_gtr &
[ CONTEXT.RELS <! relation, [ ARG0 [ E.TENSE no_tense,
                                     SF prop-or-ques ] ] !> ].

compl_notense_gtr1 := compl_notense_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_notense_gtr2 := compl_notense_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_notense_gtr3 := compl_notense_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_notense_gtr := complementizer_gtr &
[ CONTEXT.RELS <! relation, [ ARG0 [ E.TENSE no_tense,
                                     SF ques ] ] !> ].

compl_ques_notense_gtr1 := compl_ques_notense_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_notense_gtr2 := compl_ques_notense_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_ques_notense_gtr3 := compl_ques_notense_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

#|
compl_like_gtr := complementizer_gtr &
[ CONTEXT.RELS <! relation, [ ARG0 [ E.TENSE real_tense,
                                     SF prop ] ] !> ].

compl_like_gtr1 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG1 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_like_gtr2 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG2 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_like_gtr3 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG3 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].

compl_like_gtr4 := compl_like_gtr &
[ CONTEXT.RELS <! [ ARG4 #h & handle ], relation !>,
  FLAGS.EQUAL < semarg, #h > ].
|#

;;; Idiom rules

v_nbar_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind & #arg2 ],
                [ LBL handle,
                  ARG0 #arg2 ],
                [ PRED idiom_q_i_rel,
                  ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

v_nbar_plus_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 basic_non_expl-ind,
                    ARG2 ref-ind,
                    ARG3 ref-ind ],
                [ LBL handle,
                  ARG0 #arg2 ],
                [ ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

basic_v_nbar_pp_idiom_mtr := v_nbar_plus_pp_idiom_mtr &
  [ INPUT.RELS <! [ ARG2 ref-ind & #arg ],
		  [ ARG0 #arg ], relation !> ].

; For |take X into account|
v_np_detlesspp_idiom_mtr := v_nbar_plus_pp_idiom_mtr &
  [ INPUT.RELS <! [ ARG3 ref-ind & #arg ],
		  [ ARG0 #arg ], relation !> ].

v_nbar_pp_idiom_mtr := basic_v_nbar_pp_idiom_mtr &
  [ INPUT.RELS <! relation, relation, [ PRED idiom_q_i_rel ] !> ].

v_nbar-pl_pp_idiom_mtr := basic_v_nbar_pp_idiom_mtr &
  [ INPUT.RELS <! relation, relation, [ PRED udef_q_rel ] !> ].

v_np_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind & #arg2 ],
                [ LBL handle,
                  ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !>,
    FLAGS.EQUAL < #arg2 > ].

v_light_adj_idiom_mtr := monotonic_mtr &
  [ INPUT [ RELS <! [ ARG1 ref-ind,
                      ARG2 #lbl ],
                    [ LBL #lbl ] !> ],
    OUTPUT.RELS <! !> ].

basic_v_np_xp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG1 ref-ind,
                    ARG2 ref-ind ],
                  [ LBL handle ] !>,
    OUTPUT.RELS <! !> ].

v_np_xp_idiom_mtr := basic_v_np_xp_idiom_mtr &
  [ INPUT.RELS <! [ ARG2 #arg2, ARG3 ref-ind ],
		  [ ARG0 #arg2 ] !>,
    FLAGS.EQUAL < #arg2 > ].

v_np2_xp_idiom_mtr := basic_v_np_xp_idiom_mtr &
  [ INPUT.RELS <! [ ARG3 #arg3 & ref-ind ],
		  [ ARG0 #arg3 ] !>,
    FLAGS.EQUAL < #arg3 > ].

detless_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 event,
                    ARG2 ref-ind & #arg2 ],
                  [ LBL handle,
                    ARG0 #arg2 ],
                  [ PRED idiom_q_i_rel, ARG0 #arg2 ] !>,
    OUTPUT.RELS <! !> ].

;; |point of view|
noun_detless_pp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    ARG0 ref-ind,
                    ARG1 ref-ind & #arg1 ],
                  [ LBL handle,
                    ARG0 #arg1 ],
                  [ PRED idiom_q_i_rel, ARG0 #arg1 ] !>,
    OUTPUT.RELS <! !> ].


; wait one's turn
basic_v_reflnp_idiom_mtr := monotonic_mtr &
  [ INPUT.RELS.LIST 
	      < [ LBL handle & #vlbl,
		  ARG0 event,
		  ARG1 ref-ind & #varg1,
		  ARG2 ref-ind & #varg2 ],
		[ LBL handle & #lbl,
		  ARG0 #varg2 ],
		[ LBL #vlbl,
		  PRED id_rel,
		  ARG1 #varg1,
		  ARG2 #parg2 ],
		[ LBL #lbl,
		  PRED poss_rel,
		  ARG1 #varg2,
		  ARG2 #parg2 ], ... >,
    OUTPUT.RELS <! !> ].

v_reflnp_idiom_mtr := basic_v_reflnp_idiom_mtr &
  [ INPUT.RELS <! relation, relation, relation, relation !> ].

classifier_noun_mtr := monotonic_mtr &
  [ INPUT.RELS <! [ LBL handle,
                    PRED quantum_n_of_rel,
                    ARG0 ref-ind,
                    ARG1 ref-ind & #arg1],
                  [ ARG0 #arg1 ] !>,
    OUTPUT.RELS <! !> ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OpenProof

;;;; MRS `inflation' rules

openproof_mtr := monotonic_mtr &
[ OUTPUT.HOOK.INDEX.E [ TENSE present, ASPECT.PRF - ] ].

openproof_addquant_mtr := monotonic_mtr &
[ OUTPUT [ HOOK.INDEX.E [ TENSE present, ASPECT.PRF - ],
	   RELS.LIST < [ LBL #h1 ], [ RSTR #h2 ], ... >, 
	   HCONS <! qeq & [ HARG #h2, LARG #h1 ] !> ] ].

;; "name"
named_op_mtr := monotonic_mtr &
[ INPUT.RELS <! [ PRED "name", LBL #h1, ARG0 #x2, CARG #carg ] !>,
  OUTPUT.RELS <! [ PRED named_rel, LBL #h1 & handle, ARG0 #x2 & ref-ind, 
		   CARG #carg ] !>,
  FLAGS.EQUAL < #x2 > ].

;; "cube"
;;
pred_noun_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h2, ARG0 #e3, ARG1 ref-ind & #x4 ] !>, 
  OUTPUT [ HOOK.INDEX #e3,
	   RELS <! [ LBL #h2, PRED _be_v_id_rel, ARG0 #e3, ARG1 #x4, ARG2 #x5 ],
		   [ LBL handle, ARG0 ref-ind & #x5 ] !> ] ].

;; "large"
;;
adj_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h2, ARG0 #e3, ARG1 ref-ind & #x4 ] !>, 
  OUTPUT [ HOOK.INDEX #e3,
	   RELS <! [ LBL #h2, ARG0 #e3, ARG1 #x4 ] !> ],
  FLAGS.EQUAL < #x4 > ].

;; "samesize"
;;
same_noun_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5 ] !>, 
  OUTPUT [ HOOK.INDEX #e3,
	   RELS <! [ PRED _be_v_id_rel, LBL #h1, ARG0 #e3 & [ E.ASPECT.PROGR -],
		     ARG1 #x4, ARG2 #x6 ],
		   [ LBL #h2, ARG0 ref-ind & #x6 ],
		   [ PRED "_same_a_as_rel", LBL #h2, 
		     ARG0 event & #e7 & [ E.TENSE untensed ], ARG1 #x6 ],
		   [ PRED comp_equal_rel, LBL #h2, ARG1 #e7, ARG2 #x5 ] !> ] ].

;; "samecol"
;;
same_loc_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5 ] !>, 
  OUTPUT [ HOOK.INDEX #e3,
	   RELS <! [ PRED _in_p_rel, LBL #h1, ARG0 #e3, ARG1 #x4, ARG2 #x6 ],
		   [ LBL #h2, ARG0 ref-ind & #x6 & [ PNG.PN 3s ] ],
	           [ PRED "_same_a_as_rel", LBL #h2, ARG0 event & #e7, 
		     ARG1 #x6 ],
	           [ PRED comp_equal_rel, LBL #h2, ARG1 #e7, ARG2 #x5 ] !> ] ].

;; "rightof"
;;
loc_of_op_gpr := openproof_addquant_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5 ] !>, 
  OUTPUT [ HOOK.INDEX #e3,
	   RELS <! [ LBL #h2 & handle, ARG0 #x6 ],
		   [ PRED _the_q_rel, LBL handle, ARG0 #x6 & ref-ind ],
		   [ PRED _to_p_rel, LBL #h1, ARG0 #e3, ARG1 #x4, ARG2 #x6 ],
		   [ PRED _of_p_rel, LBL #h2, ARG0 event, 
		     ARG1 #x6, ARG2 ref-ind & #x5 ] !> ],
  FLAGS.EQUAL < #x4, #x5 > ].

;; "backof"
;;
prep_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, ARG2 ref-ind & #x5] !>,
  OUTPUT [ HOOK.INDEX #e3,
	   RELS <! [ LBL #h1, ARG0 #e3, ARG1 #x4, ARG2 #x5 ] !> ],
  FLAGS.EQUAL < #x4, #x5 > ].

;; "between"
;;
prep_threearg_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5, ARG3 ref-ind & #x6  ] !>, 
  OUTPUT [ HOOK.INDEX #e3,
	   RELS <! [ PRED _and_c_rel, LBL handle, ARG0 ref-ind & #x7, 
		     L-INDEX #x5, R-INDEX #x6 ],
		   [ LBL #h1, ARG0 #e3, ARG1 #x4, ARG2 #x7 ] !> ] ].


;; "larger"
;;
compar_adj_op_gpr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1, ARG0 #e3, ARG1 ref-ind & #x4, 
		  ARG2 ref-ind & #x5 ] !>, 
  OUTPUT [ HOOK.INDEX #e3,
	   RELS <! [ LBL #h1, ARG0 #e3, ARG1 #x4 ],
		   [ PRED comp_rel, LBL #h1, 
		     ARG0 event & [ E [ TENSE untensed, ASPECT no_aspect ] ],
		     ARG1 #e3, ARG2 #x5 ] !> ],
  FLAGS.EQUAL < #h1 > ].

;; Add quantifiers
;;
add_quant_mtr := openproof_mtr &
[ CONTEXT.RELS <! [ LBL handle & #h1, ARG0 #x2 & ref-ind ] !>,
  FILTER.RELS <! [ PRED quant_rel, ARG0 #x2 ] !>,
  OUTPUT [ RELS <! [ LBL handle, ARG0 #x2, RSTR handle & #h5, BODY handle ] !>,
	   HCONS <! qeq & [ HARG handle & #h5, LARG #h1 ] !> ],
  FLAGS.EQUAL < #x2, #h1 > ].

;; Conjunctions
;;
conj_op_mtr := openproof_mtr &
[ INPUT.RELS <! [ LBL #h1 & handle, ARG0 #i2 & individual, 
		  L-INDEX #i3 & individual, R-INDEX #i4 & individual ] !>,
  OUTPUT.RELS <! [ LBL #h1 & handle, ARG0 #i2, L-INDEX #i3, R-INDEX #i4 ] !> ].

;; Add left and right handles for conj-rels with event arguments
;;
add_conjunction_handles_mtr := monotonic_mtr &
[ CONTEXT.RELS <! [ LBL #h1 & handle, ARG0 event & #e2 ],
		  [ LBL #h3 & handle, ARG0 event & #e4 ] !>,
  INPUT.RELS <! [ PRED conj_rel & #pred, LBL #h5, ARG0 #e6, 
		  L-INDEX #e2, R-INDEX #e4, L-HNDL individual, 
		  R-HNDL individual ] !>,
  OUTPUT [ RELS <! [ PRED #pred, LBL #h5, ARG0 #e6, L-INDEX #e2, R-INDEX #e4,
	  	     L-HNDL #h10 & handle, R-HNDL #h11 & handle ] !>,
	   HCONS <! qeq & [ HARG #h10, LARG #h1 ], 
		    qeq & [ HARG #h11, LARG #h3 ] !> ] ].

adjust_neg_conj_index_mtr := monotonic_mtr &
[ CONTEXT [ RELS <! [ PRED neg_rel, LBL handle, ARG0 event, 
		      ARG1 #h10 & handle ],
		    [ LBL #h11 & handle, ARG0 event ] !>,
	    HCONS <! qeq & [ HARG #h10, LARG #h11 ] !> ],
  INPUT.RELS <! [ PRED conj_rel & #pred, LBL #h5, ARG0 #e6,
		  L-HNDL #h7, R-HNDL #h8 ] !>,
  OUTPUT.RELS <! [ PRED #pred, LBL #h5 & handle, ARG0 #e6,
		   L-HNDL #h7 & handle, R-HNDL #h8 & handle ] !> ].

adjust_neg_conj_index_left_mtr := adjust_neg_conj_index_mtr &
[ CONTEXT.RELS <! [ ARG0 #e1 & event ], [ ARG0 #e2 & event ] !>,
  INPUT.RELS <! [ L-INDEX #e1, R-INDEX #e3 & event ] !>,
  OUTPUT.RELS <! [ L-INDEX #e2, R-INDEX #e3 ] !> ].

adjust_neg_conj_index_right_mtr := adjust_neg_conj_index_mtr &
[ CONTEXT.RELS <! [ ARG0 #e1 & event ], [ ARG0 #e2 & event ] !>,
  INPUT.RELS <! [ LBL #h1, L-INDEX #e3 & event, R-INDEX #e1 ] !>,
  OUTPUT.RELS <! [ LBL #h1, L-INDEX #e3, R-INDEX #e2 ] !> ].

negation_op_mtr := monotonic_mtr &
[ CONTEXT.RELS <! [ LBL handle & #h1, ARG0 event & #e2 ] !>,
  INPUT.RELS <! [ PRED "not", LBL #h3, ARG0 #e1, ARG1 #e2 ] !>,
  OUTPUT [ RELS <! [ PRED neg_rel, LBL #h3 & handle, 
		     ARG0 #e1 & event & [ E.TENSE untensed ],
		     ARG1 #h4 & handle ] !>,
 	   HCONS <! qeq & [ HARG #h4, LARG #h1 ] !> ],
  FLAGS.EQUAL < #e1, #e2 > ].


;; if-then
;;
if_then_cond_mtr := openproof_mtr &
[ CONTEXT.RELS <! [ LBL #h5, ARG0 #e3 ],
		  [ LBL #h6, ARG0 #e4 ] !>,
  INPUT.RELS <! [ PRED "if", LBL #h1, ARG0 #e2, L-INDEX #e3, 
		  R-INDEX #e4 ] !>,
  OUTPUT [ RELS <! [ PRED "_if_x_then_rel", LBL #h1, 
		     ARG0 #e2 & event & [ E.TENSE untensed ], 
		     ARG1 #h7, ARG2 #h8 ],
		   [ PRED "_then_a_1_rel", LBL #h10, 
		     ARG0 event & [ E.TENSE untensed ], ARG1 #h11 ] !>,
	   HCONS <! qeq & [ HARG #h7, LARG #h10 ],
		    qeq & [ HARG #h11, LARG #h6 ],
		    qeq & [ HARG #h8, LARG #h5 ] !> ],
  FLAGS.EQUAL < > ].

;; Accommodate variant input with L-INDEX, R-INDEX
if_and_only_if_mtr := openproof_mtr &
[ CONTEXT.RELS <! [ LBL #h5, ARG0 #e3 ],
		  [ LBL #h6, ARG0 #e4 ] !>,
  INPUT.RELS <! [ PRED "iff", LBL #h1, ARG0 #e2, L-INDEX #e3, 
		  R-INDEX #e4 ] !>,
  OUTPUT [ RELS <! [ PRED "_if+and+only+if_x_1_rel", LBL #h1, 
		     ARG0 #e2 & event & [ E.TENSE untensed ], 
		     ARG1 #h7, ARG2 #h8 ] !>,
	   HCONS <! qeq & [ HARG #h7, LARG #h5 ],
		    qeq & [ HARG #h8, LARG #h6 ] !> ],
  FLAGS.EQUAL < > ].

;;;; OpenProof paraphrase rule types

;; Coord subj: When given two clauses where the subjects differ but the
;; VPs are identical, discard the second identical verbal conjunct and create a 
;; conjoined subject NP whose conj's PRED is the same as the sentence conj PRED.
;;
;; A and B are large
;;
basic_coord_subj_onearg_op_gpr := monotonic_omtr &
[ CONTEXT.RELS.LIST < [ PRED named_rel, ARG0 ref-ind & #x3 ],
		      [ PRED named_rel, ARG0 ref-ind & #x6 ], ... >,
  INPUT [ RELS.LIST <
		  [ LBL handle, ARG0 #e2 & event, ARG1 #x3 & ref-ind,
		    PRED #pred ],
                  [ LBL handle, ARG0 #e5 & event, ARG1 #x6 & ref-ind,
		    PRED #pred ],
	   	  [ PRED conj_rel & #cpred, LBL handle, ARG0 #e10, 
		    L-INDEX #e2, R-INDEX #e5, L-HNDL #h21, R-HNDL #h22 ], ... >,
	  HCONS.LIST < qeq & [ HARG #h21 ], qeq & [ HARG #h22 ], ... > ],
  OUTPUT [ RELS.LIST <
		   [ ARG0 #e10 & event &
                     [ E [ ASPECT [ PRF - ], TENSE present ], SF prop ],
		     ARG1 #x10, PRED #pred ],
		   [ PRED udef_q_rel, LBL handle, ARG0 #x10 & ref-ind,
		     RSTR handle & #h11, BODY handle ],
                   [ PRED #cpred, LBL handle & #h12, ARG0 #x10 & [ PNG.PN 3 ],
                     L-INDEX #x3 & ref-ind & [ PNG [ PN 3s ] ],
		     R-INDEX #x6 & ref-ind & [ PNG [ PN 3s ] ] ], ... >,
	   HCONS <! qeq & [ HARG #h11, LARG #h12 ] !> ],
  FLAGS.EQUAL < #e2, #x3, #x6, #e5, #e10, ... > ].

;; The INPUT..[ARG2 handle] is a hack to prevent this rule from applying to 
;; two-arg predications.
;;
coord_subj_onearg_pos_op_gpr := basic_coord_subj_onearg_op_gpr &
[ CONTEXT.RELS <! [ ], [ ] !>,
  FILTER.RELS <! [ PRED comp_rel, LBL #h1 ] !>,
  INPUT [ RELS <! [ LBL #h1, ARG2 handle ], [ ], [ LBL #h3 ] !>,
	  HCONS <! qeq !> ],
  OUTPUT.RELS <! [ LBL #h3 ], [ ], [ ] !>,
  FLAGS.EQUAL < semarg, semarg, semarg, semarg, semarg > ].

;; "A and B are not large"
;;
coord_subj_onearg_neg_op_gpr := basic_coord_subj_onearg_op_gpr &
[ CONTEXT [ RELS <! [ ], [ ] !>,
	    HCONS <! qeq & [ HARG #h3, LARG #h1 ] !> ],
  FILTER.RELS <! [ PRED comp_rel, LBL #h1 ] !>,
  INPUT [ RELS <! [ LBL #h1, ARG2 handle ], [ LBL #h2 ], [ LBL #h10 ], 
		  [ PRED neg_rel, ARG0 #e1, ARG1 #h3 ],
		  [ PRED neg_rel, ARG1 #h4 ] !>,
	  HCONS <! qeq, qeq, qeq & [ HARG #h4, LARG #h2 ] !> ],
  OUTPUT.RELS <! [ LBL #h1 ], [ ], [ ],
	         [ PRED neg_rel, LBL #h10, ARG0 #e1, ARG1 #h3 ] !>,
  FLAGS.EQUAL < semarg, semarg, semarg, semarg, semarg > ].

;; Two-argument common predicates with coord subj
;;   B and D are smaller than C.
;;   B and D are cubes
;;
basic_coord_subj_twoarg_op_gpr := basic_coord_subj_onearg_op_gpr &
[ CONTEXT.RELS.LIST < [ ], [ ],
		      [ PRED named_rel, ARG0 ref-ind & #x7, CARG #carg ], ... >,
  INPUT [ RELS.LIST < [ ], [ ], [ ],
		      [ PRED named_rel, ARG0 ref-ind & #x8, CARG #carg ],
		      [ PRED proper_q_rel, LBL handle, ARG0 #x8, 
			RSTR handle & #h20, BODY handle ], ... >,
	  HCONS.LIST < qeq, qeq, qeq & [ HARG #h20 ], ... > ],
  FLAGS.EQUAL < semarg, semarg, semarg, semarg, semarg, #x7, #x8 > ].

;; B and D are in back of C.
coord_subj_twoarg_op_gpr := basic_coord_subj_twoarg_op_gpr &
[ INPUT.HCONS <! qeq, qeq, qeq !> ].

coord_subj_twoarg_neg_op_gpr := basic_coord_subj_twoarg_op_gpr &
[ CONTEXT [ RELS <! [ ], [ ], [ ARG0 #x1 ] !>,
	    HCONS <! qeq & [ HARG #h3, LARG #h1 ] !> ],
  INPUT [ RELS <! [ LBL #h1 ], [ LBL #h2 ], [ LBL #h10 ], 
		  [ ], [ ],
		  [ PRED neg_rel, ARG0 #e1, ARG1 #h3 ],
		  [ PRED neg_rel, ARG1 #h4 ] !>,
	  HCONS <! qeq, qeq, qeq, qeq & [ HARG #h4, LARG #h2 ] !> ],
  OUTPUT.RELS <! [ LBL #h1, ARG2 #x1 ], [ ], [ ],
	         [ PRED neg_rel, LBL #h10, ARG0 #e1, ARG1 #h3 ] !> ].

;; B and D are cubes
;; B and D are not cubes
;;
coord_subj_twoarg_noprop_op_gpr := basic_coord_subj_onearg_op_gpr &
[ CONTEXT.RELS <! [ ], [ ] !>,
  INPUT [ RELS.LIST < [ ARG2 #x7 ], [ ARG2 #x8 ], [ ],
		  [ PRED #pred, ARG0 ref-ind & #x8 ],
		  [ PRED _a_q_rel, LBL handle, ARG0 #x8, 
		    RSTR handle & #h20, BODY handle ],
		  [ PRED "~._n_" & #pred, LBL handle & #h4, ARG0 ref-ind & #x7],
		  [ PRED _a_q_rel, LBL #h2, ARG0 #x7, RSTR #h21, 
		    BODY #h22 ], ... >,
	  HCONS.LIST < qeq, qeq, qeq & [ HARG #h20 ], ... > ],
  OUTPUT.RELS.LIST < [ ARG2 #x7 ], [ ], [ ],
	         [ PRED #pred, LBL #h4, ARG0 #x7 & [ PNG.PN 3p ] ],
	         [ PRED udef_q_rel, LBL #h2, ARG0 #x7, 
		   RSTR #h21, BODY #h22 ], ... >,
  FLAGS.EQUAL < semarg, semarg, semarg, semarg, semarg, #x7, #x8 > ].

;; B and D are cubes
;;
coord_subj_twoarg_noprop_pos_op_gpr := coord_subj_twoarg_noprop_op_gpr &
[ FILTER [ RELS <! [ PRED neg_rel, ARG1 #h1 ] !>,
	   HCONS <! qeq & [ HARG #h1, LARG #h3 ] !> ],
  INPUT [ RELS <! [ ], [ LBL #h3 ], [ LBL #h2 ], [ ], [ ], [ ], [ ] !>,
	  HCONS <! qeq, qeq, qeq !> ],
  OUTPUT.RELS <! [ LBL #h2 ], [ ], [ ], [ ], [ ] !> ].

coord_subj_twoarg_noprop_neg_op_gpr := coord_subj_twoarg_noprop_op_gpr &
[ CONTEXT.HCONS <! qeq & [ HARG #h3, LARG #h1 ] !>,
  INPUT [ RELS <! [ LBL #h1 ], [ LBL #h2 ], [ LBL #h10 ], [ ], [ ], [ ], [ ],
		  [ PRED neg_rel, ARG0 #e1, ARG1 #h3 ],
		  [ PRED neg_rel, ARG1 #h4 ] !>,
	  HCONS <! qeq, qeq, qeq, qeq & [ HARG #h4, LARG #h2 ] !> ],
  OUTPUT.RELS <! [ LBL #h1 ], [ ], [ ], [ ], [ ],
	         [ PRED neg_rel, LBL #h10, ARG0 #e1, ARG1 #h3 ] !> ].

;; B and D are not cubes

;; A and B are between C and D
;;
coord_subj_threearg_op_gpr := basic_coord_subj_twoarg_op_gpr &
[ CONTEXT.RELS <! [], [], [ ARG0 #x1 ],
		  [ PRED conj_rel & #cpred, ARG0 #x8, L-INDEX #x1 & ref-ind, 
		    R-INDEX #x9 & ref-ind ],
		  [ ARG0 #x9, CARG #carg ] !>,
  INPUT [ RELS <! [ PRED _between_p_rel, ARG2 #x8 ], 
		  [ ARG2 #x13 ], [], [], [ ARG0 #x11 ],
	   	  [ PRED conj_rel & #cpred, ARG0 #x13, 
		    L-INDEX #x11, R-INDEX #x12 ],
		  [ PRED quant_rel, ARG0 #x13, RSTR handle & #h21 ],
		  [ PRED named_rel, ARG0 ref-ind & #x12, CARG #carg ],
		  [ PRED proper_q_rel, ARG0 #x12, RSTR handle & #h20 ] !>,
	  HCONS <! qeq, qeq, qeq, qeq & [ HARG #h20 ], qeq & [ HARG #h21 ] !>]].

;; Common subj in coord Ss: note that need to drop the qeqs for L-HNDL, R-HNDL
;; when doing VP coord.  REVIEW.
;; B is smaller than C and (is) larger than D.
;;
basic_coord_vp_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ ARG0 event & #e1 & [ E.TENSE present ], ARG1 #x1 ],
		  [ ARG0 #x1 & ref-ind, CARG #carg ] !>,
  INPUT [ RELS <! [ PRED conj_rel & #pred1, LBL #h14, ARG0 #e7, L-INDEX #e1, 
		    R-INDEX #e2, L-HNDL #h10 & handle, R-HNDL #h11 & handle ],
		  [ ARG0 #x2 & ref-ind, CARG #carg ],
		  [ PRED proper_q_rel, ARG0 #x2, RSTR #h20 ],
		  [ PRED #pred2, LBL #h4, ARG0 event & #e2, ARG1 #x2 ] !>,
	  HCONS <! qeq & [ HARG #h20 ], 
		   qeq & [ HARG #h10, LARG #h12 ],
		   qeq & [ HARG #h11, LARG #h13 ] !> ],
  OUTPUT [ RELS <! [ PRED #pred1, LBL #h14, ARG0 #e7, L-INDEX #e1, R-INDEX #e2, 
		    L-HNDL #h12, R-HNDL #h13 ],
		   [ PRED #pred2, LBL #h4, ARG0 #e2, ARG1 #x1 ] !>,
	   HCONS <! !> ],
  FLAGS.EQUAL < #e2, #x1, #x2, ... > ].

coord_vp_onearg_op_gpr := basic_coord_vp_op_gpr &
[ INPUT.RELS <! [], [], [], [ ARG2 handle ] !>,
  FLAGS.EQUAL < semarg, semarg, semarg > ].

coord_vp_twoarg_op_gpr := basic_coord_vp_op_gpr &
[ INPUT.RELS <! [], [], [], [ ARG2 #x3 & ref-ind ] !>,
  OUTPUT.RELS <! [], [ ARG2 #x3 ] !>,
  FLAGS.EQUAL < semarg, semarg, semarg, #x3 > ].

pro_subj_gpr := monotonic_omtr &
[ CONTEXT.RELS.LIST < [ ARG0 event & [ E.TENSE present ], ARG1 #x1 ],
		      [ ARG0 event, ARG1 #x2 ],
		      [ ARG0 #x1 & ref-ind, CARG #carg ],
		      [ ], ... >,
  INPUT.RELS <! [ LBL #h10, ARG0 #x2 & ref-ind & [ PNG.GEN neut ], CARG #carg ],
		  [ PRED proper_q_rel, ARG0 #x2, RSTR #h20 ] !>,
  OUTPUT [ RELS <! [ PRED pron_rel, LBL #h10, ARG0 #x2 ],
		  [ PRED pronoun_q_rel, LBL handle, ARG0 #x2, RSTR #h20 ] !>,
	   HCONS <! !> ],
  FLAGS.EQUAL < #x2 > ].

subord_s_pro_subj_gpr := pro_subj_gpr &
[ CONTEXT [ RELS.LIST < [  ], [  ], [ ], [ ARG2 #h3 ], ... >,
	    HCONS.LIST < qeq & [ ],
		         qeq & [ HARG #h3 ], ... > ] ].

cond_s_pro_subj_gpr := subord_s_pro_subj_gpr &
[ CONTEXT [ RELS <! [ LBL #h4 ], [ LBL #h2 ], [ ], 
		    [ PRED "_if_x_then_rel", ARG1 #h3 ],
		    [ PRED "_then_a_1_rel", LBL #h1, ARG1 #h5 ] !>,
	    HCONS <! qeq & [ HARG #h5, LARG #h2 ], [ LARG #h4 ],
		     qeq & [ HARG #h3, LARG #h1 ] !> ] ].

bicond_s_pro_subj_gpr := subord_s_pro_subj_gpr &
[ CONTEXT [ RELS <! [ LBL #h2 ], [ LBL #h4 ], [ ],
		  [ PRED "_if+and+only+if_x_1_rel" ] !>,
	    HCONS <! [ LARG #h2 ], [ LARG #h4 ] !> ] ].

shared_dobj_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ LBL #h1, ARG0 event, ARG2 #x1 ],
		  [ ARG0 #x1 & ref-ind, CARG #carg ],
	   	  [ PRED conj_rel, L-HNDL #h1, R-HNDL #h2 ] !>,
  INPUT [ RELS <! [ ARG0 #x2 & ref-ind, CARG #carg ],
		  [ PRED proper_q_rel, ARG0 #x2, RSTR #h20 ],
		  [ PRED #pred, LBL #h2, ARG0 event & #e2, ARG1 #i3,
		    ARG2 #x2 ] !>,
	  HCONS <! qeq & [ HARG #h20 ] !> ],
  OUTPUT [ RELS <! [ PRED #pred, LBL #h2, ARG0 #e2, ARG1 #i3, ARG2 #x1 ] !>,
	   HCONS <! !> ],
  FLAGS.EQUAL < #e2, #x1, #x2 > ].

and_neg_to_but_op_mtr := monotonic_mtr &
[ CONTEXT [ RELS <! [ PRED neg_rel, LBL handle, ARG1 #h2 ],
		    [ LBL #h3, ARG0 #e4 & event ] !>,
  	    HCONS <! qeq & [ HARG #h2, LARG #h3 ] !> ],
  FILTER [ RELS <! [ PRED neg_rel, ARG1 #h20 ],
		   [ LBL #h21, ARG0 #e6 ] !>,
	   HCONS <! qeq & [ HARG #h20, LARG #h21 ] !> ],
  INPUT.RELS <! [ PRED _and_c_rel, LBL #h7, ARG0 #e8, L-INDEX #e6, 
		  R-INDEX #e4, L-HNDL handle & #h15, R-HNDL handle & #h11 ] !>, 
  OUTPUT.RELS <! [ PRED _but_c_rel, LBL #h7, ARG0 #e8, L-INDEX #e6, 
	           R-INDEX #e4, L-HNDL #h15, R-HNDL #h11  ] !>,
  FLAGS.EQUAL < #e4 > ].

neg_or_to_nor_op_mtr := monotonic_mtr &
[ INPUT [ RELS <! [ PRED neg_rel, LBL #h1, ARG1 #h2 ],
		  [ PRED _or_c_rel, LBL #h7, ARG0 #e8, L-INDEX #e6, 
		    R-INDEX #e4, L-HNDL #h3, R-HNDL #h4 ] !>,
  	    HCONS <! qeq & [ HARG #h2, LARG #h7 ] !> ],
  OUTPUT [ RELS <! [ PRED _nor_c_rel, LBL #h1, ARG0 #e8, L-INDEX #e6, 
		     R-INDEX #e4, L-HNDL #h3, R-HNDL #h4 ]!>,
	   HCONS <! !> ] ].

;; "to the right or to the left of"
shared_ppof_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED _to_p_rel, ARG1 #x1, ARG2 #x2 ],
		  [ LBL #h1, ARG0 #x2 ],
		  [ LBL #h1, PRED _of_p_rel, ARG1 #x2, ARG2 #x3 ],
		  [ ARG0 #x3, CARG #carg ],
		  [ PRED _to_p_rel, ARG1 #x1, ARG2 #x5 ],
		  [ PRED "~._n_", LBL #h6, ARG0 #x5 ] !>,
  INPUT [ RELS <! [ LBL #h6, PRED _of_p_rel, ARG1 #x5, ARG2 #x7 ],
		  [ ARG0 #x7, CARG #carg ],
	          [ PRED quant_rel, ARG0 #x7, RSTR #h8 ] !>,
	  HCONS <! qeq & [ HARG #h8 ] !> ],
  OUTPUT [ RELS <! !>,
	   HCONS <! !> ] ].

;; "to the right or left of"
shared_to_the_op_gpr := monotonic_omtr &
[ CONTEXT.RELS <! [ PRED "~._n_", LBL handle, ARG0 #x2 ],
		  [ PRED "~._n_", LBL #h6, ARG0 #x5 ] !>,
  INPUT [ RELS <! [ PRED conj_rel & #cpred2, LBL #h10, ARG0 #e11, 
		    L-INDEX #e12, R-INDEX #e13 ],
		  [ PRED _to_p_rel, ARG0 #e12, ARG1 #x1, ARG2 #x2 ],
		  [ PRED _to_p_rel, ARG0 #e13, ARG1 #x1, ARG2 #x5 ],
		  [ PRED _the_q_rel, LBL #h7, ARG0 #x2, RSTR #h8, BODY #h9 ],
		  [ PRED _of_p_rel, LBL #h6, ARG0 #e8, ARG1 #x5, ARG2 #x3 ],
		  [ PRED quant_rel, LBL #h17, ARG0 #x5, RSTR #h18, BODY #h19]!>,
	  HCONS <! !> ],
  OUTPUT [ RELS <! [ PRED conj_rel & #cpred2, LBL #h14, ARG0 #x15 & ref-ind, 
		    L-INDEX #x2, R-INDEX #x5 ],
		   [ PRED _to_p_rel, LBL #h10, ARG1 #x1, ARG2 #x15, ARG0 #e11 & 
		     [ E [ ASPECT [ PRF - ], TENSE present ], SF prop ] ],
		   [ PRED _of_p_rel, LBL #h14, ARG0 #e8, ARG1 #x15, ARG2 #x3 ],
		   [ PRED _the_q_rel, LBL #h7, ARG0 #x15, RSTR #h16, BODY #h9],
		   [ PRED udef_q_rel, LBL #h17, ARG0 #x5, RSTR #h18, BODY #h19],
		   [ PRED udef_q_rel, LBL handle, ARG0 #x2, RSTR #h8, 
		     BODY handle ] !>,
	   HCONS <! qeq & [ HARG #h16, LARG #h14 ] !> ] ].

;; Coord and-S with semicolon + moreover
coord_sent_semi_op_gpr := monotonic_omtr &
[ CONTEXT [ RELS <! [ LBL #h10, ARG0 event ] !>,
	    HCONS <! qeq & [ HARG #h22, LARG #h10 ] !> ],
  INPUT.RELS <! [ LBL handle & #h14, ARG0 #e10, L-INDEX #e2 & event, 
    	        R-INDEX #e5, L-HNDL #h21 & handle, R-HNDL #h22 & handle ] !>,
  OUTPUT [ RELS <! [ PRED implicit_conj_rel, LBL handle & #h14, ARG0 #e10, 
		     L-INDEX #e2, R-INDEX #e5, L-HNDL #h21, R-HNDL #h4 & handle ],
	           [ LBL #h5, ARG0 event & [ E.TENSE untensed ], ARG1 #h22 ] !>,
	   HCONS <! qeq & [ HARG #h4, LARG #h5 ] !> ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

expletive_it_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ] !> ],
  FLAGS.TRIGGER "it" ].

; Exclude adverbs with same pred as it-adjectives
expletive_it_adj_gtr := expletive_it_gtr &
[ CONTEXT [ RELS <! [ ARG1 handle ] !> ] ].

expletive_is_adj_expl_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE present ] ] !> ],
  FLAGS.TRIGGER "be_c_is" ].

expletive_was_adj_expl_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE past ] ] !> ],
  FLAGS [ TRIGGER "be_c_was" ] ].

expletive_be_adj_expl_gtr1 := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE future ] ] !> ],
  FLAGS.TRIGGER "be_c_be" ].

expletive_be_adj_expl_gtr2 := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ E.TENSE untensed ] ] !> ],
  FLAGS.TRIGGER "be_c_be" ].

expletive_been_adj_expl_gtr := generator_rule &
[ CONTEXT [ RELS <! [ ARG0 [ PERF + ] ] !> ],
  FLAGS.TRIGGER "be_c_been" ].

; Copula trigger rule types
; Five rules for copula plus [ PROGR + ] verbs, with ref-ind in 
; ARG1,2,3, or handle in ARG1,2 (sentential subject of active -- passive
; treated separately).

be_cop_x1_rule := arg0e+1x_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ],
		       ARG1 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

be_cop_x2_rule := arg0e+2x_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ],
		       ARG2 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

be_cop_x3_rule := arg0e+3x_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ],
		       ARG3 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

; Special case for future-modal "going to" as in "He is going to leave."
be_cop_going+to_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED _going+to_v_qmodal_rel ] !> ] ].

; Exclude 'are, 'were' since expletive 'it' and sentential subjects are
; 3sg.
be_cop_h1_rule := arg0e+1h_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ] ] !> ] ].

be_cop_h2_rule := arg0e+2h_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative,
                                  ASPECT.PROGR + ] ] ] !> ] ].

; Five rules for copula with passives: Either a message's PSV is
; coindexed with (1) a ref-ind (ARG 2,3) or (2) a handle (sentential subject 
; of passive verb, as ARG2) -- where the PSV attribute is unconstrained, allow
; both active and passive; or (3-4) context is a raising verb with a message
; argument (ARG1,2), as in "It was known that Kim won", where the PSV value 
; remains unbound since the syntactic subject is an expletive, invisible in MRS
; This latter case is unfortunate, since it means copulas will be introduced
; unnecessarily for lots of MRSs.
; So for the moment, we'll limit the damage by restricting these expletive
; subject passives to ones where there is no explicit 'by phrase', so we
; won't generate e.g. "It was known by everyone that Kim won".  Maybe no
; great loss for now.

; Here the FILTER rel prevents triggering when the event introducing the
; potentially passived argument is the ARG0 of a message whose PSV does not
; license that argument.  The #u also in FLAGS.EQUAL prevents this filter
; from being invoked if there is no value assigned in PSV, with the effect
; that an underspecified (or absent) PSV value will be compatible with
; this rule, so it will trigger.

be_cop_2x_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ],
                       ARG2 #x & event_or_index ] !> ],
   FLAGS [ EQUAL < semarg >,
           SUBSUME < #x >,
	   TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					     AGR.PNG #png ] ] ].

be_cop_3x_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ],
                       ARG3 #x & event_or_index ] !> ],
   FLAGS [ EQUAL < semarg >,
           SUBSUME < #x >,
	   TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					     AGR.PNG #png ] ] ].

be_cop_2h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative ] ],
                       ARG2 #h & handle ],
		     [ LBL #h,
		       PRED "~_v_",
		       ARG0.E.TENSE real_tense ] !> ],
   FLAGS.EQUAL < event, #h > ].

be_cop_3h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ MOOD indicative ] ],
                       ARG3 #h & handle ],
		     [ LBL #h,
		       PRED "~_v_",
		       ARG0.E.TENSE real_tense ] !> ],
   FLAGS.EQUAL < event, #h > ].

#|
be_cop_expl_1h_psv_rule := arg0e+1h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].
|#

be_cop_expl_2h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ],
                       ARG1 #x & ref-ind,
                       ARG2 #h & handle ] !> ],
   FILTER.RELS <! [ ARG0 #x ] !>,
   FLAGS.EQUAL < semarg, #h > ].

be_cop_expl_3h_psv_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_v_",
                       ARG0 [ E [ MOOD indicative ] ],
                       ARG1 #x & ref-ind,
                       ARG3 #h & handle ] !> ],
   FILTER.RELS <! [ ARG0 #x ] !>,
   FLAGS.EQUAL < semarg, #h > ].

; Three rules for copula plus predicative PP or AP, with 3sg ref-ind ARG1,2,3
be_cop_prd_1x_rule := arg0e+1x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ],
		       ARG1 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].


be_cop_prd_2x_rule := arg0e+2x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ],
		       ARG2 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

be_cop_prd_3x_rule := arg0e+3x_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ],
		       ARG2 #x ] !> ],
   FLAGS.TRIGGER-CONSTRAINT.SYNSEM.LOCAL [ CONT.HOOK.XARG #x & [ PNG #png ],
					   AGR.PNG #png ] ].

; Two similar rules for copula plus adjective with message argument as
; syntactic subject (again only ARG1,2 possible, and maybe even only ARG1).
; Again, exclude 'am, are, were'

be_cop_prd_1h_rule := arg0e+1h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

be_cop_prd_2h_rule := arg0e+2h_gtr &
 [ CONTEXT [ RELS <! [ PRED "~_[paj]_",
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

; One rule for copula with purposive VP: 'Kim is to stay here.'
be_cop_inf_rule := generator_rule &
 [ CONTEXT.RELS <! [ PRED eventuality_rel ] !> ].

; One rule for tag questions with there-copula in main clause (hack to avoid
; spurious ambiguity).
be_cop_tag_th_expl_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED _be_v_there_rel ] !> ] ].

; One rule for VP ellipsis with there-copula (hack to avoid spurious ambig).
be_cop_ellip_th_expl_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED _be_v_there_rel ],
                     [ PRED ellipsis_expl_rel,
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

be_cop_ellip_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ PRED ellipsis_ref_rel,
                       ARG0 [ E [ MOOD indicative ] ] ] !> ] ].

;; Rules for copula 'were' with group nouns which are semantically NUM 3s
;; as in |a number of cats were arising/hired|
be_cop_were_group_rule := arg0e_gtr &
 [ CONTEXT [ RELS <! [ ARG0 [ E [ TENSE past,
				  MOOD indicative ] ] ],
		     [ ARG0 basic_non_expl-ind & #x & [ PNG [ PN 3s ] ],
		       ARG1 basic_non_expl-ind & #arg & 
			    [ PNG [ PN -3s ] ] ] !> ],
   FLAGS [ EQUAL < semarg >,
	   SUBSUME < #x, #arg > ] ].

prep_particle_rule := generator_rule &
 [ CONTEXT [ RELS <! [ ARG2 #x & ref-ind ] !> ],
   FLAGS [ EQUAL < #x > ] ]. 

prep_particle_n_rule := generator_rule &
 [ CONTEXT [ RELS <! [ ARG1 #x & ref-ind ] !> ],
   FLAGS [ EQUAL < #x > ] ]. 

