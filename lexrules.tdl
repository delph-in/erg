;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright (c) 1994-2005
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see erg/licence.txt for conditions
;;;
;;;  lexrules.tdl
;;;
;;;  Inflectional affixes and derivational lexical rules
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Inflectional affixes
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Verbal inflections

non_fin_verb := local & 
  [ CAT.HEAD verb &
             [ VOICE active,
	       TAM [ TENSE #tense,
		     ASPECT #aspect ] ],
    CONT [ HOOK.INDEX #index & [ E [ TENSE #tense,
                                     ASPECT #aspect ] ],
           RELS.LIST.FIRST.ARG0 #index ] ].

; Need to constrain MOD value for PRP verbs.  Also for passive participles.


;; Verbal affix for present and passive participles, which can modify N-bars
;; DPF (7-Apr-99) Removed POSTHD - since the head_complement rule now passes
;; up the value of POSTHD from the head-dtr, so we need to leave it unmarked
;; to get "managers interviewed by Abrams" on the passive-by reading, and also
;; to still get "the interviewed managers"

;; Present participles and passives are both marked as PRD +, to block e.g. 
;; "the destroyed by Sandy chair" or "the talking to Kim consultant", but then
;; to get these participles alone in attributive position, we need a 
;; generalization of the attributive-adjective lexical rule below.
;; DPF 19-Feb-01 - To avoid massive unwanted ambiguity as in "Kim is sleeping"
;; restrict the MOD value to [AUX -].  
;; DPF 24-Mar-01 - Added SUBJ..SLASH 0-dlist to avoid spurious gaps.
;; DPF 18-Aug-01 - Removed [SUBJ.OPT -] to allow participle phrases without
;; subjects to be no-copula clauses, as in "arriving tomorrow".
;; DPF 24-Sep-01 - Added [MOD..TENSE real_tense as hack to block participles
;; from modifying nocop VPs, as in "partial clearing" - works since nouns have
;; underspecified TAM.
;; DPF 18-Apr-03 - From 19-Feb-01 - This also blocks "I am available starting
;; on Monday"
;; DPF 27-Apr-03 - Note that in blocking ambiguity for "Kim is sleeping"
;; (see 19-Feb-01), we also prevent an analysis for "Kim is happy driving",
;; so probably want to remove this constraint once parse ranking can carry the
;; load, given that there are also contexts where we want "Kim is, sleeping"

verb_participle_affix := local &
  [ CAT [ HEAD verb & [ PRD + ],
	  VAL.SUBJ < [ --SIND #agr,
                       NONLOC.SLASH 0-dlist ] >,
	  HC-LEX - ],
    CONT [ HOOK [ LTOP #hand,
                  INDEX #event ],
           RELS.LIST.FIRST [ LBL #hand,
                             ARG0 #event ] ],
    AGR #agr ].

; DPF 21-apr-04 Let's try making this underspecified for STATIVE, not STATIVE +
prp_verb := non_fin_verb & verb_participle_affix &
  [ CAT.HEAD [ VFORM prp,
               TAM.ASPECT [ PROGR + ] ] ].

; DPF 27-May-01 - Removed [ASPECT.PERF +] since this form is also used for
; passives, and since the auxiliary "have" already imposes PERF + on the
; relevant event.
; DPF 11-Nov-03 - Gave up on using past-participle form as input for passive,
; since this lack of constraint on PROGR created too much trouble for 
; generation, since "Kim has arrived" didn't say [PROGR -] so we could get
; 'Kim is being hired'.  One disadvantage is that we have to stipulate
; duplicate irregular passive forms for the irregular past participles.

psp_verb := non_fin_verb &
  [ CAT [ HEAD [ VFORM psp,
                 TAM.ASPECT [ PROGR -,
                              PERF + ],
		 PRD - ],
	  VAL.SUBJ < [ OPT - ] > ] ].

non_perf :< local.

; DPF 12-May-00 - bse_verb needs to have [ MOD nbar ] to enable coordination
; of imperative and declarative clauses, as in "Leave and I will follow you"
; DPF 17-Oct-01 - Made ASPECT be no_aspect rather than no_aspect* in order to
; let K2Y distinguish true base-VPs from participles.
; DPF 7-Nov-03 - Remember that bse_verb can't have TENSE no_tense (which would
; be convenient for generation) since it can combine with "do" as in "did the
; dog bark?"

bse_verb := non_fin_verb & non_perf &
  [ CAT [ HEAD [ VFORM bse,
		 PRD -,
		 TAM.ASPECT no_aspect ],
          POSTHD +,
	  VAL.SUBJ < unexpressed_reg & [ OPT - ] > ] ].

; Since finite verbs can project relative clauses, we introduce [MOD < nbar >]
; here, and make sure that no other projections of finite verbs can be
; adjuncts, through constraints on the head-adjunct phrase type.
; DPF 4-Mar-01 - Removed [CONT.MSG no_msg] from SUBJ, to allow e.g.
; "me hiring you bothered him"
; 21-apr-04 - Removed STATIVE - from INDEX

basic_fin_verb := non_perf &
  [ CAT [ HEAD verb &
               [ PRD -,
                 VOICE active,
		 TAM [ TENSE #tense,
		       ASPECT #aspect ],
		 VFORM fin ],
	  POSTHD +,
	  VAL.SUBJ < synsem & [ LOCAL [ CAT.HEAD.CASE nom,
                                        CONJ cnil ] ] > ],
    CONT psoa & 
             [ HOOK.INDEX #event & [ E [ TENSE #tense,
                                         ASPECT #aspect ] ],
	       RELS.LIST.FIRST.ARG0 #event ] ].


fin_verb := basic_fin_verb & 
  [ CAT.VAL.SUBJ < [ OPT - ] > ].

pres_verb := fin_verb & 
  [ CAT.HEAD.TAM ind_or_mod_subj_tam &
                 [ TENSE present,
		   ASPECT no_aspect,
		   MOOD indicative ] ].

past_or_subj_verb := fin_verb &
  [ CAT.HEAD.TAM past_or_subj_tam ].

third_sg_fin_verb := pres_verb &
  [ AGR.PNG png & [ PN 3sg ] ].

non_third_sg_fin_verb := pres_verb &
  [ CAT.VAL.SUBJ < [ LOCAL local & [ CONT nom-obj ] ] >,
    AGR.PNG png & [ PN non3sg ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Nominal inflections

sing_noun := local &
  [ CAT [ HEAD noun,
          VAL.SPR < [ LOCAL.AGR [ PNG.PN 3sg,
                                  DIVISIBLE - ] ] > ],
    CONT.HOOK.INDEX [ PNG png & [ PN 3sg ],
                      DIVISIBLE - ] ]. 

mass_noun := local &
  [ CAT [ HEAD noun,
          VAL.SPR < [ LOCAL.AGR [ PNG.PN 3sg,
                                  DIVISIBLE + ] ] > ],
    CONT.HOOK.INDEX [ PNG png & [ PN 3sg,
                                  GEN neut ],
		      DIVISIBLE + ] ]. 

mass_count_noun := local &
  [ CAT [ HEAD noun,
          VAL.SPR < [ LOCAL.AGR.PNG.PN 3sg ] > ],
    CONT.HOOK.INDEX.PNG png & [ PN 3sg,
                                GEN neut ] ]. 

plur_noun := local &
  [ CAT [ HEAD noun,
          VAL.SPR < [ LOCAL.AGR [ PNG.PN 3pl,
                                  DIVISIBLE + ] ] > ],
    CONT.HOOK.INDEX [ PNG png & [ PN 3pl ],
                      DIVISIBLE + ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Adjectival inflections
;;
;;  May-96: Martina

pos_adj := local &
  [ CAT [ HEAD adj,
          VAL.SPR < [ LOCAL local &
                            [ CAT.HEAD.KEYS.KEY very_deg_rel ] ] > ] ].


er_comp_adj := local &
  [ CAT [ HEAD adj,
          VAL.SPR < [ LOCAL local &
                          [ CAT.HEAD.KEYS.KEY much_deg_rel ] ] > ] ].


est_super_adj := local &
  [ CAT [ HEAD adj,
          VAL.SPR < [ LOCAL local &
                          [ CAT.HEAD.KEYS.KEY def_explicit_q_rel ],
                    OPT - ] > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Place holder affix for -ly

-ly := local & [ CAT.HEAD no_head ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  (Non-inflectional) lexical rules
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; AAC - INFLECTD added so that the relationship between inflectional 
;;; morphology and lexical rules can be represented declaratively
;;;
;;; lex_rule_infl turns uninflected things into inflected ones
;;; but otherwise does inheritance
;;; everything else requires inflected forms
;;; ND-AFF ('needs affix') is used to determine whether a rule has an overt
;;; suffix which triggers the spelling-change rules.

lex_rule_supermost := phrase_or_lexrule & word_or_lexrule &
  [ ND-AFF bool,
    DTR sign & [ ALTS #alts,
                 POSSCL -,
                 IDIOM #idiom,
                 SYNSEM.PUNCT [ LPUNCT #lpunct,
                                RPUNCT #rpunct ] ],
    ALTS #alts,
    IDIOM #idiom,
    SYNSEM abstr_lex_synsem &
           [ PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct ] ] ].


; DPF 14-Aug-99 - Reorder appending of RELS from above since treatment of 
; fragments looks for the first scope hole from left to right in RELS, and 
; the first definition below gives different results for "October first" and 
; "the first of October".
; DPF 22-May-00 - But lexical rules in general may want to change categories,
; and the output's properties should conform to the type; for example, the
; rule for partitives wants to have the output be a noun, so the first element
; on RELS should be a nom_rel, not the quant_rel which the DTR would supply.
; So we go back to the original appending model, and leave the proper
; treatment of scope holes in fragments for later solutions.

lex_rule_compos := lex_rule_supermost &
  [ DTR.SYNSEM.LOCAL.CONT.RELS [ LIST #first,
                                 LAST #middle ],
    SYNSEM.LOCAL.CONT.RELS [ LIST #first,
                             LAST #last ],
    C-CONT.RELS [ LIST #middle,
                  LAST #last ] ].

lex_rule_infl_affixed := lex_rule_compos &
  [ INFLECTD +,
    KEY-ARG #keyarg,   
    SYNSEM #synsem,
    ARGS < #dtr >,
    POSSCL -,
    DTR #dtr & [ INFLECTD -,
                 KEY-ARG #keyarg,   
                 SYNSEM #synsem ],
    C-CONT.RELS <! !> ].

; ERB (05-10-97) Now that sai stamps MSG.PRED int_m_rel on its output, that
; default has to be taken out of lex_rule.  To avoid breaking anything else, I
; am making a new type lex_rule_super that is just like the current lex_rule
; except that it doesn't identify the messages, and then having lex_rule do
; that identification.

lex_rule_super := lex_rule_supermost &
  [ DTR word_or_lexrule &
        [ INFLECTD +,
          SYNSEM.LOCAL local &
		       [ CONJ cnil ] ],
    INFLECTD +,
    SYNSEM.LOCAL local &
	[ CONJ cnil ] ].

lex_rule_super_compos := lex_rule_super & lex_rule_compos &
  [ POSSCL - ].

lex_rule := lex_rule_super_compos &
  [ DTR #stem &
	[ SYNSEM.LOCAL [ CAT [ MC #mc,
                               HC-LEX #hclex ],
                         CONT.MSG #msg ] ],
    SYNSEM [ LOCAL [ CAT [ MC #mc,
                           HC-LEX #hclex ],
                     CONT.MSG #msg ] ],
    ARGS < #stem > ].

;;
;;  Forms derived from inflected verbs
;;

; ERB (05-10-97) Before we had a special rule hcomp_yn_root for matrix polar
; questions.  Now, the unique head complement rule is taking over this job.
; To do this, we must put the int_m_rel onto the inverted auxiliaries (see also
; sai_synsem).  The original objection to this was that the inverted
; auxiliaries are used for things other than matrix questions (i.e., negative
; inversion).  However, a) we don't currently have an analysis of negative
; inversion, and b) it's not clear that they are the same auxiliaries.  The
; most obvious test -- 1st person aren't -- is not available since the
; contracted auxiliaries are in general disallowed in negative inverstion
; (polarity effect?).
;
; At the moment this is allowing "Will who sleep?" and "Will Kim see who?"
; (actually two parses of the latter).  This is fine, except that this is not
; producing the apropriate semantics.  In fact, all ynq (matrix and
; subordinate) are not currently specified for PARAMS.  I think this will be
; easier to fix once we have a) lexical threading and b) an implementation of
; the analysis of echo questions, so I am leaving it for later.
 
; DPF (10-Jan-99) Added SUBJ value identified with dtr's SPR value (usually
; < anti_synsem > which never unifies with real synsem), in order to allow 
; adjunct extraction to still apply to inverted sentences such as "When is 
; Kim happy" where "is Kim happy" is built by two applications of the head_comp
; rule.  By identifying SUBJ with dtr's SPR, we can maintain lexical control
; over modifiability, in particular blocking spurious modification of 
; auxiliary "do", both in noninverted and inverted clauses.
; DPF 22-Apr-00 - Added reentrancy for VFORM on DTR and mother - don't know
; why this was omitted before.  It's needed to block spurious parse for e.g. 
; "Could you sleep please"
; DPF 5-Jul-02 - Removed re-entrancy of SYNSEM..SUBJ..INDEX with dtr's, since
; it was wrecking coordination of "did Kim win or did Sandy win, since the
; SUBJ..INDEX got identified for both.  So what do we give up?
 
; ERB (2003-10-13) Making a supertype to keep mal_sai as close to sai as
; possible.

basic_sai := lex_rule &
  [ STEM #orth,
    DTR #stem &
	 [ STEM #orth,
	   SYNSEM [ LOCAL [ CAT [ HEAD verb &
				       [ VFORM fin & #vform,
                                         TAM #tam,
					 VOICE #voice,
                                         KEYS #keys ],
				  VAL [ SUBJ < #subj & canonical_synsem &
                                               [ LOCAL 
                                                 [ CAT nomp_cat_nom,
                                                   CONT.MSG no_msg ] ] >,
                                        COMPS #comps,
					SPR #spr,
					KCMP #keycomp ] ],
			    CONT [ HOOK #hook,
				   HCONS #hcons,
                                   MSG #msg ],
                            AGR #agr ],
                    NONLOC #nonloc ] ],
    SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				  TAM #tam,
				  VOICE #voice,
				  KEYS #keys ],
			   VAL [ COMPS < #subj & [ OPT - ]
					 . #comps >,
				 SPR #spr,
				 SUBJ < anti_synsem >,
				 KCMP #keycomp ] ],
		     CONT [ HOOK #hook,
			    HCONS #hcons,
			    MSG #msg & no_msg],
                   AGR #agr ],
	     NONLOC #nonloc ],
    ARGS < #stem >,
    C-CONT.RELS <! !> ].

; DPF 28-mar-05 - Now propagate AUX from daughter, since we need cop-id to
; be unmarked for AUX, so it can be modified by PPs, as in "where is Kim the
; king?"
sai := basic_sai &
  [ SYNSEM basic_sai_synsem & [ LOCAL.CAT.HEAD.AUX #aux ],
    DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +,
                                AUX #aux ] ].

tag := lex_rule_super &
  [ STEM #orth,
    DTR #stem &
	[ STEM #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD [ TAM #tam,
                                      KEYS #keys ],
			       VAL.COMPS < [ LOCAL.AGR.PNG #png ],
                                           [ LOCAL.CAT.HEAD subst ], ... >,
                               HC-LEX #hclex ] ],
		 NONLOC #nonloc & 
		       [ SLASH 0-dlist,
			 REL 0-dlist,
			 QUE 0-dlist ] ] ],
    SYNSEM tag_synsem &
	 [ LOCAL [ CAT [ HEAD [ TAM #tam,
                                KEYS #keys ],
			 VAL.COMPS.FIRST synsem & 
                                  [ LOCAL [ CAT nomp_cat_nom_min,
                                            AGR.PNG #png,
                                            CONT.MSG no_msg,
                                            CONJ cnil ],
                                    OPT - ], 
                         HC-LEX #hclex ],
		   CONT [ RELS #cliszt,
                          MSG #msg ] ],
           NONLOC #nonloc ],
    ARGS < #stem >,
    C-CONT.RELS #cliszt & <! #msg !> ].


; DPF 3-Apr-01 - Eventually generalize to "stand, sit" etc. 

loc_inv := lex_rule_super &
  [ STEM #orth,
    POSSCL -,
    DTR #stem &
	[ STEM #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD #head,
			       VAL.COMPS < #subj,
                                           [ LOCAL #local & [ CAT prd_cat ]] >,
                               HC-LEX #hclex ],
                         CONT.HOOK [ LTOP #ltop,
                                     INDEX #ind ],
                         AGR #agr ],
		 NONLOC 
		       [ SLASH 0-dlist,
			 REL 0-dlist,
			 QUE 0-dlist ] ] ],
    SYNSEM loc_inv_synsem &
	 [ LOCAL [ CAT [ HEAD #head,
			 VAL.COMPS < #subj >,
                         HC-LEX #hclex ],
                   AGR #agr,
		   CONT [ HOOK [ LTOP #ltop,
                                 INDEX #ind ],
                          RELS #cliszt,
                          MSG #msg ] ],
           NONLOC [ SLASH <! #local !>,
                       REL 0-dlist,
                       QUE 0-dlist ] ],
    C-CONT.RELS #cliszt & <! #msg !>,
    ARGS < #stem > ].


; DPF 31-Jul-99 - Removed [INV -] from DTR, since it blocked entry for
; "Is that also important?"
; DPF 1-Jun-01 - Removed DTR..SUBJ canonical_synsem, since prevents relative
; clauses headed by these, as in "messages that are not valid fail".
; DPF 3-Jun-01 - Made DTR..VFORM fin rather than fin* to avoid V+ADV analysis
; of "be not happy"
; DPF 13-Sep-01 - Copy attributes of HEAD from dtr to mother, to make sure that
; dtr is [AUX +] but mother is [AUX +*] so it will still coordinate with nonaux
; ERB 2003-10-13 Make supertype to keep mal_adv_addition as close as possible.

basic_adv_addition := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM 
               [ LOCAL [ CAT [ HEAD verb &
				    [ VFORM fin,
                                      MOD #mod,
                                      PRD #prd,
                                      INV #inv,
                                      TAM #tam,
                                      VOICE #voice,
                                      KEYS #keys ],
			       VAL [ SUBJ #subj & < synsem >,
				     COMPS #comps & *substlist*,
				     SPR #spr ],
			       POSTHD #ph ],
			 CONT [ HOOK [ LTOP #vltop,
                                       INDEX #vindex,
                                       XARG #xarg ],
				HCONS #hcons ],
			 CTXT #ctxt ],
		 NONLOC #nonloc ] ],
    SYNSEM basic_aux_verb &
	 [ LOCAL 
	   [ CAT 
	     [ HEAD verb &
                    [ AUX +,
                      VFORM fin,
                      MOD #mod,
                      PRD #prd,
                      INV #inv,
                      TAM #tam,
                      VOICE #voice,
                      KEYS #keys ],
               VAL [ SUBJ #subj,
		     COMPS *cons* &
			  < [ LOCAL local &
			     [ CAT [ HEAD basic_lexadv &
                                     [ MOD < [ LOCAL.CONT.HOOK 
                                                         [ LTOP #vltop,
                                                           INDEX #vindex ] ] >,
                                       TAM #tam ],
                                     VAL.COMPS < > ],
                               CONT [ HOOK.LTOP #advltop,
                                      MSG no_msg ] ],
                              LEX +,
			      OPT - ] . #comps >,
		     SPR #spr ],
	       POSTHD #ph ],
	     CONT [ HOOK [ LTOP #advltop,
                           INDEX #vindex,
                           XARG #xarg ],
		    HCONS #hcons ],
	     CTXT #ctxt ],
	   NONLOC #nonloc ],
    C-CONT.RELS <! !> ].

adv_addition := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.AUX + ].

;; VP Ellipsis
;; We can't let this rule apply to the infinitival "to", since we would then
;; have no way of blocking the NP "the book to", where "to" first underwent
;; this rule, then the subject-extraction rule (needed for ordinary infinitival
;; relatives), and then the usual infinitival relative rule.  So instead we
;; create a separate lexical entry for the elided form of "to", and make it
;; MOD < >.
;; DPF 24-Jun-01 - Made DTR be TAM.ASPECT nonprg to prevent "Kim is being".
;; DPF 31-May-02 - This may not have been enough, so tried adding VFORM 
;; fin_or_bse.
;; DPF 28-Nov-03 - But then we don't get "Kim has been", so removed it; now
;; we should block "kim is being with the ASPECT.PROGR - constraint.
;; DPF 11-mar-05 - Removed AUX + since now restricting PPs to modify only
;; [AUX -] VPs.

vp_ellipsis := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
          ALTS.VPELLIP +,
	  SYNSEM basic_verb_synsem &
	   [ LOCAL [ CAT [ HEAD verb &
				[ MOD #mod,
                                  PRD #prd,
                                  INV #inv,
                                  AUX +,
                                  TAM #tam &
                                      [ ASPECT.PROGR - ],
                                  VFORM #vform,
                                  VOICE #voice,
                                  KEYS.KEY #key ],
                           POSTHD #ph,
			   VAL [ SUBJ #subj,
				 SPR #spr,
				 COMPS < unexpressed &
					 [ LOCAL [ CAT.HEAD subst,
						   CONT.HOOK 
                                                   [ LTOP #chand,
                                                     INDEX #cind ]]], ... > ]],
                     CONT [ HOOK [ LTOP #hand,
                                   INDEX #ind ],
			    HCONS #hcons ],
		     CTXT #ctxt ],
             LKEYS.KEYREL.PRED #key,
	     NONLOC #nonloc ] ],
    SYNSEM verb_synsem &
	 [ LOCAL [ CAT [ HEAD verb & 
                              [ MOD #mod,
                                PRD #prd,
                                INV #inv,
                                TAM #tam,
                                VFORM #vform,
                                VOICE #voice,
                                KEYS [ KEY #key,
                                       ALTKEY ellipsis_rel ] ],
                         POSTHD #ph,
			 VAL [ SUBJ #subj,
			       SPR #spr,
			       COMPS < > ] ],
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #ind ],
			  HCONS #hcons ],
                   CTXT #ctxt ],
           LKEYS [ KEYREL.PRED #key,
                   ALTKEYREL #altkey & arg1_relation &
                               [ LBL #chand,
                                 PRED ellipsis_rel,
                                 ARG0 #cind ] ],
           NONLOC #nonloc ],
    C-CONT.RELS <! #altkey !> ].

vp_ellipsis_ref := vp_ellipsis &
  [ DTR.SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --SIND #cind ] >,
                       CONT.HOOK.XARG ref-ind & #sind ],
    SYNSEM verb_synsem &
	 [ LOCAL.CONT.HOOK.XARG #sind,
           LKEYS.ALTKEYREL [ ARG0 #cind,
                             ARG1 #sind ] ] ].
                   
vp_ellipsis_expl := vp_ellipsis &
  [ DTR.SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY _be_v_there_rel,
                               VAL.COMPS < synsem, unexpressed > ],
                         CONT.HOOK.XARG there-ind & #ind ],
                 LKEYS.--+SUBJIND #subjind ],
    SYNSEM verb_synsem &
	 [ LOCAL.CONT.HOOK [ LTOP #ltop,
                             INDEX #event,
                             XARG #ind ],
           NONLOC.QUE 0-dlist,
           LKEYS [ ALTKEYREL [ LBL #ltop,
                               ARG0 #event ],
                   --+SUBJIND #subjind ] ] ].

;; Need to work on generalizing the semantics - since we derive this entry
;; from the past participle, we have to discard the tense information from
;; the input - not clear yet how to do this in general.  For now we assume
;; that transitive verbs introduce a single relation, bound to the KEYREL
;; attrib.

; This incorrectly orders the by_pp before all remaining comps - wrong for
; double-NP verbs, and incomplete for verbs with other oblique arguments,
; since this allows only one order.  But this latter is a general problem.

; DPF 3-Nov-01 - Removed [CONT..E-INDEX.E.ASPECT perf*] since this allows wrong
; generation.  Why was it here?

basic_passive_verb_lr := lex_rule_compos &
  [ INFLECTD +,
    DTR #dtr &
        [ ALTS.PASSIVE +,
          INFLECTD -,
	  SYNSEM verb_synsem &
               [ LOCAL [ CAT [ HEAD verb &
                                    [ VFORM pas,
                                      TAM [ TENSE #tense,
                                            MOOD #mood ],
                                      KEYS.KEY #key ],
                               VAL [ SUBJ < [ --SIND #subjind, 
                                              NONLOC #snonloc ] >,
                                     SPR #spr ] ],
			 CONT [ HOOK.LTOP #hand,
				HCONS #hcons ],
                         CONJ cnil,
			 CTXT #ctxt ],
                 LKEYS [ --COMPKEY #ckey,
                         --+COMPKEY #plusckey,
                         --OCOMPKEY #ockey,
                         --+OCOMPKEY #plusockey ],
                 NONLOC #nonloc ] ],
    SYNSEM passive_synsem &
	 [ LOCAL verb_participle_affix &
		 [ CAT [ HEAD verb & [ TAM [ TENSE #tense,
                                             MOOD #mood ],
                                       KEYS.KEY #key ],
			 VAL [ SPR #spr,
                               COMPS < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                           INDEX #subjind ],
                                         NONLOC #snonloc ], ... > ] ],
                   CONT [ HOOK.LTOP #hand,
			  HCONS #hcons ],
		   CTXT #ctxt ],
           LKEYS [ --COMPKEY #ckey,
                   --+COMPKEY #plusckey,
                   --OCOMPKEY #ockey,
                   --+OCOMPKEY #plusockey ],
           NONLOC #nonloc ],
    C-CONT.RELS <! !>,
    POSSCL -,
    ARGS < #dtr > ].

;; This has the same problem as the passive lexical rule.  Since we derive the
;; gerund from the present particple, we somehow have to filter out the
;; progressive relation.

;; DPF 27-May-99 - We block extraction from gerunds, at least for efficiency.
;; DPF 27-May-99 - POSS-ING gerunds are given a non-empty SUBJ value so they
;; can be modified by ordinary PPs and non-sentential adverbs, but the synsem
;; value is the hack 'anti_synsem' which is also used for the SPR value of 
;; verbs, for similar reasons.
;; DPF 27-May-99 - Try combining the two verbal gerund rules into one.
;; DPF 02-June-99 - We also block the auxiliary verbs "being, having, doing",
;; to avoid identity copula analyses for "Kim is being good" or "Kim is having
;; hired Sandy".
;; DPF 31-Jul-99 - Make gerund_rel like nominalize_rel in identifying its
;; handle with the verb_rel's, rather than taking the verb's handle as arg.
;; DPF 24-Jun-01 - Added REL 0-dlist to block "interviewing that" as gerund NP
;; with rel-pro "that".  This is overly strong for pied piping, as in "I met
;; some people talking to whom was pleasant", but we would need to distinguish
;; at least rel-pro "that" (and maybe "who") from "whom" - maybe later.
;; DPF 8-Nov-01 - The decision to block extraction from verbal gerunds means
;; we don't get "Which books are you interested in buying".
;; DPF 21-Jul-03 - Removed PRONTYPE not_pron from mother's index - not clear
;; why it was there, but it blocked "my arriving surprised kim".
;; DPF 23-aug-04 - Added SLASH 0-dlist, like for nominal gerunds, to further
;; enforce Ross's complex-NP constraint.
;; DPF 23-aug-04 - Regarding 02-June-99 comment, we now more generally use
;; SORT to block spurious analysis for "kim is being good", just like for
;; "Kim is arriving", so we remove the [AUX -] constraint, which means we
;; once again can get "after being hired, Kim smiled"
;; Changed SYNSEM nonpro_onearg_synsem to SYNSEM basic_one_arg so as to
;; leave the LEX value underspecified, so we can avoid bare-vger for 
;; unadorned verbal gerunds.

vger_ing := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ CAT [ HEAD verb &
                                    [ VFORM prp ],
			       VAL [ SUBJ < [ --SIND #subj,
                                              NONLOC #snonloc ] >,
                                     COMPS #comps ] ],
			 CONT [ HOOK.LTOP #vhand,
                                HCONS [ LIST #hclist,
                                        LAST #hclast ] ],
                         CTXT #ctxt ],
                 LKEYS [ KEYREL.ARG0.E [ TENSE no_tense, 
                                         ASPECT.PERF - ],
                         --COMPKEY #ckey,
                         --OCOMPKEY #ockey ],
		 NONLOC #nonloc ] ],
    SYNSEM basic_one_arg &
	   [ LOCAL [ AGR #ind,
		     CAT [ HEAD gerund &
				[ MOD < >,
				  PRD -,
                                  POSS -,
                                  KEYS.KEY gerund_rel ],
			   VAL [ SUBJ < synsem &
				    [ LOCAL [ CAT nomp_cat_acc_min &
                                                  [ HEAD noun ],
					      CONJ cnil,
                                              CONT.MSG no_msg ],
                                      --SIND #subj ] >,
                                 SPR < [ LOCAL local &
					   [ CAT [ HEAD det & 
						    [ POSS + ],
                                                   VAL [ SUBJ < >,
							 SPR *olist*,
							 COMPS < > ] ],
                                             CONT.HOOK.INDEX #subj ],
                                         NONLOC #snonloc,
                                         OPT - ] >,
                                 COMPS #comps ] ],
		     CONT nom-obj &
                          [ HOOK [ LTOP #hand,
                                   INDEX #ind &
                                       [ PNG png & [ PN 3sg,
                                                     GEN neut ],
                                         DIVISIBLE +] ],
                            HCONS [ LIST < qeq & 
                                      [ HARG #marghand,
                                        LARG #vhand ] . #hclist >,
                               LAST #hclast ] ],
                     CTXT #ctxt ],
             LKEYS [ KEYREL #key & gerund_relation &
                            [ LBL #hand,
                              ARG0 #ind,
                              ARG1 #arghand ],
                     --COMPKEY #ckey,
                     --OCOMPKEY #ockey ],
	     NONLOC #nonloc & [ SLASH 0-dlist,
                                REL 0-dlist & [ LIST < > ] ] ],
    C-CONT.RELS <! #key, message & [ LBL #arghand,
                                     PRED prpstn_m_rel,
                                     MARG #marghand ] !> ].

;; DPF (12-Jul-98) In order to allow prenominal adjectives for nominal gerunds,
;; as in "regular tasting of wine is healthy", we have to treat the specifier
;; of the gerund as obligatory, since prenominal adjectives distinguish proper
;; from common nouns based on the optionality (or absence) of the specifier.
;; So these gerunds have to undergo the bare plural rule if no determiner is
;; present, which means they also have to be DIVISIBLE +.
;; DPF 26-Mar-01 - Added [ALTKEY relation] to mother, to avoid having verbal
;; gerunds as, e.g., modified by "per/a person".
;; DPF 22-Apr-01 - Removed DIVISIBLE + since we're getting a systematic
;; ambiguity between bare nominal gerunds and bare verbal gerunds.  This means
;; we'll block "hiring of consultants is important", but that's okay for now.
;; DPF 30-Aug-01 - But we also lose "loud singing is discouraged", which is
;; not okay, so we put DIVISIBLE + back on mother.
;; DPF 23-Sep-01 - Used to have [ALTKEY relation] to block gerunds appearing as
;; left members of noun-noun compounds, but this also blocked them as heads of
;; compounds as in "chair buying is fun".  So eliminate this constraint, and
;; allow nominal gerunds on both sides of compounds, as in "email routing list"
;; or "weekend shopping regulations" - and block pres-participles as adjectives
;; to avoid apparently spurious ambiguity for e.g. "shopping trip".  But 
;; consider "the hiring consultant" which is ambiguous between the one who
;; does the hiring and the one who advises on hiring - maybe differing 
;; intonation suggests two distinct analyses, not spurious.  But block for now.
;; DPF 10-Nov-01 - Made nominal gerunds have head type nomger so they can be
;; distinguished from non-derived nouns (e.g. so modifiers like "per" don't
;; attach).
;; DPF 26-aug-04 - Note that we leave the output of the nominal-gerund rule
;; unmarked for INFLECTD so it can appear as the left member of n-n-cmpnds.

nominal_gerund := lex_rule_compos &
  [ STEM #orth,
    DTR word_or_lexrule & #dtr &
        [ STEM #orth,
          INFLECTD +,
	  SYNSEM verb_synsem &
	       [ LOCAL local &
                       [ CAT [ HEAD verb &
                                    [ VFORM prp,
				      AUX - ],
			       VAL.SUBJ < [ NONLOC #snonloc ] >,
                               MC #mc,
                               HC-LEX #hclex ],
			 CONT [ HOOK.LTOP #vhand,
                                MSG #msg,
                                HCONS [ LIST #hclist,
                                        LAST #hclast ] ],
                         CONJ cnil,
			 CTXT #ctxt ],
                 LKEYS [ KEYREL.ARG0.E [ TENSE no_tense,
                                         ASPECT.PERF - ],
                         --COMPKEY #ckey,
                         --OCOMPKEY #ockey ],
		 NONLOC #nonloc ] ],
    SYNSEM nonpro_nomod_synsem &
	   [ LOCAL local &
	     [ AGR #ind,
	       CAT 
	       [ HEAD nomger & [ KEYS.KEY nominalize_rel ],
		 VAL [ SUBJ < >,
		       SPR < [ LOCAL local &
				     [ CAT [ HEAD det,
					     VAL [ SUBJ < >,
						   SPR *olist*,
						   COMPS < > ] ],
                                       AGR.PNG #png ],
                               --SIND #ind & [ PNG #png ],
			       NONLOC #snonloc,
			       OPT - ] > ],
                 MC #mc,
                 HC-LEX #hclex ],
               CONT [ HOOK [ LTOP #hand,
                             INDEX #ind & [ PNG png & [ PN 3sg,
                                                        GEN neut ],
                                            DIVISIBLE +,
                                            PRONTYPE not_pron ] ],
                      MSG #msg,
                      HCONS [ LIST < qeq & 
                                      [ HARG #marghand,
                                        LARG #vhand ] . #hclist >,
                               LAST #hclast ] ],
               CONJ cnil,
	       CTXT #ctxt ],
             LKEYS [ KEYREL #key & nominalize_relation &
                              [ LBL #hand,
                                ARG0 #ind,
                                ARG1 #arghand ],
                     --COMPKEY #ckey,
                     --OCOMPKEY #ockey ],
	     NONLOC #nonloc & [ SLASH 0-dlist ],
             MODIFD notmod ],
    C-CONT.RELS <! #key, message & [ LBL #arghand,
                                     PRED prpstn_m_rel,
                                     MARG #marghand ] !>,
    POSSCL -,
    ARGS < #dtr > ].

intrans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM intrans_subst & 
	       [ LOCAL.CAT.VAL.COMPS #comps ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #comps ].

intrans_pp_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM unsat_two_arg_subst &
	       [ LOCAL.CAT.VAL.COMPS #comps &
                                     < [ LOCAL.CAT.HEAD prep ], ... > ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #comps ].


;; This is too restrictive.  It only forms nominal gerunds from strictly
;; transitive verbs.  So, it doesn't give you "Kim's putting of food on the
;; table" or "Kim's warning of Sandy that it would rain" or "Kim's giving of
;; raisins to the ants".  
;;  To avoid ambiguity with the intransitive nominal gerund, we make the PP
;; obligatory.
;; DPF 19-Feb-01 - But this is too restrictive: blocks "Hiring is difficult"
;; DPF 22-Feb-01 - Added restriction on --COMPKEY (and --OCOMPKEY) to prevent 
;; verb-particle verbs (with "selected_rel" complements) from undergoing rule.
;; DPF 26-Mar-01 - Make the OPT value of the of-PP complement be same as that
;; of the verb's complement NP.
;; DPF 23-Sep-01 - But this prevents e.g. "hiring is important".  So make the
;; value OPT +, which seems true for nominal gerunds.
;; DPF 03-Apr-03 - Constrained PP-comp to be [SLASH 0-dlist] (and REL and QUE)
;; Long-standing bug.  Sigh.
;; DPF 22-Jul-03 - Added constraint COMPS <expressed_synsem> to remove spurious
;; ambiguity for "My hiring" as we do for ordinary n_ppcomp lexical entries.

trans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM trans_subst & 
	       [ LOCAL.CAT.VAL.COMPS < [ --SIND #index,
                                         NONLOC #nonloc ] >,
                 LKEYS [ --COMPKEY independent_rel,
                         --OCOMPKEY independent_rel ] ],
    SYNSEM.LOCAL [ CAT.VAL.COMPS < expressed_synsem &
                                   [ LOCAL [ CAT basic_pp_cat &
                                               [ HEAD.KEYS.KEY _of_p_sel_rel ],
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #index ],
                                             CONJ cnil ],
                                     NONLOC #nonloc,
                                     OPT + ] >,
                   CONT.HOOK.LTOP #ltop ] ].

; DPF 13-Oct-02 - Added COMPS < > to SPEC..SYNSEM, to avoid spurious ambiguity
; for e.g. "Friday evening"

date_det_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD noun,
                                 VAL.COMPS < [ OPT + ] > ],
			   CONT.HCONS [ LIST #hclist,
                                        LAST #hclast ],
			   CTXT #ctxt ],
                   LKEYS [ KEYREL #altkey,
                           --COMPKEY #ckey,
                           --OCOMPKEY #ockey ],
		   NONLOC #nonloc ] ],
    SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD det & [ KEYS.KEY #keypred ],
                           VAL [ SUBJ < >,
				 SPR < >,
                                 COMPS < >,
				 SPEC < [ LOCAL [ CAT.VAL.COMPS < >,
                                                  CONT.HOOK.LTOP #nltop ],
                                          --SIND #ind ] > ] ],
                     CONT [ HOOK.INDEX #ind,
			    HCONS [ LIST < qeq &
                                            [ HARG #rhand,
                                              LARG #nltop ] . < qeq &
                                              [ HARG #mhand,
                                                LARG #mltop ] . #hclist > >,
                                     LAST #hclast ] ],
		     CTXT #ctxt ],
             LKEYS [ KEYREL #key &
                            [ PRED def_q_rel & #keypred,
                              ARG0 #ind,
                              RSTR #rhand ],
                     ALTKEYREL #altkey &
                               [ LBL #mltop,
                                 ARG0 #spind ],
                     --COMPKEY #ckey,
                     --OCOMPKEY #ockey ],
	     NONLOC #nonloc & [ SLASH 0-dlist,
                                   REL 0-dlist,
                                   QUE 0-dlist ],
	     MODIFD hasmod ],
    C-CONT.RELS <! #key,
                    prep_relation &
                    [ LBL #nltop,
                      PRED of_p_rel,
                      ARG0.E.TENSE no_tense,
                      ARG1 #ind,
                      ARG2 #spind ],
                    [ PRED def_q_rel,
                      ARG0 #spind,
                      RSTR #mhand ] !> ].

; "October": NP => Determiner
;          "(in) October" => "October first"

month_det_lr := date_det_lr &
  [ DTR.SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY mofy_rel,
                 LKEYS.KEYREL.PRED mofy_rel ],
    SYNSEM.LOCAL.CAT [ HEAD.KEYS.ALTKEY mofy_rel,
                       VAL.SPEC < [ LOCAL.CAT.HEAD.KEYS.KEY dofm_rel ] > ] ].

; "Tuesday": NP => Determiner
;          "(on) Tuesday" => "Tuesday morning"

weekday_det_lr := date_det_lr &
  [ SYNSEM.LOCAL.CAT [ HEAD.KEYS.ALTKEY dofw_rel,
                       VAL.SPEC < [ LOCAL.CAT.HEAD.KEYS.KEY day_part_rel ] > ],
    DTR.SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY dofw_rel,
                 LKEYS.KEYREL.PRED dofw_rel ] ].

; "January first 1984" from "the first of january"
mofy_dofm_yofc_lr := lex_rule &
  [ STEM #orth,
    SYNSEM dom_ord_yofc_synsem,
    DTR [ STEM #orth,
	  SYNSEM dom_ord_synsem ] ].


; Comment out for now - unused due to too much ambiguity
#|
adj_noun_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD adj & [ PRD - ],
				 VAL [ COMPS #comps,
				       SPR < #spr > ] ],
			   CONT [ HOOK.LTOP #ahand,
                                  HCONS #hcons,
                                  MSG #msg ],
			   CTXT #ctxt ],
                   LKEYS [ --COMPKEY #ckey,
                           --OCOMPKEY #ockey ],
		   NONLOC #non-local ] ],
    SYNSEM adj_noun_synsem & 
	  [ LOCAL [ CAT.VAL [ COMPS #comps,
			      SPR < #spr, ... > ],
		    CONT [ HCONS #hcons,
                           MSG #msg ],
		    CTXT #ctxt ],
            LKEYS [ KEYREL #key & [ ARG2 #ahand ],
                    --COMPKEY #ckey,
                    --OCOMPKEY #ockey ],
	    NONLOC #non-local ],
    C-CONT.RELS <! #key !> ].

adj_noun_personal_lr := adj_noun_lr &
  [ DTR.SYNSEM.LKEYS.KEYREL adj_personal_rel,
    SYNSEM adj_noun_personal_synsem].

adj_noun_abstract_lr := adj_noun_lr &
  [ DTR.SYNSEM.LKEYS.KEYREL adj_abstract_rel,
    SYNSEM adj_noun_abstract_synsem].
|#

; Relate transitive predicative adjectives to their intransitive attributive
; counterparts

attr_adj_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM pred_adj_synsem &
	         [ LOCAL [ CAT [ HEAD [ MOD #mod,
                                        KEYS.KEY #key ],
				 VAL [ SUBJ #subj,
				       SPR #spr,
                                       COMPS *olist* ] ],
                           CTXT #ctxt ],
		   NONLOC #non-local ] ],
    SYNSEM basic_attr_adj_synsem &
	  [ LOCAL [ CAT [ HEAD [ MOD #mod,
                                 KEYS.KEY #key ],
			  VAL [ SUBJ #subj,
				SPR #spr ] ],
		    CTXT #ctxt ],
	    NONLOC #non-local ],
    C-CONT.RELS <! !> ].


;; Makes "admired" into an attributive adjective, as in "the admired hero"
;; DPF 22-Feb-01 - Added restriction of 'independent_rel' on --COMPKEY (and 
;; --OCOMPKEY) to prevent verb-particle verbs (with "selected_rel" complements)
;; from undergoing rule.
;; DPF 22-May-01 - But this did not generalize to blocking other unwanted
;; subcat variants, like S-comp-taking "checking".  So instead constrain
;; dtr's SYNSEM to be passive_or_unacc_subst, and require the --COMPKEY to be
;; no_rel.  This allows only intransitive (past-participle) verbs or passive 
;; transitive verbs to undergo this rule.
;; DPF 31-Jul-01 - Removed attr_adj_synsem from output since it didn't work.
;; What was I thinking?  Also removed MOD..SPR..KEY explicit_q_rel from
;; output, since this blocks "hired consultants arrive".  What was it for?
;; DPF 23-Sep-01 - Tempting to restrict this rule to only passives, since now 
;; handling pres-participles as nominal gerunds in noun-noun compounds.  (We
;; don't yet enable unaccusative participles as in "the fallen leaf".)  But as
;; noted above, what about two readings for "the hiring consultant" - one seems
;; to be n-n compound, the other an attrib adj, so maybe need both?  Block for
;; now.
;; DPF 25-Nov-01 - Changed SYNSEM.HEAD to be verb* rather than adj*, to allow
;; "The recently purchased chair arrived"
;; DPF 3-Jan-02 - Added hack unary length limit on RELS for input, to block 
;; application of rule to v-np-pp verbs like "send" (cf. 'Do you offer a 
;; printed catalog')
;; For now, allow only intransitive and transitive verb participles to appear
;; as attributive modifiers - block e.g. subj-equi variants to avoid spurious
;; ambiguity for 'the starting point'
;; DPF 14-dec-03 - Consider removing LPERIPH na, since it prevents NPs with
;; one of these guys from appearing in appositive constructions: "the singing 
;; bear Kim".  Not clear what work it does.  FIX.
;; DPF 27-jan-04 - Changed LPERIPH on mother from na to +, to enable these
;; as modifiers in compounds, as in "Fedex tracking number".  Can't remove the
;; constraint entirely (see above) since it serves to block unwanted
;; appositive analyses for examples like "Kim interviewed Sandy".
;; DPF 21-aug-04 - Added SPEC < > to prevent these from being modified by
;; posthead PP - always a dead-end attachment.
;; DPF 10-mar-05 - Re 25-Nov-01: Now allowing adverbs to modify adjectives as
;; well, so make output be HEAD adj, which also allows us now to coordinate
;; these as in "the admired and hated politicians" (didn't parse before).
;; DPF 28-mar-05 - Restored LPERIPH bool in order to prevent these inside
;; N-Adj-N compounds, since there is an alternative analysis of e.g.
;; 'company tracking number' where 'tracking number' is an N-N compound.

basic_attr_verb_part_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD verb &
                                      [ VFORM non_fin,
                                        PRD +,
                                        AUX -,
                                        KEYS.KEY #key ],
				 VAL [ SUBJ #subj,
                                       SPR #spr ] ],
                           CONT [ HOOK [ LTOP #ltop,
                                         INDEX #event &
                                              [ E [ TENSE no_tense,
                                                    ASPECT.PERF - ] ] ],
                                  RELS <! relation !>,
                                  HCONS #hcons,
                                  MSG #msg ],
                           CTXT #ctxt ],
                   NONLOC #non-local ] ],
    SYNSEM canonical_synsem &
	  [ LOCAL [ CAT [ HEAD adj &
                               [ MOD < synsem &
                                       [ LOCAL intersective_mod &
                                         [ CAT nbar_cat &
                                               [ HEAD.KEYS.KEY nom_nbar_rel ],
                                           CONJ cnil,
                                           AGR #ind ],
                                         --SIND #ind ] >,
                                 PRD -,
                                 KEYS.KEY #key ],
                          VAL [ SUBJ #subj &
                                   < unexpressed & [ --SIND #ind ] >,
                                SPR #spr,
                                COMPS < >,
                                SPEC < > ],
                          POSTHD -,
                          MC na ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #event,
                                  XARG #ind ],
                           HCONS #hcons,
                           MSG #msg ],
                    CTXT #ctxt ],
	    NONLOC #non-local,
            MODIFD.LPERIPH bool ],
    C-CONT.RELS <! !> ].

attr_verb_part_lr := basic_attr_verb_part_lr &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

attr_verb_part_tr_lr := basic_attr_verb_part_lr &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < unexpressed &
                                     [ LOCAL.CAT.HEAD n_or_p ] . *olist* > ].


;; The partitive construction rule introduces a new type of relation: 
;; part_of_rel, which contains the semantic information of the partitive.
;; The features of the relation, a subtype of nom_rel, were
;; - LBL, 
;; - ARG0, the index of the NP,
;; - SET, the handle of the PP complement, defining the set of which the head 
;;        determines a subset,
;; - NPREP,the index of the PP complement of the head, which is actually the
;;        index of the NP complement of that PP.
;; The idea is that there is a difference between, for example, "some books", 
;; and "some of the books". In the first case, "books" can refer to a subset
;; of the set of all the existing books, and "some" quantifies over the 
;; set of all existing books. In the second case, "some" refers to a subset of
;; the set of books defined by "the books": that set cannot refer to the 
;; universal set of all existing books. The relation "part_of_rel" tries to
;; capture that notion of subset of a certain set (defined by the context, or 
;; the determiner of the NP complement): the subset has an index 
;; (ARG0), and the defined set is referred to by "SET", which is the handle of
;; the prepositional phrase, and also the handle of the determiner of the 
;; prepositional complement.  We thus give partitives a complex lexical
;; semantics, including both the part_of_rel and the original quantifier
;; relation, with its usual attributes.

;; A problem which remains is to get the right agreement with the right head.
;; At the moment, the index of the head is the same as the index of the 
;; original determiner. As an example, "all" can be mass or plural, and is 
;; going to agree with a singular or a plural verb, whatever its complement is
;; ("all of the cake", "all of the students"). If we decide to have the index
;; of the construction being the index of the complement noun, what about 
;; "each" ? "Each of the boys" will agree with a plural only, when it should
;; agree with a singular. On the other hand, there is also the problem of 
;; "all of the oats are", plural when "all" is the mass determiner here: 
;; agreement is determined, here, by the plural form of the complement noun.

basic_part_constr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM part_det_synsem & 
	  [ LOCAL [ CAT [ HEAD.KEYS.KEY #key,
                          VAL.SPR #spr ],
                    CONT.HCONS #hcons ],
            LKEYS.KEYREL #relation,
	    NONLOC [ SLASH #slash,
                        QUE #que ] ] ],
   SYNSEM partitive_noun_synsem & 
     [ LOCAL [ CAT [ HEAD.KEYS.ALTKEY #key,
                     VAL.SPR #spr ],
               CONT.HCONS #hcons ],
       LKEYS [ KEYREL #keyrel,
               ALTKEYREL #relation ],
       NONLOC [ SLASH #slash,
                   QUE #que ] ],
   C-CONT [ RELS <! #keyrel !> ] ].

part_nocomp_constr := basic_part_constr &
 [ SYNSEM partitive_noun_nocomp_synsem &
          [ LOCAL [ CAT.VAL.COMPS #comps,
                    AGR.DIVISIBLE #div ] ],
   DTR.SYNSEM.LOCAL [ CAT.VAL.COMPS #comps,
                      AGR.DIVISIBLE #div ] ].

part_ppof_agr_constr := basic_part_constr &
 [ DTR.SYNSEM.LOCAL.CAT [ HEAD.KEYS.KEY explicit_quant_agr_q_rel,
                          VAL [ KCMP #kcomp,
                                COMPS #comps ] ],
   SYNSEM basic_partitive_noun_ppof_synsem &
        [ LOCAL [ CAT.VAL [ KCMP #kcomp & [ LOCAL.AGR.PNG.PN #pn ],
                            COMPS < #kcomp . #comps > ],
                  AGR.PNG.PN #pn ] ] ].
          
part_ppof_noagr_constr := basic_part_constr &
 [ DTR.SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY explicit_quant_or_udef_noagr_q_rel,
                            VAL [ KCMP #kcomp &
                                       [ LOCAL.CAT.HEAD.KEYS.ALTKEY #key ],
                                  COMPS #comps ] ],
                      AGR #agr ],
   SYNSEM basic_partitive_noun_ppof_synsem &
        [ LOCAL [ AGR #agr,
                  CAT [ HEAD.KEYS.KEY #key,
                        VAL [ KCMP #kcomp,
                              COMPS < #kcomp . #comps > ] ] ] ] ].

; NP-particle alternation (e.g. "look up the answer/look the answer up"
; Stamp canonical_synsem on NP of output to avoid spurious parse for extraction
; of the NP, as in "Which problem did Kim figure out?"

NP_particle_lr := lex_rule &
 [ STEM #orth,
   ALTS.NPPART +,
   DTR [ STEM #orth,
         SYNSEM generic_NP_particle_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          POSTHD #ph,
			  VAL [ SUBJ #subj,
                                COMPS < [ OPT #opt2,
                                          NONLOC #nloc2 ] .
                                        < [ OPT #opt1,
                                            LOCAL.CAT.HEAD.KEYS.KEY #ckey,
                                            NONLOC #nloc1 ] . #comps > > ],
                          MC #mc,
                          HC-LEX #hclex  ],
		    CONT #cont,
		    CTXT #ctxt ],
	    NONLOC #nonlocal,
            LKEYS #lkeys ] ],
   SYNSEM generic_particle_NP_verb &
          [ LOCAL [ CAT [ HEAD #head,
                          POSTHD #ph,
                          VAL [ SUBJ #subj,
                                COMPS < [ OPT #opt1,
                                          LOCAL.CAT.HEAD.KEYS.KEY #ckey,
                                          NONLOC #nloc1 ] . 
                                        < canonical_synsem & 
                                          [ OPT #opt2,
                                            NONLOC #nloc2 ] . #comps > > ],
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT #cont,
                    CTXT #ctxt ],
            NONLOC #nonlocal,
            LKEYS #lkeys ],
   C-CONT.RELS <! !> ].

; --OCOMPKEY is not the same for ditrans and to-trans.

dative_shift_lr := lex_rule_compos &
 [ STEM #orth,
   INFLECTD -,
   DTR #dtr & 
       [ STEM #orth,
         INFLECTD -,
         SYNSEM ditrans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          VAL.SUBJ #subj,
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ],
                           MSG #msg,
                           RELS #liszt,
                           HCONS #hcons ],
                    CONJ cnil,
                    CTXT #ctxt ],
            LKEYS [ KEYREL #key,
                    ALTKEYREL #altkey,
                    --COMPKEY #ckey ],
            NONLOC #nonlocal ] ],
   SYNSEM empty_to_trans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL [ SUBJ #subj,
				COMPS < [ OPT - ], [ OPT - ] > ],
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ],
                           MSG #msg,
			   RELS #liszt,
			   HCONS #hcons ],
                    CONJ cnil,
		    CTXT #ctxt ],
            LKEYS [ KEYREL #key,
                    ALTKEYREL #altkey,
                    --COMPKEY #ckey ],
	    NONLOC #nonlocal ],
   ARGS < #dtr >,
   C-CONT.RELS <! !>,
   POSSCL - ].

possessed_word_lexrule := 
  lex_rule_compos &
  [ POSSCL +,
    SYNSEM #synsem,
    DTR #dtr & [ SYNSEM #synsem ],
    ARGS < #dtr >,
    C-CONT.RELS <! !> ].

; Converts e.g. int-adj 'twenty' to minute-noun for 'twenty (minutes) to nine'
; Currently does not allow 'twenty-two to nine' - would need to append COMPS
; more carefully.

minute_prep_lr := lex_rule_super &
 [ STEM #orth,
   DTR #dtr & 
       [ STEM #orth,
         SYNSEM norm_num_synsem &
	  [ LOCAL [ CAT [ HEAD intadj2- &
                             [ MOD < [ LOCAL.CONT.HOOK.LTOP #arghand ] > ],
                          VAL.COMPS < > ],
                    CONT.HOOK.INDEX #minst,
                    CTXT #ctxt ],
            LKEYS.KEYREL #key & [ LBL #arghand ],
	    NONLOC #nonlocal ] ],
   SYNSEM minute_noun_synsem &
	  [ LOCAL [ CONT.RELS <! relation, relation, #key !>,
                    CTXT #ctxt ],
            LKEYS.KEYREL [ LBL #arghand,
                           ARG1 #minst ],
	    NONLOC #nonlocal ],
   ARGS < #dtr > ].


; For "Kim is happy enough with Sandy (to ...)"
enough_addition := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM 
           [ LOCAL [ CAT [ HEAD #head & [ KEYS.KEY independent_mod_rel ],
                           VAL [ SUBJ #subj,
                                 COMPS #comps & *substlist*,
                                 SPR #spr & 
                                      < synsem &
                                        [ LOCAL [ CAT.HEAD.KEYS.KEY
                                                             very_deg_rel,
                                                  CONT.HOOK #sphook ] ] > ] ],
                     CONT [ HOOK #hook,
                            HCONS #hcons ],
                     CTXT #ctxt ],
             NONLOC #nonloc ] ],
    SYNSEM [ LOCAL 
	    [ CAT 
	     [ HEAD #head,
               VAL [ SUBJ #subj,
		     COMPS *cons* &
			  < [ LOCAL local &
				    [ CAT [ HEAD adv &
                                                 [ MOD < >,
                                                   KEYS.KEY enough_deg_rel ],
                                            VAL.SPEC 
                                              < [ LOCAL.CONT.HOOK #hook ] > ],
                                      CONT.HOOK #sphook ],
                              LEX +,
			      OPT - ] . #comps >,
		     SPR #spr ] ],
             CONT [ HOOK #hook,
		    HCONS #hcons ],
	     CTXT #ctxt ],
	   NONLOC #nonloc ],
    C-CONT.RELS <! !> ].

