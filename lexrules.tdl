;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-1999
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  lexrules.tdl
;;;
;;;  Inflectional affixes and derivational lexical rules
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Inflectional affixes
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Verbal inflections

non_fin_verb := local & 
  [ STEMHEAD vstem,
    CAT.HEAD [ VOICE active,
	       TAM [ TENSE #tense,
		     ASPECT #aspect ] ],
    CONT.INDEX #index & [ E [ TENSE #tense,
			      ASPECT #aspect ] ],
    KEYS.KEY.EVENT #index ].

; Need to constrain MOD value for PRP verbs.  Also for passive participles.


;; Verbal affix for present and passive participles, which can modify N-bars
;; DPF (7-Apr-99) Removed POSTHEAD - since the head_complement rule now passes
;; up the value of POSTHEAD from the head-dtr, so we need to leave it unmarked
;; to get "managers interviewed by Abrams" on the passive-by reading, and also
;; to still get "the interviewed managers"

;; Present participles and passives are both marked as PRD +, to block e.g. 
;; "the destroyed by Sandy chair" or "the talking to Kim consultant", but then
;; to get these participles alone in attributive position, we need a 
;; generalization of the attributive-adjective lexical rule below.

verb_participle_affix := local &
  [ STEMHEAD vstem,
    CAT [ HEAD [ MOD < [ LOCAL intersective_mod &
			       [ CAT nbar_cat,
				 CONT.INDEX #nind ] ] >,
		 PRD + ],
	  VAL.SUBJ < [ LOCAL local & [ CONT.INDEX #nind ],
		       OPT - ] >,
	  HC-LEX - ],
    CONT [ TOP #hand,
	   INDEX #event ],
    KEYS.KEY [ HANDEL #hand,
	       EVENT #event ] ].

prp_verb := non_fin_verb & verb_participle_affix &
  [ CAT.HEAD [ VFORM prp,
	       TAM.ASPECT progr* ] ].

psp_verb := non_fin_verb & nomod_local &
  [ CAT.HEAD [ VFORM psp,
	       TAM.ASPECT nonprg,
	       PRD - ] ].

non_perf :< local.

; DPF 12-May-00 - bse_verb needs to have [ MOD nbar ] to enable coordination
; of imperative and declarative clauses, as in "Leave and I will follow you"

bse_verb := non_fin_verb & non_perf &
  [ CAT [ HEAD [ VFORM bse,
                 MOD < [ LOCAL intersective_mod &
			       [ CAT nbar_cat ] ] >,
		 PRD -,
		 TAM.ASPECT no_aspect* ],
          POSTHEAD +,
	  VAL.SUBJ < unexpressed &
                     [ OPT - ] > ] ].

; Since finite verbs can project relative clauses, we introduce [MOD < nbar >]
; here, and make sure that no other projections of finite verbs can be
; adjuncts, through constraints on the head-adjunct phrase type.

fin_verb := non_perf &
  [ STEMHEAD vstem,
    CAT [ HEAD [ PRD -,
                 VOICE active,
		 TAM [ TENSE #tense,
		       ASPECT #aspect ],
		 VFORM fin*,
		 MOD < [ LOCAL intersective_mod &
			       [ CAT nbar_cat ] ] > ],
	  POSTHEAD +,
	  VAL.SUBJ < synsem & [ LOCAL [ CAT nomp_cat_nom_min,
					CONJ cnil ],
				OPT - ] > ],
    CONT psoa & [ INDEX #event & [ E [ TENSE #tense,
				       ASPECT #aspect ] ] ],
    KEYS.KEY.EVENT #event ].

pres_verb := fin_verb & 
  [ CAT.HEAD.TAM [ TENSE present*,
		   ASPECT no_aspect*,
		   MOOD indicative* ] ].

past_verb := fin_verb & 
  [ CAT.HEAD.TAM [ TENSE past*,
		   ASPECT no_aspect*,
		   MOOD indicative* ] ].

subjunctive_verb := fin_verb & 
  [ CAT.HEAD.TAM.MOOD subjunctive ].

third_sg_fin_verb := pres_verb &
  [ AGR.PNG png & [ PN 3sg ] ].

non_third_sg_fin_verb := pres_verb &
  [ CAT.VAL.SUBJ < [ LOCAL local & [ CONT nom-obj ] ] >,
    AGR.PNG png & [ PN non3sg & strict_sort ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Nominal inflections

sing_noun := local &
  [ STEMHEAD countnstem,
    CONT.INDEX [ PNG png & [ PN 3sg*,
			     GEN neut* ],
		 DIVISIBLE - ] ]. 

mass_noun := local &
  [ STEMHEAD massnstem,
    CONT.INDEX [ PNG png & [ PN 3sg*,
			     GEN neut* ],
		 DIVISIBLE + ] ]. 

plur_noun := local &
  [ STEMHEAD countnstem,
    CONT.INDEX [ PNG png & [ PN 3pl* ],
		 DIVISIBLE + ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Adjectival inflections
;;
;;  May-96: Martina

pos_adj := local &
  [ STEMHEAD astem,
    CAT.VAL.SPR < [ LOCAL local &
				[ KEYS.KEY very_deg_rel ] ] > ].


er_comp_adj := local &
  [ STEMHEAD astem,
    CAT.VAL.SPR < [ LOCAL local &
				[ KEYS.KEY much_deg_rel ] ] > ].


est_super_adj := local &
  [ STEMHEAD astem,
    CAT.VAL.SPR < [ LOCAL local &
				[ KEYS.KEY def_rel ],
			  OPT - ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Place holder affix for -ly

-ly := local & [ CAT.HEAD no_head ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  (Non-inflectional) lexical rules
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; AAC - INFLECTED added so that the relationship
;;; between inflectional morphology and lexical rules
;;; which is hacked into PAGE can be represented declaratively
;;;
;;; lex_rule_infl turns uninflected things into inflected ones
;;; but otherwise does inheritance
;;; everything else requires inflected forms

#|
lex_rule_supermost := phrase_or_lexrule & word_or_lexrule &
  [ DTR sign &
	[ SYNSEM.LOCAL.CONT.LISZT [ LIST #middle,
				    LAST #last ] ],
    SYNSEM.LOCAL.CONT.LISZT [ LIST #first,
			      LAST #last ],
    C-CONT.LISZT [ LIST #first,
		   LAST #middle ] ].
|#

lex_rule_supermost := phrase_or_lexrule & word_or_lexrule &
  [ DTR sign ].

#|
lex_rule_compos := lex_rule_supermost &
  [ DTR.SYNSEM.LOCAL.CONT.LISZT [ LIST #middle,
				  LAST #last ],
    SYNSEM.LOCAL.CONT.LISZT [ LIST #first,
			      LAST #last ],
    C-CONT.LISZT [ LIST #first,
		   LAST #middle ] ].

|#
; DPF 14-Aug-99 - Reorder appending of LISZT from above since treatment of fragments
; looks for the first scope hole from left to right in LISZT, and above gives different
; results for "October first" and "the first of October".
lex_rule_compos := lex_rule_supermost &
  [ DTR.SYNSEM.LOCAL.CONT.LISZT [ LIST #first,
                                  LAST #middle ],
    SYNSEM.LOCAL.CONT.LISZT [ LIST #first,
			      LAST #last ],
    C-CONT.LISZT [ LIST #middle,
                   LAST #last ] ].

lex_rule_infl := lex_rule_compos &
  [ NEEDS-AFFIX bool,
    INFLECTED +,
    KEY-ARG #keyarg,   
    SYNSEM #synsem,
    ARGS < #dtr >,
    ROOT #root,
    DTR #dtr & [ INFLECTED -,
                 KEY-ARG #keyarg,   
                 SYNSEM #synsem,
                 ROOT #root ],
    C-CONT.LISZT <! !> ].

lex_rule_infl_affixed := lex_rule_infl.

#|

lex_rule_infl_no-affix := lex_rule_infl & 
  [ DTR non_affix_bearing ].

|#

; ERB (05-10-97) Now that sai stamps MESSAGE int_rel on its output, that
; default has to be taken out of lex_rule.  To avoid breaking anything else, I
; am making a new type lex_rule_super that is just like the current lex_rule
; except that it doesn't identify the messages, and then having lex_rule do
; that identification.

lex_rule_super := lex_rule_supermost &
  [ DTR word_or_lexrule &
        [ INFLECTED +,
          SYNSEM.LOCAL local &
		       [ CONJ cnil ] ],
    INFLECTED +,
    SYNSEM.LOCAL local &
	[ CONJ cnil ] ].

lex_rule_super_compos := lex_rule_super & lex_rule_compos.

lex_rule := lex_rule_super_compos &
  [ DTR #stem &
	[ SYNSEM.LOCAL [ CAT [ MC #mc,
			       HC-LEX #hclex ],
			 KEYS.MESSAGE #msg ] ],
    SYNSEM.LOCAL [ CAT [ MC #mc,
			 HC-LEX #hclex ],
		   KEYS.MESSAGE #msg ],
    ARGS < #stem > ].

;;
;;  Forms derived from inflected verbs
;;

; ERB (05-10-97) Before we had a special rule hcomp_yn_root for matrix polar
; questions.  Now, the unique head complement rule is taking over this job.
; To do this, we must put the int_rel onto the inverted auxiliaries (see also
; sai_synsem).  The original objection to this was that the inverted
; auxiliaries are used for things other than matrix questions (i.e., negative
; inversion).  However, a) we don't currently have an analysis of negative
; inversion, and b) it's not clear that they are the same auxiliaries.  The
; most obvious test -- 1st person aren't -- is not available since the
; contracted auxiliaries are in general disallowed in negative inverstion
; (polarity effect?).
;
; At the moment this is allowing "Will who sleep?" and "Will Kim see who?"
; (actually two parses of the latter).  This is fine, except that this is not
; producing the apropriate semantics.  In fact, all ynq (matrix and
; subordinate) are not currently specified for PARAMS.  I think this will be
; easier to fix once we have a) lexical threading and b) an implementation of
; the analysis of echo questions, so I am leaving it for later.
 
; DPF (10-Jan-99) Added SUBJ value identified with dtr's SPR value (usually
; < anti_synsem > which never unifies with real synsem), in order to allow 
; adjunct extraction to still apply to inverted sentences such as "When is 
; Kim happy" where "is Kim happy" is built by two applications of the head_comp
; rule.  By identifying SUBJ with dtr's SPR, we can maintain lexical control
; over modifiability, in particular blocking spurious modification of 
; auxiliary "do", both in noninverted and inverted clauses.
; DPF 22-Apr-00 - Added reentrancy for VFORM on DTR and mother - don't know
; why this was omitted before.  It's needed to block spurious parse for e.g. 
; "Could you sleep please"

sai := lex_rule_super_compos &
  [ STEM #orth,
    DTR #stem &
	 [ STEM #orth,
	   SYNSEM [ LOCAL [ CAT [ HEAD verb &
				       [ INV +,
					 VFORM fin* & #vform,
                                         TAM #tam,
					 VOICE #voice ],
				  VAL [ SUBJ < #subj & canonical_synsem >,
					COMPS #comps,
					SPR #spr,
					--KEYCOMP #keycomp ] ],
			    CONT [ TOP #dtrhand,
				   INDEX #ind,
				   H-CONS #hcons ],
                            AGR #agr,
			    KEYS #keys ],
		    NON-LOCAL #nonloc ] ],
    SYNSEM sai_synsem &
	 [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				TAM #tam,
                                VOICE #voice ],
                         VAL [ COMPS < #subj & [ OPT - ]
				       . #comps >,
			       SPR #spr,
			       SUBJ < anti_synsem >,
			       --KEYCOMP #keycomp ] ],
		   CONT [ TOP #dtrhand,
			  INDEX #ind,
			  H-CONS #hcons ],
                   AGR #agr,
		   KEYS #keys &
		       [ MESSAGE <! !> ] ],
	   NON-LOCAL #nonloc ],
    ARGS < #stem >,
    C-CONT.LISZT <! !> ].

tag := lex_rule_super &
  [ STEM #orth,
    DTR #stem &
	[ STEM #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD.TAM [ TENSE #tense,
					  MOOD ind_or_mod_subj & strict_sort ],
			       VAL.COMPS < #subj, [ LOCAL.CAT.HEAD subst ], ... > ],
			 KEYS.KEY #key ],
		 NON-LOCAL #nonloc & 
		       [ SLASH 0-dlist,
			 REL 0-dlist,
			 QUE 0-dlist ] ] ],
    SYNSEM tag_synsem &
	 [ LOCAL [ CAT [ HEAD.TAM [ TENSE #tense ],
			 VAL.COMPS.FIRST #subj ],
		   CONT.LISZT #cliszt,
		   KEYS [ KEY #key,
			  MESSAGE <! #msg !> ] ],
	   NON-LOCAL #nonloc ],
    ARGS < #stem >,
    C-CONT.LISZT #cliszt & <! #msg !> ].


; DPF 31-Jul-99 - Removed [INV -] from DTR, since it blocked entry for
; "Is that also important?"

adv_addition := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM 
               [ LOCAL [ STEMHEAD vstem,
			 CAT [ HEAD #head & verb &
				    [ AUX +,
				      VFORM fin* ],
			       VAL [ SUBJ #subj & < canonical_synsem >,
				     COMPS #comps & *substlist*,
				     SPR #spr ],
			       POSTHEAD #ph ],
			 CONT [ TOP #vtop,
				INDEX #vindex,
				H-CONS #hcons ],
			 CTXT #ctxt,
			 KEYS #keys ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM aux_verb &
	 [ LOCAL 
	   [ CAT 
	     [ HEAD #head,
	       VAL [ SUBJ #subj,
		     COMPS *cons* &
			  < [ LOCAL local &
				    [ CAT.HEAD basic_lexadv,
				      CONT [ TOP #advtop,
					     H-CONS <! [ OUTSCPD #vtop ] !> ],
				      KEYS.MESSAGE 0-dlist ],
			      OPT - ] . #comps >,
		     SPR #spr ],
	       POSTHEAD #ph ],
	     CONT [ TOP #advtop,
		    INDEX #vindex,
		    H-CONS #hcons ],
	     CTXT #ctxt,
	     KEYS #keys ],
	   NON-LOCAL #nonloc ],
    C-CONT.LISZT <! !> ].

;; VP Ellipsis
;; We can't let this rule apply to the infinitival "to", since we would then
;; have no way of blocking the NP "the book to", where "to" first underwent
;; this rule, then the subject-extraction rule (needed for ordinary infinitival
;; relatives), and then the usual infinitival relative rule.  So instead we
;; create a separate lexical entry for the elided form of "to", and make it
;; MOD < >.

;; DPF 26-Nov-99 - In order to make sure that the VIT LABEL of expletive 'there'
;; subjects gets bound by elliptical verb, we split the rule for VP ellipsis
;; into two, one for referential subjects and one for expletives.  Don't know
;; if this is motivated beyond the LABEL requirements of Verbmobil.
;; AAC - killed LABEL

vp_ellipsis := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM 
	   [ LOCAL [ CAT [ HEAD #head & verb &
				[ AUX +,
				  INV - ],
			   POSTHEAD #ph,
			   VAL [ SUBJ #subj,
				 SPR #spr,
				 COMPS < unexpressed &
					 [ LOCAL [ CAT.HEAD subst,
						   CONT.TOP #chand,
						   KEYS.KEY #altkey ] ] > ] ],
		     CONT [ TOP #hand,
			    INDEX #ind,
			    H-CONS #hcons ],
		     CTXT #ctxt,
		     KEYS.KEY #key ],
	     NON-LOCAL #nonloc ] ],
    SYNSEM verb_synsem &
	 [ LOCAL [ CAT [ HEAD #head,
			 POSTHEAD #ph,
			 VAL [ SUBJ #subj,
			       SPR #spr,
			       COMPS < > ] ],
		   CONT [ TOP #hand,
			  INDEX #ind,
			  H-CONS #hcons ],
		   KEYS [ KEY #key,
			  ALTKEY #altkey & ellipsis_rel &
				       [ HANDEL #chand ] ],
		   CTXT #ctxt ],
	   NON-LOCAL #nonloc ],
    C-CONT.LISZT <! #altkey !> ].

vp_ellipsis_ref := vp_ellipsis &
  [ DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.INDEX ref-ind & #sind ] >,
			       COMPS < [ LOCAL.CONT.INDEX #cind ] > ],
    SYNSEM verb_synsem &
	 [ LOCAL.KEYS.ALTKEY [ EVENT #cind,
			       ROLE #sind ] ] ].

vp_ellipsis_expl := vp_ellipsis &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL [ CONT.INDEX there-ind,
					      KEYS.KEY no_rel ] ] >,
    SYNSEM verb_synsem &
	 [ LOCAL [ CONT.INDEX #event,
		   KEYS [ ALTKEY [ EVENT #event ] ] ] ] ].

;; Need to work on generalizing the semantics - since we derive this entry
;; from the past participle, we have to discard the tense information from
;; the input - not clear yet how to do this in general.  For now we assume
;; that transitive verbs introduce a single relation, bound to the KEY attrib.

; This incorrectly orders the by_pp before all remaining comps - wrong for
; double-NP verbs, and incomplete for verbs with other oblique arguments,
; since this allows only one order.  But this latter is a general problem.

passive_verb := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM trans_subst & verb_synsem &
               [ LOCAL [ STEMHEAD vstem,
                         CAT [ HEAD.VFORM psp_or_psp_irreg,
			       VAL [ SUBJ < [ LOCAL local &
						    [ CONT.INDEX #subjind ], 
						  NON-LOCAL #snonloc ] >,
					 SPR #spr,
					 COMPS [ FIRST [ LOCAL local &
							[ CONT #objcont ],
							 NON-LOCAL #ononloc ],
						 REST #comps ] ] ],
			 CONT [ TOP #hand,
				H-CONS #hcons ],
			 KEYS [ KEY #key,
				--COMPKEY #ckey,
				--OCOMPKEY #ockey ],
			 CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM lex_synsem &
	 [ LOCAL verb_participle_affix &
		 [ CAT [ HEAD verb* & [ AUX -,
					VFORM pas,
					VOICE passive ],
			 VAL [ SUBJ < synsem &
					[ LOCAL [ CAT nomp_cat_min,
						  CONJ cnil,
						  CONT #objcont ],
					  NON-LOCAL #ononloc ] >,
				   SPR #spr,
				   COMPS < synsem & 
					   [ LOCAL local &
					     [ CAT [ HEAD prep,
						     VAL [ SUBJ < >,
							   SPR *olist*,
							   COMPS *olist* ] ],
					       CONT.TOP #hand,
					       KEYS.KEY _by_pass_rel &
						   [ ARG3 #subjind ] ],
					     NON-LOCAL #snonloc,
					     OPT + ]
					   . #comps > ] ],
		   CONT [ TOP #hand,
			  H-CONS #hcons ],
		   KEYS [ KEY #key,
			  --COMPKEY #ckey,
			  --OCOMPKEY #ockey ],
		   CTXT #ctxt ],
	   NON-LOCAL #nonloc ],
    C-CONT.LISZT <! !> ].


#|
; it-extraposition

it-extraposition := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM extraposable_synsem &
	       [ LOCAL [ CAT [ HEAD #head,
			       VAL [ SUBJ < [ LOCAL local &
						[ CONT.INDEX #subjind ] ] >,
					 COMPS #comps ] ] ],
			 CONT #cont,
			 CTXT #ctxt,
		         KEYS #keys ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM expl_it_subj_synsem &
	 [ LOCAL [ CAT [ VAL [ SUBJ < synsem &
					[ LOCAL [ CAT nomp_cat_min,
						  CONJ cnil,
						  CONT.INDEX it-ind ] ] >,
				   COMPS < synsem & 
					   [ LOCAL [ CAT s_cat_fin_v_c,
						     CONJ cnil,
						     CONT.INDEX #subjind ],
					     OPT - ]
					   . #comps > ] ],
		   CONT #cont,
		   CTXT #ctxt,
		   KEYS #keys ],
	   NON-LOCAL #nonloc ],
   C-CONT.LISZT <! !>  ].
|#

;; This has the same problem as the passive lexical rule.  Since we derive the
;; gerund from the present particple, we somehow have to filter out the
;; progressive relation.

;; DPF 27-May-99 - We block extraction from gerunds, at least for efficiency.
;; DPF 02-June-99 - We also block the auxiliary verbs "being, having, doing",
;; to avoid identity copula analyses for "Kim is being good" or "Kim is having
;; hired Sandy".
;; DPF 31-Jul-99 - Make gerund_rel like nominalize_rel in identifying its
;; handle with the verb_rel's, rather than taking the verb's handle as arg.

verbal_gerund := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ STEMHEAD vstem,
                         CAT [ HEAD [ VFORM prp,
				      AUX - ],
			       VAL.COMPS #comps ],
			 CONT [ TOP #hand,
				H-CONS #hcons ],
			 KEYS [ --COMPKEY #ckey,
				--OCOMPKEY #ockey ],
			 CTXT #ctxt ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM nonpro_onearg_synsem &
	   [ LOCAL [ AGR #ind,
		     CAT [ HEAD gerund* &
				[ MOD < >,
				  PRD - ],
			   VAL [ SUBJ < [ LOCAL.CAT.HEAD noun* ] >,
				 SPR < [ OPT - ] >,
				 COMPS #comps ] ],
		     CONT [ TOP #hand,
			    INDEX #ind &
				   [ PNG png & [ PN 3sg*,
						 GEN neut* ],
				     DIVISIBLE + ],
			    H-CONS #hcons ],
		     KEYS [ KEY gerund_rel & #key &
				[ HANDEL #hand,
				  INST #ind ],
			    --COMPKEY #ckey,
			    --OCOMPKEY #ockey ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc & [ SLASH 0-dlist ] ],
    C-CONT.LISZT <! #key !> ].

; DPF 27-May-99 - POSS-ING gerunds are given a non-empty SUBJ value so they
; can be modified by ordinary PPs and non-sentential adverbs, but the synsem
; value is the hack 'anti_synsem' which is also used for the SPR value of verbs,
; for similar reasons.

#|
poss_ing := verbal_gerund &
  [ DTR.SYNSEM [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.INDEX #subj,
					NON-LOCAL #snonloc ] >,
		 NON-LOCAL.SLASH 0-dlist ],
    SYNSEM.LOCAL [ CAT.VAL [ SUBJ < anti_synsem >,
			     SPR < [ LOCAL local &
					   [ CAT [ HEAD det & 
						    [ POSS + ],
						   VAL [ SUBJ < >,
							 COMPS *olist* ] ],
					     KEYS.--COMPKEY [ POSSD #ind,
							      POSSR #subj ] ],
				     NON-LOCAL #snonloc ] > ],
		   CONT.INDEX #ind ] ].

acc_ing := verbal_gerund &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem_min & [ LOCAL.CONT #subj ] >,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < synsem &
				  [ LOCAL [ CAT nomp_cat_acc_min,
					    CONJ cnil,
					    CONT #subj ] ] >,
			   SPR < anti_synsem > ] ].
|#

;; DPF 27-May-99 - Try combining the two verbal gerund rules into one.

vger_ing := verbal_gerund &
  [ DTR.SYNSEM [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.INDEX #subj,
					NON-LOCAL #snonloc ] >,
		 NON-LOCAL.SLASH 0-dlist ],
    SYNSEM.LOCAL [ CAT.VAL [ SUBJ < synsem &
				    [ LOCAL [ CAT nomp_cat_acc_min,
					      CONJ cnil,
					      CONT.INDEX #subj ] ] >,
			     SPR < [ LOCAL local &
					   [ CAT [ HEAD det & 
						    [ POSS + ],
						   VAL [ SUBJ < >,
							 SPR *olist*,
							 COMPS *olist* ] ],
					     KEYS.--COMPKEY [ POSSD #ind,
							      POSSR #subj ] ],
				     NON-LOCAL #snonloc ] > ],
		   CONT.INDEX #ind ] ].

;; DPF (12-Jul-98) In order to allow prenominal adjectives for nominal gerunds,
;; as in "regular tasting of wine is healthy", we have to treat the specifier
;; of the gerund as obligatory, since prenominal adjectives distinguish proper
;; from common nouns based on the optionality (or absence) of the specifier.
;; So these gerunds have to undergo the bare plural rule if no determiner is
;; present, which means they also have to be DIVISIBLE +.

nominal_gerund := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ CAT [ HEAD [ VFORM prp,
				      AUX - ],
			       VAL.SUBJ < [ LOCAL local &
						  [ CONT.INDEX #subj ],
					    NON-LOCAL #snonloc ] > ],
			 CONT [ TOP #hand,
				H-CONS #hcons ],
			 KEYS [ KEY.HANDEL #hand,
				--COMPKEY #ckey,
				--OCOMPKEY #ockey ],
			 CTXT #ctxt ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM nonpro_nomod_synsem &
	   [ LOCAL 
	     [ AGR #ind,
	       CAT 
	       [ HEAD noun*,
		 VAL [ SUBJ < >,
		       SPR < [ LOCAL local &
				     [ CAT [ HEAD det,
					     VAL [ SUBJ < >,
						   SPR *olist*,
						   COMPS *olist* ] ],
				       CONT.INDEX #ind,
				       KEYS.ALTKEY poss_rel &
					   [ POSSR #subj ] ],
			       NON-LOCAL #snonloc,
			       OPT - ] > ] ],
	       CONT [ TOP #hand,
		      INDEX #ind & [ PNG png & [ PN 3sg*,
						 GEN neut* ],
				     DIVISIBLE + ],
		      H-CONS #hcons ],
	       KEYS [ KEY #key & nominalize_rel & 
			    [ HANDEL #hand,
			      INST #ind ],
		      --COMPKEY #ckey,
		      --OCOMPKEY #ockey ],
	       CTXT #ctxt ],
	     NON-LOCAL #nonloc ],
    C-CONT.LISZT <! #key !> ].

intrans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM intrans_subst & 
	       [ LOCAL.CAT.VAL.COMPS #comps ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #comps ].


;; This is too restrictive.  It only forms nominal gerunds from strictly
;; transitive verbs.  So, it doesn't give you "Kim's putting of food on the
;; table" or "Kim's warning of Sandy that it would rain" or "Kim's giving of
;; raisins to the ants".  
;;  To avoid ambiguity with the intransitive nominal gerund, we make the PP
;; obligatory.
trans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM trans_subst & 
	       [ LOCAL.CAT.VAL.COMPS < [ LOCAL local &
						   [ CONT.INDEX #index ] ] > ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < synsem &
				 [ LOCAL [ CAT pp_cat,
					   CONJ cnil,
					   KEYS.KEY _of_rel & 
							[ ARG3 #index ],
					   CONT.INDEX #index ],
				   OPT - ] > ].

date_det_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ STEMHEAD nstem,
                           CAT.VAL.COMPS < [ OPT + ] >,
			   CONT.H-CONS [ LIST #hclist,
                                         LAST #hclast ],
			   KEYS [ KEY #altkey,
				  --COMPKEY #ckey,
				  --OCOMPKEY #ockey ],
			   CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD det,
			   VAL [ SUBJ < >,
				 SPR < >,
				 COMPS < >,
				 SPEC < [ LOCAL.CONT [ TOP #ntop,
						       INDEX #ind ] ] > ] ],
		     CONT [ INDEX #ind,
			    H-CONS [ LIST < qeq &
                                            [ SC-ARG #rhand,
                                              OUTSCPD #ntop ] . #hclist >,
                                     LAST #hclast ] ],
		     KEYS [ KEY #key & def_rel &
				      [ BV #ind,
					RESTR #rhand ],
			    ALTKEY #altkey & [ INST #spind ],
			    --COMPKEY #ckey,
			    --OCOMPKEY #ockey ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc,
	     MODIFIED hasmod ],
    C-CONT.LISZT <! #key,
                    _of_rel & [ HANDEL #ntop,
                                ARG #ind,
                                ARG3 #spind ] !> ].

; "October": NP => Determiner
;          "(in) October" => "October first"

month_det_lr := date_det_lr &
  [ DTR.SYNSEM.LOCAL.KEYS.KEY mofy_rel,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.KEYS.KEY dofm_rel ] > ].

; "Tuesday": NP => Determiner
;          "(on) Tuesday" => "Tuesday morning"

weekday_det_lr := date_det_lr &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.KEYS.KEY day_part_rel ] >,
    DTR.SYNSEM.LOCAL.KEYS.KEY dofw_rel ].

;; "January" ==> "every January"
;; DPF (13-Jan-99) Note we're overgenerating the first of the following examples:
;; "*Let's meet January" but "Let's meet every/next/some January"

; DPF 26-Jul-99 - Made rule change KEY from non-modable to modable, to get
; contrast between "We arrived every June" and "*We arrived June"

month_unsat_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ STEMHEAD nstem,
                           CAT [ HEAD noun* & #head,
				 VAL [ SPR < >,
				       COMPS < [ LOCAL.CAT.HEAD noun ] > ] ],
			   CONT [ TOP #top,
				  H-CONS #hcons ],
			   KEYS.KEY mofy_rel &
				    [ INST #index,
                                      MONTH #month ],
			   CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD #head,
			   VAL [ SUBJ < >,
				 SPR < synsem &
				       [ LOCAL local &
					       [ CAT [ HEAD det,
						       VAL [ SUBJ < >,
							     SPR *olist*,
							     COMPS *olist* ] ],
						 KEYS.KEY [ BV #index,
							    RESTR #top ] ],
					 OPT - ]>,
				 COMPS < > ] ],
		     CONT [ TOP #top,
			    INDEX #index & [ DIVISIBLE - ],
			    H-CONS #hcons ],
		     AGR #index,
		     KEYS.KEY mofy_mod_rel &
			 [ HANDEL #top,
			   INST #index,
			   MONTH #month ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc ],
    C-CONT.LISZT <! !> ].



adj_noun_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ STEMHEAD astem,
                           CAT [ HEAD.PRD -,
				 VAL [ COMPS #comps,
				       SPR < #spr > ] ],
			   CONT.H-CONS #hcons,
			   KEYS [ KEY.HANDEL #ahand,
				  --COMPKEY #ckey,
				  --OCOMPKEY #ockey,
				  MESSAGE #msg ],
			   CTXT #ctxt ],
		   NON-LOCAL #non-local ] ],
    SYNSEM adj_noun_synsem & 
	  [ LOCAL [ CAT.VAL [ COMPS #comps,
			      SPR < #spr, ... > ],
		    CONT.H-CONS #hcons,
		    KEYS [ KEY #key & [ ARG3 #ahand ],
			   --COMPKEY #ckey,
			   --OCOMPKEY #ockey,
			   MESSAGE #msg ],
		    CTXT #ctxt ],
	    NON-LOCAL #non-local ],
    C-CONT.LISZT <! #key !> ].

adj_noun_personal_lr := adj_noun_lr &
  [ DTR.SYNSEM.LOCAL.KEYS.KEY adj_personal_rel,
    SYNSEM adj_noun_personal_synsem].

adj_noun_abstract_lr := adj_noun_lr &
  [ DTR.SYNSEM.LOCAL.KEYS.KEY adj_abstract_rel,
    SYNSEM adj_noun_abstract_synsem].

; Relate transitive predicative adjectives to their intransitive attributive
; counterparts

attr_adj_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM pred_adj_synsem &
	         [ LOCAL [ CAT [ HEAD.MOD #mod,
				 VAL [ SUBJ #subj,
				       SPR #spr ] ],
			   CONT #cont,
			   CTXT #ctxt,
			   KEYS #keys ],
		   NON-LOCAL #non-local ] ],
    SYNSEM attr_adj_synsem &
	  [ LOCAL [ CAT [ HEAD.MOD #mod,
			  VAL [ SUBJ #subj,
				SPR #spr ] ],
		    CONT #cont,
		    CTXT #ctxt,
		    KEYS #keys ],
	    NON-LOCAL #non-local ],
    C-CONT.LISZT <! !> ].


;; The partitive construction rule introduces a new type of relation: 
;; part_of_rel, which contains the semantic information of the partitive.
;; The features of the relation, a subtype of nom_rel, are
;; - HANDEL, 
;; - INST, the index of the NP,
;; - SET, the handle of the PP complement, defining the set of which the head 
;;        determines a subset,
;; - NPREP,the index of the PP complement of the head, which is actually the
;;        index of the NP complement of that PP.
;; The idea is that there is a difference between, for example, "some books", 
;; and "some of the books". In the first case, "books" can refer to a subset
;; of the set of all the existing books, and "some" quantifies over the 
;; set of all existing books. In the second case, "some" refers to a subset of
;; the set of books defined by "the books": that set cannot refer to the 
;; universal set of all existing books. The relation "part_of_rel" tries to
;; capture that notion of subset of a certain set (defined by the context, or 
;; the determiner of the NP complement): the subset has an index 
;; (INST), and the defined set is referred to by "SET", which is the handle of
;; the prepositional phrase, and also the handle of the determiner of the 
;; prepositional complement.  We thus give partitives a complex lexical
;; semantics, including both the part_of_rel and the original quantifier
;; relation, with its usual attributes.

;; A problem which remains is to get the right agreement with the right head.
;; At the moment, the index of the head is the same as the index of the 
;; original determiner. As an example, "all" can be mass or plural, and is 
;; going to agree with a singular or a plural verb, whatever its complement is
;; ("all of the cake", "all of the students"). If we decide to have the index
;; of the construction being the index of the complement noun, what about 
;; "each" ? "Each of the boys" will agree with a plural only, when it should
;; agree with a singular. On the other hand, there is also the problem of 
;; "all of the oats are", plural when "all" is the mass determiner here: 
;; agreement is determined, here, by the plural form of the complement noun.

part_constr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM part_det_synsem & 
	  [ LOCAL.KEYS.KEY #relation,
	    NON-LOCAL #nonlocal ] ],
   SYNSEM partitive_noun_synsem & 
     [ LOCAL.KEYS [ KEY #key,
                    ALTKEY #relation ],
       NON-LOCAL #nonlocal ],
   C-CONT [ LISZT <! #key !> ] ].


; NP-particle alternation (e.g. "look up the answer/look the answer up"
; Stamp canonical_synsem on NP of output, to avoid spurious parse for extraction
; of the NP, as in "Which problem did Kim figure out?"

NP_particle_lr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM particle_NP_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          POSTHEAD #ph,
			  VAL [ SUBJ #subj,
				    COMPS < [ OPT #opt1 ], [ OPT #opt2 ] > ] ],
		    CONT #cont,
		    CTXT #ctxt,
		    KEYS #keys ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM NP_particle_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          POSTHEAD #ph,
			  VAL [ SUBJ #subj,
				    COMPS < canonical_synsem & [ OPT #opt2 ], 
					    [ OPT #opt1 ] > ] ],
		    CONT #cont,
		    CTXT #ctxt,
		    KEYS #keys ],
	    NON-LOCAL #nonlocal ],
   C-CONT.LISZT <! !> ].

; --OCOMPKEY is not the same for ditrans and to-trans.

dative_shift_lr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM ditrans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL.SUBJ #subj ],
		    CONT [ TOP #top,
			   INDEX #ind,
			   LISZT #liszt,
			   H-CONS #hcons ],
		    KEYS [ KEY #key,
			   ALTKEY #altkey,
			   --COMPKEY #ckey ],
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM to_trans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL [ SUBJ #subj,
				COMPS < [ OPT - ], [ OPT - ] > ] ],
		    CONT [ TOP #top,
			   INDEX #ind,
			   LISZT #liszt,
			   H-CONS #hcons ],
		    KEYS [ KEY #key,
			   ALTKEY #altkey,
			   --COMPKEY #ckey ],
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ],
   C-CONT.LISZT <! !> ].

;;
;; Derivational rules 
;;

#|
agent_nom_rel := reg_nom_rel & arg_rel.

; This lexical rule should be applied by hand, e.g.: 
;
; :leval (apply-lexical-rule 'simple_agent_nominal 'walk1 "walker").
;
; Also, this type ought to inherit from the type intr_noun_word, but that type
; assumes that all common nouns have a singleton LISZT. 

simple_agent_nominal := lex_rule & norm_word & 
  [ DTR.SYNSEM [ LOCAL [ STEMHEAD vstem,
                         CAT [ HEAD [ AUX -*,
				      INV -,
				      VFORM bse ],
			       VAL.SUBJ < [ LOCAL local &
						  [ CONT.INDEX #sindex ] ] ] >,
			 CONT.TOP #vhand ] ],
    SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.KEYS.KEY quant_rel ] >,
		     CONT.INDEX #sindex,
		     KEYS.KEY agent_nom_rel & #key &
				 [ ARG #vhand ] ] ],
    C-CONT.LISZT <! #key !> ].

|#


