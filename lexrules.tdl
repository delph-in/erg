;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-1999
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  lexrules.tdl
;;;
;;;  Inflectional affixes and derivational lexical rules
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Inflectional affixes
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Verbal inflections

non_fin_verb := local & 
  [ STEMHEAD vstem,
    CAT.HEAD [ VOICE active,
	       TAM [ TENSE #tense,
		     ASPECT #aspect ] ],
    CONT.HOOK.INDEX #index & [ E [ TENSE #tense,
                                   ASPECT #aspect ] ],
    KEYS.KEY.ARG0 #index ].

; Need to constrain MOD value for PRP verbs.  Also for passive participles.


;; Verbal affix for present and passive participles, which can modify N-bars
;; DPF (7-Apr-99) Removed POSTHEAD - since the head_complement rule now passes
;; up the value of POSTHEAD from the head-dtr, so we need to leave it unmarked
;; to get "managers interviewed by Abrams" on the passive-by reading, and also
;; to still get "the interviewed managers"

;; Present participles and passives are both marked as PRD +, to block e.g. 
;; "the destroyed by Sandy chair" or "the talking to Kim consultant", but then
;; to get these participles alone in attributive position, we need a 
;; generalization of the attributive-adjective lexical rule below.
;; DPF 19-Feb-01 - To avoid massive unwanted ambiguity as in "Kim is sleeping"
;; restrict the MOD value to [AUX -].
;; DPF 24-Mar-01 - Added SUBJ..SLASH 0-dlist to avoid spurious gaps.
;; DPF 18-Aug-01 - Removed [SUBJ.OPT -] to allow participle phrases without
;; subjects to be no-copula clauses, as in "arriving tomorrow".
;; DPF 24-Sep-01 - Added [MOD..TENSE real_tense as hack to block participles
;; from modifying nocop VPs, as in "partial clearing" - works since nouns have
;; underspecified TAM.

verb_participle_affix := local &
  [ STEMHEAD vstem,
    CAT [ HEAD [ MOD < [ LOCAL intersective_mod &
			       [ CAT n_or_v_cat & 
                                     [ HEAD [ AUX -,
                                              TAM.TENSE real_tense ] ],
                                 AGR #agr ] ] >,
		 PRD + ],
	  VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #agr,
                       NON-LOCAL.SLASH 0-dlist ] >,
	  HC-LEX - ],
    CONT.HOOK [ LTOP #hand,
                INDEX #event ],
    AGR #agr,
    KEYS.KEY [ LBL #hand,
	       ARG0 #event ] ].

prp_verb := non_fin_verb & verb_participle_affix &
  [ CAT.HEAD [ VFORM prp,
	       TAM.ASPECT progr* ] ].

; DPF 27-May-01 - Removed [ASPECT perf*] since this form is also used for
; passives, and since the auxiliary "have" already imposes ASPECT perf* on the
; relevant event.
psp_verb := non_fin_verb & nomod_local &
  [ CAT [ HEAD [ VFORM psp,
		 PRD - ],
	  VAL.SUBJ < [ OPT - ] > ] ].

non_perf :< local.

; DPF 12-May-00 - bse_verb needs to have [ MOD nbar ] to enable coordination
; of imperative and declarative clauses, as in "Leave and I will follow you"
; DPF 17-Oct-01 - Made ASPECT be no_aspect rather than no_aspect* in order to
; let K2Y distinguish true base-VPs from participles.

bse_verb := non_fin_verb & non_perf &
  [ CAT [ HEAD [ VFORM bse,
                 MOD < [ LOCAL intersective_mod &
			       [ CAT nbar_cat ] ] >,
		 PRD -,
		 TAM.ASPECT no_aspect* ],
          POSTHEAD +,
	  VAL.SUBJ < unexpressed & [ OPT - ] > ] ].

; Since finite verbs can project relative clauses, we introduce [MOD < nbar >]
; here, and make sure that no other projections of finite verbs can be
; adjuncts, through constraints on the head-adjunct phrase type.
; DPF 4-Mar-01 - Removed [KEYS.MESSAGE 0-dlist] from SUBJ, to allow e.g.
; "me hiring you bothered him"

basic_fin_verb := non_perf &
  [ STEMHEAD vstem,
    CAT [ HEAD [ PRD -,
                 VOICE active,
		 TAM [ TENSE #tense,
		       ASPECT #aspect ],
		 VFORM fin*,
		 MOD < [ LOCAL intersective_mod &
			       [ CAT nbar_cat ] ] > ],
	  POSTHEAD +,
	  VAL.SUBJ < synsem & [ LOCAL [ CAT nomp_cat_nom_min,
					CONJ cnil ] ] > ],
    CONT psoa & [ HOOK.INDEX #event & [ E [ TENSE #tense,
				       ASPECT #aspect ] ] ],
    KEYS.KEY.ARG0 #event ].

fin_verb := basic_fin_verb & 
  [ CAT.VAL.SUBJ < [ OPT - ] > ].

pres_verb := fin_verb & 
  [ CAT.HEAD.TAM ind_or_mod_subj_tam &
                 [ TENSE present*,
		   ASPECT no_aspect*,
		   MOOD indicative* ] ].

past_or_subj_verb := fin_verb &
  [ CAT.HEAD.TAM past_or_subj_tam ].

third_sg_fin_verb := pres_verb &
  [ AGR.PNG png & [ PN 3sg ] ].

non_third_sg_fin_verb := pres_verb &
  [ CAT.VAL.SUBJ < [ LOCAL local & [ CONT nom-obj ] ] >,
    AGR.PNG png & [ PN non3sg & strict_sort ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Nominal inflections

sing_noun := local &
  [ STEMHEAD countnstem,
    CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3sg,
                                DIVISIBLE - ] ] >,
    CONT.HOOK.INDEX [ PNG png & [ PN 3sg* ],
                      DIVISIBLE -* ] ]. 

mass_noun := local &
  [ STEMHEAD massnstem,
    CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3sg,
                                DIVISIBLE + ] ] >,
    CONT.HOOK.INDEX [ PNG png & [ PN 3sg*,
                                  GEN neut* ],
		      DIVISIBLE +* ] ]. 

mass_count_noun := local &
  [ STEMHEAD masscountnstem,
    CAT.VAL.SPR < [ LOCAL.AGR.PNG.PN 3sg ] >,
    CONT.HOOK.INDEX.PNG png & [ PN 3sg*,
                                GEN neut* ] ]. 

plur_noun := local &
  [ STEMHEAD count_or_masscount_nstem,
    CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3pl,
                                DIVISIBLE + ] ] >,
    CONT.HOOK.INDEX [ PNG png & [ PN 3pl* ],
                      DIVISIBLE +* ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Adjectival inflections
;;
;;  May-96: Martina

pos_adj := local &
  [ STEMHEAD astem,
    CAT.VAL.SPR < [ LOCAL local &
                          [ KEYS.KEY very_deg_rel ] ] > ].


er_comp_adj := local &
  [ STEMHEAD astem,
    CAT.VAL.SPR < [ LOCAL local &
                          [ KEYS.KEY much_deg_rel ] ] > ].


est_super_adj := local &
  [ STEMHEAD astem,
    CAT.VAL.SPR < [ LOCAL local &
                          [ KEYS.KEY _def_rel ],
                    OPT - ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Place holder affix for -ly

-ly := local & [ CAT.HEAD no_head ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  (Non-inflectional) lexical rules
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; AAC - INFLECTED added so that the relationship
;;; between inflectional morphology and lexical rules
;;; which is hacked into PAGE can be represented declaratively
;;;
;;; lex_rule_infl turns uninflected things into inflected ones
;;; but otherwise does inheritance
;;; everything else requires inflected forms

lex_rule_supermost := phrase_or_lexrule & word_or_lexrule &
  [ NEEDS-AFFIX bool,
    DTR sign & [ ALTS #alts,
                 POSSCL - ],
    ALTS #alts ].

; DPF 14-Aug-99 - Reorder appending of RELS from above since treatment of 
; fragments looks for the first scope hole from left to right in RELS, and 
; the first definition below gives different results for "October first" and 
; "the first of October".
; DPF 22-May-00 - But lexical rules in general may want to change categories,
; and the output's properties should conform to the type; for example, the
; rule for partitives wants to have the output be a noun, so the first element
; on RELS should be a nom_rel, not the quant_rel which the DTR would supply.
; So we go back to the original appending model, and leave the proper
; treatment of scope holes in fragments for later solutions.

lex_rule_compos := lex_rule_supermost &
  [ DTR.SYNSEM.LOCAL.CONT.RELS [ LIST #middle,
                                 LAST #last ],
    SYNSEM.LOCAL.CONT.RELS [ LIST #first,
                             LAST #last ],
    C-CONT.RELS [ LIST #first,
                  LAST #middle ] ].

lex_rule_infl_affixed := lex_rule_compos &
  [ INFLECTED +,
    KEY-ARG #keyarg,   
    SYNSEM #synsem,
    ARGS < #dtr >,
    ROOT #root,
    POSSCL -,
    DTR #dtr & [ INFLECTED -,
                 KEY-ARG #keyarg,   
                 SYNSEM #synsem,
                 ROOT #root ],
    C-CONT.RELS <! !> ].

; ERB (05-10-97) Now that sai stamps MESSAGE int_rel on its output, that
; default has to be taken out of lex_rule.  To avoid breaking anything else, I
; am making a new type lex_rule_super that is just like the current lex_rule
; except that it doesn't identify the messages, and then having lex_rule do
; that identification.

lex_rule_super := lex_rule_supermost &
  [ DTR word_or_lexrule &
        [ INFLECTED +,
          SYNSEM.LOCAL local &
		       [ CONJ cnil ] ],
    INFLECTED +,
    SYNSEM.LOCAL local &
	[ CONJ cnil ] ].

lex_rule_super_compos := lex_rule_super & lex_rule_compos &
  [ POSSCL - ].

lex_rule := lex_rule_super_compos &
  [ DTR #stem &
	[ SYNSEM.LOCAL [ CAT [ MC #mc,
			       HC-LEX #hclex ],
			 KEYS.MESSAGE #msg ] ],
    SYNSEM.LOCAL [ CAT [ MC #mc,
			 HC-LEX #hclex ],
		   KEYS.MESSAGE #msg ],
    ARGS < #stem > ].

;;
;;  Forms derived from inflected verbs
;;

; ERB (05-10-97) Before we had a special rule hcomp_yn_root for matrix polar
; questions.  Now, the unique head complement rule is taking over this job.
; To do this, we must put the int_rel onto the inverted auxiliaries (see also
; sai_synsem).  The original objection to this was that the inverted
; auxiliaries are used for things other than matrix questions (i.e., negative
; inversion).  However, a) we don't currently have an analysis of negative
; inversion, and b) it's not clear that they are the same auxiliaries.  The
; most obvious test -- 1st person aren't -- is not available since the
; contracted auxiliaries are in general disallowed in negative inverstion
; (polarity effect?).
;
; At the moment this is allowing "Will who sleep?" and "Will Kim see who?"
; (actually two parses of the latter).  This is fine, except that this is not
; producing the apropriate semantics.  In fact, all ynq (matrix and
; subordinate) are not currently specified for PARAMS.  I think this will be
; easier to fix once we have a) lexical threading and b) an implementation of
; the analysis of echo questions, so I am leaving it for later.
 
; DPF (10-Jan-99) Added SUBJ value identified with dtr's SPR value (usually
; < anti_synsem > which never unifies with real synsem), in order to allow 
; adjunct extraction to still apply to inverted sentences such as "When is 
; Kim happy" where "is Kim happy" is built by two applications of the head_comp
; rule.  By identifying SUBJ with dtr's SPR, we can maintain lexical control
; over modifiability, in particular blocking spurious modification of 
; auxiliary "do", both in noninverted and inverted clauses.
; DPF 22-Apr-00 - Added reentrancy for VFORM on DTR and mother - don't know
; why this was omitted before.  It's needed to block spurious parse for e.g. 
; "Could you sleep please"
; DPF 5-Jul-02 - Removed re-entrancy of SYNSEM..SUBJ..INDEX with dtr's, since
; it was wrecking coordination of "did Kim win or did Sandy win, since the
; SUBJ..INDEX got identified for both.  So what do we give up?
 
sai := lex_rule &
  [ STEM #orth,
    DTR #stem &
	 [ STEM #orth,
	   SYNSEM [ LOCAL [ CAT [ HEAD verb &
				       [ INV +,
					 VFORM fin* & #vform,
                                         TAM #tam,
					 VOICE #voice ],
				  VAL [ SUBJ < #subj & canonical_synsem &
                                               [ LOCAL 
                                                 [ CAT nomp_cat_nom,
                                                   KEYS.MESSAGE 0-dlist ] ] >,
                                        COMPS #comps,
					SPR #spr,
					--KEYCOMP #keycomp ] ],
			    CONT [ HOOK [ LTOP #dtrhand,
                                          INDEX #ind ],
				   HCONS #hcons ],
                            AGR #agr,
			    KEYS #keys ],
                    NON-LOCAL #nonloc ] ],
    SYNSEM sai_synsem &
	 [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				TAM #tam,
                                VOICE #voice ],
                         VAL [ COMPS < #subj & [ OPT - ]
				       . #comps >,
			       SPR #spr,
			       SUBJ < anti_synsem >,
			       --KEYCOMP #keycomp ] ],
		   CONT [ HOOK [ LTOP #dtrhand,
                                 INDEX #ind ],
			  HCONS #hcons ],
                   AGR #agr,
		   KEYS #keys &
		       [ MESSAGE <! !> ] ],
	   NON-LOCAL #nonloc ],
    ARGS < #stem >,
    C-CONT.RELS <! !> ].

#|
tag := lex_rule_super &
  [ STEM #orth,
    DTR #stem &
	[ STEM #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD.TAM #tam,
			       VAL.COMPS < #subj, [ LOCAL.CAT.HEAD subst ], ... >,
                               HC-LEX #hclex ],
			 KEYS.KEY #key ],
		 NON-LOCAL #nonloc & 
		       [ SLASH 0-dlist,
			 REL 0-dlist,
			 QUE 0-dlist ] ] ],
    SYNSEM tag_synsem &
	 [ LOCAL [ CAT [ HEAD.TAM #tam,
			 VAL.COMPS.FIRST #subj,
                         HC-LEX #hclex ],
		   CONT.RELS #cliszt,
		   KEYS [ KEY #key,
			  MESSAGE <! #msg !> ] ],
	   NON-LOCAL #nonloc ],
    ARGS < #stem >,
    C-CONT.RELS #cliszt & <! #msg !> ].
|#

tag := lex_rule_super &
  [ STEM #orth,
    DTR #stem &
	[ STEM #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD.TAM #tam,
			       VAL.COMPS < [ LOCAL.AGR.PNG #png ],
                                           [ LOCAL.CAT.HEAD subst ], ... >,
                               HC-LEX #hclex ],
                         KEYS.KEY #key ],
		 NON-LOCAL #nonloc & 
		       [ SLASH 0-dlist,
			 REL 0-dlist,
			 QUE 0-dlist ] ] ],
    SYNSEM tag_synsem &
	 [ LOCAL [ CAT [ HEAD.TAM #tam,
			 VAL.COMPS.FIRST synsem & 
                                  [ LOCAL [ CAT nomp_cat_nom_min,
                                            AGR.PNG #png,
                                            KEYS.MESSAGE 0-dlist,
                                            CONJ cnil ],
                                    OPT - ], 
                         HC-LEX #hclex ],
		   CONT.RELS #cliszt,
		   KEYS [ KEY #key,
			  MESSAGE <! #msg !> ] ],
	   NON-LOCAL #nonloc ],
    ARGS < #stem >,
    C-CONT.RELS #cliszt & <! #msg !> ].


; DPF 3-Apr-01 - Eventually generalize to "stand, sit" etc. 

loc_inv := lex_rule_super &
  [ STEM #orth,
    POSSCL -,
    DTR #stem &
	[ STEM #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD #head,
			       VAL.COMPS < #subj,
                                           [ LOCAL #local & [ CAT prd_cat ]] >,
                               HC-LEX #hclex ],
                         CONT.HOOK [ LTOP #ltop,
                                     INDEX #ind ],
                         AGR #agr,
			 KEYS.KEY #key ],
		 NON-LOCAL 
		       [ SLASH 0-dlist,
			 REL 0-dlist,
			 QUE 0-dlist ] ] ],
    SYNSEM loc_inv_synsem &
	 [ LOCAL [ CAT [ HEAD #head,
			 VAL.COMPS < #subj >,
                         HC-LEX #hclex ],
                   AGR #agr,
		   CONT [ HOOK [ LTOP #ltop,
                                 INDEX #ind ],
                          RELS #cliszt ],
		   KEYS [ KEY #key,
                          MESSAGE <! #msg !> ] ],
	   NON-LOCAL [ SLASH <! #local !>,
                       REL 0-dlist,
                       QUE 0-dlist ] ],
    C-CONT.RELS #cliszt & <! #msg !>,
    ARGS < #stem > ].


; DPF 31-Jul-99 - Removed [INV -] from DTR, since it blocked entry for
; "Is that also important?"
; DPF 1-Jun-01 - Removed DTR..SUBJ canonical_synsem, since prevents relative
; clauses headed by these, as in "messages that are not valid fail".
; DPF 3-Jun-01 - Made DTR..VFORM fin rather than fin* to avoid V+ADV analysis
; of "be not happy"
; DPF 13-Sep-01 - Copy attributes of HEAD from dtr to mother, to make sure that
; dtr is [AUX +] but mother is [AUX +*] so it will still coordinate with nonaux

adv_addition := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM 
               [ LOCAL [ STEMHEAD vstem,
			 CAT [ HEAD verb &
				    [ AUX +,
				      VFORM fin,
                                      MOD #mod,
                                      PRD #prd,
                                      INV #inv,
                                      TAM #tam,
                                      VOICE #voice ],
			       VAL [ SUBJ #subj & < synsem >,
				     COMPS #comps & *substlist*,
				     SPR #spr ],
			       POSTHEAD #ph ],
			 CONT [ HOOK [ LTOP #vltop,
                                       INDEX #vindex,
                                       E-INDEX #veindex,
                                       XARG #xarg ],
				HCONS #hcons ],
			 CTXT #ctxt,
			 KEYS #keys ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM aux_verb &
	 [ LOCAL 
	   [ CAT 
	     [ HEAD verb &
                    [ AUX +*,
                      VFORM fin,
                      MOD #mod,
                      PRD #prd,
                      INV #inv,
                      TAM #tam,
                      VOICE #voice ],
               VAL [ SUBJ #subj,
		     COMPS *cons* &
			  < [ LOCAL local &
				    [ CAT.HEAD basic_lexadv &
                                       [ MOD < [ LOCAL.CONT.HOOK.LTOP #vltop ] >,
                                         TAM.TENSE no_tense ],
				      CONT.HOOK [ LTOP #advltop,
                                                  INDEX #vindex,
                                                  E-INDEX #veindex ],
				      KEYS.MESSAGE 0-dlist ],
			      LEX +,
			      OPT - ] . #comps >,
		     SPR #spr ],
	       POSTHEAD #ph ],
	     CONT [ HOOK [ LTOP #advltop,
                           INDEX #vindex,
                           E-INDEX #veindex,
                           XARG #xarg ],
		    HCONS #hcons ],
	     CTXT #ctxt,
	     KEYS #keys ],
	   NON-LOCAL #nonloc ],
    C-CONT.RELS <! !> ].

;; VP Ellipsis
;; We can't let this rule apply to the infinitival "to", since we would then
;; have no way of blocking the NP "the book to", where "to" first underwent
;; this rule, then the subject-extraction rule (needed for ordinary infinitival
;; relatives), and then the usual infinitival relative rule.  So instead we
;; create a separate lexical entry for the elided form of "to", and make it
;; MOD < >.
;; DPF 24-Jun-01 - Made DTR be TAM.ASPECT nonprg to prevent "Kim is being".
;; DPF 31-May-02 - This may not have been enough, so tried adding VFORM 
;; fin_or_bse.

vp_ellipsis := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
          ALTS.VPELLIP +,
	  SYNSEM 
	   [ LOCAL [ CAT [ HEAD verb &
				[ MOD #mod,
                                  PRD #prd,
                                  INV #inv,
                                  AUX +,
                                  TAM #tam &
                                      [ ASPECT nonprg ],
                                  VFORM #vform & fin_or_bse,
                                  VOICE #voice ],
                           POSTHEAD #ph,
			   VAL [ SUBJ #subj,
				 SPR #spr,
				 COMPS < unexpressed &
					 [ LOCAL [ CAT.HEAD subst,
						   CONT.HOOK [ LTOP #chand,
                                                               E-INDEX #cind ],
						   KEYS.KEY #altkey ] ] > ] ],
		     CONT [ HOOK [ LTOP #hand,
                                   INDEX #ind ],
			    HCONS #hcons ],
		     CTXT #ctxt,
		     KEYS.KEY #key ],
	     NON-LOCAL #nonloc ] ],
    SYNSEM verb_synsem &
	 [ LOCAL [ CAT [ HEAD verb & 
                              [ MOD #mod,
                                PRD #prd,
                                INV #inv,
                                AUX +*,
                                TAM #tam,
                                VFORM #vform & fin_or_bse,
                                VOICE #voice ],
                         POSTHEAD #ph,
			 VAL [ SUBJ #subj,
			       SPR #spr,
			       COMPS < > ] ],
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #ind ],
			  HCONS #hcons ],
		   KEYS [ KEY #key,
			  ALTKEY #altkey & ellipsis_rel &
				       [ LBL #chand,
                                         ARG0 #cind ] ],
		   CTXT #ctxt ],
	   NON-LOCAL #nonloc ],
    C-CONT.RELS <! #altkey !> ].

vp_ellipsis_ref := vp_ellipsis &
  [ DTR.SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #cind ] >,
                       CONT.HOOK.XARG ref-ind & #sind ],
    SYNSEM verb_synsem &
	 [ LOCAL [ KEYS.ALTKEY [ ARG0 #cind,
                                 ROLE #sind ],
                   CONT.HOOK.XARG #sind ] ] ].

vp_ellipsis_expl := vp_ellipsis &
  [ DTR.SYNSEM.LOCAL [ CAT.VAL.SUBJ < [ LOCAL.KEYS.KEY no_rel ] >,
                       CONT.HOOK.XARG there-ind & #ind ],
    SYNSEM verb_synsem &
	 [ LOCAL [ CONT.HOOK [ INDEX #event,
                               XARG #ind ],
		   KEYS [ ALTKEY [ ARG0 #event ] ] ] ] ].

;; Need to work on generalizing the semantics - since we derive this entry
;; from the past participle, we have to discard the tense information from
;; the input - not clear yet how to do this in general.  For now we assume
;; that transitive verbs introduce a single relation, bound to the KEY attrib.

; This incorrectly orders the by_pp before all remaining comps - wrong for
; double-NP verbs, and incomplete for verbs with other oblique arguments,
; since this allows only one order.  But this latter is a general problem.

; DPF 3-Nov-01 - Removed [CONT..E-INDEX.E.ASPECT perf*] since this allows wrong
; generation.  Why was it here?

;; DPF 10-Oct-00 - SYNSEM.COMPS..KEYS.KEY needs fixing

passive_verb := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
          ALTS.PASSIVE +,
	  SYNSEM trans_subst & verb_synsem &
               [ LOCAL [ STEMHEAD vstem,
                         CAT [ HEAD [ VFORM psp_or_psp_irreg,
                                      TAM [ TENSE #tense,
                                            ASPECT nonprf,
                                            MOOD #mood ] ],
                               VAL [ SUBJ < [ LOCAL local &
						[ CONT.HOOK.INDEX #subjind ], 
                                              NON-LOCAL #snonloc ] >,
					 SPR #spr,
					 COMPS [ FIRST [ LOCAL local &
							[ CONT #objcont ],
							 NON-LOCAL #ononloc ],
						 REST #comps ] ] ],
			 CONT [ HOOK.LTOP #hand,
				HCONS #hcons ],
			 KEYS [ KEY #key,
				--COMPKEY #ckey,
				--OCOMPKEY #ockey ],
			 CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM passive_synsem &
	 [ LOCAL verb_participle_affix &
		 [ CAT [ HEAD verb* & [ AUX -,
					VFORM pas,
					VOICE passive,
                                        TAM [ TENSE #tense,
                                              MOOD #mood ] ],
			 VAL [ SUBJ < synsem &
					[ LOCAL [ CAT nomp_cat_min,
						  CONJ cnil,
						  CONT #objcont &
                                                      [ HOOK.INDEX #objind ] ],
					  NON-LOCAL #ononloc ] >,
                               SPR #spr,
                               COMPS < synsem & 
                                       [ LOCAL local &
                                               [ CAT [ HEAD prep,
                                                       VAL [ SUBJ < >,
                                                             SPR *olist*,
                                                             COMPS *olist* ] ],
                                                 KEYS.KEY _by_pass_rel_cm &
                                                     [ ARG2 #subjind ] ],
                                         NON-LOCAL #snonloc,
                                         OPT + ]
                                       . #comps > ] ],
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #ind & [ E.ASPECT perf* ],
                                 E-INDEX #ind,
                                 XARG #objind ],
			  HCONS #hcons ],
		   KEYS [ KEY #key,
			  --COMPKEY #ckey,
			  --OCOMPKEY #ockey ],
		   CTXT #ctxt ],
	   NON-LOCAL #nonloc ],
    C-CONT.RELS <! !> ].


#|
; it-extraposition

it-extraposition := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM extraposable_synsem &
	       [ LOCAL [ CAT [ HEAD #head,
			       VAL [ SUBJ < [ LOCAL local &
					      [ CONT.HOOK.INDEX #subjind ] ] >,
					 COMPS #comps ] ] ],
			 CONT #cont,
			 CTXT #ctxt,
		         KEYS #keys ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM expl_it_subj_synsem &
	 [ LOCAL [ CAT [ VAL [ SUBJ < synsem &
					[ LOCAL [ CAT nomp_cat_min,
						  CONJ cnil,
						  CONT.HOOK.INDEX it-ind ] ] >,
				   COMPS < synsem & 
					   [ LOCAL [ CAT s_cat_fin_v_c,
						     CONJ cnil,
						     CONT.HOOK.INDEX #subjind],
					     OPT - ]
					   . #comps > ] ],
		   CONT #cont,
		   CTXT #ctxt,
		   KEYS #keys ],
	   NON-LOCAL #nonloc ],
   C-CONT.RELS <! !>  ].
|#

;; This has the same problem as the passive lexical rule.  Since we derive the
;; gerund from the present particple, we somehow have to filter out the
;; progressive relation.

;; DPF 27-May-99 - We block extraction from gerunds, at least for efficiency.
;; DPF 02-June-99 - We also block the auxiliary verbs "being, having, doing",
;; to avoid identity copula analyses for "Kim is being good" or "Kim is having
;; hired Sandy".
;; DPF 31-Jul-99 - Make gerund_rel like nominalize_rel in identifying its
;; handle with the verb_rel's, rather than taking the verb's handle as arg.
;; DPF 24-Jun-01 - Added REL 0-dlist to block "interviewing that" as gerund NP
;; with rel-pro "that".  This is overly strong for pied piping, as in "I met
;; some people talking to whom was pleasant", but we would need to distinguish
;; at least rel-pro "that" (and maybe "who") from "whom" - maybe later.
;; DPF 8-Nov-01 - The decision to block extraction from verbal gerunds means
;; we don't get "Which books are you interested in buying".

verbal_gerund := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ STEMHEAD vstem,
                         CAT [ HEAD verb &
                                    [ VFORM prp,
				      AUX - ],
			       VAL.COMPS #comps ],
			 CONT [ HOOK.LTOP #hand,
				HCONS #hcons ],
			 KEYS [ KEY.ARG0.E.TENSE no_tense,
                                --COMPKEY #ckey,
				--OCOMPKEY #ockey ],
			 CTXT #ctxt ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM nonpro_onearg_synsem &
	   [ LOCAL [ AGR #ind,
		     CAT [ HEAD gerund* &
				[ MOD < >,
				  PRD - ],
			   VAL [ SUBJ < [ LOCAL.CAT.HEAD noun* ] >,
                                 SPR < [ OPT - ] >,
                                 COMPS #comps ] ],
		     CONT [ HOOK [ LTOP #hand,
                                   INDEX #ind &
                                       [ PNG png & [ PN 3sg*,
                                                     GEN neut* ],
                                         DIVISIBLE +,
                                         PRONTYPE not_pron ] ],
                            HCONS #hcons ],
		     KEYS [ KEY gerund_rel & #key &
				[ LBL #hand,
				  ARG0 #ind ],
			    --COMPKEY #ckey,
			    --OCOMPKEY #ockey ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc & [ REL 0-dlist & [ LIST < > ] ] ],
    C-CONT.RELS <! #key !> ].

; DPF 27-May-99 - POSS-ING gerunds are given a non-empty SUBJ value so they
; can be modified by ordinary PPs and non-sentential adverbs, but the synsem
; value is the hack 'anti_synsem' which is also used for the SPR value of verbs,
; for similar reasons.

;; DPF 27-May-99 - Try combining the two verbal gerund rules into one.

;; DPF 10-Oct-00 - SPR..KEYS.ALTKEY needs fixing

vger_ing := verbal_gerund &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #subj,
                                      NON-LOCAL #snonloc ] >,
    SYNSEM.LOCAL [ CAT.VAL [ SUBJ < synsem &
				    [ LOCAL [ CAT nomp_cat_acc_min,
					      CONJ cnil,
                                              KEYS.MESSAGE 0-dlist,
					      CONT.HOOK.INDEX #subj ] ] >,
			     SPR < [ LOCAL local &
					   [ CAT [ HEAD det & 
						    [ POSS + ],
						   VAL [ SUBJ < >,
							 SPR *olist*,
							 COMPS *olist* ] ],
					     KEYS.ALTKEY [ ARG1 #ind,
                                                           ARG2 #subj ] ],
                                     NON-LOCAL #snonloc ] > ],
		   CONT.HOOK.INDEX #ind ] ].

;; DPF (12-Jul-98) In order to allow prenominal adjectives for nominal gerunds,
;; as in "regular tasting of wine is healthy", we have to treat the specifier
;; of the gerund as obligatory, since prenominal adjectives distinguish proper
;; from common nouns based on the optionality (or absence) of the specifier.
;; So these gerunds have to undergo the bare plural rule if no determiner is
;; present, which means they also have to be DIVISIBLE +.
;; DPF 26-Mar-01 - Added [ALTKEY relation] to mother, to avoid having verbal
;; gerunds as, e.g., modified by "per/a person".
;; DPF 22-Apr-01 - Removed DIVISIBLE + since we're getting a systematic
;; ambiguity between bare nominal gerunds and bare verbal gerunds.  This means
;; we'll block "hiring of consultants is important", but that's okay for now.
;; DPF 30-Aug-01 - But we also lose "loud singing is discouraged", which is
;; not okay, so we put DIVISIBLE + back on mother.
;; DPF 23-Sep-01 - Used to have [ALTKEY relation] to block gerunds appearing as
;; left members of noun-noun compounds, but this also blocked them as heads of
;; compounds as in "chair buying is fun".  So eliminate this constraint, and
;; allow nominal gerunds on both sides of compounds, as in "email routing list"
;; or "weekend shopping regulations" - and block pres-participles as adjectives
;; to avoid apparently spurious ambiguity for e.g. "shopping trip".  But 
;; consider "the hiring consultant" which is ambiguous between the one who
;; does the hiring and the one who advises on hiring - maybe differing 
;; intonation suggests two distinct analyses, not spurious.  But block for now.
;; DPF 10-Nov-01 - Made nominal gerunds have head type nomger so they can be
;; distinguished from non-derived nouns (e.g. so modifiers like "per" don't
;; attach).

nominal_gerund := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ CAT [ HEAD verb &
                                    [ VFORM prp,
				      AUX - ],
			       VAL.SUBJ < [ NON-LOCAL #snonloc ] > ],
			 CONT [ HOOK.LTOP #vhand,
                                HCONS [ LIST #hclist,
                                         LAST #hclast ] ],
                         KEYS [ KEY.ARG0.E.TENSE no_tense,
                                --COMPKEY #ckey,
				--OCOMPKEY #ockey ],
			 CTXT #ctxt ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM nonpro_nomod_synsem &
	   [ LOCAL 
	     [ AGR #ind,
	       CAT 
	       [ HEAD nomger,
		 VAL [ SUBJ < >,
		       SPR < [ LOCAL local &
				     [ CAT [ HEAD det,
					     VAL [ SUBJ < >,
						   SPR *olist*,
						   COMPS *olist* ] ],
				       CONT.HOOK.INDEX #ind ],
			       NON-LOCAL #snonloc,
			       OPT - ] > ] ],
	       CONT [ HOOK [ LTOP #hand,
                             INDEX #ind & [ PNG png & [ PN 3sg*,
                                                        GEN neut* ],
                                            DIVISIBLE +,
                                            SORT entity,
                                            PRONTYPE not_pron ] ],
                      HCONS [ LIST < qeq & 
                                      [ HARG #marghand,
                                        LARG #vhand ] . #hclist >,
                               LAST #hclast ] ],
	       KEYS [ KEY #key & nominalize_rel & 
			    [ LBL #hand,
			      ARG0 #ind,
                              ARG1 #arghand ],
		      --COMPKEY #ckey,
		      --OCOMPKEY #ockey ],
	       CTXT #ctxt ],
	     NON-LOCAL #nonloc & [ SLASH 0-dlist ] ],
    C-CONT.RELS <! #key, prpstn_rel & [ LBL #arghand,
                                        MARG #marghand ] !> ].

intrans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM intrans_subst & 
	       [ LOCAL.CAT.VAL.COMPS #comps ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #comps ].


;; This is too restrictive.  It only forms nominal gerunds from strictly
;; transitive verbs.  So, it doesn't give you "Kim's putting of food on the
;; table" or "Kim's warning of Sandy that it would rain" or "Kim's giving of
;; raisins to the ants".  
;;  To avoid ambiguity with the intransitive nominal gerund, we make the PP
;; obligatory.
;; DPF 19-Feb-01 - But this is too restrictive: blocks "Hiring is difficult"

;; DPF 10-Oct-00 - SPR..KEYS.KEY needs fixing
;; DPF 22-Feb-01 - Added restriction on --COMPKEY (and --OCOMPKEY) to prevent 
;; verb-particle verbs (with "selected_rel" complements) from undergoing rule.
;; DPF 26-Mar-01 - Make the OPT value of the of-PP complement be same as that
;; of the verb's complement NP.
;; DPF 23-Sep-01 - But this prevents e.g. "hiring is important".  So make the
;; value OPT +, which seems true for nominal gerunds.
trans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM trans_subst & 
	       [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
						[ CONT.HOOK.INDEX #index ] ] >,
                         KEYS [ --COMPKEY independent_rel,
                                --OCOMPKEY independent_rel ] ] ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < synsem &
				 [ LOCAL [ CAT pp_cat,
					   CONJ cnil,
					   KEYS.KEY _of_rel & 
							[ ARG2 #index ],
					   CONT.HOOK.INDEX #index ],
				   OPT + ] > ].

; DPF 13-Oct-02 - Added COMPS < > to SPEC..SYNSEM, to avoid spurious ambiguity
; for e.g. "Friday evening"

date_det_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ STEMHEAD nstem,
                           CAT.VAL.COMPS < [ OPT + ] >,
			   CONT.HCONS [ LIST #hclist,
                                        LAST #hclast ],
			   KEYS [ KEY #altkey,
				  --COMPKEY #ckey,
				  --OCOMPKEY #ockey ],
			   CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD det,
			   VAL [ SUBJ < >,
				 SPR < >,
				 COMPS < >,
				 SPEC < [ LOCAL [ CAT.VAL.COMPS < >,
                                                  CONT.HOOK.INDEX #ind,
                                                  KEYS.KEY.LBL #nltop ]] >]],
		     CONT [ HOOK.INDEX #ind,
			    HCONS [ LIST < qeq &
                                            [ HARG #rhand,
                                              LARG #nltop ] . < qeq &
                                              [ HARG #mhand,
                                                LARG #mltop ] . #hclist > >,
                                     LAST #hclast ] ],
                     KEYS [ KEY #key & def_rel &
				      [ ARG0 #ind,
					RSTR #rhand ],
			    ALTKEY #altkey & [ LBL #mltop,
                                               ARG0 #spind ],
			    --COMPKEY #ckey,
			    --OCOMPKEY #ockey ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc,
	     MODIFIED hasmod ],
    C-CONT.RELS <! #key,
                    _of_rel & [ LBL #nltop,
                                ARG0.E.TENSE no_tense,
                                ARG1 #ind,
                                ARG2 #spind ],
                    def_rel & [ ARG0 #spind,
                                RSTR #mhand ] !> ].

; "October": NP => Determiner
;          "(in) October" => "October first"

month_det_lr := date_det_lr &
  [ DTR.SYNSEM.LOCAL.KEYS.KEY mofy_rel,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.KEYS.KEY dofm_rel ] > ].

; "Tuesday": NP => Determiner
;          "(on) Tuesday" => "Tuesday morning"

weekday_det_lr := date_det_lr &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.KEYS.KEY day_part_rel ] >,
    DTR.SYNSEM.LOCAL.KEYS.KEY dofw_rel ].

; "January first 1984" from "the first of january"
mofy_dofm_yofc_lr := lex_rule &
  [ STEM #orth,
    SYNSEM dom_ord_yofc_synsem,
    DTR [ STEM #orth,
	  SYNSEM dom_ord_synsem ] ].


; Comment out for now - unused due to too much ambiguity
#|
adj_noun_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ STEMHEAD astem,
                           CAT [ HEAD.PRD -,
				 VAL [ COMPS #comps,
				       SPR < #spr > ] ],
			   CONT [ HOOK.LTOP #ahand,
                                  HCONS #hcons ],
			   KEYS [ --COMPKEY #ckey,
				  --OCOMPKEY #ockey,
				  MESSAGE #msg ],
			   CTXT #ctxt ],
		   NON-LOCAL #non-local ] ],
    SYNSEM adj_noun_synsem & 
	  [ LOCAL [ CAT.VAL [ COMPS #comps,
			      SPR < #spr, ... > ],
		    CONT.HCONS #hcons,
		    KEYS [ KEY #key & [ ARG2 #ahand ],
			   --COMPKEY #ckey,
			   --OCOMPKEY #ockey,
			   MESSAGE #msg ],
		    CTXT #ctxt ],
	    NON-LOCAL #non-local ],
    C-CONT.RELS <! #key !> ].

adj_noun_personal_lr := adj_noun_lr &
  [ DTR.SYNSEM.LOCAL.KEYS.KEY adj_personal_rel,
    SYNSEM adj_noun_personal_synsem].

adj_noun_abstract_lr := adj_noun_lr &
  [ DTR.SYNSEM.LOCAL.KEYS.KEY adj_abstract_rel,
    SYNSEM adj_noun_abstract_synsem].
|#

; Relate transitive predicative adjectives to their intransitive attributive
; counterparts

attr_adj_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM pred_adj_synsem &
	         [ LOCAL [ CAT [ HEAD.MOD #mod,
				 VAL [ SUBJ #subj,
				       SPR #spr,
                                       COMPS *olist* ] ],
                           CONT.RELS <! relation !>,
			   CTXT #ctxt,
			   KEYS #keys ],
		   NON-LOCAL #non-local ] ],
    SYNSEM attr_adj_synsem &
	  [ LOCAL [ CAT [ HEAD.MOD #mod,
			  VAL [ SUBJ #subj,
				SPR #spr ] ],
		    CTXT #ctxt,
		    KEYS #keys ],
	    NON-LOCAL #non-local ],
    C-CONT.RELS <! !> ].


;; Makes "admired" into an attributive adjective, as in "the admired hero"
;; DPF 22-Feb-01 - Added restriction of 'independent_rel' on --COMPKEY (and 
;; --OCOMPKEY) to prevent verb-particle verbs (with "selected_rel" complements)
;; from undergoing rule.
;; DPF 22-May-01 - But this did not generalize to blocking other unwanted
;; subcat variants, like S-comp-taking "checking".  So instead constrain
;; dtr's SYNSEM to be passive_or_unacc_subst, and require the --COMPKEY to be
;; no_rel.  This allows only intransitive (past-participle) verbs or passive 
;; transitive verbs to undergo this rule.
;; DPF 31-Jul-01 - Removed attr_adj_synsem from output since it didn't work.
;; What was I thinking?  Also removed MOD..SPR..KEY explicit_quant_rel from
;; output, since this blocks "hired consultants arrive".  What was it for?
;; DPF 23-Sep-01 - Tempting to restrict this rule to only passives, since now 
;; handling pres-participles as nominal gerunds in noun-noun compounds.  (We
;; don't yet enable unaccusative participles as in "the fallen leaf".)  But as
;; noted above, what about two readings for "the hiring consultant" - one seems
;; to be n-n compound, the other an attrib adj, so maybe need both?  Block for
;; now.
;; DPF 25-Nov-01 - Changed SYNSEM.HEAD to be verb* rather than adj*, to allow
;; "The recently purchased chair arrived"
;; DPF 3-Jan-02 - Added (hack?) length limit on RELS for input, to block 
;; application of rule to v-np-pp verbs like "send" (cf. 'Do you offer a 
;; printed catalog')

attr_verb_part_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM passive_or_unacc_synsem &
	         [ LOCAL [ CAT [ HEAD verb &
                                      [ VFORM pas_or_psp,
                                        AUX - ],
				 VAL [ SUBJ #subj,
                                       SPR #spr ] ],
                           CONT [ HOOK [ LTOP #ltop,
                                         INDEX.E [ TENSE no_tense,
                                                   ASPECT perf* ] ],
                                  RELS <! relation !>,
                                  HCONS #hcons ],
                           CTXT #ctxt,
			   KEYS #keys & [ --COMPKEY no_rel ] ],
                   NON-LOCAL #non-local ] ],
    SYNSEM canonical_synsem &
	  [ LOCAL [ CAT [ HEAD verb* &
                               [ MOD < [ LOCAL intersective_mod &
                                         [ CAT n_or_v_cat & 
                                           [ HEAD [ AUX -,
                                                    TAM.TENSE real_tense ] ],
                                           AGR #ind,
                                           CONT.HOOK.INDEX #ind ] ] >,
                                 VFORM psp_adj,
                                 PRD - ],
                          VAL [ SUBJ #subj &
                                   < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
                                SPR #spr,
                                COMPS < > ] ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ],
                           HCONS #hcons ],
                    CTXT #ctxt,
		    KEYS #keys ],
            MODIFIED.PERIPH na,
	    NON-LOCAL #non-local ],
    C-CONT.RELS <! !> ].

;; The partitive construction rule introduces a new type of relation: 
;; part_of_rel, which contains the semantic information of the partitive.
;; The features of the relation, a subtype of nom_rel, were
;; - LBL, 
;; - ARG0, the index of the NP,
;; - SET, the handle of the PP complement, defining the set of which the head 
;;        determines a subset,
;; - NPREP,the index of the PP complement of the head, which is actually the
;;        index of the NP complement of that PP.
;; The idea is that there is a difference between, for example, "some books", 
;; and "some of the books". In the first case, "books" can refer to a subset
;; of the set of all the existing books, and "some" quantifies over the 
;; set of all existing books. In the second case, "some" refers to a subset of
;; the set of books defined by "the books": that set cannot refer to the 
;; universal set of all existing books. The relation "part_of_rel" tries to
;; capture that notion of subset of a certain set (defined by the context, or 
;; the determiner of the NP complement): the subset has an index 
;; (ARG0), and the defined set is referred to by "SET", which is the handle of
;; the prepositional phrase, and also the handle of the determiner of the 
;; prepositional complement.  We thus give partitives a complex lexical
;; semantics, including both the part_of_rel and the original quantifier
;; relation, with its usual attributes.

;; A problem which remains is to get the right agreement with the right head.
;; At the moment, the index of the head is the same as the index of the 
;; original determiner. As an example, "all" can be mass or plural, and is 
;; going to agree with a singular or a plural verb, whatever its complement is
;; ("all of the cake", "all of the students"). If we decide to have the index
;; of the construction being the index of the complement noun, what about 
;; "each" ? "Each of the boys" will agree with a plural only, when it should
;; agree with a singular. On the other hand, there is also the problem of 
;; "all of the oats are", plural when "all" is the mass determiner here: 
;; agreement is determined, here, by the plural form of the complement noun.

basic_part_constr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM basic_part_det_synsem & 
	  [ LOCAL [ KEYS.KEY #relation,
                    CONT.HCONS #hcons,
                    AGR.DIVISIBLE #div ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM partitive_noun_synsem & 
     [ LOCAL [ KEYS [ KEY #key,
                      ALTKEY #relation ],
               CONT.HCONS #hcons,
               AGR.DIVISIBLE #div ],
       NON-LOCAL #nonlocal ],
   C-CONT [ RELS <! #key !> ] ].

part_nocomp_constr := basic_part_constr &
 [ SYNSEM partitive_noun_nocomp_synsem ].

part_ppof_agr_constr := basic_part_constr &
 [ DTR.SYNSEM.LOCAL [ KEYS.KEY explicit_quant_agr_rel,
                      CAT.VAL.--KEYCOMP.LOCAL.AGR.DIVISIBLE #div ],
   SYNSEM partitive_noun_ppof_synsem &
        [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.AGR.PNG.PN #pn,
                  AGR [ PNG.PN #pn,
                        DIVISIBLE #div ] ] ] ].
          
part_ppof_noagr_constr := basic_part_constr &
 [ ARGS < [ SYNSEM.LOCAL [ KEYS.KEY explicit_quant_or_udef_noagr_rel,
                           AGR #agr ] ] >,
   SYNSEM partitive_noun_ppof_synsem &
        [ LOCAL.AGR #agr ] ].

; NP-particle alternation (e.g. "look up the answer/look the answer up"
; Stamp canonical_synsem on NP of output, to avoid spurious parse for extraction
; of the NP, as in "Which problem did Kim figure out?"

NP_particle_lr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM particle_NP_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          POSTHEAD #ph,
			  VAL [ SUBJ #subj,
                                COMPS < [ OPT #opt1 ], [ OPT #opt2 ] > ] ],
		    CONT #cont,
		    CTXT #ctxt,
		    KEYS #keys ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM NP_particle_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          POSTHEAD #ph,
			  VAL [ SUBJ #subj,
				    COMPS < canonical_synsem & [ OPT #opt2 ], 
					    [ OPT #opt1 ] > ] ],
		    CONT #cont,
		    CTXT #ctxt,
		    KEYS #keys ],
	    NON-LOCAL #nonlocal ],
   C-CONT.RELS <! !> ].

; --OCOMPKEY is not the same for ditrans and to-trans.

dative_shift_lr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM ditrans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL.SUBJ #subj ],
		    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ],
			   RELS #liszt,
			   HCONS #hcons ],
		    KEYS [ KEY #key,
			   ALTKEY #altkey,
			   --COMPKEY #ckey ],
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM to_trans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL [ SUBJ #subj,
				COMPS < [ OPT - ], [ OPT - ] > ] ],
		    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ],
			   RELS #liszt,
			   HCONS #hcons ],
		    KEYS [ KEY #key,
			   ALTKEY #altkey,
			   --COMPKEY #ckey ],
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ],
   C-CONT.RELS <! !> ].

possessed_word_lexrule := 
  lex_rule_compos &
  [ POSSCL +,
    SYNSEM #synsem,
    DTR #dtr & [ SYNSEM #synsem ],
    ARGS < #dtr >,
    C-CONT.RELS <! !> ].
