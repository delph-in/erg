;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  lexrules.tdl
;;;
;;;  Inflectional affixes and derivational lexical rules
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;  Last revised: Dan Flickinger, 24-Feb-97
;;;
;;;  $Id$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Inflectional affixes
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Verbal inflections


non_fin_verb := affix & 
  [ CAT.VOICE active,
    CONT psoa ].

; Need to constrain MOD value for PRP verbs.  Also for passive participles.


;; Verbal affix for present and passive participles, which can modify N-bars

verb_participle_affix := affix &
  [ CAT [ HEAD verb,
	  VALENCE.SUBJ.LOCAL local & [ CONT.INDEX #nind ],
	  MOD [ CAT [ HEAD cnoun &
			   [ POSS - ],
		      VALENCE [ SPR < synsem >,
				COMPS *olist* ] ],
		CONT [ HANDEL #hand,
		       INDEX #nind ] ] ],
    CONT [ HANDEL #hand,
	   KEY.HANDEL #hand,
	   MODCONT [ HANDEL #hand,
		     LISZT <! !> ] ] ].

prp_verb := non_fin_verb & verb_participle_affix &
  [ CAT.HEAD [ VFORM prp,
	       PRD + ],
    CONT [ INDEX.TIME #e,
	   LISZT <! prog_rel &
		  [ EVENT1 #e ] !> ] ].

psp_verb := non_fin_verb & nomod_local &
  [ CAT.HEAD [ VFORM psp,
	       PRD - ],
    CONT [ HANDEL #hand,
	   INDEX [ TIME #e,
		   REFERENCE #r ],
	   LISZT <! temp_prec_rel &
		  [ HANDEL #hand,
		    EVENT1 #e,
		    LATER #r ] !> ] ].

non_perf := affix & nomod_local &
  [ CONT.INDEX [ TIME #e,
		 REFERENCE #e ] ].

bse_verb := non_fin_verb & non_perf &
  [ CAT.HEAD [ VFORM bse,
	       PRD - ],
    CONT.LISZT <! !> ].

fin_verb := affix & non_perf &
  [ CAT [ HEAD [ PRD -,
		 VFORM fin,
                 VOICE active ],
          VALENCE.SUBJ @nomp($case=nom) ],
    CONT psoa & [ --TMP.FIN_VERB #liszt,
		  LISZT #liszt ] ].

; Add speech-time to finite verb's index, to make printed MRS more readable.

pres_verb := fin_verb & 
  [ CAT.HEAD.MOOD indicative,
    CONT [ HANDEL #hand,
	   INDEX [ REFERENCE #r,
		   SPCH #s ],
	   --TMP.FIN_VERB <! temp_over_rel &
			 [ HANDEL #hand,
			   EVENT1 #r,
			   WHEN #s ] !> ],
    CTXT.C-INDS.SPEECH #s ].

past_verb := fin_verb & 
  [ CAT.HEAD [ TENSE past,
               MOOD indicative ],
    CONT [ HANDEL #hand,
	   INDEX [ REFERENCE #r,
		   SPCH #s ],
	   --TMP.FIN_VERB <! temp_prec_rel &
			 [ HANDEL #hand,
			   EVENT1 #r,
			   LATER #s ] !> ],
    CTXT.C-INDS.SPEECH #s ].

subjunctive_verb := fin_verb & 
  [ CAT.HEAD.MOOD subjunctive,
    CONT [ HANDEL #hand,
	   --TMP.FIN_VERB <! irrealis_rel &
                          [ HANDEL #hand ] !> ] ].

third_sg_fin_verb := pres_verb &
  [ CAT [ HEAD.TENSE present,
	  AGR.PNG 3sg ] ].

non_third_sg_fin_verb := pres_verb &
  [ CAT [ HEAD.TENSE present,
	  AGR.PNG non3sg,
	  VALENCE.SUBJ.LOCAL local & [ CONT nom-obj ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Nominal inflections

sing_noun := affix &
  [ CAT.HEAD noun,
    CONT [ INDEX [ PNG 3sg_n,
		   DIVISIBLE - ],
	   LISZT <! !> ] ].

plur_noun := affix &
  [ CAT.HEAD noun,
    CONT [ INDEX [ PNG 3pl,
		   DIVISIBLE + ],
	   LISZT <! !> ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Adjectival inflections
;;
;;  May-96: Martina

pos_adj := affix &
  [ CAT [ HEAD adj,
	  VALENCE.SPR < [ LOCAL local &
				[ CONT.KEY very_deg_rel ] ] > ],
    CONT.LISZT <! !> ].

er_comp_adj := affix &
  [ CAT [ HEAD adj,
	  VALENCE.SPR < [ LOCAL local &
				[ CONT.KEY much_deg_rel ] ] > ],
    CONT [ LISZT <! more_sc_adv_rel &
		    [ HANDEL #hand,
		      ARG-1 #nind ] !>,
	   MODCONT [ HANDEL #hand,
		     INDEX #nind ] ] ].

est_super_adj := affix &
  [ CAT [ HEAD adj,
	  VALENCE.SPR < [ LOCAL local &
				[ CONT.KEY def_rel ],
			  OPT - ] > ],
    CONT [ LISZT <! comp_most_rel &
                  [ HANDEL #hand,
		    ARG-1 #nind,
		    SET handle ] !>,
	   MODCONT [ HANDEL #hand,
		     INDEX #nind ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Place holder affix for -ly

-ly := affix & [ CAT.HEAD no_head ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  (Non-inflectional) lexical rules
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ERB (05-10-97) Now that sai stamps MESSAGE int_rel on its output, that
; default has to be taken out of lex_rule.  To avoid breaking anything else, I
; am making a new type lex_rule_super that is just like the current lex_rule
; except that it doesn't identify the messages, and then having lex_rule do
; that identification.

lex_rule_super := word &
  [ DTR #stem &
	[ SYNSEM.LOCAL local &
		       [ CAT.ROOT #root,
			 CONT [ COMPKEY #ckey,
				OCOMPKEY #ockey,
				H-STORE #hstore,
				MODCONT #mcont ],
			 CONJ cnil,
			 CTXT.C-INDS #c-inds ] ],
    SYNSEM.LOCAL local &
	[ CAT.ROOT #root,
	  CONT [ COMPKEY #ckey,
		 OCOMPKEY #ockey,
		 H-STORE #hstore,
		 MODCONT #mcont ],
	  CONJ cnil,
	  CTXT.C-INDS #c-inds ],
    ARGS < #stem > ],
  status: lex-rule.

lex_rule := lex_rule_super &
   [ DTR.SYNSEM.LOCAL.CONT.MESSAGE #msg,
     SYNSEM.LOCAL.CONT.MESSAGE #msg ].

;;
;;  Forms derived from inflected verbs
;;

; ERB (05-10-97) Before we had a special rule hcomp_yn_root for matrix polar
; questions.  Now, the unique head complement rule is taking over this job.
; To do this, we must put the int_rel onto the inverted auxiliaries (see also
; sai_synsem).  The original objection to this was that the inverted
; auxiliaries are used for things other than matrix questions (i.e., negative
; inversion).  However, a) we don't currently have an analysis of negative
; inversion, and b) it's not clear that they are the same auxiliaries.  The
; most obvious test -- 1st person aren't -- is not available since the
; contracted auxiliaries are in general disallowed in negative inverstion
; (polarity effect?).
;
; At the moment this is allowing "Will who sleep?" and "Will Kim see who?"
; (actually two parses of the latter).  This is fine, except that this is not
; producing the apropriate semantics.  In fact, all ynq (matrix and
; subordinate) are not currently specified for PARAMS.  I think this will be
; easier to fix once we have a) lexical threading and b) an implementation of
; the analysis of echo questions, so I am leaving it for later.
 
sai := lex_rule_super &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD #head & verb &
				      [ INV +,
					VFORM fin ],
				 VALENCE [ SUBJ #subj,
					   COMPS #comps,
					   SPR #spr,
					   --KEYCOMP #keycomp ],
				 MOD #mod ],
			   CONT [ INDEX #ind,
 				  LISZT #liszt,
 				  KEY #key,
				  H-CONS #hcons ],
			   ARG-S #arg-s ],
		   NON-LOCAL [ SLASH #slash,
			       QUE #que ] ] ],
    SYNSEM sai_synsem &
	 [ LOCAL [ CAT [ HEAD #head, 
			 VALENCE [ COMPS < #subj & [ OPT - ] . #comps >,
				   SPR #spr,
				   --KEYCOMP #keycomp ],
			 MOD #mod ],
		   CONT [ INDEX #ind,
			  LISZT #liszt,
			  KEY #key,
			  H-CONS #hcons ],
		   ARG-S #arg-s ],
	   NON-LOCAL [ SLASH #slash,
		       QUE #que ] ] ].

tag := lex_rule_super &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD [ TENSE #tense,
				      MOOD indicative ],
			       VALENCE [ SUBJ none,
					 COMPS.FIRST #subj ] ],
			 CONT.KEY #key ],
		 NON-LOCAL.SLASH #slash ] ],
		       
    SYNSEM tag_synsem &
	 [ LOCAL [ CAT [ HEAD [ TENSE #tense ],
			 VALENCE.COMPS.FIRST #subj ],
		   CONT.KEY #key ],
	   NON-LOCAL.SLASH #slash ] ].

neg_addition := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD #head & verb & [ AUX +,
						       INV -,
						       VFORM fin ],
				 VALENCE [ SUBJ #subj,
					   COMPS #comps &
					      < [ LOCAL.CAT.HEAD subst ], ...>,
					   SPR #spr,
					   --KEYCOMP #keycomp ],
				 MOD #mod ],
			   CONT [ HANDEL #vhand,
				  INDEX #vindex,
				  KEY #vkey,
				  H-CONS #hcons,
				  LISZT #vliszt ],
			   CTXT #ctxt,
			   ARG-S #arg-s ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   VALENCE [ SUBJ #subj,
				     COMPS *cons* &
				      < [ LOCAL local &
						[ CAT [ HEAD neg,
							--SCOPEDARG.LOCAL
							 local &
							 [ CONT
							  [ HANDEL #vhand,
							    H-STORE <! !> ] ]],
						  CONT.KEY.HANDEL #neghand ],
					  OPT - ] . #comps >,
				     SPR #spr,
				     --KEYCOMP #keycomp ],
			   MOD #mod ],
		     CONT [ HANDEL #neghand,
			    INDEX #vindex,
			    LISZT #vliszt,
			    H-CONS #hcons,
			    KEY #vkey & [ HANDEL #vhand ] ],
		     CTXT #ctxt,
		     ARG-S #arg-s ],
	     NON-LOCAL #nonloc ] ].

;; Need to work on generalizing the semantics - since we derive this entry
;; from the past participle, we have to discard the tense information from
;; the input - not clear yet how to do this in general.  For now we assume
;; that transitive verbs introduce a single relation, bound to the KEY attrib.

; This incorrectly orders the by_pp before all remaining comps - wrong for
; double-NP verbs, and incomplete for verbs with other oblique arguments,
; since this allows only one order.  But this latter is a general problem.

passive_verb := lex_rule &
  [ STEM #orth,
    DTR [ ORTH #orth,
	  SYNSEM trans_subst &
	       [ LOCAL [ CAT [ HEAD verb & [ VFORM psp ],
			       VALENCE [ SUBJ.LOCAL local &
						    [ CONT.INDEX #subjind,
						      THROLE #subjrole ],
					 SPR #spr,
					 COMPS [ FIRST.LOCAL local &
							[ CONT #objcont,
							  THROLE #objrole ],
						 REST #comps ] ] ],
			 CONT [ HANDEL #hand,
				INDEX #ind,
				H-CONS #hcons,
				KEY #key ],
			 CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM modifier_synsem &
	 [ LOCAL verb_participle_affix &
		 [ CAT [ HEAD [ AUX -,
				VFORM pas,
				VOICE passive ],
			 VALENCE [ SUBJ synsem & @nomp() &
					[ LOCAL [ CONT #objcont &
						       [ INDEX non_expl-ind ],
						  THROLE #objrole ] ],
				   SPR #spr,
				   COMPS < synsem & 
					   [ LOCAL local &
					     [ CAT [ HEAD prep,
						     VALENCE [ SUBJ none,
							       SPR *olist*,
							     COMPS *olist* ] ],
					       CONT.KEY _by_pass_rel &
						   [ PREP #subjind ],
					       THROLE #subjrole ],
					     OPT + ]
					   . #comps > ] ],
		   CONT [ HANDEL #hand,
			  INDEX #ind,
			  H-CONS #hcons,
			  LISZT <! #key !> ],
		   CTXT #ctxt ],
	   NON-LOCAL #nonloc ] ].

#|
; it-extraposition

it-extraposition := lex_rule &
  [ STEM #orth,
    DTR [ ORTH #orth,
	  SYNSEM extraposable_synsem &
	       [ LOCAL [ CAT [ HEAD #head,
			       VALENCE [ SUBJ.LOCAL local &
						    [ CONT.INDEX #subjind,
						      THROLE #subjrole ],
					 COMPS #comps ] ] ],
			 CONT #cont,
			 CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM expl_it_subj_synsem &
	 [ LOCAL [ CAT [ VALENCE [ SUBJ synsem & @nomp() &
					[ LOCAL.CONT.INDEX it-ind ],
				   COMPS < @cp($vform=fin) &
					   [ LOCAL [ CONT.INDEX #subjind,
						     THROLE #subjrole ],
					     OPT - ]
					   . #comps > ] ],
		   CONT #cont,
		   CTXT #ctxt ],
	   NON-LOCAL #nonloc ] ].
|#

;; This has the same problem as the passive lexical rule.  Since we derive the
;; gerund from the present particple, we somehow have to filter out the
;; progressive relation.

verbal_gerund := lex_rule &
  [ STEM #orth,
    DTR [ ORTH #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ CAT [ HEAD verb & [ VFORM prp ],
			       VALENCE.COMPS #comps,
			       ARG-S #args ],
			 CONT [ HANDEL #hand,
				H-CONS #hcons,
				KEY #key ],
			 CTXT #ctxt ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM nonpronominal_synsem & nomod_synsem &
	   [ LOCAL [ CAT [ HEAD gerund,
			   VALENCE.COMPS #comps,
			   ARG-S #args ],
		     CONT [ HANDEL #hand,
			    INDEX #ind &
				   [ PNG 3sg_n ],
			    LISZT <! #key, 
				     gerund_rel & #nkey &
				     [ INST #ind,
				       NOMARG #hand ] !>,
			    H-CONS #hcons,
			    KEY #nkey ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc ] ].

poss_ing := verbal_gerund &
  [ DTR.SYNSEM [ LOCAL.CAT.VALENCE.SUBJ.LOCAL.CONT.INDEX #subj,
		 NON-LOCAL.SLASH <! !> ],
    SYNSEM.LOCAL [ CAT.VALENCE [ SUBJ none,
				 SPR < [ LOCAL local &
					 [ CAT [ HEAD det & [ POSS + ],
						 VALENCE [ SUBJ none,
							   COMPS *olist* ] ],
					   CONT.COMPKEY [ POSSD #ind,
							  POSSR #subj ] ],
					 OPT + ] > ],
		   CONT.INDEX #ind ] ].

acc_ing := verbal_gerund &
  [ DTR.SYNSEM.LOCAL.CAT.VALENCE.SUBJ.LOCAL.CONT #subj,
    SYNSEM.LOCAL.CAT.VALENCE [ SUBJ @np($case=acc) &
				    [ LOCAL.CONT #subj ],
			       SPR < > ] ].

nominal_gerund := lex_rule &
  [ STEM #orth,
    DTR [ ORTH #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ CAT [ HEAD verb & [ VFORM prp,
					     AUX - ],
			       VALENCE.SUBJ.LOCAL local &
				    [ CONT.INDEX #subj ],
			       ARG-S #args ],
			 CONT [ HANDEL #vhand,
				KEY #vkey ],
			 CTXT #ctxt ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM nonpronominal_synsem & nomod_synsem &
	   [ LOCAL 
	     [ CAT 
	       [ HEAD cnoun,
		 VALENCE [ SUBJ none,
			   SPR < [ LOCAL local &
					 [ CAT [ HEAD det,
						 VALENCE [ SUBJ none,
							   COMPS *olist* ] ],
					   CONT [ INDEX #ind,
						  ALTKEY.POSSR #subj,
						  KEY [ HANDEL #dethand,
							RESTR #arg ] ] ],
				   OPT + ] > ],
		 ARG-S #args ],
	       CONT [ HANDEL #hand,
		      INDEX #ind & [ PNG 3sg_n ],
		      LISZT <! #key & nominalize_rel & 
			              [ HANDEL #hand,
					INST #ind,
					NOMARG #vhand ],
			     #vkey & [ HANDEL #vhand ] !>,
		      KEY #key,
		      H-CONS <! is-one-of &
				 [ SC-ARG #arg,
				   CANDS < #hand > ],
				 outscopes & 
				 [ SC-ARG #dethand,
				   OUTSCPD #hand ] !> ],
	       CTXT #ctxt ],
	     NON-LOCAL #nonloc ] ].

intrans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM intrans_subst & 
	       [ LOCAL.CAT.VALENCE.COMPS #comps ],
    SYNSEM.LOCAL.CAT.VALENCE.COMPS #comps ].


;; This is too restrictive.  It only forms nominal gerunds from strictly
;; transitive verbs.  So, it doesn't give you "Kim's putting of food on the
;; table" or "Kim's warning of Sandy that it would rain" or "Kim's giving of
;; raisins to the ants".  
;;  To avoid ambiguity with the intranstive nominal gerund, we make the PP
;; obligatory.
trans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM trans_subst & 
	       [ LOCAL.CAT.VALENCE.COMPS < [ LOCAL local &
						   [ CONT.INDEX #index ] ] > ],
    SYNSEM.LOCAL.CAT.VALENCE.COMPS < @pp() &
				     [ LOCAL.CONT [ INDEX #index,
						    KEY _of_rel & 
							[ PREP #index ] ],
				       OPT - ] > ].

date_det_lr := lex_rule &
  [ STEM #orth,
    DTR [ ORTH #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD noun,
				  VALENCE [ SPR < >,
					    COMPS < [ OPT + ] > ] ],
			   CONT [ HANDEL #hand,
				  LISZT [ LIST #list,
					  LAST #last ],
				  H-CONS #hcons,
				  KEY #altkey ],
			   CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD det,
			   VALENCE [ SUBJ none,
				     SPR < >,
				     COMPS < > ] ],
		     CONT [ HANDEL #hand,
			    INDEX #ind,
			    LISZT [ LIST < #key & def_rel . #list >,
				    LAST #last ],
			    KEY #key &
				[ HANDEL #hand,
				  BV #ind ],
			    H-CONS #hcons,
			    ALTKEY #altkey ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc ] ].

; "October": NP => Determiner
;          "(in) October" => "October first"

month_det_lr := date_det_lr &
  [ DTR.SYNSEM.LOCAL.CONT.KEY mofy_rel ].

; "Tuesday": NP => Determiner
;          "(on) Tuesday" => "Tuesday morning"

weekday_det_lr := date_det_lr &
  [ DTR.SYNSEM.LOCAL.CONT.KEY dofw_rel ].

adj_noun_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ CAT [ VALENCE [ COMPS #comps,
					   SPR < #spr > ],
				 HEAD adj & [ PRD - ] ],
			   CONT [ KEY.HANDEL #ahand,
				  LISZT [ LIST #list,
					  LAST #last ],
				  MESSAGE #msg ],
			   CTXT #ctxt ],
		   NON-LOCAL #non-local ] ],
    SYNSEM adj_noun_synsem & 
	  [ LOCAL [ CAT [ VALENCE [ COMPS #comps,
				    SPR < #spr, ... > ] ],
		    CONT [ KEY #key & [ NOMARG #ahand ],
			   LISZT [ LIST < #key . #list >,
				   LAST #last ],
			   MESSAGE #msg ],
		    CTXT #ctxt ],
	    NON-LOCAL #non-local ] ].

adj_noun_personal_lr := adj_noun_lr &
  [DTR.SYNSEM.LOCAL.CONT.KEY adj_personal_rel,
   SYNSEM adj_noun_personal_synsem].

adj_noun_abstract_lr := adj_noun_lr &
  [DTR.SYNSEM.LOCAL.CONT.KEY adj_abstract_rel,
   SYNSEM adj_noun_abstract_synsem].


;; The partitive construction rule introduces a new type of relation: 
;; part_of_rel, which contains the semantic information of the partitive.
;; The features of the relation, a subtype of nom_rel, are
;; - HANDEL, 
;; - INST, the index of the NP,
;; - SET, the handle of the PP complement, defining the set of which the head 
;;        determines a subset,
;; - NPREP,the index of the PP complement of the head, which is actually the
;;        index of the NP complement of that PP.
;; The idea is that there is a difference between, for example, "some books", 
;; and "some of the books". In the first case, "books" can refer to a subset
;; of the set of all the existing books, and "some" quantifies over the 
;; set of all existing books. In the second case, "some" refers to a subset of
;; the set of books defined by "the books": that set cannot refer to the 
;; universal set of all existing books. The relation "part_of_rel" tries to
;; capture that notion of subset of a certain set (defined by the context, or 
;; the determiner of the NP complement): the subset has an index 
;; (INST), and the defined set is referred to by "SET", which is the handle of
;; the prepositional phrase, and also the handle of the determiner of the 
;; prepositional complement.  We thus give partitives a complex lexical
;; semantics, including both the part_of_rel and the original quantifier
;; relation, with its usual attributes.

;; A problem which remains is to get the right agreement with the right head.
;; At the moment, the index of the head is the same as the index of the 
;; original determiner. As an example, "all" can be mass or plural, and is 
;; going to agree with a singular or a plural verb, whatever its complement is
;; ("all of the cake", "all of the students"). If we decide to have the index
;; of the construction being the index of the complement noun, what about 
;; "each" ? "Each of the boys" will agree with a plural only, when it should
;; agree with a singular. On the other hand, there is also the problem of 
;; "all of the oats are", plural when "all" is the mass determiner here: 
;; agreement is determined, here, by the plural form of the complement noun.

part_constr := lex_rule &
 [ STEM #orth,
   DTR [ ORTH #orth,
         SYNSEM part_det_synsem & 
	  [ LOCAL.CONT [ HANDEL #hand,
			 KEY #relation ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM partitive_noun_synsem & 
     [ LOCAL.CONT [ HANDEL #hand,
		    ALTKEY #relation ],
       NON-LOCAL #nonlocal ] ].


; NP-particle alternation (e.g. "look up the answer/look the answer up"

NP_particle_lr := lex_rule &
 [ STEM #orth,
   DTR [ ORTH #orth,
         SYNSEM particle_NP_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  MOD #mod,
			  VALENCE [ SUBJ #subj,
				    COMPS < [ OPT #opt1 ], [ OPT #opt2 ] > ] ],
		    CONT #cont,
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM NP_particle_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  MOD #mod,
			  VALENCE [ SUBJ #subj,
				    COMPS < [ OPT #opt2 ], [ OPT #opt1 ] > ] ],
		    CONT #cont,
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ].

dative_shift_lr := lex_rule &
 [ STEM #orth,
   DTR [ ORTH #orth,
         SYNSEM ditrans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  MOD #mod,
			  VALENCE.SUBJ #subj ],
		    CONT #cont,
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM to_trans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  MOD #mod,
			  VALENCE [ SUBJ #subj,
				    COMPS < [ OPT - ], [ OPT - ] > ] ],
		    CONT #cont,
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ].

:begin :instance.

taglr := tag.

sailr := sai.

negadd := neg_addition.

passive := passive_verb.

;; accing := acc_ing.

possing := poss_ing.

intransng := intrans_nominal_gerund.

transng := trans_nominal_gerund.

monthdet := month_det_lr.

weekdaydet := weekday_det_lr.

; Comment out for now - too much ambiguity
;adj_noun := adj_noun_lr.

partitive := part_constr.

NP_part_lr := NP_particle_lr.

dative_lr := dative_shift_lr.

:end :instance.

;;
;; Derivational rules 
;;

agent_nom_rel := reg_nom_rel & arg_rel.

; This lexical rule should be applied by hand, e.g.: 
;
; :leval (apply-lexical-rule 'simple_agent_nominal 'walk1 "walker").
;
; Also, this type ought to inherit from the type intr_noun_word, but that type
; assumes that all common nouns have a singleton STEMLISZT. 

simple_agent_nominal := lex_entry & norm_word & affix_bearing &
  [ DTR.SYNSEM [ LOCAL [ CAT [ HEAD verb &
				    [ AUX -,
				      INV -,
				      VFORM bse ],
			       VALENCE.SUBJ.LOCAL local &
				    [ CONT.INDEX #sindex ] ],
			 CONT [ HANDEL #vhand,
				STEMLISZT [ LIST #vlist,
					    LAST #vlast ] ] ] ],
    SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.VALENCE.SPR < [ LOCAL.CONT.KEY quant_rel ] >,
		     CONT [ INDEX #sindex,
			    KEY agent_nom_rel &
				  [ ARG #vhand ],
			    STEMLISZT [ LIST.REST #vlist,
					LAST #vlast ] ] ] ] ].

