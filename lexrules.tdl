;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2013
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see LICENSE for conditions
;;;
;;;  lexrules.tdl
;;;
;;;  Inflectional affixes and derivational lexical rules
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;
;;;  $Id: lexrules.tdl 7479 2010-02-21 23:11:30Z danf $


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Inflectional affixes
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Verbal inflections

non_fin_verb := local & 
  [ CAT.HEAD verb ].

; Need to constrain MOD value for PRP verbs.  Also for passive participles.

;; Verbal affix for present and passive participles, which can modify N-bars
;; DPF (7-Apr-99) Removed POSTHD - since the head_complement rule now passes
;; up the value of POSTHD from the head-dtr, so we need to leave it unmarked
;; to get "managers interviewed by Abrams" on the passive-by reading, and also
;; to still get "the interviewed managers"

;; Present participles and passives are both marked as PRD +, to block e.g. 
;; "the destroyed by Sandy chair" or "the talking to Kim consultant", but then
;; to get these participles alone in attributive position, we need a 
;; generalization of the attributive-adjective lexical rule below.
;; DPF 19-Feb-01 - To avoid massive unwanted ambiguity as in "Kim is sleeping"
;; restrict the MOD value to [AUX -].  
;; DPF 24-Mar-01 - Added SUBJ..SLASH 0-dlist to avoid spurious gaps.
;; DPF 18-Aug-01 - Removed [SUBJ.OPT -] to allow participle phrases without
;; subjects to be no-copula clauses, as in "arriving tomorrow".
;; DPF 24-Sep-01 - Added [MOD..TENSE real_tense as hack to block participles
;; from modifying nocop VPs, as in "partial clearing" - works since nouns have
;; underspecified TAM.
;; DPF 18-Apr-03 - From 19-Feb-01 - This also blocks "I am available starting
;; on Monday"
;; DPF 27-Apr-03 - Note that in blocking ambiguity for "Kim is sleeping"
;; (see 19-Feb-01), we also prevent an analysis for "Kim is happy driving",
;; so probably want to remove this constraint once parse ranking can carry the
;; load, given that there are also contexts where we want "Kim is, sleeping"
;;
verb_participle_affix := local &
  [ CAT [ HEAD verb & [ PRD + ],
	  VAL.SUBJ < synsem &
		     [ LOCAL.AGR #agr,
		       NONLOC.SLASH 0-dlist ] >,
	  HC-LEX - ],
    AGR #agr ].

prp_verb := non_fin_verb & verb_participle_affix &
  [ CAT.HEAD [ VFORM prp,
	       TAM.ASPECT [ PROGR + ] ] ].

; DPF 27-May-01 - Removed [ASPECT.PRF +] since this form is also used for
; passives, and since the auxiliary "have" already imposes PRF + on the
; relevant event.
; DPF 11-Nov-03 - Gave up on using past-participle form as input for passive,
; since this lack of constraint on PROGR created too much trouble for 
; generation, since "Kim has arrived" didn't say [PROGR -] so we could get
; 'Kim is being hired'.  One disadvantage is that we have to stipulate
; duplicate irregular passive forms for the irregular past participles.
; DPF 25-Oct-06 - Removed PROGR - since we want to parse "having arrived",
; and since the 11-Nov-03 difficulty has been resolved.

psp_verb := non_fin_verb &
  [ CAT [ HEAD [ VFORM psp,
                 TAM.ASPECT.PRF +,
		 PRD - ],
	  VAL.SUBJ < [ OPT - ] > ] ].

; DPF 12-May-00 - bse_verb needs to have [ MOD nbar ] to enable coordination
; of imperative and declarative clauses, as in "Leave and I will follow you"
; DPF 17-Oct-01 - Made ASPECT be no_aspect rather than no_aspect* in order to
; let K2Y distinguish true base-VPs from participles.
; DPF 7-Nov-03 - Remember that bse_verb can't have TENSE no_tense (which would
; be convenient for generation) since it can combine with "do" as in "did the
; dog bark?"
; DPF 12-aug-07 - Removed constraint < SUBJ unexpressed_reg > since we want
; to parse "Kim suggested we be early".

bse_or_non3sg_verb := local &
  [ CAT [ HEAD [ VFORM fin_or_bse_or_imp,
                 PRD -,
		 TAM.ASPECT no_aspect,
                 --ADDIN [ ADDPN -3s,
			   ADDTAM indic_tam & [ TENSE present ] ] ],
          POSTHD +,
	  VAL.SUBJ < synsem & [ OPT -,
                                LOCAL [ CAT.HEAD.CASE nom,
                                        CONT nom-obj,
                                        CONJ cnil,
                                        AGR #agr ] ] > ],
    AGR #agr ].

; Only used for unknown verbs
bse_verb := non_fin_verb & bse_or_non3sg_verb &
  [ CAT.HEAD.VFORM bse ].

; Since finite verbs can project relative clauses, we introduce [MOD < nbar >]
; here, and make sure that no other projections of finite verbs can be
; adjuncts, through constraints on the head-adjunct phrase type.
; DPF 4-Mar-01 - Removed [CONT.MSG no_msg] from SUBJ, to allow e.g.
; "me hiring you bothered him"

basic_fin_verb := local &
  [ CAT [ HEAD verb &
               [ PRD -,
		 VFORM fin ],
	  POSTHD +,
	  VAL.SUBJ < synsem & [ LOCAL [ CAT.HEAD.CASE nom,
                                        CONJ cnil ] ] > ] ].

fin_verb := basic_fin_verb & 
  [ CAT.VAL.SUBJ < [ OPT - ] > ].

pres_verb := fin_verb & 
  [ CAT.HEAD.TAM indic_tam &
		 [ TENSE present,
		   ASPECT no_aspect ] ].

; DPF 06-mar-06 - Can't identify SUBJ's --SIND..PN and AGR..PN since we now
; have sentential subjects where the --SIND value is a handle which does not
; have a PNG attribute.  Instead, make SUBJ's AGR..PN unify with verb's.

past_or_subj_verb := fin_verb &
  [ CAT [ HEAD.TAM past_or_subj_tam,
          VAL.SUBJ.FIRST.LOCAL.AGR.PNG.PN #pn ],
    AGR.PNG.PN #pn ].

; DPF 30-Sept-05 - Tempted to make --SIND..PN 3s to improve generator 
; efficiency (not proposing 3sg verb when argument is plural).  But this
; desire clashes with assumption that syntactic AGR and semantic INDEX are
; not always identical, e.g. for treatment of numerals as in "Six is even."
; where the semantics of the adjective "six" has a plural index, but the
; hdn_np-num_c rule makes a syntactically singular nominal out of it.  So we
; (currently) have to live with the extra work in generation.  Or maybe
; we add PNG to restrictor, since it rarely helps given above assumption
; about potential mismatch.

third_sg_fin_verb := pres_verb &
  [ CAT.VAL.SUBJ < [ LOCAL.AGR.PNG.PN 3s ] >,
    AGR.PNG png & [ PN 3s ] ].

; Only used for unknown verbs
non_third_sg_fin_verb := pres_verb & bse_or_non3sg_verb &
  [ CAT.VAL.SUBJ < [ LOCAL local & [ CONT nom-obj ] ] >,
    AGR.PNG png & [ PN -3s ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Nominal inflections

noun_local := local &
  [ CONT.HOOK.INDEX nonconj_ref-ind ].

sing_noun := noun_local &
  [ CAT [ HEAD noun_or_ttl,
          VAL.SPR.FIRST.LOCAL.AGR [ PNG.PN 3s,
				    DIV - ] ],
    CONT.HOOK.INDEX [ PNG png & [ PN 3s ],
                      DIV - ] ]. 

mass_noun := noun_local &
  [ CAT [ HEAD noun_or_ttl,
          VAL.SPR < [ LOCAL.AGR [ PNG.PN 3s,
                                  DIV + ] ] > ],
    CONT.HOOK.INDEX [ PNG png & [ PN 3s,
                                  GEN neut ],
		      DIV + ] ]. 

mass_count_noun := noun_local &
  [ CAT [ HEAD noun_or_ttl & [ --BARE - ],
          VAL.SPR < [ LOCAL.AGR.PNG.PN 3s ] > ],
    CONT.HOOK.INDEX.PNG png & [ PN 3s ] ].

plur_noun := noun_local &
  [ CAT [ HEAD noun_or_ttl,
          VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                  DIV + ] ] > ],
    CONT.HOOK.INDEX [ PNG png & [ PN 3p ],
                      DIV + ] ].

;; As a hack to prevent inflected nouns in certain constructions, add this:
noninfl_noun_local := noun_local.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Adjectival inflections
;;
;;  May-96: Martina

pos_adj := local &
  [ CAT [ HEAD adj,
          VAL.SPR < [ --MIN very_deg_rel ] > ] ].


er_comp_adj := local &
  [ CAT [ HEAD adj,
          VAL.SPR < [ --MIN much_deg_rel ] > ] ].


est_super_adj := local &
  [ CAT [ HEAD adj,
          VAL.SPR < [ --MIN def_explicit_q_rel,
                      OPT - ] > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Place holder affix for -ly

-ly := local & [ CAT.HEAD no_head ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  (Non-inflectional) lexical rules
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; AAC - INFLECTD added so that the relationship between inflectional 
;;; morphology and lexical rules can be represented declaratively
;;;
;;; lex_rule_infl turns uninflected things into inflected ones
;;; but otherwise does inheritance
;;; everything else requires inflected forms
;;; ND-AFF ('needs affix') is used to determine whether a rule has an overt
;;; suffix which triggers the spelling-change rules.

lex_rule_supermost := word_or_lexrule &
  [ ND-AFF bool,
    DTR sign & [ IDIOM #idiom,
                 DIALECT #dialect,
		 ALTS #alts,
                 SYNSEM.LOCAL local & 
                              [ CONT [ RELS [ LIST #rfirst,
                                              LAST #rmiddle ],
                                       HCONS [ LIST #hcfirst,
                                               LAST #hcmiddle ],
				       ICONS [ LIST #icfirst,
                                               LAST #icmiddle ] ] ] ],
    IDIOM #idiom,
    DIALECT #dialect,
    ALTS #alts,
    SYNSEM abstr_lex_synsem & 
           [ LOCAL local &
                   [ CONT [ RELS [ LIST #rfirst,
                                   LAST #rlast ],
                            HCONS [ LIST #hcfirst,
                                    LAST #hclast ],
			    ICONS [ LIST #icfirst,
                                    LAST #iclast ]] ] ],
    ORTH [ TO #to,
	   CLASS #class,
	   FORM #form ],
    ARGS.FIRST.ORTH [ TO #to,
		      CLASS #class,
		      FORM #form ],
    C-CONT [ RELS [ LIST #rmiddle,
                    LAST #rlast ],
             HCONS [ LIST #hcmiddle,
                     LAST #hclast ],
	     ICONS [ LIST #icmiddle,
                     LAST #iclast ]] ].


; DPF 14-Aug-99 - Reorder appending of RELS from above since treatment of 
; fragments looks for the first scope hole from left to right in RELS, and 
; the first definition below gives different results for "October first" and 
; "the first of October".
; DPF 22-May-00 - But lexical rules in general may want to change categories,
; and the output's properties should conform to the type; for example, the
; rule for partitives wants to have the output be a noun, so the first element
; on RELS should be a nom_rel, not the quant_rel which the DTR would supply.
; So we go back to the original appending model, and leave the proper
; treatment of scope holes in fragments for later solutions.

lex_rule_basic := lex_rule_supermost & word_or_nonpunct_rule &
  [ DTR [ SYNSEM [ LOCAL.CONJ cnil,
                   PUNCT #punct & [ LPUNCT no_punct,
				    RPUNCT no_punct ] ],
          GENRE #genre ],
    SYNSEM [ LOCAL.CONJ cnil,
             PUNCT #punct,
	     PHON.ONSET #onset ],
    ARGS.FIRST.SYNSEM.PHON.ONSET #onset,
    GENRE #genre ].

;; DPF 2014-08-19 - Make dtr be word_or_nonpunct_rule  to prevent inflectional 
;; rules from applying spuriously after the italics rules (or other punctuation
;; rules) have applied.
;;
lex_rule_infl_affixed := lex_rule_basic & word_or_infl_rule &
  [ INFLECTD +,
    KEY-ARG #keyarg,   
    SYNSEM #synsem,
    ARGS < #dtr >,
    DTR #dtr & word_or_nonpunct_rule &
	       [ INFLECTD -,
                 KEY-ARG #keyarg,   
                 SYNSEM #synsem ],
    C-CONT.RELS <! !> ].

lex_rule := lex_rule_basic &
  [ DTR word_or_lexrule & #stem &
	[ INFLECTD +,
          SYNSEM.LOCAL [ CAT [ MC #mc,
                               HC-LEX #hclex ] ],
          KEY-ARG #keyarg ],
    SYNSEM [ LOCAL [ CAT [ MC #mc,
                           HC-LEX #hclex ] ] ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    INFLECTD + ].

;;
;;  Forms derived from inflected verbs
;;

; ERB (05-10-97) Before we had a special rule hcomp_yn_root for matrix polar
; questions.  Now, the unique head complement rule is taking over this job.
; To do this, we must put the int_m_rel onto the inverted auxiliaries (see also
; sai_synsem).  The original objection to this was that the inverted
; auxiliaries are used for things other than matrix questions (i.e., negative
; inversion).  However, a) we don't currently have an analysis of negative
; inversion, and b) it's not clear that they are the same auxiliaries.  The
; most obvious test -- 1st person aren't -- is not available since the
; contracted auxiliaries are in general disallowed in negative inverstion
; (polarity effect?).
;
; At the moment this is allowing "Will who sleep?" and "Will Kim see who?"
; (actually two parses of the latter).  This is fine, except that this is not
; producing the apropriate semantics.  In fact, all ynq (matrix and
; subordinate) are not currently specified for PARAMS.  I think this will be
; easier to fix once we have a) lexical threading and b) an implementation of
; the analysis of echo questions, so I am leaving it for later.
 
; DPF (10-Jan-99) Added SUBJ value identified with dtr's SPR value (usually
; < anti_synsem > which never unifies with real synsem), in order to allow 
; adjunct extraction to still apply to inverted sentences such as "When is 
; Kim happy" where "is Kim happy" is built by two applications of the head_comp
; rule.  By identifying SUBJ with dtr's SPR, we can maintain lexical control
; over modifiability, in particular blocking spurious modification of 
; auxiliary "do", both in noninverted and inverted clauses.
; DPF 22-Apr-00 - Added reentrancy for VFORM on DTR and mother - don't know
; why this was omitted before.  It's needed to block spurious parse for e.g. 
; "Could you sleep please"
; DPF 5-Jul-02 - Removed re-entrancy of SYNSEM..SUBJ..INDEX with dtr's, since
; it was wrecking coordination of "did Kim win or did Sandy win, since the
; SUBJ..INDEX got identified for both.  So what do we give up?
 
; ERB (2003-10-13) Making a supertype to keep mal_sai as close to sai as
; possible.

basic_sai := lex_rule &
  [ ORTH #orth,
    DTR #stem &
     [ ORTH #orth,
       SYNSEM 
        [ LOCAL [ CAT [ HEAD verb &
                             [ VFORM fin & #vform,
                               TAM #tam,
                               MINORS #mins ],
                        VAL [ SUBJ < #subj & canonical_synsem &
                                     [ LOCAL [ CAT nomp_cat_nom ] ] >,
                              COMPS #comps,
                              SPR #spr,
			      SPCMPS #spcmps,
                              KCMP #keycomp ] ],
                  AGR #agr ],
          NONLOC #nonloc,
	  MODIFD #modif,
	  LKEYS.KEYREL [ CFROM #cfrom, CTO #cto ] ] ],
    SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				  TAM #tam,
				  MINORS #mins ],
			   VAL [ COMPS < #subj & [ OPT - ]
					 . #comps >,
				 SPR #spr,
				 SPCMPS #spcmps,
				 SUBJ < anti_synsem >,
				 KCMP #keycomp ] ],
		     AGR #agr ],
	     NONLOC #nonloc,
	     MODIFD #modif,
	     LKEYS.KEYREL [ CFROM #cfrom, CTO #cto ] ],
    C-CONT.ICONS <! !>,
    ARGS < #stem > ].

; DPF 28-mar-05 - Now propagate AUX from daughter, since we need cop-id to
; be unmarked for AUX, so it can be modified by PPs, as in "where is Kim the
; king?"
; DPF 20-oct-09 - In fact, we won't propagate AUX so we can also get e.g.
; "how old will Kim be on Tuesday", where we're still trying to avoid spurious
; ambiguity by not attaching PPs to AUX + phrases, but we need to in this
; inverted sentence construction because there is no "lower" VP to attach the
; modifier to.

sai := basic_sai &
  [ SYNSEM basic_sai_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < [ --MIN no_rel,
					LOCAL intersective_mod &
					      [ CAT.VAL.SPR *cons* ] ] >,
			   POSTHD + ],
		     CONT.HOOK #hook ] ],
    DTR.SYNSEM.LOCAL [ CAT.HEAD.INV +,
		       CONT.HOOK #hook ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

;; DPF 2012-09-10 - Changed MOD..NONLOC non-local_none to REL,QUE 0-dlist,
;; to allow non-empty SLASH, as in |on the other hand, had they stayed, Kim
;; would have cried|

cond_sai := basic_sai &
  [ SYNSEM basic_sai_synsem &
	   [ LOCAL.CAT 
	      [ HEAD.MOD < synsem &
			   [ LOCAL scopal_mod &
				   [ CAT [ HEAD verb &
						[ MOD < anti_synsem_min > ],
					   VAL [ SUBJ *anti_list*,
						 COMPS < > ] ],
				     CONT.HOOK [ LTOP #modltop,
						 INDEX #modind ],
				     CONJ cnil ],
			     NONLOC [ REL 0-dlist,
				      QUE 0-dlist ] ] >,
		MC na ],
	     NONLOC non-local_none ],
    DTR [ SYNSEM [ LOCAL [ CAT [ HEAD [ INV +,
					TAM.MOOD basic_subjunctive ],
				 VAL.COMPS *substlist* ],
			   CONT.HOOK.LTOP #dltop ],
		   LKEYS.KEYREL [ CFROM #from, CTO #to ] ],
	  ALTS.CSAI + ],
    C-CONT [ HOOK [ LTOP #lbl,
		    INDEX #modind ],
	     RELS <! subord_relation &
		   [ LBL #lbl,
		     PRED "_if_x_then_rel",
		     ARG0 [ E [ TENSE no_tense,
				ASPECT no_aspect ] ],
		     ARG1 #main,
		     ARG2 #subord,
		     CFROM #from, CTO #to ] !>,
	     HCONS <! qeq & [ HARG #main,
			      LARG #modltop ],
		      qeq & [ HARG #subord,
			      LARG #dltop ] !> ] ].

tag := lex_rule_basic &
  [ ORTH #orth,
    INFLECTD +,
    DTR #stem &
	[ ORTH #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD verb &
                                    [ TAM #tam,
                                      MINORS [ MIN #min,
                                               ALTMIN ellipsis_rel ] ],
			       VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX.PNG #png ]>,
                               HC-LEX #hclex ],
                         CONT.HOOK [ LTOP #tltop,
                                     INDEX #index,
                                     XARG #xarg ],
                         AGR #agr ],
                 NONLOC #nonloc & non-local_none,
		 LKEYS.KEYREL [ CFROM #from, CTO #to ] ] ],
    SYNSEM tag_synsem &
	 [ LOCAL [ CAT [ HEAD [ TAM #tam,
                                MINORS.MIN #min,
                                MOD < [ LOCAL.CONT.HOOK [ LTOP #mltop,
                                                          XARG #subjind ]] > ],
                         VAL.COMPS.FIRST synsem & 
                                  [ LOCAL [ CAT nomp_cat_nom_min,
                                            CONT.HOOK.INDEX #xarg &
                                                [ PNG #png ],
                                            CONJ cnil ],
                                    OPT - ], 
                         HC-LEX #hclex ],
                   CONT.HOOK.INDEX #index,
                   AGR #agr ],
           NONLOC #nonloc,
	   LKEYS [ KEYREl [ CFROM #from,
			    CTO #to ],
		   ALTKEYREL [ CFROM #from,
			       CTO #to ] ] ],
    C-CONT [ HOOK.LTOP #ltop,
             RELS <! [ LBL #ltop,
                       PRED ne_x_rel,
                       ARG0 event,
                       ARG1 #mltop,
                       ARG2 #tltop,
		       CFROM #from, CTO #to ],
                     [ LBL #ltop,
                       PRED id_rel,
                       ARG0.E.TENSE no_tense,
                       ARG1 #subjind,
                       ARG2 #xarg,
		       CFROM #from, CTO #to ] !>,
             HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #stem > ].


; DPF 31-Jul-99 - Removed [INV -] from DTR, since it blocked entry for
; "Is that also important?"
; DPF 1-Jun-01 - Removed DTR..SUBJ canonical_synsem, since prevents relative
; clauses headed by these, as in "messages that are not valid fail".
; DPF 3-Jun-01 - Made DTR..VFORM fin rather than fin* to avoid V+ADV analysis
; of "be not happy"
; DPF 13-Sep-01 - Copy attributes of HEAD from dtr to mother, to make sure that
; dtr is [AUX +] but mother is [AUX +*] so it will still coordinate with nonaux
; ERB 2003-10-13 Make supertype to keep mal_adv_addition as close as possible.
; DPF 19-apr-05 - Block adv_addition rule from applying to negated auxiliaries,
; since these (uniquely) have ALT2KEYREL.PRED neg_rel, while the positive ones
; are unconstrained.
; DPF 25-nov-05 - Removed AUX + from mother, since it was preventing adjunct-
; extraction for e.g. "In Berlin, Browne is also Abrams"
; DPF 08-oct-06 - Note that this rule does not correctly get the scope right
; for "must not" which idiosyncratically gives the modal scope over the
; the neg_rel.  Can't simply split rule, since would have to overwrite the
; qeq in the lexical entry for "must" to insert neg_rel in scope chain.  So
; probably need to manually add separate "must not" lexical entry and block
; application of this rule to "must".  Then what about non-neg adverbs with
; "must"?  FIX someday.
;; DPF 2012-12-21 - Removed dtr's ALT2KEYREL.PRED never_unify_rel,
;; since this blocked e.g. |Kim isn't always Abrams|
;;
basic_adv_addition := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
          ALTS.ADVADD +,
	  SYNSEM aux_verb &
               [ LOCAL [ CAT [ HEAD verb &
				    [ VFORM #vform & fin,
				      TAM #tam,
				      AUX #aux,
				      INV #inv,
				      MOD #mod,
				      PRD #prd,
				      MINORS #minors  ],
			       VAL [ SUBJ #subj & < synsem >,
				     COMPS #comps & *substlist*,
				     SPR #spr ],
			       POSTHD #ph ],
			 CONT [ HOOK #hook &
                                     [ INDEX #vindex,
                                       XARG #xarg ] ],
                         CTXT #ctxt ],
		 NONLOC #nonloc ] ],
    SYNSEM aux_verb &
	 [ LOCAL 
	   [ CAT 
	     [ HEAD verb & [ VFORM #vform,
			     TAM #tam,
			     AUX #aux,
			     INV #inv,
			     MOD #mod,
			     PRD #prd,
			     MINORS #minors & [ ALTMIN #altmin ] ],
               VAL [ SUBJ #subj,
		     COMPS *cons* &
			  < [ LOCAL local &
			     [ CAT [ HEAD basic_lexadv &
                                     [ MOD < [ LOCAL [ CONT.HOOK #hook,
						       CAT [ HEAD.MINORS.ALTMIN 
									#altmin,
							     VAL.SUBJ #subj]]]>,
				       TAM #tam ],
                                     VAL.COMPS < > ],
                               CONT [ HOOK.LTOP #advltop ] ],
                              LEX +,
			      OPT - ] . #comps >,
		     SPR #spr ],
	       POSTHD #ph ],
	     CONT [ HOOK [ LTOP #advltop,
                           INDEX #vindex,
                           XARG #xarg ] ],
	     CTXT #ctxt ],
	   NONLOC #nonloc ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2013-11-08 - Split this rule into two, one for "not" and one for the
;; rest, since only "not" can be added to an elliptical aux verb, while they
;; can all appear with verbs that have overt complements.  Thus |we should not|
;; but |*we should never|, |*we should both|, etc.

adv_addition := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS *cons* ].

adv_add_neg_ellipt := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.MIN neg_rel ].

;; VP Ellipsis
;; We can't let this rule apply to the infinitival "to", since we would then
;; have no way of blocking the NP "the book to", where "to" first underwent
;; this rule, then the subject-extraction rule (needed for ordinary infinitival
;; relatives), and then the usual infinitival relative rule.  So instead we
;; create a separate lexical entry for the elided form of "to", and make it
;; MOD < >.
;; DPF 24-Jun-01 - Made DTR be TAM.ASPECT nonprg to prevent "Kim is being".
;; DPF 31-May-02 - This may not have been enough, so tried adding VFORM 
;; fin_or_bse.
;; DPF 28-Nov-03 - But then we don't get "Kim has been", so removed it; now
;; we should block "kim is being with the ASPECT.PROGR - constraint.
;; DPF 11-mar-05 - Removed AUX + since now restricting PPs to modify only
;; [AUX -] VPs.
;; DPF 2011-08-23 - For now, exclude elided verbs in inverted conditionals,
;; even though they can be okay at least in S-initial position, in context:
;; [We hadn't left the door open.] |Had we, the flies would have entered.|
;; But it's hard to find good examples in S-final position:
;; ... |? The files would have left, had we.|
;; And there is spurious ambiguity for e.g. |Who did we know were programmers?|

vp_ellipsis := lex_rule &
  [ ORTH #orth,
    ALTS.CSAI -,
    DTR [ ORTH #orth,
          ALTS.VPELLIP +,
	  SYNSEM aux_verb &
	   [ LOCAL 
             [ CAT 
               [ HEAD verb &
                      [ MOD #mod,
                        PRD #prd,
                        INV #inv,
			AUX +,
                        TAM #tam & [ ASPECT.PROGR - ],
                        VFORM #vform,
                        MINORS.MIN #min ],
                 POSTHD #ph,
                 VAL [ SUBJ #subj,
                       SPR #spr,
                       COMPS < canonical_or_unexpressed &
			       [ LOCAL [ CAT.HEAD subst,
                                         CONT.HOOK 
                                                  [ LTOP #chand,
                                                    INDEX #cind ] ],
				 NONLOC.SLASH 0-dlist ], ... > ] ],
	       CONT.HOOK [ LTOP #hand,
			   INDEX #ind ],
               CTXT #ctxt ],
             LKEYS [ KEYREL.PRED #keyrelpred,
                     ALT2KEYREL #alt2keyrel ],
             NONLOC #nonloc ] ],
    SYNSEM aux_verb &
	 [ LOCAL [ CAT [ HEAD verb & 
                              [ MOD #mod,
                                PRD #prd,
                                INV #inv,
                                TAM #tam,
                                VFORM #vform,
                                MINORS [ MIN #min,
                                         ALTMIN ellipsis_rel ] ],
                         POSTHD #ph,
			 VAL [ SUBJ #subj & 
				    [ FIRST.NONLOC [ QUE #que, REL #rel ] ],
			       SPR #spr,
			       COMPS < > ] ],
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #ind ] ],
                   CTXT #ctxt ],
           LKEYS [ KEYREL.PRED #keyrelpred,
                   ALTKEYREL #altkeyrel & arg1_relation &
                               [ LBL #chand,
                                 PRED ellipsis_rel,
                                 ARG0 #cind & non_conj_sement ],
                   ALT2KEYREL #alt2keyrel ],
           NONLOC #nonloc & [ QUE #que, REL #rel ] ],
    C-CONT [ RELS <! #altkeyrel !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

vp_ellipsis_ref := vp_ellipsis &
  [ DTR.SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --SIND #cind ] >,
                       CONT.HOOK.XARG non_expl-ind & #sind ],
    SYNSEM [ LOCAL.CONT.HOOK.XARG #sind,
	     LKEYS.ALTKEYREL [ PRED ellipsis_ref_rel,
			       ARG0 #cind,
			       ARG1 #sind ] ] ].
                   
; DPF 25-jul-05 - Block there-copula from undergoing ellipsis, since the
; (raising) predicative copula can also take a there-subject when elided.
; DPF 20-feb-10 - But blocking the there-copula meant that we had to have
; a bogus over-unification type `be_v_prd-or-there_rel' for tag questions
; like `There is a cat, isn't there', and eventually disadvantages of this
; unmotivated type emerged.  So go back to allowing this rule to apply to
; there-copula as well.
;; DPF 2012-06-12 - The INDEX value was wrongly reentrant with the ARG0 of 
;; the ALTKEYREL: this worked for the expletive-it ordinary copula `be' 
;; which has no RELS, but not for the there-copula which adds its own
;; _be_v_there_rel.  Fix this by unifying the ellipsis-rel's ARG0 with
;; the index of the first complement on the dtr.
;
vp_ellipsis_expl := vp_ellipsis &
  [ DTR.SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN be_v_there-or-prd_rel,
                             VAL [ SUBJ < [ --SIND expl-ind & #sind ] >,
                                   COMPS.FIRST synsem &
					[ --SIND #cindex ] ] ],
		 LKEYS [ KEYREL.LBL #lbl,
			 --+ARGIND #subjind ] ],
    SYNSEM [ LOCAL.CONT.HOOK.XARG #sind,
	     NONLOC [ QUE 0-dlist,
		      SLASH 0-dlist ],
	     LKEYS [ ALTKEYREL [ LBL #lbl,
				 PRED ellipsis_expl_rel,
				 ARG0 #cindex ],
		     --+ARGIND #subjind ] ] ].


;; Need to work on generalizing the semantics - since we derive this entry
;; from the past participle, we have to discard the tense information from
;; the input - not clear yet how to do this in general.  For now we assume
;; that transitive verbs introduce a single relation, bound to the KEYREL
;; attrib.

; This incorrectly orders the by_pp before all remaining comps - wrong for
; double-NP verbs, and incomplete for verbs with other oblique arguments,
; since this allows only one order.  But this latter is a general problem.
; DPF 3-Nov-01 - Removed [CONT..E-INDEX.E.ASPECT perf*] since this allows wrong
; generation.  Why was it here?
; DPF 28-jun-07 - Made ALTMIN event_dim_rel, to prevent application of
; the vp_sbrd-prd-ell_c rule to passive VPs.
; DPF 19-jun-09 - Added parent type word_or_infl_rule so drop_ital rules
; will also apply to passive verb forms.

basic_passive_verb_lr := lex_rule_basic & word_or_infl_rule &
  [ INFLECTD +,
    DTR #dtr &
        [ ALTS.PASSIVE +,
          INFLECTD -,
	  SYNSEM verb_synsem &
               [ LOCAL [ CAT [ HEAD verb &
                                    [ VFORM pas,
                                      TAM [ TENSE #tense,
                                            MOOD #mood ],
                                      MINORS.MIN #min ],
                               VAL [ SPCMPS #spcmps ],
			       MC #mc ],
			 CONT.HOOK [ LTOP #hand,
                                     INDEX #index ],
                         CONJ cnil,
			 CTXT #ctxt ],
                 LKEYS [ KEYREL #keyrel,
			 --COMPKEY #cmin,
                         --+COMPKEY #pluscmin,
                         --OCOMPKEY #ocmin,
                         --+OCOMPKEY #plusocmin ],
		 NONLOC #nonloc ] ],
    SYNSEM basic_passive_synsem &
	 [ LOCAL verb_participle_affix &
		 [ CAT [ HEAD verb & [ TAM [ TENSE #tense,
                                             MOOD #mood ],
                                       MINORS [ MIN #min,
                                                ALTMIN passive_rel ] ],
			 VAL [ SPCMPS #spcmps ],
			 MC #mc ],
                   CONT.HOOK [ LTOP #hand,
                               INDEX #index,
                               XARG #xarg ],
		   CTXT #ctxt ],
	   NONLOC #nonloc,
           LKEYS [ KEYREL #keyrel,
		   --COMPKEY #cmin,
                   --+COMPKEY #pluscmin,
                   --OCOMPKEY #ocmin,
                   --+OCOMPKEY #plusocmin ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! topic & [ IARG1 #index,
				IARG2 #xarg ] !> ],
    ARGS < #dtr > ].


;; DPF 13-05-09 - The reentrancy of DTR..SUBJ..NONLOC and COMPS.FIRST..NONLOC 
;; (that is, identifying the dtr's NP NONLOC with the mother's PP-by NONLOC)
;; is a bad idea, since there are more general constraints on SLASH that
;; conflict, meaning that we were not parsing e.g. |happily, Kim is being
;; admired|.
;;
norm_passive_verb_lr := basic_passive_verb_lr &
  [ DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ --SIND #subjind, 
					NONLOC #snonloc ] >,
			       COMPS.FIRST.LOCAL.CONT.HOOK.XARG #compxarg ],
    SYNSEM passive_synsem &
           [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.XARG #compxarg ] >,
			     COMPS < [ LOCAL.CONT.HOOK.INDEX #subjind,
				       NONLOC #snonloc ], ... > ] ] ].

; 'was referred to as ...'
prep_passive_verb_lr := basic_passive_verb_lr &
  [ DTR.SYNSEM [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #sind, 
					NONLOC #snonloc ] >,
				 COMPS [ FIRST phr_synsem &
					     [ --MIN #min & selected_rel,
					       LOCAL [ CAT [ HEAD prep,
							     VAL.COMPS < > ],
						       CONT #objcont ],
					       NONLOC #ononloc,
					       --SIND #objind ],
					 REST #comps ] ],
		 LKEYS.KEYREL #keyrel ],
    SYNSEM prep_passive_synsem &
           [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT #objcont,
					  --SIND #objind,
					  NONLOC #ononloc ] >,
				 COMPS [ FIRST [ --MIN #min ],
				   REST [ FIRST [ LOCAL.CONT.HOOK.INDEX #sind,
						  NONLOC #snonloc ],
					  REST #comps ] ] ] ],
		     CONT.HOOK.XARG #objind ],
		 LKEYS.KEYREL #keyrel ] ].

; "this chapter has been added to" (dtr has opt NP complement)
; or verb+NP+particle
;;
basic_prep_passive_trans_verb_lr := basic_passive_verb_lr &
  [ DTR.SYNSEM 
     [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #sind, 
				NONLOC #snonloc ] >,
		       COMPS [ FIRST [ LOCAL.CAT.HEAD noun,
				       NONLOC #ononloc ],
			       REST [ FIRST [ --MIN #min & 
						    selected_rel,
					      LOCAL [ CAT.HEAD prep,
						      CONT #objcont ] ],
				      REST #comps ] ] ],
       LKEYS.KEYREL #keyrel ],
    SYNSEM prep_passive_synsem &
        [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT #objcont,
				       --SIND #objind,
				       NONLOC #ononloc ] >,
			      COMPS [ FIRST [ --MIN #min ],
				    REST [ FIRST [ LOCAL.CONT.HOOK.INDEX #sind,
						   NONLOC #snonloc ],
					   REST #comps ] ] ] ],
		  CONT.HOOK.XARG #objind ],
	  LKEYS.KEYREL #keyrel ] ].

;; For |the collection was added to|
prep_passive_trans_verb_lr := basic_prep_passive_trans_verb_lr &
 [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS [ FIRST.OPT +,
				    REST.FIRST [ LOCAL.CAT.VAL.COMPS < >,
						 --SIND #objind ] ],
   SYNSEM.LOCAL.CONT.HOOK.XARG #objind ].

;; For |the answer could be looked up|
prep_passive_ptcl_verb_lr := basic_prep_passive_trans_verb_lr &
 [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS [ FIRST [ OPT -,
					    LOCAL.CONT.HOOK.INDEX #objind ],
				    REST.FIRST.LOCAL.CAT.VAL.COMPS *cons* ],
   SYNSEM.LOCAL.CONT.HOOK.XARG #objind ].

;; This has the same problem as the passive lexical rule.  Since we derive the
;; gerund from the present particple, we somehow have to filter out the
;; progressive relation.

;; DPF 27-May-99 - We block extraction from gerunds, at least for efficiency.
;; DPF 27-May-99 - POSS-ING gerunds are given a non-empty SUBJ value so they
;; can be modified by ordinary PPs and non-sentential adverbs, but the synsem
;; value is the hack 'anti_synsem' which is also used for the SPR value of 
;; verbs, for similar reasons.
;; DPF 27-May-99 - Try combining the two verbal gerund rules into one.
;; DPF 02-June-99 - We also block the auxiliary verbs "being, having, doing",
;; to avoid identity copula analyses for "Kim is being good" or "Kim is having
;; hired Sandy".
;; DPF 31-Jul-99 - Make gerund_rel like nominalize_rel in identifying its
;; handle with the verb_rel's, rather than taking the verb's handle as arg.
;; DPF 24-Jun-01 - Added REL 0-dlist to block "interviewing that" as gerund NP
;; with rel-pro "that".  This is overly strong for pied piping, as in "I met
;; some people talking to whom was pleasant", but we would need to distinguish
;; at least rel-pro "that" (and maybe "who") from "whom" - maybe later.
;; DPF 8-Nov-01 - The decision to block extraction from verbal gerunds means
;; we don't get "Which books are you interested in buying".
;; DPF 21-Jul-03 - Removed PT notpro from mother's index - not clear
;; why it was there, but it blocked "my arriving surprised kim".
;; DPF 23-aug-04 - Added SLASH 0-dlist, like for nominal gerunds, to further
;; enforce Ross's complex-NP constraint.
;; DPF 23-aug-04 - Regarding 02-June-99 comment, we now more generally use
;; SORT to block spurious analysis for "kim is being good", just like for
;; "Kim is arriving", so we remove the [AUX -] constraint, which means we
;; once again can get "after being hired, Kim smiled"
;; Changed SYNSEM nonpro_onearg_synsem to SYNSEM basic_one_arg so as to
;; leave the LEX value underspecified, so we can avoid bare-vger for 
;; unadorned verbal gerunds.
;; DPF 26-aug-07 - Restrict DTR..SUBJ..HEAD noun to avoid making gerunds
;; for locative inversion verbs like "going"
#|
vger_ing := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ CAT [ HEAD verb &
                                    [ VFORM prp ],
			       VAL [ SUBJ < [ --SIND #subj,
                                              LOCAL.CAT.HEAD noun,
                                              NONLOC #snonloc ] >,
                                     COMPS #comps ] ],
			 CONT.HOOK [ LTOP #vhand,
                                     INDEX.SF prop ],
                         CTXT #ctxt ],
                 LKEYS [ KEYREL.ARG0.E [ TENSE no_tense, 
                                         ASPECT.PRF - ],
                         --COMPKEY #cmin,
                         --OCOMPKEY #ocmin ],
		 NONLOC #nonloc,
		 LKEYS.KEYREL [ CFROM #from, CTO #to ] ] ],
    SYNSEM basic_one_arg &
	   [ LOCAL [ AGR #ind,
		     CAT [ HEAD gerund &
				[ MOD < >,
				  PRD -,
                                  POSS -,
                                  MINORS.MIN gerund_rel ],
			   VAL [ SUBJ < synsem &
				    [ LOCAL [ CAT nomp_cat_acc_min &
                                                  [ HEAD noun ],
					      CONJ cnil ],
                                      --SIND #subj ] >,
                                 SPR < [ LOCAL local &
					   [ CAT [ HEAD det & 
						    [ POSS + ],
                                                   VAL [ SUBJ < >,
							 SPR *olist*,
							 COMPS < > ] ],
                                             CONT.HOOK.INDEX #subj ],
                                         NONLOC #snonloc,
                                         OPT - ] >,
                                 COMPS #comps,
				 SPCMPS < > ] ],
		     CONT nom-obj &
                          [ HOOK [ LTOP #hand,
                                   INDEX #ind &
                                       [ PNG png & [ PN 3s,
                                                     GEN neut ],
                                         DIV +] ] ],
                     CTXT #ctxt ],
             LKEYS [ KEYREL #keyrel & gerund_relation &
                            [ LBL #hand,
                              ARG0 #ind,
                              ARG1 #vhand,
			      CFROM #from, CTO #to ],
		     --COMPKEY #cmin,
                     --OCOMPKEY #ocmin ],
	     NONLOC #nonloc & [ SLASH 0-dlist,
                                REL 0-dlist & [ LIST < > ] ] ],
    C-CONT [ RELS <! #keyrel !>,
             HCONS <! !>,
	     ICONS <! !> ] ].
|#
;; DPF (12-Jul-98) In order to allow prenominal adjectives for nominal gerunds,
;; as in "regular tasting of wine is healthy", we have to treat the specifier
;; of the gerund as obligatory, since prenominal adjectives distinguish proper
;; from common nouns based on the optionality (or absence) of the specifier.
;; So these gerunds have to undergo the bare plural rule if no determiner is
;; present, which means they also have to be DIV +.
;; DPF 26-Mar-01 - Added [ALTMIN relation] to mother, to avoid having verbal
;; gerunds as, e.g., modified by "per/a person".
;; DPF 22-Apr-01 - Removed DIV + since we're getting a systematic
;; ambiguity between bare nominal gerunds and bare verbal gerunds.  This means
;; we'll block "hiring of consultants is important", but that's okay for now.
;; DPF 30-Aug-01 - But we also lose "loud singing is discouraged", which is
;; not okay, so we put DIV + back on mother.
;; DPF 23-Sep-01 - Used to have [ALTMIN relation] to block gerunds appearing as
;; left members of noun-noun compounds, but this also blocked them as heads of
;; compounds as in "chair buying is fun".  So eliminate this constraint, and
;; allow nominal gerunds on both sides of compounds, as in "email routing list"
;; or "weekend shopping regulations" - and block pres-participles as adjectives
;; to avoid apparently spurious ambiguity for e.g. "shopping trip".  But 
;; consider "the hiring consultant" which is ambiguous between the one who
;; does the hiring and the one who advises on hiring - maybe differing 
;; intonation suggests two distinct analyses, not spurious.  But block for now.
;; DPF 10-Nov-01 - Made nominal gerunds have head type nomger so they can be
;; distinguished from non-derived nouns (e.g. so modifiers like "per" don't
;; attach).
;; DPF 26-aug-04 - Note that we leave the output of the nominal-gerund rule
;; unmarked for INFLECTD so it can appear as the left member of n-n-cmpnds.
;; DPF 13-jul-06 - Added DIV + to SPR, to avoid spurious ambiguity with
;; nbar_coord_asym_rule.

nominal_gerund := lex_rule_basic &
  [ ORTH #orth & [ FROM #from, TO #to ],
    DTR word_or_lexrule & #dtr &
        [ ORTH #orth,
          INFLECTD +,
	  SYNSEM verb_synsem &
	       [ LOCAL local &
                       [ CAT [ HEAD verb &
                                    [ VFORM prp,
				      AUX - ],
			       VAL.SUBJ < [ NONLOC #snonloc ] >,
                               MC #mc,
                               HC-LEX #hclex ],
			 CONT [ HOOK [ LTOP #vhand,
                                       INDEX.SF prop ] ],
                         CONJ cnil,
			 CTXT #ctxt ],
                 LKEYS [ KEYREL.ARG0.E [ TENSE no_tense,
                                         ASPECT.PRF - ],
                         --COMPKEY #cmin,
                         --OCOMPKEY #ocmin ],
		 NONLOC #nonloc ] ],
    SYNSEM nonpro_nomod_synsem &
	   [ LOCAL local &
	     [ AGR #ind,
	       CAT 
	       [ HEAD nomger & [ MINORS.MIN nominalize_rel ],
		 VAL [ SUBJ < >,
		       SPR < [ LOCAL local &
				     [ CAT [ HEAD det,
					     VAL [ SUBJ < >,
						   SPR *olist*,
						   COMPS < > ] ],
                                       AGR.PNG #png ],
                               --SIND #ind & [ PNG #png,
                                               DIV + ],
			       NONLOC #snonloc,
			       OPT - ] >,
		       SPCMPS < > ],
                 MC #mc,
                 HC-LEX #hclex ],
               CONT [ HOOK [ LTOP #hand,
                             INDEX #ind & [ PNG png & [ PN 3s,
                                                        GEN neut ],
                                            DIV +,
                                            PT notpro ] ] ],
               CONJ cnil,
               CTXT #ctxt ],
             LKEYS [ KEYREL #keyrel & nominalize_relation &
                              [ LBL #hand,
                                ARG0 #ind,
                                ARG1 #vhand,
				CFROM #from, CTO #to ],
		     --COMPKEY #cmin,
                     --OCOMPKEY #ocmin ],
	     NONLOC #nonloc & [ SLASH 0-dlist ],
             MODIFD notmod ],
    C-CONT [ RELS <! #keyrel !>,
             HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #dtr > ].

intrans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM intrans_subst & 
	       [ LOCAL.CAT.VAL.COMPS #comps ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #comps ].

; DPF 23-may-07 - Since virtually all PP complements of nouns are optional,
; remove the OPT value from the dtr's specification of the PP.
; DPF 20-jun-07 - Restrict these to PPs, not particles, to avoid spurious
; gerunds for e.g. "leaving" from "leave+in"
; DPF 26-aug-07 - Re 23-may-07: Still want to require that verbs with
; empty PP complements still require them. So propagate OPT value from DTR's
; COMP to mother.

intrans_pp_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM unsat_two_arg_subst &
	       [ LOCAL.CAT.VAL.COMPS < phr_synsem &
                                       [ LOCAL #local & 
                                               [ CAT.HEAD prep ],
                                         NONLOC #nonloc,
                                         MODIFD #modif,
                                         PUNCT #punct,
                                         OPT #opt,
					 --MIN #min ] . #comps > ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL #local,
                                   NONLOC #nonloc,
                                   MODIFD #modif,
                                   PUNCT #punct,
                                   OPT #opt,
				   --MIN #min ] . #comps > ].

;; This is too restrictive.  It only forms nominal gerunds from strictly
;; transitive verbs.  So, it doesn't give you "Kim's putting of food on the
;; table" or "Kim's warning of Sandy that it would rain" or "Kim's giving of
;; raisins to the ants".  
;;  To avoid ambiguity with the intransitive nominal gerund, we make the PP
;; obligatory.
;; DPF 19-Feb-01 - But this is too restrictive: blocks "Hiring is difficult"
;; DPF 22-Feb-01 - Added restriction on --COMPKEY (and --OCOMPKEY) to prevent 
;; verb-particle verbs (with "selected_rel" complements) from undergoing rule.
;; DPF 26-Mar-01 - Make the OPT value of the of-PP complement be same as that
;; of the verb's complement NP.
;; DPF 23-Sep-01 - But this prevents e.g. "hiring is important".  So make the
;; value OPT +, which seems true for nominal gerunds.
;; DPF 03-Apr-03 - Constrained PP-comp to be [SLASH 0-dlist] (and REL and QUE)
;; Long-standing bug.  Sigh.
;; DPF 22-Jul-03 - Added constraint COMPS <expressed_synsem> to remove spurious
;; ambiguity for "My hiring" as we do for ordinary n_ppcomp lexical entries.
;; DPF 11-oct-05 - Try preserving optionality of complement from dtr to mother.
;; DPF 4-nov-05 - But this prevents N-N compounds where the first is notionally
;; an argument of the second (from a strictly transitive verb), as in 
;; "cat chasing is popular."  So let's try another approach, where we allow
;; transitive verbs to undergo this rule as long as there is not an alternative
;; entry like a v_prep_dir_le which would compete.  The underlying idea is
;; that there should be a single lexical entry with an underspecification 
;; for prep-dir and strict-transitive, but we currently have to express this as
;; an explicit disjunction with two lexical entries.  This approach doesn't yet
;; do so well with causative/inchoative alternations, where the two verbs
;; introduce different predicates, and we can't easily get to the 
;; underspecified sense.  For now, we'll exclude the causative variant here, 
;; and expect some post-processing to do the right thing with the semantics of
;; e.g. "cat shipping" to get from the overly specific "_ship_v_1_rel" to one 
;; possible reading where there is a "_ship_v_cause_rel".
;; DPF 27-aug-07 - Re 22-Feb-01: This constraint on --OCOMPKEY is overly
;; restrictive, since it blocks gerunds for verbs with an optional second
;; complement (like "recommend").  Instead, require that the REST of the 
;; COMPS list be *olist*, and add ALTS.NGER + to still block unwanted gerunds
;; for causatives.

trans_nominal_gerund := nominal_gerund &
  [ DTR [ ALTS.NGER +,
          SYNSEM trans_subst & 
	       [ LOCAL.CAT.VAL.COMPS < [ --SIND #index,
                                         NONLOC #nonloc ] . *olist* >,
                 LKEYS.--COMPKEY independent_rel ] ],
    SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --MIN _of_p_sel_rel,
                                     LOCAL [ CAT basic_pp_cat,
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #index ],
                                             CONJ cnil ],
                                     NONLOC #nonloc ] >,
                   CONT.HOOK.LTOP #ltop ] ].

; DPF 13-Oct-02 - Added COMPS < > to SPEC..SYNSEM, to avoid spurious ambiguity
; for e.g. "Friday evening"

date_det_lr := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD noun,
                                 VAL.COMPS *olist* ],
			   CTXT #ctxt ],
                   LKEYS [ KEYREL #altkeyrel,
                           --COMPKEY #cmin,
                           --OCOMPKEY #ocmin ],
		   NONLOC #nonloc ] ],
    SYNSEM lex_synsem &
	   [ LOCAL [ CAT [ HEAD det,
                           VAL [ SUBJ < >,
				 SPR < >,
                                 COMPS < >,
				 SPEC < [ LOCAL [ CAT.VAL.COMPS < >,
                                                  CONT.HOOK.LTOP #nltop ],
                                          --SIND #ind ] >,
				 SPCMPS < > ] ],
                     CONT.HOOK [ INDEX #ind,
				 XARG #nltop ],
		     CTXT #ctxt ],
             LKEYS [ KEYREL #keyrel &
                            [ PRED def_explicit_q_rel,
                              ARG0 #ind,
                              RSTR #rhand ],
                     ALTKEYREL #altkeyrel &
                               [ LBL #mltop,
                                 ARG0 #spind ],
                     --COMPKEY #cmin,
                     --OCOMPKEY #ocmin ],
	     NONLOC #nonloc & [ SLASH 0-dlist,
                                   REL 0-dlist,
                                   QUE 0-dlist ],
	     MODIFD hasmod ],
    C-CONT [ RELS <! #keyrel &
		     [ CFROM #from, CTO #to ],
                     prep_relation &
                     [ LBL #nltop,
                       PRED of_p_rel,
                       ARG0.E.TENSE no_tense,
                       ARG1 #ind,
                       ARG2 #spind,
		       CFROM #from, CTO #to ],
                     [ PRED def_implicit_q_rel,
                       ARG0 #spind,
                       RSTR #mhand,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nltop ],
                      qeq & [ HARG #mhand,
                              LARG #mltop ] !>,
	     ICONS <! !> ] ].

; "October": NP => Determiner
;          "(in) October" => "October first"

month_det_lr := date_det_lr &
  [ DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN mofy_rel,
                 LKEYS.KEYREL.PRED mofy_rel ],
    SYNSEM.LOCAL.CAT [ HEAD [ MINORS [ MIN defdate_q_rel,
				       ALTMIN mofy_rel ],
                              MOD < > ],
                       VAL [ SPEC < [ --MIN dofm_or_interval_rel ] >,
                             SPCMPS < > ] ] ].

; "Tuesday": NP => Determiner
;          "(on) Tuesday" => "Tuesday morning"
; DPF 13-aug-09 - Restrict dtr to singular: "*Tuesdays morning"

#|
weekday_det_lr := date_det_lr &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MINORS [ MIN #min,
                                         ALTMIN dofw_rel ],
                                MOD < anti_synsem_min > ],
                       VAL.SPEC < [ --MIN day_part_rel ] > ],
             LKEYS.KEYREL.PRED #min ],
    DTR.SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN dofw_rel,
			 AGR.PNG.PN 3s ],
                 LKEYS.KEYREL.PRED dofw_rel ] ].
|#
weekday_det_lr := date_det_lr &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MINORS [ MIN def_explicit_q_rel,
					 ALTMIN dofw_rel ],
				MOD < > ],
			 VAL.SPEC < [ --MIN day_part_rel ] > ] ],
    DTR.SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN dofw_rel,
			 AGR.PNG.PN 3s ],
                 LKEYS.KEYREL.PRED dofw_rel ] ].

; Relate transitive predicative adjectives to their intransitive attributive
; counterparts

attr_adj_lr := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  ALTS.ATTRJ +,
	  SYNSEM pred_adj_synsem &
	         [ LOCAL [ CAT [ HEAD [ MOD #mod,
                                        MINORS.MIN #min ],
				 VAL [ SUBJ #subj,
				       SPR #spr,
                                       COMPS *olist*,
				       SPCMPS #spcmps ] ],
                           CTXT #ctxt ],
		   NONLOC #non-local,
		   MODIFD #modif ] ],
    SYNSEM attr_adj_constr_synsem &
	  [ LOCAL [ CAT [ HEAD adj &
                               [ MOD #mod,
                                 MINORS.MIN #min ],
			  VAL [ SUBJ #subj,
				SPR #spr,
				SPCMPS #spcmps ] ],
		    CTXT #ctxt ],
	    NONLOC #non-local,
	    MODIFD #modif ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].


;; Makes "admired" into an attributive adjective, as in "the admired hero"
;; DPF 22-Feb-01 - Added restriction of 'independent_rel' on --COMPKEY (and 
;; --OCOMPKEY) to prevent verb-particle verbs (with "selected_rel" complements)
;; from undergoing rule.
;; DPF 22-May-01 - But this did not generalize to blocking other unwanted
;; subcat variants, like S-comp-taking "checking".  So instead constrain
;; dtr's SYNSEM to be passive_or_unacc_subst, and require the --COMPKEY to be
;; no_rel.  This allows only intransitive (past-participle) verbs or passive 
;; transitive verbs to undergo this rule.
;; DPF 31-Jul-01 - Removed attr_adj_synsem from output since it didn't work.
;; What was I thinking?  Also removed MOD..SPR..MIN explicit_q_rel from
;; output, since this blocks "hired consultants arrive".  What was it for?
;; DPF 23-Sep-01 - Tempting to restrict this rule to only passives, since now 
;; handling pres-participles as nominal gerunds in noun-noun compounds.  (We
;; don't yet enable unaccusative participles as in "the fallen leaf".)  But as
;; noted above, what about two readings for "the hiring consultant" - one seems
;; to be n-n compound, the other an attrib adj, so maybe need both?  Block for
;; now.
;; DPF 25-Nov-01 - Changed SYNSEM.HEAD to be verb* rather than adj*, to allow
;; "The recently purchased chair arrived"
;; DPF 3-Jan-02 - Added hack unary length limit on RELS for input, to block 
;; application of rule to v-np-pp verbs like "send" (cf. 'Do you offer a 
;; printed catalog')
;; For now, allow only intransitive and transitive verb participles to appear
;; as attributive modifiers - block e.g. subj-equi variants to avoid spurious
;; ambiguity for 'the starting point'
;; DPF 14-dec-03 - Consider removing LPERIPH na, since it prevents NPs with
;; one of these guys from appearing in appositive constructions: "the singing 
;; bear Kim".  Not clear what work it does.  FIX.
;; DPF 27-jan-04 - Changed LPERIPH on mother from na to +, to enable these
;; as modifiers in compounds, as in "Fedex tracking number".  Can't remove the
;; constraint entirely (see above) since it serves to block unwanted
;; appositive analyses for examples like "Kim interviewed Sandy".
;; DPF 21-aug-04 - Added SPEC < > to prevent these from being modified by
;; posthead PP - always a dead-end attachment.
;; DPF 10-mar-05 - Re 25-Nov-01: Now allowing adverbs to modify adjectives as
;; well, so make output be HEAD adj, which also allows us now to coordinate
;; these as in "the admired and hated politicians" (didn't parse before).
;; DPF 28-mar-05 - Restored LPERIPH bool in order to prevent these inside
;; N-Adj-N compounds, since there is an alternative analysis of e.g.
;; 'company tracking number' where 'tracking number' is an N-N compound.
;; DPF 16-sept-05 - Try blocking SPR for these, to avoid e.g. "*a very hired
;; consultant"
;; DPF 5-nov-05 - It's tempting to relax SYNSEM..MOD..MIN from nom_nbar_rel to 
;; reg_nom_rel in order to also allow "the retired Abrams", but this leads to
;; unpleasant spurious ambiguity as in "Abrams has hired Browne."  Let's try
;; a specialized variant of this rule for proper names which requires that
;; they then have a non-empty specifier.
;; DPF 13-nov-05 - Re: 16-sept-05, but this also prevents "most visited",
;; so instead constrain SPR to only allow this-that ones, which include
;; comparative/superlative deg-specs.
;; DPF 13-may-06 - Re: 3-Jan-02 - this constraint no longer blocks application
;; to v-np-pp verbs since lexical semantics is no longer complex, and it
;; blocks desired application to lexical passives like "untrafficked", which
;; do have decomposed semantics.  So remove it.

basic_attr_verb_part_lr := lex_rule_basic &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD verb &
                                      [ VFORM non_fin,
                                        PRD +,
                                        AUX - ],
				 VAL.SUBJ < [ --SIND #ind & non_expl,
                                              LOCAL.CAT.HEAD noun ] > ],
                           CONT [ HOOK [ LTOP #ltop,
                                         INDEX #event &
                                              [ E [ TENSE no_tense,
                                                    ASPECT.PRF - ] ] ] ],
                           CTXT #ctxt ],
                   NONLOC #non-local,
		   MODIFD #modif ] ],
    SYNSEM adj_synsem_lex_constr &
     [ LOCAL [ CAT [ HEAD.PRD -,
		     POSTHD -,
		     MC na ],
	       CTXT #ctxt ],
       MODIFD #modif,
       NONLOC #non-local ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event & [ SF prop ],
                    XARG #ind ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 22-may-09 - Had changed MOD..--MIN to nbar_or_num_rel for some
; SciBorg-related reason, but can't recall now, and don't really like
; 'chased one' as an NP with num-noun 'one'
;

attr_verb_part_nbarmod_lr := basic_attr_verb_part_lr & lex_rule &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ --MIN gen_nom_nbar_rel ] >,
	     LEX + ] ].

attr_verb_part_lr := attr_verb_part_nbarmod_lr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    DTR.SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
		 LKEYS.--COMPKEY independent_rel ] ].

; transitive -ing verbs
; DPF 25-aug-07 - Block causative -ing forms to avoid spurious ambiguity for
; e.g. "the shrinking window"

attr_verb_part_tr_lr := attr_verb_part_nbarmod_lr &
  [ ALTS.VADJ +,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    DTR.SYNSEM [ LOCAL.CAT [ HEAD [ VFORM prp,
				    MINORS.ALTMIN role_rel ],
			     VAL.COMPS 
                              < unexpressed &
                                [ --MIN independent_rel,
                                  LOCAL.CAT.HEAD n_or_p ] . *olist* > ],
		 LKEYS.--COMPKEY independent_rel ] ].

attr_verb_part_psv_lr := attr_verb_part_nbarmod_lr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    DTR [ SYNSEM [ LOCAL.CAT [ HEAD.VFORM pas,
				 VAL.COMPS 
				     < unexpressed &
				       [ --MIN selected_rel ] . *olist* > ],
		   LKEYS.--COMPKEY independent_rel ],
	  ALTS.ATTRJ + ],
    C-CONT.RELS <! !> ].

;; For e.g. |the dried out cloth| |the written up report| (often with hyphens)
;; DPF 2013-09-25 - Constrain mother to be LEX - but HC-LEX + in order to block
;; |*the dried cloth out|.
;;
attr_verb_part_ptcl_psv_lr := basic_attr_verb_part_lr &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ --MIN gen_nom_nbar_rel ] >,
			 VAL.COMPS < #comp >,
			 MC #mc,
			 HC-LEX + ],
	     LEX - ],
    DTR word_or_lexrule & #stem &
	[ INFLECTD +,
	  SYNSEM.LOCAL.CAT [ HEAD.VFORM pas,
			     VAL.COMPS [ FIRST #comp & [ OPT -,
							 --MIN selected_rel ],
					 REST *cons* ],
			     MC #mc ],
          KEY-ARG #keyarg,
	  ALTS.ATTRJ + ],
    C-CONT.RELS <! !>,
    KEY-ARG #keyarg,
    ARGS < #stem >,
    INFLECTD + ].


; For "the bewitching Abrams"
; DPF 30-sept-06 - The DTR..VFORM prp constraint prevents e.g. "the newly
; built Paris", so remove and see what happens to added ambiguity.

attr_verb_part_namemod_lr := basic_attr_verb_part_lr & lex_rule &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ --MIN named_rel,
				      LOCAL.CAT.VAL.SPR < expressed_synsem > ]>,
			 VAL.COMPS < > ],
	     LEX + ],
    DTR.SYNSEM.LKEYS.--COMPKEY independent_rel ].

attr_verb_part_intr_namemod_lr := attr_verb_part_namemod_lr &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

attr_verb_part_tr_namemod_lr := attr_verb_part_namemod_lr &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < unexpressed &
                                     [ LOCAL.CAT.HEAD n_or_p ] > ].

;; The partitive construction rule introduces a new type of relation: 
;; part_of_rel, which contains the semantic information of the partitive.
;; The features of the relation, a subtype of nom_rel, were
;; - LBL, 
;; - ARG0, the index of the NP,
;; - SET, the handle of the PP complement, defining the set of which the head 
;;        determines a subset,
;; - NPREP,the index of the PP complement of the head, which is actually the
;;        index of the NP complement of that PP.
;; The idea is that there is a difference between, for example, "some books", 
;; and "some of the books". In the first case, "books" can refer to a subset
;; of the set of all the existing books, and "some" quantifies over the 
;; set of all existing books. In the second case, "some" refers to a subset of
;; the set of books defined by "the books": that set cannot refer to the 
;; universal set of all existing books. The relation "part_of_rel" tries to
;; capture that notion of subset of a certain set (defined by the context, or 
;; the determiner of the NP complement): the subset has an index 
;; (ARG0), and the defined set is referred to by "SET", which is the handle of
;; the prepositional phrase, and also the handle of the determiner of the 
;; prepositional complement.  We thus give partitives a complex lexical
;; semantics, including both the part_of_rel and the original quantifier
;; relation, with its usual attributes.

;; A problem which remains is to get the right agreement with the right head.
;; At the moment, the index of the head is the same as the index of the 
;; original determiner. As an example, "all" can be mass or plural, and is 
;; going to agree with a singular or a plural verb, whatever its complement is
;; ("all of the cake", "all of the students"). If we decide to have the index
;; of the construction being the index of the complement noun, what about 
;; "each" ? "Each of the boys" will agree with a plural only, when it should
;; agree with a singular. On the other hand, there is also the problem of 
;; "all of the oats are", plural when "all" is the mass determiner here: 
;; agreement is determined, here, by the plural form of the complement noun.

basic_part_constr := lex_rule &
 [ ORTH #orth,
   DTR [ ORTH #orth,
         SYNSEM basic_part_det_synsem & 
	  [ LOCAL.CAT [ HEAD.MINORS.MIN #min,
                        VAL [ SPCMPS #spcmps ] ],
            LKEYS.KEYREL #relation,
	    NONLOC [ SLASH #slash,
                     QUE #que ] ] ],
   SYNSEM partitive_noun_synsem & 
     [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN #min,
		     VAL [ SPR.FIRST unexpressed,
			   SPCMPS #spcmps ] ],
	       CONT.HOOK.INDEX overt_non_expl-ind ],
       LKEYS [ KEYREL #keyrel,
               ALTKEYREL #relation ],
       NONLOC [ SLASH #slash,
                QUE #que ] ],
   C-CONT [ RELS <! #keyrel !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

part_nocomp_constr := basic_part_constr &
 [ SYNSEM partitive_noun_nocomp_synsem &
          [ LOCAL [ CAT.VAL.COMPS #comps,
                    AGR.DIV #div ] ],
   DTR.SYNSEM.LOCAL [ CAT.VAL.COMPS #comps,
                      AGR.DIV #div ] ].

part_ppof_agr_constr := basic_part_constr &
 [ DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN explicit_quant_agr_q_rel,
                          VAL [ KCMP #kcomp,
                                COMPS #comps ] ],
   SYNSEM basic_partitive_noun_ppof_synsem &
        [ LOCAL [ CAT.VAL [ KCMP #kcomp & [ LOCAL.AGR.PNG.PN #pn ],
                            COMPS < #kcomp . #comps > ],
                  AGR.PNG.PN #pn ] ] ].
          
part_ppof_noagr_constr := basic_part_constr &
 [ DTR.SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN explicit_quant_or_udef_noagr_q_rel,
                            VAL [ KCMP #kcomp &
                                       [ LOCAL.CAT.HEAD.MINORS.ALTMIN #min ],
                                  COMPS #comps ] ],
                      AGR #agr ],
   SYNSEM basic_partitive_noun_ppof_synsem &
        [ LOCAL [ AGR #agr & [ PNG.PN 3 ],
                  CAT [ HEAD.MINORS.MIN #min,
                        VAL [ KCMP #kcomp,
                              COMPS < #kcomp . #comps > ] ] ] ] ].

; NP-particle alternation (e.g. "look up the answer/look the answer up"
; Stamp canonical_synsem on NP of output to avoid spurious parse for extraction
; of the NP, as in "Which problem did Kim figure out?"
;; DPF 2011-08-20 - Curious observation: If we don't include the (desirable)
;; re-entrancy for --COMPKEY in this rule, we get an asymmetry between the 
;; LKB and PET for the sentence |Throw away paper or other rice.| -- namely, 
;; the LKB quicly produces three analyses, while PET fails to terminate.  
;; Further, PET is happy as long as the rule vp_cr-cc_c is commented out.  
;; FIX? - Maybe diagnose this someday.
;; DPF 2012-08-21 - Identified --ADDIN on mother and dtr, to avoid spurious
;; analysis with mismatched subj-verb agreement, as in |she turn in homework|.
;; Sigh.

NP_particle_lr := lex_rule &
 [ ORTH #orth,
   ALTS.NPPART +,
   DTR [ ORTH #orth,
         SYNSEM basic_NP_particle_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod,
				 PRD #prd,
				 --ADDIN #addin ],
                          POSTHD #ph,
			  VAL [ SUBJ #subj,
                                COMPS < [ OPT #opt2,
                                          NONLOC #nloc2 ] .
                                        < [ OPT #opt1,
                                            --MIN #cmin,
                                            NONLOC #nloc1 ] . #comps > >,
                                KCMP #kcmp ],
                          MC #mc,
                          HC-LEX #hclex  ],
		    CONT [ HOOK #hook,
			   RELS #rels ],
		    CTXT #ctxt ],
	    NONLOC #nonlocal,
            LKEYS #lkeys ] ],
   SYNSEM generic_particle_NP_verb &
          [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod,
				 PRD #prd,
				 --ADDIN #addin ],
                          POSTHD #ph,
                          VAL [ SUBJ #subj,
                                COMPS < [ OPT #opt1,
                                          --MIN #cmin,
                                          NONLOC #nloc1 ] . 
                                        < canonical_synsem &
                                          [ OPT #opt2,
                                            NONLOC #nloc2 ] . #comps > >,
                                KCMP #kcmp ],
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK #hook,
			   RELS #rels ],
                    CTXT #ctxt ],
            NONLOC #nonlocal,
            LKEYS #lkeys ],
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

; --OCOMPKEY is not the same for ditrans and to-trans.

dative_shift_lr := lex_rule_basic &
 [ ORTH #orth,
   INFLECTD -,
   DTR #dtr & 
       [ ORTH #orth,
         INFLECTD -,
	 ALTS.DATIVE +,
         SYNSEM ditrans_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod ],
                          VAL.SUBJ #subj,
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ] ],
                    CONJ cnil,
                    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
                    ALTKEYREL #altkeyrel,
                    --COMPKEY #cmin ],
            NONLOC #nonlocal ] ],
   SYNSEM empty_to_trans_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod ],
			  VAL [ SUBJ #subj,
				COMPS < [ OPT - ], [ OPT - ] > ],
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ] ],
                    CONJ cnil,
		    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
                    ALTKEYREL #altkeyrel,
                    --COMPKEY #cmin ],
	    NONLOC #nonlocal ],
   ARGS < #dtr >,
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

;; Verbs with expletive-it subject and direct object alternate with second
;; complement as CP or VP:
;; |It annoyed him that we left|
;; |It annoyed him to shave himself| 
;;
verb_it_cp_vp_lr := lex_rule_basic &
 [ ORTH #orth,
   INFLECTD -,
   DTR #dtr & 
       [ ORTH #orth,
         INFLECTD -,
         SYNSEM expl_it_subj_np_cp_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod ],
                          VAL.SUBJ #subj,
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ] ],
                    CONJ cnil,
                    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
                    ALTKEYREL #altkeyrel,
                    --COMPKEY #cmin ],
            NONLOC #nonlocal ] ],
   SYNSEM expl_it_subj_np_vp_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod ],
			  VAL.SUBJ #subj,
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ] ],
                    CONJ cnil,
		    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
                    ALTKEYREL #altkeyrel,
                    --COMPKEY #cmin ],
	    NONLOC #nonlocal ],
   ARGS < #dtr >,
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

; Converts e.g. int-adj 'twenty' to minute-noun for 'twenty (minutes) to nine'
; Currently does not allow 'twenty-two to nine' - would need to append COMPS
; more carefully.

minute_prep_lr := lex_rule &
 [ ORTH #orth,
   DTR #dtr & 
       [ ORTH #orth,
         SYNSEM norm_num_synsem &
	  [ LOCAL [ CAT [ HEAD intadj2- &
                             [ MOD < [ LOCAL.CONT.HOOK.LTOP #arghand ] > ],
                          VAL.COMPS < > ],
                    CONT.HOOK.INDEX #minst,
                    CTXT #ctxt ],
            LKEYS.KEYREL [ LBL #arghand,
			   CFROM #cfrom, CTO #cto ],
	    PHON.ONSET con_or_voc,
	    NONLOC #nonlocal ] ],
   SYNSEM minute_noun_synsem &
	  [ LOCAL.CTXT #ctxt,
            LKEYS.KEYREL #keyrel & 
                         [ LBL #arghand,
                           ARG1 #minst,
			   CFROM #cfrom, CTO #cto ],
	    NONLOC #nonlocal ],
   C-CONT [ RELS <! #keyrel !>,
            HCONS <! !>,
	    ICONS <! !> ],
   ARGS < #dtr > ].


; DPF 28-jun-07 - Restricted dtr to HEAD a_or_adv to block partitive dets
; like "a bit".  Also made mother's SPCMPS < >.

; For "A large enough cat arrived."

;; DPF 2013-09-27 - Constrain dtr to be norm_adj_lex_synsem in order to
;; block as input deverbal adjectives: |*we brought a baked enough cake|
;;
basic_enough_addition := lex_rule_basic &
  [ ORTH #orth,
    INFLECTD +,
    DTR word_or_lexrule & #stem &
	[ ORTH #orth,
	  INFLECTD +,
	  SYNSEM norm_adj_lex_synsem &
           [ LOCAL [ CAT [ HEAD #head & a_or_adv &
                                [ MINORS.MIN independent_mod_rel,
                                  AUX - ],
                           VAL [ SUBJ #subj,
                                 COMPS *olist*,
                                 SPR.FIRST synsem &
				      [ --MIN very_deg_rel,
					LOCAL.CONT.HOOK #sphook ] ],
			   MC #mc ],
		     CONT.HOOK #hook,
                     CTXT #ctxt ],
             NONLOC #nonloc,
	     MODIFD #modif,
	     LKEYS #lkeys ],
	  KEY-ARG #keyarg ],
    SYNSEM [ LOCAL 
	    [ CAT 
	     [ HEAD #head & [ MINORS.ALTMIN non_event_rel ],
               VAL [ SUBJ #subj,
		     COMPS *cons* &
		     [ FIRST [ --MIN enough_deg_rel,
			       LOCAL local &
				     [ CAT [ HEAD adv &
						  [ MOD < > ],
					     VAL.SPEC 
					       < [ LOCAL.CONT.HOOK #hook ] > ],
				       CONT.HOOK #sphook ],
			       LEX +,
			       OPT - ] ],
		     SPR < anti_synsem >,
                     SPCMPS < > ],
	       MC #mc,
	       HC-LEX + ],
	      CONT.HOOK #hook,
	      CTXT #ctxt ],
	     NONLOC #nonloc & non-local_none,
	     MODIFD #modif,
	     LKEYS #lkeys ],
    KEY-ARG #keyarg,
    C-CONT [ RELS <! !>,
	     ICONS <! !> ],
    ARGS < #stem > ].

; |Kim is competent enough|
enough_addition_nocomps := basic_enough_addition &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < synsem >,
    C-CONT.HCONS <! !> ].

; |Kim is competent enough to hire|
enough_addition_wcomp := basic_enough_addition &
  [ SYNSEM.LOCAL 
	    [ CAT.VAL.COMPS < [ LKEYS.KEYREL.ARG2 #arg2 ],
			      synsem &
			      [ LOCAL [ CAT s_or_vp_inf_cat,
					CONT.HOOK.LTOP #vltop,
					CONJ cnil ],
				NONLOC.SLASH 1-dlist &
				      <! [ CAT np_cat_acc_min &
					       [ HEAD [ MINORS.MIN norm_nom_rel,
							MOD < > ] ],
					   CONT.HOOK.INDEX #xarg ] !>,
				OPT -,
				PUNCT.LPUNCT no_punct ] >,
	      CONT.HOOK.XARG #xarg ],
    C-CONT.HCONS <! qeq & [ HARG #arg2,
			    LARG #vltop ] !> ].

; For "eyed" of "wide-eyed"
;
noun_adj_lr := lex_rule_basic &
  [ DTR word_or_lexrule & #stem &
        [ INFLECTD -,
          SYNSEM [ LOCAL [ CAT [ HEAD noun &
                                      [ MOD < >,
                                        MINORS.MIN n-ed_rel ],
				 VAL #val &
                                      [ SUBJ < >,
                                       SPR < unexpressed & 
                                             [ --MIN quant_or_deg_rel ] >,
                                       COMPS < > ] ],
                           CONT.HOOK [ LTOP #nltop,
                                       INDEX #nind ],
                           CTXT #ctxt ],
		   NONLOC #non-local ],
          KEY-ARG #keyarg ],
    SYNSEM [ LOCAL [ CAT [ HEAD n-ed &
                                [ MOD < >,
                                  MINORS [ MIN norm_nom_rel,
                                           ALTMIN no_rel,
                                           NORM norm_rel ] ],
                           VAL #val ],
		     AGR #nind,
                     CTXT #ctxt ],
             NONLOC #non-local,
             MODIFD notmod ],
    C-CONT [ HOOK [ LTOP #nltop,
                    INDEX #nind ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    INFLECTD + ].

tough_adj_lr := lex_rule_basic &
  [ DTR word_or_lexrule & #stem &
        [ INFLECTD #infl,
	  ORTH #orth,
          SYNSEM reg_adj_atrans_synsem &
		 [ LOCAL [ CONT.HOOK [ LTOP #ltop,
                                       INDEX #ind ],
                           CTXT #ctxt ],
		   NONLOC #non-local ],
	  ALTS.TOUGH +,
          KEY-ARG #keyarg ],
    SYNSEM tough_adj_atrans_synsem &
	[ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN non_ellipt_rel ],
			 VAL.SPR.FIRST synsem &
			      [ --MIN more_or_very_deg_rel,
				LOCAL.CAT.HS-LEX #hslex ],
			 HS-LEX #hslex ],
		  CTXT #ctxt ],
	  MODIFD notmod,
	  NONLOC #non-local ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #ind ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    ORTH #orth,
    INFLECTD #infl ].


;; DPF 2012-12-01 - Identified missing PUNCT on dtr and mother, to prevent
;; e.g. spurious application of the paired_bracket rule.
;;
pre_noun_adj_lr := lex_rule_supermost & word_or_nonpunct_rule &
  [ DTR word_or_lexrule & #stem &
        [ INFLECTD +,
          SYNSEM [ LOCAL [ CAT [ HEAD noun &
                                      [ MOD < >,
                                        MINORS.MIN reg_nom_rel ],
				 VAL [ SUBJ < >,
				       SPR < synsem & 
					     [ --MIN quant_or_deg_rel ] >,
				       COMPS < > ] ],
			   CONT.HOOK [ LTOP #nhand,
                                       INDEX #nind ],
			   AGR.PNG.PN 3s,
			   CONJ cnil ],
		   NONLOC #nonloc,
		   PUNCT #punct,
		   LKEYS.KEYREL [ CFROM #cfrom, CTO #cto ],
		   PHON.ONSET #onset ],
	  KEY-ARG #keyarg ],
    SYNSEM adj_synsem_lex_rule &
	   [ LOCAL [ CAT [ HEAD.MOD.FIRST.LOCAL.CONT.HOOK [ LTOP #ltop,
							    INDEX #modind ],
			   VAL.SPR.FIRST anti_synsem_min ],
		     CONT.HOOK #hook,
		     CONJ cnil ],
             NONLOC #nonloc,
	     PUNCT #punct,
	     LEX +,
             MODIFD notmod,
	     PHON.ONSET #onset ],
    C-CONT [ HOOK #hook & [ LTOP #ltop,
			    INDEX #ind ],
             RELS <! [ PRED "_pre-_a_ante_rel",
		       LBL #ltop,
                       ARG0 #ind,
		       ARG1 #nind,
		       ARG2 #modind,
		       CFROM #cfrom, CTO #cto ],
		     [ PRED udef_q_rel,
                       ARG0 #nind,
                       RSTR #rhand,
		       CFROM #cfrom, CTO #cto ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !>,
	     ICONS <! !> ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    INFLECTD + ].

; Converts bipartite nouns which are prescriptively [IND -] ("*many sunglasses
; were broken") into less constrained variants which are used for more robust
; parsing.  (All ignoring the type/individual contrast which the ERG currently
; doesn't distinguish.)

bipart_lr := lex_rule_supermost & word_or_nonpunct_rule &
  [ INFLECTD -,
    ORTH #orth,
    GENRE prescrip,
    KEY-ARG #keyarg,
    DTR n_-_bipart_le & #stem &
        [ INFLECTD -,
          ORTH #orth,
	  SYNSEM [ LOCAL #local,
                   NONLOC #nonloc,
                   PUNCT #punct & [ LPUNCT no_punct,
                                    RPUNCT no_punct ],
                   LKEYS #lkeys,
		   PHON.ONSET #onset ],
          KEY-ARG #keyarg ],
    SYNSEM [ LOCAL #local &
                   [ CONT.HOOK.INDEX.IND - ],
             NONLOC #nonloc,
             LKEYS #lkeys,
             PUNCT #punct,
	     PHON.ONSET #onset ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #stem > ].


; 'Kim arrived, said Abrams'
; DPF 18-jul-07 - Restrict inverted subj to non-pronominal, to avoid spurious
; parse for e.g. "Kim knew she was afraid"
; In lexrules.tdl
; ; DPF 18-apr-08 - Also restrict subj to NORM norm_rel to exclude CP-WH NPs
; as in "remembered who arrived"
;; DPF 2012-10-20 -  Added SF prop to mother to prevent an inverted main-verb
;; S from being mistaken for a WH-phrase in the CP->NP rule.
;; DPF 2014-11-17 - Re 18-jul-07: But the ambiguity is there just as much for
;; "Kim knew the cat was afraid", and we want |the cat, said he|, so remove
;; this constraint, and accept the (real) ambiguity.
;
inverted_quote_lr := lex_rule_basic &
 [ ORTH #orth,
   INFLECTD +,
   DTR #dtr & 
       [ ORTH #orth,
         INFLECTD +,
         SYNSEM cp_comp_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          VAL [ SUBJ < #subj & canonical_synsem &
                                       [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
					 NONLOC.QUE 0-dlist ] >,
				COMPS #comps,
                                KCMP #keycomp ],
                          HC-LEX #hclex ],
                    CONT.HOOK #hook & [ INDEX.SF prop ],
                    AGR #agr,
                    CTXT #ctxt ],
            LKEYS #lkeys,
            NONLOC #nonlocal,
	    PHON.ONSET #onset ] ],
   SYNSEM quoting_verb_inv_synsem &
          [ LOCAL [ CAT [ HEAD #head &
                               [ TAM #tam,
                                --ADDIN [ ADDTAM #tam,
                                          ADDPN #pn ] ],
                          VAL [ COMPS < #subj . #comps >,
                                KCMP #keycomp &
                                      [ LOCAL.CAT.HEAD verb ] ],
                          HC-LEX #hclex ],
                    CONT.HOOK #hook,
                    AGR #agr & [ PNG.PN #pn ],
		    CTXT #ctxt ],
            LKEYS #lkeys,
	    NONLOC #nonlocal,
	    PHON.ONSET #onset ],
   ARGS < #dtr >,
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

;; |he said "Yes."| from |he said "we should".|
;; and also |"Yes," he said.| from (derived) |"we should," he said.|
;;
cp_frag_lr := lex_rule_basic &
 [ ORTH #orth,
   INFLECTD -,
   DTR #dtr & 
       [ ORTH #orth,
         INFLECTD -,
         SYNSEM cp_comp_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          VAL [ SUBJ #subj & < canonical_synsem &
                                       [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
					 NONLOC.QUE 0-dlist ] >,
				COMPS.FIRST.LOCAL.CAT.HEAD subst,
				KCMP.--SIND.SF prop ],
                          HC-LEX #hclex ],
                    CONT.HOOK #hook & [ INDEX.SF prop ],
                    AGR #agr,
                    CTXT #ctxt ],
            LKEYS.KEYREL #keyrel,
            NONLOC #nonlocal,
	    PHON.ONSET #onset ] ],
   SYNSEM cp_frag_intrans_verb &
          [ LOCAL [ CAT [ HEAD #head &
                               [ TAM #tam,
                                --ADDIN [ ADDTAM #tam,
                                          ADDPN #pn ] ],
                          VAL.SUBJ #subj,
                          HC-LEX #hclex ],
                    CONT.HOOK #hook,
                    AGR #agr & [ PNG.PN #pn ],
		    CTXT #ctxt ],
            LKEYS.KEYREL #keyrel,
	    NONLOC #nonlocal,
	    PHON.ONSET #onset ],
   ARGS < #dtr >,
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

;; Foreign words
;;
foreign_lr := lex_rule_supermost & word_or_nonpunct_rule &
  [ INFLECTD +,
    ORTH #orth,
    KEY-ARG #keyarg,
    DTR #stem &
	[ INFLECTD na_or_+,
	  ORTH #orth,
	  SYNSEM basic_lex_synsem &
		 [ LOCAL.CONT.HOOK [ LTOP #hand,
				     INDEX #index1 ],
		   NONLOC #nonloc,
                   PUNCT [ LPUNCT dq_or_sq_or_lital_punct,
			   RPUNCT dq_or_sq_or_rital_punct ],
                   LKEYS #lkeys,
		   PHON.ONSET #onset ],
          KEY-ARG #keyarg,
          GENRE #genre ],
    SYNSEM lex_phr_synsem &
	   [ LOCAL [ CAT nomp_cat &
			 [ HEAD noun & 
				[ MOD < >,
				  MINORS [ MIN norm_nom_rel,
					   ALTMIN no_rel ] ],
			   VAL.SPR < > ],
		     CONT nom-obj &
			 [ HOOK.INDEX #index ],
		     CONJ cnil,
		     AGR #index & [ PNG.PN 3s ] ],
	     NONLOC #nonloc & non-local_none,
	     LEX +,
	     LKEYS #lkeys & [ KEYREL [ CFROM #from, CTO #to ] ],
             PUNCT.RPUNCT clause_or_no_punct,
	     PHON.ONSET #onset ],
    GENRE #genre,
    C-CONT [ HOOK [ LTOP #hand,
		    INDEX #index ],
	     RELS <! [ LBL #hand,
		       PRED fw_seq_rel,
		       ARG0 #index,
		       L-INDEX #index1,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #stem > ].


;; Punctuation rules
;
; Making mother be SYNSEM lex_punct_synsem prevents spurious application of
; derivational rules that are constrained by synsem type.  Assumes that
; right punctuation will attempt to attach to each derivational stage of
; a lexical entry - maybe not pretty, but can't be helped since PUNCT has
; to be inside SYNSEM, so can't identify synsems of hd-dtr and mother.

basic_punctuation_rule := lex_rule_supermost & word_or_punct_rule &
  [ ND-AFF +,
    KEY-ARG #keyarg,   
    DTR #dtr,
    ARGS < #dtr &
           [ KEY-ARG #keyarg,
	     SYNSEM [ OPT #opt,
                      LEX #lex,
                      LOCAL #local,
                      NONLOC #nonloc,
                      MODIFD #mod,
                      --SIND #sind,
                      PHON #phon,
                      PUNCT [ LPUNCT pair_or_no_punct,
			      RPUNCT.PSF #psf ],
                      LKEYS #lkeys ] ] >,
    SYNSEM lex_punct_synsem &
           [ OPT #opt,
             LEX #lex,
             LOCAL #local,
             NONLOC #nonloc,
             MODIFD #mod,
             --SIND #sind,
             PHON #phon,
	     PUNCT.RPUNCT.PSF #psf,
             LKEYS #lkeys ],
    C-CONT.RELS <! !> ].

punctuation_rule := basic_punctuation_rule &
  [ INFLECTD #infl & na_or_+,
    SYNSEM.PUNCT.RCLSTR #rclstr,
    GENRE #genre,
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT.RCLSTR #rclstr,
             GENRE #genre ] > ].

punctuation_clause_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT clause_punct ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct ] ] > ].  

punctuation_period_rule := punctuation_clause_rule &
  [ SYNSEM.PUNCT.RPUNCT.PSF punct-prop-comm ].

punctuation_qmark_rule := punctuation_clause_rule &
  [ SYNSEM.PUNCT.RPUNCT.PSF punct-ques ].

punctuation_semicol_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT semicol_punct &
                          [ PSF punct-prop-comm ] ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct ] ] > ].

w_semicol_rule := punctuation_semicol_rule.
w_double_semicol_rule := punctuation_semicol_rule.

punctuation_colon_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT colon_punct ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct ] ] > ].

basic_punctuation_comma_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RCLSTR #rclstr ],
    GENRE #genre,
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct,
                            RCLSTR #rclstr ],
             GENRE #genre ] > ].

punctuation_comma_rule := basic_punctuation_comma_rule &
  [ SYNSEM.PUNCT [ PNCTPR no_ppair,
                   PAIRED no_ppair,
                   RPUNCT comma_punct ] ].

punctuation_rparen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT rparen_punct & [ PSF #pred ],
                   RCLSTR [ RPAREN +,
			    RFP #rfp ] ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT clause_or_pair_or_no_punct &
                                   [ PSF #pred ],
			    RCLSTR.RFP #rfp ],
             GENRE #genre ] >,
    GENRE #genre ].

w_rparen_rule := punctuation_rparen_rule.
w_comma-rp_rule := punctuation_rparen_rule.
w_rbrack_rule := punctuation_rparen_rule.

punctuation_lparen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT lparen_punct,
                   RPUNCT #rpunct,
                   PNCTPR #pnctpr,
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ RPUNCT #rpunct,
                            PNCTPR #pnctpr,
                            RCLSTR #rclstr ],
             GENRE #genre ] >,
    GENRE #genre ].

w_lparen_rule := punctuation_lparen_rule.
w_lbrack_rule := punctuation_lparen_rule.

; DPF 03-jun-10 - Changed LPUNCT from dq_or_no_punct to no_punct to avoid
; spurious ambiguity for |"cat"|
;;
punctuation_dqright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                   RPUNCT dq_punct & [ PSF #pred ],
		   RCLSTR #rclstr,
		   PAIRED #paired,
		   PNCTPR #pnctpr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT #lpunct,
                            RPUNCT.PSF #pred,
			    RCLSTR #rclstr,
			    PAIRED #paired,
			    PNCTPR #pnctpr ],
             GENRE #genre ] >,
    GENRE #genre ].

punctuation_dqleft_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT dq_punct,
                   RPUNCT #rpunct,
                   RCLSTR #rclstr,
		   PAIRED #paired,
		   PNCTPR #pnctpr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ RPUNCT #rpunct &
	     		           comma_or_rbc_or_clause_or_pair_or_no_punct,
                            RCLSTR #rclstr,
			    PAIRED #paired,
			    PNCTPR #pnctpr ],
             GENRE #genre ] >,
    GENRE #genre ].
    
punctuation_sqright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT sq_punct & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT comma_or_clause_or_no_punct &
                                   [ PSF #pred ],
                            RCLSTR #rclstr ],
             GENRE #genre ] >,
    GENRE #genre ].
    
punctuation_sqleft_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT sq_punct,
                   RPUNCT #rpunct,
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ RPUNCT #rpunct,
                            RCLSTR #rclstr ],
             ALTS.SQPNCT +,
             GENRE #genre ] >,
    GENRE #genre ].
    
punctuation_hyphen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT hyphen_sgl & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT no_punct &
                                   [ PSF #pred ],
                            RCLSTR #rclstr ],
             GENRE #genre ] >,
    GENRE #genre ].
    
w_hyphen_rule := punctuation_hyphen_rule.
w_threedot_rule := punctuation_hyphen_rule.

punctuation_bang_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT clause_punct &
                          [ PSF punct-prop-comm ] ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT clause_or_pair_or_no_punct ] ] > ].
    
punctuation_asterisk_rule := punctuation_rule &
  [ SYNSEM.PUNCT #punct,
    ARGS < [ SYNSEM.PUNCT #punct ] > ].
    
w_asterisk_rule := punctuation_asterisk_rule.
w_asterisk_pre_rule := punctuation_asterisk_rule.

punctuation_comma_informal_rule := basic_punctuation_comma_rule &
  [ INFLECTD +,
    SYNSEM.PUNCT [ PNCTPR ppair,
                   RPUNCT rbcomma_punct ],
    GENRE nonformal ].
    
punctuation_period_robust_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT clause_punct ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct ] ] > ].
    
; DPF 14-feb-08 - Note that we can't make ARGS..RPUNCT be 
; clause_or_pair_or_no_punct since this makes the rule circular for
; generation (adding arbitrary numbers of question marks).  We want
; to analyze multiple qmarks, but not generate them. So we'll have to
; have a separate rule to admit ?? (or !?) which we can exclude for
; generation.

punctuation_clmark_qmark_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT clause_punct &
                          [ PSF punct-ques ] ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT clause_punct ] ] > ].
    
w_qqmark_rule := punctuation_clmark_qmark_rule.
w_qmark-bang_rule := punctuation_clmark_qmark_rule.

punctuation_italleft_rule := basic_punctuation_rule &
  [ INFLECTD na,
    SYNSEM.PUNCT [ LPUNCT lital_punct,
                   RPUNCT #rpunct,
                   RCLSTR #rclstr ],
    ARGS < word_or_infl_or_punct_rule &
	   [ INFLECTD +,
	     SYNSEM [ PUNCT [ RPUNCT #rpunct & 
				     comma_or_rbc_or_clause_or_no_punct,
			      RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre ].
    
punctuation_italright_rule := basic_punctuation_rule &
  [ INFLECTD na,
    SYNSEM.PUNCT [ LPUNCT #lpunct & dq_or_sq_or_lital_or_no_punct,
                   RPUNCT rital_punct & [ PSF #psf ],
		   RCLSTR [ RPAREN #rparen,
			    RFP + ] ],
    ARGS < [ INFLECTD na_or_+,
	     SYNSEM [ PUNCT [ LPUNCT #lpunct,
			      RPUNCT clause_or_no_punct & [ PSF #psf ],
			      RCLSTR.RPAREN #rparen ] ],
             GENRE #genre ] >,
    GENRE #genre ].
    
;; DPF 29-mar-10 - Don't remember why dtr was constrained to word_or_infl_rule,
;; but it blocks e.g. |``(For| so remove it and see what happens. 
;; DPF 08-apr-10 - Well, the above constraint ensures that these two rules
;; apply in only one order when a single token is marked with both left and
;; right.  Otherwise we get two derivations for the dropped-italic analysis
;; of e.g. ini
;; So for now, we'll sacrifice the tokens like |``(For|, until a better
;; solution emerges to control the interaction of these two rules.
;;
punct_drop_italleft_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT no_punct,
                   RPUNCT #rpunct,
                   RCLSTR #rclstr ],
    ARGS < word_or_infl_rule &
	   [ INFLECTD #infl,
	     SYNSEM [ PHON.ONSET con_or_voc,
		      PUNCT [ RPUNCT #rpunct & no_punct,
			      RCLSTR #rclstr ] ],
             GENRE #genre ] >,
    GENRE #genre ].
    
punct_drop_italright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT #rpunct,
		   RCLSTR [ RPAREN #rparen,
			    RFP - ] ],
    ARGS < [ INFLECTD #infl,
	     SYNSEM [ PHON.ONSET con_or_voc,
		      PUNCT [ LPUNCT #lpunct & no_punct,
			      RPUNCT #rpunct & clause_or_no_punct,
			      RCLSTR.RPAREN #rparen ] ],
             GENRE #genre ] >,
    GENRE #genre ].
    
; DPF 09-aug-09 - Restrict these prefixing rules to native entries, since
; there is little benefit in decomposition of unknown words, and it's hard
; to get the PHON.ONSET right for native (con) vs generic (unk)
;; DPF 2010-10-10 - Consider |reschedule| which has an optional complement,
;; even though |schedule| has an obligatory one.  FIX?

verb_prefix_rule := lex_rule_supermost & word_or_nonpunct_rule &
  [ INFLECTD +,
    DTR word_or_lexrule & #stem &
	[ INFLECTD +,
	  SYNSEM [ LOCAL [ CAT #cat & [ HEAD verb & 
					     [ AUX - ],
					VAL.SUBJ.FIRST synsem ],
			   CONT [ HOOK #hook &
				       [ LTOP #lbl,
					 INDEX #vindex ] ],
			   CONJ cnil,
			   CTXT #ctxt ],
                   PUNCT #punct & [ LPUNCT no_punct,
                                    RPUNCT no_punct ],
		   NONLOC #nonloc,
		   LKEYS.KEYREL [ CFROM #from, CTO #to ],
		   PHON.ONSET con_or_voc ],
          KEY-ARG #keyarg,
          GENRE #genre ],
    SYNSEM derived_verb_synsem &
	 [ LOCAL 
	   [ CAT #cat,
	     CONT.HOOK #hook,
	     CONJ cnil,
	     CTXT #ctxt ],
	   PUNCT #punct,
	   NONLOC #nonloc,
	   LKEYS.KEYREL [ CFROM #from, CTO #to ] ],
    GENRE #genre,
    KEY-ARG #keyarg,
    ARGS < #stem >,
    C-CONT [ RELS <! [ LBL #lbl,
		       ARG1 #vindex,
		       CFROM #from, CTO #to ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

v_v-re_rule := verb_prefix_rule.
v_v-pre_rule := verb_prefix_rule.
v_v-mis_rule := verb_prefix_rule.
v_v-co_rule := verb_prefix_rule.
v_v-un_rule := verb_prefix_rule.
v_v-counter_rule := verb_prefix_rule.

dependency_annotation_lr := lex_rule_supermost & word_or_punct_rule &
  [ ND-AFF +,
    KEY-ARG #keyarg,   
    INFLECTD #infl,
    SYNSEM #synsem,
    ARGS < #dtr &
           [ KEY-ARG #keyarg,
	     INFLECTD #infl,
	     SYNSEM #synsem,
             GENRE #genre ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    GENRE #genre,
    DTR #dtr ].

;; DPF 2014-04-23 - In response to multiple requests for a subtyping of the
;; inflectional rule type, I'm adding the following subtypes, to provide a
;; one-to-one association of inflectional rules and the types that they
;; instantiate.

n_pl_inflrule := lex_rule_infl_affixed.
v_3s-fin_inflrule := lex_rule_infl_affixed.
v_psp_inflrule := lex_rule_infl_affixed.
v_pst_inflrule := lex_rule_infl_affixed.
v_prp_inflrule := lex_rule_infl_affixed.
v_prp-nf_inflrule := lex_rule_infl_affixed.
v_n3s-bse_inflrule := lex_rule_infl_affixed.
n_sg_inflrule := lex_rule_infl_affixed.
n_ms_inflrule := lex_rule_infl_affixed.
n_ms-cnt_inflrule := lex_rule_infl_affixed.
n_pl-cur_inflrule := lex_rule_infl_affixed.
v_pas-norm_lexrule := norm_passive_verb_lr.
v_pas-cp_lexrule := norm_passive_verb_lr.
v_pas-dat_lexrule := basic_passive_verb_lr.
