;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  lexrules.tdl
;;;
;;;  Inflectional affixes and derivational lexical rules
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;  Last revised: Dan Flickinger, 20-Oct-97
;;;
;;;  $Id$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Inflectional affixes
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Verbal inflections

non_fin_verb := local & 
  [ STEMHEAD vstem,
    CAT.HEAD [ VOICE active,
	       TENSE #vittense ],
    CONT.INDEX.VIT.VITTENSE #vittense ].

; Need to constrain MOD value for PRP verbs.  Also for passive participles.


;; Verbal affix for present and passive participles, which can modify N-bars

verb_participle_affix := local &
  [ STEMHEAD vstem,
    CAT [ VAL.SUBJ < [ LOCAL local & [ CONT.INDEX #nind ] ] >,
	  HEAD.MOD intersective_mod &
		   [ CAT [ HEAD noun &
				[ POSS - ],
			   VAL [ SPR < synsem & [ OPT - ] >,
				 COMPS *olist* ] ],
		     CONT [ TOP #hand,
			    INDEX #nind ] ] ],
    CONT [ TOP #hand,
	   INDEX #nind ] ].

prp_verb := non_fin_verb & verb_participle_affix &
  [ CAT.HEAD [ VFORM prp,
	       PRD + ] ].

psp_verb := non_fin_verb & nomod_local &
  [ CAT [ HEAD [ VFORM psp,
		 PRD - ],
	  VAL.SUBJ < [ OPT - ] > ],
    CONT psoa & [ INDEX #event,
		  KEY.EVENT #event ] ].

non_perf :< local.

#|
bse_verb := non_fin_verb & non_perf & nomod_local &
  [ CAT [ HEAD [ VFORM bse,
		 PRD - ],
	  VAL.SUBJ < [ OPT - ] > ] ].
|#

; Since finite verbs can project relative clauses, we introduce [MOD @nbar] here,
; and make sure that no other projections of finite verbs can be adjuncts, 
; through constraints on the head-adjunct phrase type.

; Finite verbs cannot identify their INDEX with ECONT.INDEX, since the ECONT will
; only be employed in relative clauses, where the ECONT has to be unifiable with
; the ref-ind of the noun being modified.

fin_verb := non_perf &
  [ STEMHEAD vstem,
    CAT [ HEAD [ PRD -,
                 VOICE active,
		 MOD intersective_mod & @nbar() ],
	  VAL.SUBJ < @nomp($case=nom) &
			 [ OPT - ] > ],
    CONT psoa & [ INDEX #event,
		  KEY.EVENT #event ] ].

pres_verb := fin_verb & 
  [ CAT.HEAD.MOOD indicative* ].

past_verb := fin_verb & 
  [ CAT.HEAD [ VFORM fin,
	       TENSE past* & #vittense,
               MOOD indicative* ],
    CONT.INDEX.VIT.VITTENSE #vittense ].

subjunctive_verb := fin_verb & 
  [ CAT.HEAD [ VFORM fin,
	       MOOD subjunctive,
	       TENSE #vittense ],
    CONT.INDEX.VIT.VITTENSE #vittense ].

third_sg_fin_verb := pres_verb &
  [ CAT.HEAD [ VFORM fin,
	       TENSE present* & #vittense ],
    CONT.INDEX.VIT.VITTENSE #vittense,
    AGR.PNG png & [ PN 3sg ] ].

; Instead of the usual identification of HEAD.TENSE with VIT.VITTENSE, here we
; identify VITTENSE with VFORM, which is underspecified for base or fin-non3sg, 
; and we interpret the feature semantically after parsing.

non_third_sg_fin_verb := pres_verb &
  [ CAT [ HEAD [ VFORM fin_or_bse & #vittense,
		 TENSE present* ],
	  VAL.SUBJ < [ LOCAL local & [ CONT nom-obj ] ] > ],
    CONT.INDEX.VIT.VITTENSE #vittense,    
    AGR.PNG png & [ PN non3sg & strict_pn ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Nominal inflections

sing_noun := local &
  [ STEMHEAD nstem,
    CONT.INDEX [ PNG png & [ PN 3sg*,
			     GEN neut* ],
		 DIVISIBLE - ] ]. 

plur_noun := local &
  [ STEMHEAD nstem,
    CONT.INDEX [ PNG png & [ PN 3pl* ],
		 DIVISIBLE + ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Adjectival inflections
;;
;;  May-96: Martina

pos_adj := local &
  [ STEMHEAD astem,
    CAT.VAL.SPR < [ LOCAL local &
				[ CONT.KEY very_deg_rel ] ] > ].

er_comp_adj := local &
  [ STEMHEAD astem,
    CAT.VAL.SPR < [ LOCAL local &
				[ CONT.KEY much_deg_rel ] ] > ].

est_super_adj := local &
  [ STEMHEAD astem,
    CAT.VAL.SPR < [ LOCAL local &
				[ CONT.KEY def_rel ],
			  OPT - ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Place holder affix for -ly

-ly := local & [ CAT.HEAD no_head ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  (Non-inflectional) lexical rules
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; AAC - INFLECTED added so that the relationship
;;; between inflectional morphology and lexical rules
;;; which is hacked into PAGE can be represented declaratively
;;;
;;; lex_rule_infl turns uninflected things into inflected ones
;;; but otherwise does inheritance
;;; everything else requires inflected forms

lex_rule_supermost := word &
  [ DTR sign ].

lex_rule_infl := lex_rule_supermost &
  [ NEEDS-AFFIX bool,
    INFLECTED +,
    AFFIX #affix,
    KEY-ARG #keyarg,   
    SYNSEM #synsem,
    ARGS < #dtr & [ AFFIX #argaff ] >,
    DTR #dtr & [ INFLECTED -,
                 AFFIX #affix,
                 KEY-ARG #keyarg,   
                 SYNSEM #synsem,
                 ARGS < [ AFFIX #argaff ] , ... > ] ].


lex_rule_infl_affixed := lex_rule_infl & affix_bearing.

lex_rule_infl_no-affix := lex_rule_infl & non_affix_bearing.



; ERB (05-10-97) Now that sai stamps MESSAGE int_rel on its output, that
; default has to be taken out of lex_rule.  To avoid breaking anything else, I
; am making a new type lex_rule_super that is just like the current lex_rule
; except that it doesn't identify the messages, and then having lex_rule do
; that identification.

lex_rule_super := lex_rule_supermost &
  [ DTR [ INFLECTED +,
          SYNSEM.LOCAL local &
		       [ CONT [ COMPKEY #ckey,
				OCOMPKEY #ockey ],
			 CONJ cnil,
			 CTXT.C-INDS #c-inds ] ],
    INFLECTED +,
    SYNSEM.LOCAL local &
	[ CONT [ COMPKEY #ckey,
		 OCOMPKEY #ockey ],
	  CONJ cnil,
	  CTXT.C-INDS #c-inds ] ],
  status: lex-rule.

lex_rule := lex_rule_super &
  [ DTR #stem &
	[ SYNSEM.LOCAL [ CAT.MC #mc,
			 CONT.MESSAGE #msg ] ],
    SYNSEM.LOCAL [ CAT.MC #mc,
		   CONT.MESSAGE #msg ],
    ARGS < #stem > ].

two_dtr_lex_rule := lex_rule_super &
  [ LDTR #ldtr &
	[ SYNSEM.LOCAL [ CAT.MC #mc,
			 CONT.MESSAGE #msg ] ],
    RDTR #rdtr,
    SYNSEM.LOCAL [ CAT.MC #mc,
		   CONT.MESSAGE #msg ],
    ARGS < #ldtr, #rdtr > ].

;;
;;  Forms derived from inflected verbs
;;

; ERB (05-10-97) Before we had a special rule hcomp_yn_root for matrix polar
; questions.  Now, the unique head complement rule is taking over this job.
; To do this, we must put the int_rel onto the inverted auxiliaries (see also
; sai_synsem).  The original objection to this was that the inverted
; auxiliaries are used for things other than matrix questions (i.e., negative
; inversion).  However, a) we don't currently have an analysis of negative
; inversion, and b) it's not clear that they are the same auxiliaries.  The
; most obvious test -- 1st person aren't -- is not available since the
; contracted auxiliaries are in general disallowed in negative inverstion
; (polarity effect?).
;
; At the moment this is allowing "Will who sleep?" and "Will Kim see who?"
; (actually two parses of the latter).  This is fine, except that this is not
; producing the apropriate semantics.  In fact, all ynq (matrix and
; subordinate) are not currently specified for PARAMS.  I think this will be
; easier to fix once we have a) lexical threading and b) an implementation of
; the analysis of echo questions, so I am leaving it for later.
 
sai := lex_rule_super &
  [ STEM #orth,
    DTR #stem &
	[ STEM #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD #head & verb &
				      [ INV +,
					VFORM fin ],
				 VAL [ SUBJ < #subj >,
					   COMPS #comps,
					   SPR #spr,
					   --KEYCOMP #keycomp ] ],
			   CONT [ TOP #top,
				  INDEX #ind,
 				  LISZT #liszt,
 				  KEY #key,
				  H-STORE #hstore,
				  H-CONS #hcons ],
			   ARG-S #arg-s ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM sai_synsem &
	 [ LOCAL [ CAT [ HEAD #head, 
			 VAL [ COMPS < #subj & [ OPT - ]
					   . #comps >,
				   SPR #spr,
				   --KEYCOMP #keycomp ] ],
		   CONT [ TOP #top,
			  INDEX #ind,
			  LISZT #liszt,
			  KEY #key,
			  H-STORE #hstore,
			  H-CONS #hcons ],
		   ARG-S #arg-s ],
	   NON-LOCAL #nonloc ],
    ARGS < #stem > ].

tag := lex_rule_super &
  [ STEM #orth,
    DTR #stem &
	[ STEM #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD [ TENSE #tense & strict_tense,
				      MOOD indicative ],
			       VAL.COMPS.FIRST #subj ],
			 CONT [ KEY #key,
				H-STORE #hstore,
				H-CONS #hcons ] ],
		 NON-LOCAL #nonloc & 
		       [ SLASH 0-dlist,
			 REL 0-dlist,
			 QUE 0-dlist ] ] ],
    SYNSEM tag_synsem &
	 [ LOCAL [ CAT [ HEAD [ TENSE #tense ],
			 VAL.COMPS.FIRST #subj ],
		   CONT [ KEY #key,
			  H-STORE #hstore,
			  H-CONS #hcons ] ],
	   NON-LOCAL #nonloc ],
    ARGS < #stem > ].

neg_addition := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM aux_verb &
               [ LOCAL [ STEMHEAD vstem,
			 CAT [ HEAD #head & 
				    [ INV -,
				      VFORM fin ],
			       VAL [ SUBJ #subj,
				     COMPS #comps &
					  < [ LOCAL.CAT.HEAD subst ], ...>,
				     SPR #spr,
				     --KEYCOMP #keycomp ] ],
			 CONT [ TOP #vhand,
				INDEX #vindex,
				KEY #vkey,
				H-STORE #hstore,
				LISZT #vliszt ],
			 CTXT #ctxt,
			 ARG-S #arg-s ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   VAL [ SUBJ #subj,
				     COMPS *cons* &
				      < [ LOCAL local &
						[ CAT.HEAD neg,
						  CONT [ TOP #negtop,
							 KEY.ARG #vhand,
							 H-STORE #hstore ] ],
					  OPT - ] . #comps >,
				     SPR #spr,
				     --KEYCOMP #keycomp ] ],
		     CONT [ TOP #negtop,
			    INDEX #vindex,
			    LISZT #vliszt,
			    H-STORE #hstore,
			    H-CONS <! !>,
			    KEY #vkey & [ HANDEL #vhand ] ],
		     CTXT #ctxt,
		     ARG-S #arg-s ],
	     NON-LOCAL #nonloc ] ].

;; Need to work on generalizing the semantics - since we derive this entry
;; from the past participle, we have to discard the tense information from
;; the input - not clear yet how to do this in general.  For now we assume
;; that transitive verbs introduce a single relation, bound to the KEY attrib.

; This incorrectly orders the by_pp before all remaining comps - wrong for
; double-NP verbs, and incomplete for verbs with other oblique arguments,
; since this allows only one order.  But this latter is a general problem.

passive_verb := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM trans_subst & verb_synsem &
               [ LOCAL [ STEMHEAD vstem,
                         CAT [ HEAD.VFORM psp,
			       VAL [ SUBJ < [ LOCAL local &
						    [ CONT.INDEX #subjind,
						      THROLE #subjrole ], 
						  NON-LOCAL #snonloc ] >,
					 SPR #spr,
					 COMPS [ FIRST [ LOCAL local &
							[ CONT #objcont,
							  THROLE #objrole ],
							 NON-LOCAL #ononloc ],
						 REST #comps ] ] ],
			 CONT [ TOP #hand,
				KEY #key,
				H-STORE #hstore,
				H-CONS #hcons,
				LISZT #liszt ],
			 CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM modifier_synsem &
	 [ LOCAL verb_participle_affix &
		 [ CAT [ HEAD verb* & [ AUX -,
					VFORM pas,
					VOICE passive ],
			 VAL [ SUBJ < synsem & @nomp() &
					[ LOCAL [ CONT #objcont,
						  THROLE #objrole ],
					  NON-LOCAL #ononloc ] >,
				   SPR #spr,
				   COMPS < synsem & 
					   [ LOCAL local &
					     [ CAT [ HEAD prep,
						     VAL [ SUBJ < >,
							   SPR *olist*,
							   COMPS *olist* ] ],
					       CONT.KEY _by_pass_rel &
						   [ PREP #subjind ],
					       THROLE #subjrole ],
					     NON-LOCAL #snonloc,
					     OPT + ]
					   . #comps > ] ],
		   CONT [ TOP #hand,
			  H-STORE #hstore,
			  H-CONS #hcons,
			  LISZT #liszt,
			  KEY #key ],
		   CTXT #ctxt ],
	   NON-LOCAL #nonloc ] ].

particle_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM mod_n_or_vp_synsem &
               [ LOCAL [ CAT.VAL #val,
			 CONT [ TOP #top,
				INDEX #ind,
				KEY #key,
				H-STORE #hstore,
				H-CONS #hcons ],
			 CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM [ LOCAL [ CAT [ HEAD prep & [ MOD no-mod ],
			   VAL #val ], 
		     CONT [ TOP #top,
			    INDEX #ind,
			    H-STORE #hstore,
			    H-CONS #hcons,
			    LISZT <! !>,
			    KEY #key ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc ] ].

#|
; it-extraposition

it-extraposition := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM extraposable_synsem &
	       [ LOCAL [ CAT [ HEAD #head,
			       VAL [ SUBJ < [ LOCAL local &
						    [ CONT.INDEX #subjind,
						      THROLE #subjrole ] ] >,
					 COMPS #comps ] ] ],
			 CONT #cont,
			 CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM expl_it_subj_synsem &
	 [ LOCAL [ CAT [ VAL [ SUBJ < synsem & @nomp() &
					[ LOCAL.CONT.INDEX it-ind ] >,
				   COMPS < @cp($vform=fin) &
					   [ LOCAL [ CONT.INDEX #subjind,
						     THROLE #subjrole ],
					     OPT - ]
					   . #comps > ] ],
		   CONT #cont,
		   CTXT #ctxt ],
	   NON-LOCAL #nonloc ] ].
|#

;; This has the same problem as the passive lexical rule.  Since we derive the
;; gerund from the present particple, we somehow have to filter out the
;; progressive relation.

verbal_gerund := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ STEMHEAD vstem,
                         CAT [ HEAD.VFORM prp,
			       VAL.COMPS #comps ],
			 CONT [ TOP #hand,
				H-STORE #hstore,
				KEY #key,
				H-CONS #hcons ],
			 CTXT #ctxt ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM nonpronominal_synsem & nomod_synsem &
	   [ LOCAL [ CAT [ HEAD gerund*,
			   VAL.COMPS #comps ],
		     CONT [ TOP #hand,
			    INDEX #ind &
				   [ PNG png & [ PN 3sg*,
						 GEN neut* ] ],
			    LISZT <! #key, 
				     gerund_rel & #nkey &
				     [ INST #ind,
				       NOMARG #hand ] !>,
			    H-STORE #hstore,
			    H-CONS #hcons,
			    KEY #nkey ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc ] ].

poss_ing := verbal_gerund &
  [ DTR.SYNSEM [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.INDEX #subj,
					    NON-LOCAL #snonloc ] >,
		 NON-LOCAL.SLASH 0-dlist ],
    SYNSEM.LOCAL [ CAT.VAL [ SUBJ < >,
				 SPR < [ LOCAL local &
					 [ CAT [ HEAD det & [ POSS + ],
						 VAL [ SUBJ < >,
							   COMPS *olist* ] ],
					   CONT.COMPKEY [ POSSD #ind,
							  POSSR #subj ] ],
					 NON-LOCAL #snonloc,
					 OPT + ] > ],
		   CONT.INDEX #ind ] ].

#|

;;; AAC commented out - unification failure
;;; because nomod_synsem says SUBJ *null*

acc_ing := verbal_gerund &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT #subj ] >,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < @nomp($case=acc) &
				      [ LOCAL.CONT #subj ] >,
			       SPR < > ] ].

|#

;; DPF (12-Jul-98) In order to allow prenominal adjectives for nominal gerunds,
;; as in "regular tasting of wine is healthy", we have to treat the specifier
;; of the gerund as obligatory, since prenominal adjectives distinguish proper
;; from common nouns based on the optionality (or absence) of the specifier.
;; So these gerunds have to undergo the bare plural rule if no determiner is
;; present, which means they also have to be DIVISIBLE +.  Hmm.

nominal_gerund := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM verb_synsem &
	       [ LOCAL [ CAT [ HEAD [ VFORM prp,
				      AUX - ],
			       VAL.SUBJ < [ LOCAL local &
						    [ CONT.INDEX #subj ],
						NON-LOCAL #snonloc ] > ],
			 CONT [ TOP #hand,
				KEY #vkey,
				H-STORE #hstore,
				H-CONS #hcons ],
			 CTXT #ctxt ],
		 NON-LOCAL #nonloc ] ],
    SYNSEM nonpronominal_synsem & nomod_synsem &
	   [ LOCAL 
	     [ CAT 
	       [ HEAD noun*,
		 VAL [ SUBJ < >,
		       SPR < [ LOCAL local &
				     [ CAT [ HEAD det,
					     VAL [ SUBJ < >,
						   SPR *olist*,
						   COMPS *olist* ] ],
				       CONT [ INDEX #ind,
					      ALTKEY.POSSR #subj,
					      KEY.RESTR #hand ] ],
			       NON-LOCAL #snonloc,
			       OPT - ] > ] ],
	       CONT [ TOP #hand,
		      INDEX #ind & [ PNG png & [ PN 3sg*,
						 GEN neut* ] ],
		      LISZT <! #key & nominalize_rel & 
			     [ HANDEL #hand,
			       INST #ind ],
			     #vkey & [ HANDEL #hand ] !>,
		      KEY #key,
		      H-STORE #hstore,
		      H-CONS #hcons ],
	       CTXT #ctxt ],
	     NON-LOCAL #nonloc ] ].

intrans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM intrans_subst & 
	       [ LOCAL.CAT.VAL.COMPS #comps ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #comps ].


;; This is too restrictive.  It only forms nominal gerunds from strictly
;; transitive verbs.  So, it doesn't give you "Kim's putting of food on the
;; table" or "Kim's warning of Sandy that it would rain" or "Kim's giving of
;; raisins to the ants".  
;;  To avoid ambiguity with the intransitive nominal gerund, we make the PP
;; obligatory.
trans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM trans_subst & 
	       [ LOCAL.CAT.VAL.COMPS < [ LOCAL local &
						   [ CONT.INDEX #index ] ] > ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < @pp() &
				     [ LOCAL.CONT [ INDEX #index,
						    KEY _of_rel & 
							[ PREP #index ] ],
				       OPT - ] > ].

date_det_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ STEMHEAD nstem,
                           CAT.VAL [ SPR < >,
                                         COMPS < [ OPT + ] > ],
			   CONT [ TOP #hand,
				  LISZT [ LIST #list,
					  LAST #last ],
				  KEY #altkey,
				  H-CONS #hcons ],
			   CTXT #ctxt ],
		   NON-LOCAL #nonloc ] ],
    SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD det,
			   VAL [ SUBJ < >,
				     SPR < >,
				     COMPS < > ] ],
		     CONT [ TOP #hand,
			    INDEX #ind,
			    LISZT [ LIST < #key & def_rel . #list >,
				    LAST #last ],
			    KEY #key &
				[ HANDEL #hand,
				  BV #ind ],
			    H-STORE <! #hand !>,
			    H-CONS #hcons,
			    ALTKEY #altkey ],
		     CTXT #ctxt ],
	     NON-LOCAL #nonloc ] ].

; "October": NP => Determiner
;          "(in) October" => "October first"

month_det_lr := date_det_lr &
  [ DTR.SYNSEM.LOCAL.CONT.KEY mofy_rel ].

; "Tuesday": NP => Determiner
;          "(on) Tuesday" => "Tuesday morning"

weekday_det_lr := date_det_lr &
  [ DTR.SYNSEM.LOCAL.CONT.KEY dofw_rel ].

adj_noun_lr := lex_rule &
  [ STEM #orth,
    DTR [ STEM #orth,
	  SYNSEM [ LOCAL [ STEMHEAD astem,
                           CAT [ VAL [ COMPS #comps,
					   SPR < #spr > ],
				 HEAD.PRD - ],
			   CONT [ KEY.HANDEL #ahand,
				  LISZT [ LIST #list,
					  LAST #last ],
				  H-STORE #hstore,
				  H-CONS #hcons,
				  MESSAGE #msg ],
			   CTXT #ctxt ],
		   NON-LOCAL #non-local ] ],
    SYNSEM adj_noun_synsem & 
	  [ LOCAL [ CAT [ VAL [ COMPS #comps,
				    SPR < #spr, ... > ] ],
		    CONT [ KEY #key & [ ARG3 #ahand ],
			   LISZT [ LIST < #key . #list >,
				   LAST #last ],
			   H-STORE #hstore,
			   H-CONS #hcons,
			   MESSAGE #msg ],
		    CTXT #ctxt ],
	    NON-LOCAL #non-local ] ].

adj_noun_personal_lr := adj_noun_lr &
  [DTR.SYNSEM.LOCAL.CONT.KEY adj_personal_rel,
   SYNSEM adj_noun_personal_synsem].

adj_noun_abstract_lr := adj_noun_lr &
  [DTR.SYNSEM.LOCAL.CONT.KEY adj_abstract_rel,
   SYNSEM adj_noun_abstract_synsem].


;; The partitive construction rule introduces a new type of relation: 
;; part_of_rel, which contains the semantic information of the partitive.
;; The features of the relation, a subtype of nom_rel, are
;; - HANDEL, 
;; - INST, the index of the NP,
;; - SET, the handle of the PP complement, defining the set of which the head 
;;        determines a subset,
;; - NPREP,the index of the PP complement of the head, which is actually the
;;        index of the NP complement of that PP.
;; The idea is that there is a difference between, for example, "some books", 
;; and "some of the books". In the first case, "books" can refer to a subset
;; of the set of all the existing books, and "some" quantifies over the 
;; set of all existing books. In the second case, "some" refers to a subset of
;; the set of books defined by "the books": that set cannot refer to the 
;; universal set of all existing books. The relation "part_of_rel" tries to
;; capture that notion of subset of a certain set (defined by the context, or 
;; the determiner of the NP complement): the subset has an index 
;; (INST), and the defined set is referred to by "SET", which is the handle of
;; the prepositional phrase, and also the handle of the determiner of the 
;; prepositional complement.  We thus give partitives a complex lexical
;; semantics, including both the part_of_rel and the original quantifier
;; relation, with its usual attributes.

;; A problem which remains is to get the right agreement with the right head.
;; At the moment, the index of the head is the same as the index of the 
;; original determiner. As an example, "all" can be mass or plural, and is 
;; going to agree with a singular or a plural verb, whatever its complement is
;; ("all of the cake", "all of the students"). If we decide to have the index
;; of the construction being the index of the complement noun, what about 
;; "each" ? "Each of the boys" will agree with a plural only, when it should
;; agree with a singular. On the other hand, there is also the problem of 
;; "all of the oats are", plural when "all" is the mass determiner here: 
;; agreement is determined, here, by the plural form of the complement noun.

part_constr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM part_det_synsem & 
	  [ LOCAL.CONT [ TOP #hand,
			 KEY #relation,
			 H-STORE #hstore,
			 H-CONS #hcons ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM partitive_noun_synsem & 
     [ LOCAL.CONT [ TOP #hand,
		    H-STORE #hstore,
		    H-CONS #hcons,
		    ALTKEY #relation ],
       NON-LOCAL #nonlocal ] ].


; NP-particle alternation (e.g. "look up the answer/look the answer up"
; Stamp canonical_synsem on NP of output, to avoid spurious parse for extraction
; of the NP, as in "Which problem did Kim figure out?"

NP_particle_lr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM particle_NP_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL [ SUBJ #subj,
				    COMPS < [ OPT #opt1 ], [ OPT #opt2 ] > ] ],
		    CONT #cont,
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM NP_particle_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL [ SUBJ #subj,
				    COMPS < canonical_synsem & [ OPT #opt2 ], 
					    [ OPT #opt1 ] > ] ],
		    CONT #cont,
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ].

dative_shift_lr := lex_rule &
 [ STEM #orth,
   DTR [ STEM #orth,
         SYNSEM ditrans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL.SUBJ #subj ],
		    CONT #cont,
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ],
   SYNSEM to_trans_verb &
	  [ LOCAL [ CAT [ HEAD #head,
			  VAL [ SUBJ #subj,
				    COMPS < [ OPT - ], [ OPT - ] > ] ],
		    CONT #cont,
		    CTXT #ctxt ],
	    NON-LOCAL #nonlocal ] ].

;;
;; Derivational rules 
;;

#|
agent_nom_rel := reg_nom_rel & arg_rel.

; This lexical rule should be applied by hand, e.g.: 
;
; :leval (apply-lexical-rule 'simple_agent_nominal 'walk1 "walker").
;
; Also, this type ought to inherit from the type intr_noun_word, but that type
; assumes that all common nouns have a singleton LISZT. 

simple_agent_nominal := lex_rule & norm_word & affix_bearing &
  [ DTR.SYNSEM [ LOCAL [ STEMHEAD vstem,
                         CAT [ HEAD [ AUX -*,
				      INV -,
				      VFORM bse ],
			       VAL.SUBJ < [ LOCAL local &
						  [ CONT.INDEX #sindex ] ] ] >,
			 CONT [ TOP #vhand,
				LISZT [ LIST #vlist,
					LAST #vlast ] ] ] ],
    SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CONT.KEY quant_rel ] >,
		     CONT [ INDEX #sindex,
			    KEY agent_nom_rel &
				  [ ARG #vhand ],
			    LISZT [ LIST.REST #vlist,
				    LAST #vlast ] ] ] ] ].

|#

specific_hour_adj := two_dtr_lex_rule &
  [ STEM < #lorth, #rorth >,
    LDTR [ STEM #lorth,
	   SYNSEM [ LOCAL.CONT [ INDEX #hind,
				 KEY #lkey & numbered_hour_rel ],
		    NON-LOCAL #nonloc ] ],
    RDTR [ STEM #rorth,
	   SYNSEM.LOCAL [ CAT.VAL.COMPS *olist*,
			  CONT.KEY #rkey & minute_rel ] ],
    SYNSEM lex_synsem &
	 [ LOCAL [ CAT [ HEAD adj &
			      [ PRD -,
				MOD intersective_mod &
				    [ CAT [ HEAD noun &
						 [ POSS -,
						   MOD no-mod ],
					    VAL [ SPR < synsem & [ OPT - ] >,
						  COMPS *olist* ] ],
				      CONT [ TOP #nhand,
					     INDEX #index & individual ] ] ],
			 POSTHEAD -,
			 VAL [ SPR < >,
			       SUBJ < >,
			       COMPS < > ] ],
		   CONT [ TOP #top,
			  INDEX #index,
			  --TOPKEY #lkey & [ HANDEL #top ],
			  KEY #lkey,
			  LISZT <! #lkey &
				   [ HANDEL #hhand,
				     INST #hind,
				     MIN #minute ],
				   temp_loc_rel &
				   [ HANDEL #nhand,
				     ARG #index,
				     PREP #hind ],
				   def_rel &
				   [ HANDEL #def,
				     BV #hind,
				     RESTR #hhand ],
				   #rkey &
				   [ INST #minute ] !>,
			  H-STORE <! #def !>,
			  H-CONS <! !> ] ], 
	   NON-LOCAL #nonloc ] ].





