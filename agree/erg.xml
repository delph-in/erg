<Workspace
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns="clr-namespace:agree;assembly=agree-sys"
  xmlns:cfg="clr-namespace:agree.configuration;assembly=agree-sys"
  xmlns:tsdb="clr-namespace:agree.itsdb;assembly=tsdb-core"
  xmlns:semi="clr-namespace:agree.semi;assembly=agree-sys">

    <Workspace.DefaultDirectories>
        <x:String>grammars\erg</x:String>
    </Workspace.DefaultDirectories>

    <Grammar x:Name="ERG"
             DisplayName="English Resource Grammar"
             Author="Flickinger (2000). in Flickinger, Oepen, Tsujii, Uszkoreit, eds."
             ItemCulture="en-US">
        <Grammar.AgreeConfig>
            <cfg:PetConfigLoader Filename="pet/english.set" />
        </Grammar.AgreeConfig>
        <Grammar.SemI>
            <semi:SemI PredicateArgs="{semi:PredicateArgsLoader etc/core.smi}">
                <semi:VpmLoader Filename="semi.vpm" />
            </semi:SemI>
        </Grammar.SemI>
        <Grammar.TestSentence>
            <StringItem>Kim runs very quickly.</StringItem>
            <!--<StringItem>The cat is sleeping.</StringItem>-->
            <!--<StringItem>We're going to invite you'll never guess who to the party.</StringItem>-->
            <!--<StringItem>We admire the National Aeronautics and Space Administration's Ames Research Center at Moffett Field, Calif.</StringItem>-->
        </Grammar.TestSentence>
    </Grammar>

    <PropertyRef Item="{x:PathRef {x:Reference ERG}, AgreeConfig}" Path="Parser.Chart.NonIdiomRoot" Value="root_non_idiom" />

    <PropertyRef Item="{x:PathRef {x:Reference ERG}, AgreeConfig}" Path="Generator.Chart.IgnoreRules">
        <ReadFileLines Filename="lkb/nogen-rules.set" />
    </PropertyRef>

    <!-- 
    'lkb/noparse-rules.set' lists two rules for exclusion, but neither is indicated:
       1. xp_brck-pr_c: should not be excluded since agree supports chart mapping;
       2. hdn_bnp-rbst_c: vacuous omission since it's already commented out in constructions.tdl
    <PropertyRef Item="{x:PathRef {x:Reference ERG}, AgreeConfig}" Path="Parser.Chart.IgnoreRules">
        <ReadFileLines Filename="lkb/noparse-rules.set" />
    </PropertyRef>
    -->

    <TdlGroup x:Name="ERG_TdlGroup">
        <!--
            the type of the following property is 'TdlLetterSets', which is a XAML dictionary of Char -to- LetterSet. You
            can add items directly to the default instance, as shown here. If you instead instantiate and assign a new 
            TdlLetterSets, its contents will be copied into the default instance. Exact duplicates are ignored, but 
            attempting to assign a new value to an existing key will fail. An effort is made to copy its properties 
            over to the default instance but this is hazy territory (are x:Name values registered on a namescope, for 
            example?). Note that there is no way to delete a letter set once it is added.
            -->
        <TdlGroup.TdlLetterSets>
            <LetterSet Identifier="c" Letters="bdfgklmnprstz" />
            <LetterSet Identifier="s" Letters="abcdefghijklmnopqrtuvwxyz05_/." />
            <LetterSet Identifier="t" Letters="bcdfghjklmnpqrstvwxyz" />
            <LetterSet Identifier="v" Letters="aeiou" />
            <LetterSet Identifier="."><![CDATA[abcdefghijklmnopqrstuvwxyzåøöáéíóúìµñABCDEFGHIJKLMNOPQRSTUVWXYZÅØÖÉÌ0123456789[](){}|>/_-…%`”"'’?!#+¦σΩÅØµ™°º]]></LetterSet>
            <LetterSet Identifier="p"><![CDATA[abcdefghijklmnopqrstuvwxyzåøöáéíóúìµñABCDEFGHIJKLMNOPQRSTUVWXYZÅØÖÉÌ0123456789,.?![](){}|>/_%”"'’#+¦σΩÅØ®…™°ºβ*]]></LetterSet>
            <LetterSet Identifier="q"><![CDATA[abcdefghijklmnopqrstuvwxyzåøöáéíóúìµñABCDEFGHIJKLMNOPQRSTUVWXYZÅØÖÉÌ0123456789,.?!()[]{}|>:/_-%`”"'’#+¦σΩ…µ™°º]]></LetterSet>
            <LetterSet Identifier="f"><![CDATA[abcdefghijklmnopqrstuvwxyzåøöáéíóúìµñABCDEFGHIJKLMNOPQRSTUVWXYZÅØÖÉÌ0123456789[]“"‘'#+¦$£=()[]{}|<_\-.,ÅØ½…µ™°ºβ]]></LetterSet>
            <LetterSet Identifier="k"><![CDATA[abcdefghijklmnopqrstuvwxyzåøöáéíóúìµñABCDEFGHIJKLMNOPQRSTUVWXYZÅØÖÉÌ0123456789.![](){}|>/_%”"'’#+¦σΩÅØ®…™°ºβ*]]></LetterSet>
            <LetterSet Identifier="b" Letters="!" />
        </TdlGroup.TdlLetterSets>

        <Tdl Content="{ReadFile fundamentals.tdl}" />
        <Tdl Content="{ReadFile lextypes.tdl}" />
        <Tdl Content="{ReadFile tmt.tdl}" />
        <Tdl Content="{ReadFile lfr.tdl}"             TdlType="LexicalFilteringRule" />
        <Tdl Content="{ReadFile syntax.tdl}" />
        <Tdl Content="{ReadFile ctype.tdl}" />
        <Tdl Content="{ReadFile lexrules.tdl}"/>
        <Tdl Content="{ReadFile dts.tdl}"/>
        <Tdl Content="{ReadFile delims.tdl}"/>
        <Tdl Content="{ReadFile auxverbs.tdl}" />
        <Tdl Content="{ReadFile letypes.tdl}" />

        <Tdl Content="{ReadFile mtr.tdl}" />

        <Tdl Content="{ReadFile lexicon.tdl}"         TdlType="LexicalEntry" />
        <Tdl Content="{ReadFile agree/lexicon-aux.tdl}" TdlType="LexicalEntry" />
        <Tdl Content="{ReadFile gle.tdl}"             TdlType="GenericLexicalEntry" />
        <Tdl Content="{ReadFile constructions.tdl}"   TdlType="SyntaxRule" />
        <!-- Rules with morphology are submitted as LexicalRules; detection of possible spelling-change is automatic -->
        <Tdl Content="{ReadFile inflr.tdl}"           TdlType="LexicalRule" />
        <Tdl Content="{ReadFile lexrinst.tdl}"        TdlType="LexicalRule" />
        <!-- Rules with morphology are submitted as LexicalRules; detection of possible spelling-change is automatic -->
        <Tdl Content="{ReadFile inflr-pnct.tdl}"      TdlType="LexicalRule" />
        <Tdl Content="{ReadFile parse-nodes.tdl}"     TdlType="NodeLabel" />
        <Tdl Content="{ReadFile roots.tdl}"           TdlType="StartSymbol" />
        <Tdl Content="{ReadFile trigger.mtr}"         TdlType="TriggerRule" />

    </TdlGroup >

    <TdlGroup x:Name="ERG_TmrGroup">
        <!--<Tdl Content="{ReadFile tmr/ner.tdl}"         TdlType="TokenMappingRule" />-->
        <Tdl Content="{ReadFile tmr/gml.tdl}"         TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/ptb.tdl}"         TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/spelling.tdl}"    TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/ne1.tdl}"         TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/split.tdl}"       TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/ne2.tdl}"         TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/class.tdl}"       TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/ne3.tdl}"         TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/punctuation.tdl}" TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/pos.tdl}"         TdlType="TokenMappingRule" />
        <Tdl Content="{ReadFile tmr/finis.tdl}"       TdlType="TokenMappingRule" />
    </TdlGroup>

    <TdlTokenizerFactory x:Name="tok_functor"
                         AgreeConfig="{x:PathRef {x:Reference ERG}, AgreeConfig}"
                         TdlLetterSets="{PathRef {x:Reference ERG_TdlGroup}, TdlLetterSets}" />

    <TypeLattice x:Name="ERG_tl">
        <TypeDictionary Grammar="{x:Reference ERG}">
            <TdlConstraintGrouper TdlType="Type">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <Where x:TypeArguments="Tdl" Functor="{TdlTypePred {x:Static TdlType.Type}}">
                        <x:Reference Name="ERG_TdlGroup" />
                    </Where>
                </TdlAggregator>
            </TdlConstraintGrouper>
        </TypeDictionary>
    </TypeLattice>

    <TypeUtils x:Name="ERG_tu" TypeLattice="{x:Reference ERG_tl}" />

    <FeatMgr x:Name="ERG_ftm" TypeUtils="{x:Reference ERG_tu}" />

    <Isometrics x:Name="ERG_im" FeatMgr="{x:Reference ERG_ftm}" />

    <ChartDependencyPaths x:Name="ERG_cdm" Isometrics="{x:Reference ERG_im}" />

    <QuickCheckFull x:Name="ERG_qc"
                Isometrics="{x:Reference ERG_im}"
                Paths="{ReadFileLines agree/erg-qc-paths.txt}" />

    <EntryMgr x:Name="ERG_em">

        <EntryMgr.TfsUnifier>
            <TfsUnifier Isometrics="{x:Reference ERG_im}" />
        </EntryMgr.TfsUnifier>

        <EntryMgr.MrsManager>
            <MrsManager Isometrics="{x:Reference ERG_im}" />
        </EntryMgr.MrsManager>

        <EntryMgr.TokenGeometry>
            <TokenGeometry Isometrics="{x:Reference ERG_im}" >
                <TokenGeometry.TokenMergeRuleTdl>
                    <Tdl xml:space="preserve">
<![CDATA[
merge_tmr := token_mapping_rule &
[ +INPUT < [ +PRED #pred,
             +CLASS #class,
             +TRAIT #trait,
             +FROM #from,
             +ID [ LIST #front, LAST #middle ], 
             +TNT [ +TAGS #tags, +PRBS #prbs ] ],
           [ +PRED #pred,
             +TRAIT #trait,
             +TO #to,
             +ID [ LIST #middle, LAST #back ], 
             +TNT [ +TAGS #tags, +PRBS #prbs ] ] >,
  +OUTPUT < [ +PRED #pred,
              +FORM #form,
              +CARG #carg,
              +CLASS #class,
              +TRAIT #trait,
              +FROM #from, 
              +TO #to,
              +ID [ LIST #front, LAST #back ],
              +TNT [ +TAGS #tags, +PRBS #prbs ] ] >,
  +CONTEXT < string & #form, string & #carg > ].        
]]>
                    </Tdl>
                </TokenGeometry.TokenMergeRuleTdl>
            </TokenGeometry>
        </EntryMgr.TokenGeometry>

        <EntryMgr.SyntaxRuleTokenGroups>
            <TdlConstraintGrouper TdlType="SyntaxRule">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <Where x:TypeArguments="Tdl" Functor="{TdlTypePred {x:Static TdlType.SyntaxRule}}" >
                        <x:Reference Name="ERG_TdlGroup" />
                    </Where>
                </TdlAggregator>
            </TdlConstraintGrouper>
        </EntryMgr.SyntaxRuleTokenGroups>

        <EntryMgr.LexicalRuleTokenGroups>
            <TdlConstraintGrouper TdlType="LexicalRule">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <Where x:TypeArguments="Tdl" Functor="{TdlTypePred {x:Static TdlType.LexicalRule}}">
                        <x:Reference Name="ERG_TdlGroup" />
                    </Where>
                </TdlAggregator>
            </TdlConstraintGrouper>
        </EntryMgr.LexicalRuleTokenGroups>

        <EntryMgr.LexicalEntryTokenGroups>
            <TdlConstraintGrouper TdlType="LexicalEntry">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <Where x:TypeArguments="Tdl" Functor="{TdlTypePred {x:Static TdlType.LexicalEntry}}">
                        <x:Reference Name="ERG_TdlGroup" />
                    </Where>
                </TdlAggregator>
            </TdlConstraintGrouper>
        </EntryMgr.LexicalEntryTokenGroups>

        <EntryMgr.GenericLexicalEntryTokenGroups>
            <TdlConstraintGrouper TdlType="GenericLexicalEntry">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <Where x:TypeArguments="Tdl" Functor="{TdlTypePred {x:Static TdlType.GenericLexicalEntry}}">
                        <x:Reference Name="ERG_TdlGroup" />
                    </Where>
                </TdlAggregator>
            </TdlConstraintGrouper>
        </EntryMgr.GenericLexicalEntryTokenGroups>

        <EntryMgr.NodeLabelTokenGroups>
            <TdlConstraintGrouper TdlType="NodeLabel">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <Where x:TypeArguments="Tdl" Functor="{TdlTypePred {x:Static TdlType.NodeLabel}}">
                        <x:Reference Name="ERG_TdlGroup" />
                    </Where>
                </TdlAggregator>
            </TdlConstraintGrouper>
        </EntryMgr.NodeLabelTokenGroups>

        <EntryMgr.TriggerRuleTokenGroups>
            <TdlConstraintGrouper TdlType="TriggerRule">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <Where x:TypeArguments="Tdl" Functor="{TdlTypePred {x:Static TdlType.TriggerRule}}">
                        <x:Reference Name="ERG_TdlGroup" />
                    </Where>
                </TdlAggregator>
            </TdlConstraintGrouper>
        </EntryMgr.TriggerRuleTokenGroups>

        <EntryMgr.StartSymbolTokenGroups>
            <TdlConstraintGrouper TdlType="StartSymbol">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <Where x:TypeArguments="Tdl" Functor="{TdlTypePred {x:Static TdlType.StartSymbol}}">
                        <x:Reference Name="ERG_TdlGroup" />
                    </Where>
                </TdlAggregator>
            </TdlConstraintGrouper>
        </EntryMgr.StartSymbolTokenGroups>

        <!-- Here, for the token mapping rules, we demonstrate an alternative to using the 'Where' markup 
            extension to select the tokens of a certain type (as for the entry types shown above). Instead, 
            we just grab all of the tokens from a dedicated TdlGroup we defined above ('ERG_TmrGroup') -->
        <EntryMgr.TokenMappingRuleTokenGroups>
            <TdlConstraintGrouper TdlType="TokenMappingRule">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <x:Reference Name="ERG_TmrGroup" />
                </TdlAggregator>
            </TdlConstraintGrouper>
        </EntryMgr.TokenMappingRuleTokenGroups>

        <EntryMgr.LexicalFilteringRuleTokenGroups>
            <TdlConstraintGrouper TdlType="LexicalFilteringRule">
                <TdlAggregator Functor="{x:Reference tok_functor}">
                    <Where x:TypeArguments="Tdl" Functor="{TdlTypePred {x:Static TdlType.LexicalFilteringRule}}">
                        <x:Reference Name="ERG_TdlGroup" />
                    </Where>
                </TdlAggregator>
            </TdlConstraintGrouper>
        </EntryMgr.LexicalFilteringRuleTokenGroups>

    </EntryMgr>

    <NodeLabeler EntryMgr="{x:Reference ERG_em}" />

    <TriggerRuleMgr EntryMgr="{x:Reference ERG_em}" />

    <MorphologyRules>
        <MorphologyRules.Irregulars>
            <Irregulars EntryMgr="{x:Reference ERG_em}" Items="{IrregsReader irregs.tab}" />
        </MorphologyRules.Irregulars>
    </MorphologyRules>

    <Lexicon EntryMgr="{x:Reference ERG_em}" />

    <ReppRootModule x:Name="ERG_repp"
                AgreeConfig="{PathRef {x:Reference ERG}, AgreeConfig}"
                ReppSource="{ReadFile rpp/tokenizer.rpp}"
                Calls="xml;ascii;lgt;quotes" />

</Workspace>
