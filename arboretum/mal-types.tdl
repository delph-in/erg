;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright Emily M. Bender 2003-2005
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  mal-types.tdl
;;;
;;;  mal-types for Arboretum project.
;;;

;; Type for bare_np_sg rule.  I want this to be different
;; from the one already in the grammar, because I want to
;; give it a distinguished quant rel that we can generate
;; from.

mal_bare_np_sg_phrase := generic_bare_np_phrase &
  [ SYNSEM [ LOCAL [ AGR [ DIV -,
			   PNG.PN 3s ],
                     CAT.HEAD.MINORS.ALTMIN implicit_q_rel ],
             MODIFD #modif ],
    ARGS < [ SYNSEM [ LOCAL [ AGR [ DIV -,
                                    PNG.PN 3s ],
                              CAT [ VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.MIN udef_q_rel ] >,
                                    HEAD [ MINORS.MIN norm_nom_rel,
					   --BARE + ] ] ],
                      MODIFD #modif & [ LPERIPH na_or_- ] ] ] >,
    C-CONT.RELS <! [ PRED mal_bare_div_q_rel ] !>,
    GENRE robust ].

mal_bare_np_sg_rule := rule & mal_bare_np_sg_phrase.

;; Type for quant-rel:

mal_bare_div_q_rel := implicit_q_rel & some_q_rel.

;; Mal NI (but not CE) rules, for lack of do support:

mal_adv_addition := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.AUX - ].

mal_sai_synsem := basic_sai_synsem & 
  [ LOCAL.CAT.HEAD.AUX - ].

; (ERB 2003-08-15) sai seems to be constraining its input
; to be INV +, rather than AUX +.  So, moving that constraint down
; to sai, and putting the opposite thing on mal_sai.

; (ERB 2003-08-15) Adding AUX - to DTR to keep auxiliaries out
; of this mal-rule.

mal_sai := basic_sai &
  [ SYNSEM mal_sai_synsem,
    DTR.SYNSEM.LOCAL.CAT.HEAD [ AUX -,
				INV - ] ].

; (ERB 2003-10-17) For verbs like "allow" taking a CP[to]
; complement with the PRO bound to arbitrary reference.  Regenerate
; with gerunds instead.  (Might need another class where we
; regenerate with an inserted pronoun "one", if there are verbs
; that show up in this pattern but can't take gerund complements.)

; (ERB 2003-10-17) This is going to be a fairly strange verb type.  I
; can't think of any true English verbs off hand that take an
; infinitival CP complement and allow arbitrary control of the subject
; of that complement.  Furthermore, this type is also putting in some
; extra semantics, in order to allow the right string to come back
; from the generator.  So, we're not inheriting from the usual places
; in the hierarchy.  For example, main_verb is constrained to have a
; single element RELSs list.  main_verb_mliszt will do, though,
; although this isn't what it was intended for. Likewise, I don't
; think any of the linking types lower in the hierarchy will do what
; we want.  Took some constraints from subj_equi_inf_lt to try to
; restrict what can show up as the complement.

; (ERB 2003-10-23) Can't currently generate with these entries,
; and I don't know why.  Can generate from the produced MRS at all,
; in fact.  The MRS produced isn't the same as the MRS for the target,
; because of gerunds are built from progressives and therefore have
; a different value for PROGR.  (There are some other mismatches,
; but they are compatible, so maybe it would work otherwise.)
; While we might consider changing the analysis of gerunds, I
; think the main conclusion to draw is that we will need some kind
; of a transfer component.  Maybe put everything there rather than
; trying to map from mal-formed syntax to well-formed semantics in
; the grammar itself?  If not everything, how to decide when to do
; which?

mal_v_inf_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & basic_two_arg & 
			  basic_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  quant_or_wh_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].
	   
mal_v_inf_from_cp_comp_verb := inf_intrans_subst & arg1_subj_lt & 
			       basic_two_arg & basic_verb_synsem &
   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
				       CONT [ HOOK [ INDEX #ind,
						     LTOP #larg ] ] ] ] >,
	     CONT [ RELS <! relation , 
			  quant_or_wh_relation &
			  [ PRED udef_q_rel,
			    ARG0 #ger,
			    RSTR #harg ],
			  gerund_relation &
			  [ ARG0 #ger,
			    ARG1 #ind,
			    LBL #larg ] !>,
		    HCONS <! qeq &
			     [ HARG #harg,
			       LARG #larg ] !> ] ],
     LKEYS.KEYREL arg12_relation &
	          [ ARG2 #ger ] ].

_they+that_q_mal_rel :< demonstrative_q_rel.

mal_finvp_rule := basic_unary_phrase & rule &
  [ INFLECTD +,
    GENRE robust,
    SYNSEM [ LOCAL [ CAT [ HEAD frag,
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
                           MC + ],
                     CONJ cnil ],
             NONLOC non-local_none ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VFORM fin,
                                                  INV - ],
                                    VAL [ SUBJ < unexpressed_reg >,
                                          COMPS *olist* ] ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX #event,
                                          XARG #arg0 ],
                              AGR.PNG #png ],
                      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                  REL 0-dlist,
                                  QUE 0-dlist ] ],
	     GENRE robust ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event ],
             RELS <! [ PRED _they+that_q_mal_rel,
                     ARG0 #arg0 & ref-ind & 
                          [ PNG #png & [ PN 3p,
                                         GEN neut ] ],
                     RSTR #rhand ],
                   [ LBL #nhand,
                     PRED generic_nom_rel,
                     ARG0 #arg0 ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !> ] ].
             
double_det_rule := head_valence_phrase & head_final & rule &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT #cat,
                     CONJ cnil ],
             NONLOC #nonloc,
	     MODIFD #modif,
             LEX #lex ],
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT #cat & [ HEAD det ],
                              CONT.HOOK #hdhook,
                              CONJ cnil ],
                      NONLOC #nonloc,
                      MODIFD #modif,
                      LEX #lex ] ],
    NH-DTR [ SYNSEM lex_synsem &
                   [ LOCAL [ CAT.HEAD det,
                             CONT.HOOK.INDEX #nhindex,
                             CONJ cnil ],
                     NONLOC non-local_none,
                     LKEYS.KEYREL.RSTR #rstr ] ],
    C-CONT [ HOOK #hdhook,
             RELS <! arg0_relation &
                     [ LBL #nhand,
                       PRED generic_nom_rel,
                       ARG0 #nhindex ],
                     arg1_relation &
                     [ PRED ellipsis_rel,
                       ARG1 #nhindex ] !>,
	     HCONS <! qeq & [ HARG #rstr,
                              LARG #nhand ] !> ],
    GENRE robust ].

; "One books"
mal_num_det_rule_1 := num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.AGR.PNG.PN 3p ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.PNG.PN 3s ] > ] >,
    GENRE robust ].

; "Twenty book"
mal_num_det_rule_2 := num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.AGR.PNG.PN 3s ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.PNG.PN 3p ] > ] >,
    GENRE robust ].
