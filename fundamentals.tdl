;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2006
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see erg/licence.txt for conditions
;;;
;;;  fundamentals.tdl
;;;
;;;  Basic definitions of types for English grammar
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id: fundamentals.tdl 7479 2010-02-21 23:11:30Z danf $


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign_min := *avm* &
  [ SYNSEM synsem_min,
    KEY-ARG bool ].

;; GENRE used to control variations in grammaticality, e.g. for edited
;; vs informal text, but subsuming earlier boolean ROBUST feature so we
;; can accommodate some ill-formed input such as missing det for sg-noun.
;; IDIOM marks whether a sign contains an idiomatic element.
;; --SIND is re-entrant with HOOK.INDEX, to help modularize path specs,
;; and to delay expansion of subcategorizations until necessary.
sign := sign_min &
  [ SYNSEM synsem &
           [ LOCAL [ CAT.HEAD.MINORS.MIN #min,
                     CONT.HOOK.INDEX #index ],
             --MIN #min,
             --SIND #index ],
    ORTH orthog,
    ARGS *list*,
    INFLECTD luk,
    GENRE genre,
    DIALECT dialect,
    IDIOM bool ].

phrase_or_lexrule := sign &
  [ SYNSEM canonical_synsem &
	   [ LOCAL.CONT.HOOK #hook ],
    ORTH.FROM #from,
    C-CONT mrs_min & [ HOOK #hook ],
    ARGS.FIRST.ORTH.FROM #from,
    RNAME string ].

word_or_lexrule_min := sign_min.

; ALTS allow lexical entries to block lexical rule application
; ORTHTYPE distinguishes orthographic class (e.g. alphanumeric or mixed-case.
word_or_lexrule := word_or_lexrule_min & sign &
  [ ALTS alts_min ].

; Group 'word' together with punctuation rules to distinguish basic words from
; derived or inflected forms - used at least in the rule for italicized or
; foreign word sequences.

word_or_infl_or_punct_rule := word_or_lexrule.
word_or_punct_rule := word_or_infl_or_punct_rule.
word_or_infl_rule := word_or_infl_or_punct_rule.

basic_word := word_or_infl_rule & word_or_punct_rule &
  [ SYNSEM [ PHON.ONSET.--TL #tl,
	     LKEYS.KEYREL [ CFROM #from,
			    CTO #to ] ],
    ORTH [ CLASS #class, FROM #from, TO #to, FORM #form ],
    TOKENS tokens &
           [ +LIST #tl & < [ +CLASS #class, +FROM #from, +FORM #form ], ... >,
             +LAST.+TO #to ] ].

word := basic_word &
  [ SYNSEM.PUNCT.PNCTPR ppair ].

orthog := *cons* &
[ FORM string,
  FROM string,
  TO string ].

orthography := orthog &
[ CLASS token_class ].

; Not all phrases have SYNSEM phr_synsem, since we need to allow the head-comp
; rules to build signs which are still [ SYNSEM lex_synsem ], for constructions
; like "twenty-two" and "five fifteen p.m.".  So most phrases will assign the
; type phr_synsem to the value of SYNSEM, but not all.

; DPF 02-Sept-00 - Removed [ HC-LEX - ] because it blocks conjoined lexical
; somethings.

phrase := phrase_or_lexrule &
  [ SYNSEM [ LOCAL.ARG-S < >,
	     PHON.ONSET #onset ],
    ARGS.FIRST.SYNSEM.PHON.ONSET #onset ].

; DPF (09-Jan-99) - Added boolean LEX feature to be used for determining the
; head-complement type of the projections of lexical heads - most produce 
; phrases, but see discussion of HC-LEX feature below.

synsem_min := *avm*.

synsem_min0 := synsem_min &
  [ LOCAL mod_local,
    NONLOC non-local_min ].

synsem_min1 := synsem_min0 &
  [ OPT bool,
    --MIN predsort,
    --SIND *top* ].

synsem_min2 := synsem_min1 &
  [ LEX luk,
    MODIFD xmod_min,
    PHON phon_min,
    PUNCT punctuation_min ].

lex_or_phrase := synsem_min2.

synsem := synsem_min2.

expressed_synsem := synsem.

; No gaps
canonical_or_unexpressed := synsem_min0.

canonical_synsem := expressed_synsem & canonical_or_unexpressed.

canonical_lex_or_phrase_synsem := canonical_synsem & lex_or_phrase.
    
; Type which enables exclusion of phrases like n-n compounds which are built
; by rule but have similar distribution to lexical signs.
lex_or_nonlex_synsem := canonical_lex_or_phrase_synsem.

; To distinguish syntactically constructed constituents marked LEX + from
; simple lexical entries - used e.g. to avoid making nominal gerund NPs
; directly from lexical gerunds, to avoid spurious ambiguity for
; 'Singing is fun' given that there is already a verbal gerund 'singing'.

nonlex_or_lex_phr_synsem := canonical_lex_or_phrase_synsem.
nonlex_synsem := lex_or_nonlex_synsem & nonlex_or_lex_phr_synsem.

phr_synsem := nonlex_synsem &
  [ LEX - ].

; LKEYS provide shortcuts to relations in RELS or a lex-entry's complements
abstr_lex_synsem := canonical_lex_or_phrase_synsem &
  [ LKEYS lexkeys ].           
    
basic_lex_synsem := abstr_lex_synsem & lex_or_nonlex_synsem.

lex_synsem := basic_lex_synsem &
  [ LEX + ].

; For signs that are constructed by syntactic rule but have similar
; (though not identical) distribution to lexical items - e.g. n_n_cmpnds.
lex_phr_synsem := abstr_lex_synsem & nonlex_or_lex_phr_synsem &
  [ LEX + ].

; For signs that have combined with a punctuation mark, and hence are no
; longer eligible to undergo derivational rules, to avoid spurious ambiguity.
lex_punct_synsem := basic_lex_synsem.

; DPF 29-Nov-02 - Removed [INDEX non_expl] to allow "There was known to be a
; problem" where pred "was" requires complement to be SUBJ *olist*.
non_canonical := synsem.
expressed_non_canonical := non_canonical & expressed_synsem.

gap := expressed_non_canonical &
  [ LOCAL [ CAT #cat,
	    CONT.HOOK [ INDEX #index,
			XARG #xarg ],
	    CONJ #conj,
	    AGR #agr ],
    NONLOC [ REL 0-dlist,
             QUE 0-dlist,
             SLASH 1-dlist &
                 [ LIST < [ CAT #cat,
			    CONT.HOOK [ INDEX #index,
					XARG #xarg ],
			    CONJ #conj,
			    AGR #agr ] > ] ] ].

unexpressed_min := canonical_or_unexpressed.
unexpressed := unexpressed_min & synsem_min2 &
  [ NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ] ].

unexpressed_reg := unexpressed & non_canonical.

; DPF 28-Aug-99 - Removed OPT + from anti_synsem since it blocked 
; "you can have anything you want"
anti_synsem_min := unexpressed_min.
anti_synsem := anti_synsem_min & unexpressed.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT type

;; The feature MC has three possible values: +, -, and na.  Non-clauses are
;; always MC na, since they can't really be said to be root or non-root.
;; All clauses are MC bool, and if they have a restricted distribution then
;; they are MC + or MC -.

local_basic := local_min &
  [ CONJ conj_min ].

local := local_basic &
  [ CTXT ctxt_min,
    ARG-S *list* ].

; Distinguish arg gaps from modifier gaps, to constrain ATB extraction to args
arg-local := local.
mod-local := local.

non-local := non-local_min &
  [ SLASH 0-1-dlist,
    QUE *diff-list*,
    REL 0-1-dlist ].

non-local_norel := non-local &
  [ QUE 0-dlist,
    REL 0-dlist ].

non-local_none := non-local_norel &
  [ SLASH 0-dlist ].

;; For unrealized extracted adjuncts needed in relative clauses, as in 
;; "the day he arrived"
;;unexpr_local := local_basic.

;; For exceptions to lexical rules
alts_min := *avm*.
alts := alts_min &
  [ PASSIVE bool,
    VPELLIP bool,
    ADVADD bool,
    ADVNGADD bool,
    NPPART bool,
    VADJ bool,
    NGER bool,
    SQPNCT bool,
    VPREF bool,
    DATIVE bool,
    ATTRJ bool ].
no_alts := alts_min.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsem values

; The feature AGR is introduced on LOCAL rather than on CAT (or on HEAD) since
; coordination schema unify the CAT value of the daughters with that of then
; mother, but need to be able to change AGR on the mother (to get plural 
; agreement on verb when subject is a coordinated NP with "and" vs. "or").  

cat_min := *avm*.

;; DPF (22-Oct-98) Added feature HC-LEX ("is head-complement type lexical?")
;; on CAT, to identify the type of synsem that results from combining the word 
;; with its complements.  We recognize at least the head-complement 
;; structures  "thirty-two" and "two o'clock" as still being lexical signs, not
;; phrasal ones, since they can appear as prenominal adjectives and in noun-
;; noun compound constructions, respectively.  The head-complement rule 
;; determines its SYNSEM type by unifying its LEX value with the HC-LEX of
;; its head dtr - this works because the HCOMP rule requires its SYNSEM value to
;; be of type canonical_synsem, and the subtypes of canonical_synsem are the
;; only types that introduce the feature LEX, namely lex_synsem and phr_synsem.

; DPF 2-Jun-02 - Similarly, words differ in whether the head-specifier
; construction they head is lexical or phrasal: det+noun is phrasal to avoid
; allowing e.g. "*my the sony laptop arrived" but deg+adj is still lexical to
; avoid "*the children very small arrived" (given other constraints for each
; of these two constructions).  So introduce HS-LEX value.


cat_min1 := cat_min &
  [ HEAD head_min,
    VAL valence_min ].

; DPF 24-apr-08 - Added NEGPOL to distinguish negative polarity effects,
; especially to license declarative subj-aux inversion as in "Not until
; today did Kim see the point."

cat := cat_min1 &
  [ MC luk,
    POSTHD bool,
    HC-LEX luk,
    HS-LEX luk,
    NEGPOL luk ].

local_min1 := mod_local &
  [ CAT cat_min ].

local_min2 := mod_local &
  [ CONT mrs_min ].

local_min := local_min1 & local_min2 &
  [ AGR *top* ].

non-local_min := *avm*.

phon_min := *avm*.
phon := phon_min &
  [ ONSET onset ].

onset := *sort* &
[ --TL *list* ].
con_or_unk := onset.
voc_or_unk := onset.
con_or_voc := onset &
[ --TL native_token_list ].
con := con_or_unk & con_or_voc.
voc := voc_or_unk & con_or_voc.
; For unknown words
unk_onset := con_or_unk & voc_or_unk &
[ --TL generic_token_list ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Head and valence
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mod_local := *avm*.

; The MOD value specifies the type of phrase that a sign can modify, and the
; POSTHD value stipulates the relative position of the modifier with
; respect to the head.  (An earlier approach employing a generalization about
; a head being final in its phrase or not might still be considered as an
; alternate to this stipulative one.)
; The POSTHD feature should stay with MOD, since only relevant when MOD is
; non-empty.

; DPF 09-Jan-99 - Changed value of MOD to be of type synsem rather than type
; local, since some modifiers (like vocative NPs) only modify SLASH-empty
; phrases, which means they have to have access to the NONLOC feature of
; the phrase they modify.

head_min := *avm*.

; DPF 16-Aug-99 - Added INV to head type, since need to distinguish root
; from non-root phrases as output from parser, and since inverted S's now have
; MSG empty, we have to require all non-root fragments to be INV -.
; DPF 09-sept-07 - With the departure of messages, we can now push INV back
; down to verb_or_frag.
; TAM likewise can be pushed down to non-noun subtype.
; AUX has to be here as long as we want PPs to avoid attaching to aux-headed
; phrases, since they can also modify nouns.

head := head_min &
  [ MOD *list*,
    PRD bool,
    MINORS minors_basic,
    AUX luk,
    CASE case ].

valence_min := *avm*.

valence := valence_min &
  [ SUBJ *list*,
    SPR *list*,
    COMPS *list* ].

valence_sp := valence &
  [ SPEC *list*,
    SPCMPS 0-1-list ].

; KCMP is a pointer to a distinguished ('key') complement synsem, used in
; generalizations within the lexical type hierarchy, but not present in the
; syntax.
valence_lex := valence_sp &
  [ KCMP *avm* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

; POSS is akin to CASE, distinguishing possessive-marked NPs from ordinary NPs,
; a contrast needed for e.g. the adjective "own" which can only appear in
; phrases with a possessive NP specifier.  Also used in building partitive
; phrases such as in "Kim's is good."
;
poss-able := head_min &
  [ POSS bool ].

disc_adverbee := head.

subst_or_func := head.
non_frag := subst_or_func.
func := non_frag.

n_or_p_or_v_or_adv := head.
n_or_p_or_v := n_or_p_or_v_or_adv & subst.

p_or_adv_or_dadv := head.
n_or_a_or_p_or_adv := head.
v_or_g_or_dadv := head.
p_or_adv_or_comp := head.
p_or_adv := n_or_p_or_v_or_adv & p_or_adv_or_dadv & n_or_a_or_p_or_adv &
            n_or_p_or_adv & p_or_adv_or_comp.
adv_or_comp := p_or_adv_or_comp.
subst_or_adv := head.

subst := non_frag & subst_or_adv.

v_or_g_or_p := v_or_g_or_a_or_p.

non_noun_or_frag := head &
  [ TAM tam_min ].
non_noun_or_adv := non_noun_or_frag.
non_noun := subst & non_noun_or_adv.
v_or_a_or_p := non_noun.
; Used by copula in "it is that Kim arrived" or "it is because Kim arrived"
verbal_or_p := non_noun.

a_or_adv := n_or_a_or_p_or_adv & n_or_a_or_adv_or_det.

n_or_p_or_frag := head.

n_or_p_or_a := n_or_a_or_p_or_adv.

n_or_p_or_adv := head.

;v_or_n_or_g_or_a := subst.
;n_or_v_or_a := v_or_n_or_g_or_a.
n_or_v_or_a := subst.

n_or_p :=  n_or_p_or_v & n_or_p_or_frag & n_or_p_or_a & n_or_p_or_adv.
;n_or_a := n_or_v_or_a.

; DPF 3-apr-05 - Added poss-able to allow for locative inversion using sb-hd_mc_c.
a_or_p := v_or_a_or_p & n_or_p_or_a & poss-able.
v_or_p := v_or_a_or_p & n_or_p_or_v & v_or_g_or_p.
n_or_v := n_or_p_or_v & n_or_v_or_a.

; For heads that can take comparative degree specifiers
comp_spec_able := head.
; Exclude prepositions for target of most comp. deg. specifiers
n_or_a_or_adv_or_det := comp_spec_able.
n_or_adv := n_or_a_or_adv_or_det.
basic_nom_or_ttl := poss-able & head.
nom_or_ttl := basic_nom_or_ttl.
noun_or_ttl := nom_or_ttl.

; For constraint on head-spec rule.
; DPF 8-aug-07 - The hack feature --BARE is used to prevent underspecified
; mass-count nouns from undergoing the robust bare-pl-sg rule, since they
; can already undergo the ordinary bare-plural rule.
;
n_or_a_or_det := n_or_a_or_adv_or_det &
 [ --BARE bool ].

det := func & poss-able & n_or_a_or_det.

adverbee_or_modnp := head.
; Adverbs modify adverbees.
adverbee := adverbee_or_modnp.

v_or_g_or_a_or_int := subst.

v_or_g_or_a_or_p := subst.
v_or_g_or_a := v_or_g_or_a_or_p & v_or_g_or_a_or_int.
v_or_g := v_or_g_or_a & v_or_g_or_p & verb_or_frag & v_or_g_or_dadv.

nominal_or_verbal := subst.

nominal := nominal_or_verbal & poss-able.

verbal := v_or_g & nominal_or_verbal & adverbee & disc_adverbee & verbal_or_p.

; mobile things can be extracted in the complement-extraction rule, from which
; we exclude nominative-case NPs by not making all NPs mobile.

mobile := head.

; DPF 7-mar-05 - Make subtype of nominal_or_verbal so PPs can modify APs,
; in order to admit "towns not obvious on the map"
; DPF 12-feb-08 - Add a_or_adv to adj_or_intadj so we can coordinate
; integer adjectives as in "six or seven cats"
adj_or_intadj := n_or_v_or_a & a_or_p & adverbee & nominal_or_verbal &
                 v_or_g_or_a_or_int & a_or_adv.

v_or_a := v_or_g_or_a & n_or_v_or_a & non_noun.
basic_adj := v_or_a & mobile & adj_or_intadj.
; For positive adjectives
adj := basic_adj & n_or_a_or_det.


prep_or_modnp := p_or_adv.

; DPF 26-Jul-99 - Made prep not inherit from adverbee, since in general
; don't want adverbs modifying PPs.
; DPF 17-Dec-01 - But need to have at least some adverbs modifying PPs: 
; "The books currently in the store include ..."

basic_prep := a_or_p & v_or_p & n_or_p & prep_or_modnp & verbal_or_p &
        adverbee.

prep := basic_prep & mobile & comp_spec_able.

prep_nonmob := basic_prep.

; For result of npadv_mod non-branching rule
; Need mobile for "where did i put it"

modnp := n_or_p & nominal & prep_or_modnp & mobile & a_or_adv & v_or_a_or_p &
         adverbee_or_modnp.

supnoun := nominal & n_or_v & n_or_a_or_det.

noun_or_nomger_or_nadj := supnoun.

; for both nominal and verbal gerunds
noun_or_nomger := n_or_p & basic_nom_or_ttl & noun_or_nomger_or_nadj.
noun_or_gerund := supnoun.
; For nouns that can undergo conversion to adj, like "eared" or "blue"
;noun_adj := supnoun.
noun_adj := subst.

basic_noun := noun_or_nomger & n_or_adv & noun_or_gerund & noun_or_ttl.

noun := basic_noun.
noun_adjable := basic_noun & noun_adj.


; DPF 10-Apr-02 - Added n_or_p since want to allow gerunds to undergo hdn_optcmp_c
; rule, to get e.g."way of saying that Kim arrives"
; DPF 19-may-09 - Now that we make verbal gerunds as phrases, try dropping
; v_or_g supertype, to avoid spurious ambiguity for e.g. "not hiring kim".
; May lead to larger clean-up of head types. FIX?
; gerund := noun_or_gerund & adverbee & v_or_g & n_or_p & disc_adverbee.
; DPF 23-jun-09 - Re 19-may-09: But gerunds still need to inherit verbal
; features VFORM, INV, TAM, so add super-type verb_or_frag.
gerund := noun_or_gerund & adverbee & n_or_p & disc_adverbee & 
	  basic_verb_or_frag.
gerund_full := gerund & vc_add.

; For derived entries like the "eyed" of "wide-eyed"
n-ed := noun_adj & basic_nom_or_ttl & noun_or_nomger_or_nadj.

; For run-on sentences.
verb_or_conj_or_frag := head.
verb_or_conj-s := verb_or_conj_or_frag.
; For no-copula and run-on sentences
basic_verb_or_frag := non_noun_or_frag & verb_or_conj_or_frag &
  [ VFORM vform,
    INV bool ].

; Enable exclusion of spurious ambiguity for gerund "not hiring Kim"
verb_or_frag := basic_verb_or_frag.

; Added poss-able to allow s's as subjects of quoting verbs, as in
; 'Kim arrived said Sandy.'
verb := verbal & v_or_p & n_or_v & v_or_a & poss-able & mobile & 
	verb_or_conj-s.

addinfl := *avm* &
  [ ADDPN pn,
    ADDTAM tam_min ].

vc_add := subst &
  [ --ADDIN addinfl ].

verb_full := verb & vc_add.

; DPF 24-jul-05 - Removed nominal as supertype of comp since we use a rule to
; convert NP-subject-taking VPs into CP-taking ones, with distinct semantic
; linking.
comp := verbal & poss-able & mobile & adv_or_comp &
  [ MOD *anti_list* ].
comp_full := comp & vc_add.

; For adverb fragments, including speech-relevant adverbs
adv_or_no_head := head.
basic_adv := func & non_noun_or_adv & subst_or_adv & adv_or_no_head.

; 'not' and closed class of other adverbs that can be added to aux COMPS list
; via 'adv_addition' lexical rule.
basic_lexadv := basic_adv & disc_adverbee.
negadv := basic_lexadv & adverbee.
lexadv := basic_lexadv & a_or_adv.

reg_adv := basic_adv & disc_adverbee & p_or_adv & adv_or_comp &
           a_or_adv & n_or_adv.
adv := reg_adv & mobile.
adv_nonmob := reg_adv.
deg_adv := basic_adv.
root-marker := v_or_g_or_dadv & adverbee & p_or_adv_or_dadv & non_frag.
wh_adv := func.
; For titles like "Mr" or "Professor", not to be confused with nouns
ttl := func & noun_or_ttl & n_or_a_or_p_or_adv.

detspec := func.

; Hack used in blocking unwanted affixes
no_head := non_frag & adv_or_no_head.

; Types for punctuation and string boundaries.
; **FIX**

punct_hd := head.

punct_pair_hd := func.
quote_punct_hd := punct_pair_hd.
dq_punct_hd := quote_punct_hd.
sq_punct_hd := quote_punct_hd.
lq_punct_hd := sq_punct_hd.
lp_punct_hd := punct_pair_hd.
rp_punct_hd := punct_pair_hd.

nomger := noun_or_nomger & nom_or_ttl.
nomger_mob := nomger & mobile & [ CASE non_nom ].

; The following types are used to enable strict subcategorization (the usual 
; case)

noun_mob := noun & mobile & [ CASE non_nom ].
partn := basic_noun.
partn_mobile := partn & mobile.
gerund_mob := gerund & mobile & [ CASE non_nom ].
; For 'long' of 'for too long'
grad_n := partn_mobile & [ CASE non_nom ].
interv_n := noun.

; For types that can undergo number-partitive:'five of them','ten feet of rope'
adj_partitive := non_frag.
intadj_or_superl := adj_partitive.
intadj_or_comp := adj_partitive & intsort.

compar_or_superl_adj := basic_adj.
superl_adj := compar_or_superl_adj & intadj_or_superl.
compar_adj := compar_or_superl_adj & intadj_or_comp.

; For measure-NPs
noun_meas := noun & adj_partitive.

; For tag questions, which can't be verbal in order to avoid being root S's.
tagaux := non_frag & verb_or_frag.

conj_or_frag := verb_or_conj_or_frag.

; For fragments of all kinds
; DPF 12-apr-08 - Try adding disc_adverbee, to allow "Yes, and Kim."
frag := subst_or_func & verb_or_frag & conj_or_frag & disc_adverbee &
  [ MOD < > ].

; For run-on sentence conjunction (to avoid spurious modifier ambiguity)
conj-s := verbal & conj_or_frag & verb_or_conj-s.

; For 'foreign' words, typically marked as italicized
fw := head & [ MOD < > ].

; Speech filler words in word lattices
spfill := head & [ MOD < > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

strict_sort := *sort*.

; Person and number represented as atomic sorts, with gender a separate attrib
; relevant for 3sg, and where count/mass distinction only for 3sg neuter.

pn := *sort*.

; 5 cells
-1s := pn.
-2s := pn.
-3s := pn.
-1p := pn.
-2p := pn.
-3p := pn.

; 4 cells
-1 := -1s & -1p.
-2 := -2s & -2p.
-3 := -3s & -3p.

-12s := -1s & -2s.
-13s := -1s & -3s.
-23s := -2s & -3s.

-12p := -1p & -2p.
-13p := -1p & -3p.
-23p := -2p & -3p.

-1s-2p := -1s & -2p.
-1s-3p := -1s & -3p.
-2s-1p := -2s & -1p. 

-2s-3p := -2s & -3p.
-3s-1p := -3s & -1p.
-3s-2p := -3s & -2p.

;3 cells
sg := -12p & -13p & -23p. 
pl := -12s & -13s & -23s.

1+2s := -3s-2p & -23p & -3.
1+2p := -2s-3p & -23s & -3.
1+3s := -2s-3p & -23p & -2.
1+3p := -3s-2p & -23s & -2.

2+1s := -3s-1p & -13p & -3.
2+1p := -1s-3p & -13s & -3.
2+3s := -1s-3p & -13p & -1.
2+3p := -3s-1p & -13s & -1.

3+1s := -2s-1p & -12p & -2.
3+1p := -1s-2p & -12s & -2.
3+2s := -1s-2p & -12p & -1.
3+2p := -2s-1p & -12s & -1.

12s+3p := -3s-1p & -3s-2p & -12p.
13s+2p := -2s-1p & -2s-3p & -13p.
23s+1p := -1s-2p & -1s-3p & -23p.

1s+23p := -2s-1p & -3s-1p & -23s.
2s+13p := -1s-2p & -3s-2p & -13s.
3s+12p := -1s-3p & -2s-3p & -12s.

; 2 cells
1 := 1+2s & 1+2p & 1+3s & 1+3p. 
2 := 2+1s & 2+1p & 2+3s & 2+3p.
3 := 3+1s & 3+1p & 3+2s & 3+2p.

12s := 12s+3p & 1+2s & 2+1s & sg.
13s := 13s+2p & 1+3s & 3+1s & sg.
23s := 23s+1p & 2+3s & 3+2s & sg.
12p := 3s+12p & 1+2p & 2+1p & pl.
23p := 1s+23p & 2+3p & 3+2p & pl.
13p := 2s+13p & 1+3p & 3+1p & pl.

1s+2p := 1+2p & 2+1s & 13s+2p & 1s+23p.
1s+3p := 1+3p & 3+1s & 12s+3p & 1s+23p.
2s+1p := 2+1p & 1+2s & 2s+13p & 23s+1p.
2s+3p := 2+3p & 3+2s & 2s+13p & 12s+3p.
3s+1p := 3+1p & 1+3s & 3s+12p & 23s+1p.
3s+2p := 3+2p & 2+3s & 3s+12p & 13s+2p.

1s := 1 & 12s & 13s & 1s+2p & 1s+3p.
2s := 2 & 12s & 23s & 2s+1p & 2s+3p.
3s := 3 & 13s & 23s & 3s+1p & 3s+2p.
1p := 1 & 12p & 13p & 2s+1p & 3s+1p.
2p := 2 & 12p & 23p & 1s+2p & 3s+2p.
3p := 3 & 13p & 23p & 2s+3p & 1s+3p.

; For unspecified pernum, to constrain generator introducing e.g. 'am' when
; an argument position is unbound.

unsp_pernum := pn.

gender := *sort*.
real_gender := gender.
animate := real_gender.
masc := animate.
fem := animate.
neut := real_gender.
andro := animate.
andro1 := animate.

; The following two are used in tag questions to block mismatched expletive
; pronouns in main clause and tag, since we can't block on unified index
; values, since in general tag questions introduce a pronoun which must have
; a unique index bound by the quantifier it (now) introduces lexically.
no_gend_it := gender.
no_gend_there := gender.

png_min := *avm*.
png := png_min & 
  [ PN pn,
    GEN gender ].

; ERB declarative and interrogative seem to form a natural class
; in that 'know', 'guess', 'suspect' ... take either.  The type
; decl_int is meant to reflect this.  
; ERB (23-07-96) declarative and imperative also form a class 
; with respect to tag questions.  The type decl_imp is meant to
; reflect this.

cl_mode := *sort*.
no_cl_mode := cl_mode.
relative := cl_mode.
decl_int := cl_mode.
decl_imp := cl_mode.
declarative := decl_int & decl_imp.
interrogative := decl_int.
imperative := decl_imp.

prontype := *sort*.
real_pron := prontype.
std_pron := real_pron.
recip := real_pron.
refl := real_pron.
impers := real_pron.
demon := real_pron.
zero_pron := real_pron.
not_pron := prontype.

; Three-valued sort evoking Polish logician Jan Lukasiewicz
luk := *sort*.
; NA for Not Applicable.  
na_or_+ := luk.
na_or_- := luk.
bool := luk.
na := na_or_+ & na_or_-.


+ := bool & na_or_+.
- := bool & na_or_-.

; Three-valued sort for distinguishing unmodified signs from both left-modified
; and right-modified signs
; LPERIPH and RPERIPH indicate whether this modifier is left- or 
; right-peripheral in its phrase - e.g., "the IBM temporary employees" but 
; "*the IBM five employees", and similarly "chairs I buy that you like are
; expensive" but "*chairs that you like I buy are expensive"

xmod_min := *sort*.
xmod := xmod_min &
  [ LPERIPH luk,
    RPERIPH luk ].

notmod_or_rmod := xmod.
notmod_or_lmod := xmod.
notmod := notmod_or_rmod & notmod_or_lmod.

hasmod := xmod.
lmod := hasmod & notmod_or_lmod.
rmod := hasmod & notmod_or_rmod.

; One of a grammatically salient inventory of semantic sorts, such as
; 'animate' or 'time'

semsort := *sort*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT types

semarg := *avm* &
  [ INSTLOC string,
    SORT *sort* ].

basic_non_expl := semarg.
non_conj_sement := semarg.
basic_non_event := semarg.
non_event := basic_non_expl & basic_non_event.
handle := non_event & non_conj_sement.
individual_min := semarg.

individual := individual_min &
 [ --TPC luk ].


; DIV (divisible) distinguishes singular count nouns from plural and mass 
; nouns, for determiners like "some", and for bare-plural NPs.
; IND (individuated) draws the relevant semantic distinction between 
; countable and non-countable entities, so DIV should be only a morphosyntactic
; distinction.

index := individual &
  [ PNG png_min,
    DIV bool,
    IND bool ].
    
; Moved SORT to individual, since need to allow constraint to affect events too
full_index := index &
  [ PRONTYPE prontype ].

; This is the type of the index of the phrase modified by predicative PPs, which
; can either modify a ref-ind nominal or an event VP.

non_expl := individual & basic_non_expl.

event_or_index := non_expl.

event_or_deg-ind := event_or_index.

basic_tense := *sort*.
tense := basic_tense.
untensed := basic_tense.
basic_aspect := *avm*.
aspect := basic_aspect &
  [ PRF luk,
    PROGR luk ].
no_aspect := aspect &
  [ PRF -,
    PROGR - ].

real_tense := tense.
nonpast := real_tense.
present := nonpast.
nonpresent := real_tense.
past := nonpresent.
future := nonpast.
no_tense := tense & untensed.
; For PPs that can never be complements of 'be'
nontense := untensed.

mood := *sort*.
ind_or_modal_subj := mood.
ind_or_subj := mood.
indicative := ind_or_modal_subj & ind_or_subj.
basic_subjunctive := mood.
modal_subj := ind_or_modal_subj & basic_subjunctive.
subjunctive := basic_subjunctive & ind_or_subj.

tam_min := *avm*.

tam := tam_min &
 [ TENSE basic_tense,
   ASPECT basic_aspect,
   MOOD mood ]. 

past_or_subj_tam := tam &
 [ TENSE nonpresent ].

subjnct_tam := past_or_subj_tam &
 [ MOOD subjunctive ].

indic_tam := tam &
 [ TENSE real_tense,
   MOOD ind_or_modal_subj ].

past_tam := past_or_subj_tam & indic_tam &
 [ TENSE past,
   ASPECT no_aspect ].

event := event_or_deg-ind & ind_or_event_or_conj &
  [ E tam_min,
    PERF luk,
    PROG luk,
    SF iforce ].

; Once used to distinguish discourse adverbs, for VIT purposes - now obsolete?
disc_frag := event_or_index.

; LNK links semantic relation to input string elements
; CFROM and CTO used for characterization

relation_min := *avm*.
relation := relation_min &
  [ PRED predsort,
    LBL handle,
    LNK *list*,
    CFROM *top*,
    CTO *top* ].

arg0_relation := relation &
  [ ARG0 event_or_index ].

event_relation := arg0_relation &
  [ ARG0 event ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MRS type
;
;   HOOK                   ; Label of rel with highest scope in sign
;   RELS                   ; List of elementary predications
;   HCONS *diff-list*      ; Scope constraints: list of scp_pr's

; DPF 18-jul-04 - Avoid making value of LTOP handle, since want to allow for
; optional sentential complements, so need to have that argument position in
; the higher verb's relation be underspecified.  We give up some type-checking
; benefits here, but gain cleaner treatment of optionality.
; DPF 22-may-09 - The feature --SLTOP is introduced in response to our
; decision to conform more closely to the semantic algebra, in
; particular ensuring that heads identify their LBL with each of their
; complements unless they take that complement LBL as an argument (as
; with sent.  complements). The challenge to composition arises in
; across-the-board extraction, as in "Him, we like and admire"
; (assuming for this example that we've dispensed with the
; pronoun_q_rel, so the LBL of the complement's pron_rel should be
; identified with its verbal head).  If we just unify the SLASH values
; of the conjoined VPs in the above example, we then wrongly get the
; same LBL for both _like_v_rel and _admire_v_rel.  The new solution:
; have the various SLASH-introduction constructions keep the LBL of
; the SLASH value unbound, instead identifying the LTOP of the slashed
; argument (or adjunct) with this new attribute --SLTOP on the mother.
; This attribute will ordinarily then be passed up the tree with the
; help of enriched basic lexical types which identify their --SLTOP
; with that of their complements (the same as lexical threading for
; SLASH). In the filler-head construction the filler's LTOP is
; identified with this --SLTOP.  But in coordinate structures, the
; link is broken, so the coordinate phrase simply identifies the
; phrase's --SLTOP with the left conjunct (arbitrarily).  This results
; in a well-scoped structure, though there's surely a better solution
; somewhere.  [Note that we first tried making the coordinate structure
; identify its own LTOP with its --SLTOP, but this fails with multiple
; coordinate structures like "Don't toss paper and other garbage on
; streets and in the terrain."  since each of the two coordinate
; complements would each identify their --SLTOP with their own LTOP,
; and then the verb "toss" would in turn make its --SLTOP unify with
; both of these, wrongly resulting in the LTOP of the first complement
; identified with that of the second.]

hook_min := *top*.
hook := hook_min &
  [ LTOP handle,
    INDEX semarg,
    XARG *top*,
    --SLTOP handle ].

mrs_min := *avm*.
mrs_min0 := mrs_min &
  [ HOOK hook_min ].

mrs_min1 := mrs_min0 &
  [ RELS *diff-list* ].
    
;; DPF 10-Oct-00 - Added ARG0 attribute for predicative phrases, as in
;; "Kim kept calm" where the INDEX of "calm" is "Kim"'s INDEX and the first
;; argument of _keep_rel, while "calm"'s ARG0 is second argument of _keep_rel.

mrs := mrs_min1 &
  [ HCONS *diff-list* ].

; Constrains handle of scopable argument HARG relative to one or more 
; handles
scp_pr := *top* &
  [ HARG handle,
    LARG handle ].        

; Constrains scope to be equal subject to intervening quantifiers
;;;
;;; as of jul-04, the generator supports a mode where QEQs in its input MRSs
;;; are equated internal to the generator, which (although formally it results
;;; in an MRS that could not be scope-resolved) makes sure we get attachments
;;; of scopal elements right, even though in the final semantics compatibility
;;; test there is no testing of handle constraints.  instead, an MRS that comes
;;; off a generator output is subjected to QEQ equation internall too, so that
;;; plain mrs-equalp() is sufficient.  equating INSTLOC values inside of QEQs
;;; in the grammar makes sure we get the intended effect during generation, but
;;; still end up producing a well-formed MRS with scope underspecification.
;;;                                                            (14-jul-04; oe)
; Constrains scope to be equal subject to intervening quantifiers
qeq := scp_pr & [ HARG.INSTLOC #1, LARG.INSTLOC #1 ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONJ type -
;
; CONJ values come in two types, cnil and real-conj (i.e., non-cnil).  Cnil
; and the atomic substypes of real-conj are the possible CONJ values of the
; left conjunct in a coordinate structure.  The right conjunct must always
; have a complex-conj CONJ value.  A complex CONJ value has three parts: the
; handles and indices of the sub-parts of the right conjunct, and the CHEAD
; info that gets passed from the right conjunct to the mother.  The CHEAD
; value has only one piece of information: the CONJ value of the
; left conjunct daughters.  For more info about how this works, see
; top_coord_rule in syntax.tdl.
; CLEX enables the conjunction to constrain the LEX property of the left
; conjunct.

conj_min := *avm*.
basic-conj := conj_min &
  [ CHEAD cnil_or_atomconj,
    CLEX luk ].

conj := basic-conj.
cnil_or_numconj := basic-conj.
cnil_or_phrconj := basic-conj.
cnil_or_lexconj := basic-conj.
cnil_or_atomconj := *avm*.
both_or_cnil := basic-conj.
either_or_cnil := basic-conj.
neither_or_cnil := basic-conj.
first_or_cnil := basic-conj.
notonly_or_cnil := basic-conj.
not_or_cnil := basic-conj.
cnil := conj_min.
cnil_full := cnil & cnil_or_numconj & cnil_or_phrconj & cnil_or_lexconj &
             cnil_or_atomconj & both_or_cnil & either_or_cnil & 
             neither_or_cnil & first_or_cnil & notonly_or_cnil & not_or_cnil.

real-conj := conj.
atomic-conj := cnil_or_atomconj & basic-conj.
both := both_or_cnil & atomic-conj.
either := either_or_cnil & atomic-conj.
neither := neither_or_cnil & atomic-conj.
first := first_or_cnil & atomic-conj.
notonly := notonly_or_cnil & atomic-conj.
not-conj := not_or_cnil & atomic-conj.

; CREL is a pointer to the coord_relation, needed for semantic composition.
; CPUNCT enables lexical conjunctions to block comma-marked left conjunct
; in simple two-part coordination: '*Abrams, and Browne arrived'.
; CPNG records agreement constraints which a conjunction can contribute,
; allowing 'and' to provide singular nbar-coordination, but plural NP
; coordination, for the contrast in "Their hardiness and zest for life is"
; but "*Abrams and Browne is"

complex-conj := real-conj &
  [ CREL *top*,
    CPUNCT pnctpair,
    CPNG png ].

phr-conj := complex-conj & cnil_or_phrconj.
lex-conj := complex-conj & cnil_or_lexconj.
num-conj := cnil_or_numconj & atomic-conj.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Contextual information

ctxt_min := *avm*.

ctxt := ctxt_min &
  [ ACTIVATED bool,
    PRESUP *diff-list* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LKEYS relations (shortcuts to keyrels of complements, only used in lexicon)
;  KEYREL relation          ; Pointer to main relation in RELS
;  ALTKEYREL relation       ; Pointer to an alternate relation in RELS
;  ALT2KEYREL relation      ; Pointer to a second alternate relation in RELS
;  --COMPKEY predsort       ; Pointer to the complement's MIN
;  --OCOMPKEY predsort      ; Pointer to the oblique complement's MIN
;  --+COMPKEY predsort      ; Pointer to obligatory complement's MIN
;  --+OCOMPKEY predsort      ; Pointer to obligatory oblique complement's MIN

minors_basic := *avm* &
  [ MIN predsort ].

minors := minors_basic &
  [ ALTMIN predsort ].

minors_full := minors &
  [ NORM predsort ].

lexkeys := *avm* &
  [ KEYREL relation ].

lexkeys_norm := lexkeys &
  [ KEYREL [ CFROM #from, CTO #to ],
    ALTKEYREL relation & [ CFROM #from, CTO #to ] ].

lexkeys_full := lexkeys_norm &
  [ KEYREL [ CFROM #from, CTO #to ],
    ALT2KEYREL relation & [ CFROM #from, CTO #to ],
    --COMPKEY predsort,
    --OCOMPKEY predsort,
    --+COMPKEY predsort,
    --+OCOMPKEY predsort,
    --COMPHD head_min ].

; To support chart dependency filtering for there-copula and expletive-it args
lexkeys+ := lexkeys_full &
  [ --+ARGIND index ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; DPF (14-Oct-98) --FINAL-ARG points to the final element in a word with 
;; spaces, since that element bears any inflection.
;; AAC - dropped --FINAL-ARG - default infl position is end of word
;; in user-fns. Find better soln when we do multi words properly
;; (and use defaults)

; Rule

rule := sign.

; LNAME and META used for labeling nodes in parse trees

tree_node_label := *top* &
  [ NODE sign ].

label := sign &
  [ LNAME string ].

;; see lkbpatches
meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ]. 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CASE and VFORM

case := *sort*.
non_obliq := case.
nom_or_obliq := case.
nom := non_obliq & nom_or_obliq.
non_nom := case.
acc := non_nom & non_obliq.
obliq := non_nom & nom_or_obliq.

vform := *sort*.
fin_or_non_fin := vform.
non_fin := fin_or_non_fin.
non_inf := vform.
non_prp := non_fin & non_inf.
non_bse := vform.
non_pas := non_fin.
non_fin_non_bse := non_fin & non_bse.
ger := non_prp.
pas_or_psp := non_fin_non_bse & non_inf.
pas_or_prp := vform.
pas := non_prp & pas_or_psp & pas_or_prp.
psp_or_psp_irreg := pas_or_psp & non_pas.
psp := psp_or_psp_irreg.
psp_irreg := psp_or_psp_irreg.
bse_or_inf := non_fin.
; fin_or_bse used to collapse morpholog. unmarked forms for bse and fin-non3sg.
fin_or_bse_or_imp := non_inf.
fin_or_bse := fin_or_bse_or_imp.
bse := bse_or_inf & fin_or_bse_or_imp.
; Base morphology verbs can be either base or imperative, but not if negated.
; See discussion of type neg_word.
bse_only := bse & fin_or_bse.
fin_or_inf_or_imp := vform.
fin_or_imp := fin_or_inf_or_imp & fin_or_bse_or_imp.
imp_vform := bse & fin_or_imp.
fin_or_inf := non_bse & fin_or_inf_or_imp.
fin := fin_or_inf & fin_or_bse & fin_or_imp & fin_or_non_fin.
inf_or_prp := non_pas & non_fin_non_bse.
inf := inf_or_prp & bse_or_inf & fin_or_inf.
prp := inf_or_prp & non_inf & pas_or_prp.

inf_and := vform.
inf_but := vform.
inf_from := inf_or_prp.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  CONT values (MRS semantics)
;;
;; The basic semantic objects are all sub-types of semarg.  Right now, the only
;; type of semarg that has an internal structure is index, but that will
;; probably change.  For example, an event might have various times associated
;; with them or a handle may include a list of "subhandles" which are in its
;; scope.  Indices are classified in the familiar HPSG way.

expl-ind := index & basic_non_event.
full_expl-ind := expl-ind & full_index.
it-ind := full_expl-ind &
  [ PNG [ PN 3s,
          GEN no_gend_it ] ].
there-ind := expl-ind &
  [ PNG.GEN no_gend_there ].

non_expl_or_conj-ind := index.
non_expl_or_param := *sort*.
ind_or_event_or_conj := non_expl_or_conj-ind & event_or_index.
non_expl-ind := ind_or_event_or_conj & non_event & non_expl_or_param &
  [ PNG.GEN real_gender ].
ref-ind := non_expl-ind.
deg-ind := non_expl-ind & event_or_deg-ind.
full_non_expl := full_index & non_expl-ind.
full_there-ind := there-ind & full_expl-ind.
full_ref-ind := ref-ind & full_non_expl.
full_deg-ind := deg-ind & full_non_expl.
; Added to block spurious ambiguity for conjoined proper names:
nonconj_ref-ind := full_ref-ind & non_conj_sement.

conj-ind := ind_or_event_or_conj.
conj_event_or_deg-ind := event_or_deg-ind & conj-ind.
conj_event := conj_event_or_deg-ind & event.
; Used to distinguish non-conjoined sentences in order to prevent np_cp_wh_rule
; from applying to conjoined message-underspecified clauses.
non_conj_event := event & non_conj_sement.

conj_non_expl-ind := conj-ind & non_expl-ind.
conj_full-ind := conj_non_expl-ind & full_non_expl.
conj_ref-ind := conj_non_expl-ind & ref-ind.
conj_full_ref-ind := conj_ref-ind & conj_full-ind & full_ref-ind.
conj_deg-ind := conj_event_or_deg-ind & conj_non_expl-ind & deg-ind.
conj_full_deg-ind := conj_deg-ind & conj_full-ind & full_deg-ind.

unbound-ind := non_expl-ind.

; The basic semantic structure, a CONT, is just something with a handle.
; Conts are further classified into mrss (i.e., things with liszts) and
; relations (i.e., things that go on liszts).  Conts are divided into psoas
; (with a distinguished event) and nom-objs (with a distinguished index).
; We use a polymorphic attribute name INDEX for both of these, to simplify
; manipulation of these objects; for example, modifying PPs assign as their
; ARG1's value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  Similarly useful
; for coordination.

; ERB (03-10-96) 
; The intermediate types ques_prop_msg and prop_com_msg represent the
; natural classes needed for selection by know, announce, care, check,
; etc. and the analysis of THAT (see lextypes.tdl) and the 
; forthcoming analysis of tags on imperatives, respectively.

psoa := mrs_min0 &
  [ HOOK.INDEX event ].

psoa_basicmrs := psoa.

psoa_mrs := psoa_basicmrs & mrs.

; DPF 11-Feb-01 - For now, make all nom-objs have INDEX and E-INDEX the same, 
; to keep coordination working now that we want to treat coordination of 
; predicative phrases via their E-INDEX.  Probably will have to adjust this
; once we get more interesting temporal semantics for some nouns.
; DPF 29-Nov-02 - Can't have E-INDEX the same, since pre-nominal adjectives
; now unify their E-INDEX with that of the noun, and it's of type event.
; Recall that adjectives must do this unification in order to propagate the
; E-INDEX of the syntactic head, since the adjective is the semantic head.
; DPF 4-Dec-02 - For now, make all nouns not expose an external argument, so
; they won't appear as controlled complements.  Will perhaps want to treat
; indefinite NPs in copular constructions by relaxing this constraint for e.g.
; "Kim is a consultant"
; DPF 13-Nov-03 - Removed [ HOOK.XARG nothing ], since nom-obj is also the
; type assigned to determiners, and these need to be able to take degree
; specifiers, including comparative/equative ones like "as many X", where the
; degree-spec identifies its SPEC's XARG with one argument in the comparative
; relation - necessary because adjectives expose their modifiee noun's index
; as the adj's XARG (since the adj's INDEX is its event, for copula constr's).
; DPF 27-Nov-03 - Also, experimentally, make XARG of NPs be the handle of
; the nbar, which often seems to be needed, e.g. in it-clefts, where the
; rel clause wants to identify its message's handle with that of the nbar.

nom-obj := mrs.

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; Since some temporal nouns can be either arguments or VP modifiers, their 
; rel's ARG0 value (coindexed with INDEX of the containing MRS) must remain 
; unspecified for type.  Consider "Kim arrived Tuesday" vs. "Tuesday comes
; after Monday"; in the first, Tuesday must have an event ARG0, while in the
; second, it must have a ref-ind ARG0.

; ERB (24-10-96) Here is the series of relations that will be used for
; questions, etc.  Cf. Gizburg & Sag.

quant_or_wh_relation := arg0_relation &
  [ PRED quant_or_wh_rel,
    ARG0 ref-ind,
    RSTR handle,
    BODY handle ].

; Values in the feature QUE, used to distinguish ordinary WH-questions from 
; in-situ WH.
param := non_expl_or_param.

; Nominal sorts
nominal-sort := *sort*.
entity-or-event := nominal-sort.
basic_entity := entity-or-event.
entity := basic_entity.
nonloc := entity.
human := nonloc.
location := nominal-sort.
time := location & entity-or-event.
; DPF 14-nov-05 - Removed 'entity' supertype, since this means we get bad
; coordination as in "*We arrived here and the chair."
place := location.
nom-event := entity-or-event.
; DPF 14-nov-09 - Can't make integers be of SORT number distinct from
; 'entity' (tempting, to block "Abrams one") because we also want
; "Kim is ten" which we currently treat as identity-copula with NP "ten"
;number := basic_entity.

; modable_rel distinguishes those relations whose nominal lexical entries can 
; undergo a syntactic rule to produce a modifier phrase, as in "we'll meet
; next week" or "I'll do it my way".

; dir_state_modable_rel is the supertype of modable_rel and dir_or_state_rel
; used by verbs selecting for locative PPs including nominal adverbials which
; are converted from NPs to PPs via a syntactic rule which introduces the
; two-place locative relation.  This type is needed to support the shortcut of
; chart dependencies to filter out verb entries if the corresponding particle
; or preposition is not present, so we can still parse e.g. "Kim put it here".

; Nominal relations

instance_relation := arg0_relation &
  [ ARG0 individual_min ].

nom_relation := instance_relation &
  [ ARG0 non_expl-ind ].

; DPF 25-Sep-01 - Added [SORT entity] contrasted with [SORT time] to enable
; blocking of e.g. "the book that kim arrived" but allow "the day that Kim
; arrived"

reg_nom_relation := nom_relation &
  [ ARG0.SORT entity ].

reg_nom_wcarg_relation := reg_nom_relation & const_value_relation.

modable_nom_relation := nom_relation &
  [ ARG0.SORT entity ].

basic_diadic_nom_relation := nom_relation & basic_arg01_relation.

diadic_nom_relation := basic_diadic_nom_relation &
  [ ARG1 non_expl-ind ].

reg_diadic_nom_relation := diadic_nom_relation &
  [ ARG0.SORT entity ].

diadic_nom_carg_relation := basic_diadic_nom_relation & const_arg01_relation.

triadic_nom_relation := diadic_nom_relation & basic_arg12_relation &
  [ ARG2 non_expl-ind ].

reg_triadic_nom_relation := reg_diadic_nom_relation & basic_arg12_relation &
  [ ARG2 non_expl-ind ].

basic_hcomp_nom_relation := basic_diadic_nom_relation &
  [ ARG1 handle ].

hcomp_nom_relation := basic_hcomp_nom_relation &
  [ ARG0.SORT entity ].

; Changed nominalize_rel and gerund_rel to subtype of non_temp_nom_rel rather 
; than reg_nom_rel to avoid semantically anomalous readings for e.g. "Kim is 
; sleeping".

nom_or_ger_relation := arg0_relation &
  [ ARG0.SORT nom-event ].

nominal_relation := basic_hcomp_nom_relation &
  [ PRED nominalization_rel ].

nominalize_relation := nominal_relation & nom_or_ger_relation.

gerund_relation := basic_diadic_nom_relation & nom_or_ger_relation &
  [ PRED nominalization_rel,
    ARG0 ref-ind ].

temp_abstr_relation := nom_relation &
  [ ARG0.SORT time ].

const_value_relation := relation &
  [ CARG *top* ].

const_arg0_relation := const_value_relation & arg0_relation.
const_arg01_relation := const_arg0_relation & arg01_relation.

generic_named_nom_relation := nom_relation & const_arg0_relation.

named_nom_relation := generic_named_nom_relation &
  [ ARG0.SORT entity ].

generic_diadic_named_relation := generic_named_nom_relation & 
                                 const_arg01_relation &
                                 diadic_nom_relation.
generic_triadic_named_relation := generic_diadic_named_relation &
                                  triadic_nom_relation.
diadic_named_nom_relation := generic_diadic_named_relation &
                             reg_diadic_nom_relation.

; ARG1 is the minute_rel complement's ARG0, and ARG2 is the am_pm's ARG0.
numbered_hour_relation := const_arg01_relation & basic_arg12_relation & 
  [ PRED numbered_hour_rel,
    ARG0 [ PNG png & [ PN 3s,
                       GEN neut ],
           SORT time ],
    CARG string,
    ARG1 individual_min,
    ARG2 individual_min ].

; Pronouns
; DPF 2-Jul-03 - Removed DIV - which was perhaps used earlier to block
; spurious application of bare-np rule.  Not desirable since antecedent could
; of course be mass or plural, and maybe want indices to be unifiable for
; anaphora resolution.

pron_relation := nom_relation &
  [ PRED pron_rel,
    ARG0 ref-ind & [ SORT entity ] ].

recip_pro_relation := nom_relation &
  [ PRED recip_pro_rel,
    ARG0 ref-ind & [ SORT entity ] ].

basic_adj_relation := arg0_relation.
adj_01_relation := basic_adj_relation & basic_arg01_relation.
norm_adj_relation := basic_adj_relation & arg1_relation.
adj_relation := norm_adj_relation &
  [ ARG1 basic_non_expl ].

adj_arg1_relation := adj_relation.
adj_arg12_relation := adj_arg1_relation & arg12_relation.
adj_arg123_relation := adj_arg12_relation & arg123_relation.
it_adj_arg1_relation := adj_arg1_relation.
it_adj_arg12_relation := adj_arg12_relation & it_adj_arg1_relation.
it_adj_arg123_relation := adj_arg123_relation & it_adj_arg12_relation.

; For unknown word adjectives, which currently need a CARG
adj_wcarg_relation := norm_adj_relation & const_arg01_relation.

basic_arg01_relation := arg0_relation &
  [ ARG1 *top* ].

arg01_relation := basic_arg01_relation &
  [ ARG1 semarg ].

arg01_only_relation := arg01_relation.
arg01_carg_relation := arg01_only_relation & const_arg01_relation.

adv_relation := arg01_relation &
  [ ARG0.E [ TENSE no_tense,
             ASPECT no_aspect ] ].
adv12_relation := adv_relation & arg2_relation.
adv_carg_relation := adv_relation & const_arg01_relation.

arg1_relation := arg01_relation & event_relation.

arg2_relation := relation &
  [ ARG2 semarg ].

arg3_relation := relation &
  [ ARG3 semarg ].

arg4_relation := relation &
  [ ARG4 semarg ].

basic_arg12_relation := arg01_relation & arg2_relation.
arg12_relation := basic_arg12_relation & arg1_relation.
arg123_relation := arg12_relation & arg3_relation.
arg1234_relation := arg123_relation & arg4_relation.

aux_arg1_relation := arg1_relation &
  [ PRED aux_arg1_rel ].

; Preposition relations

prep_relation := basic_arg12_relation &
  [ PRED prep_rel ].	    

prep_notense_relation := prep_relation &
  [ ARG0.E [ TENSE no_tense,
             ASPECT no_aspect ] ].

prep_123_relation := prep_relation & arg3_relation.

; Degree relations

degree_relation := basic_arg01_relation &
  [ ARG0 individual_min ].

comparative_relation := degree_relation & basic_arg12_relation &
  [ ARG1 index ].

;; For "how" adjective, which quantifies over properties.

; For "how does Tuesdaay look" using second-order quantification (see notes for
; adj_wh_le in lextypes.tdl
; ARG1 is proposition, ARG2 is property

prpstn_to_prop_relation := arg12_relation &
  [ PRED prpstn_to_prop_rel,
    ARG1 handle,
    ARG2 non_expl-ind ].

comp_relation := prep_relation &
  [ ARG2 event_or_index,
    ARG0.E.TENSE no_tense ].
superl_relation := prep_relation &
  [ ARG2 event_or_index ].

subord_relation := arg12_relation &
  [ ARG1 handle,
    ARG2 handle ].

; Relation for unknown-word noun lexical typess
basic_arg12_carg_relation := basic_arg12_relation & const_arg01_relation.

; Relation for unknown-word verb lexical types, which currently need a ARG
arg12_carg_relation := arg12_relation & const_arg01_relation.

; Discourse functions

; ERB (03-10-96) In order to capture the similarities and differences
; between embedded and matrix questions, I am decomposing the ynq_rel
; into polar_q_rel and request_ans_rel.  NB polar_q_rel
; probably doesn't qualify as 'discourse function'.  

; So, the ynq_root construction will contribute a polar_q_rel and
; a request_ans_rel, whether will contribute a polar_q_rel, and
; matrix wh questions will contribute a request_ans_rel.

prag_d_rel := predsort.
focus_d_rel := prag_d_rel.
parg_d_rel := prag_d_rel.

#|
polar_q_rel := mod_rel.
request_ans_rel := mod_rel.

polite_rel := mod_rel.
|#

basic_conj_relation := arg0_relation &
  [ PRED basic_conj_rel,
    ARG0 conj-ind,
    L-INDEX non_expl,
    R-INDEX non_expl ].

conj_relation := basic_conj_relation &
  [ PRED conj_rel,
    L-HNDL semarg,
    R-HNDL semarg ].

; Abstract relations specified by more than one lexical entry

abstr_place_relation := nom_relation &
  [ ARG0.SORT place ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Number relations

; DPF 10-Feb-02 - Highly experimental addition of ARG0 attribute to get 
; segregation of numerical adjectives

integer_relation := basic_arg01_relation &
  [ PRED integer_rel,
    ARG1 individual_min ].

const_relation := integer_relation & const_arg01_relation &
  [ PRED const_rel].

; plus, times
arg123_int_relation := integer_relation & arg123_relation &
  [ ARG2 handle,
    ARG3 handle ].

;; TYPES/SORTS
;; The CARDINAL feature determines whether its bearer is cardinal or not 
;; (i.e., is ordinal or cardinal).  Thus it is only appropriate for
;; numbers.  All numbers have a HEAD value of sort intsort, those
;; used adjectivally have heads of sort intadj (or one of its 
;; subsorts) or intdet (which has no subsorts).  Nominal uses are
;; not yet supported.
;;
;; Subcategorization, which is in terms of the maximum number of digits
;; allowed for the complement or specifier, is handled by the subsorts
;; of the digitn hierarchy.  Currently, only adjectives participate in
;; this hierarchy; there is only a single integer determiner ("one").
;; Nominal uses could be added by adding a type
;;          intnoun := intsort & digitn & noun.
;;

intsort := head & [ CARDINAL bool ].

digitn := head.

digit15 := digitn.
digit12 := digit15.
digit9 := digit12.
digit6 := digit9.
digit3 := digit6.
digit2 := digit3.
digit1 := digit2.

; The sorts    digitk    specify the number of digits of a lexeme 
; together with its largest complement and specifier.
; The sorts    digitk-    are used for subcategorization; they include
; values of k or fewer digits.
 
digit15- := digitn.
digit12- := digit15-.
digit9- := digit12-.
digit6- := digit9-.
digit3- := digit6-.
digit2- := digit3-.
digit1- := digit2-.

;; DPF 26-Apr-00 - Removed adj parent from intadj.
;; DPF 19-Sept-01 - Added supertype adj_or_intadj, for adj-intervals ("2 - 3")

intadj := adj_or_intadj & intadj_or_superl & intadj_or_comp.
intadjn := intadj & digitn.
intdet := intsort & det.

; intadj1- := intadj1.
; intadjk- means an integer adjective of at most k digits (when
;   combined with specifier and complement

intadj15- := intadj.
intadj15  := intadj15- & digit15.
intadj12- := intadj15-.
intadj12  := intadj12- & digit12.
intadj9- := intadj12-.
intadj9  := intadj9- & digit9.
intadj6- := intadj9-.
intadj6  := intadj6- & digit6.
intadj3- := intadj6-.
intadj3  := intadj3- & digit3.
intadj2- := intadj3-.
intadj2  := intadj2- & digit2.
intadj1  := intadj2- & digit1.

fractadj := intadj & [ MOD < anti_synsem > ].

_here_a_1_rel := adj_rel.
_now_a_1_rel := adj_rel.
_there_a_1_rel := adj_rel.
_today_a_1_rel := adj_rel.
_tomorrow_a_1_rel := adj_rel & dofw_or_poss_q_rel.
_yesterday_a_1_rel := adj_rel & dofw_or_poss_q_rel.
_midmorning_a_1_rel := adj_rel.
_midafternoon_a_1_rel := adj_rel.
_tonight_a_1_rel := adj_rel & dofw_or_poss_q_rel.
_yesteryear_a_1_rel := adj_rel.
_east_a_1_rel := adj_rel.
_north_a_1_rel := adj_rel.
_south_a_1_rel := adj_rel.
_west_a_1_rel := adj_rel.
_outdoors_a_1_rel := adj_rel.
_indoors_a_1_rel := adj_rel.
_overseas_a_1_rel := adj_rel.
_online_a_1_rel := adj_rel.
_offline_a_1_rel := adj_rel.
_off+season_a_1_rel := adj_rel.
_overhead_a_1_rel := adj_rel.
_southeast_a_1_rel := adj_rel.
_southwest_a_1_rel := adj_rel.
_northeast_a_1_rel := adj_rel.
_northwest_a_1_rel := adj_rel.
_northward_a_1_rel := adj_rel.
_southward_a_1_rel := adj_rel.
_eastward_a_1_rel := adj_rel.
_westward_a_1_rel := adj_rel.
_northeastward_a_1_rel := adj_rel.
_southeastward_a_1_rel := adj_rel.
_northwestward_a_1_rel := adj_rel.
_southwestward_a_1_rel := adj_rel.
_upward_a_1_rel := adj_rel.
_downward_a_1_rel := adj_rel.
_uptown_a_1_rel := adj_rel.
_downtown_a_1_rel := adj_rel.
_downhill_p_rel := dir_rel.
_heavenward_a_1_rel := adj_rel.
_inward_a_1_rel := adj_rel.
_outward_a_1_rel := adj_rel.
_inland_a_1_rel := adj_rel.
_late_p_rel := miscprep_rel.
_elsewhere_a_1_rel := adj_rel.
_forever_a_1_rel := adj_rel.
_long_a_1_rel := adj_rel.
_longer_a_1_rel := adj_rel.
_respective_a_1_rel := miscprep_rel.
_soon_p_rel := miscprep_rel.
_sooner_p_rel := miscprep_rel.
_skyward_a_1_rel := adj_rel.
_thither_a_1_rel := adj_rel.
_underfoot_a_1_rel := adj_rel.
_underground_a_1_rel := adj_rel.
_up+to+date_a_1_rel := adj_rel.
_yonder_a_1_rel := adj_rel.
_arrear_a_1_rel := adj_rel.
_one-by-one_a_1_rel := adj_rel.


much-many_a_rel := adj_rel & card_or_much_rel.
little-few_a_rel := adj_rel & card_or_much_rel.

; For fragments
unknown_relation := arg0_relation &
  [ PRED unknown_rel,
    ARG0 event,
    ARG semarg ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Basic types

; DPF 10-Sep-03 Temporary redefinition of *sort* until we get rid of relations
; as values of MIN.

*sort* := *top*.

atom := predsort.

*avm* := *top*.

*list* := *avm*.

*cons* := *list* &
  [ FIRST *top*,
    REST *top* ].

0-1-list := *list*.
1-list := 0-1-list & *cons* &
  [ REST *null* ].
*null* := 0-1-list.
1-oblcons := 1-list & *oblcons*.
1-ocons := 1-list & *ocons*.

1-plus-list := *cons* &
  [ REST *cons* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Basic types

; Used for characterization
initial-cfrom-val := atom.
initial-cto-val := atom.

string := initial-cfrom-val & initial-cto-val.

integer := atom.

; Lists

; ERB (13-12-97) This type is meant as a PRO -- i.e., what can show
; up in such things as the 'way' construction and embedded infinitival
; wh questions.  It should eventually receive some binding properties,
; but I don't know what to put there yet, and since we don't have
; a binding theory...

; ERB (14-12-97) I am adding the pron_rel to pro_ss, so that in the
; types like common_noun_vpcomp_synsem I don't have to put it in.  I
; can just take the KEYREL.

; ERB (14-12-97) No pron_rel for pro_ss.

; ERB (14-12-97) ... and pro_ss is accusative, to block (once I get
; infinitival relatives working) *A person left came in.

; ERB (14-12-97) This is moved here so as to be after acc, which is a 
; *sort* and thus can't handle being referenced before it is defined.

; ERB (19-01-98) PRO is obligatorially OPT -.  This keeps to_c_prop
; from serving as a modifier without first building a non_wh_rel,
; because hadj requires SUBJ *olist*.

; ERB (21-01-98) In order for PRO to be extractable, it can't be
; SLASH 0-dlist, and thus can't be a subtype of unexpressed.  With
; PRO underspecified for SLASH, something will always have to fill
; in that value.  In the case of subject non_wh_rels (e.g., 
; "Kim found a person to fix the sink") it is extracted, i.e., resolved
; to gappro by extrasubj.  In the cases where the PRO is the subject of
; a selected complement, the selector will impose SLASH 0-dlist on the
; PRO (this case includes equi constructions, embedded infinitival
; wh questions, and the complement of 'way' as in "Kim found a way
; to leave early").  In the case of the (as yet unimplemented) CP[to]
; subjects, the NP -> CP rule will probably do the work.  Alternatively,
; the selecting category could do it.  Finally, in the case of
; non-subject non_wh_rels (e.g., "Kim found a cheeseburger to devour"),
; the PRO must be SLASH 0-dlist because the non_wh_rel_rule limits
; the SLASH list to length one.
;
; On a related note, we want the distribution of gappro (i.e., of
; extracted PRO) to be quite constrained, and perhaps even limited
; to the subject non_wh_rels.  In general, we are relying on the
; restriction of SLASH to lists of length one stated in several places
; in the grammar, in addition to certain selecting categories' specifying
; an empty value for SLASH on the PROs in their complements' subjects
; to keep us from getting in trouble on this one.
;
; Finally, rather than make a subtype of pro_ss that says SLASH 0-dlist,
; I have opted to include that information on the type *prolist*.

; ERB (03-23-98) We need a way to identify indices introduced by a PRO
; that are "discourse bound".  We were using PRONTYPE for this, but
; of course that doesn't work when the controller of the PRO is an overt
; pronoun.  So the new strategy is to make the INDEX a non_expl.
; This will unify with the indices introduced by (appropriate) controllers,
; and (hopefully) be identifiable if it is not controlled.

; DPF 27-May-99 - Removed OPT - constraint from pro_ss (see ERB (19-01-98) 
; above) since head_mod type now constrained via PRD rather than by requiring 
; SUBJ to be empty (cf note DPF 27-May-99 with n_adj_int_phrase in syntax.tdl).
; This change means the types for saturated subcats can again simply require 
; SUBJ to be *olist* rather than *null*, which e.g. allows verbal gerunds to 
; have optional but non-empty SUBJ value and still themselves appear as 
; subjects or complements without discharging that SUBJ value.
; DPF 15-Nov-03 - Added CONT.HOOK.INDEX ref-ind, which blocks spurious analysis
; of e.g. "to be" with expletive-subj elided be.  And linked it to --SIND
; for consistency.  
; DPF 06-dec-03 - But this fails to scope when there is no antecedent, as in
; "it takes a week to get there" (cf ok "It takes me a week to get there").
; So remove constraint of ref-ind.  Instead constrain NP-S rule's XARG.

pro_ss := expressed_non_canonical &
  [ LOCAL [ CAT.HEAD noun & [ CASE acc ],
            CONT.HOOK.INDEX #ind ],
    NONLOC [ REL 0-dlist,
             QUE 0-dlist ],
    --SIND #ind ].

; ERB (19-01-98) We need a subtype of pro and gap so that to_c_prop
; can undergo subject extraction.  See the notes near non_wh_rel in
; syntax.tdl for the details of the analysis.
; I am positive that this will break something, but I could not
; guess what.

gappro := pro_ss & gap.
; Needed in infinitival vp_fin-frg_c rule to prevent spurious analyis with subj gap.
nongappro := pro_ss &
  [ NONLOC.SLASH 0-dlist ].

*olist_or_prolist* := *list*.
*ocons_or_procons* := *olist_or_prolist* & *cons* &
  [ FIRST.NONLOC.SLASH 0-dlist ].
*olist* := *olist_or_prolist*.
*ocons* := *olist* & *ocons_or_procons* &
  [ FIRST unexpressed & [ OPT + ],
    REST  *olist* ].
*onull* := *olist* & *null*.

*obllist* := *list*.
; DPF 8-May-08 - Added constraint that element be HEAD subst to exclude
; "enough" deg complement added by lexical rule to adjectives
*oblcons* := *obllist* & *cons* &
  [ FIRST [ OPT -,
	    LOCAL.CAT.HEAD subst ],
    REST  *obllist* ].
*oblnull* := *obllist* & *null*.

*synlist* := *list*.
*syncons* := *synlist* & *cons* &
  [ FIRST synsem,
    REST  *synlist* ].
*syn_ocons* := *syncons* & *ocons*.
*synnull* := *synlist* & *onull*.

*phrlist* := *list*.
*phrcons* := *phrlist* & *cons* &
  [ FIRST phr_synsem & [ OPT + ],
    REST  *phrlist* ].
*phrnull* := *phrlist* & *onull* & *oblnull*.

*gaplist* := *list*.
*gapcons* := *gaplist* & *cons* &
  [ FIRST gap,
    REST  *null* ].
*gapnull* := *gaplist* & *null*.

*prolist* := *olist_or_prolist*.
*procons* := *prolist* & *ocons_or_procons* &
  [ FIRST pro_ss,
    REST *null* ].
*pronull* := *prolist* & *onull*.

*anti_list* := *list*.
*anti_cons* := *anti_list* & *cons* &
  [ FIRST anti_synsem,
    REST *anti_list* ].
*anti_ocons* := *anti_cons* & *ocons*.
*anti_null* := *anti_list* & *onull*.

;; *unexplist* is used for common nouns whose specifier is possibly obligatory,
;; but unexpressed, as in noun-noun compounds.  As usual, we use the same hack
;; as for *olist*, to get around the lack of recursive types in TDL.

*unexplist* := *list*.

*unexpcons* := *unexplist* & *cons* &
  [ FIRST unexpressed,
    REST  *null* ].

;*unexpnull* := *unexplist* & *olist* & *null*.
*unexpnull* := *unexplist* & *onull*.

;; *substlist* is used in the adv_addition lexical rule, to prevent spurious
;; re-application of the rule to its own output by requiring the input to
;; be a (possibly empty) list of substantive synsems.
*substlist* := *list*.

*substcons* := *substlist* & *cons* &
  [ FIRST.LOCAL.CAT.HEAD subst,
    REST  *substlist* ].

; For there-copula
*substocons* := *substcons* & *ocons*.

;*substnull* := *substlist* & *olist* & *null*.
*substnull* := *substlist* & *onull* & *oblnull*.

; For constraint on COMPS.REST in passive rule, to block e.g.
; "*Kim was given by Abrams a book."
*obliquelist* := *list*.

*obliquecons* := *obliquelist* & *cons* &
  [ FIRST.LOCAL.CAT.HEAD non_noun,
    REST  *obliquelist* ].

*obliqueocons* := *obliquecons* & *ocons*.
*obliquenull* := *obliquelist* & *onull*.

; Values of SLASH.LIST
*arglist* := 0-1-list.
*argcons* := *arglist* & 1-list &
  [ FIRST arg-local,
    REST *arglist* ].
*argnull* := *arglist* & *null*.

*modlist* := 0-1-list.
*modcons* := *modlist* & 1-list &
  [ FIRST mod-local,
    REST *modlist* ].
*modnull* := *modlist* & *null*.

;; *paramlist* is used in the treatment of free relatives, to distinguish
;; the usual value of QUE from its use in free relatives, where QUE is instead
;; a list of referential indices.

*paramlist* := *list*.

*paramcons* := *paramlist* & 1-list &
  [ FIRST param,
    REST  *null* ].

*paramnull* := *paramlist* & *onull*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subtypes of *diff-list*

;; Experimental use of subtypes of *diff-list* to enforce constraint of at
;; most one element in SLASH (for efficiency, "violin/sonnet" examples
;; notwithstanding).  Will only have effect in LKB version which does the
;; necessary type inference.

*diff-list* := *avm* &
[ LIST *list*,
  LAST *list* ].

0-1-dlist := *diff-list* &
  [ LIST 0-1-list ].

; DPF 10-Oct-02 - Just a reminder that we cannot make the LIST value of 0-dlist
; be < >, much as we might like to, since we're doing lexical threading of
; SLASH (at least), and if we make all 0-dlists have LIST < >, then if the
; first of two complements is a proper name with SLASH 0-dlist, then the
; appended diff-list also has LIST <>, which prevents the second complement
; (or the subject) from being slashed, so we would even block "Who hired Kim".
; Instead, need to ensure manually that for each dtr in a construction, if the
; SLASH value of the nonhead dtr is not carried up via lexical threading by
; the head-dtr, or by the construction itself, then that dtr must be 
; constrained to be (seemingly redundantly) [ SLASH 0-dlist & [ LIST < > ] ].

0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].
1-dlist := 0-1-dlist &
  [ LIST 1-list &
	 [ REST #rest & *null* ],
    LAST #rest ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; pred names

; for 'different from/than X'
than_or_from_rel := selected_prep_rel.

; For PP complements of (temporal) 'from X to/until/through Y'
abstr_until_sel_rel := selected_prep_rel.

_aback_p_sel_rel := selected_prep_rel.
_about_p_sel_rel := selected_prep_rel.
_across_p_sel_rel := selected_prep_rel.
_after_p_sel_rel := minute_prep_sel_rel.
_against_p_sel_rel := selected_prep_rel.
_ahead_p_sel_rel := selected_prep_rel.
_along_p_sel_rel := selected_prep_rel.
_among_p_sel_rel := selected_prep_rel.
_apart_a_sel_rel := selected_adj_rel.
_around_p_sel_rel := selected_prep_rel.
_as_p_comp_rel := selected_prep_rel.
_as_p_sel_rel := selected_prep_rel.
_as+to_p_sel_rel := selected_prep_rel.
_aside_p_sel_rel := selected_prep_rel.
_at_p_sel_rel := selected_prep_rel.
_away_p_sel_rel := selected_prep_rel.
_back_p_sel_rel := selected_prep_rel.
_behind_p_sel_rel := selected_prep_rel.
_between_p_sel_rel := selected_prep_rel.
_by_p_sel_rel := selected_prep_rel.
_by_p_cm_rel := selected_prep_rel.
_down_p_sel_rel := selected_prep_rel.
_for_p_sel_rel := selected_prep_rel.
_for_p_trgt_rel := selected_prep_rel.
_forth_p_sel_rel := selected_prep_rel.
_forward_p_sel_rel := selected_prep_rel.
_from_p_sel_rel := than_or_from_rel.
_home_a_sel_rel := selected_adj_rel.
_in_p_sel_rel := selected_prep_rel.
_into_p_sel_rel := selected_prep_rel.
of_p_sel_rel := selected_prep_rel.
_of_p_sel_rel := of_p_sel_rel.
_of_p_nbar_rel := of_p_sel_rel.
_off_p_sel_rel := selected_prep_rel.
on_p_sel_rel := selected_prep_rel.
_on_p_sel_rel := on_p_sel_rel.
_onto_p_sel_rel := selected_prep_rel.
_onward_p_sel_rel := on_p_sel_rel.
_onwards_p_sel_rel := on_p_sel_rel.
_open_a_sel_rel := selected_adj_rel.
_out+of_p_sel_rel := selected_prep_rel.
_out_p_sel_rel := selected_prep_rel.
_over_p_sel_rel := selected_prep_rel.
_short_a_sel_rel := selected_adj_rel.
_still_a_sel_rel := selected_adj_rel.
_thin_a_sel_rel := selected_adj_rel.
_through_p_sel_rel := abstr_until_sel_rel.
_to_p_sel_rel := abstr_until_sel_rel & minute_prep_sel_rel.
_to_p_nbar_rel := selected_prep_rel.
_together_p_sel_rel := selected_prep_rel.
_toward_p_sel_rel := selected_prep_rel.
_towards_p_sel_rel := selected_prep_rel.
_under_p_sel_rel := selected_prep_rel.
_until_p_sel_rel := abstr_until_sel_rel & minute_prep_sel_rel.
_dashpnct_p_sel_rel := abstr_until_sel_rel.
_up_p_sel_rel := selected_prep_rel.
_upon_p_sel_rel := selected_prep_rel.
_with_p_sel_rel := selected_prep_rel.
_without_p_sel_rel := selected_prep_rel.
_than_p_compar_rel := than_or_from_rel.
_yet_p_sel_rel := selected_prep_rel.

_a_p_per_rel := miscprep_rel.
_abaft_p_rel := dir_or_state_nontemp_rel.
_abaft_p_dir_rel := _abaft_p_rel & dir_rel.
_abaft_p_state_rel := _abaft_p_rel & state_loc_rel.
_abeam_p_rel := dir_or_state_nontemp_rel.
_abeam_p_dir_rel := _abeam_p_rel & dir_rel.
_abeam_p_state_rel := _abeam_p_rel & state_loc_rel.
_aboard_p_rel := dir_or_state_nontemp_rel.
_aboard_p_dir_rel := _aboard_p_rel & dir_rel.
_aboard_p_state_rel := _aboard_p_rel & state_loc_rel.
_about_p_rel := miscprep_rel.
_above_p_rel := dir_or_state_nontemp_rel.
_above_p_dir_rel := _above_p_rel & dir_rel.
_above_p_state_rel := _above_p_rel & state_loc_rel.
_aboveboard_p_rel := miscprep_rel.
_aboveground_p_rel := miscprep_rel.
_abroad_p_rel := miscprep_rel.
_according+to_p_rel := miscprep_rel.
_across_p_rel := dir_or_state_nontemp_rel.
_across_p_dir_rel := _across_p_rel & dir_rel.
_across_p_state_rel := _across_p_rel & state_loc_rel.
_ad_p_temp_rel := temp_loc_sp_rel.
_adjacent+to_p_rel := dir_or_state_nontemp_rel.
_adjacent+to_p_dir_rel := _adjacent+to_p_rel & dir_rel.
_adjacent+to_p_state_rel := _adjacent+to_p_rel & state_loc_rel.
_afield_p_rel := miscprep_rel.
_aft_p_rel := dir_or_state_nontemp_rel.
_aft_p_dir_rel := _aft_p_rel & dir_rel.
_aft_p_state_rel := _aft_p_rel & state_loc_rel.
_aft+of_p_rel := dir_or_state_nontemp_rel.
_aft+of_p_dir_rel := _aft+of_p_rel & dir_rel.
_aft+of_p_state_rel := _aft+of_p_rel & state_loc_rel.
_after_p_rel := temp_loc_rel.
_after_p_n-n_rel := miscprep_rel.
_afterward_p_rel := miscprep_rel.
_afterwards_p_rel := miscprep_rel.
_against_p_rel := miscprep_rel.
_ago_p_rel := miscprep_rel.
_ahead_p_rel := miscprep_rel.
_ahead+of_p_rel := dir_or_state_nontemp_rel.
_ahead+of_p_dir_rel := _ahead+of_p_rel & dir_rel.
_ahead+of_p_state_rel := _ahead+of_p_rel & state_loc_rel.
_a+la_p_rel := miscprep_rel.
_albeit_x_rel := miscprep_rel.
_all+around_p_rel := miscprep_rel.
_all+over_p_rel := miscprep_rel.
_all+the+while_p_rel := miscprep_rel.
_alone_p_rel := miscprep_rel.
_along_p_rel := dir_or_state_nontemp_rel.
_along_p_dir_rel := _along_p_rel & dir_rel.
_along_p_state_rel := _along_p_rel & state_loc_rel.
_along+with_p_rel := miscprep_rel.
_alongside_p_rel := miscprep_rel.
_although_x_rel := miscprep_rel.
_amid_p_rel := miscprep_rel.
_amidst_p_rel := miscprep_rel.
_among_p_rel := dir_or_state_nontemp_rel.
_among_p_dir_rel := _among_p_rel & dir_rel.
_among_p_state_rel := _among_p_rel & state_loc_rel.
_amongst_p_rel := dir_or_state_nontemp_rel.
_amongst_p_dir_rel := _amongst_p_rel & dir_rel.
_amongst_p_state_rel := _amongst_p_rel & state_loc_rel.
_apart+from_p_rel := miscprep_rel.
_arm+in+arm_a_1_rel := miscprep_rel.
_around_p_rel := dir_or_state_nontemp_rel.
_around_p_dir_rel := _around_p_rel & dir_rel.
_around_p_state_rel := _around_p_rel & state_loc_rel.
_as_p_rel := miscprep_rel.
_as_p_nbar_rel := miscprep_rel.
_as+far+as_p_rel := dir_or_state_nontemp_rel.
_as+far+as_p_dir_rel := _as+far+as_p_rel & dir_rel.
_as+far+as_p_state_rel := _as+far+as_p_rel & state_loc_rel.
_as+follows_p_rel := miscprep_rel.
_as+for_p_rel := miscprep_rel.
_as+if_p_rel := miscprep_rel.
_as+is_p_rel := miscprep_rel.
_as+of_p_rel := temp_loc_rel.
_as+opposed+to_p_rel := miscprep_rel.
_as+though_x_rel := miscprep_rel.
_as+to_p_rel := miscprep_rel.
_ashore_p_rel := miscprep_rel.
_aside_p_rel := miscprep_rel.
_aside+from_p_rel := miscprep_rel.
_astray_p_rel := miscprep_rel.
_astride_p_rel := miscprep_rel.
_at+best_p_rel := miscprep_rel.
_at+large_p_rel := miscprep_rel.
_at+present_p_rel := miscprep_rel.
_at_p_rel := state_loc_rel & nontemp_loc_sp_rel.
_at_p_temp_rel := temp_loc_sp_rel.
_athwart_p_rel := dir_or_state_nontemp_rel.
_athwart_p_dir_rel := _athwart_p_rel & dir_rel.
_athwart_p_state_rel := _athwart_p_rel & state_loc_rel.
_atop_p_rel := miscprep_rel.
_away_p_rel := dir_or_state_nontemp_rel.
_away_p_dir_rel := _away_p_rel & dir_rel.
_away_p_state_rel := _athwart_p_rel & state_loc_rel.
_back_p_rel := miscprep_rel.
_backward_p_rel := miscprep_rel.
_backwards_p_rel := miscprep_rel.
_bc_p_temp_rel := temp_loc_sp_rel.
_because+of_p_rel := miscprep_rel.
_before_p_rel := miscprep_rel.
_beforehand_p_rel := miscprep_rel.
_below_p_rel := dir_or_state_nontemp_rel.
_below_p_dir_rel := _below_p_rel & dir_rel.
_below_p_state_rel := _below_p_rel & state_loc_rel.
_behind_p_rel := dir_or_state_nontemp_rel.
_behind_p_dir_rel := _behind_p_rel & dir_rel.
_behind_p_state_rel := _behind_p_rel & state_loc_rel.
_beneath_p_rel := miscprep_rel.
_beside_p_rel := dir_or_state_nontemp_rel.
_beside_p_dir_rel := _beside_p_rel & dir_rel.
_beside_p_state_rel := _beside_p_rel & state_loc_rel.
_besides_p_rel := miscprep_rel.
_between_p_rel := temp_loc_rel.
_betwixt_p_rel := temp_loc_rel.
_beyond_p_rel := dir_or_state_nontemp_rel.
_beyond_p_dir_rel := _beyond_p_rel & dir_rel.
_beyond_p_state_rel := _beyond_p_rel & state_loc_rel.
_but+for_p_rel := miscprep_rel.
_but_p_except_rel := miscprep_rel.
_by_p_rel := dir_rel.
_by_p_temp_rel := temp_loc_rel.
_by_p_means_rel := miscprep_rel.
_by+means+of_p_rel := miscprep_rel.
_by+way+of_p_rel := miscprep_rel.
_by+colon_p_rel := miscprep_rel.
_by_p_n-n_rel := miscprep_rel.
_circa_p_rel := temp_loc_rel.
_close+to_p_rel := miscprep_rel.
_colon_p_namely_rel := loc_abstr_rel.
_concerning_p_rel := miscprep_rel.
_care+of_p_rel := miscprep_rel.
_clockwise_p_rel := dir_or_state_nontemp_rel.
_clockwise_p_dir_rel := _clockwise_p_rel & dir_rel.
_clockwise_p_state_rel := _clockwise_p_rel & state_loc_rel.
_close+by_p_rel := miscprep_rel.
_counterclockwise_p_rel := dir_or_state_nontemp_rel.
_counterclockwise_p_dir_rel := _counterclockwise_p_rel & dir_rel.
_counterclockwise_p_state_rel := _counterclockwise_p_rel & state_loc_rel.
_counter+to_p_rel := miscprep_rel.
_crossways_p_rel := dir_or_state_nontemp_rel.
_crossways_p_dir_rel := _crossways_p_rel & dir_rel.
_crossways_p_state_rel := _crossways_p_rel & state_loc_rel.
_despite_p_rel := miscprep_rel.
_down_p_rel := dir_rel.
_downstairs_p_rel := miscprep_rel.
_downstream_p_rel := miscprep_rel.
_downstream+of_p_rel := dir_or_state_nontemp_rel.
_downstream+of_p_dir_rel := _downstream+of_p_rel & dir_rel.
_downstream+of_p_state_rel := _downstream+of_p_rel & state_loc_rel.
_due+to_p_rel := miscprep_rel.
_during_p_rel := temp_loc_rel.
_e+g_p_rel := miscprep_rel.
_each_p_rel := miscprep_rel.
_en+route_p_rel := dir_rel.
_ever+before_p_rel := temp_loc_rel.
_ever+since_p_rel := temp_loc_rel.
_except+for_p_rel := miscprep_rel.
_except_p_rel := miscprep_rel.
_excepting_p_rel := miscprep_rel.
_face+to+face_a_1_rel := dir_or_state_nontemp_rel.
_face+to+face_a_dir_rel := _face+to+face_a_1_rel & dir_rel.
_face+to+face_a_state_rel := _face+to+face_a_1_rel & state_loc_rel.
_facing_p_rel := dir_rel.
_farther+on_p_rel := miscprep_rel.
_for_p_rel := miscprep_rel.
_for+example_p_rel := miscprep_rel.
_for+instance_p_rel := miscprep_rel.
_for+lack+of_p_rel := miscprep_rel.
_for+the+better_p_rel := miscprep_rel.
_fore_p_rel := dir_or_state_nontemp_rel.
_fore_p_dir_rel := _fore_p_rel & dir_rel.
_fore_p_state_rel := _fore_p_rel & state_loc_rel.
_forth_p_rel := dir_or_state_nontemp_rel.
_forth_p_dir_rel := _forth_p_rel & dir_rel.
_forth_p_state_rel := _forth_p_rel & state_loc_rel.
_forward_p_rel := dir_or_state_nontemp_rel.
_forward_p_dir_rel := _forward_p_rel & dir_rel.
_forward_p_state_rel := _forward_p_rel & state_loc_rel.
_forward+of_p_rel := dir_or_state_nontemp_rel.
_forward+of_p_dir_rel := _forward+of_p_rel & dir_rel.
_forward+of_p_state_rel := _forward+of_p_rel & state_loc_rel.
_forwards_p_rel := miscprep_rel.
_fore+and+aft_p_rel := miscprep_rel.
_from_p_rel := miscprep_rel.
_from_p_to_rel := dir_rel & instance_rel.
_from_p_to-n_rel := dir_rel & instance_rel.
_from_p_time-on_rel := miscprep_rel.
_from_p_time_rel := temp_loc_sp_rel.
_further_p_rel := dir_or_state_nontemp_rel.
_further_p_dir_rel := _further_p_rel & dir_rel.
_further_p_state_rel := _further_p_rel & state_loc_rel.
_further+on_p_rel := miscprep_rel.
_going+by_p_rel := miscprep_rel.
_gone+by_p_rel := miscprep_rel.
_hand+in+hand+with_p_rel := miscprep_rel.
_hereabouts_p_rel := miscprep_rel.
_herein_p_rel := dir_or_state_nontemp_rel.
_herein_p_dir_rel := _herein_p_rel & dir_rel.
_herein_p_state_rel := _herein_p_rel & state_loc_rel.
_hither_p_rel := dir_or_state_nontemp_rel.
_hither_p_dir_rel := _hither_p_rel & dir_rel.
_hither_p_state_rel := _hither_p_rel & state_loc_rel.
_hitherward_p_rel := miscprep_rel.
_home_p_rel := dir_or_state_nontemp_rel.
_home_p_dir_rel := _home_p_rel & dir_rel.
_home_p_state_rel := _home_p_rel & state_loc_rel.
_i+e_p_rel := miscprep_rel.
_in+addition+to_p_rel := miscprep_rel.
_in+back+of_p_rel := dir_or_state_nontemp_rel.
_in+back+of_p_dir_rel := _in+back+of_p_rel & dir_rel.
_in+back+of_p_state_rel := _in+back+of_p_rel & state_loc_rel.
_in+behalf+of_p_rel := miscprep_rel.
_in+between_p_rel := dir_or_state_nontemp_rel.
_in+between_p_dir_rel := _in+between_p_rel & dir_rel.
_in+between_p_state_rel := _in+between_p_rel & state_loc_rel.
_in+case+of_p_rel := miscprep_rel.
_in+connection+with_p_rel := miscprep_rel.
_in+front+of_p_rel := dir_or_state_nontemp_rel.
_in+front+of_p_dir_rel := _in+front+of_p_rel & dir_rel.
_in+front+of_p_state_rel := _in+front+of_p_rel & state_loc_rel.
_in+full_p_1_rel := miscprep_rel.
_in+general_a_1_rel := miscprep_rel.
_in+lieu+of_p_rel := miscprep_rel.
_in+part_p_1_rel := miscprep_rel.
_in+particular_p_1_rel := miscprep_rel.
_in+situ_a_1_rel := miscprep_rel.
_in+the+know_a_1_rel := miscprep_rel.
_in+the+meanwhile_p_rel := miscprep_rel.
_in_p_rel := nontemp_loc_sp_rel.
_in_p_dir_rel := _in_p_rel & dir_rel.
_in_p_state_rel := _in_p_rel & state_loc_rel.
_in_p_temp_rel := temp_loc_sp_rel.
_in+place+of_p_rel := miscprep_rel.
_in+regard+to_p_rel := miscprep_rel.
_in+relation+to_p_rel := miscprep_rel.
_in+spite+of_p_rel := miscprep_rel.
_instead+of_p_rel := miscprep_rel.
_in+the+course+of_p_rel := miscprep_rel.
_in+the+way+of_p_rel := miscprep_rel.
_in+view+of_p_rel := miscprep_rel.
_inboard+of_p_rel := dir_or_state_nontemp_rel.
_inboard+of_p_dir_rel := _inboard+of_p_rel & dir_rel.
_inboard+of_p_state_rel := _inboard+of_p_rel & state_loc_rel.
_independently+of_p_rel := miscprep_rel.
_inside_p_rel := dir_or_state_nontemp_rel.
_inside_p_dir_rel := _inside_p_rel & dir_rel.
_inside_p_state_rel := _inside_p_rel & state_loc_rel.
_instead_p_rel := miscprep_rel.
_into_p_rel := dir_rel.
_in+toward_p_rel := miscprep_rel.
_just+like_p_rel := miscprep_rel.
_later+on_p_rel := miscprep_rel.
_less+than_p_rel := miscprep_rel.
_like_p_rel := miscprep_rel.
_long+past_p_rel := miscprep_rel.
_maximum_p_rel := miscprep_rel.
_meanwhile_p_rel := miscprep_rel.
_midfield_p_rel := state_loc_rel.
_more+than_p_rel := miscprep_rel.
_namely_p_rel := miscprep_rel.
_nationwide_a_1_rel := miscprep_rel.
_near_p_rel := dir_or_state_nontemp_rel.
_near_p_dir_rel := _near_p_rel & dir_rel.
_near_p_state_rel := _near_p_rel & state_loc_rel.
_nearby_p_rel := miscprep_rel.
_nearest_p_rel := state_loc_rel.
_next+to_p_rel := dir_or_state_nontemp_rel.
_next+to_p_dir_rel := _next+to_p_rel & dir_rel.
_next+to_p_state_rel := _next+to_p_rel & state_loc_rel.
_no+matter_p_rel := miscprep_rel.
_notwithstanding_p_rel := miscprep_rel.
of_p_rel := miscprep_rel & compound_or_prep_rel.
_of_p_rel := of_p_rel.
_off-course_p_rel := dir_or_state_nontemp_rel.
_off-course_p_dir_rel := _off-course_p_rel & dir_rel.
_off-course_p_state_rel := _off-course_p_rel & state_loc_rel.
_off+of_p_rel := miscprep_rel.
_off_p_rel := dir_or_state_nontemp_rel.
_off_p_dir_rel := _off_p_rel & dir_rel.
_off_p_state_rel := _off_p_rel & state_loc_rel.
_offshore_p_rel := miscprep_rel.
_on_p_rel := nontemp_loc_sp_rel.
_on_p_dir_rel := _on_p_rel & dir_rel.
_on_p_state_rel := _on_p_rel & state_loc_rel.
_on_p_temp_rel := temp_loc_sp_rel.
_on+behalf+of_p_rel := miscprep_rel.
_on+board_p_rel := miscprep_rel.
_on+foot_p_rel := miscprep_rel.
_on+the+basis+of_p_rel := miscprep_rel.
_on+the+part+of_p_rel := miscprep_rel.
_once_p_rel := temp_loc_rel.
_once_x_rel := miscprep_rel.
_onto_p_rel := dir_rel.
_onward_p_rel := dir_rel.
_onwards_p_rel := dir_rel.
_opposite_p_rel := dir_rel.
_other+than_p_rel := miscprep_rel.
_out_p_rel := dir_or_state_nontemp_rel.
_out_p_dir_rel := _out_p_rel & dir_rel.
_out_p_state_rel := _out_p_rel & state_loc_rel.
_out+of_p_rel := dir_or_state_nontemp_rel.
_out+of_p_dir_rel := _out+of_p_rel & dir_rel.
_out+of_p_state_rel := _out+of_p_rel & state_loc_rel.
_out+of+doors_p_rel := dir_or_state_nontemp_rel.
_out+of+doors_p_dir_rel := _out+of+doors_p_rel & dir_rel.
_out+of+doors_p_state_rel := _out+of+doors_p_rel & state_loc_rel.
_outboard+of_p_rel := dir_or_state_nontemp_rel.
_outboard+of_p_dir_rel := _outboard+of_p_rel & dir_rel.
_outboard+of_p_state_rel := _outboard+of_p_rel & state_loc_rel.
_outside_p_rel := dir_or_state_nontemp_rel.
_outside_p_dir_rel := _outside_p_rel & dir_rel.
_outside_p_state_rel := _outside_p_rel & state_loc_rel.
_outside+of_p_rel := dir_or_state_nontemp_rel.
_outside+of_p_dir_rel := _outside+of_p_rel & dir_rel.
_outside+of_p_state_rel := _outside+of_p_rel & state_loc_rel.
_over_p_rel := dir_or_state_nontemp_rel.
_over_p_dir_rel := _over_p_rel & dir_rel.
_over_p_state_rel := _over_p_rel & state_loc_rel.
_over_p_temp_rel := temp_loc_sp_rel.
_overboard_p_rel := miscprep_rel.
_overland_p_rel := miscprep_rel.
_overnight_a_1_rel := adj_rel.
_owing+to_p_rel := miscprep_rel.
_past_p_rel := dir_or_state_nontemp_rel.
_past_p_dir_rel := _past_p_rel & dir_rel.
_past_p_state_rel := _past_p_rel & state_loc_rel.
_per_p_rel := miscprep_rel.
_per+centimeter_p_rel := miscprep_rel.
_per+se_p_rel := miscprep_rel.
_per+mol_p_rel := miscprep_rel.
_per+second_p_rel := miscprep_rel.
_previous+to_p_rel := temp_loc_rel.
_prior+to_p_rel := temp_loc_rel.
_pro+rata_p_rel := miscprep_rel.
_rather+than_p_rel := miscprep_rel.
_rearward_p_rel := dir_or_state_nontemp_rel.
_rearward_p_dir_rel := _rearward_p_rel & dir_rel.
_rearward_p_state_rel := _rearward_p_rel & state_loc_rel.
_regarding_p_rel := miscprep_rel.
_regardless+of_p_rel := miscprep_rel.
_rightarrow_p_rel := miscprep_rel.
_right+away_p_rel := miscprep_rel.
_save_p_rel := miscprep_rel.
_save+for_p_rel := miscprep_rel.
_side+by+side_p_rel := miscprep_rel.
_sideways_p_rel := miscprep_rel.
_since_p_rel := temp_loc_rel.
_starboard_p_rel := miscprep_rel.
_such+as_p_rel := miscprep_rel.
_thanks+to_p_rel := miscprep_rel.
_than_p_ind_rel := miscprep_rel.
_that+is_p_rel := miscprep_rel.
_then_p_temp_rel := miscprep_rel.
_thereabouts_p_rel := miscprep_rel.
_thereafter_p_rel := miscprep_rel.
_therefrom_p_rel := miscprep_rel.
_thereof_p_rel := miscprep_rel.
_therein_p_rel := dir_or_state_nontemp_rel.
_therein_p_dir_rel := _therein_p_rel & dir_rel.
_therein_p_state_rel := _therein_p_rel & state_loc_rel.
_therewith_p_rel := miscprep_rel.
_thither_p_rel := dir_or_state_nontemp_rel.
_thither_p_dir_rel := _thither_p_rel & dir_rel.
_thither_p_state_rel := _thither_p_rel & state_loc_rel.
_thitherward_p_rel := miscprep_rel.
_though_x_rel := miscprep_rel.
_through_p_rel := dir_or_state_nontemp_rel.
_through_p_dir_rel := _through_p_rel & dir_rel. 
_through_p_state_rel := _through_p_rel & state_loc_rel. 
_throughout_p_rel := dir_or_state_nontemp_rel.
_throughout_p_dir_rel := _throughout_p_rel & dir_rel.
_throughout_p_state_rel := _throughout_p_rel & state_loc_rel.
_to+date_p_rel := miscprep_rel.
_to+do+with_p_rel := miscprep_rel.
_to_p_rel := dir_rel & to_or_with_p_rel.
_together_p_rel := dir_rel.
_together+with_p_rel := miscprep_rel.
_too_a_also_rel := adv_rel.
_toward_p_rel := dir_rel.
_towards_p_rel := dir_rel.
_under_p_rel := dir_or_state_nontemp_rel.
_under_p_dir_rel := _under_p_rel & dir_rel.
_under_p_state_rel := _under_p_rel & state_loc_rel.
_underneath_p_rel := dir_or_state_nontemp_rel.
_underneath_p_dir_rel := _underneath_p_rel & dir_rel.
_underneath_p_state_rel := _underneath_p_rel & state_loc_rel.
_unless_x_rel := miscprep_rel.
_unlike_p_rel := miscprep_rel.
_until_p_rel := miscprep_rel.
_until+recently_p_rel := miscprep_rel.
_unto_p_rel := dir_rel.
_up_p_rel := dir_rel.
_uphill_p_rel := dir_rel.
_up+front_p_rel := miscprep_rel.
_up+to_p_rel := miscprep_rel.
_up+to+and+including_p_rel := miscprep_rel.
_up+until_p_rel := miscprep_rel.
_upon_p_rel := state_loc_rel.
_upstairs_p_rel := miscprep_rel.
_upstream_p_rel := dir_or_state_nontemp_rel.
_upstream_p_dir_rel := _upstream_p_rel & dir_rel.
_upstream_p_state_rel := _upstream_p_rel & state_loc_rel.
_upstream+of_p_rel := dir_or_state_nontemp_rel.
_upstream+of_p_dir_rel := _upstream+of_p_rel & dir_rel.
_upstream+of_p_state_rel := _upstream+of_p_rel & state_loc_rel.
_versus_p_rel := miscprep_rel.
_via_p_rel := miscprep_rel.
_vis-a-vis_p_rel := miscprep_rel.
_viz_p_rel := miscprep_rel.
_what+with_p_rel := miscprep_rel.
_whither_p_rel := dir_rel.
_whence_p_rel := dir_rel.
_while_x_rel := miscprep_rel.
_whilst_x_rel := miscprep_rel.
_with_p_rel := to_or_with_p_rel & state_loc_rel.
_within_p_rel := dir_or_state_nontemp_rel.
_within_p_dir_rel := _within_p_rel & dir_rel.
_within_p_state_rel := _within_p_rel & state_loc_rel.
_without_p_rel := miscprep_rel.
_with+respect+to_p_rel := miscprep_rel.
_worth_p_rel := miscprep_rel.

_anymore_a_1_rel := neg_polar_rel.
_as+of+yet_a_1_rel := neg_polar_rel.
_at+all_a_1_rel := neg_polar_rel.
_ever_a_1_rel := neg_polar_rel.
_nomore_a_1_rel := neg_polar_rel.
_or+what_a_1_rel := neg_polar_rel.

_please_x_rel := adv_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Determiner preds

_a+little_q_rel := explicit_noagr_nodef_q_rel.
_a+bit_q_rel := explicit_noagr_nodef_q_rel.
_a_q_rel := some_q_rel & def_udef_a_q_rel.
_such+a_q_rel := some_q_rel.
_what+a_q_rel := some_q_rel.
_many+a_q_rel := some_q_rel.
_another_q_rel := some_q_rel.
_any_q_rel := any_q_rel.
both_all_udef_q_rel := nodef_q_rel.
both_all_q_rel := both_all_udef_q_rel.
_both_q_rel := basic_def_explicit_q_rel & both_all_q_rel.
_each_q_rel := explicit_noagr_nodef_q_rel.
_either_q_rel := explicit_quant_agr_q_rel.
_enough_q_rel := explicit_quant_agr_q_rel.
_every_q_rel := every_q_rel.
; Temporary hack for "Kim sings twice a week"
_twice+a_q_rel := every_q_rel.
_half_q_rel := explicit_quant_agr_q_rel.
_less_q_rel := explicit_noagr_nodef_q_rel.
_little_q_rel := explicit_noagr_nodef_q_rel.
_more_q_than_rel := explicit_quant_agr_q_rel.
_most_q_rel := explicit_quant_agr_q_rel.
_neither_q_rel := explicit_noagr_nodef_q_rel.
_no_q_rel := no_q_rel.
_some_q_rel := some_q_rel.
_some_q_indiv_rel := some_q_rel.
_such_q_rel := explicit_q_rel.
_that_q_dem_rel := demon_far_q_rel.
_the+most_q_rel := explicit_quant_agr_q_rel.
_these_q_dem_rel := demon_near_q_rel.
_this_q_dem_rel := demon_near_q_rel.
_those_q_dem_rel := demon_far_q_rel.
_twice_q_rel := explicit_quant_agr_q_rel.
_umpteen_q_rel := explicit_noagr_nodef_q_rel.
_which_q_rel := which_q_rel.
_any+more_q_rel := explicit_quant_agr_q_rel.
_no+more_q_rel := explicit_quant_agr_q_rel.
_some+more_q_rel := explicit_quant_agr_q_rel.
_less+than+a_q_rel := some_q_rel.
_part_q_rel := explicit_noagr_nodef_q_rel.
_a+third_q_rel := explicit_quant_agr_q_rel.
_a+fourth_q_rel := explicit_quant_agr_q_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; sentence-force preds


iforce := predsort.
basic-comm := iforce.
prop-or-comm := iforce.
prop-or-ques := iforce.
prop-or-pol-ques := prop-or-ques.
prop-or-like := iforce.
basic-prop := prop-or-pol-ques & prop-or-like.
punct-prop-comm := iforce.
prop-comm := prop-or-comm & punct-prop-comm.
prop := basic-prop & prop-comm.
comm := basic-comm & prop-comm.

ques := prop-or-ques.
basic-wh-ques := ques.
basic-pol-ques := ques & prop-or-pol-ques.

punct-ques := ques.
pol-ques := basic-pol-ques & punct-ques.
wh-ques := basic-wh-ques & punct-ques.

; Subtype to distinguish complementizer "like" from "that", to block
; '*Kim said like Sandy left' and '*it looks that Sandy left"
like-iforce := prop-or-like.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; pred sorts

predsort := *sort*.

non_number_rel := predsort.
norm_non_num_rel := non_number_rel.
norm_or_no_rel := predsort.
norm_rel := norm_non_num_rel & norm_or_no_rel.
event_or_degree_or_no_rel := predsort.
non_conj_rel := predsort.
norm_non_conj_rel := non_conj_rel & norm_rel.
event_or_degree_rel := norm_non_conj_rel & event_or_degree_or_no_rel.
nonpro_or_event_rel := predsort.
event_rel := event_or_degree_rel & nonpro_or_event_rel.
; Needed to divide two types of head-specifier phrases
compos_spec_rel := predsort.

; Subtypes of this relation are the types for particle semantics in
; verb-particle constructions like _together_rel in "get together"
; DPF 15-Apr-01 - Removed ASPECT no_aspect, since want to let "of" be progr*
; to block e.g. "as of NP"

selected_rel := event_rel.
selected_adj_rel := selected_rel & abstr_adj_rel.
selected_adv_rel := selected_rel & basic_adv_rel.
selected_prep_rel := selected_rel & prep_rel.

independent_rel := predsort.
non_ellipt_rel := predsort.
non_event_rel := norm_non_conj_rel & non_ellipt_rel.
aux_or_ellipt_rel := event_rel.
aux_event_rel := aux_or_ellipt_rel & non_ellipt_rel.
aux_arg1_rel := aux_event_rel & v_event_rel.
nonaux_event_rel := non_ellipt_rel.
norm_non_ellipt_rel := non_ellipt_rel & norm_rel.
non_freerel_rel := independent_rel.
no_rel := non_freerel_rel & non_conj_rel & event_or_degree_or_no_rel &
          nonaux_event_rel & non_number_rel & quantity_or_no_rel &
	  norm_or_no_rel.
; Hack to prevent 'this/that' from being modified by non-wh rel clauses
; which it would do if this were instead a subtype of norm_rel.
deictic_sg_rel := norm_non_num_rel.

never_unify_rel := predsort.

; For appositives
appos-able_rel := predsort.
indef_or_udef_or_meas_rel := appos-able_rel.
def_or_meas_rel := predsort.

norm_dim_rel := norm_non_conj_rel.
basic_event_dim_rel := norm_dim_rel & event_rel.
non_event_dim_rel := non_event_rel & norm_dim_rel.
quant_or_deg_rel := non_event_dim_rel.
i_or_e_quant_or_deg_rel := quant_or_deg_rel.
quant_or_wh_rel := quant_or_deg_rel.
quant_rel := quant_or_wh_rel.
non_freerel_q_or_meas_rel := non_freerel_rel.
non_freerel_q_rel := non_freerel_q_or_meas_rel & quant_rel.
nodef_q_rel := quant_rel.
impl_or_expl_q_rel := non_freerel_q_rel & i_or_e_quant_or_deg_rel.
; Used in bare plurals
impl_or_proper_q_rel := nodef_q_rel.
; Used for superlative adjs
impl_or_the_q_rel := quant_rel.
; Used in appositive rule
implicit_q_rel := impl_or_proper_q_rel & def_or_udef_q_rel & impl_or_the_q_rel.
; Used for heads of appositive phrases
explicit_or_proper_q_rel := quant_or_wh_rel.
explicit_q_rel := impl_or_expl_q_rel & explicit_or_proper_q_rel.
; Determiners with these relations show agreement with of_PP in partitives
explicit_quant_agr_q_rel := explicit_nodef_q_rel.
; These don't
explicit_quant_or_udef_noagr_q_rel := impl_or_expl_q_rel.
explicit_quant_noagr_q_rel := explicit_q_rel & 
                              explicit_quant_or_udef_noagr_q_rel.
explicit_noagr_nodef_q_rel := explicit_quant_noagr_q_rel & nodef_q_rel.
explicit_nodef_q_rel := explicit_q_rel & nodef_q_rel.

; For '(exactly) three chairs'
num_q_rel := explicit_nodef_q_rel.

; DPF 19-Oct-02 - This is to allow not only ordinary bare plurals, but also
; "afternoons" which must be the one that takes an optional PP-of and
; usually requires a definite determiner (unless it's a bare plural)

; Used for underspecification in translation
def_udef_some_a_q_rel := quant_rel.
def_udef_a_q_rel := def_udef_some_a_q_rel.

abstr_def_or_udef_q_rel := quant_rel.
def_or_udef_q_rel := abstr_def_or_udef_q_rel & impl_or_expl_q_rel.
def_or_proper_q_rel := abstr_def_or_udef_q_rel & def_or_meas_rel.
udef_q_rel := implicit_q_rel & explicit_quant_or_udef_noagr_q_rel &
              indef_or_udef_or_meas_rel & both_all_udef_q_rel &
	      def_udef_a_q_rel.
some-any_q_rel := explicit_quant_agr_q_rel & def_udef_some_a_q_rel.
some_q_rel := some-any_q_rel & indef_or_udef_or_meas_rel.
any_q_rel := some-any_q_rel.
every_q_rel := explicit_nodef_q_rel.
no_q_rel := explicit_nodef_q_rel.
def_q_rel := def_or_udef_q_rel & def_or_meas_rel & def_udef_a_q_rel &
	     def_or_demon_q_rel.

def_implicit_q_rel := def_q_rel & implicit_q_rel.
basic_def_explicit_q_rel := def_q_rel & explicit_quant_noagr_q_rel &
                            def_or_proper_q_rel & appos-able_rel.
def_explicit_q_rel := basic_def_explicit_q_rel.
; Used only in MINORS.MIN
nondef_explicit_q_rel := explicit_q_rel & indef_or_udef_or_meas_rel &
			 nodef_q_rel.
; Used for n_det-mnth_dlr, to allow use of compositional head-spec rule, to allow
; "the January 11 meeting"
; DPF 31-jan-09 - But cannot use compos.head-spec rule for "January 11" since
; this wrongly makes the LBL of "11" the LTOP of the NP, so it would get bound
; both by the restrictor of the quantifier and as the LBL of the verb.
;
defmonth_q_rel := impl_or_proper_q_rel & basic_def_explicit_q_rel.

; Used by NP-N-cmpnd rule:
meas_np_or_proper_q_rel := explicit_or_proper_q_rel & nodef_q_rel.
; Used for lexical NPs including proper names
; It is distinct from i_or_e_quant_or_deg_rel to prevent relative clauses
; from attaching to proper names with no specifier.
num_or_proper_q_rel := non_freerel_q_rel & def_or_proper_q_rel & nodef_q_rel &
                       explicit_or_proper_q_rel & appos-able_rel.
proper_q_rel := num_or_proper_q_rel & impl_or_proper_q_rel.
number_q_rel := num_or_proper_q_rel & impl_or_proper_q_rel.
; For determiners that can appear e.g. with 'same' (also excluding 'both')
def_or_demon_q_rel := quant_rel.
pronoun_q_rel := non_freerel_q_rel & def_or_demon_q_rel.
demonstrative_q_rel := explicit_nodef_q_rel & def_or_proper_q_rel & 
                       def_or_demon_q_rel & appos-able_rel.
demon_near_q_rel := demonstrative_q_rel.
demon_far_q_rel := demonstrative_q_rel.
basic_free_relative_q_rel := explicit_noagr_nodef_q_rel.
free_relative_q_rel := basic_free_relative_q_rel.
free_relative_ever_q_rel := basic_free_relative_q_rel.
_the_q_rel := basic_def_explicit_q_rel & impl_or_the_q_rel & 
	      dofw_or_poss_or_def_q_rel.
which_q_rel := explicit_quant_agr_q_rel.
_all_q_rel := explicit_quant_agr_q_rel & both_all_q_rel.
_not+all_q_rel := explicit_quant_agr_q_rel & both_all_q_rel.
idiom_q_i_rel := implicit_q_rel.

dir_state_modable_rel := predsort.
modable_rel := basic_nom_rel & dir_state_modable_rel.
; nontemp_rel used to distinguish temporal nominal phrases from all others
nontemp_or_conj_rel := norm_rel.
nontemp_rel := nontemp_or_conj_rel.
instance_rel := independent_rel.
basic_nom_or_mnp_rel := compos_spec_rel.
basic_nom_rel := non_event_rel & instance_rel & basic_nom_or_mnp_rel.
nom_or_mnp_rel := basic_nom_or_mnp_rel.
nom_rel := basic_nom_rel & nom_or_mnp_rel.
nonpro_or_refl_or_num_rel := predsort.
nonpro_or_num_rel := nonpro_or_refl_or_num_rel.
basic_nonpro_rel := nom_rel & nonpro_or_num_rel.
; Exclude relative pronouns and deictics, which can not take possessive 's.
nonpro_rel := basic_nonpro_rel & nonpro_or_event_rel.
abstr_meas_nom_rel := nom_rel.
nom_nondim_rel := nom_rel.
non_temp_nom_rel := nom_nondim_rel & nontemp_rel.
basic_non_temp_nonpro_rel := non_temp_nom_rel & basic_nonpro_rel.
non_temp_nonpro_rel := basic_non_temp_nonpro_rel & nonpro_rel.
reg_nom_rel := non_temp_nonpro_rel & reg_or_temp_nom_rel.
modable_nom_rel := non_temp_nonpro_rel & modable_rel.
unspec_diadic_nom_rel := nonpro_rel & nom_nbar_rel.
reg_diadic_nom_rel := unspec_diadic_nom_rel & reg_nom_rel.
basic_diadic_modable_nom_rel := unspec_diadic_nom_rel & modable_rel.
diadic_modable_nom_rel := basic_diadic_modable_nom_rel & modable_nom_rel.
basic_hcomp_nom_rel := non_temp_nonpro_rel & gen_nom_nbar_rel.
hcomp_nom_rel := basic_hcomp_nom_rel & reg_nom_rel.
hcomp_modable_nom_rel := basic_hcomp_nom_rel & modable_rel.
nbar_or_nger_rel := nom_rel.
nbar_or_dofm_rel := nom_rel.
nominalize_rel := basic_hcomp_nom_rel & nbar_or_nger_rel.
gerund_rel := non_temp_nonpro_rel.
; For SEM-I
nominalization_rel := nom_rel.
; Ordinary nbars or numerals
nbar_or_num_rel := nom_rel.
; nom_rels for nouns that can undergo nbar-coordination (avoiding proper names)
gen_nom_nbar_rel := nbar_or_num_rel.
; nom_rels for nouns that can appear in noun_noun compounds (excluding e.g. 
; number-nouns)
nom_nbar_rel := gen_nom_nbar_rel & nbar_or_nger_rel & nbar_or_dofm_rel.
norm_nom_or_place_rel := nom_rel.
non_temp_nbar_rel := non_temp_nonpro_rel & nom_nbar_rel.
norm_nom_rel := reg_nom_rel & non_temp_nbar_rel & norm_nom_or_place_rel.
reg_or_temp_nom_rel := nom_rel.
temp_abstr_or_conj_rel := predsort.
temp_abstr_rel := nonpro_rel & temp_abstr_or_conj_rel.
temp_nondim_rel := temp_abstr_rel & gen_nom_nbar_rel & reg_or_temp_nom_rel.
; Used in NP-N-cmpnd rule, to include measure-NP phrases.
named_or_meas_rel := norm_rel.
; Used in munging rules to make reversible the implicit quantifier
abstr_named_rel := norm_rel.
gen_named_rel := abstr_named_rel.
named_np_or_num_rel := gen_named_rel & named_or_meas_rel.
abstr_named_np_rel := named_np_or_num_rel.
named_np_rel := abstr_named_np_rel & reg_nom_rel & norm_nom_or_place_rel.
		
named_num_or_seq_rel := nom_rel.
; DPF 03-may-04 ; Changed non_temp_nonpro_rel to nom_nocmpnd_rel, to prevent
; these from appearing in N-N-compounds
named_num_rel := named_np_or_num_rel & nom_nocmpnd_rel & nonpro_or_num_rel &
               named_num_or_seq_rel & norm_nom_or_place_rel & nbar_or_num_rel.
num_seq_nom_rel := named_num_or_seq_rel & non_temp_nom_rel & 
		   nonpro_or_num_rel & named_np_or_num_rel.
;named_card_rel := named_num_rel & card_rel.
named_times_rel := named_num_rel & times_rel.
named_plus_rel := named_num_rel & plus_rel.

integer_or_color_rel := compos_spec_rel & independent_mod_rel &
			event_arg_dim_rel.
color_rel := integer_or_color_rel & adj_rel.
elliptical_n_rel := diadic_nom_rel.
; Relation used in decomposed lexical semantics, e.g. for 'when'
temp_rel := abstr_named_rel & modable_rel & temp_abstr_rel.
day_rel := temp_nondim_rel & day_or_time_rel.
diadic_day_rel := day_rel & unspec_diadic_nom_rel & modable_rel.
named_day_rel := diadic_day_rel & abstr_named_np_rel.
; Needs to inherit from both since we get "on the first day" but "in my day"
unnamed_day_rel := diadic_day_rel & non_day_or_deg_rel & abstr_meas_nom_rel.
; DPF 10-Oct-02 - Need to allow measure-NPs to be complements of temporal "in",
; as in "I'll be finished in two chapters".
non_day_or_deg_rel := norm_rel.
non_day_rel := temp_nondim_rel & non_day_or_deg_rel & abstr_meas_nom_rel.
;; day_of_month_rel
; DPF 03-may-04 - Replaced diadic_day_rel with day_rel,modable_rel to prevent
; these from being nom_nbar_rel, so they won't appear in compounds, among
; other unwanted places
; DPF 04-mar-06 - Added dofm_or_mofy_rel to capture the possible modifiees
; of n_year_le.
dofm_or_mofy_rel := temp_nondim_rel.
dofm_rel := day_rel & modable_rel & gen_named_rel & nbar_or_dofm_rel &
            dofm_or_mofy_rel.


;; Need supertype of dofw_rel and poss_rel and non-'the' quantifiers
;; for the specifier of the small class of words like "morning" as in "my 
;; mornings" or "Tuesday mornings"

dofw_or_poss_or_def_q_rel := norm_rel.
dofw_or_poss_q_rel := dofw_or_poss_or_def_q_rel.
;; day_of_week_rel
dofw_rel := named_day_rel & dofw_or_poss_q_rel.
holiday_rel := named_day_rel & hour_or_time_rel.
day_part_rel := diadic_day_rel.
; dim_rel: 'almost three o'clock'
; DPF 2-Apr-02 - Added type for hour_rel and _time_rel, to get both "at three"
; and 'at that time" while distinguishing "kim fell three times" from "*Kim
; fell three o'clock".  Also include seasons, since 'at' uses this sort.
day_or_time_rel := predsort.
hour_or_time_rel := day_or_time_rel.
hour_rel := temp_abstr_rel & hour_or_time_rel & nom_nbar_rel.
_breakfast_n_time_rel := hour_rel.
_dinner_n_time_rel := hour_rel.
_lunch_n_time_rel := hour_rel.
_supper_n_time_rel := hour_rel.
_tea_n_time_rel := hour_rel.
_night_n_time_rel := hour_rel.
_minute_n_1_rel := hour_rel & non_day_diadic_modable_rel.
; a quarter till three  ("till" is head - cf "come at a quarter till.")
hour_prep_rel := hour_rel.
gen_hour_rel := hour_rel.
; prep_rels that can modify hour times as in "ten minutes after five"
minute_prep_sel_rel := selected_prep_rel.

basic_numbered_hour_rel := hour_rel & abstr_named_rel.
numbered_hour_rel := basic_numbered_hour_rel.
numbered_hour_unk_rel := basic_numbered_hour_rel & generic_unk_rel.

; DPF 31-Jul-99 - Changed minute_or_ampm_rel to be non-temp, since it cannot
; appear after temporal prepositions (ignoring the elliptical "I'll see you 
; in ten"), and we also need to block "from ten to eleven o'clock" with
; "ten" as minute.
minute_or_ampm_rel := nom_nondim_rel.

;modable_hour_rel := non_day_diadic_modable_rel.
;modable_hour_or_time_rel := modable_hour_rel & hour_or_time_rel.

am_pm_rel := minute_or_ampm_rel.
bc_ad_rel := nom_nondim_rel.

ctime_rel := numbered_hour_rel.

; 'the morning', not 'some morning': 'in the morning' but 'on some morning'
def_day_part_rel := non_day_diadic_modable_rel.
_afternoon_n_def_rel := def_day_part_rel.
_evening_n_def_rel := def_day_part_rel.
_morning_n_def_rel := def_day_part_rel.
_night_n_def_rel := def_day_part_rel.
_weekend_n_def_rel := def_day_part_rel.

non_day_diadic_rel := non_day_rel & unspec_diadic_nom_rel.
non_day_modable_rel := non_day_rel & modable_rel & nom_nbar_rel.

non_day_diadic_modable_rel := non_day_diadic_rel & modable_rel.
non_day_time_rel := non_day_diadic_rel & modable_rel & hour_or_time_rel.
; "while"
;non_day_nonmodable_rel := non_day_rel & meas_nom_rel.
; mealtimes - disallow relative clause modification
mealtime_rel := hour_or_time_rel.
;; named_month_rel as in "January is fine"
;; DPF 13-Mar-02 - Changed parent non_day_diadic_modable_rel to 
;; non_day_diadic_rel since we were overgenerating: "*Kim arrived June" in 
;; order to admit "Kim arrived last June".  Have to do something else to
;; allow the latter.
;; DPF 04-sep-09 - Changed back, since we want "last June", and can block
;; just "June" as NPadv via MODIFD value
mofy_rel := non_day_diadic_modable_rel & abstr_named_np_rel & dofm_or_mofy_rel.

; basic_yofc_rel := non_day_rel & abstr_named_np_rel & named_or_meas_rel.
basic_yofc_rel := non_day_rel & abstr_named_np_rel.
yofc_rel := basic_yofc_rel.
yofc_unk_rel := basic_yofc_rel & generic_unk_rel.

season_rel := non_day_modable_rel & gen_named_rel.
season_nomod_rel := day_rel & gen_named_rel & hour_or_time_rel.

;age_rel := non_day_nonmodable_rel.
age_rel := non_day_rel.
year_n_rel := non_day_diadic_modable_rel.

_morning_n_1_rel := day_part_rel.
_afternoon_n_1_rel := day_part_rel.
_evening_n_1_rel := day_part_rel.
_night_n_1_rel := day_part_rel.
_weekend_n_1_rel := day_part_rel.
_noon_n_1_rel := day_part_rel.
_day_n_of_rel := day_rel.

_week_n_1_rel := non_day_diadic_modable_rel.
_month_n_1_rel := non_day_diadic_modable_rel.
_quarter_n_temp_rel := non_day_diadic_modable_rel.

duration_rel := temp_rel.

named_rel := named_np_rel.
; For guessed (unknown) proper names
named_unk_rel := named_np_rel & generic_unk_rel.
named_city_rel := named_np_rel.
named_abb_rel := named_np_rel.
named_n_rel := gen_named_rel & reg_nom_rel.


gen_numval_rel := non_temp_nonpro_rel & nom_nbar_rel.

; For classifier nouns like "piece" or "pair"
quantum_n_of_rel := reg_nom_rel.
_pair_n_of-i_rel := quantum_n_of_rel.
_piece_n_of-i_rel := quantum_n_of_rel.

; For X to Y constructions

basic_interval_rel := unspec_diadic_nom_rel & abstr_named_rel.
; named_num_or_seq_rel for |items 1 - 3|
interval_rel := basic_interval_rel & named_num_or_seq_rel.
; For "to" of "May 23 to 25"
interval_modable_rel := basic_interval_rel & modable_nom_rel.

; For determinerless-PP nouns ('within range')
bare_nom_rel := non_temp_nonpro_rel.
; Disallow adjective modifiers ('at eye level' but '*at high level')
bare_n_nmod_rel := bare_nom_rel & nbar_or_nger_rel.
; Disallow noun-noun compounding ('at close range' but '*at cellphone range')
bare_n_jmod_rel := bare_nom_rel.
; Disallow any modification ('on top' 'of course')
bare_n_nomod_rel := bare_nom_rel.

n-ed_rel := non_temp_nbar_rel & reg_or_temp_nom_rel.

mnp_symb_rel := abstr_meas_nom_rel & nonpro_rel.

; For 'it is a pleasure to visit abrams.' and 'Abrams is a pleasure to visit.'
prednom_rel := nonpro_rel.
pred_a_rel := independent_rel.

;; The relation event_or_mod_rel is designed to distinguish non-nominal signs, 
;; including verbs, adjectives, prepositions, and adverbs.  One use of this 
;; distinction is for the conjuncts accepted by "but": "*Kim but Sandy left."

event_or_mod_rel := predsort.

mod_rel := event_or_mod_rel.

event_mod_rel := event_rel & mod_rel.
event_arg_dim_rel := event_mod_rel & basic_event_dim_rel.
event_dim_rel := basic_event_dim_rel & nonaux_event_rel.
independent_mod_rel := independent_rel & mod_rel.
abstr_excl_rel := independent_mod_rel.

greet_rel := abstr_excl_rel.
excl_rel := abstr_excl_rel.
polite_rel := excl_rel.

; For distinguishing passive from active VPs, needed for complement of "as"
;
passive_rel := event_dim_rel.
nonpass_rel := event_dim_rel.

; For adjectival pro-forms like "the last", and derived number-nouns, neither
; of which appear in N-N-compounds
nom_nocmpnd_rel := non_temp_nom_rel.
num_nocmpnd_rel := nom_nocmpnd_rel & nonpro_rel & part_nom_rel.
_one_n_1_rel := nom_nocmpnd_rel & nonpro_rel & gen_nom_nbar_rel.

basic_pron_rel := non_temp_nom_rel & abstr_named_rel.
pron_rel := basic_pron_rel.
; For partitives
pron_part_rel := basic_pron_rel.
; For WH and REL "who, whom" which can appear as second complement of "give"
; even though ordinary pronouns cannot, but which like other pronouns cannot
; appear as specifier of possessive 's: "*who's".
pron_nonlocal_rel := basic_pron_rel & nonpro_or_refl_or_num_rel.

refl_pron_rel := non_temp_nom_rel & nonpro_or_refl_or_num_rel.
recip_pro_rel := basic_non_temp_nonpro_rel.
generic_nom_rel := basic_non_temp_nonpro_rel.
generic_entity_rel := non_temp_nonpro_rel.

generic_unk_nom_rel := non_temp_nonpro_rel & generic_unk_rel.

basic_adj_rel := event_dim_rel & nontemp_rel & compos_spec_rel.
abstr_adj_rel := basic_adj_rel & event_arg_dim_rel.
adj_rel := abstr_adj_rel & independent_mod_rel.
norm_adj_rel := adj_rel.
expl_adj_rel := basic_adj_rel & independent_rel.
it_adj_rel := abstr_adj_rel & independent_rel.
const_or_meas_rel := predsort.
meas_adj_rel := abstr_adj_rel & const_or_meas_rel.
adj_personal_rel := adj_rel.
adj_abstract_rel := adj_rel.
generic_unk_adj_rel := adj_rel & generic_unk_rel.

verb_or_subord_rel := independent_rel & event_rel.
verb_aspect_rel := verb_or_subord_rel.

prog_rel := verb_aspect_rel.

v_event_rel := verb_aspect_rel & event_arg_dim_rel.

mod_role_rel := v_event_rel.
nonaux_v_rel := mod_role_rel & nonaux_event_rel.

no_role_rel := mod_role_rel. 
it_subj_nonaux_rel := no_role_rel & nonaux_v_rel.
weather_v_rel := it_subj_nonaux_rel.

role_rel := nontemp_rel & nonaux_v_rel.

; To support underspecification of can/able especially for future tense
; where 'able' is required.
;
can_able_rel := predsort.

modal_rel := aux_arg1_rel.
_can_v_modal_rel := modal_rel & can_able_rel.
_could_v_modal_rel := modal_rel.
_dare_v_modal_rel := modal_rel.
_may_v_modal_rel := modal_rel.
_might_v_modal_rel := modal_rel.
_must_v_modal_rel := modal_rel.
_need_v_modal_rel := modal_rel.
_ought_v_modal_rel := modal_rel.
_shall_v_modal_rel := modal_rel.
_should_v_modal_rel := modal_rel.
_used+to_v_modal_rel := nonaux_v_rel.
_had+better_v_modal_rel := modal_rel.
_would_v_modal_rel := modal_rel.
ellipsis_rel := v_event_rel & aux_or_ellipt_rel.
ellipsis_ref_rel := ellipsis_rel.
ellipsis_expl_rel := ellipsis_rel.
; Used to ensure tag question agreement, but will not appear in RELS.
have_aux_rel := aux_arg1_rel.
; For infinitival relatives and purposive-to constructions: 'Kim is to stay'
expected_event_v_rel := v_event_rel.

; Needed to allow filtering of the relations for "will" and "would" for VIT.
will_modal_rel := aux_arg1_rel.
_will_v_aux_rel := will_modal_rel.
_going+to_v_modal_rel := will_modal_rel.
would_like_rel := predsort.
; Used in "how about" words:
generic_verb_rel := event_dim_rel.

; PRED for generic entry for unknown verbs.
generic_unk_verb_rel := event_dim_rel & generic_unk_rel.

; Support for can/able undespecification
_able_a_1_rel := adj_rel & can_able_rel.

prep_rel := event_dim_rel.
basic_prep_mod_rel := prep_rel & event_arg_dim_rel & independent_rel.
prep_mod_rel := basic_prep_mod_rel.
nontemp_prep_rel := prep_mod_rel & nontemp_rel.
poss_rel := of_p_rel & dofw_or_poss_q_rel.
loc_abstr_rel := prep_mod_rel.
dir_or_state_rel := loc_abstr_rel & dir_state_modable_rel.
dir_or_state_nontemp_rel := dir_or_state_rel & nontemp_prep_rel.
dir_rel := dir_or_state_nontemp_rel & dir_or_unsp_loc_rel.
misc_or_state_loc_rel := prep_mod_rel.
state_loc_rel := dir_or_state_nontemp_rel & misc_or_state_loc_rel.
generic_loc_rel := loc_abstr_rel.

temp_loc_rel := independent_mod_rel & state_loc_rel.

miscprep_rel := nontemp_prep_rel & misc_or_state_loc_rel.

part_nom_rel := predsort.
part_of_rel := reg_diadic_nom_rel & part_nom_rel.
part_nc_rel := reg_nom_rel & nom_nbar_rel & part_nom_rel.

diadic_nom_rel := reg_diadic_nom_rel & norm_nom_rel.

loc_rel := dir_or_state_rel.

dir_or_unsp_loc_rel := prep_mod_rel.
unspec_loc_or_mod_rel := prep_rel.

; Either specific 'in, on, at' or loc_nonsp_rel, whether temporal nor not
; Note this type is the supertype for loc_sp_rel and loc_nonsp_rel, so
; beware of potential for name confusion
;
unspec_loc_rel := loc_rel & dir_or_unsp_loc_rel & independent_mod_rel & 
		  unspec_loc_or_mod_rel.

temp_sp_or_nonsp_rel := temp_loc_rel.

; Used for implicit locative, as in "Kim arrived Tuesday" or "Kim is here"
loc_nonsp_rel := unspec_loc_rel.
nontemp_loc_nonsp_rel := loc_nonsp_rel & nontemp_sp_or_nonsp_rel &
			 dir_or_state_nontemp_rel.
temp_loc_nonsp_rel := loc_nonsp_rel & temp_sp_or_nonsp_rel.

; For specific locatives whether temporal or not
loc_sp_rel := unspec_loc_rel.
; For specific temporal locatives 'in, on, at'
temp_loc_sp_rel := temp_sp_or_nonsp_rel & loc_sp_rel.
; Decomposed rel for e.g. free relative "when"
temp_loc_x_rel := temp_loc_rel.

; Specific nontemporal locatives 'in, on, at', potentially useful for
; underspecified generator input.
nontemp_sp_or_nonsp_rel := loc_rel & nontemp_prep_rel.
nontemp_loc_sp_rel := dir_or_state_nontemp_rel & nontemp_sp_or_nonsp_rel & 
		      loc_sp_rel.

interval_p_start_rel := miscprep_rel.
interval_p_end_rel := miscprep_rel.
; For |5-10 ft. tall|
interval_meas_rel := interval_p_end_rel & const_or_meas_rel.

; For time zones like "PDT"
timezone_p_rel := temp_loc_rel.

; for 'talk to/with X (about Y)', 'speak' etc
to_or_with_p_rel := dir_or_state_nontemp_rel.

; For "how"
unspec_manner_rel := miscprep_rel.

basic_adv_rel := non_event_rel & nontemp_rel & event_or_degree_rel &
		 nonpro_or_event_rel.
abstr_adv_rel := basic_adv_rel & independent_mod_rel.

abstr_adv_dim_rel := abstr_adv_rel & non_event_dim_rel.

adv_rel := abstr_adv_dim_rel.

neg_rel := abstr_adv_rel.
generic_unk_adv_rel := abstr_adv_rel & generic_unk_rel.

neg_polar_rel := abstr_adv_dim_rel.
long_r_rel := abstr_adv_dim_rel.

degree_rel := compos_spec_rel & independent_rel & event_or_degree_rel
             & i_or_e_quant_or_deg_rel & non_day_or_deg_rel.
comp_degree_rel := degree_rel.
non_comp_degree_rel := degree_rel.

; For the subset of specifiers needed for adjectives (but not, e.g., subconj)
; DPF 07-may-04 - Added non_temp_nom_rel to allow MNPs as complements of
; e.g. 'under' which wants non-temporal NP.  Also blocks spurious parse for
; "kim sings in ten minutes"
; DPF 14-nov-05 - But this means degree_rels unify with nom_rels - undesirable.
; So try alternate approach to e.g. 'Kim hid under five feet of snow'

much_or_very_deg_rel := degree_rel & nonpro_or_num_rel.
more_or_very_deg_rel := degree_rel.
much_or_more_deg_rel := degree_rel.

; For specifiers of adjectives
deg_rel := non_comp_degree_rel.

very_this_that_rel := deg_rel & much_or_very_deg_rel & more_or_very_deg_rel.
; For specifiers of positive adjectives
very_deg_rel := very_this_that_rel & ord_or_very_rel.

; For degree specifiers "this/that/too/as" as in "that much", "so tall"
this_that_deg_rel := very_this_that_rel.

; For 'more" with positive adjectives
more_deg_rel := more_or_very_deg_rel & just_only_notvery_deg_rel &
		much_or_more_deg_rel.

; For as..as, too..to
comp_as_too_enough_rel := comp_more_less_rel.
comp_as_too_degree_rel := this_that_deg_rel & comp_as_too_enough_rel.
comp_more_degree_rel := much_deg_rel & comp_more_less_rel.
enough_deg_rel := comp_as_too_enough_rel.

; For specifiers of superlatives: "very tallest", "next tallest"
sup_deg_rel := very_deg_rel.

; For specifiers of "the", including "only" and "just"
just_only_degree_rel := degree_rel.
; 'exactly in the center'
just_only_very_deg_rel := just_only_degree_rel & very_deg_rel.
just_only_notvery_deg_rel := just_only_degree_rel.
; 'far into the park'
just_only_much_deg_rel := just_only_notvery_deg_rel & much_deg_rel.
just_only_deg_rel := just_only_notvery_deg_rel & deg_rel.

; For "how" degree specifier
abstr_deg_rel := this_that_deg_rel.

; For specifiers of comparative adjectives
much_deg_rel := deg_rel & much_or_very_deg_rel & card_or_much_rel &
		much_or_more_deg_rel.
; To constrain adjectives to only take "much", as with modifiee of "than Sandy"
much_deg_only_rel := much_deg_rel.

; For specifiers of superlatives: "very tallest" "second tallest"
ord_or_very_rel := degree_rel.

; For specifiers of comparatives: "twenty more"
card_or_much_rel := degree_rel.

; For conjoined spr-less adjectives as in "sunny and cooler"
; DPF 5-Sep-03 - But this eliminates the blocking of inappropriate degree specs
; for head that want only one or the other.
;;very_and_much_deg_rel := very_deg_rel & much_deg_rel.

; For e.g. 'eightish'
approx_grad_rel := deg_rel.

; For syntactic rules (for indexing for generation)
gen_deg_rel := deg_rel.
comparative_rel := comp_degree_rel.
comp_more_less_rel := comparative_rel.
_more_x_comp_rel := comp_more_less_rel.
_less_x_comp_rel := comp_more_less_rel.
comp_most_least_rel := comparative_rel.
_most_x_comp_rel := comp_most_least_rel.
_least_x_comp_rel := comp_most_least_rel.

; For measure-NPs and other degree specifiers: 'how tall'
measure_rel := non_comp_degree_rel.

;; For "how" adjective, which quantifies over properties.
property_rel := reg_nom_rel.
prpstn_to_prop_rel := event_rel.
comp_or_superl_rel := miscprep_rel.
comp_rel := comp_or_superl_rel & abstr_meas_nom_rel.
superl_rel := comp_or_superl_rel.
comp_less_rel := miscprep_rel.
comp_equal_rel := miscprep_rel.
comp_so_rel := miscprep_rel.
comp_deg_rel := miscprep_rel.
comp_too_rel := comp_deg_rel.
comp_enough_rel := comp_deg_rel.
difference_rel := miscprep_rel.
all+too_rel := comp_deg_rel.

; Abstract prep relations
; Needed for idiosyncratic decomposition of "why"
cause := miscprep_rel.
; For identity, as with pronoun in tag questions.
id_rel := predsort.
; For tag questions: notionally, "isn't it the case that ..."
ne_x_rel := predsort.

; Added event_or_degree_or_no_rel to enable coordination of these guys
subord_rel := verb_or_subord_rel.
cop_id_rel := v_event_rel.
_be_v_id_rel := cop_id_rel.
_be_v_nv_rel := cop_id_rel.
;;title_id_rel := cop_id_rel.
person_name_rel := cop_id_rel.
_colon_v_id_rel := cop_id_rel.
unspec_adj_rel := adj_rel.
; To restrict heads in appositives
quantity_or_no_rel := predsort.
quantity_rel := reg_diadic_nom_rel & quantity_or_no_rel.
prednom_state_rel := reg_diadic_nom_rel.
defequal_v_rel := v_event_rel.

be_v_there-or-prd_rel := aux_event_rel.
be_v_prd_rel := v_event_rel & be_v_there-or-prd_rel.
; Allow unification of KEYREL preds for predicative-cop with both id-cop and
; there-cop, in order to get tag question (which requires match on MIN)
; using only pred-cop in tags: "Everyone is Sara, aren't they?", and
; "There is a solution, isn't there?"
be_v_id_rel := cop_id_rel.
be_v_nv_rel := cop_id_rel.
be_v_there_rel := aux_arg1_rel & be_v_there-or-prd_rel.
be_v_prd-or-id_rel := be_v_prd_rel & be_v_id_rel.
be_v_prd-or-nv_rel := be_v_prd_rel & be_v_nv_rel.
be_v_it_rel := aux_arg1_rel.
;; DPF 19-feb-10 - This type was used as a hack for tag questions with
;; there-copula to avoid ambiguity for "There is."  But we abandon this hack
;; since we want to distinguish be_v_prd from other auxiliaries, e.g. for
;; constraining applicability of vmod rule.
;; be_v_prd-or-there_rel := be_v_prd_rel & be_v_there_rel.

unk_n_rel := norm_nom_rel & generic_unk_rel.
gen_currency_rel := reg_nom_rel.

; To distinguish class of nouns that can serve as measure-NP PP-specifiers
meas_nom_rel := reg_nom_rel & nom_nbar_rel & abstr_meas_nom_rel & 
                indef_or_udef_or_meas_rel & non_freerel_q_or_meas_rel &
                def_or_meas_rel & named_or_meas_rel.

; To support underspecification of compounds vs PPs in generation
compound_or_prep_rel := predsort.

unspec_rel := prep_rel.
compound_rel := unspec_rel & compound_or_prep_rel.
argument_rel := unspec_rel.
appos_rel := unspec_rel.
compound_name_rel := compound_rel.
; For 'the term "whippletree"'
term_rel := compound_rel.

parenthetical_rel := unspec_rel.
; For n-ed as in "wide-eyed"
unspec_mod_rel := unspec_rel & unspec_loc_or_mod_rel.
; For reflexive pro modification: 'you yourself' 'do it yourself'
refl_mod_rel := miscprep_rel.

; For instrumental relative clauses
with_p_rel := miscprep_rel.

; Relation introduced for tag questions
probable_rel := adj_rel.

; For comparative "as possible" (hack)
possible_rel := adj_rel.

; For how_about entries
how+about_r_rel := verb_or_subord_rel.

basic_conj_rel := non_freerel_rel & nontemp_or_conj_rel & 
            temp_abstr_or_conj_rel.
conj_rel := basic_conj_rel.
implicit_conj_rel := conj_rel.
_and_c_rel := conj_rel.
_and+also_c_rel := conj_rel.
_and+so_c_rel := conj_rel.
_and+then_c_rel := conj_rel.
_and+finally_c_rel := conj_rel.
_and+not_c_rel := conj_rel.
_and+thus_c_rel := conj_rel.
_and+yet_c_rel := conj_rel.
_after_c_rel := conj_rel.
_as+well+as_c_rel := conj_rel.
_but_c_rel := conj_rel.
_but+also_c_rel := conj_rel.
_but+not_c_rel := conj_rel.
_but+then_c_rel := conj_rel.
_if+not_c_rel := conj_rel.
_instead+of_c_rel := conj_rel.
_let+alone_c_rel := conj_rel.
_much+less_c_rel := conj_rel.
_minus_c_rel := conj_rel.
_nor_c_rel := conj_rel.
_or_c_rel := conj_rel.
_or+else_c_rel := conj_rel.
_plus_c_rel := conj_rel.
_plus-minus_c_rel := conj_rel.
_rather+than_c_rel := conj_rel.
_then_c_rel := conj_rel.
_though_c_rel := conj_rel.
_so_c_rel := conj_rel.
_versus_c_rel := conj_rel.
_except+that_c_rel := conj_rel.
_except_c_rel := conj_rel.
_not_c_rel := conj_rel.
_et+al_c_rel := conj_rel.
_etc_c_rel := conj_rel.
_so+on_c_rel := conj_rel.
_vice+versa_c_rel := conj_rel.
_to+name+a+few_c_rel := conj_rel.
_not+to+mention_c_rel := conj_rel.
_together-with_c_rel := conj_rel.
_yet_c_rel := conj_rel.
_even_c_rel := conj_rel.
_albeit_c_rel := conj_rel.

; For fragments
discourse_rel := conj_rel. 
; For number sequences
num_seq_rel := conj_rel.
; For foreign/funny word sequences
fw_seq_rel := conj_rel.

abstr_place_rel := unspec_diadic_nom_rel & non_temp_nonpro_rel &
                   norm_nom_or_place_rel & reg_or_temp_nom_rel.
basic_place_n_rel := abstr_place_rel & abstr_named_rel.
place_n_rel :=  basic_place_n_rel & modable_rel.
_place_n_1_rel := basic_place_n_rel.

time_n_rel := modable_rel & temp_abstr_rel & independent_mod_rel.
_time_n_1_rel := time_n_rel.
_awhile_n_1_rel := time_n_rel.
person_rel := norm_nom_rel.
thing_rel := norm_nom_rel.
manner_rel := norm_nom_rel.
reason_rel := norm_nom_rel.
title_rel := basic_nom_rel.
pre_title_rel := reg_or_temp_nom_rel.
addressee_rel := basic_nom_rel.

_be_v_there_rel := aux_arg1_rel.
_be_v_itcleft_rel := aux_arg1_rel.
_gotta_v_modal_rel := modal_rel.
_got_v_to_rel := aux_arg1_rel.
lex_imp_rel := nonaux_event_rel.
_have_v_to_rel := modal_rel.

; Want these to undergo the adj-coord rule
integer_rel := integer_or_color_rel.
const_rel := integer_rel & gen_named_rel & const_or_meas_rel.
plus_rel := integer_rel.
times_rel := integer_rel.
basic_ord_rel := const_rel & ord_or_very_rel.
ord_rel := basic_ord_rel.
ord_unk_rel := basic_ord_rel & generic_unk_rel.

basic_card_rel := const_rel & card_or_much_rel.
card_rel := basic_card_rel.
card_unk_rel := basic_card_rel & generic_unk_rel.
card_of_rel := card_rel.

; DPF 23-May-03 - minute_n_rel is never in a predicative adjective lexeme, so
; we can identify its ARG0 with its ARG1, to allow ordinary cardinal adjectives
; to specialize to minute semantics and let hour-words get the ARG0 index of
; the minute_rel by asking for the lexeme's HOOK.INDEX which is reentrant with
; ARG1 like ordinary adjectives.
minute_rel := card_rel.
range_num_rel := const_rel.
fraction_rel := const_rel.

unknown_rel := v_event_rel.

; Predicate supertype for generic unknown lexical entries
generic_unk_rel := predsort.

; For QUE-word complements as in "what the hell"
wh_the_hell_rel := predsort.
_the+heck_x_rel := wh_the_hell_rel.
_the+hell_x_rel := wh_the_hell_rel.
_the+fuck_x_rel := wh_the_hell_rel.
_on+earth_x_rel := wh_the_hell_rel.
_oh+where_x_rel := wh_the_hell_rel.
_in+the+world_x_rel := wh_the_hell_rel.
_exactly_x_rel := wh_the_hell_rel.
_else_x_rel := wh_the_hell_rel.

punct_rel := predsort.
paren_rel := punct_rel.
hyphen_rel := punct_rel.
dbl_hyphen_rel := punct_rel.

idiom_expr := sign &
  [ IDIOM + ].

v_nbar_idiom := idiom_expr &
  [ SYNSEM.LOCAL.CONT.RELS <! [ LBL handle,
                                ARG0 event,
                                ARG1 ref-ind,
                                ARG2 ref-ind & #arg2 ],
                              [ LBL handle,
                                ARG0 #arg2 ] !> ].

v_nbar_pp_idiom := idiom_expr &
  [ SYNSEM.LOCAL.CONT.RELS <! [ LBL handle,
                                ARG0 event,
                                ARG1 ref-ind,
                                ARG2 ref-ind & #arg2,
                                ARG3 ref-ind & #arg3 ],
                              [ LBL handle,
                                ARG0 #arg2 ],
                              [ LBL handle,
                                ARG0 #arg3 ] !> ].


; Punctuation marks

punctuation_min := *avm*.

punctuation_min1 := punctuation_min &
 [ PNCTPR pnctpair ].

; DPF 06-sep-07 - Added RCLSTR to record presence of right-half members of
; paired punctuation like parentheses.  Needed independent of RPUNCT since
; these left-right pairs co-occur with commas, periods, etc.  Also needed
; independent of PNCTPR/PAIRED since these features are concerned with
; matching up non-local requirements of RPUNCT on two distinct signs, as
; with matching commas for appositives.  For now, only record right paren,
; since this is needed to constrain the "floating" rules for parenthesized
; sentences and nominals, as in "Kim (my cousin is a doctor) arrived").
;
punctuation := punctuation_min1 &
  [ LPUNCT basic_punct_mark,
    RPUNCT basic_punct_mark,
    PAIRED pnctpair,
    RCLSTR rpunct_cluster ].

rpunct_cluster := *avm* &
  [ RPAREN bool,
    RFP bool ].

no_punctuation_min := punctuation_min1.
no_punctuation := punctuation & no_punctuation_min &
  [ LPUNCT no_punct,
    RPUNCT no_punct,
    PNCTPR ppair,
    RCLSTR [ RPAREN -,
	     RFP - ] ].

basic_punct_mark := *avm* &
  [ PSF iforce ].

clause_or_semicol_or_no_punct := basic_punct_mark.
clause_or_semicol := clause_or_semicol_or_no_punct.
comma_or_clause_or_pair_or_no_punct := basic_punct_mark.
comma_or_rbc_or_clause_or_no_punct := basic_punct_mark.
clause_or_pair_or_no_punct := comma_or_clause_or_pair_or_no_punct.
clause_or_no_punct := clause_or_semicol_or_no_punct & 
                      clause_or_pair_or_no_punct &
		      quote_or_hyphen_or_clause_or_no_punct.
comma_or_clause_or_pair_punct := comma_or_clause_or_pair_or_no_punct &
                                 hyphen_or_comma_or_pair_or_clause.
comma_or_clause_or_no_punct := comma_or_clause_or_pair_or_no_punct &
                               comma_or_rbc_or_clause_or_no_punct.
comma_or_rbc_or_hyphen_or_pair_or_no_punct := basic_punct_mark.
comma_or_rbc_or_colon_or_pair_or_no_punct := basic_punct_mark.
comma_or_hyphen_or_pair_or_no_punct := comma_or_rbc_or_hyphen_or_pair_or_no_punct.
rbc_or_hyphen_or_pair_or_no_punct := comma_or_rbc_or_hyphen_or_pair_or_no_punct.
hyphen_or_pair_or_no_punct := comma_or_hyphen_or_pair_or_no_punct &
                              rbc_or_hyphen_or_pair_or_no_punct.
comma_or_rbc_or_pair_or_no_punct := comma_or_rbc_or_hyphen_or_pair_or_no_punct
                                   & comma_or_rbc_or_colon_or_pair_or_no_punct.
comma_or_rbc_or_no_punct := comma_or_rbc_or_pair_or_no_punct &
                            comma_or_rbc_or_clause_or_no_punct.
comma_or_pair_or_no_punct := comma_or_hyphen_or_pair_or_no_punct &
                             comma_or_rbc_or_pair_or_no_punct &
                             comma_or_clause_or_pair_or_no_punct.
rbc_or_pair_or_no_punct := comma_or_rbc_or_pair_or_no_punct &
                           comma_or_hyphen_or_pair_or_no_punct &
                           rbc_or_hyphen_or_pair_or_no_punct.
rbc_or_no_punct := rbc_or_pair_or_no_punct & hyphen_sgl_or_rbc_or_no_punct.

hyphen_sgl_or_clause_or_no_punct := basic_punct_mark.
hyphen_dbl_or_clause_or_no_punct := basic_punct_mark.
hyphen_sgl_or_rbc_or_no_punct := basic_punct_mark.
3dots_or_clause_or_no_punct := basic_punct_mark.
comma_or_no_punct := comma_or_clause_or_no_punct & comma_or_pair_or_no_punct &
                     comma_or_rbc_or_no_punct.
comma_or_rbc_punct := comma_or_rbc_or_no_punct.
hyphen_sgl_or_no_punct := hyphen_sgl_or_clause_or_no_punct &
			  hyphen_sgl_or_rbc_or_no_punct &
			  hyphen_or_pair_or_no_punct.
hyphen_dbl_or_no_punct := hyphen_dbl_or_clause_or_no_punct &
                          hyphen_or_pair_or_no_punct.
3dots_or_no_punct := 3dots_or_clause_or_no_punct.
pair_or_no_punct := comma_or_pair_or_no_punct & hyphen_or_pair_or_no_punct
                    & clause_or_pair_or_no_punct & rbc_or_pair_or_no_punct.
lital_or_no_punct := basic_punct_mark.
no_punct := clause_or_no_punct & comma_or_no_punct & hyphen_sgl_or_no_punct &
            hyphen_dbl_or_no_punct & 3dots_or_no_punct & pair_or_no_punct &
            lparen_or_no_punct & rbc_or_no_punct & dq_or_no_punct &
	    lital_or_no_punct.

pnctpair := *sort*.
no_ppair := pnctpair.
ppair := pnctpair.

punct_mark := basic_punct_mark.

hyphen_or_comma_or_pair_or_clause := punct_mark.
hyphen_or_comma_or_clause := hyphen_or_comma_or_pair_or_clause.
hyphen_sgl_or_clause := punct_mark.
hyphen_sgl_or_dbl := punct_mark.
hyphen_sgl := hyphen_sgl_or_clause & hyphen_sgl_or_no_punct &
              hyphen_or_comma_or_clause & pair_or_no_punct & 
              comma_or_pair_punct &
	      quote_or_hyphen_or_no_punct &
	      comma_or_rbc_or_clause_or_no_punct & hyphen_sgl_or_dbl.

rparen_or_clause_punct := basic_punct_mark.
hyphen_dbl_or_clause := punct_mark.
comma_or_clause := comma_or_clause_or_no_punct & hyphen_or_comma_or_clause &
                   comma_or_clause_or_pair_punct.
comma_or_pair_punct := comma_or_pair_or_no_punct & 
                       comma_or_clause_or_pair_punct.
comma_punct := comma_or_clause & comma_or_no_punct & comma_or_pair_punct &
	       comma_or_rbc_punct.
3dots_or_clause := basic_punct_mark.
3dots_punct := 3dots_or_clause & 3dots_or_no_punct & basic_clause_punct.
basic_semicol_punct := clause_or_semicol & punct_mark.
basic_clause_punct := clause_or_no_punct & clause_or_semicol & 
		      rparen_or_clause_punct & punct_mark.
clause_punct := comma_or_clause & 3dots_or_clause & basic_clause_punct.
semicol_punct := clause_punct & basic_semicol_punct.
clause_sh_punct := hyphen_sgl_or_clause & basic_clause_punct.
clause_dh_punct := hyphen_dbl_or_clause & basic_clause_punct.
s_dash_punct := basic_clause_punct & comma_or_rbc_or_clause_or_no_punct.
colon_punct := comma_or_rbc_or_colon_or_pair_or_no_punct & basic_clause_punct &
               comma_or_clause_or_no_punct.
pair_punct := pair_or_no_punct & comma_or_pair_punct.
lparen_or_dq_or_no_punct := basic_punct_mark.
lparen_or_no_punct := lparen_or_dq_or_no_punct.
; Include parent type dq_or_sq_or_no_punct for np-hdn_nme-cpd_c (unused elsewhere)
lparen_punct := pair_punct & lparen_or_no_punct & dq_or_sq_or_no_punct.
;rparen_punct := basic_clause_punct & pair_punct.
; Add comma_or_rbc_or_clause_or_no_punct to allow e.g. |(those who smile)|
rparen_punct := pair_punct & rparen_or_clause_punct &
		comma_or_rbc_or_clause_or_no_punct.
quote_or_hyphen_or_clause_or_no_punct := basic_punct_mark.
quote_or_hyphen_or_no_punct := quote_or_hyphen_or_clause_or_no_punct.
dq_or_sq_or_no_punct := comma_or_rbc_or_clause_or_no_punct &
			quote_or_hyphen_or_no_punct.
dq_or_no_punct := dq_or_sq_or_no_punct & lparen_or_dq_or_no_punct.
dq_or_sq_or_lital_punct := punct_mark.
dq_or_sq_or_rital_punct := punct_mark.
dq_punct := basic_clause_punct & pair_punct & 3dots_or_clause &
            dq_or_no_punct & hyphen_or_comma_or_clause &
            dq_or_sq_or_lital_punct & dq_or_sq_or_rital_punct.
sq_punct := basic_clause_punct & pair_punct & dq_or_sq_or_no_punct &
            dq_or_sq_or_lital_punct & dq_or_sq_or_rital_punct.
hyphen_dbl := hyphen_dbl_or_clause & hyphen_dbl_or_no_punct &
              hyphen_or_comma_or_clause & pair_or_no_punct & hyphen_sgl_or_dbl.

; Robust punctuation
rbcomma_punct := punct_mark & rbc_or_no_punct & comma_or_rbc_punct.
; Inserted by preprocessor.
cap_punct := punct_mark.

; For italicized (foreign/funny) words
lital_punct := dq_or_sq_or_lital_punct & lital_or_no_punct & pair_punct.
rital_punct := dq_or_sq_or_rital_punct & pair_punct.

genre := *sort*.
formality := genre.
formal := formality.
nonformal := formality.
g-medium := genre.
written := g-medium.
spoken := g-medium.
standard := genre.
edited := formal & standard.
informal := nonformal & standard.
nonstandard := nonformal.
prescrip := formal.
robust := nonformal.

formal-w := formal & written.
formal-s := formal & spoken.
edited-w := edited & written.
edited-s := edited & spoken.
prescrip-w := prescrip & written.
prescrip-s := prescrip & spoken.
informal-w := informal & written.
informal-s := informal & spoken.
nonformal-w := nonformal & written.
nonformal-s := nonformal & spoken.
robust-w := robust & written.
robust-s := robust & spoken.

;; Dialect

dialect := *sort*.
us := dialect.
br := dialect.
uk := br.
au := br.

basic_root_synsem := canonical_synsem &
  [ LOCAL [ CAT [ HEAD [ TAM indic_tam ],
                  VAL [ SUBJ *olist*,
                        SPR *olist*,
                        COMPS < > ] ],
            CONT.HOOK.INDEX.SF #pred ],
    NONLOC [ SLASH 0-dlist & [ LIST < > ],
             REL 0-dlist & [ LIST < > ],
             QUE 0-dlist & [ LIST < > ] ],
    PUNCT.RPUNCT.PSF #pred ].

root_synsem := basic_root_synsem &
  [ LOCAL [ CAT [ HEAD verbal & [ VFORM fin_or_imp ],
		  MC + ],
	    CONJ cnil ],
    PUNCT.RPUNCT clause_or_pair_or_no_punct ].

basic_root_phr_synsem := basic_root_synsem & phr_synsem.
basic_root_lex_synsem := basic_root_synsem & lex_synsem.
root_phr_synsem := root_synsem & phr_synsem.
root_lex_synsem := root_synsem & lex_synsem.

root_frag_synsem := canonical_synsem &
  [ LOCAL [ CAT [ HEAD conj_or_frag,
		  VAL.COMPS *olist*,
		  MC na_or_+ ],
	    CONJ cnil_or_lexconj,
	    CONT.HOOK.INDEX.SF #pred ],
    NONLOC.SLASH 0-dlist & [ LIST < > ],
    PUNCT.RPUNCT clause_or_pair_or_no_punct & [ PSF #pred ] ].
