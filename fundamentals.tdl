;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-2002
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  fundamentals.tdl
;;;
;;;  Basic definitions of types for English grammar
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign_min := *avm* &
  [ STEM *list* ].

basic_sign := sign_min &
  [ KEY-ARG bool ].

;; ROBUST used to enable ungrammatical phrases such as missing det for sg-noun
;; POSSCL marks whether sign contains a possessive clitic.
;; --SEMIND is re-entrant with HOOK.INDEX, to help modularize path specs,
;; and to delay expansion of subcategorizations until necessary.
sign := basic_sign &
  [ SYNSEM synsem &
           [ LOCAL.CONT.HOOK.INDEX #index,
             --SEMIND #index ],
    ARGS *list*,
    INFLECTED bool,
    ROBUST bool,
    POSSCL bool ].

phrase_or_lexrule := sign &
  [ SYNSEM canonical_synsem &
	   [ LOCAL.CONT.HOOK #hook ],
    C-CONT mrs_min & [ HOOK #hook ] ].

word_or_lexrule_min := sign_min.

; ALTS allow lexical entries to block lexical rule application
word_or_lexrule := word_or_lexrule_min & sign &
  [ ALTS alts_min ].

word := word_or_lexrule &
  [ POSSCL - ].

; Not all phrases have SYNSEM phr_synsem, since we need to allow the head-comp
; rules to build signs which are still [ SYNSEM lex_synsem ], for constructions
; like "twenty-two" and "five fifteen p.m.".  So most phrases will assign the
; type phr_synsem to the value of SYNSEM, but not all.

; DPF 02-Sept-00 - Removed [ HC-LEX - ] because it blocks conjoined lexical
; somethings.

phrase := phrase_or_lexrule &
  [ SYNSEM.LOCAL.ARG-S < > ].


; DPF (09-Jan-99) - Added boolean LEX feature to be used for determining the
; head-complement type of the projections of lexical heads - most produce 
; phrases, but see discussion of HC-LEX feature below.

synsem_min := *avm*.

synsem_min0 := synsem_min &
  [ LOCAL mod_local ].

synsem_min1 := synsem_min0 &
  [ OPT bool,
    LEX bool,
    ROOT bool,
    NON-LOCAL non-local_min,
    MODIFIED xmod,
    --SEMIND *top* ].

lex_or_phrase :< synsem_min1.

synsem := synsem_min1.

expressed_synsem :< synsem.

canonical_synsem := expressed_synsem.

canonical_lex_or_phrase_synsem := canonical_synsem & lex_or_phrase &
  [ LOCAL local_min ].
    
phr_synsem := canonical_lex_or_phrase_synsem &
  [ LEX - ].

; LKEYS provide shortcuts to relations in RELS or a lex-entry's complements
abstr_lex_synsem := canonical_lex_or_phrase_synsem &
  [ LKEYS lexkeys ].           
    
basic_lex_synsem :< abstr_lex_synsem.

lex_synsem := basic_lex_synsem &
  [ LEX +].

; For signs that are constructed by syntactic rule but have similar
; (though not identical) distribution to lexical items - e.g. n_n_cmpnds.
lex_phr_synsem := abstr_lex_synsem &
  [ LEX + ].

; DPF 29-Nov-02 - Removed [INDEX non_expl] to allow "There was known to be a
; problem" where pred "was" requires complement to be SUBJ *olist*.
non_canonical := synsem.
expressed_non_canonical := non_canonical & expressed_synsem.

gap := expressed_non_canonical &
  [ LOCAL #local,
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist,
		SLASH 1-dlist &
		    [ LIST < #local > ] ] ].

unexpressed_min := synsem_min.
unexpressed := unexpressed_min & synsem_min1 &
  [ NON-LOCAL [ SLASH 0-dlist,
                REL 0-dlist,
		QUE 0-dlist ] ].

unexpressed_reg := unexpressed & non_canonical.

; DPF 28-Aug-99 - Removed OPT + from anti_synsem since it blocked 
; "you can have anything you want"
anti_synsem_min :< unexpressed_min.
anti_synsem := anti_synsem_min & unexpressed.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT type

;; The feature MC has three possible values: +, -, and na.  Non-clauses are
;; always MC na, since they can't really be said to be root or non-root.
;; All clauses are MC bool, and if they have a restricted distribution then
;; they are MC + or MC -.

local_basic := local_min &
  [ CONJ conj ].

local := local_basic &
  [ CTXT ctxt_min,
    ARG-S *list*,
    STEMHEAD stemhead ].

non-local := non-local_min &
  [ SLASH 0-1-dlist,
    QUE 0-1-dlist,
    REL 0-1-dlist ].

non-local_norel := non-local &
  [ QUE 0-dlist,
    REL 0-dlist ].

non-local_none := non-local_norel &
  [ SLASH 0-dlist & [ LIST < > ] ].

;; For unrealized extracted adjuncts needed in relative clauses, as in 
;; "the day he arrived"
unexpr_local :< local_basic.

;; For exceptions to lexical rules
alts_min :< *avm*.
alts := alts_min &
  [ PASSIVE bool,
    VPELLIP bool ].
no_alts :< alts_min.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsem values

; The feature AGR is introduced on LOCAL rather than on CAT (or on HEAD) since
; coordination schema unify the CAT value of the daughters with that of then
; mother, but need to be able to change AGR on the mother (to get plural 
; agreement on verb when subject is a coordinated NP with "and" vs. "or").  

cat_min :< *avm*.

;; DPF (22-Oct-98) Added feature HC-LEX ("is head-complement type lexical?")
;; on CAT, to identify the type of synsem that results from combining the word 
;; with its complements.  We recognize at least the head-complement 
;; structures  "thirty-two" and "two o'clock" as still being lexical signs, not
;; phrasal ones, since they can appear as prenominal adjectives and in noun-
;; noun compound constructions, respectively.  The head-complement rule 
;; determines its SYNSEM type by unifying its LEX value with the HC-LEX of
;; its head dtr - this works because the HCOMP rule requires its SYNSEM value to
;; be of type canonical_synsem, and the subtypes of canonical_synsem are the
;; only types that introduce the feature LEX, namely lex_synsem and phr_synsem.

; DPF 2-Jun-02 - Similarly, words differ in whether the head-specifier
; construction they head is lexical or phrasal: det+noun is phrasal to avoid
; allowing e.g. "*my the sony laptop arrived" but deg+adj is still lexical to
; avoid "*the children very small arrived" (given other constraints for each
; of these two constructions).  So introduce HS-LEX value.


cat := cat_min &
  [ HEAD head_min,
    VAL valence_min,
    MC luk,
    POSTHEAD bool,
    HC-LEX bool,
    HS-LEX bool].

local_min := mod_local &
  [ CAT cat_min,
    CONT mrs_min,
    AGR *top* ].

; no-affix :< mod_local.

non-local_min :< *avm*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Head and valence
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mod_local :< *avm*.

; The MOD value specifies the type of phrase that a sign can modify, and the
; POSTHEAD value stipulates the relative position of the modifier with
; respect to the head.  (An earlier approach employing a generalization about
; a head being final in its phrase or not might still be considered as an
; alternate to this stipulative one.)
; The POSTHEAD feature should stay with MOD, since only relevant when MOD is
; non-empty.

; DPF 09-Jan-99 - Changed value of MOD to be of type synsem rather than type
; local, since some modifiers (like vocative NPs) only modify SLASH-empty
; phrases, which means they have to have access to the NON-LOCAL feature of
; the phrase they modify.

head_min :< *avm*.

; DPF 16-Aug-99 - Added INV to head type, since need to distinguish root
; from non-root phrases as output from parser, and since inverted S's now have
; MSG empty, we have to require all non-root fragments to be INV -.

head := head_min &
  [ MOD *list*,
    PRD bool,
    KEYS keys,
    INV bool,
    AUX luk,
    TAM tam].

valence_min :< *avm*.

valence := valence_min &
  [ SUBJ *list*,
    SPR *list*,
    COMPS *list*,
    SPEC *list*,
    --KEYCOMP *avm* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

poss-able := head_min &
  [ POSS bool ].

disc_adverbee :< head.

func := head.

det := func & poss-able.

n_or_p_or_adv :< head.

p_or_adv_or_dadv :< head.

p_or_adv := n_or_p_or_adv & p_or_adv_or_dadv.

subst :< head.

v_or_g_or_p :< subst.

v_or_a_or_p :< subst.

a_or_adv :< head.

n_or_p_or_frag :< head.

n_or_p :=  n_or_p_or_adv & n_or_p_or_frag.
n_or_a :< subst.
a_or_p := v_or_a_or_p.
v_or_p :< v_or_a_or_p.
n_or_v :< subst.

; Adverbs modify adverbees.
adverbee :< head.

v_or_g_or_a :< subst.
v_or_g := v_or_g_or_a & v_or_g_or_p &
  [ VFORM vform ].

nominal_or_verbal :< subst.

nominal := nominal_or_verbal & poss-able &
  [ CASE case ].

verbal := v_or_g & nominal_or_verbal & adverbee & disc_adverbee.

; mobile things can be extracted in the complement-extraction rule, from which
; we exclude nominative-case NPs by not making all nouns mobile.

mobile :< head.
adj_or_intadj :< n_or_a.

adj := a_or_p & a_or_adv & v_or_g_or_a & adverbee & mobile &
       adj_or_intadj.

prep_or_modnp :< head.

; DPF 26-Jul-99 - Made prep not inherit from adverbee, since in general
; don't want adverbs modifying PPs.
; DPF 17-Dec-01 - But need to have at least some adverbs modifying PPs: 
; "The books currently in the store include ..."

prep := a_or_p & v_or_p & n_or_p & mobile & prep_or_modnp & v_or_g_or_p &
        p_or_adv & adverbee.

; For result of temp_mod non-branching rule
; Need mobile for "where did i put it"
; DPF 13-Oct-02 - Changed parent a_or_adv to a_or_p so these guys
; can take meaure_np degree specifiers.

modnp := n_or_p & nominal & prep_or_modnp & a_or_p & mobile & a_or_adv.

supnoun :< nominal.

noun_or_nomger := supnoun & n_or_p.

noun := n_or_v & n_or_a & noun_or_nomger.

; DPF 10-Apr-02 - Added n_or_p since want to allow gerunds to undergo noptcomp
; rule, to get e.g."way of saying that Kim arrives"
gerund := supnoun & adverbee & v_or_g & n_or_v & n_or_p & disc_adverbee.

verb := verbal & v_or_p & n_or_v &
  [ VOICE voice ].

comp := nominal & verbal.

basic_adv :< func.

; 'not' and closed class of other adverbs that can be added to aux COMPS list
; via 'adv_addition' lexical rule.
basic_lexadv := basic_adv & disc_adverbee.
negadv := basic_lexadv & adverbee.
lexadv :< basic_lexadv.

reg_adv := basic_adv & disc_adverbee & p_or_adv &
           a_or_adv.
adv := reg_adv & mobile.
adv_nonmob :< reg_adv.
deg_adv :< basic_adv.
root-marker := v_or_g & adverbee & p_or_adv_or_dadv.
wh_adv :< func.

detspec :< func.

; Hack used in blocking unwanted affixes
no_head := head.

; Types for punctuation and string boundaries.
punct := head.
clause-punct :< punct.

mobile_nom := mobile & nominal.

; Nominal gerunds
nomger :< noun_or_nomger.
nomger_acc := nomger & mobile_nom & [ CASE acc ].

; The following types are used to enable strict subcategorization (the usual 
; case)

noun_acc := noun & mobile_nom & [ CASE acc ].
noun_nom := noun & [ CASE nom ].
partn :< noun.
partn_mobile := partn & mobile.

partn_acc := partn & [ CASE acc ].
gerund_acc := gerund & mobile_nom & [ CASE acc ].
gerund_nom := gerund & [ CASE nom ].
; For tag questions, which can't be verbal in order to avoid being root S's.
tagaux := head.
frag := head & [ MOD < > ].
; Some fragment phrases can combine with another modifier
frag+ := frag & n_or_p_or_frag.
; Others cannot, but must be root fragments.
frag-r := frag.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

strict_sort :< *sort*.

; Person and number represented as atomic sorts, with gender a separate attrib
; relevant for 3sg, and where count/mass distinction only for 3sg neuter.

pernum :< *sort*.
1or3sg :< pernum.
non3sg :< pernum.
non1sg :< non3sg.
2per :< non1sg.
1or3pl :< non1sg.
1per := 1or3sg & non3sg.
1per+non1sg := 1per & non1sg.

1sg :< 1per.
1pl :< 1or3pl.
2sg :< 2per.
2pl :< 2per.
3pl :< 1or3pl.
3sg :< 1or3sg.

gender :< *sort*.
real_gender :< gender.
masc :< real_gender.
fem :< real_gender.
neut :< real_gender.
andro :< real_gender.
andro1 :< real_gender.

; The following two are used in tag questions to block mismatched expletive
; pronouns in main clause and tag, since we can't block on unified index
; values, since in general tag questions introduce a pronoun which must have
; a unique index bound by the quantifier it (now) introduces lexically.
no_gend_it := gender.
no_gend_there := gender.

png := *avm* & 
  [ PN pernum,
    GEN gender ].

; ERB declarative and interrogative seem to form a natural class
; in that 'know', 'guess', 'suspect' ... take either.  The type
; decl_int is meant to reflect this.  
; ERB (23-07-96) declarative and imperative also form a class 
; with respect to tag questions.  The type decl_imp is meant to
; reflect this.

cl_mode :< *sort*.
no_cl_mode :< cl_mode.
relative :< cl_mode.
decl_int :< cl_mode.
decl_imp :< cl_mode.
declarative := decl_int & decl_imp.
interrogative :< decl_int.
imperative :< decl_imp.


voice :< *sort*.
active :< voice.
passive :< voice.
act+pass := active & passive.

mood :< *sort*.
ind_or_mod_subj :< mood.

strict_ind_or_mod_subj := ind_or_mod_subj & strict_sort.
indicative :< strict_ind_or_mod_subj.
modal_subj :< strict_ind_or_mod_subj.
subjunctive :< mood.

prontype :< *sort*.
real_pron :< prontype.
std_pron :< real_pron.
recip :< real_pron.
refl :< real_pron.
impers :< real_pron.
demon :< real_pron.
zero_pron :< real_pron.
not_pron :< prontype.

; Three-valued sort evoking Polish logician Jan Lukasiewicz
luk :< *sort*.
; NA for Not Applicable.  
na_or_+ :< luk.
na_or_- :< luk.
+_or_- :< luk.

na := na_or_+ & na_or_-.
bool :< luk.

+ := bool & na_or_+ & +_or_-.
- := bool & na_or_- & +_or_-.

; Three-valued sort for distinguishing unmodified signs from both left-modified
; and right-modified signs
; LPERIPH and RPERIPH indicate whether this modifier is left- or 
; right-peripheral in its phrase - e.g., "the IBM temporary employees" but 
; "*the IBM five employees", and similarly "chairs I buy that you like are
; expensive" but "*chairs that you like I buy are expensive"

xmod := *sort* &
  [ LPERIPH luk,
    RPERIPH luk ].
notmod_or_rmod :< xmod.
notmod_or_lmod :< xmod.
notmod := notmod_or_rmod & notmod_or_lmod.

hasmod :< xmod.
lmod := hasmod & notmod_or_lmod.
rmod := hasmod & notmod_or_rmod.

; One of a grammatically salient inventory of semantic sorts, such as
; 'animate' or 'time'

semsort :< *sort*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT types

basic_semarg :< *avm*.
nothing :< basic_semarg.

instloc :< *top*.
semarg := basic_semarg &
  [ INSTLOC instloc ].

handle :< semarg.
individual_min := semarg.
individual := individual_min &
 [ SORT *sort* ].

; DIVISIBLE distinguishes singular count nouns from plural and mass nouns,
; for determiners like "some", and for bare-plural NPs.

index := individual &
  [ PNG png,
    DIVISIBLE bool ].
    
; Moved SORT to individual, since need to allow constraint to affect events too
full_index := index &
  [ PRONTYPE prontype ].

; This is the type of the index of the phrase modified by predicative PPs, which
; can either modify a ref-ind nominal or an event VP.

non_expl :< individual.

event_or_index :< non_expl.
event_or_deg-ind :< event_or_index.

basic_tense :< *sort*.
tense :< basic_tense.
untensed :< basic_tense.
aspect := *avm* &
  [ PERF luk,
    PROGR luk ].
no_aspect := aspect &
  [ PERF -,
    PROGR - ].

real_tense :< tense.
nonpast :< real_tense.
present :< nonpast.
past :< real_tense.
future := nonpast.
no_tense := tense & untensed.
; For PPs that can never be complements of 'be'
nontense :< untensed.

tam := *avm* &
 [ TENSE basic_tense,
   ASPECT aspect,
   MOOD mood ]. 

basic_ind_or_mod_subj_tam := tam &
 [ MOOD ind_or_mod_subj ].

ind_or_mod_subj_tam := basic_ind_or_mod_subj_tam &
 [ TENSE real_tense ].

past_or_subj_tam := tam &
 [ ASPECT no_aspect ].

subjnct_tam := past_or_subj_tam &
 [ MOOD subjunctive ].

past_tam := past_or_subj_tam & ind_or_mod_subj_tam &
 [ TENSE past,
   MOOD indicative ].

event := event_or_deg-ind &
  [ E tam ].

; Once used to distinguish discourse adverbs, for VIT purposes - now obsolete?
disc_frag :< event_or_index.

; WLINK links semantic relation to input string elements, more or less.

relation := *avm* &
  [ LBL handle,
    WLINK *list*,
    PRED predsort ].

arg0_relation := relation &
  [ ARG0 event_or_index ].

event_relation := arg0_relation &
  [ ARG0 event ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MRS type
;
;   HOOK                   ; Label of rel with highest scope in sign
;   RELS                   ; List of elementary predications
;   HCONS *diff-list*      ; Scope constraints: list of scp_pr's

hook := *top* &
  [ LTOP handle,
    INDEX *top*,
    XARG basic_semarg ].

mrs_min := *avm* &
  [ HOOK hook,
    MSG basic_message ].

mrs_min1 := mrs_min &
  [ RELS *diff-list* ].
    
;; DPF 10-Oct-00 - Added ARG0 attribute for predicative phrases, as in
;; "Kim kept calm" where the INDEX of "calm" is "Kim"'s INDEX and the first
;; argument of _keep_rel, while "calm"'s ARG0 is second argument of _keep_rel.

mrs := mrs_min1 &
  [ HCONS *diff-list* ].

; Constrains handle of scopable argument HARG relative to one or more 
; handles
scp_pr := *top* &
  [ HARG handle,
    LARG handle ].        

; Constrains scope to be equal subject to intervening quantifiers
qeq := scp_pr.

; Used at least in fragments
geq := scp_pr.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONJ type -
;
; CONJ values come in two types, cnil and strict-conj (i.e., non-cnil).  Cnil
; and the atomic substypes of strict-conj are the possible CONJ values of the
; left conjunct in a coordinate structure.  The right conjunct must always
; have a complex-conj CONJ value.  A complex CONJ value has three parts: the
; handles and indices of the sub-parts of the right conjunct, and the CHEAD
; info that gets passed from the right conjunct to the mother.  The CHEAD
; value has only one piece of information: the CONJ values of the
; left conjunct daughters.  For more info about how this works, see
; top_coord_rule in syntax.tdl.

conj :< *avm*.
cnil_or_numconj :< conj.
cnil :< cnil_or_numconj.
real-conj := conj &
  [ CHEAD chead ].
strict-conj :< conj.
strict-real-conj := strict-conj & real-conj.
strict-atomic-conj :< strict-real-conj.
atomic-conj := strict-atomic-conj &
  [ CHEAD.LEFT.FIRST cnil ].
both :< atomic-conj.
either :< atomic-conj.
neither :< atomic-conj.
nor :< atomic-conj.
chead := *avm* &
  [ LEFT *list* ].
; CREL is a pointer to the coord_relation, needed for semantic composition.
complex-conj := strict-real-conj &
  [ CREL *top* ].
phr-conj :< complex-conj.
lex-conj :< complex-conj.
num-conj := cnil_or_numconj & strict-atomic-conj.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Contextual information

ctxt_min :< *avm*.

ctxt := ctxt_min &
  [ ACTIVATED bool,
    PRESUP *diff-list* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Stem type

; The stemhead of a lexical entry is used by inflectional affixes to ensure the
; desired stem without overly restricting the value of HEAD itself, since
; this needs to remain non-specific to allow conjunction of non-similar heads. 
; Note that if we distinguished lexemes from words, the stemhead could be the
; value of HEAD for the lexeme, and the word's value for HEAD could be 
; supplied by the affix; then the same head type could be used for both.
; This feature is only given a more specific value for lexical entries which
; get inflected (verbs, nouns, and adjectives).

stemhead :< *sort*.
vstem :< stemhead.
nstem :< stemhead.
count_or_masscount_nstem :< nstem.
masscountnstem :< count_or_masscount_nstem.
countnstem :< count_or_masscount_nstem.
massnstem :< nstem.
astem :< stemhead.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LKEYS relations (shortcuts to key rels of complements, only used in lexicon)
;  KEYREL relation          ; Pointer to main relation in RELS
;  ALTKEYREL relation       ; Pointer to an alternate relation in RELS
;  ALT2KEYREL relation      ; Pointer to a second alternate relation in RELS
;  --COMPKEY predsort       ; Pointer to the complement's KEY
;  --OCOMPKEY predsort      ; Pointer to the oblique complement's KEY
;  --+COMPKEY predsort      ; Pointer to obligatory complement's KEY
;  --+OCOMPKEY predsort      ; Pointer to obligatory oblique complement's KEY

keys := *avm* &
  [ KEY predsort,
    ALTKEY predsort,
    ALT2KEY predsort ].

lexkeys := *avm* &
  [ KEYREL relation,
    ALTKEYREL relation,
    ALT2KEYREL relation,
    --COMPKEY predsort,
    --OCOMPKEY predsort,
    --+COMPKEY predsort,
    --+OCOMPKEY predsort ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; DPF (14-Oct-98) --FINAL-ARG points to the final element in a word with 
;; spaces, since that element bears any inflection.
;; AAC - dropped --FINAL-ARG - default infl position is end of word
;; in user-fns. Find better soln when we do multi words properly
;; (and use defaults)

non_affix_bearing := word_or_lexrule &
  [ SYNSEM.LKEYS.KEYREL.WLINK *cons*,
    INFLECTED + ].

; Rule

rule := sign &
  [ RULE-NAME string ].

; LABEL-NAME and META used for labeling nodes in parse trees

tree_node_label := *top* &
  [ NODE sign ].

label := sign &
  [ LABEL-NAME string ].

;; see lkbpatches
meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ]. 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CASE and VFORM

case :< *sort*.
nom :< case.
acc :< case.

vform :< *sort*.
non_fin :< vform.
non_prp :< non_fin.
ger :< non_prp.
pas_or_psp :< non_fin.
pas := non_prp & pas_or_psp.
psp_or_psp_irreg :< pas_or_psp.
psp :< psp_or_psp_irreg.
psp_irreg :< psp_or_psp_irreg.
bse_or_inf :< vform.
; fin_or_bse used to collapse morpholog. unmarked forms for bse and fin-non3sg.
fin_or_bse :< vform.
bse :< bse_or_inf.
; Base morphology verbs can be either base or imperative, but not if negated.
; See discussion of type neg_word.
bse_only := bse & non_fin & fin_or_bse.
fin_or_imp :< vform.
imp_vform := bse & fin_or_imp.
fin_or_inf :< vform.
fin := fin_or_inf & fin_or_bse & fin_or_imp.
inf_or_prp :< non_fin.
inf := inf_or_prp & bse_or_inf & fin_or_inf.
prp :< inf_or_prp.

inf_and :< vform.
psp_adj :< vform.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  CONT values (MRS semantics)
;;
;; The basic semantic objects are all sub-types of semarg.  Right now, the only
;; type of semarg that has an internal structure is index, but that will
;; probably change.  For example, an event might have various times associated
;; with them or a handle may include a list of "subhandles" which are in its
;; scope.  Indices are classified in the familiar HPSG way.

expl-ind :< index.
full_expl-ind := expl-ind & full_index.
it-ind := full_expl-ind &
  [ PNG [ PN 3sg,
          GEN no_gend_it ] ].
there-ind := expl-ind &
  [ PNG.GEN no_gend_there ].

non_expl_or_conj-ind :< index.
ind_or_event_or_conj := non_expl_or_conj-ind & event_or_index.
non_expl-ind := ind_or_event_or_conj &
  [ PNG.GEN real_gender ].
ref-ind :< non_expl-ind.
deg-ind := non_expl-ind & event_or_deg-ind.
full_non_expl := full_index & non_expl-ind.
full_there-ind := there-ind & full_expl-ind.
full_ref-ind := ref-ind & full_non_expl.
full_deg-ind := deg-ind & full_non_expl.
; Added to block spurious ambiguity for conjoined proper names:
nonconj_ref-ind :< full_ref-ind.

conj-ind :< event_or_index.
conj_event_or_deg-ind := event_or_deg-ind & conj-ind.
conj_event := conj_event_or_deg-ind & event.
conj_non_expl-ind := conj-ind & non_expl-ind.
conj_full-ind := conj_non_expl-ind & full_non_expl.
conj_ref-ind := conj_non_expl-ind & ref-ind.
conj_full_ref-ind := conj_ref-ind & conj_full-ind & full_ref-ind.
conj_deg-ind := conj_event_or_deg-ind & conj_non_expl-ind & deg-ind.
conj_full_deg-ind := conj_deg-ind & conj_full-ind & full_deg-ind.

; The basic semantic structure, a CONT, is just something with a handle.
; Conts are further classified into mrss (i.e., things with liszts) and
; relations (i.e., things that go on liszts).  Conts are divided into psoas
; (with a distinguished event) and nom-objs (with a distinguished index).
; We use a polymorphic attribute name INDEX for both of these, to simplify
; manipulation of these objects; for example, modifying PPs assign as their
; ARG1's value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  Similarly useful
; for coordination.

; ERB (03-10-96) 
; The intermediate types ques_prop_msg and prop_com_msg represent the
; natural classes needed for selection by know, announce, care, check,
; etc. and the analysis of THAT (see lextypes.tdl) and the 
; forthcoming analysis of tags on imperatives, respectively.

psoa := mrs_min &
  [ HOOK.INDEX event ].

psoa_basicmrs :< psoa.

psoa_mrs := psoa_basicmrs & mrs.

; DPF 11-Feb-01 - For now, make all nom-objs have INDEX and E-INDEX the same, 
; to keep coordination working now that we want to treat coordination of 
; predicative phrases via their E-INDEX.  Probably will have to adjust this
; once we get more interesting temporal semantics for some nouns.
; DPF 29-Nov-02 - Can't have E-INDEX the same, since pre-nominal adjectives
; now unify their E-INDEX with that of the noun, and it's of type event.
; Recall that adjectives must do this unification in order to propagate the
; E-INDEX of the syntactic head, since the adjective is the semantic head.
; DPF 4-Dec-02 - For now, make all nouns not expose an external argument, so
; they won't appear as controlled complements.  Will perhaps want to treat
; indefinite NPs in copular constructions by relaxing this constraint for e.g.
; "Kim is a consultant"

nom-obj := mrs &
  [ HOOK.XARG nothing ].

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; Since some temporal nouns can be either arguments or VP modifiers, their 
; rel's ARG0 value (coindexed with INDEX of the containing MRS) must remain 
; unspecified for type.  Consider "Kim arrived Tuesday" vs. "Tuesday comes
; after Monday"; in the first, Tuesday must have an event ARG0, while in the
; second, it must have a ref-ind ARG0.

; ERB (24-10-96) Here is the series of relations that will be used for
; questions, etc.  Cf. Gizburg & Sag.
; ERB (12-05-96) Moved the ne_m_rel here.

basic_message := relation.
no_msg :< basic_message.
message := basic_message &
  [ PRED message_m_rel,
    MARG handle,
    PARAMS *diff-list* ].

quant_or_wh_relation := arg0_relation &
  [ PRED quant_or_wh_rel,
    ARG0 ref-ind,
    RSTR handle,
    BODY handle ].

number_q_relation := quant_or_wh_relation &
  [ PRED number_q_rel,
    ARG0.SORT number ].

; Nominal sorts
nominal-sort :< *sort*.
entity :< nominal-sort.
human :< entity.
location :< nominal-sort.
time :< location.
place :< location.
nom-event :< nominal-sort.
number :< nominal-sort.
dimension :< nominal-sort.

; modable_rel distinguishes those relations whose nominal lexical entries can 
; undergo a syntactic rule to produce a modifier phrase, as in "we'll meet
; next week" or "I'll do it my way".

; dir_state_modable_rel is the supertype of modable_rel and dir_or_state_rel
; used by verbs selecting for locative PPs including nominal adverbials which
; are converted from NPs to PPs via a syntactic rule which introduces the
; two-place locative relation.  This type is needed to support the shortcut of
; chart dependencies to filter out verb entries if the corresponding particle
; or preposition is not present, so we can still parse e.g. "Kim put it here".

; Nominal relations

instance_relation := arg0_relation &
  [ ARG0 individual_min ].

nom_relation := instance_relation &
  [ ARG0 non_expl-ind ].

; DPF 25-Sep-01 - Added [SORT entity] contrasted with [SORT time] to enable
; blocking of e.g. "the book that kim arrived" but allow "the day that Kim
; arrived"

reg_nom_relation := nom_relation &
  [ ARG0.SORT entity ].

modable_nom_relation := nom_relation &
  [ ARG0.SORT entity ].

basic_diadic_nom_relation := nom_relation & basic_arg01_relation.

diadic_nom_relation := basic_diadic_nom_relation &
  [ ARG1 non_expl-ind ].

reg_diadic_nom_relation := diadic_nom_relation &
  [ ARG0.SORT entity ].

basic_hcomp_nom_relation := basic_diadic_nom_relation &
  [ ARG1 handle ].

hcomp_nom_relation := basic_hcomp_nom_relation &
  [ ARG0.SORT entity ].

; Changed nominalize_rel and gerund_rel to subtype of non_temp_nom_rel rather 
; than reg_nom_rel to avoid semantically anomalous readings for e.g. "Kim is 
; sleeping".

nom_or_ger_relation := arg0_relation &
  [ ARG0.SORT nom-event ].

nominalize_relation := basic_hcomp_nom_relation & nom_or_ger_relation &
  [ PRED nominalize_rel ].

gerund_relation := basic_diadic_nom_relation & nom_or_ger_relation &
  [ PRED gerund_rel,
    ARG0 ref-ind ].

temp_abstr_relation := nom_relation &
  [ ARG0.SORT time ].

const_value_relation := relation &
  [ CARG *top* ].

const_arg0_relation := const_value_relation & arg0_relation.
const_arg01_relation := const_arg0_relation & basic_arg01_relation.

generic_named_nom_relation := nom_relation & const_arg0_relation.
named_nom_relation := generic_named_nom_relation &
  [ ARG0.SORT entity ].

generic_diadic_named_relation := generic_named_nom_relation & 
                                 const_arg01_relation &
                                 diadic_nom_relation.
diadic_named_nom_relation := generic_diadic_named_relation &
                             reg_diadic_nom_relation.

day_part_relation := nom_relation &
  [ PRED day_part_rel,
    ARG0.DIVISIBLE - ].

; ARG1 is the minute_rel complement's ARG0, and ARG2 is the am_pm's ARG0.
numbered_hour_relation := const_arg01_relation & basic_arg12_relation & 
  [ PRED numbered_hour_rel,
    ARG0 [ PNG png & [ PN 3sg,
                       GEN neut ],
           SORT time ],
    CARG string,
    ARG1 individual_min,
    ARG2 individual_min ].

am_pm_relation := const_arg0_relation.

; Pronouns
; DPF 2-Jul-03 - Removed DIVISIBLE - which was perhaps used earlier to block
; spurious application of bare-np rule.  Not desirable since antecedent could
; of course be mass or plural, and maybe want indices to be unifiable for
; anaphora resolution.

pron_relation := nom_relation &
  [ PRED pron_rel,
    ARG0 ref-ind & [ SORT entity ] ].

recip_pro_relation := nom_relation &
  [ PRED recip_pro_rel,
    ARG0 ref-ind & [ SORT entity ] ].

basic_adj_relation := event_relation.

adj_relation := basic_adj_relation & arg1_relation &
  [ ARG1 non_expl ].

adj_arg1_relation := adj_relation.
adj_arg12_relation := adj_arg1_relation & arg12_relation.
adj_arg123_relation := adj_arg12_relation & arg3_relation.
it_adj_arg12_relation := adj_arg12_relation.
it_adj_arg123_relation := adj_arg123_relation.

basic_arg1_relation := relation &
  [ ARG1 semarg ].

arg1_relation := basic_arg01_relation & event_relation.

arg2_relation := relation &
  [ ARG2 semarg ].

arg3_relation := relation &
  [ ARG3 semarg ].

arg4_relation := relation &
  [ ARG4 semarg ].

basic_arg01_relation := basic_arg1_relation & arg0_relation.
basic_arg12_relation := basic_arg01_relation & arg2_relation.
arg12_relation := basic_arg12_relation & arg1_relation.
arg123_relation := arg12_relation & arg3_relation.
arg1234_relation := arg123_relation & arg4_relation.

aux_arg1_relation := arg1_relation &
  [ PRED aux_arg1_rel ].

; Preposition relations

prep_relation := basic_arg12_relation &
  [ PRED prep_rel,
    ARG2 non_expl ].	    

adv_relation := basic_arg1_relation.

; Degree relations

degree_relation := arg0_relation &
  [ DARG *top*,
    ARG0 individual_min ].

comparative_relation := degree_relation &
  [ ARG-1 index,
    C-ARG0 index ].

comp_more_less_relation := comparative_relation &
  [ ARG-2 semarg ].

comp_most_least_relation := comparative_relation &
  [ C-SET handle ].

;; For "how" adjective, which quantifies over properties.

; For "how does Tuesdaay look" using second-order quantification (see notes for
; adj_wh_le in lextypes.tdl
; ARG1 is proposition, ARG2 is property

prpstn_to_prop_relation := arg12_relation &
  [ PRED prpstn_to_prop_rel,
    ARG1 handle,
    ARG2 non_expl-ind ].

comp_relation := prep_relation &
  [ ARG2 event_or_index,
    ARG0.E.TENSE no_tense ].
superl_relation := prep_relation &
  [ ARG2 event_or_index ].

subord_relation := relation &
  [ MAIN handle,
    SUBORD handle ].

; Discourse functions

; ERB (03-10-96) In order to capture the similarities and differences
; between embedded and matrix questions, I am decomposing the ynq_rel
; into polar_q_rel and request_ans_rel.  The latter is probably 
; equivalent to the ne_m_rel (see below), but ne_m_rel is too cute to
; forgo for the tag questions and probably too opaque for the 
; matrix yn questions, so I will keep the two for now.  NB polar_q_rel
; probably doesn't qualify as 'discourse function'.  

; So, the ynq_root construction will contribute a polar_q_rel and
; a request_ans_rel, whether will contribute a polar_q_rel, and
; matrix wh questions will contribute a request_ans_rel.

#|
polar_q_rel :< mod_rel.
request_ans_rel :< mod_rel.

polite_rel :< mod_rel.
|#

basic_conj_relation := relation &
  [ PRED basic_conj_rel,
    C-ARG conj-ind,
    L-INDEX non_expl,
    R-INDEX non_expl ].

conj_relation := basic_conj_relation &
  [ PRED conj_rel,
    L-HNDL basic_semarg,
    R-HNDL basic_semarg ].

; Abstract relations specified by more than one lexical entry

abstr_place_relation := nom_relation &
  [ ARG0.SORT place ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Number relations

; DPF 10-Feb-02 - Highly experimental addition of ARG0 attribute to get 
; segregation of numerical adjectives

integer_relation := basic_arg01_relation &
  [ PRED integer_rel,
    ARG1 individual_min ].

const_relation := integer_relation & const_arg01_relation &
  [ PRED const_rel,
    CARG string].

plus_relation := integer_relation & 
  [ PRED plus_rel,
    TERM1 handle,
    TERM2 handle].
times_relation := integer_relation & 
  [ PRED times_rel,
    FACTOR1 handle,
    FACTOR2 handle].

;; TYPES/SORTS
;; The ORDINAL feature determines whether its bearer is ordinal or not 
;; (i.e., is ordinal or cardinal).  Thus it is only appropriate for
;; numbers.  All numbers have a HEAD value of sort intsort, those
;; used adjectivally have heads of sort intadj (or one of its 
;; subsorts) or intdet (which has no subsorts).  Nominal uses are
;; not yet supported.
;;
;; Subcategorization, which is in terms of the maximum number of digits
;; allowed for the complement or specifier, is handled by the subsorts
;; of the digitn hierarchy.  Currently, only adjectives participate in
;; this hierarchy; there is only a single integer determiner ("one").
;; Nominal uses could be added by adding a type
;;          intnoun := intsort & digitn & noun.

intsort := head & [ORDINAL bool].

digitn :< head.

digit15 :< digitn.
digit12 :< digit15.
digit9 :< digit12.
digit6 :< digit9.
digit3 :< digit6.
digit2 :< digit3.
digit1 :< digit2.

; The sorts    digitk    specify the number of digits of a lexeme 
; together with its largest complement and specifier.
; The sorts    digitk-    are used for subcategorization; they include
; values of k or fewer digits.
 
digit15- :< digitn.
digit12- :< digit15-.
digit9- :< digit12-.
digit6- :< digit9-.
digit3- :< digit6-.
digit2- :< digit3-.
digit1- :< digit2-.

;; DPF 26-Apr-00 - Removed adj parent from intadj.
;; DPF 19-Sept-01 - Added supertype adj_or_intadj, for adj-intervals ("2 - 3")

intadj := intsort & adj_or_intadj.
intadjn := intadj & digitn.
intdet := intsort & det.

; intadj1- := intadj1.
; intadjk- means an integer adjective of at most k digits (when
;   combined with specifier and complement

intadj15- :< intadj.
intadj15  := intadj15- & digit15.
intadj12- :< intadj15-.
intadj12  := intadj12- & digit12.
intadj9- :< intadj12-.
intadj9  := intadj9- & digit9.
intadj6- :< intadj9-.
intadj6  := intadj6- & digit6.
intadj3- :< intadj6-.
intadj3  := intadj3- & digit3.
intadj2- :< intadj3-.
intadj2  := intadj2- & digit2.
intadj1  := intadj2- & digit1.

fractadj := intadj & [ MOD < > ].

_here_j_rel :< adj_rel.
_now_j_rel :< adj_rel.
_there_j_rel :< adj_rel.
_today_j_rel :< adj_rel.
_tomorrow_j_rel := adj_rel & dofw_or_poss_q_rel.
_yesterday_j_rel := adj_rel & dofw_or_poss_q_rel.
_tonight_j_rel := adj_rel & dofw_or_poss_q_rel.
_east_j_rel :< adj_rel.
_north_j_rel :< adj_rel.
_south_j_rel :< adj_rel.
_west_j_rel :< adj_rel.
_outdoors_j_rel := adj_rel.
_overseas_j_rel := adj_rel.
_online_j_rel := adj_rel.
_offline_j_rel := adj_rel.
_southeast_j_rel := adj_rel.
_southwest_j_rel := adj_rel.
_northeast_j_rel := adj_rel.
_northwest_j_rel := adj_rel.
_northward_j_rel := adj_rel.
_southward_j_rel := adj_rel.
_eastward_j_rel := adj_rel.
_westward_j_rel := adj_rel.
_upward_j_rel := adj_rel.
_downward_j_rel := adj_rel.
_downhill_p_rel :< dir_rel.
_inward_j_rel := adj_rel.
_outward_j_rel := adj_rel.
_inland_j_rel := adj_rel.
_late_p_rel := miscprep_rel.
_elsewhere_j_rel := adj_rel.
_forever_j_rel := adj_rel.

; For fragments
unknown_relation := arg0_relation &
  [ PRED unknown_rel,
    ARG semarg ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Basic types

; DPF 10-Sep-03 Temporary redefinition of *sort* until we get rid of relations
; as values of KEY.

*sort* :< *top*.

atom :< predsort.

*avm* :< *top*.

*list* :< *avm*.

*cons* := *list* &
  [ FIRST *top*,
    REST *top* ].

0-1-list :< *list*.
1-list := 0-1-list & *cons* &
  [ REST *null* ].
*null* :< 0-1-list.
1-plus-list := *cons* &
  [ REST *cons* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Basic types

string :< atom.

integer :< atom.

; Lists

; ERB (13-12-97) This type is meant as a PRO -- i.e., what can show
; up in such things as the 'way' construction and embedded infinitival
; wh questions.  It should eventually receive some binding properties,
; but I don't know what to put there yet, and since we don't have
; a binding theory...

; ERB (14-12-97) I am adding the pron_rel to pro_ss, so that in the
; types like common_noun_vpcomp_synsem I don't have to put it in.  I
; can just take the KEYREL.

; ERB (14-12-97) No pron_rel for pro_ss.

; ERB (14-12-97) ... and pro_ss is accusative, to block (once I get
; infinitival relatives working) *A person left came in.

; ERB (14-12-97) This is moved here so as to be after acc, which is a 
; *sort* and thus can't handle being referenced before it is defined.

; ERB (19-01-98) PRO is obligatorially OPT -.  This keeps to_c_prop
; from serving as a modifier without first building a non_wh_rel,
; because hadj requires SUBJ *olist*.

; ERB (21-01-98) In order for PRO to be extractable, it can't be
; SLASH 0-dlist, and thus can't be a subtype of unexpressed.  With
; PRO underspecified for SLASH, something will always have to fill
; in that value.  In the case of subject non_wh_rels (e.g., 
; "Kim found a person to fix the sink") it is extracted, i.e., resolved
; to gappro by extrasubj.  In the cases where the PRO is the subject of
; a selected complement, the selector will impose SLASH 0-dlist on the
; PRO (this case includes equi constructions, embedded infinitival
; wh questions, and the complement of 'way' as in "Kim found a way
; to leave early").  In the case of the (as yet unimplemented) CP[to]
; subjects, the NP -> CP rule will probably do the work.  Alternatively,
; the selecting category could do it.  Finally, in the case of
; non-subject non_wh_rels (e.g., "Kim found a cheeseburger to devour"),
; the PRO must be SLASH 0-dlist because the non_wh_rel_rule limits
; the SLASH list to length one.
;
; On a related note, we want the distribution of gappro (i.e., of
; extracted PRO) to be quite constrained, and perhaps even limited
; to the subject non_wh_rels.  In general, we are relying on the
; restriction of SLASH to lists of length one stated in several places
; in the grammar, in addition to certain selecting categories' specifying
; an empty value for SLASH on the PROs in their complements' subjects
; to keep us from getting in trouble on this one.
;
; Finally, rather than make a subtype of pro_ss that says SLASH 0-dlist,
; I have opted to include that information on the type *prolist*.

; ERB (03-23-98) We need a way to identify indices introduced by a PRO
; that are "discourse bound".  We were using PRONTYPE for this, but
; of course that doesn't work when the controller of the PRO is an overt
; pronoun.  So the new strategy is to make the INDEX a non_expl.
; This will unify with the indices introduced by (appropriate) controllers,
; and (hopefully) be identifiable if it is not controlled.

; DPF 27-May-99 - Removed OPT - constraint from pro_ss (see ERB (19-01-98) 
; above) since head_mod type now constrained via PRD rather than by requiring 
; SUBJ to be empty (cf note DPF 27-May-99 with n_adj_int_phrase in syntax.tdl).
; This change means the types for saturated subcats can again simply require 
; SUBJ to be *olist* rather than *null*, which e.g. allows verbal gerunds to 
; have optional but non-empty SUBJ value and still themselves appear as 
; subjects or complements without discharging that SUBJ value.

pro_ss := expressed_non_canonical &
  [ LOCAL.CAT.HEAD noun & [ CASE acc ],
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist ] ].

; ERB (19-01-98) We need a subtype of pro and gap so that to_c_prop
; can undergo subject extraction.  See the notes near non_wh_rel in
; syntax.tdl for the details of the analysis.
; I am positive that this will break something, but I could not
; guess what.

gappro := pro_ss & gap.

*olist* :< *list*.

*ocons* := *olist* & *cons* &
  [ FIRST unexpressed & [ OPT + ],
    REST  *olist* ].

*onull* := *olist* & *null*.


*gaplist* :< *list*.

*gapcons* := *gaplist* & *cons* &
  [ FIRST gap,
    REST  *null* ].

*gapnull* := *gaplist* & *null*.
*prolist* := *list*.

*procons* := *prolist* & *cons* &
  [ FIRST pro_ss &
	  [ NON-LOCAL.SLASH <! !> ],
    REST *null* ].

*pronull* := *prolist* & *onull*.

;; *unexplist* is used for common nouns whose specifier is possibly obligatory,
;; but unexpressed, as in noun-noun compounds.  As usual, we use the same hack
;; as for *olist*, to get around the lack of recursive types in TDL.

*unexplist* := *list*.

*unexpcons* := *unexplist* & *cons* &
  [ FIRST unexpressed,
    REST  *null* ].

;*unexpnull* := *unexplist* & *olist* & *null*.
*unexpnull* := *unexplist* & *onull*.

;; *substlist* is used in the adv_addition lexical rule, to prevent spurious
;; re-application of the rule to its own output by requiring the input to
;; be a (possibly empty) list of substantive synsems.
*substlist* :< *list*.

*substcons* := *substlist* & *cons* &
  [ FIRST.LOCAL.CAT.HEAD subst,
    REST  *substlist* ].

; For there-copula
*substocons* := *substcons* & *ocons*.

;*substnull* := *substlist* & *olist* & *null*.
*substnull* := *substlist* & *onull*.

;; *handlelist* is used in the treatment of free relatives, to disntinguish
;; the usual value of QUE from its use in free relatives, where QUE is instead
;; a list of referential indices.

*handlelist* := *list*.

*handlecons* := *handlelist* & 1-list &
  [ FIRST handle,
    REST  *null* ].

*handlenull* := *handlelist* & *onull*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subtypes of *diff-list*

;; Experimental use of subtypes of *diff-list* to enforce constraint of at
;; most one element in SLASH (for efficiency, "violin/sonnet" examples
;; notwithstanding).  Will only have effect in LKB version which does the
;; necessary type inference.

*diff-list* := *avm* &
[ LIST *list*,
  LAST *list* ].

0-1-dlist := *diff-list* &
  [ LIST 0-1-list ].

; DPF 10-Oct-02 - Just a reminder that we cannot make the LIST value of 0-dlist
; be < >, much as we might like to, since we're doing lexical threading of
; SLASH (at least), and if we make all 0-dlists have LIST < >, then if the
; first of two complements is a proper name with SLASH 0-dlist, then the
; appended diff-list also has LIST <>, which prevents the second complement
; (or the subject) from being slashed, so we would even block "Who hired Kim".

0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].
1-dlist := 0-1-dlist &
  [ LIST 1-list &
	 [ REST #rest & *null* ],
    LAST #rest ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; predkeys

_place_n_i_rel :< reg_nom_rel.
_quits_n_i_rel :< reg_nom_rel.
_hold_n_i_rel :< reg_nom_rel.
_ahold_n_i_rel :< reg_nom_rel.
_note_n_i_rel :< reg_nom_rel.
_advantage_n_i_rel :< reg_nom_rel.
_care_n_i_rel :< reg_nom_rel.
_charge_n_i_rel :< reg_nom_rel.
_part_n_i_rel :< reg_nom_rel.
_use_n_i_rel :< reg_nom_rel.
_account_n_i_rel :< reg_nom_rel.

abstr_sure_rel :< adj_rel.
_sure_j_rel :< abstr_sure_rel.
_certain_j_rel :< abstr_sure_rel.

_about_p_sel_rel :< selected_prep_rel.
_across_p_sel_rel :< selected_prep_rel.
_after_p_sel_rel :< selected_prep_rel.
_against_p_sel_rel :< selected_prep_rel.
_along_p_sel_rel :< selected_prep_rel.
_apart_j_sel_rel :< selected_adj_rel.
_around_p_sel_rel :< selected_prep_rel.
_as_p_comp_rel :< selected_prep_rel.
_as_p_sel_rel :< selected_prep_rel.
_as+to_p_sel_rel :< selected_prep_rel.
_aside_p_sel_rel :< selected_prep_rel.
_at_p_sel_rel :< selected_prep_rel.
_away_p_sel_rel :< selected_prep_rel.
_back_p_sel_rel :< selected_prep_rel.
_behind_p_sel_rel :< selected_prep_rel.
_between_p_sel_rel :< selected_prep_rel.
_by_p_sel_rel :< selected_prep_rel.
_by_p_cm_rel :< selected_prep_rel.
_down_p_sel_rel :< selected_prep_rel.
_for_p_sel_rel :< selected_prep_rel.
_forth_p_sel_rel :< selected_prep_rel.
_forward_p_sel_rel :< selected_prep_rel.
_from_p_sel_rel :< selected_prep_rel.
_in_p_sel_rel :< selected_prep_rel.
_into_p_sel_rel :< selected_prep_rel.
_of_p_sel_rel :< selected_prep_rel.
_of_p_nbar_rel :< selected_prep_rel.
_off_p_sel_rel :< selected_prep_rel.
_on_p_sel_rel :< selected_prep_rel.
_open_j_sel_rel :< selected_adj_rel.
_out+of_p_sel_rel :< selected_prep_rel.
_out_p_sel_rel :< selected_prep_rel.
_over_p_sel_rel :< selected_prep_rel.
_short_j_sel_rel :< selected_adj_rel.
_solid_j_sel_rel :< selected_adj_rel.
_through_p_sel_rel :< selected_prep_rel.
_to_p_sel_rel :< selected_prep_rel.
_together_p_sel_rel :< selected_prep_rel.
_toward_p_sel_rel :< selected_prep_rel.
_towards_p_sel_rel :< selected_prep_rel.
_up_p_sel_rel :< selected_prep_rel.
_upon_p_sel_rel :< selected_prep_rel.
_with_p_sel_rel :< selected_prep_rel.
_without_p_sel_rel :< selected_prep_rel.
_than_p_compar_rel :< selected_prep_rel.

_a_p_per_rel :< miscprep_rel.
_about_p_rel :< of_miscprep_rel.
_above_p_rel :< dir_or_state_rel.
_above_p_dir_rel := _above_p_rel & dir_rel.
_abroad_p_rel :< miscprep_rel.
_according+to_p_rel :< miscprep_rel.
_across_p_rel :< dir_or_state_rel.
_across_p_dir_rel := _across_p_rel & dir_rel.
_after_p_rel :< tempprep_minute_rel.
_afterward_p_rel :< miscprep_rel.
_afterwards_p_rel :< miscprep_rel.
_against_p_rel :< miscprep_rel.
_ago_p_rel :< miscprep_rel.
_ahead_p_rel :< miscprep_rel.
_ahead+of_p_rel :< miscprep_rel.
_all+over_p_rel :< miscprep_rel.
_along_p_rel :< dir_or_state_rel.
_along_p_dir_rel := _along_p_rel & dir_rel.
_along+with_p_rel :< miscprep_rel.
_amid_p_rel :< miscprep_rel.
_among_p_rel :< miscprep_rel.
_apart+from_p_rel :< miscprep_rel.
_around_p_rel :< miscprep_rel.
_as_p_rel :< miscprep_rel.
_as+of_p_rel :< temp_loc_rel.
_as+for_p_rel :< miscprep_rel.
_as+to_p_rel :< miscprep_rel.
_ashore_p_rel :< miscprep_rel.
_aside_p_rel :< miscprep_rel.
_aside+from_p_rel :< miscprep_rel.
_astray_p_rel :< miscprep_rel.
_at_p_rel :< state_loc_rel.
_at_p_temp_rel :< temp_loc_rel.
_available_j_rel :< adj_rel.
_away_p_rel :< miscprep_rel.
_back_p_rel :< miscprep_rel.
_backward_p_rel :< miscprep_rel.
_backwards_p_rel :< miscprep_rel.
_because+of_p_rel :< miscprep_rel.
_before_p_rel :< miscprep_rel.
_beforehand_p_rel :< miscprep_rel.
_below_p_rel :< dir_or_state_rel.
_below_p_dir_rel := _below_p_rel & dir_rel.
_behind_p_rel :< dir_or_state_rel.
_behind_p_dir_rel := _behind_p_rel & dir_rel.
_beside_p_rel :< dir_or_state_rel.
_beside_p_dir_rel := _beside_p_rel & dir_rel.
_besides_p_rel :< miscprep_rel.
_between_p_rel :< temp_loc_rel.
_beyond_p_rel :< dir_or_state_rel.
_beyond_p_dir_rel := _beyond_p_rel & dir_rel.
_but_p_except_rel :< miscprep_rel.
_by_p_rel :< miscprep_rel.
_by_p_temp_rel :< temp_loc_rel.
_by+means+of_p_rel :< miscprep_rel.
_by+way+of_p_rel :< miscprep_rel.
_close+to_p_rel :< miscprep_rel.
_concerning_p_rel :< miscprep_rel.
_despite_p_rel :< miscprep_rel.
_down_p_rel :< dir_rel.
_due+to_p_rel :< miscprep_rel.
_during_p_rel :< temp_loc_rel.
_except+for_p_rel :< miscprep_rel.
_except_p_rel :< miscprep_rel.
_excepting_p_rel :< miscprep_rel.
_facing_p_rel :< dir_rel.
_for_p_rel :< miscprep_rel.
_for+example_p_rel :< miscprep_rel.
_for+instance_p_rel :< miscprep_rel.
_for+lack+of_p_rel :< miscprep_rel.
_forth_p_rel :< miscprep_rel.
_forward_p_rel :< miscprep_rel.
_from_p_rel :< miscprep_rel.
_from_p_to_rel :< miscprep_inst_rel.
_from_p_time+on_rel :< miscprep_rel.
_going+by_p_rel :< miscprep_rel.
_hither_p_rel :< miscprep_rel.
_home_p_rel :< miscprep_rel.
_in+accordance+with_p_rel :< miscprep_rel.
_in+addition+to_p_rel :< miscprep_rel.
_in+back+of_p_rel :< dir_or_state_rel.
_in+back+of_p_dir_rel := _in+back+of_p_rel & dir_rel.
_in+between_p_rel :< dir_or_state_rel.
_in+between_p_dir_rel := _in+between_p_rel & dir_rel.
_in+front+of_p_rel :< dir_or_state_rel.
_in+front+of_p_dir_rel := _in+front+of_p_rel & dir_rel.
_in+lieu+of_p_rel :< miscprep_rel.
_in_p_rel :< dir_or_state_rel.
_in_p_dir_rel := _in_p_rel & dir_rel.
_in_p_temp_rel :< temp_loc_rel.
_in+regard+to_p_rel :< miscprep_rel.
_in+spite+of_p_rel :< miscprep_rel.
_in+the+course+of_p_rel :< miscprep_rel.
_in+the+way+of_p_rel :< miscprep_rel.
_inside_p_rel :< dir_or_state_rel.
_inside_p_dir_rel := _inside_p_rel & dir_rel.
_into_p_rel :< dir_rel.
_just+like_p_rel :< miscprep_rel.
_like_p_rel :< miscprep_rel.
_maximum_p_rel :< miscprep_rel.
_nationwide_j_rel :< miscprep_rel.
_near_p_rel :< dir_or_state_rel.
_near_p_dir_rel := _near_p_rel & dir_rel.
_nearby_p_rel :< miscprep_rel.
_next+to_p_rel :< dir_or_state_rel.
_next+to_p_dir_rel := _next+to_p_rel & dir_rel.
_of_p_rel :< of_nontemp_rel.
_off+of_p_rel :< miscprep_rel.
_off_p_rel :< dir_or_state_rel.
_off_p_dir_rel := _off_p_rel & dir_rel.
_on_p_rel :< dir_or_state_rel.
_on_p_dir_rel := _on_p_rel & dir_rel.
_on_p_temp_rel :< temp_loc_rel.
_on_foot_p_rel :< miscprep_rel.
_on+the+basis+of_p_rel :< miscprep_rel.
_on+the+part+of_p_rel :< miscprep_rel.
_onto_p_rel :< dir_rel.
_opposite_p_rel :< dir_rel.
_other+than_p_rel :< miscprep_rel.
_out_p_rel :< dir_or_state_rel.
_out_p_dir_rel := _out_p_rel & dir_rel.
_out+of_p_rel :< miscprep_rel.
_outside_p_rel :< dir_or_state_rel.
_outside_p_dir_rel := _outside_p_rel & dir_rel.
_over_p_rel :< dir_or_state_rel.
_over_p_dir_rel := _over_p_rel & dir_rel.
_overnight_j_rel :< adj_rel.
_past_p_rel :< miscprep_minute_rel.
_per_p_rel :< miscprep_rel.
_previous+to_p_rel :< temp_loc_rel.
_prior+to_p_rel :< temp_loc_rel.
_regarding_p_rel :< miscprep_rel.
_right+away_p_rel :< miscprep_rel.
_since_p_rel :< temp_loc_rel.
_such+as_p_rel :< miscprep_rel.
_than_p_ind_rel :< miscprep_rel.
_then_p_temp_rel :< miscprep_rel.
_thereabouts_p_rel :< miscprep_rel.
_through_p_rel :< miscprep_rel.
_through_p_until_rel :< abstr_until_rel.
_throughout_p_rel :< dir_or_state_rel.
_throughout_p_dir_rel := _throughout_p_rel & dir_rel.
_to+do+with_p_rel :< miscprep_rel.
_to_p_rel :< dir_rel.
_to_p_unsp2_rel :< abstr_until_rel.
_to_p_interval_rel :< miscprep_rel.
_together_p_rel :< miscprep_rel.
_together+with_p_rel :< miscprep_rel.
_toward_p_rel :< dir_rel.
_towards_p_rel :< dir_rel.
_under_p_rel :< dir_or_state_rel.
_under_p_dir_rel := _under_p_rel & dir_rel.
_unlike_p_rel :< miscprep_rel.
_until_p_rel :< abstr_until_rel.
_up_p_rel :< dir_rel.
_uphill_p_rel :< dir_rel.
_up+until_p_rel :< miscprep_rel.
_upon_p_rel :< state_loc_rel.
_upstairs_p_rel :< miscprep_rel.
_via_p_rel :< miscprep_rel.
with_p_rel :< miscprep_rel.
_with_p_rel :< with_p_rel.
_within_p_rel :< dir_or_state_rel.
_without_p_rel :< miscprep_rel.
_worth_p_rel :< miscprep_rel.
_yet_r_rel :< neg_polar_rel.

_anymore_r_rel :< neg_polar_rel.
_any+longer_r_rel :< neg_polar_rel.
_as+of+yet_r_rel :< neg_polar_rel.
_at+all_r_rel :< neg_polar_rel.
_ever_r_rel :< neg_polar_rel.
_nomore_r_rel :< neg_polar_rel.
_or+what_r_rel :< neg_polar_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Determiner preds

_a_few_q_rel :< explicit_quant_noagr_q_rel.
_a_q_rel :< some_q_rel.
_another_q_rel :< explicit_quant_noagr_q_rel.
_any_q_rel :< any_q_rel.
_both_q_rel :< def_explicit_q_rel.
_each_q_rel :< explicit_quant_noagr_q_rel.
_either_q_rel :< explicit_quant_agr_q_rel.
_enough_q_rel :< explicit_quant_agr_q_rel.
_every_q_rel :< every_q_rel.
_few_q_rel :< explicit_quant_noagr_q_rel.
_half_q_rel :< explicit_quant_agr_q_rel.
_less_q_rel :< explicit_quant_noagr_q_rel.
_little_q_rel :< explicit_quant_noagr_q_rel.
_many_q_rel :< much_many_q_rel.
_more_q_rel :< explicit_quant_agr_q_rel.
_most_q_rel :< explicit_quant_agr_q_rel.
_much_q_rel :< much_many_q_rel.
_neither_q_rel :< explicit_quant_noagr_q_rel.
_no_q_rel :< no_q_rel.
_several_q_rel :< explicit_quant_noagr_q_rel.
_some_q_rel :< some_q_rel.
_some_q_indiv_rel :< some_q_rel.
_such_q_rel :< explicit_q_rel.
_that_q_dem_rel :< demon_far_q_rel.
_the+same_q_rel :< explicit_quant_agr_q_rel.
_these_q_dem_rel :< demon_near_q_rel.
_this_q_dem_rel :< demon_near_q_rel.
_those_q_dem_rel :< demon_far_q_rel.
_umpteen_q_rel :< explicit_quant_noagr_q_rel.
_which_q_rel :< which_q_rel.
_a+couple_q_rel :< explicit_quant_noagr_q_rel.
_any+more_q_rel :< explicit_quant_agr_q_rel.
_no+more_q_rel :< explicit_quant_agr_q_rel.
_some+more_q_rel :< explicit_quant_agr_q_rel.
_one+or+more_q_rel :< explicit_quant_noagr_q_rel.
_less+than+a_q_rel :< some_q_rel.
_part_q_rel :< explicit_quant_noagr_q_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Message preds

message_m_rel := predsort.
imp_m_rel := message_m_rel.
;for COMPS of e.g. 'know':
prop_ques_m_rel := message_m_rel.
prpstn_or_like_m_rel := message_m_rel.
propositional_m_rel := prop_ques_m_rel & prpstn_or_like_m_rel.
prpstn_m_rel := propositional_m_rel.
; For interrogatives; PARAMS value is a set of handles.
abstr_int_m_rel := prop_ques_m_rel.
int_m_rel := abstr_int_m_rel.
; Subtype of int_m_rel for tag questions.   
ne_m_rel := abstr_int_m_rel.
; Subtype to distinguish complementizer "like" from "that", to block
; '*Kim said like Sandy left' and '*it looks that Sandy left"
like_mood_m_rel := prpstn_or_like_m_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; pred sorts

predsort := *sort*.
non_number_rel := predsort.
norm_rel := non_number_rel.
event_or_degree_or_no_rel := predsort.
non_conj_rel := predsort.
norm_non_conj_rel := non_conj_rel & norm_rel.
event_or_degree_rel := norm_non_conj_rel & event_or_degree_or_no_rel.
event_rel := event_or_degree_rel.
; Needed to divide two types of head-specifier phrases
num_or_nom_or_degree_rel := predsort.


; Subtypes of this relation are the types for particle semantics in
; verb-particle constructions like _together_rel in "get together"
; DPF 15-Apr-01 - Removed ASPECT no_aspect, since want to let "of" be progr*
; to block e.g. "as of NP"

selected_rel := event_rel.
selected_adj_rel := selected_rel & abstr_adj_rel.
selected_adv_rel := selected_rel & abstr_adv_rel.
selected_prep_rel := selected_rel & prep_rel.

independent_rel := predsort.
non_event_rel := norm_non_conj_rel.
aux_event_rel := event_rel.
aux_arg1_rel := aux_event_rel & v_event_rel.
nonaux_event_rel := predsort.
non_freerel_rel := independent_rel.
no_rel := non_freerel_rel & non_conj_rel & event_or_degree_or_no_rel &
          nonaux_event_rel.
never_unify_rel := predsort.
; For QUE-word complements as in "what the hell"
wh_the_hell_rel := predsort.
norm_dim_rel := norm_non_conj_rel.
basic_event_dim_rel := norm_dim_rel & event_rel.
non_event_dim_rel := non_event_rel & norm_dim_rel.
quant_or_deg_rel := non_event_dim_rel.
i_or_e_quant_or_deg_rel := quant_or_deg_rel.
quant_or_wh_rel := quant_or_deg_rel.
quant_rel := quant_or_wh_rel.
non_freerel_q_rel := non_freerel_rel & quant_rel.
impl_or_expl_q_rel := non_freerel_q_rel & i_or_e_quant_or_deg_rel.
; Used in bare plurals
impl_or_proper_q_rel := quant_rel.
; Used in appositive rule
implicit_q_rel := impl_or_expl_q_rel & impl_or_proper_q_rel.
explicit_q_rel := impl_or_expl_q_rel.
; Determiners with these relations show agreement with of_PP in partitives
explicit_quant_agr_q_rel := explicit_q_rel.
; These don't
explicit_quant_or_udef_noagr_q_rel := impl_or_expl_q_rel.
explicit_quant_noagr_q_rel := explicit_q_rel & 
                              explicit_quant_or_udef_noagr_q_rel.
much_many_q_rel := explicit_quant_noagr_q_rel.
; DPF 19-Oct-02 - This is to allow not only ordinary bare plurals, but also
; for "afternoons" which must be the one that takes an optional PP-of and
; usually requires a definite determiner (unless it's a bare plural)
abstr_def_or_udef_q_rel := quant_rel.
def_or_udef_q_rel := abstr_def_or_udef_q_rel.
udef_q_rel := implicit_q_rel & explicit_quant_or_udef_noagr_q_rel &
              def_or_udef_q_rel.
some_q_rel := explicit_quant_agr_q_rel.
any_q_rel := explicit_quant_agr_q_rel.
every_q_rel := explicit_q_rel.
no_q_rel := explicit_q_rel.
abstr_def_q_rel := def_or_udef_q_rel.
def_q_rel := abstr_def_q_rel & implicit_q_rel.
def_explicit_q_rel := abstr_def_q_rel & explicit_quant_noagr_q_rel.
def_both_rel := def_explicit_q_rel.
; Used only in KEYS.KEY
nondef_explicit_q_rel := explicit_q_rel.
; Used for lexical NPs including proper names
; It is distinct from i_or_e_quant_or_deg_rel to prevent relative clauses
; from attaching to proper names with no specifier.
proper_q_rel := non_freerel_q_rel & abstr_def_or_udef_q_rel &
                impl_or_proper_q_rel.
number_q_rel := non_freerel_q_rel.
pronoun_q_rel :< non_freerel_q_rel.
demonstrative_q_rel :< explicit_q_rel.
demon_near_q_rel :< demonstrative_q_rel.
demon_far_q_rel :< demonstrative_q_rel.
free_relative_ever_q_rel :< quant_rel.
_the_q_rel :< def_explicit_q_rel.
which_q_rel :< explicit_quant_agr_q_rel.
_all_q_rel :< explicit_quant_agr_q_rel.
; For bare plural/mass NPs
bare_div_q_rel :< implicit_q_rel.
idiom_q_rel :< abstr_def_or_udef_q_rel.

dir_state_modable_rel := predsort.
modable_rel := basic_nom_rel & dir_state_modable_rel.
; nontemp_rel used to distinguish temporal nominal phrases from all others
nontemp_or_conj_rel := norm_rel.
nontemp_rel :< nontemp_or_conj_rel.
instance_rel := independent_rel.
basic_nom_or_mnp_rel := num_or_nom_or_degree_rel.
basic_nom_rel := non_event_rel & instance_rel & basic_nom_or_mnp_rel.
nom_or_mnp_rel := basic_nom_or_mnp_rel.
nom_rel := basic_nom_rel & nom_or_mnp_rel.
nonpro_or_mnp_rel := nom_or_mnp_rel.
nonpro_rel := nom_rel & nonpro_or_mnp_rel.
nom_nondim_rel :< nom_rel.
non_temp_nom_rel := nom_nondim_rel & nontemp_rel.
non_temp_nonpro_rel := non_temp_nom_rel & nonpro_rel.
reg_nom_rel := non_temp_nonpro_rel.
modable_nom_rel := non_temp_nonpro_rel & modable_rel.
unspec_diadic_nom_rel := nonpro_rel.
reg_diadic_nom_rel := unspec_diadic_nom_rel & reg_nom_rel.
basic_diadic_modable_nom_rel := unspec_diadic_nom_rel & modable_rel.
diadic_modable_nom_rel := basic_diadic_modable_nom_rel & modable_nom_rel.
basic_hcomp_nom_rel := non_temp_nonpro_rel.
hcomp_nom_rel := basic_hcomp_nom_rel & reg_nom_rel.
hcomp_modable_nom_rel := basic_hcomp_nom_rel & modable_rel.
nominalize_rel := basic_hcomp_nom_rel.
gerund_rel := non_temp_nom_rel.
apposition_rel :< nom_rel.
; Non-appositional nouns
norm_nom_rel :< reg_nom_rel.
temp_abstr_or_conj_rel := predsort.
temp_abstr_rel := nonpro_rel & temp_abstr_or_conj_rel.
temp_nondim_rel :< temp_abstr_rel.
; Used in munging rules to make reversible the implicit quantifier
abstr_named_rel :< norm_rel.
gen_named_rel := abstr_named_rel.
named_np_or_num_rel :< gen_named_rel.
abstr_named_np_rel :< named_np_or_num_rel.
named_np_rel := abstr_named_np_rel & reg_nom_rel.
;named_num_rel := abstr_named_np_rel & reg_nom_rel & card_rel & apposition_rel.
named_num_or_seq_rel :< nom_rel.
named_num_rel := named_np_or_num_rel & apposition_rel & non_temp_nonpro_rel &
                 named_num_or_seq_rel.
num_seq_nom_rel := named_num_or_seq_rel & non_temp_nom_rel & 
		   named_np_or_num_rel.
named_card_rel := named_num_rel & card_rel.
named_times_rel := named_num_rel & times_rel.
named_plus_rel := named_num_rel & plus_rel.
elliptical_n_rel :< diadic_nom_rel.
; Relation used in decomposed lexical semantics, e.g. for 'when'
temp_rel := abstr_named_rel & modable_rel & temp_abstr_rel.
day_rel :< temp_nondim_rel.
diadic_day_rel := day_rel & unspec_diadic_nom_rel & modable_rel.
named_day_rel := diadic_day_rel & abstr_named_np_rel.
unnamed_day_rel :< diadic_day_rel.
; DPF 10-Oct-02 - Need to allow measure-NPs to be complements of temporal "in",
; as in "I'll be finished in two chapters".
non_day_or_deg_rel :< norm_rel.
non_day_rel := temp_nondim_rel & non_day_or_deg_rel.
;; day_of_month_rel
dofm_rel := diadic_day_rel & gen_named_rel.
;; Need supertype of dofw_rel and pro_poss_rel and non-'the' quantifiers
;; for the specifier of the small class of words like "morning" as in "my 
;; mornings" or "Tuesday mornings"
dofw_or_poss_q_rel :< norm_rel.
;; day_of_week_rel
dofw_rel := named_day_rel & dofw_or_poss_q_rel.
holiday_rel := non_day_diadic_rel & gen_named_rel.
day_part_rel := diadic_day_rel.
; dim_rel: 'almost three o'clock'
; DPF 2-Apr-02 - Added type for hour_rel and _time_rel, to get both "at three"
; and 'at that time" while distinguishing "kim fell three times" from "*Kim
; fell three o'clock"
hour_or_time_rel := predsort.
hour_rel := temp_abstr_rel & norm_dim_rel & hour_or_time_rel.
_breakfast_n_time_rel :< hour_rel.
_dinner_n_time_rel :< hour_rel.
_lunch_n_time_rel :< hour_rel.
_supper_n_time_rel :< hour_rel.
_tea_n_time_rel :< hour_rel.
_night_n_time_rel :< hour_rel.
_minute_n_rel :< modable_hour_or_time_rel.
; a quarter till three  ("till" is head - cf "come at a quarter till.")
hour_prep_rel := hour_rel.
; prep_rels that can modify hour times as in "ten minutes after five"
minute_prep_rel := predsort.
; 'past'
miscprep_minute_rel := miscprep_rel & minute_prep_rel.
; 'after'
tempprep_minute_rel := temp_loc_abstr_rel & minute_prep_rel.
numbered_hour_rel := hour_rel & abstr_named_rel.
; DPF 31-Jul-99 - Changed minute_or_ampm_rel to be non-temp, since it cannot
; appear after temporal prepositions (ignoring the elliptical "I'll see you 
; in ten"), and we also need to block "from ten to eleven o'clock" with
; "ten" as minute.
minute_or_ampm_rel :< nom_nondim_rel.

modable_hour_rel :< non_day_diadic_modable_rel.

modable_hour_or_time_rel := modable_hour_rel & hour_or_time_rel.

_second_n_rel :< non_day_diadic_modable_rel.

am_pm_rel :< minute_or_ampm_rel.

ctime_rel :< numbered_hour_rel.

; 'the morning', not 'some morning': 'in the morning' but 'on some morning'
def_day_part_rel :< non_day_diadic_modable_rel.
_afternoon_n_def_rel :< def_day_part_rel.
_evening_n_def_rel :< def_day_part_rel.
_morning_n_def_rel :< def_day_part_rel.
_night_n_def_rel :< def_day_part_rel.
_weekend_n_def_rel :< def_day_part_rel.

non_day_diadic_rel := non_day_rel & unspec_diadic_nom_rel.
non_day_modable_rel := non_day_rel & modable_rel.
non_day_diadic_modable_rel := non_day_diadic_rel & modable_rel.
non_day_nonmodable_rel :< non_day_rel.

;; named_month_rel as in "January is fine"
;; DPF 13-Mar-02 - Changed parent non_day_diadic_modable_rel to 
;; non_day_diadic_rel since we were overgenerating: "*Kim arrived June" in 
;; order to admit "Kim arrived last June".  Have to do something else to
;; allow the latter.
mofy_rel := non_day_diadic_rel & abstr_named_np_rel.

yofc_rel := non_day_rel & abstr_named_np_rel.

season_rel := non_day_modable_rel & gen_named_rel.
season_nomod_rel := non_day_rel & gen_named_rel.

age_rel :< non_day_nonmodable_rel.
_while_n_rel :< non_day_nonmodable_rel.

_morning_n_rel :< day_part_rel.
_afternoon_n_rel :< day_part_rel.
_evening_n_rel :< day_part_rel.
_night_n_rel :< day_part_rel.
_weekend_n_rel :< day_part_rel.
_day_n_rel :< unnamed_day_rel.

_week_n_rel :< non_day_diadic_modable_rel.
_month_n_rel :< non_day_diadic_modable_rel.
_year_n_rel :< non_day_diadic_modable_rel.
_quarter_n_temp_rel :< non_day_diadic_modable_rel.

duration_rel :< temp_rel.

named_rel := named_np_rel & apposition_rel.
named_abb_rel :< named_np_rel.
named_n_rel := gen_named_rel & reg_nom_rel.

;gen_numval_rel := modable_nom_rel.
gen_numval_rel := non_temp_nonpro_rel.
gen_currency_rel :< reg_nom_rel.

; For X to Y constructions
;interval_rel :< diadic_modable_nom_rel.

interval_rel := unspec_diadic_nom_rel.

;; The relation event_or_mod_rel is designed to distinguish non-nominal signs, 
;; including verbs, adjectives, prepositions, and adverbs.  One use of this 
;; distinction is for the conjuncts accepted by "but": "*Kim but Sandy left."

event_or_mod_rel := predsort.

mod_rel :< event_or_mod_rel.

event_mod_rel := event_rel & mod_rel.
event_arg_dim_rel := event_mod_rel & basic_event_dim_rel.
event_dim_rel := basic_event_dim_rel & nonaux_event_rel.
independent_mod_rel := independent_rel & mod_rel.
abstr_excl_rel := independent_mod_rel.

greet_rel :< abstr_excl_rel.

excl_rel :< abstr_excl_rel.
basic_pron_rel := non_temp_nom_rel & abstr_named_rel.
pron_rel := basic_pron_rel.
; Margaret herself just arrived.
refl_pron_rel := non_temp_nonpro_rel & apposition_rel.
recip_pro_rel := non_temp_nonpro_rel.
generic_nom_rel := non_temp_nonpro_rel.
; For partitives
generic_nonpro_rel := nonpro_rel.

basic_adj_rel := event_dim_rel & nontemp_rel.
abstr_adj_rel := basic_adj_rel & event_arg_dim_rel.
adj_rel := abstr_adj_rel & independent_mod_rel.
expl_adj_rel := basic_adj_rel & independent_rel.
it_adj_rel := abstr_adj_rel.
meas_adj_rel := abstr_adj_rel.
adj_personal_rel :< adj_rel.
adj_abstract_rel :< adj_rel.
verb_aspect_rel := event_rel & independent_rel.

prog_rel :< verb_aspect_rel.

v_event_rel := verb_aspect_rel & event_arg_dim_rel.

mod_role_rel :< v_event_rel.

no_role_rel :< mod_role_rel. 

weather_v_rel := no_role_rel & nonaux_event_rel.

role_rel := mod_role_rel & nontemp_rel & nonaux_event_rel.

modal_rel := aux_arg1_rel.
_can_v_rel :< modal_rel.
_could_v_rel :< modal_rel.
_dare_v_aux_rel :< modal_rel.
_may_v_rel :< modal_rel.
_might_v_rel :< modal_rel.
_must_v_rel :< modal_rel.
_need_v_aux_rel :< modal_rel.
_ought_v_rel :< modal_rel.
_shall_v_rel :< modal_rel.
_should_v_rel :< modal_rel.
_used+to_v_aux_rel :< modal_rel.
_had+better_v_rel :< modal_rel.
ellipsis_rel := v_event_rel.
; Used to ensure tag question agreement, but will not appear in RELS.
have_aux_rel := v_event_rel & aux_event_rel.

; Needed to allow filtering of the relations for "will" and "would" for VIT.
will_would_rel :< aux_arg1_rel.
_will_v_aux_rel :< will_would_rel.
_would_v_rel :< will_would_rel.
_going+to_v_rel :< will_would_rel.
would_like_rel := predsort.
; AAC - added for frag-msg
abstr_1_rel := basic_nom_rel.
; AAC - added for wh_adjective_word
abstr_nom_rel := event_mod_rel & basic_nom_rel.
support_rel :< no_role_rel.
prep_rel := event_dim_rel.
basic_prep_mod_rel := prep_rel & event_arg_dim_rel & independent_rel.
prep_mod_rel :< basic_prep_mod_rel.
basic_poss_rel := basic_prep_mod_rel.
poss_rel := basic_poss_rel & prep_mod_rel.
pro_poss_rel := basic_poss_rel & dofw_or_poss_q_rel.
nontemp_prep_rel := prep_mod_rel & nontemp_rel.
loc_abstr_rel :< prep_mod_rel.
dir_or_state_rel := loc_abstr_rel & nontemp_prep_rel & dir_state_modable_rel.
dir_rel :< dir_or_state_rel.
state_loc_rel :< dir_or_state_rel.
generic_loc_rel :< loc_abstr_rel.

temp_loc_abstr_rel :< loc_abstr_rel.
unspec_temp_loc_abstr_rel := temp_loc_abstr_rel & unspec_loc_rel.

miscprep_rel :< nontemp_prep_rel.

temp_loc_rel := temp_loc_abstr_rel & independent_mod_rel.

part_of_rel :< reg_diadic_nom_rel.
diadic_nom_rel := reg_diadic_nom_rel & norm_nom_rel.
diadic_nom_appos_rel := unspec_diadic_nom_rel & apposition_rel.

loc_rel :< dir_or_state_rel.

; Used for implicit locative, as in "Kim arrived Tuesday"
unspec_loc_rel :< loc_rel.

miscprep_inst_rel := miscprep_rel & instance_rel.

interval_start_rel :< miscprep_rel.
interval_end_rel := miscprep_rel.

; For "how"
unspec_manner_rel :< miscprep_rel.

abstr_adv_rel := independent_mod_rel & non_event_rel.

abstr_adv_dim_rel := abstr_adv_rel & non_event_dim_rel.

adv_rel :< abstr_adv_dim_rel.

neg_rel :< abstr_adv_rel.
_never_r_rel :< abstr_adv_rel.

neg_polar_rel :< abstr_adv_dim_rel.

degree_rel := num_or_nom_or_degree_rel & independent_rel & event_or_degree_rel
              & i_or_e_quant_or_deg_rel & non_day_or_deg_rel.
comp_degree_rel :< degree_rel.
non_comp_degree_rel :< degree_rel.

; For the subset of specifiers needed for adjectives (but not, e.g., subconj)
much_or_very_deg_rel := degree_rel & nonpro_or_mnp_rel.

; For specifiers of adjectives
deg_rel :< non_comp_degree_rel.

; For specifiers of positive adjectives
very_deg_rel := deg_rel & much_or_very_deg_rel.

; For degree specifiers "this/that/too/as" as in "that much", "so tall"
this_that_deg_rel :< very_deg_rel.
; For as..as, too..to
comp_as_too_degree_rel := this_that_deg_rel & comp_more_less_rel.

; For specifiers of "the", including "only" and "just"
just_only_degree_rel :< degree_rel.
just_only_very_deg_rel := just_only_degree_rel & very_deg_rel.
just_only_deg_rel := just_only_degree_rel & deg_rel.

; For "how" degree specifier
abstr_deg_rel :< this_that_deg_rel.

; For specifiers of comparative adjectives
much_deg_rel := deg_rel & much_or_very_deg_rel.
; To constrain adjectives to only take "much", as with modifiee of "than Sandy"
much_deg_only_rel :< much_deg_rel.

; For conjoined spr-less adjectives as in "sunny and cooler"
; DPF 5-Sep-03 - But this eliminates the blocking of inappropriate degree specs
; for head that want only one or the other.
;;very_and_much_deg_rel := very_deg_rel & much_deg_rel.

; For e.g. 'eightish'
approx_grad_rel :< deg_rel.

; For syntactic rules (for indexing for generation)
gen_deg_rel :< deg_rel.
comparative_rel := comp_degree_rel.
comp_more_less_rel := comparative_rel.
_more_x_comp_rel :< comp_more_less_rel.
_less_x_comp_rel :< comp_more_less_rel.
comp_most_least_rel := comparative_rel.
_most_x_comp_rel :< comp_most_least_rel.
_least_x_comp_rel :< comp_most_least_rel.
;; For "how" adjective, which quantifies over properties.
property_rel :< reg_nom_rel.
prpstn_to_prop_rel := event_rel.
comp_rel := miscprep_rel.
superl_rel := miscprep_rel.
; Abstract prep relations

of_or_about_rel := prep_rel.
of_nontemp_rel := of_or_about_rel & nontemp_prep_rel.
of_miscprep_rel := of_or_about_rel & miscprep_rel.

; Needed for idiosyncratic decomposition of "why"
cause :< miscprep_rel.

subord_rel := independent_rel & norm_rel.
cop_id_rel :< v_event_rel.
_be_v_id_rel :< cop_id_rel.
title_id_rel := cop_id_rel.
person_name_rel := cop_id_rel.
unspec_adj_rel :< adj_rel.
number_rel :< reg_diadic_nom_rel.
quantity_rel :< reg_diadic_nom_rel.
_be_v_prd_rel := v_event_rel & aux_event_rel.
_dollar_n_rel :< norm_nom_rel.

unspec_rel := prep_rel.
; Used for vocatives.
unspec_mod_rel :< prep_mod_rel.

abstr_until_rel :< prep_mod_rel.
until_min_rel := abstr_until_rel & minute_prep_rel.

; Relation introduced for tag questions
probable_rel :< adj_rel.

; For comparative "as possible" (hack)
possible_rel :< adj_rel.

basic_conj_rel := non_freerel_rel & nontemp_or_conj_rel & 
            temp_abstr_or_conj_rel.
conj_rel := basic_conj_rel.
_and_c_rel :< conj_rel.
_and_c_or_rel :< conj_rel.
_as+well+as_c_rel :< conj_rel.
_but_c_rel :< conj_rel.
_but+not_c_rel :< conj_rel.
_minus_c_rel :< conj_rel.
_nor_c_rel :< conj_rel.
_or_c_rel :< conj_rel.
_plus_c_rel :< conj_rel.
_rather+than_c_rel :< conj_rel.
_instead+of_c_rel :< conj_rel.
_so_c_rel :< conj_rel.
_versus_c_rel :< conj_rel.
_except+that_c_rel :< conj_rel.
_both_c_rel :< conj_rel.
_either_c_rel :< conj_rel.
_neither_c_rel :< conj_rel.
_etc_c_rel :< conj_rel.
; For fragments
discourse_rel :< conj_rel. 
; For number sequences
num_seq_rel :< conj_rel.

abstr_place_rel := basic_diadic_modable_nom_rel & non_temp_nonpro_rel.
place_rel := abstr_place_rel & abstr_named_rel.
_place_n_rel :< place_rel.

time_rel := modable_rel & temp_abstr_rel.
_time_n_rel :< time_rel.
_awhile_n_rel :< time_rel.
person_rel :< reg_nom_rel.
thing_rel :< reg_nom_rel.
next_prev_rel :< adj_rel.
manner_rel :< reg_nom_rel.
reason_rel := reg_nom_rel & abstr_named_rel.
title_rel := basic_nom_rel.
; 'Next week, last night, all day'
_next_j_rel := next_prev_rel & dofw_or_poss_q_rel.
_last_j_rel := adj_rel & dofw_or_poss_q_rel.
_all_j_rel := adj_rel & dofw_or_poss_q_rel.
_late_j_next+last_rel := adj_rel & dofw_or_poss_q_rel.
v_event_arg1_rel := aux_event_rel & v_event_rel.
_be_v_there_rel :< v_event_arg1_rel.
_exist_v_there_rel :< v_event_arg1_rel.
_have_v_to_rel :< modal_rel.
_got_v_to_rel :< v_event_arg1_rel.

integer_rel := num_or_nom_or_degree_rel & independent_mod_rel.
const_rel := integer_rel & gen_named_rel.
plus_rel := integer_rel.
times_rel := integer_rel.
ord_rel :< const_rel.
card_rel :< const_rel.
; DPF 23-May-03 - minute_n_rel is never in a predicative adjective lexeme, so
; we can identify its ARG0 with its ARG1, to allow ordinary cardinal adjectives
; to specialize to minute semantics and let hour-words get the ARG0 index of
; the minute_rel by asking for the lexeme's HOOK.INDEX which is reentrant with
; ARG1 like ordinary adjectives.
minute_rel :< card_rel.
range_num_rel :< const_rel.
fraction_rel :< const_rel.
unknown_rel :< v_event_rel.