;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright (c) 1994-2005
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see erg/licence.txt for conditions
;;;
;;;  fundamentals.tdl
;;;
;;;  Basic definitions of types for English grammar
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign_min := *avm* &
  [ SYNSEM synsem_min,
    KEY-ARG bool ].

;; ROBUST used to enable ungrammatical phrases such as missing det for sg-noun
;; POSSCL marks whether sign contains a possessive clitic.
;; IDIOM marks whether sign contains an idiomatic element.
;; --SIND is re-entrant with HOOK.INDEX, to help modularize path specs,
;; and to delay expansion of subcategorizations until necessary.
sign := sign_min &
  [ SYNSEM synsem &
           [ LOCAL.CONT.HOOK.INDEX #index,
             --SIND #index ],
    ARGS *list*,
    INFLECTD bool,
    ROBUST bool,
    POSSCL bool,
    IDIOM bool,
    STEM *list* ].

phrase_or_lexrule := sign &
  [ SYNSEM canonical_synsem &
	   [ LOCAL.CONT.HOOK #hook,
             PHON.ONSET #onset ],
    C-CONT mrs_min & [ HOOK #hook ],
    ARGS.FIRST.SYNSEM.PHON.ONSET #onset ].

word_or_lexrule_min := sign_min.

; ALTS allow lexical entries to block lexical rule application
word_or_lexrule := word_or_lexrule_min & sign &
  [ ALTS alts_min ].

word := word_or_lexrule &
  [ POSSCL - ].

; Not all phrases have SYNSEM phr_synsem, since we need to allow the head-comp
; rules to build signs which are still [ SYNSEM lex_synsem ], for constructions
; like "twenty-two" and "five fifteen p.m.".  So most phrases will assign the
; type phr_synsem to the value of SYNSEM, but not all.

; DPF 02-Sept-00 - Removed [ HC-LEX - ] because it blocks conjoined lexical
; somethings.

phrase := phrase_or_lexrule &
  [ SYNSEM.LOCAL.ARG-S < > ].


; DPF (09-Jan-99) - Added boolean LEX feature to be used for determining the
; head-complement type of the projections of lexical heads - most produce 
; phrases, but see discussion of HC-LEX feature below.

synsem_min := *avm*.

synsem_min0 := synsem_min &
  [ LOCAL mod_local ].

synsem_min1 := synsem_min0 &
  [ OPT bool,
    LEX luk,
    ROOT bool,
    NONLOC non-local_min,
    MODIFD xmod,
    --SIND *top*,
    PHON phon,
    PUNCT punctuation_min ].

lex_or_phrase :< synsem_min1.

synsem := synsem_min1.

expressed_synsem :< synsem.

canonical_synsem := expressed_synsem.

canonical_lex_or_phrase_synsem := canonical_synsem & lex_or_phrase &
  [ LOCAL local_min ].
    
phr_synsem := canonical_lex_or_phrase_synsem &
  [ LEX - ].

; LKEYS provide shortcuts to relations in RELS or a lex-entry's complements
abstr_lex_synsem := canonical_lex_or_phrase_synsem &
  [ LKEYS lexkeys ].           
    
basic_lex_synsem :< abstr_lex_synsem.

lex_synsem := basic_lex_synsem &
  [ LEX +].

; For signs that are constructed by syntactic rule but have similar
; (though not identical) distribution to lexical items - e.g. n_n_cmpnds.
lex_phr_synsem := abstr_lex_synsem &
  [ LEX + ].

; For signs that have combined with a punctuation mark, and hence are no
; longer eligible to undergo derivational rules, to avoid spurious ambiguity.
lex_punct_synsem := basic_lex_synsem.

; DPF 29-Nov-02 - Removed [INDEX non_expl] to allow "There was known to be a
; problem" where pred "was" requires complement to be SUBJ *olist*.
non_canonical := synsem.
expressed_non_canonical := non_canonical & expressed_synsem.

gap := expressed_non_canonical &
  [ LOCAL #local,
    NONLOC [ REL 0-dlist,
		QUE 0-dlist,
		SLASH 1-dlist &
		    [ LIST < #local > ] ] ].

unexpressed_min := synsem_min.
unexpressed := unexpressed_min & synsem_min1 &
  [ NONLOC [ SLASH 0-dlist,
                REL 0-dlist,
		QUE 0-dlist ] ].

unexpressed_reg := unexpressed & non_canonical.

; DPF 28-Aug-99 - Removed OPT + from anti_synsem since it blocked 
; "you can have anything you want"
anti_synsem_min :< unexpressed_min.
anti_synsem := anti_synsem_min & unexpressed.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT type

;; The feature MC has three possible values: +, -, and na.  Non-clauses are
;; always MC na, since they can't really be said to be root or non-root.
;; All clauses are MC bool, and if they have a restricted distribution then
;; they are MC + or MC -.

local_basic := local_min &
  [ CONJ conj ].

local := local_basic &
  [ CTXT ctxt_min,
    ARG-S *list* ].

non-local := non-local_min &
  [ SLASH 0-1-dlist,
    QUE *diff-list*,
    REL 0-1-dlist ].

non-local_norel := non-local &
  [ QUE 0-dlist,
    REL 0-dlist ].

non-local_none := non-local_norel &
  [ SLASH 0-dlist ].

;; For unrealized extracted adjuncts needed in relative clauses, as in 
;; "the day he arrived"
unexpr_local :< local_basic.

;; For exceptions to lexical rules
alts_min :< *avm*.
alts := alts_min &
  [ PASSIVE bool,
    VPELLIP bool,
    NPPART  bool ].
no_alts :< alts_min.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsem values

; The feature AGR is introduced on LOCAL rather than on CAT (or on HEAD) since
; coordination schema unify the CAT value of the daughters with that of then
; mother, but need to be able to change AGR on the mother (to get plural 
; agreement on verb when subject is a coordinated NP with "and" vs. "or").  

cat_min :< *avm*.

;; DPF (22-Oct-98) Added feature HC-LEX ("is head-complement type lexical?")
;; on CAT, to identify the type of synsem that results from combining the word 
;; with its complements.  We recognize at least the head-complement 
;; structures  "thirty-two" and "two o'clock" as still being lexical signs, not
;; phrasal ones, since they can appear as prenominal adjectives and in noun-
;; noun compound constructions, respectively.  The head-complement rule 
;; determines its SYNSEM type by unifying its LEX value with the HC-LEX of
;; its head dtr - this works because the HCOMP rule requires its SYNSEM value to
;; be of type canonical_synsem, and the subtypes of canonical_synsem are the
;; only types that introduce the feature LEX, namely lex_synsem and phr_synsem.

; DPF 2-Jun-02 - Similarly, words differ in whether the head-specifier
; construction they head is lexical or phrasal: det+noun is phrasal to avoid
; allowing e.g. "*my the sony laptop arrived" but deg+adj is still lexical to
; avoid "*the children very small arrived" (given other constraints for each
; of these two constructions).  So introduce HS-LEX value.


cat := cat_min &
  [ HEAD head_min,
    VAL valence_min,
    MC luk,
    POSTHD bool,
    HC-LEX luk,
    HS-LEX luk ].

local_min := mod_local &
  [ CAT cat_min,
    CONT mrs_min,
    AGR *top* ].

non-local_min :< *avm*.

phon := *avm* &
  [ ONSET onset ].

onset := *sort*.
con := onset.
voc := onset.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Head and valence
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mod_local :< *avm*.

; The MOD value specifies the type of phrase that a sign can modify, and the
; POSTHD value stipulates the relative position of the modifier with
; respect to the head.  (An earlier approach employing a generalization about
; a head being final in its phrase or not might still be considered as an
; alternate to this stipulative one.)
; The POSTHD feature should stay with MOD, since only relevant when MOD is
; non-empty.

; DPF 09-Jan-99 - Changed value of MOD to be of type synsem rather than type
; local, since some modifiers (like vocative NPs) only modify SLASH-empty
; phrases, which means they have to have access to the NONLOC feature of
; the phrase they modify.

head_min :< *avm*.

; DPF 16-Aug-99 - Added INV to head type, since need to distinguish root
; from non-root phrases as output from parser, and since inverted S's now have
; MSG empty, we have to require all non-root fragments to be INV -.

head := head_min &
  [ MOD *list*,
    PRD bool,
    KEYS keys,
    INV bool,
    AUX luk,
    TAM tam_min,
    CASE case ].

valence_min :< *avm*.

valence := valence_min &
  [ SUBJ *list*,
    SPR *list*,
    COMPS *list* ].

valence_full := valence &
  [ SPEC *list* ].

; KCMP is a pointer to a distinguished ('key') complement synsem, used in
; generalizations within the lexical type hierarchy, but not present in the
; syntax.
valence_lex := valence_full &
  [ KCMP *avm* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

poss-able := head_min &
  [ POSS bool ].

disc_adverbee :< head.

subst_or_func :< head.
func :< subst_or_func.

det := func & poss-able.

n_or_p_or_v_or_adv :< head.
n_or_p_or_v := n_or_p_or_v_or_adv & subst.

p_or_adv_or_dadv :< head.
a_or_p_or_adv :< head.
p_or_adv := n_or_p_or_v_or_adv & p_or_adv_or_dadv & a_or_p_or_adv.
subst_or_adv :< head.

subst := subst_or_func & subst_or_adv.

v_or_g_or_p :< subst.

v_or_a_or_p :< subst.

a_or_adv :< a_or_p_or_adv.

n_or_p_or_frag :< head.

n_or_p_or_a :< subst.

n_or_v_or_a :< subst.

n_or_p :=  n_or_p_or_v & n_or_p_or_frag & n_or_p_or_a.
n_or_a :< n_or_v_or_a.
; DPF 3-apr-05 - Added poss-able to allow for locative inversion using subjh.
a_or_p := v_or_a_or_p & n_or_p_or_a & a_or_p_or_adv & poss-able.
v_or_p := v_or_a_or_p & n_or_p_or_v.
n_or_v := n_or_p_or_v & n_or_v_or_a.

n_or_adv :< head.
nom_or_ttl :< poss-able.

; Adverbs modify adverbees.
adverbee :< head.

v_or_g_or_a :< subst.
v_or_g := v_or_g_or_a & v_or_g_or_p & verb_or_frag.

nominal_or_verbal := subst.

nominal := nominal_or_verbal & poss-able.

verbal := v_or_g & nominal_or_verbal & adverbee & disc_adverbee.

; mobile things can be extracted in the complement-extraction rule, from which
; we exclude nominative-case NPs by not making all NPs mobile.

mobile :< head.
adj_or_intadj := n_or_a & a_or_p.

v_or_a := v_or_g_or_a & n_or_v_or_a.
; DPF 7-mar-05 - Make adj subtype of nominal_or_verbal so PPs can modify APs,
; in order to admit "towns not obvious on the map"
adj := a_or_adv & v_or_a & adverbee & mobile & adj_or_intadj & 
       nominal_or_verbal.

prep_or_modnp :< head.

; DPF 26-Jul-99 - Made prep not inherit from adverbee, since in general
; don't want adverbs modifying PPs.
; DPF 17-Dec-01 - But need to have at least some adverbs modifying PPs: 
; "The books currently in the store include ..."

prep := a_or_p & v_or_p & n_or_p & mobile & prep_or_modnp & v_or_g_or_p &
        p_or_adv & adverbee.

; For result of npadv_mod non-branching rule
; Need mobile for "where did i put it"

modnp := n_or_p & nominal & prep_or_modnp & mobile & a_or_adv & v_or_a_or_p.

supnoun :< nominal.

; for both nominal and verbal gerunds
noun_or_gerundive := supnoun.
noun_or_nomger := noun_or_gerundive & n_or_p & nom_or_ttl.
noun_or_gerund := noun_or_gerundive.

noun := n_or_v & n_or_a & noun_or_nomger & n_or_adv & noun_or_gerund.

; DPF 10-Apr-02 - Added n_or_p since want to allow gerunds to undergo noptcomp
; rule, to get e.g."way of saying that Kim arrives"
gerund := noun_or_gerund & adverbee & v_or_g & n_or_v & n_or_p & disc_adverbee.

; For no-copula and run-on sentences
verb_or_frag := head &
  [ VFORM vform ].

; Added poss-able to allow s's as subjects of quoting verbs, as in
; 'Kim arrived said Sandy.'
verb := verbal & v_or_p & n_or_v & v_or_a & poss-able &
  [ VOICE voice ].

comp := nominal & verbal.

basic_adv := func & subst_or_adv.

; 'not' and closed class of other adverbs that can be added to aux COMPS list
; via 'adv_addition' lexical rule.
basic_lexadv := basic_adv & disc_adverbee.
negadv := basic_lexadv & adverbee.
lexadv :< basic_lexadv.

reg_adv := basic_adv & disc_adverbee & p_or_adv &
           a_or_adv & n_or_adv.
adv := reg_adv & mobile.
adv_nonmob :< reg_adv.
deg_adv :< basic_adv.
root-marker := v_or_g & adverbee & p_or_adv_or_dadv.
wh_adv :< func.
; For titles like "Mr" or "Professor", not to be confused with nouns
ttl := func & nom_or_ttl & a_or_p_or_adv.

detspec :< func.

; Hack used in blocking unwanted affixes
no_head := subst_or_func.

; Types for punctuation and string boundaries.

punct_hd := head.

punct_pair_hd := func.
quote_punct_hd := punct_pair_hd.
dq_punct_hd := quote_punct_hd.
sq_punct_hd := quote_punct_hd.
lq_punct_hd := sq_punct_hd.
lp_punct_hd := punct_pair_hd.
rp_punct_hd := punct_pair_hd.

nomger := noun_or_nomger.
nomger_mob := nomger & mobile & [ CASE acc ].

; The following types are used to enable strict subcategorization (the usual 
; case)

noun_mob := noun & mobile & [ CASE acc ].
partn := noun.
partn_mobile := partn & mobile.
gerund_mob := gerund & mobile & [ CASE acc ].
; For 'long' of 'for too long'
grad_n := noun & mobile & [ CASE acc ].
interv_n := noun.

; For types that can undergo number-partitive:'five of them','ten feet of rope'
adj_partitive :< subst_or_func.
intadj_or_superl :< adj_partitive.
superl_adj := intadj_or_superl.

; For measure-NPs
noun_meas := noun & adj_partitive.

; For tag questions, which can't be verbal in order to avoid being root S's.
tagaux := subst_or_func.

; For fragments of all kinds
frag := subst_or_func & verb_or_frag &
  [ MOD < > ].

; For run-on sentence conjunction (to avoid spurious modifier ambiguity)
conj-s := verbal.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

strict_sort :< *sort*.

; Person and number represented as atomic sorts, with gender a separate attrib
; relevant for 3sg, and where count/mass distinction only for 3sg neuter.

pernum :< *sort*.
1or3sg :< pernum.
non3sg :< pernum.
non1sg :< non3sg.
2per :< non1sg.
3per :< pernum.
1or3pl :< non1sg.
1per := 1or3sg & non3sg.
1per+non1sg := 1per & non1sg.

1sg :< 1per.
1pl :< 1or3pl.
2sg :< 2per.
2pl :< 2per.
3pl := 1or3pl & 3per.
3sg := 1or3sg & 3per.

; For unspecified pernum, to constrain generator introducing e.g. 'am' when
; an argument position is unbound.
unsp_pernum :< pernum.

gender :< *sort*.
real_gender :< gender.
animate := real_gender.
masc :< animate.
fem :< animate.
neut :< real_gender.
andro :< animate.
andro1 :< animate.

; The following two are used in tag questions to block mismatched expletive
; pronouns in main clause and tag, since we can't block on unified index
; values, since in general tag questions introduce a pronoun which must have
; a unique index bound by the quantifier it (now) introduces lexically.
no_gend_it := gender.
no_gend_there := gender.

png := *avm* & 
  [ PN pernum,
    GEN gender ].

; ERB declarative and interrogative seem to form a natural class
; in that 'know', 'guess', 'suspect' ... take either.  The type
; decl_int is meant to reflect this.  
; ERB (23-07-96) declarative and imperative also form a class 
; with respect to tag questions.  The type decl_imp is meant to
; reflect this.

cl_mode :< *sort*.
no_cl_mode :< cl_mode.
relative :< cl_mode.
decl_int :< cl_mode.
decl_imp :< cl_mode.
declarative := decl_int & decl_imp.
interrogative :< decl_int.
imperative :< decl_imp.


voice :< *sort*.
active :< voice.
passive :< voice.
act+pass := active & passive.

mood :< *sort*.
ind_or_mod_subj :< mood.

strict_ind_or_mod_subj := ind_or_mod_subj & strict_sort.
indicative :< strict_ind_or_mod_subj.
modal_subj :< strict_ind_or_mod_subj.
subjunctive :< mood.

prontype :< *sort*.
real_pron :< prontype.
std_pron :< real_pron.
recip :< real_pron.
refl :< real_pron.
impers :< real_pron.
demon :< real_pron.
zero_pron :< real_pron.
not_pron :< prontype.

; Three-valued sort evoking Polish logician Jan Lukasiewicz
luk :< *sort*.
; NA for Not Applicable.  
na_or_+ :< luk.
na_or_- :< luk.
bool :< luk.
na := na_or_+ & na_or_-.


+ := bool & na_or_+.
- := bool & na_or_-.

; Three-valued sort for distinguishing unmodified signs from both left-modified
; and right-modified signs
; LPERIPH and RPERIPH indicate whether this modifier is left- or 
; right-peripheral in its phrase - e.g., "the IBM temporary employees" but 
; "*the IBM five employees", and similarly "chairs I buy that you like are
; expensive" but "*chairs that you like I buy are expensive"

xmod := *sort* &
  [ LPERIPH luk,
    RPERIPH luk ].

notmod_or_rmod :< xmod.
notmod_or_lmod :< xmod.
notmod := notmod_or_rmod & notmod_or_lmod.

hasmod :< xmod.
lmod := hasmod & notmod_or_lmod.
rmod := hasmod & notmod_or_rmod.

; One of a grammatically salient inventory of semantic sorts, such as
; 'animate' or 'time'

semsort :< *sort*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT types

basic_semarg :< *avm*.
nothing :< basic_semarg.

semarg := basic_semarg &
  [ INSTLOC string ].

handle :< semarg.
individual_min := basic_semarg.

individual := individual_min & semarg &
 [ SORT *sort* ].

; DIVISIBLE distinguishes singular count nouns from plural and mass nouns,
; for determiners like "some", and for bare-plural NPs.

index := individual &
  [ PNG png,
    DIVISIBLE bool ].
    
; Moved SORT to individual, since need to allow constraint to affect events too
full_index := index &
  [ PRONTYPE prontype ].

; This is the type of the index of the phrase modified by predicative PPs, which
; can either modify a ref-ind nominal or an event VP.

non_expl :< individual.

; DPF 19-Feb-04 - Added --TPC and --PSV features as an experiment in
; controlling extraction and passivization during generation.  A negative
; value for --TPC signifies that no arguments or modifiers were extracted,
; while for --PSV it means no argument was passivized.

event_or_index := non_expl &
  [ --TPC bool,
    --PSV bool ].

event_or_deg-ind :< event_or_index.

basic_tense :< *sort*.
tense :< basic_tense.
untensed :< basic_tense.
aspect := *avm* &
  [ PERF luk,
    PROGR luk,
    STATIVE bool ].
no_aspect := aspect &
  [ PERF -,
    PROGR - ].

real_tense :< tense.
nonpast :< real_tense.
present :< nonpast.
nonpresent :< real_tense.
past :< nonpresent.
future := nonpast.
no_tense := tense & untensed.
; For PPs that can never be complements of 'be'
nontense :< untensed.

tam_min := *avm*.
tam := tam_min &
 [ TENSE basic_tense,
   ASPECT aspect,
   MOOD mood ]. 

basic_ind_or_mod_subj_tam := tam &
 [ MOOD ind_or_mod_subj ].

ind_or_mod_subj_tam := basic_ind_or_mod_subj_tam &
 [ TENSE real_tense ].

past_or_subj_tam := tam &
 [ TENSE nonpresent,
   ASPECT no_aspect ].

subjnct_tam := past_or_subj_tam &
 [ MOOD subjunctive ].

past_tam := past_or_subj_tam & ind_or_mod_subj_tam &
 [ TENSE past,
   MOOD indicative ].

event := event_or_deg-ind &
  [ E tam ].

; Once used to distinguish discourse adverbs, for VIT purposes - now obsolete?
disc_frag :< event_or_index.

; WLINK links semantic relation to input string elements, more or less.
; CFROM and CTO used for characterization

relation_min := *avm*.
relation := relation_min &
  [ PRED predsort,
    LBL handle,
    WLINK *list*,
    CFROM *top*,
    CTO *top* ].

arg0_relation := relation &
  [ ARG0 event_or_index ].

event_relation := arg0_relation &
  [ ARG0 event ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MRS type
;
;   HOOK                   ; Label of rel with highest scope in sign
;   RELS                   ; List of elementary predications
;   HCONS *diff-list*      ; Scope constraints: list of scp_pr's

; DPF 18-jul-04 - Avoid making value of LTOP handle, since want to allow for
; optional sentential complements, so need to have that argument position in
; the higher verb's relation be underspecified.  We give up some type-checking
; benefits here, but gain cleaner treatment of optionality.

hook := *top* &
  [ LTOP basic_semarg,
    INDEX basic_semarg,
    XARG *top* ].

mrs_min := *avm* &
  [ HOOK hook,
    MSG basic_message_min ].

mrs_min1 := mrs_min &
  [ RELS *diff-list* ].
    
;; DPF 10-Oct-00 - Added ARG0 attribute for predicative phrases, as in
;; "Kim kept calm" where the INDEX of "calm" is "Kim"'s INDEX and the first
;; argument of _keep_rel, while "calm"'s ARG0 is second argument of _keep_rel.

mrs := mrs_min1 &
  [ HCONS *diff-list* ].

; Constrains handle of scopable argument HARG relative to one or more 
; handles
scp_pr := *top* &
  [ HARG handle,
    LARG handle ].        

; Constrains scope to be equal subject to intervening quantifiers
;;;
;;; as of jul-04, the generator supports a mode where QEQs in its input MRSs
;;; are equated internal to the generator, which (although formally it results
;;; in an MRS that could not be scope-resolved) makes sure we get attachments
;;; of scopal elements right, even though in the final semantics compatibility
;;; test there is no testing of handle constraints.  instead, an MRS that comes
;;; off a generator output is subjected to QEQ equation internall too, so that
;;; plain mrs-equalp() is sufficient.  equating INSTLOC values inside of QEQs
;;; in the grammar makes sure we get the intended effect during generation, but
;;; still end up producing a well-formed MRS with scope underspecification.
;;;                                                            (14-jul-04; oe)
; Constrains scope to be equal subject to intervening quantifiers
qeq := scp_pr & [ HARG.INSTLOC #1, LARG.INSTLOC #1 ].

; Used at least in fragments
geq := scp_pr.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONJ type -
;
; CONJ values come in two types, cnil and strict-conj (i.e., non-cnil).  Cnil
; and the atomic substypes of strict-conj are the possible CONJ values of the
; left conjunct in a coordinate structure.  The right conjunct must always
; have a complex-conj CONJ value.  A complex CONJ value has three parts: the
; handles and indices of the sub-parts of the right conjunct, and the CHEAD
; info that gets passed from the right conjunct to the mother.  The CHEAD
; value has only one piece of information: the CONJ values of the
; left conjunct daughters.  For more info about how this works, see
; top_coord_rule in syntax.tdl.

conj :< *avm*.
cnil_or_numconj :< conj.
cnil_or_phrconj :< conj.
cnil := cnil_or_numconj & cnil_or_phrconj.
real-conj := conj &
  [ CHEAD chead ].
strict-conj :< conj.
strict-real-conj := strict-conj & real-conj.
strict-atomic-conj :< strict-real-conj.
atomic-conj := strict-atomic-conj &
  [ CHEAD.LEFT.FIRST cnil ].
both :< atomic-conj.
either :< atomic-conj.
neither :< atomic-conj.
nor :< atomic-conj.
chead := *avm* &
  [ LEFT *list* ].
; CREL is a pointer to the coord_relation, needed for semantic composition.
complex-conj := strict-real-conj &
  [ CREL *top* ].
phr-conj := complex-conj & cnil_or_phrconj.
lex-conj :< complex-conj.
num-conj := cnil_or_numconj & strict-atomic-conj.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Contextual information

ctxt_min :< *avm*.

ctxt := ctxt_min &
  [ ACTIVATED bool,
    PRESUP *diff-list* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LKEYS relations (shortcuts to key rels of complements, only used in lexicon)
;  KEYREL relation          ; Pointer to main relation in RELS
;  ALTKEYREL relation       ; Pointer to an alternate relation in RELS
;  ALT2KEYREL relation      ; Pointer to a second alternate relation in RELS
;  --COMPKEY predsort       ; Pointer to the complement's KEY
;  --OCOMPKEY predsort      ; Pointer to the oblique complement's KEY
;  --+COMPKEY predsort      ; Pointer to obligatory complement's KEY
;  --+OCOMPKEY predsort      ; Pointer to obligatory oblique complement's KEY

keys := *avm* &
  [ KEY predsort ].

keys_norm := keys &
  [ ALTKEY predsort ].

keys_full := keys_norm &
  [ ALT2KEY predsort ].

lexkeys := *avm* &
  [ KEYREL relation ].

lexkeys_norm := lexkeys &
  [ ALTKEYREL relation ].

lexkeys_full := lexkeys_norm &
  [ ALT2KEYREL relation,
    --COMPKEY predsort,
    --OCOMPKEY predsort,
    --+COMPKEY predsort,
    --+OCOMPKEY predsort ].

; To support chart dependency filtering for there-copula
lexkeys+ := lexkeys_full &
  [ --+SUBJIND index ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; DPF (14-Oct-98) --FINAL-ARG points to the final element in a word with 
;; spaces, since that element bears any inflection.
;; AAC - dropped --FINAL-ARG - default infl position is end of word
;; in user-fns. Find better soln when we do multi words properly
;; (and use defaults)

non_affix_bearing := word_or_lexrule &
  [ SYNSEM.LKEYS.KEYREL.WLINK *cons*,
    INFLECTD + ].

; Rule

rule := sign &
  [ RNAME string ].

; LNAME and META used for labeling nodes in parse trees

tree_node_label := *top* &
  [ NODE sign ].

label := sign &
  [ LNAME string ].

;; see lkbpatches
meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ]. 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CASE and VFORM

case :< *sort*.
non_obliq :< case.
nom :< non_obliq.
non_nom :< case.
acc := non_nom & non_obliq.
obliq :< non_nom.

vform :< *sort*.
non_fin :< vform.
non_inf :< vform.
non_prp := non_fin & non_inf.
non_bse :< vform.
ger :< non_prp.
pas_or_psp := non_fin & non_inf & non_bse.
pas_or_prp := vform.
pas := non_prp & pas_or_psp & pas_or_prp.
psp_or_psp_irreg :< pas_or_psp.
psp :< psp_or_psp_irreg.
psp_irreg :< psp_or_psp_irreg.
bse_or_inf :< vform.
; fin_or_bse used to collapse morpholog. unmarked forms for bse and fin-non3sg.
fin_or_bse :< non_inf.
bse :< bse_or_inf.
; Base morphology verbs can be either base or imperative, but not if negated.
; See discussion of type neg_word.
bse_only := bse & non_fin & fin_or_bse.
fin_or_imp :< non_inf.
imp_vform := bse & fin_or_imp.
fin_or_inf :< non_bse.
fin := fin_or_inf & fin_or_bse & fin_or_imp.
inf_or_prp :< non_fin.
inf := inf_or_prp & bse_or_inf & fin_or_inf.
prp := inf_or_prp & non_inf & non_bse & pas_or_prp.

inf_and :< vform.
inf_but :< vform.
inf_from :< vform.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  CONT values (MRS semantics)
;;
;; The basic semantic objects are all sub-types of semarg.  Right now, the only
;; type of semarg that has an internal structure is index, but that will
;; probably change.  For example, an event might have various times associated
;; with them or a handle may include a list of "subhandles" which are in its
;; scope.  Indices are classified in the familiar HPSG way.

expl-ind :< index.
full_expl-ind := expl-ind & full_index.
it-ind := full_expl-ind &
  [ PNG [ PN 3sg,
          GEN no_gend_it ] ].
there-ind := expl-ind &
  [ PNG.GEN no_gend_there ].

non_expl_or_conj-ind :< index.
ind_or_event_or_conj := non_expl_or_conj-ind & event_or_index.
non_expl-ind := ind_or_event_or_conj &
  [ PNG.GEN real_gender ].
ref-ind :< non_expl-ind.
deg-ind := non_expl-ind & event_or_deg-ind.
full_non_expl := full_index & non_expl-ind.
full_there-ind := there-ind & full_expl-ind.
full_ref-ind := ref-ind & full_non_expl.
full_deg-ind := deg-ind & full_non_expl.
; Added to block spurious ambiguity for conjoined proper names:
nonconj_ref-ind :< full_ref-ind.

conj-ind :< event_or_index.
conj_event_or_deg-ind := event_or_deg-ind & conj-ind.
conj_event := conj_event_or_deg-ind & event.
conj_non_expl-ind := conj-ind & non_expl-ind.
conj_full-ind := conj_non_expl-ind & full_non_expl.
conj_ref-ind := conj_non_expl-ind & ref-ind.
conj_full_ref-ind := conj_ref-ind & conj_full-ind & full_ref-ind.
conj_deg-ind := conj_event_or_deg-ind & conj_non_expl-ind & deg-ind.
conj_full_deg-ind := conj_deg-ind & conj_full-ind & full_deg-ind.

unbound-ind := non_expl-ind.

; The basic semantic structure, a CONT, is just something with a handle.
; Conts are further classified into mrss (i.e., things with liszts) and
; relations (i.e., things that go on liszts).  Conts are divided into psoas
; (with a distinguished event) and nom-objs (with a distinguished index).
; We use a polymorphic attribute name INDEX for both of these, to simplify
; manipulation of these objects; for example, modifying PPs assign as their
; ARG1's value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  Similarly useful
; for coordination.

; ERB (03-10-96) 
; The intermediate types ques_prop_msg and prop_com_msg represent the
; natural classes needed for selection by know, announce, care, check,
; etc. and the analysis of THAT (see lextypes.tdl) and the 
; forthcoming analysis of tags on imperatives, respectively.

psoa := mrs_min &
  [ HOOK.INDEX event ].

psoa_basicmrs :< psoa.

psoa_mrs := psoa_basicmrs & mrs.

; DPF 11-Feb-01 - For now, make all nom-objs have INDEX and E-INDEX the same, 
; to keep coordination working now that we want to treat coordination of 
; predicative phrases via their E-INDEX.  Probably will have to adjust this
; once we get more interesting temporal semantics for some nouns.
; DPF 29-Nov-02 - Can't have E-INDEX the same, since pre-nominal adjectives
; now unify their E-INDEX with that of the noun, and it's of type event.
; Recall that adjectives must do this unification in order to propagate the
; E-INDEX of the syntactic head, since the adjective is the semantic head.
; DPF 4-Dec-02 - For now, make all nouns not expose an external argument, so
; they won't appear as controlled complements.  Will perhaps want to treat
; indefinite NPs in copular constructions by relaxing this constraint for e.g.
; "Kim is a consultant"
; DPF 13-Nov-03 - Removed [ HOOK.XARG nothing ], since nom-obj is also the
; type assigned to determiners, and these need to be able to take degree
; specifiers, including comparative/equative ones like "as many X", where the
; degree-spec identifies its SPEC's XARG with one argument in the comparative
; relation - necessary because adjectives expose their modifiee noun's index
; as the adj's XARG (since the adj's INDEX is its event, for copula constr's).
; DPF 27-Nov-03 - Also, experimentally, make XARG of NPs be the handle of
; the nbar, which often seems to be needed, e.g. in it-clefts, where the
; rel clause wants to identify its message's handle with that of the nbar.

nom-obj := mrs.

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; Since some temporal nouns can be either arguments or VP modifiers, their 
; rel's ARG0 value (coindexed with INDEX of the containing MRS) must remain 
; unspecified for type.  Consider "Kim arrived Tuesday" vs. "Tuesday comes
; after Monday"; in the first, Tuesday must have an event ARG0, while in the
; second, it must have a ref-ind ARG0.

; ERB (24-10-96) Here is the series of relations that will be used for
; questions, etc.  Cf. Gizburg & Sag.
; ERB (12-05-96) Moved the ne_m_rel here.

; DPF 11-Feb-04 - Added surface realization features TPC and PSV as locus for
; encoding semantic effects of topicalization and passivization (at least) 
; on constituents that appear in marked sentence position.

basic_message_min := relation_min.
basic_message := basic_message_min &
  [ TPC individual_min,
    PSV individual_min ].
basic_message_full := basic_message & relation &
  [ PRED message_m_rel ].
    
no_msg :< basic_message_full.
message := basic_message_full &
  [ MARG handle,
    PARAMS *diff-list* ].

quant_or_wh_relation := arg0_relation &
  [ PRED quant_or_wh_rel,
    ARG0 ref-ind,
    RSTR handle,
    BODY handle ].

; Nominal sorts
nominal-sort :< *sort*.
entity :< nominal-sort.
nonloc :< entity.
human :< nonloc.
location :< nominal-sort.
time :< location.
place := location & entity.
nom-event :< nominal-sort.
; DPF 03-may-04 - No longer used
;number :< nominal-sort.

; modable_rel distinguishes those relations whose nominal lexical entries can 
; undergo a syntactic rule to produce a modifier phrase, as in "we'll meet
; next week" or "I'll do it my way".

; dir_state_modable_rel is the supertype of modable_rel and dir_or_state_rel
; used by verbs selecting for locative PPs including nominal adverbials which
; are converted from NPs to PPs via a syntactic rule which introduces the
; two-place locative relation.  This type is needed to support the shortcut of
; chart dependencies to filter out verb entries if the corresponding particle
; or preposition is not present, so we can still parse e.g. "Kim put it here".

; Nominal relations

instance_relation := arg0_relation &
  [ ARG0 individual_min ].

nom_relation := instance_relation &
  [ ARG0 non_expl-ind ].

; DPF 25-Sep-01 - Added [SORT entity] contrasted with [SORT time] to enable
; blocking of e.g. "the book that kim arrived" but allow "the day that Kim
; arrived"

reg_nom_relation := nom_relation &
  [ ARG0.SORT entity ].

modable_nom_relation := nom_relation &
  [ ARG0.SORT entity ].

basic_diadic_nom_relation := nom_relation & basic_arg01_relation.

diadic_nom_relation := basic_diadic_nom_relation &
  [ ARG1 non_expl-ind ].

reg_diadic_nom_relation := diadic_nom_relation &
  [ ARG0.SORT entity ].

reg_triadic_nom_relation := reg_diadic_nom_relation & basic_arg12_relation &
  [ ARG2 non_expl-ind ].

basic_hcomp_nom_relation := basic_diadic_nom_relation &
  [ ARG1 handle ].

hcomp_nom_relation := basic_hcomp_nom_relation &
  [ ARG0.SORT entity ].

; Changed nominalize_rel and gerund_rel to subtype of non_temp_nom_rel rather 
; than reg_nom_rel to avoid semantically anomalous readings for e.g. "Kim is 
; sleeping".

nom_or_ger_relation := arg0_relation &
  [ ARG0.SORT nom-event ].

nominalize_relation := basic_hcomp_nom_relation & nom_or_ger_relation &
  [ PRED nominalize_rel ].

gerund_relation := basic_diadic_nom_relation & nom_or_ger_relation &
  [ PRED gerund_rel,
    ARG0 ref-ind ].

temp_abstr_relation := nom_relation &
  [ ARG0.SORT time ].

const_value_relation := relation &
  [ CARG *top* ].

const_arg0_relation := const_value_relation & arg0_relation.
const_arg01_relation := const_arg0_relation & arg01_relation.

generic_named_nom_relation := nom_relation & const_arg0_relation.

named_nom_relation := generic_named_nom_relation &
  [ ARG0.SORT entity ].

generic_diadic_named_relation := generic_named_nom_relation & 
                                 const_arg01_relation &
                                 diadic_nom_relation.
diadic_named_nom_relation := generic_diadic_named_relation &
                             reg_diadic_nom_relation.

day_part_relation := nom_relation &
  [ PRED day_part_rel ].

; ARG1 is the minute_rel complement's ARG0, and ARG2 is the am_pm's ARG0.
numbered_hour_relation := const_arg01_relation & basic_arg12_relation & 
  [ PRED numbered_hour_rel,
    ARG0 [ PNG png & [ PN 3sg,
                       GEN neut ],
           SORT time ],
    CARG string,
    ARG1 individual_min,
    ARG2 individual_min ].

; Pronouns
; DPF 2-Jul-03 - Removed DIVISIBLE - which was perhaps used earlier to block
; spurious application of bare-np rule.  Not desirable since antecedent could
; of course be mass or plural, and maybe want indices to be unifiable for
; anaphora resolution.

pron_relation := nom_relation &
  [ PRED pron_rel,
    ARG0 ref-ind & [ SORT entity ] ].

recip_pro_relation := nom_relation &
  [ PRED recip_pro_rel,
    ARG0 ref-ind & [ SORT entity ] ].

basic_adj_relation := event_relation.

norm_adj_relation := basic_adj_relation & arg1_relation.
adj_relation := norm_adj_relation &
  [ ARG1 non_expl ].

adj_arg1_relation := adj_relation.
adj_arg12_relation := adj_arg1_relation & arg12_relation.
adj_arg123_relation := adj_arg12_relation & arg3_relation.
it_adj_arg12_relation := adj_arg12_relation.
it_adj_arg123_relation := adj_arg123_relation.

basic_arg01_relation := arg0_relation &
  [ ARG1 *top* ].

arg01_relation := basic_arg01_relation &
  [ ARG1 semarg ].

adv_relation := arg01_relation.
adv12_relation := adv_relation & arg2_relation.

arg1_relation := arg01_relation & event_relation.

arg2_relation := relation &
  [ ARG2 semarg ].

arg3_relation := relation &
  [ ARG3 semarg ].

arg4_relation := relation &
  [ ARG4 semarg ].

basic_arg12_relation := arg01_relation & arg2_relation.
arg12_relation := basic_arg12_relation & arg1_relation.
arg123_relation := arg12_relation & arg3_relation.
arg1234_relation := arg123_relation & arg4_relation.

aux_arg1_relation := arg1_relation &
  [ PRED aux_arg1_rel ].

; Preposition relations

prep_relation := basic_arg12_relation &
  [ PRED prep_rel,
    ARG2 non_expl ].	    

prep_notense_relation := prep_relation &
  [ ARG0.E [ TENSE no_tense,
             ASPECT no_aspect ] ].

prep_123_relation := prep_relation & arg3_relation.

; Degree relations

degree_relation := basic_arg01_relation &
  [ ARG0 individual_min ].

comparative_relation := degree_relation &
  [ ARG-1 index,
    C-ARG0 index ].

comp_more_less_relation := comparative_relation &
  [ ARG-2 semarg ].

comp_most_least_relation := comparative_relation &
  [ C-SET handle ].

;; For "how" adjective, which quantifies over properties.

; For "how does Tuesdaay look" using second-order quantification (see notes for
; adj_wh_le in lextypes.tdl
; ARG1 is proposition, ARG2 is property

prpstn_to_prop_relation := arg12_relation &
  [ PRED prpstn_to_prop_rel,
    ARG1 handle,
    ARG2 non_expl-ind ].

comp_relation := prep_relation &
  [ ARG2 event_or_index,
    ARG0.E.TENSE no_tense ].
superl_relation := prep_relation &
  [ ARG2 event_or_index ].

subord_relation := relation &
  [ MAIN handle,
    SUBORD handle ].

; Discourse functions

; ERB (03-10-96) In order to capture the similarities and differences
; between embedded and matrix questions, I am decomposing the ynq_rel
; into polar_q_rel and request_ans_rel.  The latter is probably 
; equivalent to the ne_m_rel (see below), but ne_m_rel is too cute to
; forgo for the tag questions and probably too opaque for the 
; matrix yn questions, so I will keep the two for now.  NB polar_q_rel
; probably doesn't qualify as 'discourse function'.  

; So, the ynq_root construction will contribute a polar_q_rel and
; a request_ans_rel, whether will contribute a polar_q_rel, and
; matrix wh questions will contribute a request_ans_rel.

#|
polar_q_rel :< mod_rel.
request_ans_rel :< mod_rel.

polite_rel :< mod_rel.
|#

basic_conj_relation := arg0_relation &
  [ PRED basic_conj_rel,
    ARG0 conj-ind,
    L-INDEX non_expl,
    R-INDEX non_expl ].

conj_relation := basic_conj_relation &
  [ PRED conj_rel,
    L-HNDL basic_semarg,
    R-HNDL basic_semarg ].

; Abstract relations specified by more than one lexical entry

abstr_place_relation := nom_relation &
  [ ARG0.SORT place ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Number relations

; DPF 10-Feb-02 - Highly experimental addition of ARG0 attribute to get 
; segregation of numerical adjectives

integer_relation := basic_arg01_relation &
  [ PRED integer_rel,
    ARG1 individual_min ].

const_relation := integer_relation & const_arg01_relation &
  [ PRED const_rel,
    CARG string].

plus_relation := integer_relation & 
  [ PRED plus_rel,
    TERM1 handle,
    TERM2 handle ].
times_relation := integer_relation & 
  [ PRED times_rel,
    FACTOR1 handle,
    FACTOR2 handle ].

;; TYPES/SORTS
;; The CARDINAL feature determines whether its bearer is cardinal or not 
;; (i.e., is ordinal or cardinal).  Thus it is only appropriate for
;; numbers.  All numbers have a HEAD value of sort intsort, those
;; used adjectivally have heads of sort intadj (or one of its 
;; subsorts) or intdet (which has no subsorts).  Nominal uses are
;; not yet supported.
;;
;; Subcategorization, which is in terms of the maximum number of digits
;; allowed for the complement or specifier, is handled by the subsorts
;; of the digitn hierarchy.  Currently, only adjectives participate in
;; this hierarchy; there is only a single integer determiner ("one").
;; Nominal uses could be added by adding a type
;;          intnoun := intsort & digitn & noun.

intsort := head & [ CARDINAL bool ].

digitn :< head.

digit15 :< digitn.
digit12 :< digit15.
digit9 :< digit12.
digit6 :< digit9.
digit3 :< digit6.
digit2 :< digit3.
digit1 :< digit2.

; The sorts    digitk    specify the number of digits of a lexeme 
; together with its largest complement and specifier.
; The sorts    digitk-    are used for subcategorization; they include
; values of k or fewer digits.
 
digit15- :< digitn.
digit12- :< digit15-.
digit9- :< digit12-.
digit6- :< digit9-.
digit3- :< digit6-.
digit2- :< digit3-.
digit1- :< digit2-.

;; DPF 26-Apr-00 - Removed adj parent from intadj.
;; DPF 19-Sept-01 - Added supertype adj_or_intadj, for adj-intervals ("2 - 3")

intadj := intsort & adj_or_intadj & intadj_or_superl.
intadjn := intadj & digitn.
intdet := intsort & det.

; intadj1- := intadj1.
; intadjk- means an integer adjective of at most k digits (when
;   combined with specifier and complement

intadj15- :< intadj.
intadj15  := intadj15- & digit15.
intadj12- :< intadj15-.
intadj12  := intadj12- & digit12.
intadj9- :< intadj12-.
intadj9  := intadj9- & digit9.
intadj6- :< intadj9-.
intadj6  := intadj6- & digit6.
intadj3- :< intadj6-.
intadj3  := intadj3- & digit3.
intadj2- :< intadj3-.
intadj2  := intadj2- & digit2.
intadj1  := intadj2- & digit1.

fractadj := intadj & [ MOD < anti_synsem > ].

_here_a_rel :< adj_rel.
_now_a_rel :< adj_rel.
_there_a_rel :< adj_rel.
_today_a_rel :< adj_rel.
_tomorrow_a_rel := adj_rel & dofw_or_poss_q_rel.
_yesterday_a_rel := adj_rel & dofw_or_poss_q_rel.
_tonight_a_rel := adj_rel & dofw_or_poss_q_rel.
_last+night_a_rel := adj_rel & dofw_or_poss_q_rel.
_east_a_rel :< adj_rel.
_north_a_rel :< adj_rel.
_south_a_rel :< adj_rel.
_west_a_rel :< adj_rel.
_outdoors_a_rel := adj_rel.
_overseas_a_rel := adj_rel.
_online_a_rel := adj_rel.
_offline_a_rel := adj_rel.
_overhead_a_rel := adj_rel.
_southeast_a_rel := adj_rel.
_southwest_a_rel := adj_rel.
_northeast_a_rel := adj_rel.
_northwest_a_rel := adj_rel.
_northward_a_rel := adj_rel.
_southward_a_rel := adj_rel.
_eastward_a_rel := adj_rel.
_westward_a_rel := adj_rel.
_upward_a_rel := adj_rel.
_downward_a_rel := adj_rel.
_downhill_p_rel :< dir_rel.
_inward_a_rel := adj_rel.
_outward_a_rel := adj_rel.
_inland_a_rel := adj_rel.
_late_p_rel := miscprep_rel.
_elsewhere_a_rel := adj_rel.
_forever_a_rel := adj_rel.
_long_a_rel :< adj_rel.
_longer_a_rel :< adj_rel.
_soon_p_rel :< miscprep_rel.
_sooner_p_rel :< miscprep_rel.
_thither_a_rel :< adj_rel.
_underground_a_rel := adj_rel.
_arrear_a_rel := adj_rel.

; For fragments
unknown_relation := arg0_relation &
  [ PRED unknown_rel,
    ARG semarg ].

; For parentheticals
unknown_twoarg_relation := unknown_relation &
  [ ARGB semarg ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Basic types

; DPF 10-Sep-03 Temporary redefinition of *sort* until we get rid of relations
; as values of KEY.

*sort* :< *top*.

atom :< predsort.

*avm* :< *top*.

*list* :< *avm*.

*cons* := *list* &
  [ FIRST *top*,
    REST *top* ].

0-1-list :< *list*.
1-list := 0-1-list & *cons* &
  [ REST *null* ].
*null* :< 0-1-list.
1-plus-list := *cons* &
  [ REST *cons* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Basic types

; Used for characterization
initial-cfrom-val := atom.
initial-cto-val := atom.

string := initial-cfrom-val & initial-cto-val.

integer :< atom.

; Lists

; ERB (13-12-97) This type is meant as a PRO -- i.e., what can show
; up in such things as the 'way' construction and embedded infinitival
; wh questions.  It should eventually receive some binding properties,
; but I don't know what to put there yet, and since we don't have
; a binding theory...

; ERB (14-12-97) I am adding the pron_rel to pro_ss, so that in the
; types like common_noun_vpcomp_synsem I don't have to put it in.  I
; can just take the KEYREL.

; ERB (14-12-97) No pron_rel for pro_ss.

; ERB (14-12-97) ... and pro_ss is accusative, to block (once I get
; infinitival relatives working) *A person left came in.

; ERB (14-12-97) This is moved here so as to be after acc, which is a 
; *sort* and thus can't handle being referenced before it is defined.

; ERB (19-01-98) PRO is obligatorially OPT -.  This keeps to_c_prop
; from serving as a modifier without first building a non_wh_rel,
; because hadj requires SUBJ *olist*.

; ERB (21-01-98) In order for PRO to be extractable, it can't be
; SLASH 0-dlist, and thus can't be a subtype of unexpressed.  With
; PRO underspecified for SLASH, something will always have to fill
; in that value.  In the case of subject non_wh_rels (e.g., 
; "Kim found a person to fix the sink") it is extracted, i.e., resolved
; to gappro by extrasubj.  In the cases where the PRO is the subject of
; a selected complement, the selector will impose SLASH 0-dlist on the
; PRO (this case includes equi constructions, embedded infinitival
; wh questions, and the complement of 'way' as in "Kim found a way
; to leave early").  In the case of the (as yet unimplemented) CP[to]
; subjects, the NP -> CP rule will probably do the work.  Alternatively,
; the selecting category could do it.  Finally, in the case of
; non-subject non_wh_rels (e.g., "Kim found a cheeseburger to devour"),
; the PRO must be SLASH 0-dlist because the non_wh_rel_rule limits
; the SLASH list to length one.
;
; On a related note, we want the distribution of gappro (i.e., of
; extracted PRO) to be quite constrained, and perhaps even limited
; to the subject non_wh_rels.  In general, we are relying on the
; restriction of SLASH to lists of length one stated in several places
; in the grammar, in addition to certain selecting categories' specifying
; an empty value for SLASH on the PROs in their complements' subjects
; to keep us from getting in trouble on this one.
;
; Finally, rather than make a subtype of pro_ss that says SLASH 0-dlist,
; I have opted to include that information on the type *prolist*.

; ERB (03-23-98) We need a way to identify indices introduced by a PRO
; that are "discourse bound".  We were using PRONTYPE for this, but
; of course that doesn't work when the controller of the PRO is an overt
; pronoun.  So the new strategy is to make the INDEX a non_expl.
; This will unify with the indices introduced by (appropriate) controllers,
; and (hopefully) be identifiable if it is not controlled.

; DPF 27-May-99 - Removed OPT - constraint from pro_ss (see ERB (19-01-98) 
; above) since head_mod type now constrained via PRD rather than by requiring 
; SUBJ to be empty (cf note DPF 27-May-99 with n_adj_int_phrase in syntax.tdl).
; This change means the types for saturated subcats can again simply require 
; SUBJ to be *olist* rather than *null*, which e.g. allows verbal gerunds to 
; have optional but non-empty SUBJ value and still themselves appear as 
; subjects or complements without discharging that SUBJ value.
; DPF 15-Nov-03 - Added CONT.HOOK.INDEX ref-ind, which blocks spurious analysis
; of e.g. "to be" with expletive-subj elided be.  And linked it to --SIND
; for consistency.  
; DPF 06-dec-03 - But this fails to scope when there is no antecedent, as in
; "it takes a week to get there" (cf ok "It takes me a week to get there").
; So remove constraint of ref-ind.  Instead constrain NP-S rule's XARG.

pro_ss := expressed_non_canonical &
  [ LOCAL [ CAT.HEAD noun & [ CASE acc ],
            CONT.HOOK.INDEX #ind ],
    NONLOC [ REL 0-dlist,
		QUE 0-dlist ],
    --SIND #ind ].

; ERB (19-01-98) We need a subtype of pro and gap so that to_c_prop
; can undergo subject extraction.  See the notes near non_wh_rel in
; syntax.tdl for the details of the analysis.
; I am positive that this will break something, but I could not
; guess what.

gappro := pro_ss & gap.

*olist* :< *list*.
*ocons* := *olist* & *cons* &
  [ FIRST unexpressed & [ OPT + ],
    REST  *olist* ].
*onull* := *olist* & *null*.

*obllist* :< *list*.
*oblcons* := *obllist* & *cons* &
  [ FIRST.OPT -,
    REST  *obllist* ].
*oblnull* := *obllist* & *null*.

*synlist* :< *list*.
*syncons* := *synlist* & *cons* &
  [ FIRST synsem,
    REST  *synlist* ].
*syn_ocons* := *syncons* & *ocons*.
*synnull* := *synlist* & *onull*.

*phrlist* :< *list*.
*phrcons* := *phrlist* & *cons* &
  [ FIRST phr_synsem,
    REST  *phrlist* ].
*phrnull* := *phrlist* & *onull* & *oblnull*.

*gaplist* :< *list*.
*gapcons* := *gaplist* & *cons* &
  [ FIRST gap,
    REST  *null* ].
*gapnull* := *gaplist* & *null*.

*antisyn_or_prolist* := *list*.
*prolist* := *antisyn_or_prolist*.
*procons* := *prolist* & *cons* &
  [ FIRST pro_ss &
	  [ NONLOC.SLASH <! !> ],
    REST *null* ].
*pronull* := *prolist* & *onull*.

*anti_list* := *antisyn_or_prolist*.
*anti_cons* := *anti_list* & *ocons* &
  [ FIRST anti_synsem,
    REST < > ].
*anti_null* := *anti_list* & *onull*.

;; *unexplist* is used for common nouns whose specifier is possibly obligatory,
;; but unexpressed, as in noun-noun compounds.  As usual, we use the same hack
;; as for *olist*, to get around the lack of recursive types in TDL.

*unexplist* := *list*.

*unexpcons* := *unexplist* & *cons* &
  [ FIRST unexpressed,
    REST  *null* ].

;*unexpnull* := *unexplist* & *olist* & *null*.
*unexpnull* := *unexplist* & *onull*.

;; *substlist* is used in the adv_addition lexical rule, to prevent spurious
;; re-application of the rule to its own output by requiring the input to
;; be a (possibly empty) list of substantive synsems.
*substlist* :< *list*.

*substcons* := *substlist* & *cons* &
  [ FIRST.LOCAL.CAT.HEAD subst,
    REST  *substlist* ].

; For there-copula
*substocons* := *substcons* & *ocons*.

;*substnull* := *substlist* & *olist* & *null*.
*substnull* := *substlist* & *onull*.

;; *handlelist* is used in the treatment of free relatives, to disntinguish
;; the usual value of QUE from its use in free relatives, where QUE is instead
;; a list of referential indices.

*handlelist* := *list*.

*handlecons* := *handlelist* & 1-list &
  [ FIRST handle,
    REST  *null* ].

*handlenull* := *handlelist* & *onull*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subtypes of *diff-list*

;; Experimental use of subtypes of *diff-list* to enforce constraint of at
;; most one element in SLASH (for efficiency, "violin/sonnet" examples
;; notwithstanding).  Will only have effect in LKB version which does the
;; necessary type inference.

*diff-list* := *avm* &
[ LIST *list*,
  LAST *list* ].

0-1-dlist := *diff-list* &
  [ LIST 0-1-list ].

; DPF 10-Oct-02 - Just a reminder that we cannot make the LIST value of 0-dlist
; be < >, much as we might like to, since we're doing lexical threading of
; SLASH (at least), and if we make all 0-dlists have LIST < >, then if the
; first of two complements is a proper name with SLASH 0-dlist, then the
; appended diff-list also has LIST <>, which prevents the second complement
; (or the subject) from being slashed, so we would even block "Who hired Kim".
; Instead, need to ensure manually that for each dtr in a construction, if the
; SLASH value of the nonhead dtr is not carried up via lexical threading by
; the head-dtr, or by the construction itself, then that dtr must be 
; constrained to be (seemingly redundantly) [ SLASH 0-dlist & [ LIST < > ] ].

0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].
1-dlist := 0-1-dlist &
  [ LIST 1-list &
	 [ REST #rest & *null* ],
    LAST #rest ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; predkeys

abstr_sure_rel :< adj_rel.
_sure_a_rel :< abstr_sure_rel.
_certain_a_rel :< abstr_sure_rel.

; for 'different from/than X'
than_or_from_rel :< selected_prep_rel.

; For PP complements of (temporal) 'from X to/until/through Y'
abstr_until_sel_rel :< selected_prep_rel.

_about_p_sel_rel :< selected_prep_rel.
_across_p_sel_rel :< selected_prep_rel.
_after_p_sel_rel :< minute_prep_sel_rel.
_against_p_sel_rel :< selected_prep_rel.
_ahead_p_sel_rel :< selected_prep_rel.
_along_p_sel_rel :< selected_prep_rel.
_among_p_sel_rel :< selected_prep_rel.
_apart_a_sel_rel :< selected_adj_rel.
_around_p_sel_rel :< selected_prep_rel.
_as_p_comp_rel :< selected_prep_rel.
_as_p_sel_rel :< selected_prep_rel.
_as_p_nbar_rel :< selected_prep_rel.
_as+to_p_sel_rel :< selected_prep_rel.
_aside_p_sel_rel :< selected_prep_rel.
_at_p_sel_rel :< selected_prep_rel.
_away_p_sel_rel :< selected_prep_rel.
_back_p_sel_rel :< selected_prep_rel.
_before_p_sel_rel :< minute_prep_sel_rel.
_behind_p_sel_rel :< selected_prep_rel.
_between_p_sel_rel :< selected_prep_rel.
_by_p_sel_rel :< selected_prep_rel.
_by_p_cm_rel :< selected_prep_rel.
_by_p_nbar_rel :< selected_prep_rel.
_down_p_sel_rel :< selected_prep_rel.
_for_p_sel_rel :< selected_prep_rel.
_for_p_trgt_rel :< selected_prep_rel.
_forth_p_sel_rel :< selected_prep_rel.
_forward_p_sel_rel :< selected_prep_rel.
_from_p_sel_rel :< than_or_from_rel.
_in_p_sel_rel :< selected_prep_rel.
_into_p_sel_rel :< selected_prep_rel.
of_p_sel_rel :< selected_prep_rel.
_of_p_sel_rel := of_p_sel_rel.
_of_p_nbar_rel := of_p_sel_rel.
_off_p_sel_rel :< selected_prep_rel.
_on_p_sel_rel :< selected_prep_rel.
_onto_p_sel_rel :< selected_prep_rel.
_open_a_sel_rel :< selected_adj_rel.
_out+of_p_sel_rel :< selected_prep_rel.
_out_p_sel_rel :< selected_prep_rel.
_over_p_sel_rel :< selected_prep_rel.
_past_p_sel_rel :< minute_prep_sel_rel.
_short_a_sel_rel :< selected_adj_rel.
_solid_a_sel_rel :< selected_adj_rel.
_still_a_sel_rel :< selected_adj_rel.
_through_p_sel_rel :< abstr_until_sel_rel.
_to_p_sel_rel := abstr_until_sel_rel & minute_prep_sel_rel.
_to_p_interval_rel :< selected_prep_rel.
_together_p_sel_rel :< selected_prep_rel.
_toward_p_sel_rel :< selected_prep_rel.
_towards_p_sel_rel :< selected_prep_rel.
_until_p_sel_rel := abstr_until_sel_rel & minute_prep_sel_rel.
_up_p_sel_rel :< selected_prep_rel.
_upon_p_sel_rel :< selected_prep_rel.
_with_p_sel_rel :< selected_prep_rel.
_without_p_sel_rel :< selected_prep_rel.
_than_p_compar_rel :< than_or_from_rel.

_a_p_per_rel :< miscprep_rel.
_abaft_p_rel :< dir_or_state_nontemp_rel.
_abeam_p_rel :< dir_or_state_nontemp_rel.
_aboard_p_rel :< miscprep_rel.
_about_p_rel :< miscprep_rel.
_above_p_rel :< dir_or_state_nontemp_rel.
_above_p_dir_rel := _above_p_rel & dir_rel.
_aboveground_p_rel :< miscprep_rel.
_abroad_p_rel :< miscprep_rel.
_according+to_p_rel :< miscprep_rel.
_across_p_rel :< dir_or_state_nontemp_rel.
_across_p_dir_rel := _across_p_rel & dir_rel.
_aft_p_rel :< dir_or_state_nontemp_rel.
_after_p_rel :< temp_loc_abstr_rel.
_afterward_p_rel :< miscprep_rel.
_afterwards_p_rel :< miscprep_rel.
_against_p_rel :< miscprep_rel.
_ago_p_rel :< miscprep_rel.
_ahead_p_rel :< miscprep_rel.
_ahead+of_p_rel :< dir_rel.
_all+over_p_rel :< miscprep_rel.
_along_p_rel :< dir_or_state_nontemp_rel.
_along_p_dir_rel := _along_p_rel & dir_rel.
_along+with_p_rel :< miscprep_rel.
_alongside_p_rel :< miscprep_rel.
_amid_p_rel :< miscprep_rel.
_amidst_p_rel :< miscprep_rel.
_among_p_rel :< miscprep_rel.
_amongst_p_rel :< miscprep_rel.
_apart+from_p_rel :< miscprep_rel.
_around_p_rel :< miscprep_rel.
_as_p_rel :< miscprep_rel.
_as+of_p_rel :< temp_loc_rel.
_as+for_p_rel :< miscprep_rel.
_as+to_p_rel :< miscprep_rel.
_ashore_p_rel :< miscprep_rel.
_aside_p_rel :< miscprep_rel.
_aside+from_p_rel :< miscprep_rel.
_astray_p_rel :< miscprep_rel.
_astride_p_rel :< miscprep_rel.
_at_p_rel :< state_loc_rel.
_at_p_temp_rel :< temp_loc_sp_rel.
_athwart_p_rel :< dir_or_state_nontemp_rel.
_atop_p_rel :< miscprep_rel.
_available_a_rel :< adj_rel.
_away_p_rel :< miscprep_rel.
_back_p_rel :< miscprep_rel.
_backward_p_rel :< miscprep_rel.
_backwards_p_rel :< miscprep_rel.
_because+of_p_rel :< miscprep_rel.
_before_p_rel :< miscprep_rel.
_beforehand_p_rel :< miscprep_rel.
_below_p_rel :< dir_or_state_nontemp_rel.
_below_p_dir_rel := _below_p_rel & dir_rel.
_behind_p_rel :< dir_or_state_nontemp_rel.
_behind_p_dir_rel := _behind_p_rel & dir_rel.
_beneath_p_rel :< miscprep_rel.
_beside_p_rel :< dir_or_state_nontemp_rel.
_beside_p_dir_rel := _beside_p_rel & dir_rel.
_besides_p_rel :< miscprep_rel.
_between_p_rel :< temp_loc_rel.
_betwixt_p_rel :< temp_loc_rel.
_beyond_p_rel :< dir_or_state_nontemp_rel.
_beyond_p_dir_rel := _beyond_p_rel & dir_rel.
_but_p_except_rel :< miscprep_rel.
_by_p_rel :< miscprep_rel.
_by_p_temp_rel :< temp_loc_rel.
_by+means+of_p_rel :< miscprep_rel.
_by+way+of_p_rel :< miscprep_rel.
_close+to_p_rel :< miscprep_rel.
_concerning_p_rel :< miscprep_rel.
_care_of_p_rel :< miscprep_rel.
_despite_p_rel :< miscprep_rel.
_down_p_rel :< dir_rel.
_downstream_p_rel :< miscprep_rel.
_due+to_p_rel :< miscprep_rel.
_during_p_rel :< temp_loc_rel.
_e+g_p_rel :< miscprep_rel.
_each_p_rel :< miscprep_rel.
_en+route_p_rel :< dir_rel.
_except+for_p_rel :< miscprep_rel.
_except_p_rel :< miscprep_rel.
_excepting_p_rel :< miscprep_rel.
_facing_p_rel :< dir_rel.
_far_a_rel :< dir_or_state_nontemp_rel.
_for_p_rel :< miscprep_rel.
_for+example_p_rel :< miscprep_rel.
_for+instance_p_rel :< miscprep_rel.
_for+lack+of_p_rel :< miscprep_rel.
_fore_p_rel :< dir_or_state_nontemp_rel.
_forth_p_rel :< miscprep_rel.
_forward_p_rel :< miscprep_rel.
_fore+and+aft_p_rel :< miscprep_rel.
_from_p_rel :< miscprep_rel.
_from_p_to_rel := dir_rel & instance_rel.
_from_p_time+on_rel :< miscprep_rel.
_further_p_rel :< miscprep_rel.
_going+by_p_rel :< miscprep_rel.
_hither_p_rel :< miscprep_rel.
_hitherward_p_rel :< miscprep_rel.
_home_p_rel :< miscprep_rel.
_in+accordance+with_p_rel :< miscprep_rel.
_in+addition+to_p_rel :< miscprep_rel.
_in+back+of_p_rel :< dir_or_state_nontemp_rel.
_in+back+of_p_dir_rel := _in+back+of_p_rel & dir_rel.
_in+behalf+of_p_rel :< miscprep_rel.
_in+between_p_rel :< dir_or_state_nontemp_rel.
_in+between_p_dir_rel := _in+between_p_rel & dir_rel.
_in+front+of_p_rel :< dir_or_state_nontemp_rel.
_in+front+of_p_dir_rel := _in+front+of_p_rel & dir_rel.
_in+lieu+of_p_rel :< miscprep_rel.
_in_p_rel :< dir_or_state_nontemp_rel.
_in_p_dir_rel := _in_p_rel & dir_rel.
_in_p_temp_rel :< temp_loc_sp_rel.
_in+regard+to_p_rel :< miscprep_rel.
_in+spite+of_p_rel :< miscprep_rel.
_in+the+course+of_p_rel :< miscprep_rel.
_in+the+way+of_p_rel :< miscprep_rel.
_inside_p_rel :< dir_or_state_nontemp_rel.
_inside_p_dir_rel := _inside_p_rel & dir_rel.
_into_p_rel :< dir_rel.
_just+like_p_rel :< miscprep_rel.
_less+than_p_rel :< miscprep_rel.
_like_p_rel :< miscprep_rel.
_maximum_p_rel :< miscprep_rel.
_more+than_p_rel :< miscprep_rel.
_namely_p_rel :< miscprep_rel.
_nationwide_a_rel :< miscprep_rel.
_near_p_rel :< dir_or_state_nontemp_rel.
_near_p_dir_rel := _near_p_rel & dir_rel.
_nearby_p_rel :< miscprep_rel.
_next+to_p_rel :< dir_or_state_nontemp_rel.
_next+to_p_dir_rel := _next+to_p_rel & dir_rel.
_notwithstanding_p_rel :< miscprep_rel.
of_p_rel :< miscprep_rel.
_of_p_rel :< of_p_rel.
_off+of_p_rel :< miscprep_rel.
_off_p_rel :< dir_or_state_nontemp_rel.
_off_p_dir_rel := _off_p_rel & dir_rel.
_on_p_rel :< dir_or_state_nontemp_rel.
_on_p_dir_rel := _on_p_rel & dir_rel.
_on_p_temp_rel :< temp_loc_sp_rel.
_on+behalf+of_p_rel :< miscprep_rel.
_on+board_p_rel :< miscprep_rel.
_on+foot_p_rel :< miscprep_rel.
_on+the+basis+of_p_rel :< miscprep_rel.
_on+the+part+of_p_rel :< miscprep_rel.
_onto_p_rel :< dir_rel.
_onward_p_rel :< dir_rel.
_onwards_p_rel :< dir_rel.
_opposite_p_rel :< dir_rel.
_other+than_p_rel :< miscprep_rel.
_out_p_rel :< dir_or_state_nontemp_rel.
_out_p_dir_rel := _out_p_rel & dir_rel.
_out+of_p_rel :< dir_or_state_nontemp_rel.
_outside_p_rel :< dir_or_state_nontemp_rel.
_outside_p_dir_rel := _outside_p_rel & dir_rel.
_outside+of_p_rel :< dir_or_state_nontemp_rel.
_over_p_rel :< dir_or_state_nontemp_rel.
_over_p_dir_rel := _over_p_rel & dir_rel.
_over_p_temp_rel :< temp_loc_sp_rel.
_overland_p_rel :< miscprep_rel.
_overnight_a_rel :< adj_rel.
_past_p_rel :< miscprep_rel.
_per_p_rel :< miscprep_rel.
_previous+to_p_rel :< temp_loc_rel.
_prior+to_p_rel :< temp_loc_rel.
_regarding_p_rel :< miscprep_rel.
_right+away_p_rel :< miscprep_rel.
_since_p_rel :< temp_loc_rel.
_straight_a_rel :< dir_or_state_nontemp_rel.
_such+as_p_rel :< miscprep_rel.
_than_p_ind_rel :< miscprep_rel.
_then_p_temp_rel :< miscprep_rel.
_thereabouts_p_rel :< miscprep_rel.
_thereof_p_rel :< miscprep_rel.
_therewith_p_rel :< miscprep_rel.
_thither_p_rel :< miscprep_rel.
_thitherward_p_rel :< miscprep_rel.
_through_p_rel :< miscprep_rel.
_throughout_p_rel :< dir_or_state_nontemp_rel.
_throughout_p_dir_rel := _throughout_p_rel & dir_rel.
_to+do+with_p_rel :< miscprep_rel.
_to_p_rel := dir_rel & to_or_with_p_rel.
_together_p_rel :< dir_rel.
_together+with_p_rel :< miscprep_rel.
_toward_p_rel :< dir_rel.
_towards_p_rel :< dir_rel.
_under_p_rel :< dir_or_state_nontemp_rel.
_under_p_dir_rel := _under_p_rel & dir_rel.
_unlike_p_rel :< miscprep_rel.
_until_p_rel :< miscprep_rel.
_unto_p_rel :< dir_rel.
_up_p_rel :< dir_rel.
_uphill_p_rel :< dir_rel.
_up+until_p_rel :< miscprep_rel.
_upon_p_rel :< state_loc_rel.
_upstairs_p_rel :< miscprep_rel.
_upstream_p_rel :< miscprep_rel.
_via_p_rel :< miscprep_rel.
_viz_p_rel :< miscprep_rel.
_whither_p_rel := dir_rel.
_whence_p_rel := dir_rel.
with_p_rel :< miscprep_rel.
_with_p_rel := with_p_rel & to_or_with_p_rel.
_within_p_rel :< dir_or_state_nontemp_rel.
_without_p_rel :< miscprep_rel.
_worth_p_rel :< miscprep_rel.
_yet_a_rel :< neg_polar_rel.

_anymore_a_rel :< neg_polar_rel.
_any+longer_a_rel :< neg_polar_rel.
_as+of+yet_a_rel :< neg_polar_rel.
_at+all_a_rel :< neg_polar_rel.
_ever_a_rel :< neg_polar_rel.
_nomore_a_rel :< neg_polar_rel.
_or+what_a_rel :< neg_polar_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Determiner preds

_a+few_q_rel :< explicit_quant_noagr_q_rel.
_a+little_q_rel :< explicit_quant_noagr_q_rel.
_a_q_rel :< some_q_rel.
_such+a_q_rel :< some_q_rel.
_what+a_q_rel :< some_q_rel.
_another_q_rel := some_q_rel.
_any_q_rel :< any_q_rel.
both_all_q_rel :< quant_rel.
_both_q_rel := def_explicit_q_rel & both_all_q_rel.
_each_q_rel :< explicit_quant_noagr_q_rel.
_either_q_rel :< explicit_quant_agr_q_rel.
_enough_q_rel :< explicit_quant_agr_q_rel.
_every_q_rel :< every_q_rel.
_few_q_rel :< explicit_quant_noagr_q_rel.
_half_q_rel :< explicit_quant_agr_q_rel.
_less_q_rel :< explicit_quant_noagr_q_rel.
_little_q_rel :< explicit_quant_noagr_q_rel.
_many_q_rel :< much_many_q_rel.
_more_q_rel :< explicit_quant_agr_q_rel.
_most_q_rel :< explicit_quant_agr_q_rel.
_much_q_rel :< much_many_q_rel.
_neither_q_rel :< explicit_quant_noagr_q_rel.
_no_q_rel :< no_q_rel.
_several_q_rel :< explicit_quant_noagr_q_rel.
_some_q_rel :< some_q_rel.
_some_q_indiv_rel :< some_q_rel.
_such_q_rel :< explicit_q_rel.
_that_q_dem_rel :< demon_far_q_rel.
_the+same_q_rel :< explicit_quant_agr_q_rel.
_the+most_q_rel :< explicit_quant_agr_q_rel.
_these_q_dem_rel :< demon_near_q_rel.
_this_q_dem_rel :< demon_near_q_rel.
_those_q_dem_rel :< demon_far_q_rel.
_umpteen_q_rel :< explicit_quant_noagr_q_rel.
_which_q_rel :< which_q_rel.
_a+couple_q_rel :< explicit_quant_noagr_q_rel.
_any+more_q_rel :< explicit_quant_agr_q_rel.
_no+more_q_rel :< explicit_quant_agr_q_rel.
_some+more_q_rel :< explicit_quant_agr_q_rel.
_one+or+more_q_rel :< explicit_quant_noagr_q_rel.
_less+than+a_q_rel :< some_q_rel.
_part_q_rel :< explicit_quant_noagr_q_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Message preds

message_m_rel := predsort.
prop_imp_m_rel := message_m_rel.
imp_m_rel := prop_imp_m_rel.
;for COMPS of e.g. 'know':
prop_ques_m_rel := message_m_rel.
prpstn_or_like_m_rel := message_m_rel.
propositional_m_rel := prop_ques_m_rel & prpstn_or_like_m_rel.
prpstn_m_rel := propositional_m_rel & prop_imp_m_rel.
; For interrogatives; PARAMS value is a set of handles.
abstr_int_m_rel := message_m_rel.
int_m_rel := abstr_int_m_rel & prop_ques_m_rel.

; Subtype of int_m_rel for tag questions.   
ne_m_rel := abstr_int_m_rel.
; Subtype to distinguish complementizer "like" from "that", to block
; '*Kim said like Sandy left' and '*it looks that Sandy left"
like_mood_m_rel := prpstn_or_like_m_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; pred sorts

predsort := *sort*.

non_number_rel := predsort.
norm_rel := non_number_rel.
event_or_degree_or_no_rel := predsort.
non_conj_rel := predsort.
norm_non_conj_rel := non_conj_rel & norm_rel.
event_or_degree_rel := norm_non_conj_rel & event_or_degree_or_no_rel.
event_rel := event_or_degree_rel.
; Needed to divide two types of head-specifier phrases
compos_spec_rel := predsort.

; Subtypes of this relation are the types for particle semantics in
; verb-particle constructions like _together_rel in "get together"
; DPF 15-Apr-01 - Removed ASPECT no_aspect, since want to let "of" be progr*
; to block e.g. "as of NP"

selected_rel := event_rel.
selected_adj_rel := selected_rel & abstr_adj_rel.
selected_adv_rel := selected_rel & basic_adv_rel.
selected_prep_rel := selected_rel & prep_rel.

independent_rel := predsort.
non_event_rel := norm_non_conj_rel.
non_ellipt_rel := predsort.
aux_event_rel := event_rel & non_ellipt_rel.
aux_arg1_rel := aux_event_rel & v_event_rel.
nonaux_event_rel := non_ellipt_rel.
non_freerel_rel := independent_rel.
no_rel := non_freerel_rel & non_conj_rel & event_or_degree_or_no_rel &
          nonaux_event_rel & non_number_rel.
never_unify_rel := predsort.

; For appositives
appos-able_rel := predsort.
indef_or_meas_rel := appos-able_rel.

; For QUE-word complements as in "what the hell"
wh_the_hell_rel := predsort.
norm_dim_rel := norm_non_conj_rel.
basic_event_dim_rel := norm_dim_rel & event_rel.
non_event_dim_rel := non_event_rel & norm_dim_rel.
quant_or_deg_rel := non_event_dim_rel.
i_or_e_quant_or_deg_rel := quant_or_deg_rel.
quant_or_wh_rel := quant_or_deg_rel.
quant_rel := quant_or_wh_rel.
non_freerel_q_or_meas_rel := non_freerel_rel.
non_freerel_q_rel := non_freerel_q_or_meas_rel & quant_rel.
impl_or_expl_q_rel := non_freerel_q_rel & i_or_e_quant_or_deg_rel.
; Used in bare plurals
impl_or_proper_q_rel := quant_rel.
; Used in appositive rule
implicit_q_rel := impl_or_expl_q_rel & impl_or_proper_q_rel.
explicit_q_rel := impl_or_expl_q_rel.
; Determiners with these relations show agreement with of_PP in partitives
explicit_quant_agr_q_rel := explicit_q_rel.
; These don't
explicit_quant_or_udef_noagr_q_rel := impl_or_expl_q_rel.
explicit_quant_noagr_q_rel := explicit_q_rel & 
                              explicit_quant_or_udef_noagr_q_rel.
much_many_q_rel := explicit_quant_noagr_q_rel.
; DPF 19-Oct-02 - This is to allow not only ordinary bare plurals, but also
; "afternoons" which must be the one that takes an optional PP-of and
; usually requires a definite determiner (unless it's a bare plural)

abstr_def_or_udef_q_rel := quant_rel.
def_or_udef_q_rel := abstr_def_or_udef_q_rel.
def_or_proper_q_rel := abstr_def_or_udef_q_rel.
udef_q_rel := implicit_q_rel & explicit_quant_or_udef_noagr_q_rel &
              def_or_udef_q_rel.
some_q_rel := explicit_quant_agr_q_rel & indef_or_meas_rel.
any_q_rel := explicit_quant_agr_q_rel.
every_q_rel := explicit_q_rel.
no_q_rel := explicit_q_rel.
abstr_def_q_rel := def_or_udef_q_rel.
def_q_rel := abstr_def_q_rel & implicit_q_rel.
def_explicit_q_rel := abstr_def_q_rel & explicit_quant_noagr_q_rel &
                      def_or_proper_q_rel & appos-able_rel.
def_both_rel := def_explicit_q_rel.
; Used only in KEYS.KEY
nondef_explicit_q_rel := explicit_q_rel.
; Used by NP-N-cmpnd rule:
meas_np_or_proper_q_rel := relation.
; Used for lexical NPs including proper names
; It is distinct from i_or_e_quant_or_deg_rel to prevent relative clauses
; from attaching to proper names with no specifier.
proper_q_rel := non_freerel_q_rel & def_or_proper_q_rel & impl_or_proper_q_rel
                & meas_np_or_proper_q_rel & appos-able_rel.
number_q_rel := non_freerel_q_rel & def_or_proper_q_rel & appos-able_rel.
; For determiners that can appear e.g. with 'same' (also excluding 'both')
def_or_demon_q_rel :< quant_rel.
pronoun_q_rel := non_freerel_q_rel & def_or_demon_q_rel.
demonstrative_q_rel := explicit_q_rel & def_or_proper_q_rel & 
                       def_or_demon_q_rel.
demon_near_q_rel :< demonstrative_q_rel.
demon_far_q_rel :< demonstrative_q_rel.
basic_free_relative_q_rel :< explicit_quant_noagr_q_rel.
free_relative_q_rel :< basic_free_relative_q_rel.
free_relative_ever_q_rel :< basic_free_relative_q_rel.
_the_q_rel := def_explicit_q_rel & def_or_demon_q_rel.
which_q_rel :< explicit_quant_agr_q_rel.
_all_q_rel := explicit_quant_agr_q_rel & both_all_q_rel.
; For bare plural/mass NPs
; DPF 9-oct-04 - Changed rule for these NPs to simply introduce udef_q_rel
; since this further distinction is not motivated (historically, it was used
; to prevent gerunds from appearing in noun-noun-compounds, but that analysis
; has long since been improved).
; bare_div_q_rel :< implicit_q_rel.
idiom_q_rel :< abstr_def_or_udef_q_rel.

dir_state_modable_rel := predsort.
modable_rel := basic_nom_rel & dir_state_modable_rel.
; nontemp_rel used to distinguish temporal nominal phrases from all others
nontemp_or_conj_rel := norm_rel.
nontemp_rel :< nontemp_or_conj_rel.
instance_rel := independent_rel.
basic_nom_or_mnp_rel := compos_spec_rel.
basic_nom_rel := non_event_rel & instance_rel & basic_nom_or_mnp_rel.
nom_or_mnp_rel := basic_nom_or_mnp_rel.
nom_rel := basic_nom_rel & nom_or_mnp_rel.
nonpro_or_mnp_rel := nom_or_mnp_rel.
nonpro_or_refl_or_num_rel := basic_nom_rel.
nonpro_or_num_rel := nonpro_or_refl_or_num_rel.
nonpro_rel := nom_rel & nonpro_or_mnp_rel & nonpro_or_num_rel.
abstr_meas_nom_rel := nom_rel & meas_np_or_proper_q_rel.
nom_nondim_rel :< nom_rel.
non_temp_nom_rel := nom_nondim_rel & nontemp_rel.
non_temp_nonpro_rel := non_temp_nom_rel & nonpro_rel.
reg_nom_rel := non_temp_nonpro_rel.
modable_nom_rel := non_temp_nonpro_rel & modable_rel.
unspec_diadic_nom_rel := nonpro_rel & nom_nbar_rel.
reg_diadic_nom_rel := unspec_diadic_nom_rel & reg_nom_rel.
basic_diadic_modable_nom_rel := unspec_diadic_nom_rel & modable_rel.
diadic_modable_nom_rel := basic_diadic_modable_nom_rel & modable_nom_rel.
basic_hcomp_nom_rel := non_temp_nonpro_rel & gen_nom_nbar_rel.
hcomp_nom_rel := basic_hcomp_nom_rel & reg_nom_rel.
hcomp_modable_nom_rel := basic_hcomp_nom_rel & modable_rel.
nominalize_rel := basic_hcomp_nom_rel.
gerund_rel := non_temp_nonpro_rel.
; nom_rels for nouns that can undergo nbar-coordination (avoiding proper names)
gen_nom_nbar_rel := nom_rel.
; nom_rels for nouns that can appear in noun_noun compounds (excluding e.g. 
; number-nouns)
nom_nbar_rel:< gen_nom_nbar_rel.
norm_nom_rel := reg_nom_rel & nom_nbar_rel.
temp_abstr_or_conj_rel := predsort.
temp_abstr_rel := nonpro_rel & temp_abstr_or_conj_rel & abstr_meas_nom_rel.
temp_nondim_rel :< temp_abstr_rel.
; Used in NP-N-cmpnd rule, to include measure-NP phrases.
deg_or_named_rel :< norm_rel.
; Used in munging rules to make reversible the implicit quantifier
abstr_named_rel :< deg_or_named_rel.
gen_named_rel := abstr_named_rel.
named_np_or_num_rel :< gen_named_rel.
abstr_named_np_rel :< named_np_or_num_rel.
named_np_rel := abstr_named_np_rel & reg_nom_rel.
;named_num_rel := abstr_named_np_rel & reg_nom_rel & card_rel.
named_num_or_seq_rel :< nom_rel.
; DPF 03-may-04 ; Changed non_temp_nonpro_rel to nom_nocmpnd_rel, to prevent
; these from appearing in N-N-compounds
named_num_rel := named_np_or_num_rel & nom_nocmpnd_rel & nonpro_or_num_rel &
                 named_num_or_seq_rel.
num_seq_nom_rel := named_num_or_seq_rel & non_temp_nom_rel & 
		   named_np_or_num_rel.
named_card_rel := named_num_rel & card_rel.
named_times_rel := named_num_rel & times_rel.
named_plus_rel := named_num_rel & plus_rel.
elliptical_n_rel :< diadic_nom_rel.
; Relation used in decomposed lexical semantics, e.g. for 'when'
temp_rel := abstr_named_rel & modable_rel & temp_abstr_rel.
day_rel :< temp_nondim_rel.
diadic_day_rel := day_rel & unspec_diadic_nom_rel & modable_rel.
named_day_rel := diadic_day_rel & abstr_named_np_rel.
; Needs to inherit from both since we get "on the first day" but "in my day"
unnamed_day_rel := diadic_day_rel & non_day_or_deg_rel.
; DPF 10-Oct-02 - Need to allow measure-NPs to be complements of temporal "in",
; as in "I'll be finished in two chapters".
non_day_or_deg_rel :< norm_rel.
non_day_rel := temp_nondim_rel & non_day_or_deg_rel.
;; day_of_month_rel
; DPF 03-may-04 - Replaced diadic_day_rel with day_rel,modable_rel to prevent
; these from being nom_nbar_rel, so they won't appear in compounds, among
; other unwanted places
dofm_rel := day_rel & modable_rel & gen_named_rel & gen_nom_nbar_rel.

;; Need supertype of dofw_rel and poss_rel and non-'the' quantifiers
;; for the specifier of the small class of words like "morning" as in "my 
;; mornings" or "Tuesday mornings"
dofw_or_poss_q_rel :< norm_rel.
;; day_of_week_rel
dofw_rel := named_day_rel & dofw_or_poss_q_rel.
holiday_rel := non_day_diadic_rel & gen_named_rel.
day_part_rel := diadic_day_rel.
; dim_rel: 'almost three o'clock'
; DPF 2-Apr-02 - Added type for hour_rel and _time_rel, to get both "at three"
; and 'at that time" while distinguishing "kim fell three times" from "*Kim
; fell three o'clock".  Also include seasons, since 'at' uses this sort.
hour_or_time_rel := predsort.
hour_rel := temp_abstr_rel & norm_dim_rel & hour_or_time_rel.
_breakfast_n_time_rel :< hour_rel.
_dinner_n_time_rel :< hour_rel.
_lunch_n_time_rel :< hour_rel.
_supper_n_time_rel :< hour_rel.
_tea_n_time_rel :< hour_rel.
_night_n_time_rel :< hour_rel.
;_minute_n_rel :< modable_hour_or_time_rel.
_minute_n_rel :< hour_rel.
; a quarter till three  ("till" is head - cf "come at a quarter till.")
hour_prep_rel := hour_rel.
gen_hour_rel := hour_rel.
; prep_rels that can modify hour times as in "ten minutes after five"
minute_prep_sel_rel :< selected_prep_rel.

numbered_hour_rel := hour_rel & abstr_named_rel.
; DPF 31-Jul-99 - Changed minute_or_ampm_rel to be non-temp, since it cannot
; appear after temporal prepositions (ignoring the elliptical "I'll see you 
; in ten"), and we also need to block "from ten to eleven o'clock" with
; "ten" as minute.
minute_or_ampm_rel :< nom_nondim_rel.

;modable_hour_rel :< non_day_diadic_modable_rel.
;modable_hour_or_time_rel := modable_hour_rel & hour_or_time_rel.

_second_n_rel :< non_day_diadic_modable_rel.

am_pm_rel :< minute_or_ampm_rel.
bc_ad_rel :< nom_nondim_rel.

ctime_rel :< numbered_hour_rel.

; 'the morning', not 'some morning': 'in the morning' but 'on some morning'
def_day_part_rel :< non_day_diadic_modable_rel.
_afternoon_n_def_rel :< def_day_part_rel.
_evening_n_def_rel :< def_day_part_rel.
_morning_n_def_rel :< def_day_part_rel.
_night_n_def_rel :< def_day_part_rel.
_weekend_n_def_rel :< def_day_part_rel.

non_day_diadic_rel := non_day_rel & unspec_diadic_nom_rel.
non_day_modable_rel := non_day_rel & modable_rel.
non_day_diadic_modable_rel := non_day_diadic_rel & modable_rel.
non_day_time_rel := non_day_diadic_rel & modable_rel & hour_or_time_rel.
; "while"
non_day_nonmodable_rel := non_day_rel & meas_nom_rel.

;; named_month_rel as in "January is fine"
;; DPF 13-Mar-02 - Changed parent non_day_diadic_modable_rel to 
;; non_day_diadic_rel since we were overgenerating: "*Kim arrived June" in 
;; order to admit "Kim arrived last June".  Have to do something else to
;; allow the latter.
mofy_rel := non_day_diadic_rel & abstr_named_np_rel.

yofc_rel := non_day_rel & abstr_named_np_rel.

season_rel := non_day_modable_rel & gen_named_rel.
season_nomod_rel := non_day_rel & gen_named_rel & hour_or_time_rel.

age_rel :< non_day_nonmodable_rel.
_while_n_rel :< non_day_nonmodable_rel.

_morning_n_rel :< day_part_rel.
_afternoon_n_rel :< day_part_rel.
_evening_n_rel :< day_part_rel.
_night_n_rel :< day_part_rel.
_weekend_n_rel :< day_part_rel.
_noon_n_rel :< day_part_rel.
_day_n_rel :< day_rel.

_week_n_rel :< non_day_diadic_modable_rel.
_month_n_rel :< non_day_diadic_modable_rel.
_year_n_rel :< non_day_diadic_modable_rel.
_quarter_n_temp_rel :< non_day_diadic_modable_rel.

duration_rel :< temp_rel.

named_rel := named_np_rel.
named_city_rel := named_np_rel.
named_abb_rel :< named_np_rel.
named_n_rel := gen_named_rel & reg_nom_rel.

gen_numval_rel := non_temp_nonpro_rel.

; For X to Y constructions

interval_rel := unspec_diadic_nom_rel & abstr_named_rel.

; For determinerless-PP nouns ('within range')
bare_nom_rel := non_temp_nonpro_rel.
; Disallow adjective modifiers ('at eye level' but '*at high level')
bare_n_nmod_rel := bare_nom_rel.
; Disallow noun-noun compounding ('at close range' but '*at cellphone range')
bare_n_jmod_rel := bare_nom_rel.
; Disallow any modification ('on top' 'of course')
bare_n_nomod_rel := bare_nom_rel.

mnp_symb_rel := nonpro_rel.

; For 'it is a pleasure to visit abrams.' and 'Abrams is a pleasure to visit.'
prednom_rel := nonpro_rel.
pred_a_rel := independent_rel.

;; The relation event_or_mod_rel is designed to distinguish non-nominal signs, 
;; including verbs, adjectives, prepositions, and adverbs.  One use of this 
;; distinction is for the conjuncts accepted by "but": "*Kim but Sandy left."

event_or_mod_rel := predsort.

mod_rel :< event_or_mod_rel.

event_mod_rel := event_rel & mod_rel.
event_arg_dim_rel := event_mod_rel & basic_event_dim_rel.
event_dim_rel := basic_event_dim_rel & nonaux_event_rel.
independent_mod_rel := independent_rel & mod_rel.
abstr_excl_rel := independent_mod_rel.

greet_rel :< abstr_excl_rel.

excl_rel :< abstr_excl_rel.
; For adjectival pro-forms like "the last", and derived number-nouns, neither
; of which appear in N-N-compounds
nom_nocmpnd_rel :< non_temp_nom_rel.
num_nocmpnd_rel := nom_nocmpnd_rel & nonpro_or_num_rel & part_nom_rel.
_one_n_rel := nom_nocmpnd_rel & nonpro_rel.

basic_pron_rel := non_temp_nom_rel & abstr_named_rel.
pron_rel := basic_pron_rel.

; DPF 9-oct-04 - Note that we don't parse "we showed the children themselves" 
; since we want to block pronouns as second NP in double-NP constructions as 
; for "*We sent the books them".

refl_pron_rel := non_temp_nom_rel & nonpro_or_refl_or_num_rel.
recip_pro_rel := non_temp_nonpro_rel.
generic_nom_rel := non_temp_nonpro_rel.
; For partitives
generic_nonpro_rel := non_temp_nonpro_rel.

basic_adj_rel := event_dim_rel & nontemp_rel & compos_spec_rel.
abstr_adj_rel := basic_adj_rel & event_arg_dim_rel.
adj_rel := abstr_adj_rel & independent_mod_rel.
norm_adj_rel :< adj_rel.
expl_adj_rel := basic_adj_rel & independent_rel.
it_adj_rel := abstr_adj_rel.
meas_adj_rel := abstr_adj_rel.
adj_personal_rel :< adj_rel.
adj_abstract_rel :< adj_rel.
generic_adj_rel :< adj_rel.
verb_aspect_rel := event_rel & independent_rel.

prog_rel :< verb_aspect_rel.

v_event_rel := verb_aspect_rel & event_arg_dim_rel.

mod_role_rel :< v_event_rel.
nonaux_v_rel := mod_role_rel & nonaux_event_rel.

no_role_rel :< mod_role_rel. 
weather_v_rel := no_role_rel & nonaux_v_rel.

role_rel := nontemp_rel & nonaux_v_rel.

modal_rel := aux_arg1_rel.
_can_v_rel :< modal_rel.
_could_v_rel :< modal_rel.
_dare_v_aux_rel :< modal_rel.
_have_v_to_rel :< modal_rel.
_may_v_rel :< modal_rel.
_might_v_rel :< modal_rel.
_must_v_rel :< modal_rel.
_need_v_aux_rel :< modal_rel.
_ought_v_rel :< modal_rel.
_shall_v_rel :< modal_rel.
_should_v_rel :< modal_rel.
_used+to_v_aux_rel :< modal_rel.
_had+better_v_rel :< modal_rel.
ellipsis_rel := v_event_rel.
; Used to ensure tag question agreement, but will not appear in RELS.
have_aux_rel := v_event_rel & aux_event_rel.
; For infinitival relatives and purposive-to constructions: 'Kim is to stay'
expected_inf_rel := v_event_rel.

; Needed to allow filtering of the relations for "will" and "would" for VIT.
will_would_rel :< aux_arg1_rel.
_will_v_aux_rel :< will_would_rel.
_would_v_rel := will_would_rel.
_going+to_v_rel :< will_would_rel.
would_like_rel := predsort.
generic_verb_rel :< event_dim_rel.
;;_colon_v_rel :< v_event_rel.

; AAC - added for frag-msg
abstr_1_rel := basic_nom_rel.
; AAC - added for wh_adjective_word
abstr_nom_rel := event_mod_rel & basic_nom_rel.

prep_rel := event_dim_rel.
basic_prep_mod_rel := prep_rel & event_arg_dim_rel & independent_rel.
prep_mod_rel :< basic_prep_mod_rel.
nontemp_prep_rel := prep_mod_rel & nontemp_rel.
; Collapse next two?
poss_rel := of_p_rel & dofw_or_poss_q_rel.
loc_abstr_rel :< prep_mod_rel.
dir_or_state_rel := loc_abstr_rel & dir_state_modable_rel.
dir_or_state_nontemp_rel := dir_or_state_rel & nontemp_prep_rel.
dir_rel := dir_or_state_nontemp_rel & dir_or_unsp_loc_rel.
state_loc_rel := dir_or_state_nontemp_rel.
generic_loc_rel :< loc_abstr_rel.

temp_loc_abstr_rel :< loc_abstr_rel.
; Not wanted - allows unification of nontemp_rel and temp_loc_rel.
;;unspec_temp_loc_abstr_rel := temp_loc_abstr_rel & unspec_loc_rel.

miscprep_rel :< nontemp_prep_rel.

temp_loc_rel := temp_loc_abstr_rel & independent_mod_rel.
; Specific temporal locatives in, on, at
temp_loc_sp_rel := temp_loc_rel.

part_nom_rel := predsort.
part_of_rel := reg_diadic_nom_rel & part_nom_rel.
part_nc_rel := reg_nom_rel & nom_nbar_rel & part_nom_rel.

diadic_nom_rel := reg_diadic_nom_rel & norm_nom_rel.

loc_rel := dir_or_state_rel.

dir_or_unsp_loc_rel :< prep_mod_rel.
; Used for implicit locative, as in "Kim arrived Tuesday"
unspec_loc_rel := loc_rel & dir_or_unsp_loc_rel.
unspec_loc_temp_rel := unspec_loc_rel & temp_loc_abstr_rel.
unspec_loc_nontemp_rel := unspec_loc_rel & nontemp_rel.

interval_start_rel :< miscprep_rel.
interval_end_rel := miscprep_rel.

; for 'talk to/with X (about Y)', 'speak' etc
to_or_with_p_rel :< nontemp_prep_rel.

; For "how"
unspec_manner_rel :< miscprep_rel.

basic_adv_rel := non_event_rel & nontemp_rel & event_or_degree_rel.
abstr_adv_rel := basic_adv_rel & independent_mod_rel.

abstr_adv_dim_rel := abstr_adv_rel & non_event_dim_rel.

adv_rel :< abstr_adv_dim_rel.

neg_rel :< abstr_adv_rel.
_never_a_rel :< abstr_adv_rel.
generic_adv_rel :< abstr_adv_rel.

neg_polar_rel :< abstr_adv_dim_rel.
long_r_rel :< abstr_adv_dim_rel.

degree_rel := compos_spec_rel & independent_rel & event_or_degree_rel
             & i_or_e_quant_or_deg_rel & non_day_or_deg_rel & deg_or_named_rel.
comp_degree_rel :< degree_rel.
non_comp_degree_rel :< degree_rel.

; For the subset of specifiers needed for adjectives (but not, e.g., subconj)
; DPF 07-may-04 - Added non_temp_nom_rel to allow MNPs as complements of
; e.g. 'under' which wants non-temporal NP.  Also blocks spurious parse for
; "kim sings in ten minutes"
much_or_very_deg_rel := degree_rel & nonpro_or_mnp_rel & non_temp_nom_rel &
                        nonpro_or_num_rel.

; For specifiers of adjectives
deg_rel :< non_comp_degree_rel.

; For specifiers of positive adjectives
very_deg_rel := deg_rel & much_or_very_deg_rel.

; For degree specifiers "this/that/too/as" as in "that much", "so tall"
this_that_deg_rel :< very_deg_rel.
; For as..as, too..to
comp_as_too_degree_rel := this_that_deg_rel & comp_more_less_rel.
enough_deg_rel :< degree_rel.

; For specifiers of "the", including "only" and "just"
just_only_degree_rel :< degree_rel.
just_only_very_deg_rel := just_only_degree_rel & very_deg_rel.
just_only_deg_rel := just_only_degree_rel & deg_rel.

; For "how" degree specifier
abstr_deg_rel :< this_that_deg_rel.

; For specifiers of comparative adjectives
much_deg_rel := deg_rel & much_or_very_deg_rel.
; To constrain adjectives to only take "much", as with modifiee of "than Sandy"
much_deg_only_rel :< much_deg_rel.

; For conjoined spr-less adjectives as in "sunny and cooler"
; DPF 5-Sep-03 - But this eliminates the blocking of inappropriate degree specs
; for head that want only one or the other.
;;very_and_much_deg_rel := very_deg_rel & much_deg_rel.

; For e.g. 'eightish'
approx_grad_rel :< deg_rel.

; For syntactic rules (for indexing for generation)
gen_deg_rel :< deg_rel.
comparative_rel := comp_degree_rel.
comp_more_less_rel := comparative_rel.
_more_x_comp_rel :< comp_more_less_rel.
_less_x_comp_rel :< comp_more_less_rel.
comp_most_least_rel := comparative_rel.
_most_x_comp_rel :< comp_most_least_rel.
_least_x_comp_rel :< comp_most_least_rel.

; For measure-NPs
measure_rel :< non_comp_degree_rel.

;; For "how" adjective, which quantifies over properties.
property_rel :< reg_nom_rel.
prpstn_to_prop_rel := event_rel.
comp_rel := miscprep_rel.
superl_rel := miscprep_rel.
difference_rel := miscprep_rel.

; Abstract prep relations
; Needed for idiosyncratic decomposition of "why"
cause :< miscprep_rel.

subord_rel := independent_rel & norm_rel.
cop_id_rel :< v_event_rel.
_be_v_id_rel :< cop_id_rel.
title_id_rel := cop_id_rel.
person_name_rel := cop_id_rel.
unspec_adj_rel :< adj_rel.
number_rel :< reg_diadic_nom_rel.
quantity_rel :< reg_diadic_nom_rel.
_be_v_prd_rel := v_event_rel & aux_event_rel.
;_dollar_n_rel :< norm_nom_rel.
_dollar_n_rel :< meas_nom_rel.
unk_n_rel :< norm_nom_rel.
gen_currency_rel :< reg_nom_rel.
; To distinguish class of nouns that can serve as measure-NP PP-specifiers
meas_nom_rel := reg_nom_rel & nom_nbar_rel & abstr_meas_nom_rel & 
                indef_or_meas_rel & non_freerel_q_or_meas_rel.

unspec_rel := prep_rel.

compound_rel := unspec_rel.
appos_rel := unspec_rel.
compound_name_rel := unspec_rel.

; Used for vocatives.
unspec_mod_rel :< prep_mod_rel.

; Relation introduced for tag questions
probable_rel :< adj_rel.

; For comparative "as possible" (hack)
possible_rel :< adj_rel.

basic_conj_rel := non_freerel_rel & nontemp_or_conj_rel & 
            temp_abstr_or_conj_rel.
conj_rel := basic_conj_rel.
implicit_conj_rel :< conj_rel.
_and_c_rel :< conj_rel.
_and_c_both_rel :< conj_rel.
_and_c_or_rel :< conj_rel.
_and+so_c_rel :< conj_rel.
_and+then_c_rel :< conj_rel.
_after_c_rel :< conj_rel.
_as+well+as_c_rel :< conj_rel.
_as+well+as_c_both_rel :< conj_rel.
_but_c_rel :< conj_rel.
_but+not_c_rel :< conj_rel.
_minus_c_rel :< conj_rel.
_nor_c_rel :< conj_rel.
_nor_c_neither_rel :< conj_rel.
_or_c_rel :< conj_rel.
_or_c_either_rel :< conj_rel.
_or+else_c_rel :< conj_rel.
_plus_c_rel :< conj_rel.
_rather+than_c_rel :< conj_rel.
_then_c_rel :< conj_rel.
_instead+of_c_rel :< conj_rel.
_so_c_rel :< conj_rel.
_versus_c_rel :< conj_rel.
_except+that_c_rel :< conj_rel.
_except_c_rel :< conj_rel.
_both_c_rel :< conj_rel.
_either_c_rel :< conj_rel.
_neither_c_rel :< conj_rel.
_not_c_rel :< conj_rel.
_etc_c_rel :< conj_rel.
_to+name+a+few_c_rel :< conj_rel.
_yet_c_rel :< conj_rel.
; For fragments
discourse_rel :< conj_rel. 
; For number sequences
num_seq_rel :< conj_rel.

abstr_place_rel := basic_diadic_modable_nom_rel & non_temp_nonpro_rel.
place_rel := abstr_place_rel & abstr_named_rel.
_place_n_rel :< place_rel.

time_rel := modable_rel & temp_abstr_rel & independent_mod_rel.
_time_n_rel :< time_rel.
_awhile_n_rel :< time_rel.
person_rel :< norm_nom_rel.
thing_rel :< norm_nom_rel.
next_prev_rel :< adj_rel.
manner_rel :< norm_nom_rel.
reason_rel := norm_nom_rel.
title_rel := basic_nom_rel.
; As in "chairs, tables, and the like"
like_n_rel :< norm_nom_rel.
; 'Next week, last night, all day'
_next_a_rel := next_prev_rel & dofw_or_poss_q_rel.
_last_a_rel := adj_rel & dofw_or_poss_q_rel.
_all_a_rel := adj_rel & dofw_or_poss_q_rel.
_late_a_rel := adj_rel & dofw_or_poss_q_rel.
v_event_arg1_rel := aux_event_rel & v_event_rel.
_be_v_there_rel :< v_event_arg1_rel.
_be_v_itcleft_rel :< v_event_arg1_rel.
_exist_v_there_rel :< v_event_arg1_rel.
_gotta_v_rel :< modal_rel.
_got_v_to_rel :< v_event_arg1_rel.

; Want these to undergo the adj-coord rule
integer_rel := compos_spec_rel & independent_mod_rel &
               event_arg_dim_rel.
const_rel := integer_rel & gen_named_rel.
plus_rel := integer_rel.
times_rel := integer_rel.
ord_rel :< const_rel.
card_rel :< const_rel.
; DPF 23-May-03 - minute_n_rel is never in a predicative adjective lexeme, so
; we can identify its ARG0 with its ARG1, to allow ordinary cardinal adjectives
; to specialize to minute semantics and let hour-words get the ARG0 index of
; the minute_rel by asking for the lexeme's HOOK.INDEX which is reentrant with
; ARG1 like ordinary adjectives.
minute_rel :< card_rel.
range_num_rel :< const_rel.
fraction_rel :< const_rel.
unknown_rel :< v_event_rel.

punct_rel :< predsort.
paren_rel :< punct_rel.
hyphen_rel :< punct_rel.
dbl_hyphen_rel :< punct_rel.

idiom_expr := sign &
  [ IDIOM + ].

v_nbar_idiom := idiom_expr &
  [ SYNSEM.LOCAL.CONT.RELS <! [ LBL handle,
                                ARG0 event,
                                ARG1 ref-ind,
                                ARG2 ref-ind & #arg2 ],
                              [ LBL handle,
                                ARG0 #arg2 ] !> ].

v_nbar_pp_idiom := idiom_expr &
  [ SYNSEM.LOCAL.CONT.RELS <! [ LBL handle,
                                ARG0 event,
                                ARG1 ref-ind,
                                ARG2 ref-ind & #arg2,
                                ARG3 ref-ind & #arg3 ],
                              [ LBL handle,
                                ARG0 #arg2 ],
                              [ LBL handle,
                                ARG0 event,
                                ARG1 individual_min,
                                ARG2 #arg3 ] !> ].

; Punctuation marks

punctuation_min :< *avm*.
punctuation := punctuation_min &
 [ LPUNCT basic_punct_mark,
   RPUNCT basic_punct_mark ].

no_punctuation := punctuation &
 [ LPUNCT no_punct,
   RPUNCT no_punct ].

basic_punct_mark := *avm*.
clause_or_semicol_or_no_punct := basic_punct_mark &
  [ MSGPRED predsort ].
clause_or_pair_or_no_punct :< basic_punct_mark.
clause_or_no_punct := clause_or_semicol_or_no_punct & 
                      clause_or_pair_or_no_punct.
comma_or_clause_or_no_punct := basic_punct_mark.
comma_or_hyphen_or_pair_or_no_punct := basic_punct_mark.
hyphen_sgl_or_pair_or_no_punct := comma_or_hyphen_or_pair_or_no_punct.
comma_or_pair_or_no_punct := comma_or_hyphen_or_pair_or_no_punct.
hyphen_sgl_or_clause_or_no_punct := basic_punct_mark.
hyphen_dbl_or_clause_or_no_punct := basic_punct_mark.
3dots_or_clause_or_no_punct := basic_punct_mark.
comma_or_no_punct := comma_or_clause_or_no_punct & comma_or_pair_or_no_punct.
hyphen_sgl_or_no_punct := hyphen_sgl_or_clause_or_no_punct &
                          hyphen_sgl_or_pair_or_no_punct.
hyphen_dbl_or_no_punct := hyphen_dbl_or_clause_or_no_punct.
3dots_or_no_punct := 3dots_or_clause_or_no_punct.
colon_or_no_punct := basic_punct_mark.
pair_or_no_punct := comma_or_pair_or_no_punct & hyphen_sgl_or_pair_or_no_punct
                    & clause_or_pair_or_no_punct.
no_punct := clause_or_no_punct & comma_or_no_punct & hyphen_sgl_or_no_punct &
            hyphen_dbl_or_no_punct & 3dots_or_no_punct & colon_or_no_punct &
            pair_or_no_punct.
punct_mark :< basic_punct_mark.

hyphen_sgl_or_clause :< punct_mark.
hyphen_sgl := hyphen_sgl_or_clause & hyphen_sgl_or_no_punct.
hyphen_dbl_or_clause :< punct_mark.
hyphen_dbl := hyphen_dbl_or_clause & hyphen_dbl_or_no_punct.
comma_or_clause := comma_or_clause_or_no_punct & punct_mark.
comma_or_pair_punct := comma_or_pair_or_no_punct.
comma_punct := comma_or_clause & comma_or_no_punct & comma_or_pair_punct.
3dots_or_clause :< punct_mark.
3dots_punct := 3dots_or_clause & 3dots_or_no_punct & basic_clause_punct.
basic_semicol_punct := clause_or_semicol_or_no_punct & punct_mark.
semicol_punct := basic_clause_punct.
colon_punct := colon_or_no_punct & punct_mark.

basic_clause_punct := clause_or_no_punct & basic_semicol_punct.

clause_c_punct := comma_or_clause & basic_clause_punct.
clause_sh_punct := hyphen_sgl_or_clause & basic_clause_punct.
clause_dh_punct := hyphen_dbl_or_clause & basic_clause_punct.
s_dash_punct := basic_clause_punct.
s_colon_punct := basic_clause_punct.
pair_punct := punct_mark & pair_or_no_punct & comma_or_pair_punct.

; Inserted by preprocessor.
cap_punct :< punct_mark.
