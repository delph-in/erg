;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-1999
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  fundamentals.tdl
;;;
;;;  Basic definitions of types for English grammar
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$

:begin :type.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

; Person and number represented as atomic sorts, with gender a separate attrib
; relevant for 3sg, and where count/mass distinction only for 3sg neuter.

pernum :< *sort*.
1or3sg :< pernum.
non3sg :< pernum.
non1sg :< non3sg.
2per :< non1sg.
1or3pl :< non1sg.
1per := 1or3sg & non3sg.
1per+non1sg := 1per & non1sg.

1sg* :< 1per.
1pl* :< 1or3pl.
2sg* :< 2per.
2pl* :< 2per.
3pl* :< 1or3pl.
3sg* :< 1or3sg.

1per+3sg* := 1per & 3sg*.
1or3pl+1per+non1sg := 1or3pl & 1per+non1sg.
1sg*+1per+non1sg := 1or3pl+1per+non1sg.
3sg*+1per+non1sg := 1per+3sg* & 1per+non1sg.
2per+1per+non1sg := 2per & 1per+non1sg.
2sg*+2per+1per+non1sg := 2sg* & 2per+1per+non1sg.
2pl*+2per+1per+non1sg := 2pl* & 2per+1per+non1sg.
2per+3sg*+1per+non1sg := 3sg*+1per+non1sg & 2per+1per+non1sg.
1or3pl+3sg*+1per+non1sg := 3sg*+1per+non1sg & 1or3pl+1per+non1sg.
1sg*+1or3pl+1per+non1sg := 1sg*+1per+non1sg.
1pl*+1or3pl+1per+non1sg := 1pl* & 1or3pl+1per+non1sg.
3pl*+1or3pl+1per+non1sg := 3pl* & 1or3pl+1per+non1sg.
2per+1or3pl := 2per & 1or3pl.
1or3pl+2per+1per+non1sg := 2per+1per+non1sg & 1or3pl+1per+non1sg & 2per+1or3pl.
1sg*+2per+1per+non1sg := 1sg*+1per+non1sg & 1or3pl+2per+1per+non1sg.
1sg*+2per+1per+1or2pl+non1sg := 1sg*+2per+1per+non1sg.
1pl*+1or3pl := 1pl* & 2per+1or3pl.
2sg*+1or3pl := 2sg* & 2per+1or3pl.
2pl*+1or3pl := 2pl* & 2per+1or3pl.
3pl*+1or3pl := 3pl* & 2per+1or3pl.

1sg_and_1pl := 1sg*+1or3pl+1per+non1sg & 1pl*+1or3pl+1per+non1sg.
1sg_and_2per := 1sg*+2per+1per+non1sg.
1sg_and_2sg := 1sg*+2per+1per+1or2pl+non1sg & 2sg*+2per+1per+non1sg & 
               2sg*+1or3pl.
1sg_and_2pl := 1sg*+2per+1per+1or2pl+non1sg & 2pl*+2per+1per+non1sg & 
               2pl*+1or3pl.
1sg_and_3pl := 1sg*+1or3pl+1per+non1sg & 3pl*+1or3pl+1per+non1sg.
1sg_and_3sg := 1sg* & 1per+3sg*.
1pl_and_2per := 1pl*+1or3pl.
1pl_and_2sg := 1pl*+1or3pl & 2sg*+1or3pl.
1pl_and_2pl := 1pl*+1or3pl & 2pl*+1or3pl.
1pl_and_3pl := 1pl* & 3pl*.
1pl_and_3sg := 1pl*+1or3pl+1per+non1sg & 1or3pl+3sg*+1per+non1sg.
2per_and_3pl := 3pl*+1or3pl.
2per_and_3sg := 2per+3sg*+1per+non1sg.
2sg_and_2pl := 2sg* & 2pl*.
2sg_and_3pl := 2sg*+1or3pl & 3pl*+1or3pl.
2sg_and_3sg := 2sg*+2per+1per+non1sg & 2per+3sg*+1per+non1sg.
2pl_and_3pl := 2pl*+1or3pl & 3pl*+1or3pl.
2pl_and_3sg := 2pl*+2per+1per+non1sg & 2per+3sg*+1per+non1sg.
3pl_and_3sg := 1or3pl+3sg*+1per+non1sg & 3pl*+1or3pl+1per+non1sg.



strict_sort :< *sort*.

;; GLBs
strict_pernum := pernum & strict_sort.
strict_1or3sg := 1or3sg & strict_pernum.
strict_non3sg := non3sg & strict_pernum.
strict_non1sg := non1sg & strict_non3sg.
strict_1or3pl := 1or3pl & strict_non1sg.
strict_2per := 2per & strict_non1sg.

1sg := 1sg* & strict_1or3sg & strict_non3sg.
1pl := 1pl* & strict_1or3pl.
2sg := 2sg* & strict_2per.
2pl := 2pl* & strict_2per.
3sg := 3sg* & strict_1or3sg.
3pl := 3pl* & strict_1or3pl.

gender :< *sort*.
masc* :< gender.
fem* :< gender.
neut* :< gender.
andro* :< gender.
andro1* :< gender.

masc_and_fem := masc* & fem*.
masc_and_neut := masc* & neut*.
masc_and_andro := masc* & andro*.
fem_and_neut := fem* & neut*.
fem_and_andro := fem* & andro*.
neut_and_andro := neut* & andro*.

masc := masc* & strict_sort.
fem := fem* & strict_sort.
neut := neut* & strict_sort.
andro := andro* & strict_sort.
andro1 := andro1* & strict_sort.

png := *avm* & 
  [ PN pernum,
    GEN gender ].

; ERB declarative and interrogative seem to form a natural class
; in that 'know', 'guess', 'suspect' ... take either.  The type
; decl_int is meant to reflect this.  
; ERB (23-07-96) declarative and imperative also form a class 
; with respect to tag questions.  The type decl_imp is meant to
; reflect this.

cl_mode :< *sort*.
no_cl_mode :< cl_mode.
relative :< cl_mode.
decl_int :< cl_mode.
decl_imp :< cl_mode.
declarative := decl_int & decl_imp.
interrogative :< decl_int.
imperative :< decl_imp.


voice :< *sort*.
active :< voice.
passive :< voice.
act+pass := active & passive.

mood :< *sort*.
ind_or_mod_subj :< mood.

indicative* :< ind_or_mod_subj.
modal_subj* :< ind_or_mod_subj.
subjunctive* :< mood.

indicative := indicative* & strict_sort.
modal_subj := modal_subj* & strict_sort.
subjunctive := subjunctive* & strict_sort.

ind+modsubj := indicative* & modal_subj*.

prontype :< *sort*.
std_pron :< prontype.
std_1sg :< std_pron.
std_1pl :< std_pron.
std_2 :< std_pron.
std_3 :< std_pron.
recip :< prontype.
refl :< prontype.
impers :< prontype.
demon :< prontype.
zero_pron :< prontype.

; Three-valued sort evoking Polish logician Jan Lukasiewicz
luk :< *sort*.
; NA for Not Applicable.  A strictly-typed implementation would obviate need
; for this subtype, and we could just employ bool.
na_or_+ :< luk.
na_or_- :< luk.

na := na_or_+ & na_or_-.
bool :< luk.
+* := bool & na_or_+.
-* := bool & na_or_-.

; To enable coordination of unlike values, we add the intermediate types +* and
; -+, along with the conjoined type.

+_and_- := +* & -*.
+ :< +*.
- :< -*.

; Three-valued sort for distinguishing unmodified signs from both left-modified
; and right-modified signs

xmod :< *sort*.
notmod_or_rmod :< xmod.
notmod :< notmod_or_rmod.
hasmod :< xmod.
lmod* :< hasmod.
rmod* := hasmod & notmod_or_rmod.

lmod := lmod* & strict_sort.
rmod := rmod* & strict_sort.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subtypes of *diff-list*

;; Experimental use of subtypes of *diff-list* to enforce constraint of at
;; most one element in SLASH (for efficiency, "violin/sonnet" examples
;; notwithstanding).  Will only have effect in LKB version which does the
;; necessary type inference.

0-1-dlist := *diff-list* &
  [ LIST 0-1-list ].
0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].
1-dlist := 0-1-dlist &
  [ LIST 1-list &
	 [ REST #rest & *null* ],
    LAST #rest ].
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Top-level feature geometry
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mod_local :< *avm*.

; The MOD value specifies the type of phrase that a sign can modify, and the
; POSTHEAD value stipulates the relative position of the modifier with
; respect to the head.  (An earlier approach employing a generalization about
; a head being final in its phrase or not might still be considered as an
; alternate to this stipulative one.)
; The POSTHEAD feature should stay with MOD, since only relevant when MOD is
; non-empty.

; DPF 09-Jan-99 - Changed value of MOD to be of type synsem rather than type
; local, since some modifiers (like vocative NPs) only modify SLASH-empty
; phrases, which means they have to have access to the NON-LOCAL feature of
; the phrase they modify.

head_min :< *avm*.

; DPF 16-Aug-99 - Added INV to head type, since need to distinguish root
; from non-root phrases as output from parser, and since inverted S's now have
; MESSAGE empty, we have to require all non-root fragments to be INV -.

head := head_min &
  [ MOD *list*,
    PRD bool,
    INV bool,
    TAM tam].

valence_min :< *avm*.

valence := valence_min &
  [ SUBJ *list*,
    SPR *list*,
    COMPS *list*,
    SPEC *list*,
    --KEYCOMP *avm* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT type

mod-thing :< *avm*.
nothing :< mod-thing.

instloc :< *top*.
thing := mod-thing &
  [ INSTLOC instloc ].

handle :< thing.
individual := thing &
 [ DIVISIBLE bool ].

eventtime :< thing.

; Needed for VITs
hole :< thing.

; DIVISIBLE distinguishes singular count nouns from plural and mass nouns,
; for determiners like "some", and for bare-plural NPs.

index :< individual.

full_index := index &
  [ PNG png,
    PRONTYPE prontype,
    SORT *sort* ].

; This is the type of the index of the phrase modified by predicative PPs, which
; can either modify a ref-ind nominal or an event VP.

non_expl :< individual.

event_or_index :< non_expl.

tense :< *sort*.
aspect :< *sort*.

present* :< tense.
past* :< tense.
future* :< tense.

strict_tense := tense & strict_sort.
present := present* & strict_tense.
past := past* & strict_tense.
future := future* & strict_tense.
pres+past := present* & past*.
pres+fut := present* & future*.
past+fut := past* & future*.

nonprg :< aspect.
nonprf :< aspect.
nonprg+nonprf := nonprg & nonprf.
no_aspect* := nonprg+nonprf.
progr* :< nonprf. 
perf* :< nonprg.

strict_aspect := aspect & strict_sort.
strict_nonprg := nonprg & strict_aspect.
strict_nonprf := nonprf & strict_aspect.
nonprf+nonprg+prog* := nonprg+nonprf & progr*.
nonprf+nonprg+perf* := nonprg+nonprf & perf*.
nonprf+nonprg+no_aspect* :< no_aspect*.

no_aspect := no_aspect* & strict_nonprg & strict_nonprf.
progr := progr* & strict_nonprf.
perf := perf* & strict_nonprg.

noasp+progr := nonprf+nonprg+no_aspect* & nonprf+nonprg+prog*.
noasp+perf := nonprf+nonprg+no_aspect* & nonprf+nonprg+perf*.
progr+perf := nonprf+nonprg+prog* & nonprf+nonprg+perf*.

tam := *avm* &
 [ TENSE tense,
   ASPECT aspect,
   MOOD mood ]. 

event := event_or_index &
  [ E tam ].

; Once used to distinguish discourse adverbs, for VIT purposes - now obsolete?
disc_frag :< event_or_index.

cont :< *avm*.

; LABEL attribute links semantic relation to orthography, more or less.

mod_relation := cont &
  [ HANDEL handle,
    LABEL *list* ].

relation :< mod_relation.

number_or_degree_rel :< relation.

non_number_rel :< relation.

norm_relation :< non_number_rel.

; Subtypes of this relation are the types for particle semantics in
; verb-particle constructions like _together_rel in "get together"
selected_rel :< relation.
; Subtypes of this relation contrast with those of the above, in that they
; supply an "independent" relation.
independent_rel :< mod_relation.

no_rel :< independent_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MRS type
;
;   TOP handle,            ; Local top handle, linked by H-CONS to other handles
;   H-CONS *diff-list*     ; Scope constraints: list of scp_pr's
;   TOP-H handle,          ; Top handle of MRS expression
;   --TOPKEY mod_relation  ; Pointer to relation with TOP handle.

mrs_min := cont &
  [ INDEX individual ].

mrs_min0 := mrs_min &
  [ TOP handle ].

mrs_min1 := mrs_min0 &
  [ LISZT *diff-list*,
    --TOPKEY mod_relation ].
    
mrs := mrs_min1 &
  [ H-CONS *diff-list*,
    WGLISZT *diff-list*,
    TOP-H handle ].

; Constrains handle of scopable argument SC-ARG relative to one or more 
; handles
scp_pr := *top* &
  [ SC-ARG handle ].       

; Constrains KEY handle to be less than or equal to the TOP handle.
qeq := scp_pr &
  [ OUTSCPD handle ].        

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONJ type -
;
; CONJ values come in two types, cnil and strict-conj (i.e., non-cnil).  Cnil
; and the atomic substypes of strict-conj are the possible CONJ values of the
; left conjunct in a coordinate structure.  The right conjunct must always
; have a complex-conj CONJ value.  A complex CONJ value has three parts: the
; handles and indices of the sub-parts of the right conjunct, and the CHEAD
; info that gets passed from the right conjunct to the mother.  The CHEAD
; value has only one piece of information: the CONJ values of the
; left conjunct daughters.  For more info about how this works, see
; top_coord_rule in syntax.tdl.

conj :< *avm*.
cnil_or_numconj :< conj.
cnil :< cnil_or_numconj.
real-conj := conj &
  [ CHEAD chead ].
strict-conj :< real-conj.
atomic-conj :< strict-conj.
both :< atomic-conj.
either :< atomic-conj.
neither :< atomic-conj.
nor :< atomic-conj.
chead := *avm* &
  [ LEFT *list* ].
complex-conj :< strict-conj.
phr-conj :< real-conj.
num-conj := cnil_or_numconj & strict-conj.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Contextual information

ctxt_min :< *avm*.

ctxt := ctxt_min &
  [ ACTIVATED bool,
    PRESUP *diff-list* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Stem type

; The stemhead of a lexical entry is used by inflectional affixes to ensure the
; desired stem without overly restricting the value of HEAD itself, since
; this needs to remain non-specific to allow conjunction of non-similar heads. 
; Note that if we distinguished lexemes from words, the stemhead could be the
; value of HEAD for the lexeme, and the word's value for HEAD could be 
; supplied by the affix; then the same head type could be used for both.
; This feature is only given a more specific value for lexical entries which
; get inflected (verbs, nouns, and adjectives).

stemhead :< *sort*.
vstem :< stemhead.
nstem :< stemhead.
countnstem :< nstem.
massnstem :< nstem.
astem :< stemhead.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; KEY relations, for semantic selection
;  KEY mod_relation         ; Pointer to main relation in LISZT
;  ALTKEY mod_relation      ; Pointer to an alternate relation in LISZT
;  --COMPKEY mod_relation   ; Pointer to the complement's main relation
;  --OCOMPKEY mod_relation  ; Pointer to the oblique complement's main relation
;
;  MESSAGE 0-1-dlist,       ; Message type for propositions


keys_min :< *avm*.

keys_k := keys_min &
  [ KEY mod_relation ].

keys_km := keys_k &
  [ MESSAGE 0-1-dlist ].

keys := keys_km &
  [ ALTKEY mod_relation,
    --COMPKEY mod_relation,
    --OCOMPKEY mod_relation ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsem values

; The feature AGR is introduced on LOCAL rather than on CAT (or on HEAD) since
; coordination schema unify the CAT value of the daughters with that of then
; mother, but need to be able to change AGR on the mother (to get plural 
; agreement on verb when subject is a coordinated NP with "and" vs. "or").  

cat_min :< *avm*.

cat := cat_min &
  [ HEAD head_min,
    VAL valence_min,
    MC luk,
    POSTHEAD bool,
    HC-LEX bool ].

local_min := mod_local &
  [ CAT cat_min,
    CONT cont,
    AGR index ].

no-affix :< mod_local.

non-local_min :< *avm*.

synsem_min := *avm* &
  [ OPT bool,
    LOCAL mod_local,
    NON-LOCAL non-local_min ].

; DPF (09-Jan-99) - Added boolean LEX feature to be used for determining the
; head-complement type of the projections of lexical heads - most produce 
; phrases, but see discussion of HC-LEX feature below.

lex_or_phrase := synsem_min &
  [ LEX bool ].

synsem :< synsem_min.

expressed_synsem :< synsem.

canonical_synsem := expressed_synsem &
  [ MODIFIED xmod ].

lex_synsem := canonical_synsem & lex_or_phrase &
  [ LOCAL local_min,
    LEX + ].

phr_synsem := canonical_synsem & lex_or_phrase &
  [ LOCAL local_min,
    LEX - ].

non_canonical := synsem &
  [ LOCAL.CONT.INDEX non_expl ].

expressed_non_canonical := non_canonical & expressed_synsem.

gap := expressed_non_canonical &
  [ LOCAL #local,
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist,
		SLASH 1-dlist &
		    [ LIST < #local > ] ] ].

unexpressed := synsem_min &
  [ NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

unexpressed_reg := unexpressed & non_canonical.

; DPF 28-Aug-99 - Removed OPT + from anti_synsem since it blocked 
; "you can have anything you want"
anti_synsem :< unexpressed.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT type

;; The feature MC has three possible values: +, -, and na.  Non-clauses are
;; always MC na, since they can't really be said to be root or non-root.
;; All clauses are MC bool, and if they have a restricted distribution then
;; they are MC + or MC -.

;; DPF (22-Oct-98) Added feature HC-LEX ("is head-complement type lexical?")
;; on CAT, to identify the type of synsem that results from combining the word 
;; with its complements.  We recognize at least the head-complement 
;; structures  "thirty-two" and "two o'clock" as still being lexical signs, not
;; phrasal ones, since they can appear as prenominal adjectives and in noun-
;; noun compound constructions, respectively.  The head-complement rule 
;; determines its SYNSEM type by unifying its LEX value with the HC-LEX of
;; its head dtr - this works because the HCOMP rule requires its SYNSEM value to
;; be of type canonical_synsem, and the subtypes of canonical_synsem are the
;; only types that introduce the feature LEX, namely lex_synsem and phr_synsem.

local_basic := local_min &
  [ KEYS keys_min,
    CONJ conj ].

local := local_basic &
  [ CTXT ctxt_min,
    ARG-S *list*,
    STEMHEAD stemhead ].

non-local := non-local_min &
  [ SLASH 0-1-dlist,
    QUE 0-1-dlist,
    REL 0-1-dlist ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign_min := *avm* &
  [ STEM *list*,
    --FINAL-ARG *avm* ].

basic_sign := sign_min &
  [ KEY-ARG bool ].

sign := basic_sign &
  [ SYNSEM synsem,
    ARGS *list*,
    INFLECTED bool,
    ROOT bool ],
  status: root-node.

phrase_or_lexrule := sign &
  [ SYNSEM canonical_synsem &
	   [ LOCAL.CONT [ TOP #hand,
			  INDEX #index ] ],
    C-CONT mrs_min & [ TOP #hand,
		       INDEX #index ] ].

word_or_lexrule_min := sign_min &
  [ AFFIX mod_local ].

word_or_lexrule := word_or_lexrule_min & sign.

; We use --TOPKEY rather than KEY because of negated auxiliaries, which have the
; neg_rel's HANDEL as TOP, rather than the KEY's HANDEL (where the KEY must still
; be the same as for the positive auxiliary in order to get tag questions right).
;
; Not all words have lex_synsem - e.g. lexical PPs like "tomorrow" are phr_synsem
; since they can be post-nominal modifiers.

word := word_or_lexrule &
  [ SYNSEM.LOCAL.CONT [ TOP #hand,
			--TOPKEY.HANDEL #hand ],
    ROOT - ].

;; Not all phrases have SYNSEM phr_synsem, since we need to allow the head-comp
;; rules to build signs which are still [ SYNSEM lex_synsem ], for constructions
;; like "twenty-two" and "five fifteen p.m.".  So most phrases will assign the
;; type phr_synsem to the value of SYNSEM, but not all.

;; DPF 03-Mar-99 - This definition of phrase is replaced by the following by
;; request from WK.

#|
phrase := phrase_or_lexrule &
  [ SYNSEM.LOCAL.ARG-S < >,
    ROOT bool ].
|#

lexroot := phrase_or_lexrule &
  [ SYNSEM.LOCAL.ARG-S < >,
    ROOT bool ],
  status: lexroot.

phrase := lexroot &
  [ SYNSEM.LOCAL.CAT.HC-LEX - ],
  status: root-node.

basic_lex_entry := sign &
  [ STEM < #stem >,
    ARGS < [ STEM < #stem > ] >,
    INFLECTED bool ],
    status: lex-entry.

;; see lkbpatches
lex_entry := basic_lex_entry &
  [ SYNSEM.LOCAL [ CONT.TOP-H handle,
                   KEYS.KEY.LABEL *cons* ] ].

infl_lex_entry := basic_lex_entry &
  [ INFLECTED +,
    --FINAL-ARG #arg,
    ARGS < #arg & [ AFFIX no-affix ] > ].

basic_multi_lex_entry := word &
  [ INFLECTED bool ],
  status: c-lex-entry.

; for the LKB version, INFLECTED has to be - for most entries
; so lex_entry and standard_mle
; are redefined in the patches file

;; see lkbpatches
standard_mle := basic_multi_lex_entry &
  [ SYNSEM.LOCAL [ CONT.TOP-H handle,
                   KEYS.KEY.LABEL *cons* ] ].

multi_lex_entry := basic_multi_lex_entry &
  [ STEM < #stem1, #stem2 >,
    ARGS < [ STEM < #stem1 >,
	     AFFIX no-affix ],
	   [ STEM < #stem2 >,
	     AFFIX no-affix ] > ].

multi_lex_entry_affixed := standard_mle &
  [ STEM < #stem1, #stem2 >,
    ARGS < [ STEM < #stem1 >,
	     AFFIX no-affix ],
	   [ STEM < #stem2 >,
	     AFFIX local_min ] > ].

two_space_lex_entry_affixed := standard_mle &
  [ STEM < #stem1, #stem2, #stem3 >,
    ARGS < [ STEM < #stem1 >,
	     AFFIX no-affix ],
	   [ STEM < #stem2 >,
	     AFFIX no-affix ],
	   [ STEM < #stem3 >,
	     AFFIX local_min ] > ].

three_space_lex_entry_affixed := standard_mle &
  [ STEM < #stem1, #stem2, #stem3, #stem4 >,
    ARGS < [ STEM < #stem1 >,
	     AFFIX no-affix ],
	   [ STEM < #stem2 >,
	     AFFIX no-affix ],
	   [ STEM < #stem3 >,
	     AFFIX no-affix ],
	   [ STEM < #stem4 >,
	     AFFIX local_min ] > ].

key_first := basic_multi_lex_entry &
  [ ARGS < [ KEY-ARG + ], ... > ].

key_second := basic_multi_lex_entry &
  [ ARGS < *top*, [ KEY-ARG + ], ... > ].

key_third := basic_multi_lex_entry &
  [ ARGS < *top*, *top*, [ KEY-ARG + ], ... > ].

key_fourth := basic_multi_lex_entry &
  [ ARGS < *top*, *top*, *top*, [ KEY-ARG + ], ... > ].

basic_mle1 := multi_lex_entry & key_first.
basic_infl_mle1 := basic_mle1 & 
  [ INFLECTED +,
    --FINAL-ARG #arg,
    ARGS.FIRST #arg & [ AFFIX no-affix ] ].

multi_lex_entry1 := basic_mle1 & standard_mle.
multi_lex_entry2 := multi_lex_entry & key_second & standard_mle.

two_space_lex_entry := standard_mle &
  [ STEM < #stem1, #stem2, #stem3 >,
    ARGS < [ STEM < #stem1 > ],
	   [ STEM < #stem2 >, AFFIX no-affix ],
	   [ STEM < #stem3 >, AFFIX no-affix ] > ].


two_space_lex_entry1 := two_space_lex_entry & key_first.
two_space_lex_entry2 := two_space_lex_entry & key_second.
two_space_lex_entry3 := two_space_lex_entry & key_third.

three_space_lex_entry := standard_mle &
  [ STEM < #stem1, #stem2, #stem3, #stem4 >,
    ARGS < [ STEM < #stem1 > ], 
	   [ STEM < #stem2 >, AFFIX no-affix ], 
	   [ STEM < #stem3 >, AFFIX no-affix ],
	   [ STEM < #stem4 >, AFFIX no-affix ] > ].

three_space_lex_entry1 := three_space_lex_entry & key_first.
three_space_lex_entry2 := three_space_lex_entry & key_second.
three_space_lex_entry3 := three_space_lex_entry & key_third.
three_space_lex_entry4 := three_space_lex_entry & key_fourth.

;;; AAC moved reg_lex_entry from letypes.tdl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; DPF (14-Oct-98) --FINAL-ARG points to the final element in a word with 
;; spaces, since that element bears any inflection.
;; AAC added --FINAL-ARG for non-affixed guys too

basic_affix_bearing := word &
  [ SYNSEM #synsem &
           [ LOCAL [ STEMHEAD #stemhead,
                     AGR #agr,
                     CAT #cat,
                     CONT [ TOP #hand,
                            INDEX #index ],
                     KEYS.KEY #key,
                     CTXT #ctxt ] ],
    --FINAL-ARG [ SYNSEM #synsem,
 		  AFFIX local & [ STEMHEAD #stemhead,
				  AGR #agr,
				  CAT #cat,
				  CONT [ TOP #hand,
					 INDEX #index ],
				  KEYS.KEY #key,
				  CTXT #ctxt ] ] ].

affix_bearing := basic_affix_bearing &
  [ --FINAL-ARG #arg,
    ARGS < #arg > ].

affix_bearing_two := basic_affix_bearing &
  [ --FINAL-ARG #arg,
    ARGS < *top*, #arg > ].

affix_bearing_three := basic_affix_bearing &
  [ --FINAL-ARG #arg,
    ARGS < *top*, *top*, #arg > ].

affix_bearing_four := basic_affix_bearing &
  [ --FINAL-ARG #arg,
    ARGS < *top*, *top*, *top*, #arg > ].

non_affix_bearing := word_or_lexrule &
  [ SYNSEM.LOCAL.KEYS.KEY.LABEL *cons*,
    --FINAL-ARG #arg,
    ARGS < #arg & [ AFFIX no-affix ] , ... > ].

affixed_lex_entry := affix_bearing & lex_entry.
affixed_two_lex_entry := affix_bearing_two & multi_lex_entry_affixed.
affixed_three_lex_entry := affix_bearing_three & two_space_lex_entry_affixed.
affixed_four_lex_entry := affix_bearing_four & three_space_lex_entry_affixed.

reg_lex_entry := affixed_lex_entry &
  [ SYNSEM.LOCAL.CONT.LISZT <! *top* !> ].

reg_affixed_two_lex_entry := affixed_two_lex_entry &
  [ SYNSEM.LOCAL.CONT.LISZT <! *top* !> ].

rule := sign &
  [ RULE-NAME symbol ],
  status: rule.

; LABEL and META used for labeling nodes in parse trees

tree_node_label := *top* &
  [ NODE sign ].

;; see lkbpatches
label := *top* &
  [ LABEL-NAME string ], 
  status: label.

;; see lkbpatches
meta := *top* &
  [ META-PREFIX string,
    META-SUFFIX string ], 
  status: meta.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CAT values

case :< *sort*.
nom :< case.
acc :< case.

vform :< *sort*.
non_fin :< vform.
non_prp :< non_fin.
ger :< non_prp.
pas :< non_prp.
psp_or_psp_irreg :< non_fin.
psp :< psp_or_psp_irreg.
psp_irreg :< psp_or_psp_irreg.
bse_or_inf :< vform.
; fin_or_bse used to collapse morpholog. unmarked forms for bse and fin-non3sg.
fin_or_bse :< vform.
bse := bse_or_inf & fin_or_bse.
; Base morphology verbs can be either base or imperative, but not if negated.
; See discussion of type neg_word.
bse_only := bse & non_fin.
fin_or_imp :< vform.
imp_vform* := bse & fin_or_imp.
imp_vform := imp_vform* & strict_sort.
fin_or_inf :< vform.
fin* := fin_or_inf & fin_or_bse & fin_or_imp.
fin := fin* & strict_sort.
inf_or_prp :< non_fin.
inf := inf_or_prp & bse_or_inf & fin_or_inf.
prp :< inf_or_prp.

fin+imp := fin* & imp_vform*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

poss-able := head_min &
  [ POSS bool ].

disc_adverbee :< head.

strict_type :< head_min.

func := head & strict_type.

det := func & poss-able.

subst :< head.

n_or_p :< subst.
n_or_a :< subst.
a_or_p :< subst.
v_or_p :< subst.
n_or_v :< subst.

; Adverbs modify adverbees.
adverbee :< subst.

v_or_g_or_a :< subst.
v_or_g := v_or_g_or_a &
  [ VFORM vform ].

nominal_or_verbal :< subst.

nominal := nominal_or_verbal & poss-able &
  [ CASE case ].

verbal := v_or_g & nominal_or_verbal & adverbee & disc_adverbee &
  [ AUX bool ].

; mobile things can be extracted in the complement-extraction rule, from which
; we exclude nominative-case NPs by not making all nouns mobile.

mobile :< head.

adj* := a_or_p & v_or_g_or_a & n_or_a & adverbee & mobile.

; DPF 26-Jul-99 - Made prep* not inherit from adverbee, since in general
; don't want adverbs modifying PPs.

prep* := a_or_p & v_or_p & n_or_p & mobile.

; For result of temp_mod non-branching rule
modnp* := n_or_p & nominal.

supnoun :< nominal.

noun* := supnoun & n_or_v & n_or_p & n_or_a.

gerund* := supnoun & adverbee & v_or_g & n_or_v & disc_adverbee.

verb* := verbal & v_or_p & n_or_v &
  [ VOICE voice ].

comp* := nominal & verbal.

basic_adv :< func.

; 'not' and closed class of other adverbs that can be added to aux COMPS list
; via 'adv_addition' lexical rule.
basic_lexadv := basic_adv & disc_adverbee.
negadv :< basic_lexadv.
lexadv :< basic_lexadv.

adv := basic_adv & mobile & disc_adverbee.
deg_adv :< basic_adv.
root-marker := v_or_g & adverbee & strict_type.

detspec :< func.

; Hack used in blocking unwanted affixes
no_head := head & strict_type.

; Types for punctuation and string boundaries.
punct := head & strict_type.
left_edge :< punct.
right_edge :< punct.

; The idea is that any two heads (for now only major categories) can be
; unified in a conjunction, but the resulting type is a specific type that
; will not be subcategorized for, so the only way conjuncts of distinct
; types will satisfy a subcat is when the head does not mention the type.
; An example is the copula "be", as in "Kim is in Paris and happy."

v_and_n := verb* & noun*. 
v_and_a := verb* & adj*.
v_and_p := verb* & prep*.
v_and_g := verb* & gerund*.
n_and_a := noun* & adj*.
n_and_p := noun* & prep*.
;;n_and_g := noun* & gerund*.
a_and_p := adj* & prep*.
a_and_g := adj* & gerund*.
mod_and_p := modnp* & prep*.
mod_and_n := modnp* & noun*.
mod_and_a := modnp* & adj*.

; AAC - verb_or_comp introduced because the template vp has verbal &
; strict_type which must be specified as a single type in the LKB

verb_or_comp := strict_type & verbal.

; AAC - similarly for strict_nominal and strict_supnoun

strict_nominal := strict_type & nominal.

strict_supnoun := strict_nominal & supnoun.

mobile_nom := mobile & nominal.

; The following types are used to enable strict subcategorization (the usual 
; case)

verb := verb* & verb_or_comp.
noun := noun* & strict_supnoun.
noun_acc := noun & mobile_nom & [ CASE acc ].
noun_nom := noun & [ CASE nom ].
prep := prep* & strict_type.
adj := adj* & strict_type.
comp := comp* & verb_or_comp.
gerund := gerund* & strict_supnoun.
gerund_acc := gerund & mobile_nom & [ CASE acc ].
gerund_nom := gerund & [ CASE nom ].
modnp := modnp* & strict_type.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  CONT values (MRS semantics)
;;
;; The basic semantic objects are all sub-types of thing.  Right now, the only
;; type of thing that has an internal structure is index, but that will
;; probably change.  For example, an event might have various times associated
;; with them or a handle may include a list of "subhandles" which are in its
;; scope.  Indices are classified in the familiar HPSG way.

expl-ind :< index.
it-ind := expl-ind & full_index &
  [ PNG [ PN 3sg*,
	  GEN neut* ] ].
there-ind :< expl-ind.
non_expl-ind := index & event_or_index.
ref-ind :< non_expl-ind.
deg-ind :< non_expl-ind.
full_non_expl := non_expl & full_index.
full_there-ind := there-ind & full_index.
full_ref-ind := ref-ind & full_non_expl.
full_deg-ind := deg-ind & full_index.

conj-ind :< event_or_index.
conj_event := conj-ind & event.
conj_ref-ind := conj-ind & ref-ind.
conj_full_ref-ind := conj_ref-ind & full_ref-ind.
conj_deg-ind := conj-ind & deg-ind.
conj_full_deg-ind := conj_deg-ind & full_deg-ind.
conj_non_expl-ind := conj-ind & non_expl-ind.
conj_full_non_expl := conj_non_expl-ind & full_non_expl.

; The basic semantic structure, a CONT, is just something with a handle.
; Conts are further classified into mrss (i.e., things with liszts) and
; relations (i.e., things that go on liszts).  Conts are divided into psoas
; (with a distinguished event) and nom-objs (with a distinguished index).
; We use a polymorphic attribute name INDEX for both of these, to simplify
; manipulation of these objects; for example, modifying PPs assign as their
; ARG's value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  Similarly useful
; for coordination.

; ERB (03-10-96) 
; The intermediate types ques_prop_msg and prop_com_msg represent the
; natural classes needed for selection by know, announce, care, check,
; etc. and the analysis of THAT (see lextypes.tdl) and the 
; forthcoming analysis of tags on imperatives, respectively.

psoa := mrs_min &
  [ INDEX event ].

psoa_basicmrs := psoa & mrs_min0.

psoa_mrs := psoa_basicmrs & mrs.

nom-obj := mrs_min &
  [ INDEX index ].

nom-obj_basicmrs := nom-obj & mrs_min0.

nom-obj_mrs := nom-obj_basicmrs & mrs.

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; Since some temporal nouns can be either arguments or VP modifiers, their 
; rel's INST value (coindexed with INDEX of the containing MRS) must remain 
; unspecified for type.  Consider "Kim arrived Tuesday" vs. "Tuesday comes
; after Monday"; in the first, Tuesday must have an EVENT index, while in the
; second, it must have a REF-IND index.

; ERB (24-10-96) Here is the series of relations that will be used for
; questions, etc.  Cf. Gizburg & Sag.
; ERB (12-05-96) Moved the ne_rel here.

message := norm_relation &
  [ SOA handle ].
imp_rel :< message.
prop_ques_rel :< message.          ;for COMPS of e.g. 'know'
propositional_rel :< prop_ques_rel.
prpstn_or_like_rel :< message.
prpstn_rel := propositional_rel & prpstn_or_like_rel.   ;propositions
hypo_rel :< propositional_rel.     ;hypotheticals (PRO to go)

; For interrogatives; PARAMS value is a set of handles.
abstr_int_rel := prop_ques_rel &
  [ PARAMS *diff-list* ].       

int_rel :< abstr_int_rel.

; Subtype of int_rel for tag questions.   
ne_rel :< abstr_int_rel.                 

; Subtype to distinguish complementizer "like" from "that", to block
; '*Kim said like Sandy left' and '*it looks that Sandy left"
_like_mood_rel :< prpstn_or_like_rel.

dim_rel := relation &
  [ DIM non_expl-ind ].

quant_or_wh_rel := dim_rel & norm_relation &
  [ BV ref-ind,
    RESTR handle ].

quant_rel := quant_or_wh_rel &
  [ SCOPE handle ].

udef_rel :< quant_rel.
some_rel :< quant_rel.
def_rel :< quant_rel.
; Used for lexical NPs including proper names
def_np_rel :< def_rel.
demonstrative_rel :< quant_rel.
demon_near_rel :< demonstrative_rel.
demon_far_rel :< demonstrative_rel.
free_relative_ever_rel :< quant_rel.

;which_rel should not have a scope, but given for the moment to satisfy VIT
;which_rel :< quant_or_wh_rel.
which_rel :< quant_rel.

_all_rel :< quant_rel.

; Nominal sorts used for VM2

nominal-sort :< *sort*.
entity :< nominal-sort.
human :< nominal-sort.
info_bearer :< nominal-sort.
space_time :< nominal-sort.
time :< nominal-sort.
location :< nominal-sort.
geo_location :< location.
nongeo_location :< location.
meeting_sit :< nominal-sort.
inst_loc_coll_poly :< nominal-sort.

; nondim_rel is used to determine whether the specifier that combines with its
; head provides the semantics (nonhead-compositional) or whether the head does:
; nondim_rel entries are head-compositional.

nondim_rel :< norm_relation.

; modable_rel distinguishes those relations whose nominal lexical entries can 
; undergo a syntactic rule to produce a modifier phrase, as in "we'll meet
; next week" or "I'll do it my way".

modable_rel :< norm_relation.

event_rel := norm_relation &
  [ EVENT event ].
; Nominal relations

basic_nom_rel := norm_relation & independent_rel &
  [ INST individual ].

nom_rel := basic_nom_rel &
  [ INST non_expl-ind ].

nonpro_rel :< nom_rel.
nom_nondim_rel := nom_rel & nondim_rel.
non_temp_nom_rel :< nom_nondim_rel.
reg_nom_rel := non_temp_nom_rel & nonpro_rel.
modable_nom_rel := non_temp_nom_rel & modable_rel & nonpro_rel.

arg3_rel := relation &
  [ ARG3 thing ].

diadic_nom_rel := basic_nom_rel & arg3_rel.

reg_diadic_nom_rel := diadic_nom_rel & reg_nom_rel.

hcomp_nom_rel := nom_rel & arg3_rel &
  [ ARG3 handle ].

nominalize_rel :< diadic_nom_rel.

gerund_rel := reg_nom_rel &
  [ INST ref-ind ].

apposition_rel :< nonpro_rel.

temp_abstr_rel := nonpro_rel &
  [ INST.SORT time ].

temp_nondim_rel := temp_abstr_rel & nondim_rel.

; Used in munging rules to make reversible the implicit quantifier
abstr_named_rel :< relation.

; Relation used in decomposed lexical semantics, e.g. for 'when'
temp_rel := temp_abstr_rel & abstr_named_rel & modable_rel.

; The class of temporal predicates whose lexical entries can be made into 
; modifiers
temp_modable_rel := temp_nondim_rel & modable_rel.

day_rel :< temp_modable_rel.

named_day_rel := day_rel & abstr_named_rel &
  [ DAY atom ].

non_day_rel :< temp_nondim_rel.

;; day_of_month_rel
dofm_rel := named_day_rel & diadic_nom_rel &
  [ DAY string,
    ARG3 non_expl-ind ].

;; day_of_week_rel
dofw_rel := named_day_rel &
  [ DAY symbol ].

holiday_rel := named_day_rel &
  [ DAY symbol ].

day_part_rel := day_rel &
  [ OF-DAY non_expl-ind ].

; dim_rel: 'almost three o'clock'
hour_rel := temp_abstr_rel & dim_rel.

; a quarter till three  ("till" is head - cf "come at a quarter till.")
hour_prep_rel := hour_rel &
  [ HOUR-IND individual,
    MINUTE-IND individual ].

numbered_hour_rel := hour_rel & abstr_named_rel &
  [ INST.PNG png & [ PN 3sg*,
		     GEN neut* ],
    HOUR string,
    MIN non_expl-ind,
    AM-PM non_expl-ind ].

; DPF 31-Jul-99 - Changed minute_or_ampm_rel to be non-temp, since it cannot
; appear after temporal prepositions (ignoring the elliptical "I'll see you 
; in ten"), and we also need to block "from ten to eleven o'clock" with
; "ten" as minute.
minute_or_ampm_rel :< nom_nondim_rel.

#|
minute_rel := minute_or_ampm_rel &
  [ MINUTE string ].
|#

modable_hour_rel := hour_rel & modable_rel.

; 'Kim sleeps three times each day'
_time_rel :< modable_hour_rel.
; 'How many hours did Kim work?'
_hour_rel :< modable_hour_rel.

am_pm_rel :< minute_or_ampm_rel.
am_rel :< am_pm_rel.
pm_rel :< am_pm_rel.

ctime_rel :< numbered_hour_rel.

; 'the morning', not 'some morning': 'in the morning' but 'on some morning'
def_day_part_rel :< non_day_rel.

non_day_diadic_rel := non_day_rel & diadic_nom_rel.
non_day_modable_rel := non_day_rel & modable_rel.
non_day_diadic_modable_rel := non_day_diadic_rel & modable_rel.

;; named_month_rel as in "January is fine"

abstr_mofy_rel := non_day_diadic_rel & abstr_named_rel &
  [ MONTH symbol,
    YEAR-IND non_expl-ind ].

mofy_rel :< abstr_mofy_rel.
;; (cf. "let's get together every October / next October / some October")
mofy_mod_rel := abstr_mofy_rel & modable_rel.

yofc_rel := non_day_rel &
  [ YEAR string ].

abstr_season_rel := non_day_rel &
  [ SEASON symbol ].

; "Summer is a bad time to travel"
season_gen_rel :< abstr_season_rel.
; "This summer will be better."
season_rel := abstr_season_rel & modable_rel & abstr_named_rel.

age_rel :< non_day_rel.

_morning_rel :< day_part_rel.
_afternoon_rel :< day_part_rel.
_evening_rel :< day_part_rel.
_night_rel :< day_part_rel.
_weekday_rel :< day_rel.
_weekend_rel :< day_rel.
_workday_rel :< day_rel.

_week_rel :< non_day_diadic_modable_rel.
_fortnight_rel :< non_day_modable_rel.
_month_rel :< non_day_diadic_modable_rel.
_moment_rel :< non_day_rel.

named_rel := reg_nom_rel & apposition_rel & abstr_named_rel &
  [ NAMED atom ].

*letter-diff-list* :< *diff-list*.
spell_rel := reg_nom_rel &
  [ LETTERS *letter-diff-list* ].

unk_rel :< named_rel.

;; The relation event_or_arg_rel is designed to distinguish non-nominal signs, 
;; including verbs, adjectives, prepositions, and adverbs.  One use of this 
;; distinction is for the conjuncts accepted by "but": "*Kim but Sandy left."

event_or_arg_rel :< relation.

arg_rel := event_or_arg_rel &
  [ ARG thing ].

abstr_excl_rel := nondim_rel & arg_rel & independent_rel &
  [ EXCL symbol ].

greet_rel :< abstr_excl_rel.

excl_rel :< abstr_excl_rel.

; Pronouns
pron_rel := non_temp_nom_rel & abstr_named_rel &
  [ INST ref-ind ].

; For deictic pronouns
generic_nom_rel := non_temp_nom_rel &
  [ INST ref-ind ].

basic_adj_rel :< dim_rel.

abstr_adj_rel := basic_adj_rel & arg_rel & event_rel &
  [ ARG non_expl ].

adj_rel := abstr_adj_rel & independent_rel.

arg2_rel := relation &
  [ ARG2 thing ].

arg4_rel := relation &
  [ ARG4 thing ].

basic_adj_arg4_rel := basic_adj_rel & arg4_rel.
adj_arg4_rel := basic_adj_arg4_rel & adj_rel.
adj_arg2_rel := adj_rel & arg2_rel.
it_adj_arg24_rel := basic_adj_arg4_rel & adj_arg2_rel.
adj_arg24_rel := adj_arg4_rel & adj_arg2_rel.
adj_arg3_rel := adj_rel & arg3_rel.

meas_adj_rel := adj_arg3_rel &
  [ ARG3 ref-ind ].

adj_personal_rel :< adj_rel.
adj_abstract_rel :< adj_rel.

verb_aspect_rel := event_rel & independent_rel.

prog_rel :< verb_aspect_rel.

v_event_rel := verb_aspect_rel & nondim_rel & event_or_arg_rel.

mod_role_rel :< v_event_rel.

no_role_rel :< mod_role_rel. 
; E.g., weather verbs

role_rel :< mod_role_rel.

arg1_rel := role_rel &
  [ ARG1 thing ].

arg12_rel := arg1_rel & arg2_rel.
arg13_rel := arg1_rel & arg3_rel.
arg14_rel := arg1_rel & arg4_rel &
  [ ARG1 non_expl-ind,
    ARG4 thing ].
arg24_rel := arg2_rel & arg4_rel.
arg123_rel := arg12_rel & arg13_rel.
arg124_rel := arg12_rel & arg14_rel.
arg134_rel := arg13_rel & arg14_rel.
arg1234_rel := arg123_rel & arg14_rel.
arg3_event_rel := arg3_rel & role_rel.
arg4_event_rel := arg4_rel & v_event_rel.
arg24_event_rel := arg2_rel & arg4_event_rel.


ellipsis_rel := role_rel &
  [ ROLE thing ].

event_arg_rel := v_event_rel & arg_rel.

irrealis_rel :< event_arg_rel.

; Used to ensure tag question agreement, but will not appear in LISZT.
have_aux_rel :< v_event_rel.

; Needed to allow filtering of the relations for "will" and "would" for VIT.
will_would_rel :< arg4_event_rel.

abstr_rel :< arg3_event_rel.

; AAC - added for frag-msg
abstr_3_rel := basic_nom_rel & arg3_rel.

; AAC - added for wh_adjective_word
abstr_nom_rel := event_arg_rel & basic_nom_rel.

; Needed for generation from German VITs
abstr_suit_rel :< arg13_rel.

prop_rel := event_rel &
	   [ PROP non_expl ].

poss_rel := nondim_rel &
  [ POSSR non_expl-ind,
    POSSD non_expl-ind ].

_got_poss_rel :< poss_rel.

; For copula "be", only for external interface (not used in grammar)
support_rel :< no_role_rel.

; Preposition relations

prep_rel := dim_rel & arg3_rel & event_rel &
  [ ARG3 non_expl ].	    

prep_mod_rel := prep_rel & arg_rel.

loc_abstr_rel :< prep_mod_rel.
dir_rel :< loc_abstr_rel.
state_loc_rel :< loc_abstr_rel.
dir_or_state_rel := dir_rel & state_loc_rel.

temp_loc_abstr_rel :< loc_abstr_rel.

miscprep_rel :< prep_mod_rel.

dir_indep_rel := dir_rel & independent_rel.
loc_rel := loc_abstr_rel & independent_rel.
miscprep_ind_rel := miscprep_rel & independent_rel.
prep_mod_ind_rel := prep_mod_rel & independent_rel.
dir_or_state_ind_rel := dir_or_state_rel & independent_rel.
temp_loc_indep_rel := temp_loc_abstr_rel & independent_rel.
temp_loc_rel :< temp_loc_indep_rel.

part_of_rel :< reg_diadic_nom_rel.
diadic_noprep_nom_rel :< reg_diadic_nom_rel.
diadic_noarg_nom_rel :< reg_diadic_nom_rel.

abstr_adv_rel := arg_rel & dim_rel & norm_relation.

adv_rel := abstr_adv_rel & independent_rel.

neg_rel := arg_rel & independent_rel.

neg_polar_rel :< adv_rel.

_from_to_rel := miscprep_ind_rel &
  [ ARGX non_expl ].

; Degree relations

degree_rel := number_or_degree_rel & dim_rel &
  [ DARG thing ].

comp_degree_rel :< degree_rel.
non_comp_degree_rel :< degree_rel.

; For specifiers of adjectives
deg_rel :< non_comp_degree_rel.

; For specifiers of positive adjectives
very_deg_rel :< deg_rel.

; For "how" degree specifier
abstr_deg_rel :< very_deg_rel.

; For specifiers of comparative adjectives
much_deg_rel :< deg_rel.

; For e.g. 'eightish'
approx_grad_rel :< deg_rel.

comparative_rel := comp_degree_rel &
  [ ARG-1 index,
    C-INST index ].

comp_more_less_rel := comparative_rel &
  [ ARG-2 index ].
more_sc_adv_rel :< comp_more_less_rel.
comp_less_rel :< comp_more_less_rel.

comp_most_least_rel := comparative_rel &
  [ C-SET handle ].

comp_most_rel :< comp_most_least_rel.
comp_least_rel :< comp_most_least_rel.

;; For "how" adjective, which quantifies over properties.

property_rel :< reg_nom_rel.

prpstn_to_prop_rel := prop_rel &
  [ PRPSTN handle,
    PROP non_expl-ind ].

_by_pass_rel_a :< miscprep_rel.
_by_pass_rel := _by_pass_rel_a & selected_rel.
_from_time_on :< miscprep_ind_rel.
_compar_than_rel :< miscprep_ind_rel.
comp_rel := miscprep_ind_rel &
  [ ARG3 event_or_index ].
_more_adj_rel :< adj_rel.
superl_rel := miscprep_ind_rel &
  [ ARG3 event_or_index ].

; Abstract relations, specialized below either to independent relations or to
; ones that appear in verb-particle constructions.
to_dir_rel :< dir_rel.
_to_rel_a :< to_dir_rel.
_for_rel_a :< miscprep_rel.
_by_rel_a :< miscprep_rel.
_of_rel_a :< prep_mod_rel.
_in_rel_a :< dir_or_state_rel.

subord_rel := nondim_rel & independent_rel &
  [ MAIN handle,
    SUBORD handle ].

cop_id_rel :< arg13_rel.
_cop_id_rel :< cop_id_rel.
temp_span_rel :< meas_adj_rel.
_equal_adj_rel :< adj_arg3_rel.
unspec_adj_rel :< adj_rel.
number_rel :< reg_nom_rel.
quantity_rel :< reg_nom_rel.
_be_prd_rel :< event_arg_rel.


; Used for underspecifying word sense.

appointment_rel :< reg_nom_rel.


;; Relations needed for VIT conversion

abstr_apply := prop_rel & arg_rel.

_get_somewhere_rel :< arg1_rel.
_get_together_rel :< arg1_rel.
_get_in_rel :< arg1_rel.
_get_lost_rel :< arg1_rel.
_enough_isect_rel :< adv_rel.

; Discourse functions

; ERB (03-10-96) In order to capture the similarities and differences
; between embedded and matrix questions, I am decomposing the ynq_rel
; into polar_q_rel and request_ans_rel.  The latter is probably 
; equivalent to the ne_rel (see below), but ne_rel is too cute to
; forgo for the tag questions and probably too opaque for the 
; matrix yn questions, so I will keep the two for now.  NB polar_q_rel
; probably doesn't qualify as 'discourse function'.  

; So, the ynq_root construction will contribute a polar_q_rel and
; a request_ans_rel, whether will contribute a polar_q_rel, and
; matrix wh questions will contribute a request_ans_rel.

polar_q_rel :< arg_rel.
request_ans_rel :< arg_rel.

polite_rel :< arg_rel.

; Phrasally introduced relations

unspec_rel := nondim_rel &
  [ HINST index,
    NHINST index ].

; Used for vocatives.
unspec_mod_rel :< prep_mod_ind_rel.

; Relation introduced for tag questions

probable_rel :< adj_rel.

; DPF 11-Jul-99 - Added C-INIT-H and C-INIT-I so the initial handle and index will be
; visible in the semantics even for a partial coordination phrase like "and Kim left"
conj_rel := nondim_rel &
  [ C-ARG conj-ind,
    L-HANDEL mod-thing,
    R-HANDEL mod-thing,
    L-INDEX non_expl,
    R-INDEX non_expl ].

; For fragments

discourse_rel :< conj_rel. 

; Abstract relations specified by more than one lexical entry

airplane_rel :< reg_nom_rel.
abstr_place_rel :< reg_diadic_nom_rel.
place_rel := abstr_place_rel & abstr_named_rel & modable_rel.
time_rel :< modable_nom_rel.
telephone_rel :< reg_nom_rel.
person_rel :< reg_nom_rel.
thing_rel :< reg_nom_rel.
next_prev_rel :< adj_rel.
manner_rel :< reg_nom_rel.
reason_rel := reg_nom_rel & abstr_named_rel.
abstr_sure_rel := adj_arg4_rel.

title_rel := basic_nom_rel &
  [ TITLE atom ].

_there_cop_rel := v_event_rel & arg3_rel &
  [ ARG3 non_expl-ind ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Number relations

abstr_number_rel := dim_rel & arg_rel & number_or_degree_rel & independent_rel &
  [ ARG individual ].

integer_rel := abstr_number_rel &
  [ ORD bool ].
const_rel := integer_rel & [ CONST_VALUE string].

plus_rel := integer_rel & [ TERM1 handle,
			    TERM2 handle].
times_rel := integer_rel & [ FACTOR1 handle,
			     FACTOR2 handle].

ord_rel := abstr_adj_rel & const_rel.

minute_rel :< const_rel.

;; TYPES/SORTS
;; The ORDINAL feature determines whether its bearer is ordinal or not 
;; (i.e., is ordinal or cardinal).  Thus it is only appropriate for
;; numbers.  All numbers have a HEAD value of sort intsort, those
;; used adjectivally have heads of sort intadj (or one of its 
;; subsorts) or intdet (which has no subsorts).  Nominal uses are
;; not yet supported.
;;
;; Subcategorization, which is in terms of the maximum number of digits
;; allowed for the complement or specifier, is handled by the subsorts
;; of the digitn hierarchy.  Currently, only adjectives participate in
;; this hierarchy; there is only a single integer determiner ("one").
;; Nominal uses could be added by adding a type
;;          intnoun := intsort & digitn & noun.


intsort := head & [ORDINAL bool].

digitn :< head.

digit9 :< digitn.
digit6 :< digit9.
digit3 :< digit6.
digit2 :< digit3.
digit1 :< digit2.

; The sorts    digitk    specify the number of digits of a lexeme 
; together with its largest complement and specifier.
; The sorts    digitk-    are used for subcategorization; they include
; values of k or fewer digits.
 
digit9- :< digitn.
digit6- :< digit9-.
digit3- :< digit6-.
digit2- :< digit3-.
digit1- :< digit2-.

;digit1 :< digit1-.
;digit2 :< digit2-.
;digit3 :< digit3-.
;digit6 :< digit6-.
;digit9 :< digit9-.

;; DPF 26-Apr-00 - Removed adj parent from intadj.

intadj  := intsort & strict_type.
intadjn := intadj & digitn.
intdet  := intsort & det.

; intadj1- := intadj1.
; intadjk- means an integer adjective of at most k digits (when
;   combined with specifier and complement

intadj9- :< intadj.
intadj9  := intadj9- & digit9.
intadj6- :< intadj9-.
intadj6  := intadj6- & digit6.
intadj3- :< intadj6-.
intadj3  := intadj3- & digit3.
intadj2- :< intadj3-.
intadj2  := intadj2- & digit2.
intadj1  := intadj2- & digit1.

;;;;;;;;Extra stuff

; ERB (13-12-97) This type is meant as a PRO -- i.e., what can show
; up in such things as the 'way' construction and embedded infinitival
; wh questions.  It should eventually receive some binding properties,
; but I don't know what to put there yet, and since we don't have
; a binding theory...

; ERB (14-12-97) I am adding the pron_rel to pro_ss, so that in the
; types like common_noun_vpcomp_synsem I don't have to put it in.  I
; can just take the KEY.

; ERB (14-12-97) No pron_rel for pro_ss.

; ERB (14-12-97) ... and pro_ss is accusative, to block (once I get
; infinitival relatives working) *A person left came in.

; ERB (14-12-97) This is moved here so as to be after acc, which is a 
; *sort* and thus can't handle being referenced before it is defined.

; ERB (19-01-98) PRO is obligatorially OPT -.  This keeps to_c_prop
; from serving as a modifier without first building a non_wh_rel,
; because hadj requires SUBJ *olist*.

; ERB (21-01-98) In order for PRO to be extractable, it can't be
; SLASH 0-dlist, and thus can't be a subtype of unexpressed.  With
; PRO underspecified for SLASH, something will always have to fill
; in that value.  In the case of subject non_wh_rels (e.g., 
; "Kim found a person to fix the sink") it is extracted, i.e., resolved
; to gappro by extrasubj.  In the cases where the PRO is the subject of
; a selected complement, the selector will impose SLASH 0-dlist on the
; PRO (this case includes equi constructions, embedded infinitival
; wh questions, and the complement of 'way' as in "Kim found a way
; to leave early").  In the case of the (as yet unimplemented) CP[to]
; subjects, the NP -> CP rule will probably do the work.  Alternatively,
; the selecting category could do it.  Finally, in the case of
; non-subject non_wh_rels (e.g., "Kim found a cheeseburger to devour"),
; the PRO must be SLASH 0-dlist because the non_wh_rel_rule limits
; the SLASH list to length one.
;
; On a related note, we want the distribution of gappro (i.e., of
; extracted PRO) to be quite constrained, and perhaps even limited
; to the subject non_wh_rels.  In general, we are relying on the
; restriction of SLASH to lists of length one stated in several places
; in the grammar, in addition to certain selecting categories' specifying
; an empty value for SLASH on the PROs in their complements' subjects
; to keep us from getting in trouble on this one.
;
; Finally, rather than make a subtype of pro_ss that says SLASH 0-dlist,
; I have opted to include that information on the type *prolist*.

; ERB (03-23-98) We need a way to identify indices introduced by a PRO
; that are "discourse bound".  We were using PRONTYPE for this, but
; of course that doesn't work when the controller of the PRO is an overt
; pronoun.  So the new strategy is to make the INDEX a non_expl.
; This will unify with the indices introduced by (appropriate) controllers,
; and (hopefully) be identifiable if it is not controlled.

; DPF 27-May-99 - Removed OPT - constraint from pro_ss (see ERB (19-01-98) 
; above) since head_mod type now constrained via PRD rather than by requiring 
; SUBJ to be empty (cf note DPF 27-May-99 with n_adj_int_phrase in syntax.tdl).
; This change means the types for saturated subcats can again simply require 
; SUBJ to be *olist* rather than *null*, which e.g. allows verbal gerunds to 
; have optional but non-empty SUBJ value and still themselves appear as 
; subjects or complements without discharging that SUBJ value.

pro_ss := expressed_non_canonical &
  [ LOCAL.CAT.HEAD.CASE acc,
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist ] ].

; ERB (19-01-98) We need a subtype of pro and gap so that to_c_prop
; can undergo subject extraction.  See the notes near non_wh_rel in
; syntax.tdl for the details of the analysis.
; I am positive that this will break something, but I could not
; guess what.

gappro := pro_ss & gap.

#|
; Replace these defs with the ones below, to eliminate disjunction.
*onull* :< *null*.
*ocons* := *cons* &
  [ FIRST.OPT +, 
    REST *onull* ].
*olist* := *ocons* \| *onull*.

; The following should replace the above, but TDL unfortunately introduces
; a generated type "A&B" when a type C inherits from both A and B, and C
; introduces additional constraints.  Hence when A is unified with B during
; processing, the result is the type "A&B", not C.  So instead do the 
; hack below.

*olist* :< *list*.
*ocons* := *olist* & *cons* &
  [ FIRST.OPT +, 
    REST *olist* ].
*onull* := *olist* & *null*.

*olist* := *list* &
  [ FIRST unexpressed & [ OPT + ],
    REST  *list* & [ FIRST unexpressed & [ OPT + ],
		     REST.FIRST unexpressed & [ OPT + ] ] ].
|#

  ;; The REST of *olist* should of course be *olist*, but TDL won't allow
  ;; recursive type definition, so add hack of making REST.FIRST.OPT +,
  ;; taking advantage of the fact that no lexical entry introduces two
  ;; optional complements followed by obligatory ones.

*olist* := *list* &
  [ FIRST unexpressed & [ OPT + ],
    REST  *list* & [ FIRST unexpressed & [ OPT + ] ] ].

*ocons* := *olist* & *cons*.

  ;; *ocons* must crucially not introduce any constraints of its own, since
  ;; if it did, TDL would then introduce a generated type T which would
  ;; have *olist* and *cons* as supertypes, and then *ocons* would inherit
  ;; from T.  But then if the [OPT +] constraint were on *ocons*, it would
  ;; not be visible during processing, when *olist* and *cons* unified.
  ;; (see definition of function Infer-Is-GLB in 
  ;; "page/src/tdl/control/define-feature-type.lisp")

*onull* := *olist* & *null*.

#| 
;;; LKB complains because of multiple introduction of FIRST and REST -
;;; so the definition above is overwritten by the following in the lkbpatches.tdl
;;; file in the directory <grammardir>/lkb/. 

*olist* :< *list*.
*ocons* := *olist* & *cons* &
  [ FIRST.OPT +,
    REST  *olist* ].
*onull* := *olist* & *null*.
|#

;; This is just like *olist*, but in this case we know the list will never
;; have more than one element.

;; see lkbpatches
*gaplist* := *list* &
  [ FIRST gap,
    REST  *null* ].

*gapcons* := *gaplist* & *cons*.

*gapnull* := *gaplist* & *onull*.

; ERB (14-12-97) Here's another one where we know there's only ever
; one.

; ERB (21-01-98) Some trickiness about the SLASH value.  See notes
; near pro_ss.

;; see lkbpatches
*prolist* := *list* &
  [ FIRST pro_ss &
	  [ NON-LOCAL.SLASH 0-dlist ],
    REST *null* ].

*procons* := *prolist* & *cons*.

*pronull* := *prolist* & *null*.

;; *unexplist* is used for common nouns whose specifier is possibly obligatory,
;; but unexpressed, as in noun-noun compounds.  As usual, we use the same hack
;; as for *olist*, to get around the lack of recursive types in TDL.

;; see lkbpatches
*unexplist* := *list* &
  [ FIRST unexpressed_reg,
    REST  *null* ].

*unexpcons* := *unexplist* & *cons*.

*unexpnull* := *unexplist* & *olist* & *null*.


;; *substlist* is used in the adv_addition lexical rule, to prevent spurious
;; re-application of the rule to its own output by requiring the input to
;; be a (possibly empty) list of substantive synsems.

;; see lkbpatches
*substlist* := *list* &
  [ FIRST.LOCAL.CAT.HEAD subst,
    REST  *list* & [ FIRST.LOCAL.CAT.HEAD subst ] ].

*substcons* := *substlist* & *cons*.

; For there-copula
*substocons* := *substcons* & *ocons*.

*substnull* := *substlist* & *olist* & *null*.

;; *handlelist* is used in the treatment of free relatives, to disntinguish
;; the usual value of QUE from its use in free relatives, where QUE is instead
;; a list of referential indices.

*handlelist* := *list* &
  [ FIRST handle,
    REST  *null* ].

*handlecons* := *handlelist* & 1-list.

*handlenull* := *handlelist* & *olist* & *null*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Selected-for relations in verb-particle constructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_to_rel_s := _to_rel_a & selected_rel.
_to_rel := _to_rel_a & independent_rel.
_for_rel_s := _for_rel_a & selected_rel.
_for_rel := _for_rel_a & independent_rel.
_by_rel_s := _by_rel_a & selected_rel.
_by_rel := _by_rel_a & independent_rel.
_of_rel_s := _of_rel_a & selected_rel.
_of_rel := _of_rel_a & independent_rel.
_in_rel_s := _in_rel_a & selected_rel.
_in_rel := _in_rel_a & independent_rel.

_out_rel_a :< dir_rel.
_out_rel_s := _out_rel_a & selected_rel.
_out_rel := _out_rel_a & independent_rel.
_from_rel_a :< dir_rel.
_from_rel_s := _from_rel_a & selected_rel.
_from_rel := _from_rel_a & independent_rel.
_on_rel_a :< dir_or_state_rel.
_on_rel_s := _on_rel_a & selected_rel.
_on_rel := _on_rel_a & independent_rel.
_with_rel_a :< miscprep_rel.
_with_rel_s := _with_rel_a & selected_rel.
_with_rel := _with_rel_a & independent_rel.
_at_rel_a :< state_loc_rel.
_at_rel_s := _at_rel_a & selected_rel.
_at_rel := _at_rel_a & independent_rel.
_between_rel_a :< temp_loc_abstr_rel.
_between_rel_s := _between_rel_a & selected_rel.
_between_rel := _between_rel_a & independent_rel.
_about_rel_a :< miscprep_rel.
_about_rel_s := _about_rel_a & selected_rel.
_about_rel := _about_rel_a & independent_rel.
_over_rel_a :< dir_or_state_rel.
_over_rel_s := _over_rel_a & selected_rel.
_over_rel := _over_rel_a & independent_rel.
_against_rel_a :< miscprep_rel.
_against_rel_s := _against_rel_a & selected_rel.
_against_rel := _against_rel_a & independent_rel.
_up_rel := dir_rel & selected_rel.
_forth_rel_a :< abstr_adv_rel.
_forth_rel_s := _forth_rel_a & selected_rel.
_forth_rel := _forth_rel_a & independent_rel.
_forward_rel_a :< abstr_adv_rel.
_forward_rel_s := _forward_rel_a & selected_rel.
_forward_rel := _forward_rel_a & independent_rel.
_off_rel_a :< dir_or_state_rel.
_off_rel_s := _off_rel_a & selected_rel.
_off_rel := _off_rel_a & independent_rel.
_back_adv_rel_a :< abstr_adv_rel.
_back_adv_rel_s := _back_adv_rel_a & selected_rel.
_back_adv_rel := _back_adv_rel_a & independent_rel.
_down_rel_a :< dir_rel.
_down_rel_s := _down_rel_a & selected_rel.
_down_rel := _down_rel_a & independent_rel.
_across_rel_a :< dir_or_state_rel.
_across_rel_s := _across_rel_a & selected_rel.
_across_rel := _across_rel_a & independent_rel.
_around_loc_rel_a :< abstr_adv_rel.
_around_loc_rel_s := _around_loc_rel_a & selected_rel.
_around_loc_rel := _around_loc_rel_a & independent_rel.
_together_rel_a :< abstr_adv_rel.
_together_rel_s := _together_rel_a & selected_rel.
_together_rel := _together_rel_a & independent_rel.
_as_rel := miscprep_rel & independent_rel.
_short_rel_a :< abstr_adj_rel.
_short_rel_s := _short_rel_a & selected_rel.
_short_rel := _short_rel_a & independent_rel.
_without_rel_a :< miscprep_rel.
_without_rel_s := _without_rel_a & selected_rel.
_without_rel := _without_rel_a & independent_rel.
_aside_rel_a :< abstr_adv_rel.
_aside_rel_s := _aside_rel_a & selected_rel.
_aside_rel := _aside_rel_a & independent_rel.
_away_adv_rel_a :< abstr_adv_rel.
_away_adv_rel_s := _away_adv_rel_a & selected_rel.
_away_adv_rel := _away_adv_rel_a & independent_rel.
_around_rel_a :< miscprep_rel.
_around_rel_s := _around_rel_a & selected_rel.
_around_rel := _around_rel_a & independent_rel.
_along_p_rel_a :< dir_or_state_rel.
_along_p_rel_s := _along_p_rel_a & selected_rel.
_along_p_rel := _along_p_rel_a & independent_rel.
_to_do_with_rel_a :< miscprep_rel.
_to_do_with_rel_s := _to_do_with_rel_a & selected_rel.
_to_do_with_rel := _to_do_with_rel_a & independent_rel.
_behind_rel_a :< dir_or_state_rel.
_behind_rel_s := _behind_rel_a & selected_rel.
_behind_rel := _behind_rel_a & independent_rel.
_after_prepx_rel_a :< temp_loc_abstr_rel.
_after_prepx_rel_s := _after_prepx_rel_a & selected_rel.
_after_prepx_rel := _after_prepx_rel_a & independent_rel.
_into_rel_a :< miscprep_rel.
_into_rel_s := _into_rel_a & selected_rel.
_into_rel := _into_rel_a & independent_rel.
_upon_rel_a :< state_loc_rel.
_upon_rel_s := _upon_rel_a & selected_rel.
_upon_rel := _upon_rel_a & independent_rel.
_apart_isect_rel_a :< abstr_adj_rel.
_apart_isect_rel_s := _apart_isect_rel_a & selected_rel.
_apart_isect_rel := _apart_isect_rel_a & independent_rel.
_open_rel_a :< abstr_adj_rel.
_open_rel_s := _open_rel_a & selected_rel.
_open_rel := _open_rel_a & independent_rel.
_until_rel_a :< prep_mod_rel.
_until_rel_s := _until_rel_a & selected_rel.
_until_rel := _until_rel_a & independent_rel.
_to_until_rel_a :< _until_rel_a.
_to_until_rel_s := _to_until_rel_a & _until_rel_s.
_to_until_rel := _to_until_rel_a & _until_rel.
_through_rel_a :< _until_rel_a.
_through_rel_s := _through_rel_a & _until_rel_s.
_through_rel := _through_rel_a & _until_rel.
_towards_rel_a :< dir_rel.
_towards_rel_s := _towards_rel_a & selected_rel.
_towards_rel := _towards_rel_a & independent_rel.
_like_prepx_rel_a :< miscprep_rel.
_like_prepx_rel_s := _like_prepx_rel_a & selected_rel.
_like_prepx_rel := _like_prepx_rel_a & independent_rel.
_out_of_rel_a :< dir_rel.
_out_of_rel_s := _out_of_rel_a & selected_rel.
_out_of_rel := _out_of_rel_a & independent_rel.


;;; these sorts are just used in the mrs-to-vit machinery


vmsort_anything :< *sort*.
vmsort_abstract :< vmsort_anything.
vmsort_property :< vmsort_abstract.
vmsort_field :< vmsort_abstract.
vmsort_info_content :< vmsort_abstract.
vmsort_institution :< vmsort_abstract.
vmsort_symbol :< vmsort_abstract.
vmsort_space_time :< vmsort_anything.
vmsort_temporal :< vmsort_space_time.
vmsort_situation :< vmsort_temporal.
vmsort_meeting_sit :< vmsort_situation.
vmsort_communication_sit :< vmsort_situation.
vmsort_action_sit :< vmsort_situation.
vmsort_move_sit :< vmsort_situation.
vmsort_position_sit :< vmsort_situation.
vmsort_temp_sit :< vmsort_situation.
vmsort_mental_sit :< vmsort_situation.
vmsort_time :< vmsort_temporal.
vmsort_entity :< vmsort_space_time.
vmsort_object :< vmsort_entity.
vmsort_agentive :< vmsort_object.
vmsort_human :< vmsort_agentive.
vmsort_animal :< vmsort_agentive. 
vmsort_thing :< vmsort_object.
vmsort_instrument :< vmsort_thing.
vmsort_info_bearer :< vmsort_thing.
vmsort_food :< vmsort_thing.
vmsort_vehicle :< vmsort_thing.
vmsort_substance :< vmsort_object.
vmsort_location :< vmsort_entity.
vmsort_geo_location :< vmsort_location.
vmsort_nongeo_location :< vmsort_location.

; Needed for underspecified "work" of "Kim works" and "Monday works"
work_unspec :< arg1_rel.

; Needed for idiosyncratic decomposition of "why"
cause :< miscprep_rel.

; Hack 13-Oct-99
; The following types in the ESEMDB don't follow the typographical 
; conventions for rel names, so can't be in the semrels.tdl file.
bring_down :< arg13_rel.
clarinet :< reg_nom_rel.
controller :< reg_nom_rel.
eco_friendly :< adj_rel.
household :< reg_nom_rel.
inside_n :< reg_nom_rel.
radio :< reg_nom_rel.
start_unspec :< arg13_rel.
nearly_grad :< very_deg_rel.
trace_n :< reg_nom_rel.

:end :type.
