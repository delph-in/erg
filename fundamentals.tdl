;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  fundamentals.tdl
;;;
;;;  Basic definitions of types for English grammar
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;  Last revision: Dan Flickinger, 20-Oct-97
;;;
;;;  $Id$

:begin :type.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

; Person and number represented as atomic sorts, with gender a separate attrib
; relevant for 3sg, and where count/mass distinction only for 3sg neuter.

pernum :< *sort*.
1or3sg :< pernum.
non3sg :< pernum.
non1sg :< non3sg.
2per :< non1sg.
1sg* := 1or3sg & non3sg.
1pl* :< non1sg.
2sg* :< 2per.
2pl* :< 2per.
3pl* :< non1sg.
3sg* :< 1or3sg.

1sg_and_1pl := 1sg* & 1pl*.
1sg_and_2per := 1sg* & 2per.
1sg_and_2sg := 1sg* & 2sg*.
1sg_and_2pl := 1sg* & 2pl*.
1sg_and_3pl := 1sg* & 3pl*.
1sg_and_3sg := 1sg* & 3sg*.
1pl_and_2per := 1pl* & 2per.
1pl_and_2sg := 1pl* & 2sg*.
1pl_and_2pl := 1pl* & 2pl*.
1pl_and_3pl := 1pl* & 3pl*.
1pl_and_3sg := 1pl* & 3sg*.
2per_and_3pl := 2per & 3pl*.
2per_and_3sg := 2per & 3sg*.
2sg_and_2pl := 2sg* & 2pl*.
2sg_and_3pl := 2sg* & 3pl*.
2sg_and_3sg := 2sg* & 3sg*.
2pl_and_3pl := 2pl* & 3pl*.  
2pl_and_3sg := 2pl* & 3sg*.  
3pl_and_3sg := 3pl* & 3sg*.  

strict_pn :< *sort*.

1sg := 1sg* & strict_pn.
1pl := 1pl* & strict_pn.
2sg := 2sg* & strict_pn.
2pl := 2pl* & strict_pn.
3sg := 3sg* & strict_pn.
3pl := 3pl* & strict_pn.

gender :< *sort*.
masc* :< gender.
fem* :< gender.
neut* :< gender.
andro* :< gender.

masc_and_fem := masc* & fem*.
masc_and_neut := masc* & neut*.
masc_and_andro := masc* & andro*.
fem_and_neut := fem* & neut*.
fem_and_andro := fem* & andro*.
neut_and_andro := neut* & andro*.

masc :< masc*.
fem :< fem*.
neut :< neut*.
andro :< andro*.

png := *avm* & 
  [ PN pernum,
    GEN gender ].

; ERB declarative and interrogative seem to form a natural class
; in that 'know', 'guess', 'suspect' ... take either.  The type
; decl_int is meant to reflect this.  
; ERB (23-07-96) declarative and imperative also form a class 
; with respect to tag questions.  The type decl_imp is meant to
; reflect this.

cl_mode :< *sort*.
no_cl_mode :< cl_mode.
relative :< cl_mode.
decl_int :< cl_mode.
decl_imp :< cl_mode.
declarative := decl_int & decl_imp.
interrogative :< decl_int.
imperative :< decl_imp.


tense :< *sort*.
present* :< tense.
past* :< tense.
future* :< tense.
presperf* :< tense.
pastperf* :< tense.

strict_tense :< tense.

present := present* & strict_tense.
past := past* & strict_tense.
future := future* & strict_tense.
presperf := presperf* & strict_tense.
pastperf := pastperf* & strict_tense.

pres+past := present* & past*.
pres+fut := present* & future*.
pres+prperf := present* & presperf*.
pres+pperf := present* & pastperf*.
past+fut := past* & future*.
past+prperf := past* & presperf*.
past+pperf := past* & pastperf*.
fut+prperf := future* & presperf*.
fut+pperf := future* & pastperf*.
prperf+pperf := presperf* & pastperf*.


voice :< *sort*.
active :< voice.
passive :< voice.
act+pass := active & passive.

mood :< *sort*.
ind_or_mod_subj :< mood.
indicative* :< ind_or_mod_subj.
modal_subj* :< ind_or_mod_subj.

strict_mood :< mood.
indicative := indicative* & strict_mood.
modal_subj := modal_subj* & strict_mood.
subjunctive :< strict_mood.
ind+modsubj := indicative* & modal_subj*.


prontype :< *sort*.
std_pron :< prontype.
std_1sg :< std_pron.
std_1pl :< std_pron.
std_2 :< std_pron.
std_3 :< std_pron.
recip :< prontype.
refl :< prontype.
impers :< prontype.
demon :< prontype.
zero_pron :< prontype.

; Three-valued sort evoking Polish logician Jan Lukasiewicz
luk :< *sort*.
; NA for Not Applicable.  A strictly-typed implementation would obviate need
; for this subtype, and we could just employ bool.
na :< luk.
bool :< luk.
+* :< bool.
-* :< bool.

; To enable coordination of unlike values, we add the intermediate types +* and
; -+, along with the conjoined type.

+_and_- := +* & -*.
+ :< +*.
- :< -*.
#|
; Replace these defs with the ones below, to eliminate disjunction.
*onull* :< *null*.
*ocons* := *cons* & 
  [ FIRST.OPT +, 
    REST *onull* ].
*olist* := *ocons* \| *onull*.

; The following should replace the above, but TDL unfortunately introduces
; a generated type "A&B" when a type C inherits from both A and B, and C
; introduces additional constraints.  Hence when A is unified with B during
; processing, the result is the type "A&B", not C.  So instead do the 
; hack below.

*olist* :< *list*.
*ocons* := *olist* & *cons* &
  [ FIRST.OPT +, 
    REST *olist* ].
*onull* := *olist* & *null*.
|#

; In addition, add constraint on optional arguments that their MODCONT.LISZT
; must be empty, since lexical heads selecting for arguments will append this
; LISZT to their own in order to allow, eg., meaning-bearing PP complements.

*olist* := *list* &
  [ FIRST unexpressed & [ OPT + ],
    REST  *list* & [ FIRST unexpressed & [ OPT + ],
		     REST.FIRST unexpressed & [ OPT + ] ] ].

  ;; The REST of *olist* should of course be *olist*, but TDL won't allow
  ;; recursive type definition, so add hack of making REST.FIRST.OPT +,
  ;; taking advantage of the fact that no lexical entry introduces three
  ;; optional complements followed by obligatory ones.

*ocons* := *olist* & *cons*.

  ;; *ocons* must crucially not introduce any constraints of its own, since
  ;; if it did, TDL would then introduce a generated type T which would
  ;; have *olist* and *cons* as supertypes, and then *ocons* would inherit
  ;; from T.  But then if the [OPT +] constraint were on *ocons*, it would
  ;; not be visible during processing, when *olist* and *cons* unified.
  ;; (see definition of function Infer-Is-GLB in 
  ;; "page/src/tdl/control/define-feature-type.lisp")

*onull* := *olist* & *null*.

;; This is just like *olist*, but in this case we know the list will never
;; have more than one element.

*gaplist* := *list* &
  [ FIRST gap,
    REST  *null* ].

*gapcons* := *gaplist* & *cons*.

*gapnull* := *gaplist* & *null*.

#| 
;;; LKB complains because of multiple introduction of FIRST and REST -
;;; so the definition above is overwritten by the following in the patches.tdl
;;; file in the directory <grammardir>/lkb/. 

*olist* :< *list*.
*ocons* := *olist* & *cons* &
  [ FIRST [ OPT +,
	    LOCAL.CONT.MODCONT.LISZT <! !> ],
    REST  *olist* ].
*onull* := *olist* & *null*.
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Top-level feature geometry
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT type

mod_local :< *avm*.

; The MOD value specifies the type of phrase that a sign can modify, and the
; POSTHEAD value stipulates the relative position of the modifier with
; respect to the head.  (An earlier approach employing a generalization about
; a head being final in its phrase or not might still be considered as an
; alternate to this stipulative one.)
; 15-jun-96 - Changed MOD to no longer be a HEAD feature, but rather a feature
; in CAT, to allow relative clause phrases to assign a non-empty MOD value
; even though the verbal head is [MOD no-mod].  Specific phrase types will
; propagate MOD from head-dtr to mother, but crucially not the subj-head type.
; The POSTHEAD feature stays with MOD, since only relevant when MOD non-empty.

head :<  *avm*.

valence := *avm* &
  [ SUBJ *list*,
    SPR *list*,
    COMPS *list*,
    --KEYCOMP *avm* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT type

mod-thing :< *avm*.
nothing :< mod-thing.
thing :< mod-thing.

handle :< thing.
individual :< thing.
eventtime :< thing.

index := individual &
  [ PNG png,
    DIVISIBLE bool,
    PRONTYPE prontype,
    SORT *sort* ].

vit := *avm* &
 [ VITTENSE tense,
   VITMOOD mood, 
   VITAGR index ]. 

event := individual &
  [ VIT vit,
    TIME eventtime,
    REFERENCE eventtime,
    SPCH eventtime ].

cont :< *avm*.

mod_relation :< cont.

relation := mod_relation & 
  [ HANDEL handle ].

no_rel :< mod_relation.

non_number_rel :< relation.

norm_relation :< non_number_rel.

; DIVISIBLE distinguishes singular count nouns from plural and mass nouns,
; for determiners like "some", and for bare-plural NPs.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT type

cat := *avm* &
  [ HEAD head,
    VALENCE valence,
    MOD mod_local,
    ROOT luk,
    POSTHEAD bool,
    --SCOPEDARG *avm*,
    --SCOPEDARG2 *avm* ].

; The feature ROOT has three possible values: +, -, and na.  Non-clauses are
; always ROOT na, since they can't really be said to be root or non-root.
; All clauses are ROOT bool, and if they have a restricted distribution then
; they are ROOT + or ROOT -.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MRS type
;
;   KEY mod_relation,      ; Pointer to the main relation in LISZT
;   MESSAGE mod_relation,  ; Relation determining message type for propositions
;   H-STORE *diff-list*,   ; Quantifier handle store
;   H-CONS *diff-list*     ; Scope constraints: list of scp_pr's
;   TOP-H handle,          ; Top handle of MRS expression
;   MODCONT cont,          ; Semantic content added when sign acts as modifier
;   ALTKEY mod_relation,   ; Pointer to an alternate relation in LISZT
;   COMPKEY mod_relation,  ; Pointer to the complement's main relation
;   OCOMPKEY mod_relation, ; Pointer to the oblique complement's main relation

mrs := cont &
  [ TOP handle,
    INDEX individual,
    LISZT *diff-list*,
    KEY mod_relation,      
    MESSAGE mod_relation,  
    H-STORE *diff-list*,   
    H-CONS *diff-list*,
    TOP-H handle,
    MODCONT cont,
    ALTKEY mod_relation,
    COMPKEY mod_relation,  
    OCOMPKEY mod_relation, 
    --STEMLISZT *diff-list*,
    --H-CONS *diff-list*,
    --SP-H-CONS *diff-list*
  ].

; Constrains handle of scopable argument SC-ARG relative to one or more 
; handles
scp_pr := *top* &          
  [ SC-ARG handle ].       

; Pairs handle of scopable argument with a list of candidate handles to unify  
; with that handle.
is-one-of := scp_pr &      
  [ CANDS *list* ].        

; Constrains handle of scopable argument to outscope argument whose handle is
; value of CANDS.
outscopes := scp_pr &      
  [ OUTSCPD handle ].     

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONJ type -
;
; CONJ values come in two types, cnil and strict-conj (i.e., non-cnil).  Cnil
; and the atomic substypes of strict-conj are the possible CONJ values of the
; left conjunct in a coordinate structure.  The right conjunct must always
; have a complex-conj CONJ value.  A complex CONJ value has three parts: the
; handles and indices of the sub-parts of the right conjunct, and the CHEAD
; info that gets passed from the right conjunct to the mother.  The CHEAD
; value has two pieces of information: the relation that will bind together
; the content of the entire coordinate structure and the CONJ values of the
; left conjunct daughters.  For more info about how those work, see
; top_coord_rule in syntax.tdl.

conj :< *avm*.
cnil :< conj.
strict-conj :< conj.
atomic-conj :< strict-conj.
both :< atomic-conj.
either :< atomic-conj.
neither :< atomic-conj.
nor :< atomic-conj.
chead := *avm* &
  [ LEFT *list*,
    RELTN relation ].
complex-conj := strict-conj &
  [ CHEAD chead,
    HANDELS *diff-list*,
    INDICES *diff-list* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Thematic roles (used for generation)

throle :< *sort*.
arg1 :< throle.
arg2 :< throle.
arg3 :< throle.
; Avoid blocking unification if arg roles differ (as with control verbs)
arg1+arg2 := arg1 & arg2.
arg1+arg3 := arg1 & arg3.
arg2+arg3 := arg2 & arg3.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Contextual information

c-inds := *avm* &
  [ SPEECH eventtime ].

ctxt := *avm* &
  [ ACTIVATED bool,
    C-INDS c-inds,
    PRESUP *diff-list* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Stem type

; The stemhead of a lexical entry is used by inflectional affixes to ensure the
; desired stem without overly restricting the value of HEAD itself, since
; this needs to remain non-specific to allow conjunction of non-similar heads. 
; Note that if we distinguished lexemes from words, the stemhead could be the
; value of HEAD for the lexeme, and the word's value for HEAD could be 
; supplied by the affix; then the same head type could be used for both.
; This feature is only given a more specific value for lexical entries which
; get inflected (verbs, nouns, and adjectives).

stemhead :< *sort*.
vstem :< stemhead.
nstem :< stemhead.
astem :< stemhead.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsem values

; The feature AGR is introduced on LOCAL rather than on CAT (or on HEAD) since
; coordination schema unify the CAT value of the daughters with that of then
; mother, but need to be able to change AGR on the mother (to get plural 
; agreement on verb when subject is a coordinated NP with "and" vs. "or").  

local := mod_local &
  [ CAT cat,
    CONT cont,
    CONJ conj,
    CTXT ctxt,
    ARG-S *list*,
    AGR index,
    THROLE throle,
    STEMHEAD stemhead ].

affix :< local.
no-affix :< mod_local.
no-mod :< mod_local.

non-local := *avm* &
  [ SLASH *diff-list*,
    QUE *diff-list*,
    REL *diff-list* ].

synsem := *avm* & 
  [ LOCAL mod_local,
    NON-LOCAL non-local,
    OPT bool,
    --ARG handle,
    --ARGH handle ].

lex_synsem := synsem &
  [ LOCAL local ].

phr_synsem := synsem &
  [ LOCAL local ].

non_canonical :< synsem.

gap := non_canonical &
  [ LOCAL #local,
    NON-LOCAL [ REL <! !>,
		QUE <! !>,
		SLASH <! #local !> ] ].

unexpressed := non_canonical &
  [ LOCAL.CONT.MODCONT.LISZT <! !>, 
    NON-LOCAL [ SLASH <! !>,
		REL <! !>,
		QUE <! !> ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign := *avm* & 
  [ STEM *list*,
    AFFIX mod_local,
    KEY-ARG bool,   
    SYNSEM synsem,
    C-CONT cont,
    ARGS *list* ],
  status: root-node.

word := sign & 
  [ SYNSEM lex_synsem ].

phrase := sign &
  [ SYNSEM phr_synsem & [ LOCAL [ CONT [ TOP #hand,
					 INDEX #index ],
				  ARG-S < > ] ],
    C-CONT mrs & [ TOP #hand,
		   INDEX #index ] ].

lex_entry := word &
  [ STEM < #stem >,
    ARGS < [ STEM #stem ] > ],
  status: lex-entry.

basic_multi_lex_entry :< word,
  status: c-lex-entry.

multi_lex_entry := basic_multi_lex_entry &
  [ STEM < #stem1, #stem2 >,
    ARGS < [ STEM #stem1 ], 
	   [ STEM #stem2, AFFIX no-affix ] > ].

key_first := basic_multi_lex_entry &
  [ ARGS < [ KEY-ARG + ], ... > ].

key_second := basic_multi_lex_entry &
  [ ARGS < *top*, [ KEY-ARG + ], ... > ].

key_third := basic_multi_lex_entry &
  [ ARGS < *top*, *top*, [ KEY-ARG + ], ... > ].

key_fourth := basic_multi_lex_entry &
  [ ARGS < *top*, *top*, *top*, [ KEY-ARG + ], ... > ].

multi_lex_entry1 := multi_lex_entry & key_first.
multi_lex_entry2 := multi_lex_entry & key_second.

two_space_lex_entry := basic_multi_lex_entry &
  [ STEM < #stem1, #stem2, #stem3 >,
    ARGS < [ STEM #stem1 ], 
	   [ STEM #stem2, AFFIX no-affix ], 
	   [ STEM #stem3, AFFIX no-affix ] > ].

two_space_lex_entry1 := two_space_lex_entry & key_first.
two_space_lex_entry2 := two_space_lex_entry & key_second.
two_space_lex_entry3 := two_space_lex_entry & key_third.

three_space_lex_entry := basic_multi_lex_entry &
  [ STEM < #stem1, #stem2, #stem3, #stem4 >,
    ARGS < [ STEM #stem1 ], 
	   [ STEM #stem2, AFFIX no-affix ], 
	   [ STEM #stem3, AFFIX no-affix ],
	   [ STEM #stem4, AFFIX no-affix ] > ].

three_space_lex_entry1 := three_space_lex_entry & key_first.
three_space_lex_entry2 := three_space_lex_entry & key_second.
three_space_lex_entry3 := three_space_lex_entry & key_third.
three_space_lex_entry4 := three_space_lex_entry & key_fourth.

rule :< *avm*,
	status: rule.

; LABEL and META used for labeling nodes in parse trees
label := *top*, status: label.
meta := *top*, status: meta.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CAT values

case :< *sort*.
nom :< case.
acc :< case.

vform :< *sort*.
non_fin :< vform.
non_prp :< non_fin.
ger :< non_prp.
pas :< non_prp.
psp :< non_fin.
bse_or_inf :< vform.
bse :< bse_or_inf.
; Base morphology verbs can be either base or imperative, but not if negated.
; See discussion of type neg_word.
bse_only := bse & non_fin.
; ERB (03-10-97) For filler_head_non_wh.
fin_or_imp :< vform. 
imp_vform := bse & fin_or_imp.
fin_or_inf :< vform.
fin := fin_or_imp & fin_or_inf.
inf_or_prp :< non_fin.
inf := inf_or_prp & bse_or_inf & fin_or_inf.
prp :< inf_or_prp.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

particle :< *avm*.

poss-able := *avm* &
  [ POSS bool ].

n_or_p :< head.
a_or_p :< head.
v_or_p :< head.
v_or_g :< head.

func :< head.

det := func & poss-able.

subst := head &
         [ PRD bool ].

nominal := subst &
  [ CASE case ].
verbal := subst & 
  [ VFORM vform ].

; mobile things can be extracted
mobile :< subst.

; Adverbs modify adverbees.
adverbee :< subst.

adj* := particle & a_or_p & adverbee & mobile.

prep* := particle & a_or_p & v_or_p & adverbee & mobile.

nsort :< *sort*.
proper* :< nsort.
common* :< nsort.

prop_and_com := proper* & common*.
proper :< proper*.
common :< common*.

noun* := nominal & poss-able & mobile &
  [ NSORT nsort ].

gerund* := noun* & adverbee & v_or_g.

; The following is only used in parse-nodes.tdl to distinguish lexical
; conjunctions from conjoined phrases.
conjh :< subst.

verb* := verbal & adverbee & v_or_p & v_or_g &
  [ AUX bool,
    INV bool,
    TENSE tense,
    VOICE voice,
    MOOD mood ].

comp* := nominal & verbal.

neg :< head.

adv := func & particle & mobile.

root-marker :< head.

detspec :< func.

; Hack used in blocking unwanted affixes
no_head :< head.

; The idea is that any two heads (for now only major categories) can be
; unified in a conjunction, but the resulting type is a specific type that
; will not be subcategorized for, so the only way conjuncts of distinct
; types will satisfy a subcat is when the head does not mention the type.
; An example is the copula "be", as in "Kim is in Paris and happy."

v_and_n := verb* & noun*. 
v_and_a := verb* & adj*.
v_and_p := verb* & prep*.
v_and_g := verb* & gerund*.
n_and_a := noun* & adj*.
n_and_p := noun* & prep*.
;;n_and_g := noun* & gerund*.
a_and_p := adj* & prep*.
a_and_g := adj* & gerund*.

; The following types are used to enable strict subcategorization (the usual 
; case)

strict_head :< head.

verb := verb* & strict_head.
noun := noun* & strict_head.
prep := prep* & strict_head.
adj := adj* & strict_head.
comp := comp* & strict_head.
gerund := noun & gerund*.

;;; Junk slot used in lexrules.tdl and auxverbs.tdl 
tmp := *avm* &
[ FIN_VERB *diff-list*,
  HAVE *diff-list*,
  NEG *diff-list*,
  BE *diff-list*,
  BE_ID *diff-list*,
  BE_ID_POS dl-append,
  BE_ID_NEG dl-append,
  BE_COP *diff-list*,
  BE_COP_POS dl-append,
  BE_COP_NEG dl-append,
  BE_TH_COP *diff-list*,
  BE_TH_COP_POS dl-append,
  BE_TH_COP_NEG dl-append ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  CONT values (MRS semantics)
;;
;; The basic semantic objects are all sub-types of thing.  Right now, the only
;; type of thing that has an internal structure is index, but that will
;; probably change.  For example, an event might have various times associated
;; with them or a handle may include a list of "subhandles" which are in its
;; scope.  Indices are classified in the familiar HPSG way.

expl-ind :< index.
it-ind := expl-ind &
  [ PNG [ PN 3sg*,
	  GEN neut* ] ].
there-ind :< expl-ind.
non_expl-ind :< index.
ref-ind :< non_expl-ind.
deg-ind :< non_expl-ind.

; The basic semantic structure, a CONT, is just something with a handle.
; Conts are further classified into mrss (i.e., things with liszts) and
; relations (i.e., things that go on liszts).  Conts are divided into psoas
; (with a distinguished event) and nom-objs (with a distinguished index).
; We use a polymorphic attribute name INDEX for both of these, to simplify
; manipulation of these objects; for example, modifying PPs assign as their
; ARG's value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  Similarly useful
; for coordination.

; ERB (03-10-96) 
; The intermediate types ques_prop_msg and prop_com_msg represent the
; natural classes needed for selection by know, announce, care, check,
; etc. and the analysis of THAT (see lextypes.tdl) and the 
; forthcoming analysis of tags on imperatives, respectively.

psoa := mrs &
	[ INDEX event ].

; Type to avoid introducing junk slot unless needed.
psoa-tmp := psoa &
        [ --TMP tmp ].

nom-obj := mrs &
	   [ INDEX index ].

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; Since some temporal nouns can be either arguments or VP modifiers, their 
; rel's INST value (coindexed with INDEX of the containing MRS) must remain 
; unspecified for type.  Consider "Kim arrived Tuesday" vs. "Tuesday comes
; after Monday"; in the first, Tuesday must have an EVENT index, while in the
; second, it must have a REF-IND index.

; ERB (24-10-96) Here is the series of relations that will be used for
; questions, etc.  Cf. Gizburg & Sag.
; ERB (12-05-96) Moved the ne_rel here.

message := norm_relation &
  [ SOA handle ].
imp_rel :< message.
prop_ques_rel :< message.          ;for COMPS of e.g. 'know'
propositional_rel :< prop_ques_rel.
prpstn_rel :< propositional_rel.   ;propositions
hypo_rel :< propositional_rel.     ;hypotheticals (PRO to go)

; For interrogatives; PARAMS value is a set of handles.
int_rel := prop_ques_rel &         
  [ PARAMS *diff-list* ].       

; Subtype of int_rel for tag questions.   
ne_rel :< int_rel.                 

dim_rel := norm_relation &
  [ DIM non_expl-ind ].

quant_or_wh_rel := dim_rel  &
  [ BV ref-ind,
    RESTR handle ].

demon_near_rel :< demonstrative_rel.
demon_far_rel :< demonstrative_rel.

quant_rel := quant_or_wh_rel &
  [ SCOPE handle ].

udef_rel :< quant_rel.
some_rel :< quant_rel.
def_rel :< quant_rel.
demonstrative_rel :< quant_rel.

;which_rel should not have a scope, but given for the moment to satisfy VIT
;which_rel :< quant_or_wh_rel.
which_rel :< quant_rel.

; Nominal sorts used for VM2

nominal-sort :< *sort*.
entity :< nominal-sort.
time :< nominal-sort.
info_bearer :< nominal-sort.
nongeo_location :< nominal-sort.

; AAC - fix for ARG3 introduction

aac_arg3_rel := norm_relation &
  [ ARG3 thing ].

; Nominal relations

basic_nom_rel := norm_relation &
  [ INST individual ].

nom_rel := basic_nom_rel &
  [ INST non_expl-ind ].

reg_nom_rel :< nom_rel.

diadic_nom_rel := nom_rel & aac_arg3_rel &
  [ NPREP thing & #arg3,
    ARG3 #arg3 ].

reg_diadic_nom_rel := diadic_nom_rel & reg_nom_rel.

hcomp_nom_rel := nom_rel & aac_arg3_rel &
  [ NOMARG handle & #arg3,
    ARG3 #arg3 ].

part_of_rel := diadic_nom_rel &
  [ SET handle ].

nominalize_rel := diadic_nom_rel &
  [ NMZARG handle ].

gerund_rel := diadic_nom_rel & hcomp_nom_rel.

temp_rel := nom_rel &
  [ INST.SORT time ].

day_rel :< temp_rel.

named_day_rel := day_rel &
  [ DAY atom ].

non_day_rel :< temp_rel.

;; day_of_month_rel
dofm_rel := named_day_rel & diadic_nom_rel &
  [ DAY integer,
    NPREP non_expl-ind ].

;; day_of_week_rel
dofw_rel := named_day_rel &
  [ DAY symbol ].

holiday_rel := named_day_rel &
  [ DAY symbol ].

day_part_rel := day_rel &
  [ OF-DAY non_expl-ind ].

hour_rel :< temp_rel.

; a quarter till three  ("till" is head - cf "come at a quarter till.")
hour_prep_rel := hour_rel &
  [ HOUR-IND individual,
    MINUTE-IND individual ].

numbered_hour_rel := hour_rel &
  [ INST.PNG [ PN 3sg*,
	       GEN neut* ],
    HOUR integer,
    MIN non_expl-ind,
    AM-PM non_expl-ind ].

minute_rel := temp_rel &
  [ MINUTE integer ].

am_pm_rel :< temp_rel.
am_rel :< am_pm_rel.
pm_rel :< am_pm_rel.

; 'the morning', not 'some morning': 'in the morning' but 'on some morning'
def_day_part_rel :< non_day_rel.

;; named_month_rel
mofy_rel := non_day_rel &
  [ MONTH symbol,
    YEAR-IND non_expl-ind ].

yofc_rel := non_day_rel &
  [ YEAR integer ].

season_rel := non_day_rel &
  [ SEASON symbol ].

age_rel :< non_day_rel.

_morning_rel :< day_part_rel.
_afternoon_rel :< day_part_rel.
_evening_rel :< day_part_rel.
_night_rel :< day_part_rel.
_weekday_rel :< dofw_rel.
_weekend_rel :< dofw_rel.
_workday_rel :< dofw_rel.


named_rel := reg_nom_rel &
  [ NAMED symbol ].


; Pronouns
pron_rel := reg_nom_rel &
  [ INST ref-ind &
	 [ PRONTYPE prontype ] ].

refl_pro_rel := pron_rel &
  [ INST.PRONTYPE refl ].

recip_pro_rel := pron_rel &
  [ INST.PRONTYPE recip ].

adj_rel := dim_rel &
  [ NARG individual ].

varg_rel := relation &
  [ VARG thing ].

adj_varg_rel := adj_rel & varg_rel &
  [ VARG handle ].

meas_adj_rel := adj_rel &
  [ MEAS handle ].

adj_personal_rel :< adj_rel.
adj_abstract_rel :< adj_rel.

verb_aspect_rel :< norm_relation.
event_arg_rel :< verb_aspect_rel.

aspect_rel := verb_aspect_rel &
  [ EVENT1 eventtime ].

temp_prec_rel := aspect_rel &
  [ LATER eventtime ].

temp_over_rel := aspect_rel &
  [ WHEN eventtime ].

prog_rel :< aspect_rel.

event_rel := event_arg_rel &
  [ EVENT event ].

mod_role_rel :< event_rel.

no_role_rel :< mod_role_rel. 
; E.g., weather verbs

role_rel :< mod_role_rel.

arg_rel := event_arg_rel &
	   [ ARG thing ].

irrealis_rel :< arg_rel.

support_rel := event_rel & varg_rel.

support_aux_rel :< support_rel.
support_main_rel := support_rel & mod_role_rel.

abstr_rel :< arg_rel.

act_rel := role_rel &
	   [ ACT individual ].
und_rel := role_rel &
           [ UND thing ].
act_und_rel := act_rel & und_rel.
und_only_rel :< und_rel.
prop_rel := role_rel &
	   [ PROP event ].
act_prop_rel := act_rel & prop_rel.

thm_rel := role_rel &
	   [ THM thing ].

expr_rel := role_rel &
	    [ EXPR individual ].

thm_expr_rel := thm_rel & expr_rel.

; Not currently used
;grd_rel := role_rel &
;	   [ GRD individual ].
;
;dest_rel := role_rel &
;	   [ DEST individual ].
;
;act_dest_rel := act_rel & dest_rel.
;
;effect_rel := role_rel &
;	      [ EFFECT event ].
;
;path_rel := role_rel &
;	    [ PATH event ].

poss_rel := norm_relation &
  [ POSSR non_expl-ind,
    POSSD non_expl-ind ].

fig_gnd_rel := role_rel &
  [ FIG thing,
    GND non_expl-ind ].

act_fig_gnd_rel := fig_gnd_rel & act_rel.
fig_gnd_und_rel := fig_gnd_rel & und_rel.


; Preposition relations

prep_rel := dim_rel &
  [ PREP non_expl-ind ].	    

prep_mod_rel := prep_rel & arg_rel.

loc_rel :< prep_mod_rel.
dir_rel :< loc_rel.
state_loc_rel :< loc_rel.
dir_or_state_rel := dir_rel & state_loc_rel.

temp_loc_rel :< loc_rel.

miscprep_rel :< prep_mod_rel.

adv_rel :< arg_rel.

neg_rel :< arg_rel.

neg_polar_rel :< adv_rel.

excl_rel := norm_relation &
  [ EXCL symbol ].

; Degree relations

degree_rel := dim_rel &
  [ DARG thing ].

comp_degree_rel :< degree_rel.
non_comp_degree_rel :< degree_rel.

temp_degree_rel := non_day_rel & non_comp_degree_rel.
_week_rel :< temp_degree_rel.
_fortnight_rel :< temp_degree_rel.
_month_rel :< temp_degree_rel.
_moment_rel :< temp_degree_rel.

; For specifiers of adjectives
deg_rel :< non_comp_degree_rel.

; For specifiers of positive adjectives
very_deg_rel :< deg_rel.

; For specifiers of comparative adjectives
much_deg_rel :< deg_rel.

; For specifiers of either positives or comparatives
very_or_much_rel := very_deg_rel & much_deg_rel.

comparative_rel := comp_degree_rel &
  [ ARG-1 index,
    C-INST index ].

comp_more_less_rel := comparative_rel &
  [ ARG-2 index ].
more_sc_adv_rel :< comp_more_less_rel.
comp_less_rel :< comp_more_less_rel.

comp_most_least_rel := comparative_rel & 
  [ C-SET handle ].

comp_most_rel :< comp_most_least_rel.
comp_least_rel :< comp_most_least_rel.

#|
; This should probably be separated into two relations in the relevant
; lexical types, leaving the quant_rel with only its usual attributes.
comp_q_rel := quant_rel &
  [ ARG-1 #index,
    CQ-ARG-2 index,
    BV #index,
    CQ-INST index ].
|#

act_prep_rel := act_rel & 
  [ PREPARG individual ].

act_und_thm_rel := act_und_rel & thm_rel.
act_und_prep_rel := act_prep_rel & act_und_rel.
act_und_thm_prep_rel := act_und_thm_rel & act_und_prep_rel.

transfer_rel :< act_rel.
transfer_obj_rel := transfer_rel & act_und_rel.
transfer_dative_rel := transfer_obj_rel & act_und_prep_rel.
double_np_rel := act_und_thm_rel &
  [ THM individual ].
dative_to_rel :< transfer_dative_rel.

; bet
act_und_thm_prop_rel := act_und_thm_rel & prop_rel.

_to_rel :< dir_rel.
_for_rel :< miscprep_rel.
_by_rel :< miscprep_rel.
_by_pass_rel :< miscprep_rel.
_of_rel :< prep_mod_rel.
_in_rel :< dir_or_state_rel.
until_rel :< prep_mod_rel.

subord_rel := norm_relation &
  [ MAIN handle,
    SUBORD handle ].

arg1_rel := role_rel &
  [ ARG1 thing ].
arg2_rel := role_rel &
  [ ARG2 thing ].
arg3_rel := role_rel & aac_arg3_rel &
  [ ARG3 thing ].

vit_a_1 := act_rel & arg1_rel &
  [ ACT #act,
    ARG1 #act ].
vit_a_2 := act_rel & arg2_rel &
  [ ACT #act,
    ARG2 #act ].
vit_a_3 := act_rel & arg3_rel &
  [ ACT #act,
    ARG3 #act ].
vit_u_1 := und_rel & arg1_rel &
  [ UND #und,
    ARG1 #und ].
vit_u_2 := und_rel & arg2_rel &
  [ UND #und,
    ARG2 #und ].
vit_u_3 := und_rel & arg3_rel &
  [ UND #und,
    ARG3 #und ].
vit_t_2 := thm_rel & arg2_rel &
  [ THM #thm,
    ARG2 #thm ].
vit_t_3 := thm_rel & arg3_rel &
  [ THM #thm,
    ARG3 #thm ].
vit_pa_2 := act_prep_rel & arg2_rel &
  [ PREPARG #prep,
    ARG2 #prep ].
vit_pa_3 := act_prep_rel & arg3_rel &
  [ PREPARG #prep,
    ARG3 #prep ].
vit_g_1 := fig_gnd_rel & arg1_rel &
  [ GND #gnd,
    ARG1 #gnd ].
vit_g_2 := fig_gnd_rel & arg2_rel &
  [ GND #gnd,
    ARG2 #gnd ].
vit_g_3 := fig_gnd_rel & arg3_rel &
  [ GND #gnd,
    ARG3 #gnd ].
vit_f_2 := fig_gnd_rel & arg2_rel &
  [ FIG #fig,
    ARG2 #fig ].
vit_f_3 := fig_gnd_rel & arg3_rel &
  [ FIG #fig,
    ARG3 #fig ].
vit_arg_3 := varg_rel & arg3_rel &
  [ VARG #arg,
    ARG3 #arg ].
vit_arg := varg_rel & arg_rel &
  [ VARG #arg,
    ARG #arg ].

vit_fg_31 := vit_f_3 & vit_g_1.
vit_fg_32 := vit_f_3 & vit_g_2.
vit_fg_23 := vit_f_2 & vit_g_3.

vit_au_13 := vit_a_1 & vit_u_3.
vit_au_12 := vit_a_1 & vit_u_2.
vit_au_23 := vit_a_2 & vit_u_3.
vit_ap_12 := vit_a_1 & vit_pa_2.
vit_ap_13 := vit_a_1 & vit_pa_3.
vit_ap_32 := vit_a_3 & vit_pa_2.
vit_aup_123 := vit_au_13 & vit_pa_2.
vit_aut_123 := vit_au_12 & vit_t_3.
vit_autp_123 := vit_au_13 & vit_t_2 & vit_pa_2.
vit_afg_123 := vit_a_1 & vit_fg_23.
vit_afg_132 := vit_a_1 & vit_fg_32.
act_rel_a_1 :< vit_a_1.
act_rel_a_3 :< vit_a_3.
und_only_rel_u_3 := und_only_rel & vit_u_3.
und_only_rel_u_1 := und_only_rel & vit_u_1.
act_und_rel_au_13 := act_und_rel & vit_au_13.
act_und_rel_au_12 := act_und_rel & vit_au_12.
act_und_rel_au_23 := act_und_rel & vit_au_23.
act_prep_rel_ap_13 :< vit_ap_13.
act_prep_rel_ap_12 :< vit_ap_12.
act_prep_rel_ap_32 :< vit_ap_32.
fig_gnd_rel_fg_31 :< vit_fg_31.
fig_gnd_rel_fg_32 :< vit_fg_32.
act_und_prep_rel_aup_123 := act_und_prep_rel & vit_aup_123.
act_und_thm_rel_aut_123 := act_und_thm_rel & vit_aut_123.
act_fig_gnd_rel_afg_132 := act_fig_gnd_rel & vit_afg_132.
act_fig_gnd_rel_afg_123 := act_fig_gnd_rel & vit_afg_123.
act_und_thm_prep_rel_autp_123 := act_und_thm_prep_rel & vit_autp_123.
support_main_rel_arg_3 := support_main_rel & vit_arg_3.
support_rel_arg := support_rel & vit_arg.

; Discourse functions

; ERB (03-10-96) In order to capture the similarities and differences
; between embedded and matrix questions, I am decomposing the ynq_rel
; into polar_q_rel and request_ans_rel.  The latter is probably 
; equivalent to the ne_rel (see below), but ne_rel is too cute to
; forgo for the tag questions and probably too opaque for the 
; matrix yn questions, so I will keep the two for now.  NB polar_q_rel
; probably doesn't qualify as 'discourse function'.  

; So, the ynq_root construction will contribute a polar_q_rel and
; a request_ans_rel, whether will contribute a polar_q_rel, and
; matrix wh questions will contribute a request_ans_rel.

polar_q_rel :< arg_rel.
request_ans_rel :< arg_rel.

polite_rel :< arg_rel.
_dont_rel :< imp_rel.
_lets_rel :< imp_rel.
_how_about_rel :< int_rel.
_whatabout_rel :< int_rel.
_not_disc_rel :< prop_ques_rel.

; Phrasally introduced relations

unspec_rel := norm_relation &
  [ HINST index,
    NHINST index ].

; Relation introduced for tag questions

probable_rel :< adj_rel.

conj_rel := norm_relation &
  [ C-ARG individual,
    C-HANDELS *diff-list*,
    C-INDICES *diff-list* ].

; Abstract relations specified by more than one lexical entry

airplane_rel :< reg_nom_rel.
place_rel :< reg_nom_rel.
telephone_rel :< reg_nom_rel.
person_rel :< reg_nom_rel.
nonperson_rel :< reg_nom_rel.

ord_rel := adj_rel &
  [ ORD integer ].

title_rel :< basic_nom_rel.

cop_id_rel := arg1_rel & arg3_rel &
	      [ ID1 non_expl-ind & #id1,
		ID2 non_expl-ind & #id2,
		ARG1 #id1,
		ARG3 #id2 ].

_there_cop_rel := event_rel & aac_arg3_rel &
  [ ARG3 non_expl-ind ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Number relations

number_rel := relation &
  [ XARG individual ].

integer_rel := number_rel &
  [ I-ORD bool ].
const_rel := integer_rel & [ CONST_VALUE integer].
plus_rel := integer_rel & [ TERM1 handle,
			    TERM2 handle].
times_rel := integer_rel & [ FACTOR1 handle,
			     FACTOR2 handle].

;; TYPES/SORTS
;; The ORDINAL feature determines whether its bearer is ordinal or not 
;; (i.e., is ordinal or cardinal).  Thus it is only appropriate for
;; numbers.  All numbers have a HEAD value of sort intsort, those
;; used adjectivally have heads of sort intadj (or one of its 
;; subsorts) or intdet (which has no subsorts).  Nominal uses are
;; not yet supported.
;;
;; Subcategorization, which is in terms of the maximum number of digits
;; allowed for the complement or specifier, is handled by the subsorts
;; of the digitn hierarchy.  Currently, only adjectives participate in
;; this hierarchy; there is only a single integer determiner ("one").
;; Nominal uses could be added by adding a type
;;          intnoun := intsort & digitn & noun.


intsort := head & [ORDINAL bool].

digitn :< head.

digit9 :< digitn.
digit6 :< digit9.
digit3 :< digit6.
digit2 :< digit3.
digit1 :< digit2.

; The sorts    digitk    specify the number of digits of a lexeme 
; together with its largest complement and specifier.
; The sorts    digitk-    are used for subcategorization; they include
; values of k or fewer digits.
 
digit9- :< digitn.
digit6- :< digit9-.
digit3- :< digit6-.
digit2- :< digit3-.
digit1- :< digit2-.

;digit1 :< digit1-.
;digit2 :< digit2-.
;digit3 :< digit3-.
;digit6 :< digit6-.
;digit9 :< digit9-.

intadj  := intsort & adj.
intadjn := intadj & digitn.
intdet  := intsort & det.

; intadj1- := intadj1.
; intadjk- means an integer adjective of at most k digits (when
;   combined with specifier and complement

intadj9- :< intadj.
intadj9  := intadj9- & digit9.
intadj6- :< intadj9-.
intadj6  := intadj6- & digit6.
intadj3- :< intadj6-.
intadj3  := intadj3- & digit3.
intadj2- :< intadj3-.
intadj2  := intadj2- & digit2.
intadj1  := intadj2- & digit1.
