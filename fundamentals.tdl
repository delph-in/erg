;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  fundamentals.tdl
;;;
;;;  Basic definitions of types for English grammar
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;  Last revision: Dan Flickinger, 20-Oct-97
;;;
;;;  $Id$

:begin :type.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

; Person and number represented as atomic sorts, with gender a separate attrib
; relevant for 3sg, and where count/mass distinction only for 3sg neuter.

pernum :< *sort*.
1or3sg :< pernum.
non3sg :< pernum.
non1sg :< non3sg.
2per :< non1sg.
1sg* := 1or3sg & non3sg.
1pl* :< non1sg.
2sg* :< 2per.
2pl* :< 2per.
3pl* :< non1sg.
3sg* :< 1or3sg.

1sg_and_1pl := 1sg* & 1pl*.
1sg_and_2per := 1sg* & 2per.
1sg_and_2sg := 1sg* & 2sg*.
1sg_and_2pl := 1sg* & 2pl*.
1sg_and_3pl := 1sg* & 3pl*.
1sg_and_3sg := 1sg* & 3sg*.
1pl_and_2per := 1pl* & 2per.
1pl_and_2sg := 1pl* & 2sg*.
1pl_and_2pl := 1pl* & 2pl*.
1pl_and_3pl := 1pl* & 3pl*.
1pl_and_3sg := 1pl* & 3sg*.
2per_and_3pl := 2per & 3pl*.
2per_and_3sg := 2per & 3sg*.
2sg_and_2pl := 2sg* & 2pl*.
2sg_and_3pl := 2sg* & 3pl*.
2sg_and_3sg := 2sg* & 3sg*.
2pl_and_3pl := 2pl* & 3pl*.  
2pl_and_3sg := 2pl* & 3sg*.  
3pl_and_3sg := 3pl* & 3sg*.  

strict_pn :< *sort*.

1sg := 1sg* & strict_pn.
1pl := 1pl* & strict_pn.
2sg := 2sg* & strict_pn.
2pl := 2pl* & strict_pn.
3sg := 3sg* & strict_pn.
3pl := 3pl* & strict_pn.

gender :< *sort*.
masc* :< gender.
fem* :< gender.
neut* :< gender.
andro* :< gender.

masc_and_fem := masc* & fem*.
masc_and_neut := masc* & neut*.
masc_and_andro := masc* & andro*.
fem_and_neut := fem* & neut*.
fem_and_andro := fem* & andro*.
neut_and_andro := neut* & andro*.

; ERB (12-12-97) need a strict sort for gender for tags.

strict_gen :< *sort*.

masc := masc* & strict_gen.
fem := fem* & strict_gen.
neut := neut* & strict_gen.
andro := andro* & strict_gen.

png := *avm* & 
  [ PN pernum,
    GEN gender ].

; ERB declarative and interrogative seem to form a natural class
; in that 'know', 'guess', 'suspect' ... take either.  The type
; decl_int is meant to reflect this.  
; ERB (23-07-96) declarative and imperative also form a class 
; with respect to tag questions.  The type decl_imp is meant to
; reflect this.

cl_mode :< *sort*.
no_cl_mode :< cl_mode.
relative :< cl_mode.
decl_int :< cl_mode.
decl_imp :< cl_mode.
declarative := decl_int & decl_imp.
interrogative :< decl_int.
imperative :< decl_imp.


voice :< *sort*.
active :< voice.
passive :< voice.
act+pass := active & passive.

mood :< *sort*.
ind_or_mod_subj :< mood.
indicative* :< ind_or_mod_subj.
modal_subj* :< ind_or_mod_subj.
would_subj* :< modal_subj*.

strict_mood :< mood.
indicative := indicative* & strict_mood.
modal_subj := modal_subj* & strict_mood.
would_subj := would_subj* & strict_mood.
subjunctive :< strict_mood.
ind+modsubj := indicative* & modal_subj*.


prontype :< *sort*.
std_pron :< prontype.
std_1sg :< std_pron.
std_1pl :< std_pron.
std_2 :< std_pron.
std_3 :< std_pron.
recip :< prontype.
refl :< prontype.
impers :< prontype.
demon :< prontype.
zero_pron :< prontype.

; Three-valued sort evoking Polish logician Jan Lukasiewicz
luk :< *sort*.
; NA for Not Applicable.  A strictly-typed implementation would obviate need
; for this subtype, and we could just employ bool.
na :< luk.
bool :< luk.
+* :< bool.
-* :< bool.

; To enable coordination of unlike values, we add the intermediate types +* and
; -+, along with the conjoined type.

+_and_- := +* & -*.
+ :< +*.
- :< -*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Top-level feature geometry
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT type

mod_local :< *avm*.

; The MOD value specifies the type of phrase that a sign can modify, and the
; POSTHEAD value stipulates the relative position of the modifier with
; respect to the head.  (An earlier approach employing a generalization about
; a head being final in its phrase or not might still be considered as an
; alternate to this stipulative one.)
; The POSTHEAD feature should stays with MOD, since only relevant when MOD is
; non-empty.

head := *avm* &
  [ MOD mod_local ].

valence := *avm* &
  [ SUBJ *list*,
    SPR *list*,
    COMPS *list*,
    SPEC *list*,
    --KEYCOMP *avm* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT type

mod-thing :< *avm*.
nothing :< mod-thing.
thing :< mod-thing.

handle :< thing.
mod_individual :< thing.
eventtime :< thing.

disc_frag :< mod_individual.
individual :< mod_individual.

index := individual &
  [ PNG png,
    DIVISIBLE bool,
    PRONTYPE prontype,
    SORT *sort* ].


; This is the type of the index of the phrase modified by predicative PPs, which
; can either modify a ref-ind nominal or an event VP.
non_expl :< individual.

; VITTENSE cannot have the default sort 'tense', due to our 

vit := *avm* &
 [ VITTENSE *sort*,
   VITMOOD mood, 
   VITAGR index ]. 

temp_relation :< *sort*.
overlap :< temp_relation.
precede :< temp_relation.
follow :< temp_relation.

event := non_expl &
  [ TIME eventtime,
    VIT vit ].

cont :< *avm*.

mod_relation :< cont.

relation := mod_relation & 
  [ HANDEL handle ].

no_rel :< mod_relation.

non_number_rel :< relation.

norm_relation :< non_number_rel.

; DIVISIBLE distinguishes singular count nouns from plural and mass nouns,
; for determiners like "some", and for bare-plural NPs.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT type

cat := *avm* &
  [ HEAD head,
    VAL valence,
    MC luk,
    POSTHEAD bool,
    --SCOPEDARG *avm*,
    --SCOPEDARG2 *avm* ].

; The feature MC has three possible values: +, -, and na.  Non-clauses are
; always MC na, since they can't really be said to be root or non-root.
; All clauses are MC bool, and if they have a restricted distribution then
; they are MC + or MC -.


;; Experimental use of subtypes of *diff-list* to enforce constraint of at
;; most one element in SLASH (for efficiency, "violin/sonnet" examples
;; notwithstanding).  Will only have effect in LKB version which does the
;; necessary type inference.

0-1-dlist := *diff-list* &
  [ LIST 0-1-list ].
0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].
1-dlist := 0-1-dlist &
  [ LIST 1-list &
	 [ REST #rest & *null* ],
    LAST #rest ].
    

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MRS type
;
;   KEY mod_relation,      ; Pointer to the main relation in LISZT
;   MESSAGE *diff-list*,   ; Message type for propositions
;   H-STORE *diff-list*,   ; Quantifier handle store
;   H-CONS *diff-list*     ; Scope constraints: list of scp_pr's
;   TOP-H handle,          ; Top handle of MRS expression
;   ECONT cont,            ; External content added when sign acts as modifier
;   ALTKEY mod_relation,   ; Pointer to an alternate relation in LISZT
;   COMPKEY mod_relation,  ; Pointer to the complement's main relation
;   OCOMPKEY mod_relation, ; Pointer to the oblique complement's main relation


basicmrs := cont &
  [ TOP handle,
    INDEX mod_individual,
    LISZT *diff-list*,
    KEY mod_relation,      
    MESSAGE *diff-list*,  
    H-CONS *diff-list*,
    H-STORE *diff-list*,
    ECONT cont ].

econtmrs := basicmrs &
  [ ECONT basicmrs ].

mrs := econtmrs &
  [ TOP-H handle,
    ALTKEY mod_relation,
    COMPKEY mod_relation,  
    OCOMPKEY mod_relation, 
    --H-CONS *diff-list*,
    --SP-H-CONS *diff-list*
    ].

; Constrains handle of scopable argument SC-ARG relative to one or more 
; handles
scp_pr := *top* &          
  [ SC-ARG handle ].       

; Pairs handle of scopable argument with a list of candidate handles to unify  
; with that handle.
is-one-of := scp_pr &      
  [ CANDS *diff-list* ].        

; Constrains handle of scopable argument to outscope argument whose handle is
; value of CANDS.
outscopes := scp_pr &      
  [ OUTSCPD handle ].     

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONJ type -
;
; CONJ values come in two types, cnil and strict-conj (i.e., non-cnil).  Cnil
; and the atomic substypes of strict-conj are the possible CONJ values of the
; left conjunct in a coordinate structure.  The right conjunct must always
; have a complex-conj CONJ value.  A complex CONJ value has three parts: the
; handles and indices of the sub-parts of the right conjunct, and the CHEAD
; info that gets passed from the right conjunct to the mother.  The CHEAD
; value has two pieces of information: the relation that will bind together
; the content of the entire coordinate structure and the CONJ values of the
; left conjunct daughters.  For more info about how those work, see
; top_coord_rule in syntax.tdl.

conj :< *avm*.
cnil :< conj.
strict-conj :< conj.
atomic-conj :< strict-conj.
both :< atomic-conj.
either :< atomic-conj.
neither :< atomic-conj.
nor :< atomic-conj.
chead := *avm* &
  [ LEFT *list*,
    RELTN relation ].
complex-conj := strict-conj &
  [ CHEAD chead,
    HANDELS *diff-list*,
    INDICES *diff-list* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Thematic roles (used for generation)

throle :< *sort*.
arg1 :< throle.
arg2 :< throle.
arg3 :< throle.
; Avoid blocking unification if arg roles differ (as with control verbs)
arg1+arg2 := arg1 & arg2.
arg1+arg3 := arg1 & arg3.
arg2+arg3 := arg2 & arg3.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Contextual information

c-inds := *avm* &
  [ SPEECH eventtime ].

ctxt := *avm* &
  [ ACTIVATED bool,
    C-INDS c-inds,
    PRESUP *diff-list* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Stem type

; The stemhead of a lexical entry is used by inflectional affixes to ensure the
; desired stem without overly restricting the value of HEAD itself, since
; this needs to remain non-specific to allow conjunction of non-similar heads. 
; Note that if we distinguished lexemes from words, the stemhead could be the
; value of HEAD for the lexeme, and the word's value for HEAD could be 
; supplied by the affix; then the same head type could be used for both.
; This feature is only given a more specific value for lexical entries which
; get inflected (verbs, nouns, and adjectives).

stemhead :< *sort*.
vstem :< stemhead.
nstem :< stemhead.
astem :< stemhead.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsem values

; The feature AGR is introduced on LOCAL rather than on CAT (or on HEAD) since
; coordination schema unify the CAT value of the daughters with that of then
; mother, but need to be able to change AGR on the mother (to get plural 
; agreement on verb when subject is a coordinated NP with "and" vs. "or").  

local := mod_local &
  [ CAT cat,
    CONT cont,
    CONJ conj,
    CTXT ctxt,
    ARG-S *list*,
    AGR index,
    THROLE throle,
    STEMHEAD stemhead ].

affix :< local.
no-affix :< mod_local.
no-mod :< mod_local.

non-local := *avm* &
  [ SLASH 0-1-dlist,
    QUE 0-1-dlist,
    REL 0-1-dlist ].

synsem := *avm* & 
  [ LOCAL mod_local,
    NON-LOCAL non-local,
    OPT bool,
    --ARG handle,
    --ARGH handle,
    --OUTSC handle ].

expressed_synsem :< synsem.

canonical_synsem := expressed_synsem &
  [ MODIFIED bool ].

lex_synsem := canonical_synsem &
  [ LOCAL local ].

phr_synsem := canonical_synsem &
  [ LOCAL local ].

non_canonical := synsem &
  [ LOCAL.CONT.INDEX non_expl ].

gap := non_canonical & expressed_synsem &
  [ LOCAL #local,
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist,
		SLASH 1-dlist & 
		    [ LIST < #local > ] ] ].

unexpressed := non_canonical &
  [ LOCAL.CONT.ECONT.LISZT <! !>, 
    NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

#|
; Replace these defs with the ones below, to eliminate disjunction.
*onull* :< *null*.
*ocons* := *cons* & 
  [ FIRST.OPT +, 
    REST *onull* ].
*olist* := *ocons* \| *onull*.

; The following should replace the above, but TDL unfortunately introduces
; a generated type "A&B" when a type C inherits from both A and B, and C
; introduces additional constraints.  Hence when A is unified with B during
; processing, the result is the type "A&B", not C.  So instead do the 
; hack below.

*olist* :< *list*.
*ocons* := *olist* & *cons* &
  [ FIRST.OPT +, 
    REST *olist* ].
*onull* := *olist* & *null*.

*olist* := *list* &
  [ FIRST unexpressed & [ OPT + ],
    REST  *list* & [ FIRST unexpressed & [ OPT + ],
		     REST.FIRST unexpressed & [ OPT + ] ] ].
|#

  ;; The REST of *olist* should of course be *olist*, but TDL won't allow
  ;; recursive type definition, so add hack of making REST.FIRST.OPT +,
  ;; taking advantage of the fact that no lexical entry introduces two
  ;; optional complements followed by obligatory ones.

*olist* := *list* &
  [ FIRST unexpressed & [ OPT + ],
    REST  *list* & [ FIRST unexpressed & [ OPT + ] ] ].

*ocons* := *olist* & *cons*.

  ;; *ocons* must crucially not introduce any constraints of its own, since
  ;; if it did, TDL would then introduce a generated type T which would
  ;; have *olist* and *cons* as supertypes, and then *ocons* would inherit
  ;; from T.  But then if the [OPT +] constraint were on *ocons*, it would
  ;; not be visible during processing, when *olist* and *cons* unified.
  ;; (see definition of function Infer-Is-GLB in 
  ;; "page/src/tdl/control/define-feature-type.lisp")

*onull* := *olist* & *null*.

#| 
;;; LKB complains because of multiple introduction of FIRST and REST -
;;; so the definition above is overwritten by the following in the patches.tdl
;;; file in the directory <grammardir>/lkb/. 

; Add constraint on optional arguments that their ECONT.LISZT must be empty, 
; since lexical heads selecting for arguments will append this
; LISZT to their own in order to allow, eg., meaning-bearing PP complements.

*olist* :< *list*.
*ocons* := *olist* & *cons* &
  [ FIRST [ OPT +,
	    LOCAL.CONT.ECONT.LISZT <! !> ],
    REST  *olist* ].
*onull* := *olist* & *null*.
|#

;; This is just like *olist*, but in this case we know the list will never
;; have more than one element.

*gaplist* := *list* &
  [ FIRST gap,
    REST  *null* ].

*gapcons* := *gaplist* & *cons*.

*gapnull* := *gaplist* & *onull*.

; ERB (14-12-97) Here's another one where we know there's only ever
; one.

; ERB (21-01-98) Some trickiness about the SLASH value.  See notes
; near pro_ss.

*prolist* := *list* &
  [ FIRST pro_ss &
	  [ NON-LOCAL.SLASH 0-dlist ],
    REST *null* ].

*procons* := *prolist* & *cons*.

*pronull* := *prolist* & *null*.

;; *unexplist* is used for common nouns whose specifier is possibly obligatory,
;; but unexpressed, as in noun-noun compounds.  As usual, we use the same hack
;; as for *olist*, to get around the lack of recursive types in TDL.

*unexplist* := *list* &
  [ FIRST unexpressed,
    REST  *null* ].

*unexpcons* := *unexplist* & *cons*.

*unexpnull* := *unexplist* & *null*.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign := *avm* & 
  [ KEY-ARG bool,   
    SYNSEM synsem,
    ARGS *list*,
    INFLECTED bool,
    ROOT bool ],
  status: root-node.

word := sign & 
  [ STEM *list*,
    SYNSEM lex_synsem,
    AFFIX mod_local,
    ROOT - ].

phrase := sign &
  [ SYNSEM phr_synsem & [ LOCAL [ CONT [ TOP #hand,
					 INDEX #index ],
				  ARG-S < > ] ],
    ROOT bool,
    C-CONT basicmrs & [ TOP #hand,
			INDEX #index ] ].

; AAC - STEM must have a list value

lex_entry := word &
  [ STEM < #stem >,
    ARGS < [ STEM < #stem > ] >,
    INFLECTED bool ],
  status: lex-entry.

basic_multi_lex_entry := word &
  [ INFLECTED bool ],
  status: c-lex-entry.

; for the LKB version, INFLECTED has to be -
; so lex_entry and basic_multi_lex_entry 
; are redefined in the patches file

multi_lex_entry := basic_multi_lex_entry &
  [ STEM < #stem1, #stem2 >,
    ARGS < [ STEM < #stem1 > ], 
	   [ STEM < #stem2 >, AFFIX no-affix ] > ].

key_first := basic_multi_lex_entry &
  [ ARGS < [ KEY-ARG + ], ... > ].

key_second := basic_multi_lex_entry &
  [ ARGS < *top*, [ KEY-ARG + ], ... > ].

key_third := basic_multi_lex_entry &
  [ ARGS < *top*, *top*, [ KEY-ARG + ], ... > ].

key_fourth := basic_multi_lex_entry &
  [ ARGS < *top*, *top*, *top*, [ KEY-ARG + ], ... > ].

multi_lex_entry1 := multi_lex_entry & key_first.
multi_lex_entry2 := multi_lex_entry & key_second.

two_space_lex_entry := basic_multi_lex_entry &
  [ STEM < #stem1, #stem2, #stem3 >,
    ARGS < [ STEM < #stem1 > ], 
	   [ STEM < #stem2 >, AFFIX no-affix ], 
	   [ STEM < #stem3 >, AFFIX no-affix ] > ].

two_space_lex_entry1 := two_space_lex_entry & key_first.
two_space_lex_entry2 := two_space_lex_entry & key_second.
two_space_lex_entry3 := two_space_lex_entry & key_third.

three_space_lex_entry := basic_multi_lex_entry &
  [ STEM < #stem1, #stem2, #stem3, #stem4 >,
    ARGS < [ STEM < #stem1 > ], 
	   [ STEM < #stem2 >, AFFIX no-affix ], 
	   [ STEM < #stem3 >, AFFIX no-affix ],
	   [ STEM < #stem4 >, AFFIX no-affix ] > ].

three_space_lex_entry1 := three_space_lex_entry & key_first.
three_space_lex_entry2 := three_space_lex_entry & key_second.
three_space_lex_entry3 := three_space_lex_entry & key_third.
three_space_lex_entry4 := three_space_lex_entry & key_fourth.

rule := *avm* &
  [ RULE-NAME symbol ],
  status: rule.

; LABEL and META used for labeling nodes in parse trees

label := *top*, status: label.

meta := *top*, status: meta.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CAT values

case :< *sort*.
nom :< case.
acc :< case.

vform :< *sort*.
non_fin :< vform.
non_prp :< non_fin.
ger :< non_prp.
pas :< non_prp.
psp :< non_fin.
bse_or_inf :< vform.
; fin_or_bse used to collapse morpholog. unmarked forms for bse and fin-non3sg.
fin_or_bse :< vform.
bse := bse_or_inf & fin_or_bse.
; Base morphology verbs can be either base or imperative, but not if negated.
; See discussion of type neg_word.
bse_only := bse & non_fin.
; ERB (03-10-97) For filler_head_non_wh.
fin_or_imp :< vform. 
imp_vform := bse & fin_or_imp.
fin_or_inf :< vform.
fin := fin_or_imp & fin_or_inf & fin_or_bse.
inf_or_prp :< non_fin.
inf := inf_or_prp & bse_or_inf & fin_or_inf.
prp :< inf_or_prp.

; Since we've collapsed the entries for base and fin-non3rdsg verbs, we need to
; be able to unify e.g. the value PRESENT with the value BSE for examples like
; "Kim doesn't sleep", since the two verbs constrain a single event.  So we 
; adopt the hack of making the "tense" sort a subsort of BSE rather than 
; simply of *sort*.

tense :< bse_only.
present* :< tense.
past* :< tense.
future* :< tense.
presperf* :< tense.
pastperf* :< tense.

strict_tense :< tense.

present := present* & strict_tense.
past := past* & strict_tense.
future := future* & strict_tense.
presperf := presperf* & strict_tense.
pastperf := pastperf* & strict_tense.

pres+past := present* & past*.
pres+fut := present* & future*.
pres+prperf := present* & presperf*.
pres+pperf := present* & pastperf*.
past+fut := past* & future*.
past+prperf := past* & presperf*.
past+pperf := past* & pastperf*.
fut+prperf := future* & presperf*.
fut+pperf := future* & pastperf*.
prperf+pperf := presperf* & pastperf*.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

particle :< *avm*.

poss-able := *avm* &
  [ POSS bool ].

n_or_p :< head.
a_or_p :< head.
v_or_p :< head.
n_or_v :< head.
v_or_g_or_a :< head.
v_or_g :< v_or_g_or_a.

strict_head :< head.

func :< strict_head.

det := func & poss-able.

subst := head &
         [ PRD bool ].

nominal := subst &
  [ CASE case ].

verbal := subst & 
  [ VFORM vform ].

; mobile things can be extracted
mobile :< head.

; Adverbs modify adverbees.
adverbee :< subst.

adj* := particle & a_or_p & v_or_g_or_a & adverbee & mobile.

;;; AAC - SUBST is redundant - it is an ancestor of ADVERBEE 

prep* := particle & a_or_p & v_or_p & n_or_p & adverbee & mobile.

nsort :< *sort*.
proper* :< nsort.
common* :< nsort.

prop_and_com := proper* & common*.
proper :< proper*.
common :< common*.

supnoun := nominal & poss-able & mobile.

noun* := supnoun & n_or_v & n_or_p &
  [ NSORT nsort ].

gerund* := supnoun & adverbee & v_or_g.

; The following is only used in parse-nodes.tdl to distinguish lexical
; conjunctions from conjoined phrases.
conjh :< subst.

verb* := verbal & adverbee & v_or_p & v_or_g & n_or_v &
  [ AUX bool,
    INV bool,
    TENSE tense,
    VOICE voice,
    MOOD mood ].

comp* := nominal & verbal.

neg :< func.

adv := func & particle & mobile.

root-marker := subst & v_or_g_or_a & strict_head.

detspec :< func.

; Hack used in blocking unwanted affixes
no_head :< head.

; Types for punctuation and string boundaries.
punct :< strict_head.
left_edge :< punct.
right_edge :< punct.

; The idea is that any two heads (for now only major categories) can be
; unified in a conjunction, but the resulting type is a specific type that
; will not be subcategorized for, so the only way conjuncts of distinct
; types will satisfy a subcat is when the head does not mention the type.
; An example is the copula "be", as in "Kim is in Paris and happy."

v_and_n := verb* & noun*. 
v_and_a := verb* & adj*.
v_and_p := verb* & prep*.
v_and_g := verb* & gerund*.
n_and_a := noun* & adj*.
n_and_p := noun* & prep*.
;;n_and_g := noun* & gerund*.
a_and_p := adj* & prep*.
a_and_g := adj* & gerund*.

; AAC - verb_or_comp introduced because the template 
; vp has verbal & strict_head which must be specified as a single type
; in the LKB
verb_or_comp := strict_head & verbal.

; AAC - similarly for strict_nominal and strict_supnoun

strict_nominal := strict_head & nominal.

strict_supnoun := strict_nominal & supnoun.

; The following types are used to enable strict subcategorization (the usual 
; case)

verb := verb* & verb_or_comp.
noun := noun* & strict_supnoun.
prep := prep* & strict_head.
adj := adj* & strict_head.
comp := comp* & verb_or_comp.
gerund := gerund* & strict_supnoun.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  CONT values (MRS semantics)
;;
;; The basic semantic objects are all sub-types of thing.  Right now, the only
;; type of thing that has an internal structure is index, but that will
;; probably change.  For example, an event might have various times associated
;; with them or a handle may include a list of "subhandles" which are in its
;; scope.  Indices are classified in the familiar HPSG way.

expl-ind :< index.
it-ind := expl-ind &
  [ PNG [ PN 3sg*,
	  GEN neut* ] ].
there-ind :< expl-ind.
non_expl-ind := index & non_expl.
ref-ind :< non_expl-ind.
deg-ind :< non_expl-ind.

; The basic semantic structure, a CONT, is just something with a handle.
; Conts are further classified into mrss (i.e., things with liszts) and
; relations (i.e., things that go on liszts).  Conts are divided into psoas
; (with a distinguished event) and nom-objs (with a distinguished index).
; We use a polymorphic attribute name INDEX for both of these, to simplify
; manipulation of these objects; for example, modifying PPs assign as their
; ARG's value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  Similarly useful
; for coordination.

; ERB (03-10-96) 
; The intermediate types ques_prop_msg and prop_com_msg represent the
; natural classes needed for selection by know, announce, care, check,
; etc. and the analysis of THAT (see lextypes.tdl) and the 
; forthcoming analysis of tags on imperatives, respectively.

psoa := mrs &
  [ INDEX event ].

nom-obj := mrs &
  [ INDEX index ].

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; Since some temporal nouns can be either arguments or VP modifiers, their 
; rel's INST value (coindexed with INDEX of the containing MRS) must remain 
; unspecified for type.  Consider "Kim arrived Tuesday" vs. "Tuesday comes
; after Monday"; in the first, Tuesday must have an EVENT index, while in the
; second, it must have a REF-IND index.

; ERB (24-10-96) Here is the series of relations that will be used for
; questions, etc.  Cf. Gizburg & Sag.
; ERB (12-05-96) Moved the ne_rel here.

message := norm_relation &
  [ SOA handle ].
imp_rel :< message.
prop_ques_rel :< message.          ;for COMPS of e.g. 'know'
propositional_rel :< prop_ques_rel.
prpstn_rel :< propositional_rel.   ;propositions
hypo_rel :< propositional_rel.     ;hypotheticals (PRO to go)

; For interrogatives; PARAMS value is a set of handles.
int_rel := prop_ques_rel &         
  [ PARAMS *diff-list* ].       

; Subtype of int_rel for tag questions.   
ne_rel :< int_rel.                 

dim_rel := norm_relation &
  [ DIM non_expl-ind ].

quant_or_wh_rel := dim_rel &
  [ BV ref-ind,
    RESTR handle ].

quant_rel := quant_or_wh_rel & 
  [ SCOPE handle ].

udef_rel :< quant_rel.
some_rel :< quant_rel.
def_rel :< quant_rel.
demonstrative_rel :< quant_rel.
demon_near_rel :< demonstrative_rel.
demon_far_rel :< demonstrative_rel.

;which_rel should not have a scope, but given for the moment to satisfy VIT
;which_rel :< quant_or_wh_rel.
which_rel :< quant_rel.

; Nominal sorts used for VM2

nominal-sort :< *sort*.
entity :< nominal-sort.
time :< nominal-sort.
info_bearer :< nominal-sort.
nongeo_location :< nominal-sort.

; nondim_rel is used to determine whether the specifier that combines with its
; head provides the semantics (nonhead-compositional) or whether the head does:
; nondim_rel entries are head-compositional.

nondim_rel :< norm_relation.

; AAC - fix for ARG3 introduction

aac_arg3_rel := nondim_rel &
  [ ARG3 thing ].

; Nominal relations

basic_nom_rel := norm_relation &
  [ INST individual ].

nom_rel := basic_nom_rel &
  [ INST non_expl-ind ].

nom_nondim_rel := nom_rel & nondim_rel.
non_temp_nom_rel :< nom_nondim_rel.
reg_nom_rel :< non_temp_nom_rel.

diadic_nom_rel := nom_nondim_rel &
  [ NPREP thing ].

diadic_nom_rel_vit := diadic_nom_rel & aac_arg3_rel &
  [ NPREP #arg3,
    ARG3 #arg3 ].

reg_diadic_nom_rel := diadic_nom_rel_vit & reg_nom_rel.

;;;  NONDIM_REL is redundant - it is an ancestor of AAC_ARG3_REL

hcomp_nom_rel := nom_rel & aac_arg3_rel & 
  [ NOMARG handle & #arg3,
    ARG3 #arg3 ].

; part_of_rel := diadic_nom_rel &
;  [ SET handle ].

part_of_rel :< diadic_nom_rel_vit.

nominalize_rel :< diadic_nom_rel_vit.

gerund_rel := diadic_nom_rel_vit & hcomp_nom_rel.

temp_rel := nom_rel &
  [ INST.SORT time ].

temp_nondim_rel := temp_rel & nondim_rel.

day_rel :< temp_nondim_rel.

named_day_rel := day_rel &
  [ DAY atom ].

non_day_rel :< temp_nondim_rel.

;; day_of_month_rel
dofm_rel := named_day_rel & diadic_nom_rel &
  [ DAY string,
    NPREP non_expl-ind ].

;; only for VIT
dofm_aux_rel :< diadic_nom_rel_vit.

;; day_of_week_rel
dofw_rel := named_day_rel &
  [ DAY symbol ].

holiday_rel := named_day_rel &
  [ DAY symbol ].

day_part_rel := day_rel &
  [ OF-DAY non_expl-ind ].

; dim_rel: 'almost three o'clock'
hour_rel := temp_rel & dim_rel.

; a quarter till three  ("till" is head - cf "come at a quarter till.")
hour_prep_rel := hour_rel &
  [ HOUR-IND individual,
    MINUTE-IND individual ].

numbered_hour_rel := hour_rel &
  [ INST.PNG [ PN 3sg*,
	       GEN neut* ],
    HOUR string,
    MIN non_expl-ind,
    AM-PM non_expl-ind ].

minute_rel := temp_nondim_rel &
  [ MINUTE string ].

am_pm_rel :< temp_nondim_rel.
am_rel :< am_pm_rel.
pm_rel :< am_pm_rel.

; 'the morning', not 'some morning': 'in the morning' but 'on some morning'
def_day_part_rel :< non_day_rel.

non_day_diadic_rel := non_day_rel & diadic_nom_rel.

;; named_month_rel
mofy_rel := non_day_diadic_rel &
  [ MONTH symbol,
    YEAR-IND non_expl-ind ].

yofc_rel := non_day_rel &
  [ YEAR string ].

season_rel := non_day_rel &
  [ SEASON symbol ].

age_rel :< non_day_rel.

_morning_rel :< day_part_rel.
_afternoon_rel :< day_part_rel.
_evening_rel :< day_part_rel.
_night_rel :< day_part_rel.
_weekday_rel :< dofw_rel.
_weekend_rel :< dofw_rel.
_workday_rel :< dofw_rel.

_week_rel :< non_day_diadic_rel.
_fortnight_rel :< non_day_rel.
_month_rel :< non_day_diadic_rel.
_moment_rel :< non_day_rel.


named_rel := reg_nom_rel &
  [ NAMED symbol ].

excl_rel := nondim_rel &
  [ EXCL symbol ].

greet_rel :< excl_rel.

; Pronouns
pron_rel := non_temp_nom_rel &
  [ INST ref-ind ].

refl_pro_rel := pron_rel &
  [ INST.PRONTYPE refl ].

recip_pro_rel := reg_nom_rel &
  [ INST.PRONTYPE recip ].

basic_adj_rel :< dim_rel.

adj_rel := basic_adj_rel &
  [ NARG individual ].

varg_rel := relation &
  [ VARG thing ].

preparg_rel := relation &
  [ PREPARG individual ].

expr_rel := relation &
  [ EXPR individual ].

#|
adj_varg_rel := adj_rel & varg_rel &
  [ VARG handle ].

adj_varg_expr_rel := adj_varg_rel & expr_rel.
it_adj_varg_expr_rel := basic_adj_rel & varg_rel & expr_rel.
|#

basic_adj_varg_rel := basic_adj_rel & varg_rel.
adj_varg_rel := basic_adj_varg_rel & adj_rel &
  [ VARG handle ].
it_adj_varg_expr_rel := basic_adj_varg_rel & expr_rel.
adj_varg_expr_rel := adj_varg_rel & expr_rel.

adj_preparg_rel := adj_rel & preparg_rel.

meas_adj_rel := adj_rel &
  [ UNIT ref-ind ].

temp_span_rel :< meas_adj_rel.

adj_personal_rel :< adj_rel.
adj_abstract_rel :< adj_rel.

verb_aspect_rel :< norm_relation.
event_arg_rel :< verb_aspect_rel.

prog_rel :< verb_aspect_rel.

event_rel := event_arg_rel & nondim_rel &
  [ EVENT event ].

mod_role_rel :< event_rel.

no_role_rel :< mod_role_rel. 
; E.g., weather verbs

role_rel :< mod_role_rel.

arg_rel := event_arg_rel &
	   [ ARG thing ].

irrealis_rel :< arg_rel.
_going_to_rel :< arg_rel.

; Used to ensure tag question agreement, but will not appear in LISZT.
will_rel :< arg_rel.
have_aux_rel :< arg_rel.

support_rel :< event_rel.

support_main_rel := support_rel & mod_role_rel.

;;; AAC - added support_expr_rel

support_expr_rel := support_main_rel & expr_rel.

abstr_rel :< arg_rel.

; AAC - added for frag
abstr_e_rel :< event_rel.

; AAC - added for frag-msg
abstr_3_rel := basic_nom_rel & aac_arg3_rel.

; AAC - added for wh_adjective_word
abstr_nom_rel := arg_rel & basic_nom_rel.

act_rel := role_rel &
	   [ ACT individual ].
und_rel := role_rel &
           [ UND thing ].
act_und_rel := act_rel & und_rel.
und_only_rel :< und_rel.
;;; AAC - added to cope with prpstn_to_prop_rel
over_prop_rel := norm_relation &
	   [ PROP non_expl ].
prop_rel := over_prop_rel & role_rel &
	   [ PROP event ].
act_prop_rel := act_rel & prop_rel.

thm_rel := role_rel &
	   [ THM thing ].

thm_expr_rel := thm_rel & expr_rel.

; Not currently used
;grd_rel := role_rel &
;	   [ GRD individual ].
;
;dest_rel := role_rel &
;	   [ DEST individual ].
;
;act_dest_rel := act_rel & dest_rel.
;
;effect_rel := role_rel &
;	      [ EFFECT event ].
;
;path_rel := role_rel &
;	    [ PATH event ].

poss_rel := nondim_rel &
  [ POSSR non_expl-ind,
    POSSD non_expl-ind ].

_got_poss_rel :< poss_rel.

fig_gnd_rel := role_rel &
  [ FIG thing,
    GND non_expl-ind ].

act_fig_gnd_rel := fig_gnd_rel & act_rel.
fig_gnd_und_rel := fig_gnd_rel & und_rel.


; Preposition relations

prep_rel := dim_rel &
  [ PREP individual ].	    

prep_mod_rel := prep_rel & arg_rel.

loc_rel :< prep_mod_rel.
dir_rel :< loc_rel.
state_loc_rel :< loc_rel.
dir_or_state_rel := dir_rel & state_loc_rel.

temp_loc_rel :< loc_rel.

miscprep_rel :< prep_mod_rel.

;;; AAC - adv_rel also may have DIM

adv_rel := arg_rel & dim_rel.

neg_rel :< arg_rel.

neg_polar_rel :< adv_rel.

; Degree relations

degree_rel := norm_relation &
  [ DARG thing ].

comp_degree_rel :< degree_rel.
non_comp_degree_rel :< degree_rel.

; For specifiers of adjectives
deg_rel := non_comp_degree_rel & dim_rel.

; For specifiers of positive adjectives
very_deg_rel :< deg_rel.

; For specifiers of comparative adjectives
much_deg_rel :< deg_rel.

; For specifiers of either positives or comparatives
very_or_much_rel := very_deg_rel & much_deg_rel.

comparative_rel := comp_degree_rel &
  [ ARG-1 index,
    C-INST index ].

comp_more_less_rel := comparative_rel &
  [ ARG-2 index ].
more_sc_adv_rel :< comp_more_less_rel.
comp_less_rel :< comp_more_less_rel.

comp_most_least_rel := comparative_rel & 
  [ C-SET handle ].

comp_most_rel :< comp_most_least_rel.
comp_least_rel :< comp_most_least_rel.

#|
; This should probably be separated into two relations in the relevant
; lexical types, leaving the quant_rel with only its usual attributes.
comp_q_rel := quant_rel &
  [ ARG-1 #index,
    CQ-ARG-2 index,
    BV #index,
    CQ-INST index ].
|#

;; For "how" adjective, which quantifies over properties.

property_rel :< reg_nom_rel.

;;; AAC - uses PROP so has to inherit from prop_rel
;;; but can't because prop_rel assumes EVENT, so make 
;;; a new type - over_prop_rel which makes PROP take non_expl

prpstn_to_prop_rel := over_prop_rel &
  [ PRPSTN handle,
    PROP non_expl-ind ].

act_prep_rel := act_rel & preparg_rel.


act_und_thm_rel := act_und_rel & thm_rel.
act_und_prep_rel := act_prep_rel & act_und_rel.
act_und_thm_prep_rel := act_und_thm_rel & act_und_prep_rel.

transfer_rel :< act_rel.
transfer_obj_rel := transfer_rel & act_und_rel.
transfer_dative_rel := transfer_obj_rel & act_und_prep_rel.
double_np_rel := act_und_thm_rel &
  [ THM individual ].
dative_to_rel :< transfer_dative_rel.

; bet
act_und_thm_prop_rel := act_und_thm_rel & prop_rel.

_to_rel :< dir_rel.
_for_rel :< miscprep_rel.
_by_rel :< miscprep_rel.
_by_pass_rel :< miscprep_rel.
_of_rel :< prep_mod_rel.
_in_rel :< dir_or_state_rel.
until_rel :< prep_mod_rel.

subord_rel := nondim_rel &
  [ MAIN handle,
    SUBORD handle ].

arg1_rel := role_rel &
  [ ARG1 thing ].
arg2_rel := role_rel &
  [ ARG2 thing ].
arg3_rel := role_rel & aac_arg3_rel &
  [ ARG3 thing ].

vit_a_1 := act_rel & arg1_rel &
  [ ACT #act,
    ARG1 #act ].
vit_a_2 := act_rel & arg2_rel &
  [ ACT #act,
    ARG2 #act ].
vit_a_3 := act_rel & arg3_rel &
  [ ACT #act,
    ARG3 #act ].
vit_u_1 := und_rel & arg1_rel &
  [ UND #und,
    ARG1 #und ].
vit_u_2 := und_rel & arg2_rel &
  [ UND #und,
    ARG2 #und ].
vit_u_3 := und_rel & arg3_rel &
  [ UND #und,
    ARG3 #und ].
vit_t_2 := thm_rel & arg2_rel &
  [ THM #thm,
    ARG2 #thm ].
vit_t_3 := thm_rel & arg3_rel &
  [ THM #thm,
    ARG3 #thm ].
vit_pa_2 := act_prep_rel & arg2_rel &
  [ PREPARG #prep,
    ARG2 #prep ].
vit_pa_3 := act_prep_rel & arg3_rel &
  [ PREPARG #prep,
    ARG3 #prep ].
vit_g_1 := fig_gnd_rel & arg1_rel &
  [ GND #gnd,
    ARG1 #gnd ].
vit_g_2 := fig_gnd_rel & arg2_rel &
  [ GND #gnd,
    ARG2 #gnd ].
vit_g_3 := fig_gnd_rel & arg3_rel &
  [ GND #gnd,
    ARG3 #gnd ].
vit_f_2 := fig_gnd_rel & arg2_rel &
  [ FIG #fig,
    ARG2 #fig ].
vit_f_3 := fig_gnd_rel & arg3_rel &
  [ FIG #fig,
    ARG3 #fig ].
vit_arg_3 := varg_rel & arg3_rel &
  [ VARG #arg,
    ARG3 #arg ].
vit_arg := varg_rel & arg_rel &
  [ VARG #arg,
    ARG #arg ].
vit_parg := preparg_rel & arg_rel &
  [ PREPARG #arg,
    ARG #arg ].
;;; AAC - has to inherit from arg2_rel
vit_expr_2 := expr_rel & arg2_rel &
  [ EXPR #expr,
    ARG2 #expr ].

vit_fg_31 := vit_f_3 & vit_g_1.
vit_fg_32 := vit_f_3 & vit_g_2.
vit_fg_23 := vit_f_2 & vit_g_3.

vit_au_13 := vit_a_1 & vit_u_3.
vit_au_12 := vit_a_1 & vit_u_2.
vit_au_23 := vit_a_2 & vit_u_3.
vit_au_32 := vit_a_3 & vit_u_2.
vit_ap_12 := vit_a_1 & vit_pa_2.
vit_ap_13 := vit_a_1 & vit_pa_3.
vit_ap_32 := vit_a_3 & vit_pa_2.
vit_ap_23 := vit_a_2 & vit_pa_3.
vit_aup_123 := vit_au_13 & vit_pa_2.
vit_aup_132 := vit_au_12 & vit_pa_3.
vit_aut_123 := vit_au_12 & vit_t_3.
vit_aut_132 := vit_au_13 & vit_t_2.
vit_autp_123 := vit_au_13 & vit_t_2 & vit_pa_2.
vit_afg_123 := vit_a_1 & vit_fg_23.
vit_afg_132 := vit_a_1 & vit_fg_32.
vit_expr_arg_23 := vit_expr_2 & vit_arg_3.
act_rel_a_1 :< vit_a_1.
act_rel_a_3 :< vit_a_3.
und_only_rel_u_3 := und_only_rel & vit_u_3.
und_only_rel_u_1 := und_only_rel & vit_u_1.
act_und_rel_au_13 := act_und_rel & vit_au_13.
act_und_rel_au_12 := act_und_rel & vit_au_12.
act_und_rel_au_23 := act_und_rel & vit_au_23.
act_und_rel_au_32 := act_und_rel & vit_au_32.
act_prep_rel_ap_13 :< vit_ap_13.
act_prep_rel_ap_12 :< vit_ap_12.
act_prep_rel_ap_32 :< vit_ap_32.
act_prep_rel_ap_23 :< vit_ap_23.
fig_gnd_rel_fg_31 :< vit_fg_31.
fig_gnd_rel_fg_32 :< vit_fg_32.
act_und_prep_rel_aup_123 := act_und_prep_rel & vit_aup_123.
act_und_prep_rel_aup_132 := act_und_prep_rel & vit_aup_132.
act_und_thm_rel_aut_123 := act_und_thm_rel & vit_aut_123.
act_und_thm_rel_aut_132 := act_und_thm_rel & vit_aut_132.
act_fig_gnd_rel_afg_132 := act_fig_gnd_rel & vit_afg_132.
act_fig_gnd_rel_afg_123 := act_fig_gnd_rel & vit_afg_123.
act_und_thm_prep_rel_autp_123 := act_und_thm_prep_rel & vit_autp_123.
support_main_rel_arg_3 := support_main_rel & vit_arg_3.
support_expr_rel_arg_23 := support_expr_rel & vit_expr_arg_23.
support_rel_arg := support_rel & vit_arg.
adj_varg_expr_rel_arg := adj_varg_expr_rel & vit_arg.
it_adj_varg_expr_rel_arg := it_adj_varg_expr_rel & vit_arg.
adj_preparg_rel_arg := adj_preparg_rel & vit_parg.

;; Relations needed in lexical types

_equal_adj_rel :< adj_preparg_rel_arg.

;; Relations needed for VIT conversion

abstr_apply := arg_rel &
  [ PROPERTY index ].

; Discourse functions

; ERB (03-10-96) In order to capture the similarities and differences
; between embedded and matrix questions, I am decomposing the ynq_rel
; into polar_q_rel and request_ans_rel.  The latter is probably 
; equivalent to the ne_rel (see below), but ne_rel is too cute to
; forgo for the tag questions and probably too opaque for the 
; matrix yn questions, so I will keep the two for now.  NB polar_q_rel
; probably doesn't qualify as 'discourse function'.  

; So, the ynq_root construction will contribute a polar_q_rel and
; a request_ans_rel, whether will contribute a polar_q_rel, and
; matrix wh questions will contribute a request_ans_rel.

polar_q_rel :< arg_rel.
request_ans_rel :< arg_rel.

polite_rel :< arg_rel.

_dont_rel :< imp_rel.
_lets_rel :< imp_rel.
_how_about_rel :< int_rel.
_whatabout_rel :< int_rel.
_what_do_you_say_rel :< int_rel.
_what_if_rel :< int_rel.

; Phrasally introduced relations

unspec_rel := nondim_rel &
  [ HINST index,
    NHINST index ].

; Relation introduced for tag questions

probable_rel :< adj_rel.

conj_rel := nondim_rel &
  [ C-ARG individual,
    C-HANDELS *diff-list*,
    C-INDICES *diff-list* ].

; Abstract relations specified by more than one lexical entry

airplane_rel :< reg_nom_rel.
place_rel :< reg_nom_rel.
telephone_rel :< reg_nom_rel.
person_rel :< reg_nom_rel.
nonperson_rel :< reg_nom_rel.
next_prev_rel :< adj_rel.
manner_rel :< reg_nom_rel.
reason_rel :< reg_nom_rel.

ord_rel := adj_rel &
  [ ORD string ].

title_rel :< basic_nom_rel.

cop_id_rel := arg1_rel & arg3_rel &
	      [ ID1 non_expl-ind & #id1,
		ID2 non_expl-ind & #id2,
		ARG1 #id1,
		ARG3 #id2 ].

_there_cop_rel := event_rel & varg_rel & aac_arg3_rel &
  [ ARG3 non_expl-ind & #arg,
    VARG #arg ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Number relations

number_rel := dim_rel & 
  [ XARG individual ].

integer_rel := number_rel &
  [ I-ORD bool ].
const_rel := integer_rel & [ CONST_VALUE string].
plus_rel := integer_rel & [ TERM1 handle,
			    TERM2 handle].
times_rel := integer_rel & [ FACTOR1 handle,
			     FACTOR2 handle].

;; TYPES/SORTS
;; The ORDINAL feature determines whether its bearer is ordinal or not 
;; (i.e., is ordinal or cardinal).  Thus it is only appropriate for
;; numbers.  All numbers have a HEAD value of sort intsort, those
;; used adjectivally have heads of sort intadj (or one of its 
;; subsorts) or intdet (which has no subsorts).  Nominal uses are
;; not yet supported.
;;
;; Subcategorization, which is in terms of the maximum number of digits
;; allowed for the complement or specifier, is handled by the subsorts
;; of the digitn hierarchy.  Currently, only adjectives participate in
;; this hierarchy; there is only a single integer determiner ("one").
;; Nominal uses could be added by adding a type
;;          intnoun := intsort & digitn & noun.


intsort := head & [ORDINAL bool].

digitn :< head.

digit9 :< digitn.
digit6 :< digit9.
digit3 :< digit6.
digit2 :< digit3.
digit1 :< digit2.

; The sorts    digitk    specify the number of digits of a lexeme 
; together with its largest complement and specifier.
; The sorts    digitk-    are used for subcategorization; they include
; values of k or fewer digits.
 
digit9- :< digitn.
digit6- :< digit9-.
digit3- :< digit6-.
digit2- :< digit3-.
digit1- :< digit2-.

;digit1 :< digit1-.
;digit2 :< digit2-.
;digit3 :< digit3-.
;digit6 :< digit6-.
;digit9 :< digit9-.

intadj  := intsort & adj.
intadjn := intadj & digitn.
intdet  := intsort & det.

; intadj1- := intadj1.
; intadjk- means an integer adjective of at most k digits (when
;   combined with specifier and complement

intadj9- :< intadj.
intadj9  := intadj9- & digit9.
intadj6- :< intadj9-.
intadj6  := intadj6- & digit6.
intadj3- :< intadj6-.
intadj3  := intadj3- & digit3.
intadj2- :< intadj3-.
intadj2  := intadj2- & digit2.
intadj1  := intadj2- & digit1.

;;;;;;;;Extra stuff

; ERB (13-12-97) This type is meant as a PRO -- i.e., what can show
; up in such things as the 'way' construction and embedded infinitival
; wh questions.  It should eventually receive some binding properties,
; but I don't know what to put there yet, and since we don't have
; a binding theory...

; ERB (14-12-97) I am adding the pron_rel to pro_ss, so that in the
; types like common_noun_vpcomp_synsem I don't have to put it in.  I
; can just take the KEY.

; ERB (14-12-97) No pron_rel for pro_ss.

; ERB (14-12-97) ... and pro_ss is accusative, to block (once I get
; infinitival relatives working) *A person left came in.

; ERB (14-12-97) This is moved here so as to be after acc, which is a 
; *sort* and thus can't handle being referenced before it is defined.

; ERB (19-01-98) PRO is obligatorially OPT -.  This keeps to_c_prop
; from serving as a modifier without first building a non_wh_rel,
; because hadj requires SUBJ *olist*.

; ERB (21-01-98) In order for PRO to be extractable, it can't be
; SLASH 0-dlist, and thus can't be a subtype of unexpressed.  With
; PRO underspecified for SLASH, something will always have to fill
; in that value.  In the case of subject non_wh_rels (e.g., 
; "Kim found a person to fix the sink") it is extracted, i.e., resolved
; to gappro by extrasubj.  In the cases where the PRO is the subject of
; a selected complement, the selector will impose SLASH 0-dlist on the
; PRO (this case includes equi constructions, embedded infinitival
; wh questions, and the complement of 'way' as in "Kim found a way
; to leave early").  In the case of the (as yet unimplemented) CP[to]
; subjects, the NP -> CP rule will probably do the work.  Alternatively,
; the selecting category could do it.  Finally, in the case of
; non-subject non_wh_rels (e.g., "Kim found a cheeseburger to devour"),
; the PRO must be SLASH 0-dlist because the non_wh_rel_rule limits
; the SLASH list to length one.
;
; On a related note, we want the distribution of gappro (i.e., of
; extracted PRO) to be quite constrained, and perhaps even limited
; to the subject non_wh_rels.  In general, we are relying on the
; restriction of SLASH to lists of length one stated in several places
; in the grammar, in addition to certain selecting categories' specifying
; an empty value for SLASH on the PROs in their complements' subjects
; to keep us from getting in trouble on this one.
;
; Finally, rather than make a subtype of pro_ss that says SLASH 0-dlist,
; I have opted to include that information on the type *prolist*.

; ERB (03-23-98) We need a way to identify indices introduced by a PRO
; that are "discourse bound".  We were using PRONTYPE for this, but
; of course that doesn't work when the controller of the PRO is an overt
; pronoun.  So the new strategy is to make the INDEX a non_expl.
; This will unify with the indices introduced by (appropriate) controllers,
; and (hopefully) be identifiable if it is not controlled.

; pro_ss used to have CONT.ECONT.LISZT <! !> but this runs afoul of its use
; in wh_filler_head constructions such as "how does the seventeenth seem"
; where "the seventeenth" is unified with the SUBJ of "how", but has a non-empty
; ECONT.LISZT.

pro_ss := non_canonical &
  [ LOCAL.CAT.HEAD.CASE acc,
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist ],
    OPT - ].

; ERB (19-01-98) We need a subtype of pro and gap so that to_c_prop
; can undergo subject extraction.  See the notes near non_wh_rel in
; syntax.tdl for the details of the analysis.
; I am positive that this will break something, but I could not
; guess what.

gappro := pro_ss & gap.
