;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-2002
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  fundamentals.tdl
;;;
;;;  Basic definitions of types for English grammar
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Basic types

*sort* :< *top*.

atom :< *sort*.

*avm* :< *top*.

*list* :< *avm*.

*cons* := *list* &
  [ FIRST *top*,
    REST *top* ].

0-1-list :< *list*.
1-list := 0-1-list & *cons* &
  [ REST *null* ].
*null* :< 0-1-list.
1-plus-list := *cons* &
  [ REST *cons* ].

*diff-list* := *avm* &
[ LIST *list*,
  LAST *list* ].

symbol :< atom.

integer :< atom.

string := symbol.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

; Person and number represented as atomic sorts, with gender a separate attrib
; relevant for 3sg, and where count/mass distinction only for 3sg neuter.

pernum :< *sort*.
1or3sg :< pernum.
non3sg :< pernum.
non1sg :< non3sg.
2per :< non1sg.
1or3pl :< non1sg.
1per := 1or3sg & non3sg.
1per+non1sg := 1per & non1sg.

1sg* :< 1per.
1pl* :< 1or3pl.
2sg* :< 2per.
2pl* :< 2per.
3pl* :< 1or3pl.
3sg* :< 1or3sg.

1per+3sg* := 1per & 3sg*.
1or3pl+1per+non1sg := 1or3pl & 1per+non1sg.
1sg*+1per+non1sg := 1or3pl+1per+non1sg.
3sg*+1per+non1sg := 1per+3sg* & 1per+non1sg.
2per+1per+non1sg := 2per & 1per+non1sg.
2sg*+2per+1per+non1sg := 2sg* & 2per+1per+non1sg.
2pl*+2per+1per+non1sg := 2pl* & 2per+1per+non1sg.
2per+3sg*+1per+non1sg := 3sg*+1per+non1sg & 2per+1per+non1sg.
1or3pl+3sg*+1per+non1sg := 3sg*+1per+non1sg & 1or3pl+1per+non1sg.
1sg*+1or3pl+1per+non1sg := 1sg*+1per+non1sg.
1pl*+1or3pl+1per+non1sg := 1pl* & 1or3pl+1per+non1sg.
3pl*+1or3pl+1per+non1sg := 3pl* & 1or3pl+1per+non1sg.
2per+1or3pl := 2per & 1or3pl.
1or3pl+2per+1per+non1sg := 2per+1per+non1sg & 1or3pl+1per+non1sg & 2per+1or3pl.
1sg*+2per+1per+non1sg := 1sg*+1per+non1sg & 1or3pl+2per+1per+non1sg.
1sg*+2per+1per+1or2pl+non1sg := 1sg*+2per+1per+non1sg.
1pl*+1or3pl := 1pl* & 2per+1or3pl.
2sg*+1or3pl := 2sg* & 2per+1or3pl.
2pl*+1or3pl := 2pl* & 2per+1or3pl.
3pl*+1or3pl := 3pl* & 2per+1or3pl.

1sg_and_1pl := 1sg*+1or3pl+1per+non1sg & 1pl*+1or3pl+1per+non1sg.
1sg_and_2per := 1sg*+2per+1per+non1sg.
1sg_and_2sg := 1sg*+2per+1per+1or2pl+non1sg & 2sg*+2per+1per+non1sg & 
               2sg*+1or3pl.
1sg_and_2pl := 1sg*+2per+1per+1or2pl+non1sg & 2pl*+2per+1per+non1sg & 
               2pl*+1or3pl.
1sg_and_3pl := 1sg*+1or3pl+1per+non1sg & 3pl*+1or3pl+1per+non1sg.
1sg_and_3sg := 1sg* & 1per+3sg*.
1pl_and_2per := 1pl*+1or3pl.
1pl_and_2sg := 1pl*+1or3pl & 2sg*+1or3pl.
1pl_and_2pl := 1pl*+1or3pl & 2pl*+1or3pl.
1pl_and_3pl := 1pl* & 3pl*.
1pl_and_3sg := 1pl*+1or3pl+1per+non1sg & 1or3pl+3sg*+1per+non1sg.
2per_and_3pl := 3pl*+1or3pl.
2per_and_3sg := 2per+3sg*+1per+non1sg.
2sg_and_2pl := 2sg* & 2pl*.
2sg_and_3pl := 2sg*+1or3pl & 3pl*+1or3pl.
2sg_and_3sg := 2sg*+2per+1per+non1sg & 2per+3sg*+1per+non1sg.
2pl_and_3pl := 2pl*+1or3pl & 3pl*+1or3pl.
2pl_and_3sg := 2pl*+2per+1per+non1sg & 2per+3sg*+1per+non1sg.
3pl_and_3sg := 1or3pl+3sg*+1per+non1sg & 3pl*+1or3pl+1per+non1sg.



strict_sort :< *sort*.

;; GLBs
strict_pernum := pernum & strict_sort.
strict_1or3sg := 1or3sg & strict_pernum.
strict_non3sg := non3sg & strict_pernum.
strict_non1sg := non1sg & strict_non3sg.
strict_1or3pl := 1or3pl & strict_non1sg.
strict_2per := 2per & strict_non1sg.

1sg := 1sg* & strict_1or3sg & strict_non3sg.
1pl := 1pl* & strict_1or3pl.
2sg := 2sg* & strict_2per.
2pl := 2pl* & strict_2per.
3sg := 3sg* & strict_1or3sg.
3pl := 3pl* & strict_1or3pl.

gender :< *sort*.
real_gender :< gender.
masc* :< real_gender.
fem* :< real_gender.
neut* :< real_gender.
andro* :< real_gender.
andro1* :< real_gender.

masc_and_fem := masc* & fem*.
masc_and_neut := masc* & neut*.
masc_and_andro := masc* & andro*.
fem_and_neut := fem* & neut*.
fem_and_andro := fem* & andro*.
neut_and_andro := neut* & andro*.

strict_gender := gender & strict_sort.
masc := masc* & strict_gender.
fem := fem* & strict_gender.
neut := neut* & strict_gender.
andro := andro* & strict_gender.
andro1 := andro1* & strict_gender.
; The following two are used in tag questions to block mismatched expletive
; pronouns in main clause and tag, since we can't block on unified index
; values, since in general tag questions introduce a pronoun which must have
; a unique index bound by the quantifier it (now) introduces lexically.
no_gend_it := strict_gender.
no_gend_there := strict_gender.

png := *avm* & 
  [ PN pernum,
    GEN gender ].

; ERB declarative and interrogative seem to form a natural class
; in that 'know', 'guess', 'suspect' ... take either.  The type
; decl_int is meant to reflect this.  
; ERB (23-07-96) declarative and imperative also form a class 
; with respect to tag questions.  The type decl_imp is meant to
; reflect this.

cl_mode :< *sort*.
no_cl_mode :< cl_mode.
relative :< cl_mode.
decl_int :< cl_mode.
decl_imp :< cl_mode.
declarative := decl_int & decl_imp.
interrogative :< decl_int.
imperative :< decl_imp.


voice :< *sort*.
active :< voice.
passive :< voice.
act+pass := active & passive.

mood :< *sort*.
ind_or_mod_subj :< mood.

indicative* :< ind_or_mod_subj.
modal_subj* :< ind_or_mod_subj.
subjunctive* :< mood.

strict_ind_or_mod_subj := ind_or_mod_subj & strict_sort.

indicative := indicative* & strict_ind_or_mod_subj.
modal_subj := modal_subj* & strict_ind_or_mod_subj.
subjunctive := subjunctive* & strict_sort.

ind+modsubj := indicative* & modal_subj*.

prontype :< *sort*.
std_pron :< prontype.
std_1sg :< std_pron.
std_1pl :< std_pron.
std_2 :< std_pron.
std_3 :< std_pron.
recip :< prontype.
refl :< prontype.
impers :< prontype.
demon :< prontype.
zero_pron :< prontype.
not_pron :< prontype.

; Three-valued sort evoking Polish logician Jan Lukasiewicz
luk :< *sort*.
; NA for Not Applicable.  
na_or_+ :< luk.
na_or_- :< luk.

na := na_or_+ & na_or_-.
bool :< luk.
+* := bool & na_or_+.
-* := bool & na_or_-.

; To enable coordination of unlike values, we add the intermediate types +* and
; -+, along with the conjoined type.

+_and_- := +* & -*.
strict_bool := bool & strict_sort.
+ := +* & strict_bool.
- := -* & strict_bool.

; Three-valued sort for distinguishing unmodified signs from both left-modified
; and right-modified signs
; PERIPH indicates whether this modifier is left- or right-peripheral in its
; phrase - e.g., "the IBM temporary employees" but "*the IBM five employees"

xmod := *sort* &
  [ PERIPH luk ].
notmod_or_rmod :< xmod.
notmod_or_lmod :< xmod.
notmod := notmod_or_rmod & notmod_or_lmod.

hasmod :< xmod.
lmod* := hasmod & notmod_or_lmod.
rmod* := hasmod & notmod_or_rmod.

lmod := lmod* & strict_sort.
rmod := rmod* & strict_sort.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subtypes of *diff-list*

;; Experimental use of subtypes of *diff-list* to enforce constraint of at
;; most one element in SLASH (for efficiency, "violin/sonnet" examples
;; notwithstanding).  Will only have effect in LKB version which does the
;; necessary type inference.

0-1-dlist := *diff-list* &
  [ LIST 0-1-list ].
0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].
1-dlist := 0-1-dlist &
  [ LIST 1-list &
	 [ REST #rest & *null* ],
    LAST #rest ].
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Top-level feature geometry
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mod_local :< *avm*.

; The MOD value specifies the type of phrase that a sign can modify, and the
; POSTHEAD value stipulates the relative position of the modifier with
; respect to the head.  (An earlier approach employing a generalization about
; a head being final in its phrase or not might still be considered as an
; alternate to this stipulative one.)
; The POSTHEAD feature should stay with MOD, since only relevant when MOD is
; non-empty.

; DPF 09-Jan-99 - Changed value of MOD to be of type synsem rather than type
; local, since some modifiers (like vocative NPs) only modify SLASH-empty
; phrases, which means they have to have access to the NON-LOCAL feature of
; the phrase they modify.

head_min :< *avm*.

; DPF 16-Aug-99 - Added INV to head type, since need to distinguish root
; from non-root phrases as output from parser, and since inverted S's now have
; MESSAGE empty, we have to require all non-root fragments to be INV -.

head := head_min &
  [ MOD *list*,
    PRD bool,
    INV bool,
    AUX luk,
    TAM tam].

valence_min :< *avm*.

valence := valence_min &
  [ SUBJ *list*,
    SPR *list*,
    COMPS *list*,
    SPEC *list*,
    --KEYCOMP *avm* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT type

mod-thing :< *avm*.
nothing :< mod-thing.

instloc :< *top*.
thing := mod-thing &
  [ INSTLOC instloc ].

handle :< thing.
individual := thing &
 [ DIVISIBLE bool,
   SORT *sort* ].

eventtime :< thing.

; Needed for VITs
hole :< thing.

; DIVISIBLE distinguishes singular count nouns from plural and mass nouns,
; for determiners like "some", and for bare-plural NPs.

index := individual &
  [ PNG png ].
    
; Moved SORT to individual, since need to allow constraint to affect events too
full_index := index &
  [ PRONTYPE prontype ].

; This is the type of the index of the phrase modified by predicative PPs, which
; can either modify a ref-ind nominal or an event VP.

non_expl :< individual.

event_or_index :< non_expl.

tense :< *sort*.
aspect :< *sort*.

real_tense :< tense.
nonpast :< real_tense.
present* :< nonpast.
past* :< real_tense.
future* :< nonpast.
no_tense :< tense.

strict_tense := tense & strict_sort.
present := present* & strict_tense.
past := past* & strict_tense.
future := future* & strict_tense.
pres+past := present* & past*.
pres+fut := present* & future*.
past+fut := past* & future*.

nonprg :< aspect.
nonprf :< aspect.
nonprg+nonprf := nonprg & nonprf.
no_aspect* := nonprg+nonprf.
progr* :< nonprf.
perf* :< nonprg.

strict_aspect := aspect & strict_sort.
strict_nonprg := nonprg & strict_aspect.
strict_nonprf := nonprf & strict_aspect.
nonprf+nonprg+prog* := nonprg+nonprf & progr*.
nonprf+nonprg+perf* := nonprg+nonprf & perf*.
nonprf+nonprg+no_aspect* :< no_aspect*.

no_aspect := no_aspect* & strict_nonprg & strict_nonprf.
progr := progr* & strict_nonprf.
perf := perf* & strict_nonprg.

noasp+progr := nonprf+nonprg+no_aspect* & nonprf+nonprg+prog*.
noasp+perf := nonprf+nonprg+no_aspect* & nonprf+nonprg+perf*.
progr+perf := nonprf+nonprg+prog* & nonprf+nonprg+perf*.

tam := *avm* &
 [ TENSE tense,
   ASPECT aspect,
   MOOD mood ]. 

basic_ind_or_mod_subj_tam := tam &
 [ MOOD ind_or_mod_subj ].

ind_or_mod_subj_tam := basic_ind_or_mod_subj_tam &
 [ TENSE real_tense ].

past_or_subj_tam := tam &
 [ ASPECT no_aspect* ].

subjnct_tam := past_or_subj_tam &
 [ MOOD subjunctive ].

past_tam := past_or_subj_tam & ind_or_mod_subj_tam &
 [ TENSE past*,
   MOOD indicative* ].

event := event_or_index &
  [ E tam ].

; Once used to distinguish discourse adverbs, for VIT purposes - now obsolete?
disc_frag :< event_or_index.

cont :< *avm*.

; LABEL links semantic relation to input string elements, more or less.

mod_relation := cont &
  [ HANDEL handle,
    LABEL *list* ].

relation :< mod_relation.

number_or_degree_rel :< relation.

non_number_rel :< relation.

norm_relation :< non_number_rel.

event_or_degree_or_no_rel :< mod_relation.
; Needed for coordination of everything but nominals.
non_conj_rel :< mod_relation.
norm_non_conj_rel := non_conj_rel & norm_relation.
event_or_degree_rel := norm_non_conj_rel & event_or_degree_or_no_rel.

event_rel := event_or_degree_rel &
  [ EVENT event ].

; Subtypes of this relation are the types for particle semantics in
; verb-particle constructions like _together_rel in "get together"
; DPF 15-Apr-01 - Removed ASPECT no_aspect, since want to let "of" be progr*
; to block e.g. "as of NP"

selected_rel := event_rel & [ EVENT.E.TENSE no_tense ].

; Subtypes of this relation contrast with those of the above, in that they
; supply an "independent" relation.
independent_rel :< mod_relation.

non_event_rel :< norm_non_conj_rel.

aux_event_rel :< event_rel.

; DPF 23-Nov-01 - Was relation, but should be mod_relation since no_rel should
; not be subtype of relation.
nonaux_event_rel :< mod_relation.

non_freerel_rel :< independent_rel.

no_rel := non_freerel_rel & non_conj_rel & event_or_degree_or_no_rel &
          nonaux_event_rel.

never_unify_rel :< relation.
never_unify_event_rel :< event_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MRS type
;
;   TOP handle,            ; Local top handle, linked by H-CONS to other handles
;   H-CONS *diff-list*     ; Scope constraints: list of scp_pr's
;   --TOPKEY mod_relation  ; Pointer to relation with TOP handle.

mrs_min := cont &
  [ INDEX individual,
    E-INDEX individual ].

mrs_min0 := mrs_min &
  [ TOP handle ].

mrs_min1 := mrs_min0 &
  [ LISZT *diff-list*,
    --TOPKEY mod_relation ].
    
;; DPF 10-Oct-00 - Added EVENT attribute for predicative phrases, as in
;; "Kim kept calm" where the INDEX of "calm" is "Kim"'s INDEX and the first
;; argument of _keep_rel, while "calm"'s EVENT is second argument of _keep_rel.

mrs := mrs_min1 &
  [ H-CONS *diff-list* ].

; Constrains handle of scopable argument SC-ARG relative to one or more 
; handles
scp_pr := *top* &
  [ SC-ARG handle ].       

; Constrains KEY handle to be less than or equal to the TOP handle.
qeq := scp_pr &
  [ OUTSCPD handle ].        

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONJ type -
;
; CONJ values come in two types, cnil and strict-conj (i.e., non-cnil).  Cnil
; and the atomic substypes of strict-conj are the possible CONJ values of the
; left conjunct in a coordinate structure.  The right conjunct must always
; have a complex-conj CONJ value.  A complex CONJ value has three parts: the
; handles and indices of the sub-parts of the right conjunct, and the CHEAD
; info that gets passed from the right conjunct to the mother.  The CHEAD
; value has only one piece of information: the CONJ values of the
; left conjunct daughters.  For more info about how this works, see
; top_coord_rule in syntax.tdl.

conj :< *avm*.
cnil_or_numconj :< conj.
cnil :< cnil_or_numconj.
real-conj := conj &
  [ CHEAD chead ].
strict-conj :< conj.
strict-real-conj := strict-conj & real-conj.
atomic-conj := strict-real-conj &
  [ CHEAD.LEFT.FIRST cnil ].
both :< atomic-conj.
either :< atomic-conj.
neither :< atomic-conj.
nor :< atomic-conj.
chead := *avm* &
  [ LEFT *list* ].
complex-conj :< strict-real-conj.
phr-conj :< complex-conj.
lex-conj :< complex-conj.
num-conj := cnil_or_numconj & strict-conj.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Contextual information

ctxt_min :< *avm*.

ctxt := ctxt_min &
  [ ACTIVATED bool,
    PRESUP *diff-list* ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Stem type

; The stemhead of a lexical entry is used by inflectional affixes to ensure the
; desired stem without overly restricting the value of HEAD itself, since
; this needs to remain non-specific to allow conjunction of non-similar heads. 
; Note that if we distinguished lexemes from words, the stemhead could be the
; value of HEAD for the lexeme, and the word's value for HEAD could be 
; supplied by the affix; then the same head type could be used for both.
; This feature is only given a more specific value for lexical entries which
; get inflected (verbs, nouns, and adjectives).

stemhead :< *sort*.
vstem :< stemhead.
nstem :< stemhead.
count_or_masscount_nstem :< nstem.
masscountnstem :< count_or_masscount_nstem.
countnstem :< count_or_masscount_nstem.
massnstem :< nstem.
astem :< stemhead.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; KEY relations, for semantic selection
;  KEY mod_relation         ; Pointer to main relation in LISZT
;  ALTKEY mod_relation      ; Pointer to an alternate relation in LISZT
;  ALT2KEY mod_relation     ; Pointer to a second alternate relation in LISZT
;  --COMPKEY mod_relation   ; Pointer to the complement's main relation
;  --OCOMPKEY mod_relation  ; Pointer to the oblique complement's main relation
;  --+COMPKEY mod_relation  ; Pointer to obligatory complement
;
;  MESSAGE 0-1-dlist,       ; Message type for propositions


keys_min :< *avm*.

keys_k := keys_min &
  [ KEY mod_relation ].

keys_km := keys_k &
  [ MESSAGE 0-1-dlist ].

keys := keys_km &
  [ ALTKEY mod_relation,
    ALT2KEY mod_relation,
    --COMPKEY mod_relation,
    --OCOMPKEY mod_relation,
    --+COMPKEY mod_relation,
    --+OCOMPKEY mod_relation ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsem values

; The feature AGR is introduced on LOCAL rather than on CAT (or on HEAD) since
; coordination schema unify the CAT value of the daughters with that of then
; mother, but need to be able to change AGR on the mother (to get plural 
; agreement on verb when subject is a coordinated NP with "and" vs. "or").  

cat_min :< *avm*.

cat := cat_min &
  [ HEAD head_min,
    VAL valence_min,
    MC luk,
    POSTHEAD bool,
    HC-LEX bool ].

local_min := mod_local &
  [ CAT cat_min,
    CONT cont,
    AGR individual ].

; no-affix :< mod_local.

non-local_min :< *avm*.

; DPF (09-Jan-99) - Added boolean LEX feature to be used for determining the
; head-complement type of the projections of lexical heads - most produce 
; phrases, but see discussion of HC-LEX feature below.

synsem_min := *avm* &
  [ OPT bool,
    LEX bool,
    LOCAL mod_local,
    NON-LOCAL non-local_min ].

lex_or_phrase :< synsem_min.

synsem :< synsem_min.

expressed_synsem :< synsem.

canonical_synsem := expressed_synsem &
  [ MODIFIED xmod ].

lex_synsem := canonical_synsem & lex_or_phrase &
  [ LOCAL local_min,
    LEX +* ].

phr_synsem := canonical_synsem & lex_or_phrase &
  [ LOCAL local_min,
    LEX -* ].

non_canonical := synsem &
  [ LOCAL.CONT.INDEX non_expl ].

expressed_non_canonical := non_canonical & expressed_synsem.

gap := expressed_non_canonical &
  [ LOCAL #local,
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist,
		SLASH 1-dlist &
		    [ LIST < #local > ] ] ].

unexpressed := synsem_min &
  [ NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

unexpressed_reg := unexpressed & non_canonical.

; DPF 28-Aug-99 - Removed OPT + from anti_synsem since it blocked 
; "you can have anything you want"
anti_synsem :< unexpressed.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT type

;; The feature MC has three possible values: +, -, and na.  Non-clauses are
;; always MC na, since they can't really be said to be root or non-root.
;; All clauses are MC bool, and if they have a restricted distribution then
;; they are MC + or MC -.

;; DPF (22-Oct-98) Added feature HC-LEX ("is head-complement type lexical?")
;; on CAT, to identify the type of synsem that results from combining the word 
;; with its complements.  We recognize at least the head-complement 
;; structures  "thirty-two" and "two o'clock" as still being lexical signs, not
;; phrasal ones, since they can appear as prenominal adjectives and in noun-
;; noun compound constructions, respectively.  The head-complement rule 
;; determines its SYNSEM type by unifying its LEX value with the HC-LEX of
;; its head dtr - this works because the HCOMP rule requires its SYNSEM value to
;; be of type canonical_synsem, and the subtypes of canonical_synsem are the
;; only types that introduce the feature LEX, namely lex_synsem and phr_synsem.

local_basic := local_min &
  [ KEYS keys_min,
    CONJ conj ].

local := local_basic &
  [ CTXT ctxt_min,
    ARG-S *list*,
    STEMHEAD stemhead ].

non-local := non-local_min &
  [ SLASH 0-1-dlist,
    QUE 0-1-dlist,
    REL 0-1-dlist ].

non-local_norel := non-local &
  [ QUE 0-dlist,
    REL 0-dlist ].

non-local_none := non-local_norel &
  [ SLASH 0-dlist & [ LIST < > ] ].

;; For unrealized extracted adjuncts needed in relative clauses, as in 
;; "the day he arrived"
unexpr_local :< local_basic.

;; For exceptions to lexical rules
alts_min :< *avm*.
alts := alts_min &
  [ PASSIVE bool,
    VPELLIP bool ].
no_alts :< alts_min.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign_min := *avm* &
  [ STEM *list* ].

basic_sign := sign_min &
  [ KEY-ARG bool ].

;; ROBUST used to enable ungrammatical phrases such as missing det for sg-noun
;; POSSCL marks whether sign contains a possessive clitic.
sign := basic_sign &
  [ SYNSEM synsem,
    ARGS *list*,
    INFLECTED bool,
    ROOT bool,
    ROBUST bool,
    POSSCL bool ].

phrase_or_lexrule := sign &
  [ SYNSEM canonical_synsem &
	   [ LOCAL.CONT [ TOP #hand,
			  INDEX #index,
                          E-INDEX #event ] ],
    C-CONT mrs_min & [ TOP #hand,
		       INDEX #index,
                       E-INDEX #event ] ].

word_or_lexrule_min := sign_min.

; ALTS allow lexical entries to block lexical rule application
word_or_lexrule := word_or_lexrule_min & sign &
  [ ALTS alts_min ].

; We use --TOPKEY rather than KEY because of negated auxiliaries, which have the
; neg_rel's HANDEL as TOP, rather than the KEY's HANDEL (where the KEY must still
; be the same as for the positive auxiliary in order to get tag questions right).
;
; Not all words have lex_synsem - e.g. lexical PPs like "tomorrow" are phr_synsem
; since they can be post-nominal modifiers.

word := word_or_lexrule &
  [ SYNSEM.LOCAL.CONT [ TOP #hand,
			--TOPKEY.HANDEL #hand ],
    POSSCL -,
    ROOT - ].

;; Not all phrases have SYNSEM phr_synsem, since we need to allow the head-comp
;; rules to build signs which are still [ SYNSEM lex_synsem ], for constructions
;; like "twenty-two" and "five fifteen p.m.".  So most phrases will assign the
;; type phr_synsem to the value of SYNSEM, but not all.

; DPF 02-Sept-00 - Removed [ HC-LEX - ] because it blocks conjoined lexical
; somethings.

phrase := phrase_or_lexrule &
  [ SYNSEM.LOCAL.ARG-S < >,
    ROOT bool ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; DPF (14-Oct-98) --FINAL-ARG points to the final element in a word with 
;; spaces, since that element bears any inflection.
;; AAC - dropped --FINAL-ARG - default infl position is end of word
;; in user-fns. Find better soln when we do multi words properly
;; (and use defaults)

non_affix_bearing := word_or_lexrule &
[ INFLECTED +,
  SYNSEM.LOCAL.KEYS.KEY.LABEL *cons* ].

; Rule

rule := sign &
  [ RULE-NAME symbol ].

; LABEL-NAME and META used for labeling nodes in parse trees

tree_node_label := *top* &
  [ NODE sign ].

label := sign &
  [ LABEL-NAME string ].

;; see lkbpatches
meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ]. 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CAT values

case :< *sort*.
nom :< case.
acc :< case.

vform :< *sort*.
non_fin :< vform.
non_prp :< non_fin.
ger :< non_prp.
pas_or_psp :< non_fin.
pas := non_prp & pas_or_psp.
psp_or_psp_irreg :< pas_or_psp.
psp :< psp_or_psp_irreg.
psp_irreg :< psp_or_psp_irreg.
bse_or_inf :< vform.
; fin_or_bse used to collapse morpholog. unmarked forms for bse and fin-non3sg.
fin_or_bse :< vform.
bse :< bse_or_inf.
; Base morphology verbs can be either base or imperative, but not if negated.
; See discussion of type neg_word.
bse_only := bse & non_fin & fin_or_bse & strict_sort.
fin_or_imp :< vform.
imp_vform* :< bse.
imp_vform := imp_vform* & fin_or_imp & strict_sort.
fin_or_inf :< vform.
fin* := fin_or_inf & fin_or_bse & fin_or_imp.
fin := fin* & strict_sort.
inf_or_prp :< non_fin.
inf := inf_or_prp & bse_or_inf & fin_or_inf.
prp :< inf_or_prp.

fin+imp := fin* & imp_vform*.
inf_and :< vform.
psp_adj :< vform.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

poss-able := head_min &
  [ POSS bool ].

disc_adverbee :< head.

strict_type :< head_min.

func := head & strict_type.

det := func & poss-able.

n_or_p_or_adv :< head.

subst :< head.

v_or_g_or_p :< subst.

a_or_p_or_adv :< head.

n_or_p :< subst.
n_or_a :< subst.
a_or_p := subst & a_or_p_or_adv.
v_or_p :< subst.
n_or_v :< subst.

; Adverbs modify adverbees.
adverbee :< subst.

v_or_g_or_a :< subst.
v_or_g := v_or_g_or_a & v_or_g_or_p &
  [ VFORM vform ].

nominal_or_verbal :< subst.

nominal := nominal_or_verbal & poss-able &
  [ CASE case ].

verbal := v_or_g & nominal_or_verbal & adverbee & disc_adverbee.

; mobile things can be extracted in the complement-extraction rule, from which
; we exclude nominative-case NPs by not making all nouns mobile.

mobile :< head.
adj_or_intadj :< head.

adj* := a_or_p & v_or_g_or_a & n_or_a & adverbee & mobile.

prep_or_modnp :< head.

; DPF 26-Jul-99 - Made prep* not inherit from adverbee, since in general
; don't want adverbs modifying PPs.
; DPF 17-Dec-01 - But need to have at least some adverbs modifying PPs: "The books currently
; available include ..."

prep* := a_or_p & v_or_p & n_or_p & mobile & prep_or_modnp & v_or_g_or_p &
         n_or_p_or_adv & adverbee.

; For result of temp_mod non-branching rule
; Need mobile for "where did i put it"
modnp* := n_or_p & nominal & prep_or_modnp & a_or_p_or_adv & mobile &
          n_or_p_or_adv.

supnoun :< nominal.

noun* := supnoun & n_or_v & n_or_p & n_or_a.

; DPF 10-Apr-02 - Added n_or_p since want to allow gerunds to undergo noptcomp
; rule, to get e.g."way of saying that Kim arrives"
gerund* := supnoun & adverbee & v_or_g & n_or_v & n_or_p & disc_adverbee.

verb* := verbal & v_or_p & n_or_v &
  [ VOICE voice ].

comp* := nominal & verbal.

; For measure_nps
adv_or_partn :< head.

basic_adv :< func.

; 'not' and closed class of other adverbs that can be added to aux COMPS list
; via 'adv_addition' lexical rule.
basic_lexadv := basic_adv & disc_adverbee.
negadv :< basic_lexadv.
lexadv :< basic_lexadv.

reg_adv := basic_adv & disc_adverbee & adv_or_partn & n_or_p_or_adv &
           a_or_p_or_adv.
adv := reg_adv & mobile.
adv_nonmob :< reg_adv.
deg_adv :< basic_adv.
root-marker := v_or_g & adverbee & a_or_p_or_adv & strict_type.
wh_adv :< func.

detspec :< func.

; Hack used in blocking unwanted affixes
no_head := head & strict_type.

; Types for punctuation and string boundaries.
punct := head & strict_type.
left_edge :< punct.
right_edge :< punct.

; The idea is that any two heads (for now only major categories) can be
; unified in a conjunction, but the resulting type is a specific type that
; will not be subcategorized for, so the only way conjuncts of distinct
; types will satisfy a subcat is when the head does not mention the type.
; An example is the copula "be", as in "Kim is in Paris and happy."

v_and_n := verb* & noun*. 
v_and_a := verb* & adj*.
v_and_p := verb* & prep*.
v_and_g := verb* & gerund*.
n_and_a := noun* & adj*.
n_and_p := noun* & prep*.
;;n_and_g := noun* & gerund*.
a_and_p := adj* & prep*.
a_and_g := adj* & gerund*.
mod_and_p := modnp* & prep*.
mod_and_n := modnp* & noun*.
mod_and_a := modnp* & adj*.

; AAC - verb_or_comp introduced because the template vp has verbal &
; strict_type which must be specified as a single type in the LKB

verb_or_comp := strict_type & verbal.

; AAC - similarly for strict_nominal and strict_supnoun

strict_nominal := strict_type & nominal.

strict_supnoun := strict_nominal & supnoun.

mobile_nom := mobile & nominal.

noun_or_nomger := noun* & strict_supnoun.
; Nominal gerunds
nomger :< noun_or_nomger.
nomger_acc := nomger & mobile_nom & [ CASE acc ].

; The following types are used to enable strict subcategorization (the usual 
; case)

verb := verb* & verb_or_comp.
noun := noun_or_nomger & n_or_p_or_adv.
noun_acc := noun & mobile_nom & [ CASE acc ].
noun_nom := noun & [ CASE nom ].
partn :< noun.
partn_mobile := partn & mobile.


;partn_acc := partn & adv_or_partn & noun_acc.
partn_acc := partn & adv_or_partn & [ CASE acc ].
prep := prep* & strict_type.
adj := adj* & strict_type & adj_or_intadj.
comp := comp* & verb_or_comp.
gerund := gerund* & strict_supnoun.
gerund_acc := gerund & mobile_nom & [ CASE acc ].
gerund_nom := gerund & [ CASE nom ].
modnp := modnp* & strict_type.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  CONT values (MRS semantics)
;;
;; The basic semantic objects are all sub-types of thing.  Right now, the only
;; type of thing that has an internal structure is index, but that will
;; probably change.  For example, an event might have various times associated
;; with them or a handle may include a list of "subhandles" which are in its
;; scope.  Indices are classified in the familiar HPSG way.

expl-ind :< index.
it-ind := expl-ind & full_index &
  [ PNG [ PN 3sg*,
          GEN no_gend_it ] ].
there-ind := expl-ind &
  [ PNG.GEN no_gend_there ].

non_expl-ind := index & event_or_index &
  [ PNG.GEN real_gender ].

ref-ind :< non_expl-ind.
deg-ind :< non_expl-ind.
full_non_expl := full_index & non_expl-ind.
full_there-ind := there-ind & full_index.
full_ref-ind := ref-ind & full_non_expl.
full_deg-ind := deg-ind & full_non_expl.

conj-ind :< event_or_index.
conj_event := conj-ind & event.
conj_non_expl-ind := conj-ind & non_expl-ind.
conj_full-ind := conj_non_expl-ind & full_non_expl.
conj_ref-ind := conj_non_expl-ind & ref-ind.
conj_full_ref-ind := conj_ref-ind & conj_full-ind & full_ref-ind.
conj_deg-ind := conj_non_expl-ind & deg-ind.
conj_full_deg-ind := conj_deg-ind & conj_full-ind.

; The basic semantic structure, a CONT, is just something with a handle.
; Conts are further classified into mrss (i.e., things with liszts) and
; relations (i.e., things that go on liszts).  Conts are divided into psoas
; (with a distinguished event) and nom-objs (with a distinguished index).
; We use a polymorphic attribute name INDEX for both of these, to simplify
; manipulation of these objects; for example, modifying PPs assign as their
; ARG's value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  Similarly useful
; for coordination.

; ERB (03-10-96) 
; The intermediate types ques_prop_msg and prop_com_msg represent the
; natural classes needed for selection by know, announce, care, check,
; etc. and the analysis of THAT (see lextypes.tdl) and the 
; forthcoming analysis of tags on imperatives, respectively.

psoa := mrs_min &
  [ INDEX event ].

psoa_basicmrs := psoa & mrs_min0.

psoa_mrs := psoa_basicmrs & mrs.

; DPF 11-Feb-01 - For now, make all nom-objs have INDEX and E-INDEX the same, 
; to keep coordination working now that we want to treat coordination of 
; predicative phrases via their E-INDEX.  Probably will have to adjust this
; once we get more interesting temporal semantics for some nouns.

nom-obj := mrs_min &
  [ INDEX index & #ind,
    E-INDEX #ind ].

nom-obj_basicmrs := nom-obj & mrs_min0.

nom-obj_mrs := nom-obj_basicmrs & mrs.

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; Since some temporal nouns can be either arguments or VP modifiers, their 
; rel's INST value (coindexed with INDEX of the containing MRS) must remain 
; unspecified for type.  Consider "Kim arrived Tuesday" vs. "Tuesday comes
; after Monday"; in the first, Tuesday must have an EVENT index, while in the
; second, it must have a REF-IND index.

; ERB (24-10-96) Here is the series of relations that will be used for
; questions, etc.  Cf. Gizburg & Sag.
; ERB (12-05-96) Moved the ne_rel here.

message := norm_relation &
  [ SOA handle ].
imp_rel :< message.
prop_ques_rel :< message.          ;for COMPS of e.g. 'know'
propositional_rel :< prop_ques_rel.
prpstn_or_like_rel :< message.
prpstn_rel := propositional_rel & prpstn_or_like_rel.   ;propositions
;hypo_rel :< propositional_rel.     ;hypotheticals (PRO to go)

; For interrogatives; PARAMS value is a set of handles.
abstr_int_rel := prop_ques_rel &
  [ PARAMS *diff-list* ].       

int_rel :< abstr_int_rel.

; Subtype of int_rel for tag questions.   
ne_rel :< abstr_int_rel.                 

; For targets of degree specifiers like "that" as in "that much", "that tall"
this_that_rel :< relation.

; For QUE-word complements as in "what the hell"
wh_the_hell_rel :< relation.

; Subtype to distinguish complementizer "like" from "that", to block
; '*Kim said like Sandy left' and '*it looks that Sandy left"
_like_mood_rel :< prpstn_or_like_rel.

dim_rel := relation &
  [ DIM non_expl-ind ].

norm_dim_rel := norm_non_conj_rel & dim_rel.

basic_event_dim_rel := norm_dim_rel & event_rel.
non_event_dim_rel := non_event_rel & norm_dim_rel.
quant_or_deg_rel :< non_event_dim_rel.
i_or_e_quant_or_deg_rel :< quant_or_deg_rel.

quant_or_wh_rel := quant_or_deg_rel &
  [ BV ref-ind,
    RESTR handle ].

quant_rel := quant_or_wh_rel &
  [ SCOPE handle ].

impl_or_expl_quant_rel := quant_rel & i_or_e_quant_or_deg_rel &
                          non_freerel_rel.

implicit_quant_rel :< impl_or_expl_quant_rel.
explicit_quant_rel :< impl_or_expl_quant_rel.

; Determiners with these relations show agreement with of_PP in partitives
explicit_quant_agr_rel :< explicit_quant_rel.

; These don't
explicit_quant_or_udef_noagr_rel :< impl_or_expl_quant_rel.
explicit_quant_noagr_rel := explicit_quant_rel & 
                            explicit_quant_or_udef_noagr_rel.

much_many_rel := explicit_quant_noagr_rel & this_that_rel.

udef_rel := implicit_quant_rel & explicit_quant_or_udef_noagr_rel.
some_rel :< explicit_quant_agr_rel.
abstr_def_rel :< quant_rel.
def_rel := abstr_def_rel & implicit_quant_rel.
def_explicit_rel := abstr_def_rel & explicit_quant_noagr_rel.

; Used for lexical NPs including proper names
; It is distinct from i_or_e_quant_or_deg_rel to prevent relative clauses
; from attaching to proper names with no specifier.
def_np_rel :< quant_rel.

demonstrative_rel :< explicit_quant_rel.
demon_near_rel :< demonstrative_rel.
demon_far_rel :< demonstrative_rel.
free_relative_ever_rel :< quant_rel.

_def_rel :< def_explicit_rel.

;which_rel should not have a scope, but given for the moment to satisfy VIT
;which_rel :< quant_or_wh_rel.
which_rel :< explicit_quant_agr_rel.

_all_rel :< explicit_quant_agr_rel.

; Nominal sorts used for VM2

nominal-sort :< *sort*.
entity :< nominal-sort.
human :< entity.
time :< nominal-sort.

info_bearer :< nominal-sort.
space_time :< nominal-sort.
location :< nominal-sort.
geo_location :< location.
nongeo_location :< location.
meeting_sit :< nominal-sort.
inst_loc_coll_poly :< nominal-sort.

; nondim_rel is used to determine whether the specifier that combines with its
; head provides the semantics (nonhead-compositional) or whether the head does:
; nondim_rel entries are head-compositional.

nondim_rel :< norm_relation.

; modable_rel distinguishes those relations whose nominal lexical entries can 
; undergo a syntactic rule to produce a modifier phrase, as in "we'll meet
; next week" or "I'll do it my way".

modable_rel :< norm_relation.

; nontemp_rel used to distinguish temporal nominal phrases from all others
nontemp_or_conj_rel :< norm_relation.
nontemp_rel :< nontemp_or_conj_rel.

; Nominal relations

instance_rel := independent_rel &
  [ INST individual ].

basic_nom_rel := non_event_rel & instance_rel.

nom_rel := basic_nom_rel &
  [ INST non_expl-ind ].

nonpro_rel :< nom_rel.
nom_nondim_rel := nom_rel & nondim_rel.

; DPF 25-Sep-01 - Added [SORT entity] contrasted with [SORT time] to enable
; blocking of e.g. "the book that kim arrived" but allow "the day that Kim
; arrived"

non_temp_nom_rel := nom_nondim_rel & nontemp_rel &
  [ INST.SORT entity ].
non_temp_nonpro_rel := non_temp_nom_rel & nonpro_rel.
reg_nom_rel :< non_temp_nonpro_rel.
modable_nom_rel := non_temp_nonpro_rel & modable_rel.

arg3_rel := relation &
  [ ARG3 thing ].

diadic_nom_rel := basic_nom_rel & arg3_rel.

reg_diadic_nom_rel := diadic_nom_rel & reg_nom_rel.
basic_diadic_modable_nom_rel := diadic_nom_rel & modable_rel.
diadic_modable_nom_rel := basic_diadic_modable_nom_rel & modable_nom_rel.

basic_hcomp_nom_rel := reg_nom_rel & arg4_rel &
  [ ARG4 handle ].

hcomp_nom_rel :< basic_hcomp_nom_rel.

hcomp_modable_nom_rel := basic_hcomp_nom_rel & modable_rel.

; Changed nominalize_rel and gerund_rel to subtype of non_temp_nom_rel rather 
; than reg_nom_rel to avoid semantically anomalous readings for e.g. "Kim is 
; sleeping".

nom_or_ger_rel :< relation.

nominalize_rel := hcomp_nom_rel & nom_or_ger_rel.

gerund_rel := non_temp_nom_rel & nom_or_ger_rel &
  [ INST ref-ind ].

apposition_rel :< nonpro_rel.

temp_abstr_or_conj_rel :< relation.
temp_abstr_rel := nonpro_rel & temp_abstr_or_conj_rel &
  [ INST.SORT time ].

temp_nondim_rel := temp_abstr_rel & nondim_rel.

const_value_rel := relation &
  [ CONST_VALUE *top* ].

; Used in munging rules to make reversible the implicit quantifier
abstr_named_rel :< relation.
gen_named_rel := abstr_named_rel & const_value_rel &
  [ CONST_VALUE atom ].
abstr_named_np_rel :< gen_named_rel.
named_np_rel := abstr_named_np_rel & reg_nom_rel.
;named_num_rel := abstr_named_np_rel & reg_nom_rel & card_rel & apposition_rel.
named_num_rel := abstr_named_np_rel & reg_nom_rel & apposition_rel.
named_card_rel := named_num_rel & card_rel.
named_times_rel := named_num_rel & times_rel.
named_plus_rel := named_num_rel & plus_rel.

elliptical_n_rel :< diadic_noarg_nom_rel.

; Relation used in decomposed lexical semantics, e.g. for 'when'

temp_rel := abstr_named_rel & modable_rel & temp_abstr_rel.

day_rel :< temp_nondim_rel.

diadic_day_rel := day_rel & diadic_nom_rel & modable_rel.

named_day_rel := diadic_day_rel & abstr_named_np_rel.

unnamed_day_rel :< diadic_day_rel.

non_day_rel :< temp_nondim_rel.

;; day_of_month_rel
dofm_rel := diadic_day_rel & gen_named_rel &
  [ CONST_VALUE string,
    ARG3 non_expl-ind ].

;; Need supertype of dofw_rel and pro_poss_rel for the specifier of the small
;; class of words like "morning" as in "my mornings" or "Tuesday mornings"
dofw_or_poss_rel :< norm_relation.

;; day_of_week_rel
dofw_rel := named_day_rel & dofw_or_poss_rel &
  [ CONST_VALUE symbol ].

holiday_rel := named_day_rel &
  [ CONST_VALUE symbol ].

day_part_rel := diadic_day_rel &
  [ INST.DIVISIBLE -* ].

; dim_rel: 'almost three o'clock'
; DPF 2-Apr-02 - Added type for hour_rel and _time_rel, to get both "at three"
; and 'at that time" while distinguishing "kim fell three times" from "*Kim
; fell three o'clock"
hour_or_time_rel :< relation.
hour_rel := temp_abstr_rel & norm_dim_rel & hour_or_time_rel.

; a quarter till three  ("till" is head - cf "come at a quarter till.")
hour_prep_rel := hour_rel &
  [ HOUR-IND individual,
    MINUTE-IND individual ].

numbered_hour_rel := hour_rel & abstr_named_rel & const_value_rel &
  [ INST.PNG png & [ PN 3sg*,
		     GEN neut* ],
    CONST_VALUE string,
    MIN non_expl-ind,
    AM-PM non_expl-ind ].

; DPF 31-Jul-99 - Changed minute_or_ampm_rel to be non-temp, since it cannot
; appear after temporal prepositions (ignoring the elliptical "I'll see you 
; in ten"), and we also need to block "from ten to eleven o'clock" with
; "ten" as minute.
minute_or_ampm_rel :< nom_nondim_rel.

#|
minute_rel := minute_or_ampm_rel &
  [ MINUTE string ].
|#

modable_hour_rel :< non_day_diadic_modable_rel.

; 'Kim sleeps three times each day'
_time_rel := modable_hour_rel & hour_or_time_rel.
; 'How many hours did Kim work?'
_hour_rel :< modable_hour_rel.
_minute_rel :< non_day_diadic_modable_rel.
_day_amount_rel :< non_day_diadic_modable_rel.

am_pm_rel :< minute_or_ampm_rel.
am_rel :< am_pm_rel.
pm_rel :< am_pm_rel.
hours_am_pm_rel :< am_pm_rel.

ctime_rel :< numbered_hour_rel.

; 'the morning', not 'some morning': 'in the morning' but 'on some morning'
def_day_part_rel :< non_day_diadic_modable_rel.

non_day_diadic_rel := non_day_rel & diadic_nom_rel.
non_day_modable_rel := non_day_rel & modable_rel.
non_day_diadic_modable_rel := non_day_diadic_rel & modable_rel.

;; named_month_rel as in "January is fine"
;; DPF 13-Mar-02 - Changed parent non_day_diadic_modable_rel to 
;; non_day_diadic_rel since we were overgenerating: "*Kim arrived June" in 
;; order to admit "Kim arrived last June".  Have to do something else to
;; allow the latter.
mofy_rel := non_day_diadic_rel & abstr_named_np_rel &
  [ CONST_VALUE symbol ].

yofc_rel := non_day_rel & abstr_named_np_rel.

;season_rel := non_day_diadic_modable_rel & abstr_named_np_rel.
season_rel := non_day_diadic_modable_rel & gen_named_rel.

age_rel :< non_day_rel.
_while_n_rel :< non_day_rel.

_morning_rel :< day_part_rel.
_afternoon_rel :< day_part_rel.
_evening_rel :< day_part_rel.
_night_rel :< day_part_rel.
_weekday_rel :< day_rel.
_weekend_rel :< day_rel.
_workday_rel :< day_rel.

_week_rel :< non_day_diadic_modable_rel.
_fortnight_rel :< non_day_modable_rel.
_month_rel :< non_day_diadic_modable_rel.
_moment_rel :< hour_rel.
_year_rel :< non_day_diadic_modable_rel.
_quarter_temp_rel :< non_day_diadic_modable_rel.

duration_rel :< temp_rel.

named_rel := named_np_rel & apposition_rel.
named_abb_rel :< named_np_rel.
named_n_rel := gen_named_rel & reg_nom_rel.

unk_rel :< named_rel.

gen_numval_rel := modable_nom_rel & const_value_rel.
gen_currency_rel :< reg_nom_rel.

; For X to Y constructions
interval_rel :< diadic_modable_nom_rel.

;; The relation event_or_arg_rel is designed to distinguish non-nominal signs, 
;; including verbs, adjectives, prepositions, and adverbs.  One use of this 
;; distinction is for the conjuncts accepted by "but": "*Kim but Sandy left."

event_or_arg_rel :< relation.

arg_rel := event_or_arg_rel &
  [ ARG thing ].

event_arg_rel := event_rel & arg_rel.
event_arg_dim_rel := event_arg_rel & basic_event_dim_rel.
event_dim_rel := basic_event_dim_rel & nonaux_event_rel.
independent_arg_rel := independent_rel & arg_rel.

abstr_excl_rel := nondim_rel & independent_arg_rel & const_value_rel &
  [ CONST_VALUE symbol ].

greet_rel :< abstr_excl_rel.

excl_rel :< abstr_excl_rel.

; Pronouns
pron_rel := non_temp_nom_rel & abstr_named_rel &
  [ INST ref-ind & [ DIVISIBLE -* ] ].

recip_pro_rel := non_temp_nonpro_rel &
  [ INST ref-ind & [ DIVISIBLE -* ] ].

; For deictic pronouns
; DPF 12-Apr-02 - Added nonpro_rel parent, to allow deictic complements for
; e.g. there-copula
generic_nom_rel := non_temp_nonpro_rel &
  [ INST ref-ind ].

; For partitives
generic_nonpro_rel := nonpro_rel &
  [ INST ref-ind ].

basic_adj_rel := event_dim_rel & nontemp_rel.

abstr_adj_rel := basic_adj_rel & event_arg_dim_rel &
  [ ARG non_expl ].

adj_rel := abstr_adj_rel & independent_arg_rel & this_that_rel.

expl_adj_rel := basic_adj_rel & independent_rel.

arg2_rel := relation &
  [ ARG2 thing ].

arg4_rel := relation &
  [ ARG4 thing ].

; For generator to know when to introduce expletive "it"
expl_rel :< relation.

basic_adj_arg4_rel := basic_adj_rel & arg4_rel.
adj_arg4_rel := basic_adj_arg4_rel & adj_rel.
adj_arg2_rel := adj_rel & arg2_rel.
;;it_adj_arg24_rel := basic_adj_arg4_rel & adj_arg2_rel & expl_rel.
;;it_adj_arg4_rel := adj_arg4_rel & expl_rel.
it_adj_arg4_rel := adj_arg4_rel & expl_rel.
it_adj_arg24_rel := it_adj_arg4_rel & adj_arg2_rel.
adj_arg24_rel := adj_arg4_rel & adj_arg2_rel.
adj_arg3_rel := adj_rel & arg3_rel.

meas_adj_rel := adj_arg3_rel &
  [ ARG3 ref-ind ].

adj_personal_rel :< adj_rel.
adj_abstract_rel :< adj_rel.

verb_aspect_rel := event_rel & independent_rel.

prog_rel :< verb_aspect_rel.

v_event_rel := verb_aspect_rel & event_arg_dim_rel.

mod_role_rel :< v_event_rel.

no_role_rel :< mod_role_rel. 

weather_v_rel := expl_rel & no_role_rel.

role_rel := mod_role_rel & nontemp_rel & nonaux_event_rel.

arg1_rel := role_rel &
  [ ARG1 thing ].

arg12_rel := arg1_rel & arg2_rel.
arg13_rel := arg1_rel & arg3_rel.
arg14_rel := arg1_rel & arg4_rel &
  [ ARG1 non_expl-ind,
    ARG4 thing ].
arg24_rel := arg2_rel & arg4_rel.
arg123_rel := arg12_rel & arg13_rel.
arg124_rel := arg12_rel & arg14_rel & expl_rel.
arg134_rel := arg13_rel & arg14_rel.
arg1234_rel := arg123_rel & arg134_rel.
arg3_event_rel := arg3_rel & role_rel.
basic_arg4_event_rel := arg4_rel & v_event_rel.
arg4_event_rel := basic_arg4_event_rel & nonaux_event_rel.
arg24_event_rel := arg2_rel & arg4_event_rel & expl_rel.
arg34_event_rel := arg3_rel & arg4_event_rel & expl_rel.
arg14_expl_rel := arg14_rel & expl_rel.
arg4_expl_event_rel := arg4_event_rel & expl_rel.

aux_arg4_event_rel := basic_arg4_event_rel & aux_event_rel.
modal_rel :< aux_arg4_event_rel.

ellipsis_rel := role_rel &
  [ ROLE thing ].

; Used to ensure tag question agreement, but will not appear in LISZT.
have_aux_rel := v_event_rel & aux_event_rel.

; Needed to allow filtering of the relations for "will" and "would" for VIT.
will_would_rel :< aux_arg4_event_rel.

abstr_rel :< arg3_event_rel.

would_like_rel :< arg134_rel.

; AAC - added for frag-msg
abstr_3_rel := basic_nom_rel & arg3_rel.

; AAC - added for wh_adjective_word
abstr_nom_rel := event_arg_rel & basic_nom_rel.

; Needed for generation from German VITs
abstr_suit_rel :< arg13_rel.

prop_rel := event_rel &
	   [ PROP non_expl ].

; For copula "be", only for external interface (not used in grammar)
support_rel :< no_role_rel.

; Preposition relations

prep_rel := arg3_rel & event_dim_rel &
  [ ARG3 non_expl ].	    

basic_prep_mod_rel := prep_rel & event_arg_dim_rel.

prep_mod_rel :< basic_prep_mod_rel.
basic_poss_rel := basic_prep_mod_rel & [ EVENT.E.TENSE no_tense ].
poss_rel := basic_poss_rel & prep_mod_rel.
pro_poss_rel := basic_poss_rel & dofw_or_poss_rel.
_got_poss_rel :< poss_rel.


nontemp_prep_rel := prep_mod_rel & nontemp_rel.
loc_abstr_rel :< prep_mod_rel.
dir_or_state_rel := loc_abstr_rel & nontemp_prep_rel.
dir_rel :< dir_or_state_rel.
state_loc_rel :< dir_or_state_rel.
generic_loc_rel :< loc_abstr_rel.

temp_loc_abstr_rel :< loc_abstr_rel.
unspec_temp_loc_abstr_rel := temp_loc_abstr_rel & unspec_loc_rel.

miscprep_rel :< nontemp_prep_rel.

dir_indep_rel := dir_rel & independent_arg_rel.
miscprep_ind_rel := miscprep_rel & independent_arg_rel.
prep_mod_ind_rel := prep_mod_rel & independent_arg_rel.
dir_or_state_ind_rel := dir_or_state_rel & independent_arg_rel.
temp_loc_indep_rel := temp_loc_abstr_rel & independent_arg_rel.
temp_loc_rel :< temp_loc_indep_rel.

; DPF 25-Nov-01 - Added parent this_that_rel to allow "how much" partitive
part_of_rel := reg_diadic_nom_rel & gen_named_rel & this_that_rel.
diadic_noprep_nom_rel :< reg_diadic_nom_rel.
diadic_noarg_nom_rel :< reg_diadic_nom_rel.
;diadic_noarg_modable_nom_rel :< diadic_modable_nom_rel.
diadic_noarg_nom_appos_rel := reg_diadic_nom_rel & apposition_rel.

abstr_adv_rel := arg_rel & non_event_rel.

adv_rel := abstr_adv_rel & non_event_dim_rel & independent_arg_rel &
           this_that_rel.

neg_rel := abstr_adv_rel & independent_arg_rel.

basic_neg_polar_rel := abstr_adv_rel & non_event_dim_rel.
neg_polar_rel := basic_neg_polar_rel & independent_rel.

loc_rel :< dir_or_state_ind_rel.

; Used for implicit locative, as in "Kim arrived Tuesday"
unspec_loc_rel :< loc_rel.

_from_to_rel := miscprep_ind_rel & instance_rel.
_between_and_rel := miscprep_ind_rel & instance_rel.

interval_start_rel :< miscprep_ind_rel.
interval_end_rel := miscprep_ind_rel.

; For "how"
unspec_manner_rel :< miscprep_ind_rel.

; Degree relations

degree_rel := number_or_degree_rel & independent_rel & i_or_e_quant_or_deg_rel
              & event_or_degree_rel & 
  [ DARG thing ].

comp_degree_rel :< degree_rel.
non_comp_degree_rel :< degree_rel.

; For specifiers of adjectives
deg_rel :< non_comp_degree_rel.

; For specifiers of positive adjectives
very_deg_rel :< deg_rel.
eq_degree_rel := very_deg_rel & arg_rel & arg3_rel.

; For specifiers of "the", including "only" and "just"
just_only_degree_rel :< degree_rel.
just_only_very_deg_rel := just_only_degree_rel & very_deg_rel.
just_only_deg_rel := just_only_degree_rel & deg_rel.

_too_deg_rel :< very_deg_rel.

; For "how" degree specifier
abstr_deg_rel :< very_deg_rel.

; For specifiers of comparative adjectives
much_deg_rel :< deg_rel.

; For conjoined spr-less adjectives as in "sunny and cooler"
very_and_much_deg_rel := very_deg_rel & much_deg_rel.

; For e.g. 'eightish'
approx_grad_rel :< deg_rel.

; For syntactic rules (for indexing for generation)
gen_deg_rel :< deg_rel.

comparative_rel := comp_degree_rel &
  [ ARG-1 index,
    C-INST index ].

comp_more_less_rel := comparative_rel &
  [ ARG-2 index ].
more_sc_adv_rel :< comp_more_less_rel.
comp_less_rel :< comp_more_less_rel.

comp_most_least_rel := comparative_rel &
  [ C-SET handle ].

comp_most_rel :< comp_most_least_rel.
comp_least_rel :< comp_most_least_rel.

;; For "how" adjective, which quantifies over properties.

property_rel :< reg_nom_rel.

prpstn_to_prop_rel := prop_rel &
  [ PRPSTN handle,
    PROP non_expl-ind ].

_by_pass_rel_a :< miscprep_rel.
_by_pass_rel_cm := _by_pass_rel_a & selected_rel.
_from_time_on :< miscprep_ind_rel.
_compar_than_rel :< miscprep_ind_rel.
comp_rel := miscprep_ind_rel &
  [ ARG3 event_or_index,
    EVENT.E.TENSE no_tense ].
more_less_adj_rel :< adj_rel.
_more_adj_rel :< more_less_adj_rel.
_less_adj_rel :< more_less_adj_rel.
superl_rel := miscprep_ind_rel &
  [ ARG3 event_or_index ].
most_least_adj_rel :< adj_rel.
_most_adj_rel :< most_least_adj_rel.
_least_adj_rel :< most_least_adj_rel.
_as_comp_rel := miscprep_rel & selected_rel.


; Abstract relations, specialized below either to independent relations or to
; ones that appear in verb-particle constructions.
to_dir_rel :< dir_rel.
_to_rel_a :< to_dir_rel.
_for_rel_a :< miscprep_rel.
_by_rel_a :< miscprep_rel.
of_or_about_rel := prep_rel.
_of_rel_a := of_or_about_rel & nontemp_prep_rel.
_in_rel_a :< dir_or_state_rel.

subord_rel := nondim_rel & independent_rel &
  [ MAIN handle,
    SUBORD handle ].

cop_id_rel :< arg13_rel.
_cop_id_rel :< cop_id_rel.
title_id_rel := cop_id_rel & [ EVENT.E.TENSE no_tense ].
person_name_rel := cop_id_rel & [ EVENT.E.TENSE no_tense ].
temp_span_rel :< meas_adj_rel.
_equal_adj_rel :< adj_arg3_rel.
unspec_adj_rel :< adj_rel.
number_rel :< reg_diadic_nom_rel.
quantity_rel :< reg_diadic_nom_rel.
_be_prd_rel := v_event_rel & aux_event_rel.
_dollar_rel :< reg_nom_rel.

; Discourse functions

; ERB (03-10-96) In order to capture the similarities and differences
; between embedded and matrix questions, I am decomposing the ynq_rel
; into polar_q_rel and request_ans_rel.  The latter is probably 
; equivalent to the ne_rel (see below), but ne_rel is too cute to
; forgo for the tag questions and probably too opaque for the 
; matrix yn questions, so I will keep the two for now.  NB polar_q_rel
; probably doesn't qualify as 'discourse function'.  

; So, the ynq_root construction will contribute a polar_q_rel and
; a request_ans_rel, whether will contribute a polar_q_rel, and
; matrix wh questions will contribute a request_ans_rel.

polar_q_rel :< arg_rel.
request_ans_rel :< arg_rel.

polite_rel :< arg_rel.

; Phrasally introduced relations

unspec_rel := nondim_rel & event_rel &
  [ HINST index,
    NHINST index,
    EVENT.E.TENSE no_tense ].

; Used for vocatives.
unspec_mod_rel :< prep_mod_ind_rel.

; Relation introduced for tag questions

probable_rel :< adj_rel.

; DPF 24-Oct-01 - Added nontemp_rel and temp_abstr_rel so restrictions on the
; two reduced relative rules don't exclude conjoined phrases
basic_conj_rel := nondim_rel & non_freerel_rel & nontemp_or_conj_rel & 
            temp_abstr_or_conj_rel &
  [ C-ARG conj-ind,
    L-INDEX non_expl,
    R-INDEX non_expl ].

conj_rel := basic_conj_rel &
  [ L-HANDEL mod-thing,
    R-HANDEL mod-thing ].

_and_rel :< conj_rel.
_and_or_rel :< conj_rel.
_and_then_rel :< conj_rel.
_as_well_as_rel :< conj_rel.
_but_rel :< conj_rel.
_but_not_rel :< conj_rel.
_minus_coord_rel :< conj_rel.
_nor_rel :< conj_rel.
_or_rel :< conj_rel.
_plus_rel :< conj_rel.
_rather_than_rel :< conj_rel.
_so_conj_rel :< conj_rel.
_versus_rel :< conj_rel.

; For fragments

discourse_rel :< conj_rel. 

; Abstract relations specified by more than one lexical entry

abstr_place_rel := basic_diadic_modable_nom_rel & non_temp_nonpro_rel & 
  [ INST.SORT entity ].
place_rel := abstr_place_rel & abstr_named_rel.
time_rel := modable_rel & temp_abstr_rel.
telephone_rel :< reg_nom_rel.
person_rel :< reg_nom_rel.
thing_rel :< reg_nom_rel.
next_prev_rel :< adj_rel.
manner_rel :< reg_nom_rel.
reason_rel := reg_nom_rel & abstr_named_rel.
abstr_sure_rel := adj_arg4_rel.

title_rel := basic_nom_rel & const_value_rel &
  [ CONST_VALUE atom ].

; 'Next week, last night'
_next_rel := next_prev_rel & dofw_or_poss_rel.
_last_adj_rel := adj_rel & dofw_or_poss_rel.

v_event_arg3_rel := v_event_rel & arg3_rel & aux_event_rel &
  [ ARG3 non_expl-ind ].

_there_cop_rel :< v_event_arg3_rel.
_there_exist_rel :< v_event_arg3_rel.

; take into account
_account_n_rel :< diadic_noarg_nom_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Number relations

integer_rel := dim_rel & number_or_degree_rel & independent_arg_rel &
               gen_named_rel & event_rel &
  [ ARG individual ].

; DPF 10-Feb-02 - Highly experimental addition of EVENT attribute to get 
; segregation of numerical adjectives
const_rel := integer_rel &
  [ CONST_VALUE string].

plus_rel := integer_rel & [ TERM1 handle,
			    TERM2 handle].
times_rel := integer_rel & [ FACTOR1 handle,
			     FACTOR2 handle].

ord_rel :< const_rel.
card_rel :< const_rel.

minute_rel :< card_rel.

range_num_rel :< const_rel.


;; TYPES/SORTS
;; The ORDINAL feature determines whether its bearer is ordinal or not 
;; (i.e., is ordinal or cardinal).  Thus it is only appropriate for
;; numbers.  All numbers have a HEAD value of sort intsort, those
;; used adjectivally have heads of sort intadj (or one of its 
;; subsorts) or intdet (which has no subsorts).  Nominal uses are
;; not yet supported.
;;
;; Subcategorization, which is in terms of the maximum number of digits
;; allowed for the complement or specifier, is handled by the subsorts
;; of the digitn hierarchy.  Currently, only adjectives participate in
;; this hierarchy; there is only a single integer determiner ("one").
;; Nominal uses could be added by adding a type
;;          intnoun := intsort & digitn & noun.


intsort := head & [ORDINAL bool].

digitn :< head.

digit12 :< digitn.
digit9 :< digit12.
digit6 :< digit9.
digit3 :< digit6.
digit2 :< digit3.
digit1 :< digit2.

; The sorts    digitk    specify the number of digits of a lexeme 
; together with its largest complement and specifier.
; The sorts    digitk-    are used for subcategorization; they include
; values of k or fewer digits.
 
digit12- :< digitn.
digit9- :< digit12-.
digit6- :< digit9-.
digit3- :< digit6-.
digit2- :< digit3-.
digit1- :< digit2-.

;digit1 :< digit1-.
;digit2 :< digit2-.
;digit3 :< digit3-.
;digit6 :< digit6-.
;digit9 :< digit9-.

;; DPF 26-Apr-00 - Removed adj parent from intadj.
;; DPF 19-Sept-01 - Added supertype adj_or_intadj, for adj-intervals ("2 - 3")

intadj := intsort & strict_type & adj_or_intadj.
intadjn := intadj & digitn.
intdet := intsort & det.

; intadj1- := intadj1.
; intadjk- means an integer adjective of at most k digits (when
;   combined with specifier and complement

intadj12- :< intadj.
intadj12  := intadj12- & digit12.
intadj9- :< intadj.
intadj9  := intadj9- & digit9.
intadj6- :< intadj9-.
intadj6  := intadj6- & digit6.
intadj3- :< intadj6-.
intadj3  := intadj3- & digit3.
intadj2- :< intadj3-.
intadj2  := intadj2- & digit2.
intadj1  := intadj2- & digit1.

;;;;;;;;Extra stuff

; ERB (13-12-97) This type is meant as a PRO -- i.e., what can show
; up in such things as the 'way' construction and embedded infinitival
; wh questions.  It should eventually receive some binding properties,
; but I don't know what to put there yet, and since we don't have
; a binding theory...

; ERB (14-12-97) I am adding the pron_rel to pro_ss, so that in the
; types like common_noun_vpcomp_synsem I don't have to put it in.  I
; can just take the KEY.

; ERB (14-12-97) No pron_rel for pro_ss.

; ERB (14-12-97) ... and pro_ss is accusative, to block (once I get
; infinitival relatives working) *A person left came in.

; ERB (14-12-97) This is moved here so as to be after acc, which is a 
; *sort* and thus can't handle being referenced before it is defined.

; ERB (19-01-98) PRO is obligatorially OPT -.  This keeps to_c_prop
; from serving as a modifier without first building a non_wh_rel,
; because hadj requires SUBJ *olist*.

; ERB (21-01-98) In order for PRO to be extractable, it can't be
; SLASH 0-dlist, and thus can't be a subtype of unexpressed.  With
; PRO underspecified for SLASH, something will always have to fill
; in that value.  In the case of subject non_wh_rels (e.g., 
; "Kim found a person to fix the sink") it is extracted, i.e., resolved
; to gappro by extrasubj.  In the cases where the PRO is the subject of
; a selected complement, the selector will impose SLASH 0-dlist on the
; PRO (this case includes equi constructions, embedded infinitival
; wh questions, and the complement of 'way' as in "Kim found a way
; to leave early").  In the case of the (as yet unimplemented) CP[to]
; subjects, the NP -> CP rule will probably do the work.  Alternatively,
; the selecting category could do it.  Finally, in the case of
; non-subject non_wh_rels (e.g., "Kim found a cheeseburger to devour"),
; the PRO must be SLASH 0-dlist because the non_wh_rel_rule limits
; the SLASH list to length one.
;
; On a related note, we want the distribution of gappro (i.e., of
; extracted PRO) to be quite constrained, and perhaps even limited
; to the subject non_wh_rels.  In general, we are relying on the
; restriction of SLASH to lists of length one stated in several places
; in the grammar, in addition to certain selecting categories' specifying
; an empty value for SLASH on the PROs in their complements' subjects
; to keep us from getting in trouble on this one.
;
; Finally, rather than make a subtype of pro_ss that says SLASH 0-dlist,
; I have opted to include that information on the type *prolist*.

; ERB (03-23-98) We need a way to identify indices introduced by a PRO
; that are "discourse bound".  We were using PRONTYPE for this, but
; of course that doesn't work when the controller of the PRO is an overt
; pronoun.  So the new strategy is to make the INDEX a non_expl.
; This will unify with the indices introduced by (appropriate) controllers,
; and (hopefully) be identifiable if it is not controlled.

; DPF 27-May-99 - Removed OPT - constraint from pro_ss (see ERB (19-01-98) 
; above) since head_mod type now constrained via PRD rather than by requiring 
; SUBJ to be empty (cf note DPF 27-May-99 with n_adj_int_phrase in syntax.tdl).
; This change means the types for saturated subcats can again simply require 
; SUBJ to be *olist* rather than *null*, which e.g. allows verbal gerunds to 
; have optional but non-empty SUBJ value and still themselves appear as 
; subjects or complements without discharging that SUBJ value.

pro_ss := expressed_non_canonical &
  [ LOCAL.CAT.HEAD noun & [ CASE acc ],
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist ] ].

; ERB (19-01-98) We need a subtype of pro and gap so that to_c_prop
; can undergo subject extraction.  See the notes near non_wh_rel in
; syntax.tdl for the details of the analysis.
; I am positive that this will break something, but I could not
; guess what.

gappro := pro_ss & gap.

*olist* :< *list*.

*ocons* := *olist* & *cons* &
  [ FIRST unexpressed & [ OPT + ],
    REST  *olist* ].

*onull* := *olist* & *null*.


*gaplist* :< *list*.

*gapcons* := *gaplist* & *cons* &
  [ FIRST gap,
    REST  *null* ].

*gapnull* := *gaplist* & *null*.
*prolist* := *list*.

*procons* := *prolist* & *cons* &
  [ FIRST pro_ss &
	  [ NON-LOCAL.SLASH <! !> ],
    REST *null* ].

*pronull* := *prolist* & *onull*.

;; *unexplist* is used for common nouns whose specifier is possibly obligatory,
;; but unexpressed, as in noun-noun compounds.  As usual, we use the same hack
;; as for *olist*, to get around the lack of recursive types in TDL.

*unexplist* := *list*.

*unexpcons* := *unexplist* & *cons* &
  [ FIRST unexpressed,
    REST  *null* ].

;*unexpnull* := *unexplist* & *olist* & *null*.
*unexpnull* := *unexplist* & *onull*.

;; *substlist* is used in the adv_addition lexical rule, to prevent spurious
;; re-application of the rule to its own output by requiring the input to
;; be a (possibly empty) list of substantive synsems.
*substlist* :< *list*.

*substcons* := *substlist* & *cons* &
  [ FIRST.LOCAL.CAT.HEAD subst,
    REST  *substlist* ].

; For there-copula
*substocons* := *substcons* & *ocons*.

;*substnull* := *substlist* & *olist* & *null*.
*substnull* := *substlist* & *onull*.

;; *handlelist* is used in the treatment of free relatives, to disntinguish
;; the usual value of QUE from its use in free relatives, where QUE is instead
;; a list of referential indices.

*handlelist* := *list*.

*handlecons* := *handlelist* & 1-list &
  [ FIRST handle,
    REST  *null* ].

*handlenull* := *handlelist* & *onull*.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Selected-for relations in verb-particle constructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_to_rel_s := _to_rel_a & selected_rel.
; Case-marking "to" as with ditransitive "give"
_to_rel_cm :< _to_rel_s.
_to_rel := _to_rel_a & independent_rel.
_for_rel_s := _for_rel_a & selected_rel.
_for_rel := _for_rel_a & independent_rel.
_by_rel_s := _by_rel_a & selected_rel.
_by_rel := _by_rel_a & independent_rel.
_of_rel_s := _of_rel_a & selected_rel.
_of_rel := _of_rel_a & independent_rel.
_in_rel_s := _in_rel_a & selected_rel.
_in_rel := _in_rel_a & independent_rel.

_out_rel_a :< dir_rel.
_out_rel_s := _out_rel_a & selected_rel.
_out_rel := _out_rel_a & independent_rel.
_from_rel_a :< dir_rel.
_from_rel_s := _from_rel_a & selected_rel.
_from_rel := _from_rel_a & independent_rel.
_on_rel_a :< dir_or_state_rel.
_on_rel_s := _on_rel_a & selected_rel.
_on_rel := _on_rel_a & independent_rel.
_with_rel_a :< miscprep_rel.
_with_rel_s := _with_rel_a & selected_rel.
_with_rel := _with_rel_a & independent_rel.
_at_rel_a :< state_loc_rel.
_at_rel_s := _at_rel_a & selected_rel.
_at_rel := _at_rel_a & independent_rel.
_between_rel_a :< temp_loc_abstr_rel.
_between_rel_s := _between_rel_a & selected_rel.
_between_rel := _between_rel_a & independent_rel.
_about_rel_a := miscprep_rel & of_or_about_rel.
_about_rel_s := _about_rel_a & selected_rel.
_about_rel := _about_rel_a & independent_rel.
_as_to_rel_a :< miscprep_rel.
_as_to_rel_s := _as_to_rel_a & selected_rel.
_as_to_rel := _as_to_rel_a & independent_rel.
_over_rel_a :< dir_or_state_rel.
_over_rel_s := _over_rel_a & selected_rel.
_over_rel := _over_rel_a & independent_rel.
_under_rel_a :< dir_or_state_rel.
_under_rel_s := _under_rel_a & selected_rel.
_under_rel := _under_rel_a & independent_rel.
_against_rel_a :< miscprep_rel.
_against_rel_s := _against_rel_a & selected_rel.
_against_rel := _against_rel_a & independent_rel.
_among_rel_a :< miscprep_rel.
_among_rel_s := _among_rel_a & selected_rel.
_among_rel := _among_rel_a & independent_rel.
_before_i_rel_a :< miscprep_rel.
_before_i_rel_s := _before_i_rel_a & selected_rel.
_before_i_rel := _before_i_rel_a & independent_rel.
_up_rel_a := dir_rel.
_up_rel := _up_rel_a & selected_rel.
_up_rel_ind := _up_rel_a & independent_rel.
_forth_rel_a :< miscprep_rel.
_forth_rel_s := _forth_rel_a & selected_rel.
_forth_rel := _forth_rel_a & independent_rel.
_forward_rel_a :< miscprep_rel.
_forward_rel_s := _forward_rel_a & selected_rel.
_forward_rel := _forward_rel_a & independent_rel.
_off_rel_a :< dir_or_state_rel.
_off_rel_s := _off_rel_a & selected_rel.
_off_rel := _off_rel_a & independent_rel.
_onto_rel_a :< dir_rel.
_onto_rel_s := _onto_rel_a & selected_rel.
_onto_rel := _onto_rel_a & independent_rel.
_back_adv_rel_a :< miscprep_rel.
_back_adv_rel_s := _back_adv_rel_a & selected_rel.
_back_adv_rel := _back_adv_rel_a & independent_rel.
_down_rel_a :< dir_rel.
_down_rel_s := _down_rel_a & selected_rel.
_down_rel := _down_rel_a & independent_rel.
_across_rel_a :< dir_or_state_rel.
_across_rel_s := _across_rel_a & selected_rel.
_across_rel := _across_rel_a & independent_rel.
_around_loc_rel_a :< miscprep_rel.
_around_loc_rel_s := _around_loc_rel_a & selected_rel.
_around_loc_rel := _around_loc_rel_a & independent_rel.
_together_rel_a :< miscprep_rel.
_together_rel_s := _together_rel_a & selected_rel.
_together_rel := _together_rel_a & independent_rel.
_as_rel_a :< miscprep_rel.
_as_rel_s := _as_rel_a & selected_rel.
_as_rel := _as_rel_a & independent_rel.
_short_rel_a :< abstr_adj_rel.
_short_rel_s := _short_rel_a & selected_rel.
_short_rel := _short_rel_a & independent_rel.
_within_rel_a :< dir_or_state_rel.
_within_rel_s := _within_rel_a & selected_rel.
_within_rel := _within_rel_a & independent_rel.
_without_rel_a :< miscprep_rel.
_without_rel_s := _without_rel_a & selected_rel.
_without_rel := _without_rel_a & independent_rel.
_aside_rel_a :< miscprep_rel.
_aside_rel_s := _aside_rel_a & selected_rel.
_aside_rel := _aside_rel_a & independent_rel.
_ahead_rel_a :< miscprep_rel.
_ahead_rel_s := _ahead_rel_a & selected_rel.
_ahead_rel := _ahead_rel_a & independent_rel.
_away_adv_rel_a :< miscprep_rel.
_away_adv_rel_s := _away_adv_rel_a & selected_rel.
_away_adv_rel := _away_adv_rel_a & independent_rel.
_around_rel_a :< miscprep_rel.
_around_rel_s := _around_rel_a & selected_rel.
_around_rel := _around_rel_a & independent_rel.
_along_p_rel_a :< dir_or_state_rel.
_along_p_rel_s := _along_p_rel_a & selected_rel.
_along_p_rel := _along_p_rel_a & independent_rel.
_behind_rel_a :< dir_or_state_rel.
_behind_rel_s := _behind_rel_a & selected_rel.
_behind_rel := _behind_rel_a & independent_rel.
_after_prepx_rel_a :< temp_loc_abstr_rel.
_after_prepx_rel_s := _after_prepx_rel_a & selected_rel.
_after_prepx_rel := _after_prepx_rel_a & independent_rel.
_into_rel_a :< dir_rel.
_into_rel_s := _into_rel_a & selected_rel.
_into_rel := _into_rel_a & independent_rel.
_upon_rel_a :< state_loc_rel.
_upon_rel_s := _upon_rel_a & selected_rel.
_upon_rel := _upon_rel_a & independent_rel.
_apart_isect_rel_a :< abstr_adj_rel.
_apart_isect_rel_s := _apart_isect_rel_a & selected_rel.
_apart_isect_rel := _apart_isect_rel_a & independent_rel.
_open_rel_a :< abstr_adj_rel.
_open_rel_s := _open_rel_a & selected_rel.
_open_rel := _open_rel_a & independent_rel.
_until_rel_a :< prep_mod_rel.
_until_rel_s := _until_rel_a & selected_rel.
_until_rel := _until_rel_a & independent_rel.
_to_until_rel_a :< _until_rel_a.
_to_until_rel_s := _to_until_rel_a & _until_rel_s.
_to_until_rel := _to_until_rel_a & _until_rel.
_through_rel_a :< _until_rel_a.
_through_rel_s := _through_rel_a & _until_rel_s.
_through_rel := _through_rel_a & _until_rel.
_towards_rel_a :< dir_rel.
_towards_rel_s := _towards_rel_a & selected_rel.
_towards_rel := _towards_rel_a & independent_rel.
_toward_rel_a :< dir_rel.
_toward_rel_s := _toward_rel_a & selected_rel.
_toward_rel := _toward_rel_a & independent_rel.
_like_prepx_rel_a :< miscprep_rel.
_like_prepx_rel_s := _like_prepx_rel_a & selected_rel.
_like_prepx_rel := _like_prepx_rel_a & independent_rel.
_home_adv_rel_a :< miscprep_rel.
_home_adv_rel_s := _home_adv_rel_a & selected_rel.
_home_adv_rel := _home_adv_rel_a & independent_rel.
_near_p_rel_a :< dir_or_state_rel.
_near_p_rel_s := _near_p_rel_a & selected_rel.
_near_p_rel := _near_p_rel_a & independent_rel.
_out_of_rel_a :< miscprep_rel.
_out_of_rel_s := _out_of_rel_a & selected_rel.
_out_of_rel := _out_of_rel_a & independent_rel.

_yet_rel_a :< basic_neg_polar_rel.
_yet_rel_s := _yet_rel_a & selected_rel.
_yet_rel := _yet_rel_a & independent_rel.

_of_nbar_rel := miscprep_rel & independent_rel.

;;; these sorts are just used in the mrs-to-vit machinery


vmsort_anything :< *sort*.
vmsort_abstract :< vmsort_anything.
vmsort_property :< vmsort_abstract.
vmsort_field :< vmsort_abstract.
vmsort_info_content :< vmsort_abstract.
vmsort_institution :< vmsort_abstract.
vmsort_symbol :< vmsort_abstract.
vmsort_space_time :< vmsort_anything.
vmsort_temporal :< vmsort_space_time.
vmsort_situation :< vmsort_temporal.
vmsort_meeting_sit :< vmsort_situation.
vmsort_communication_sit :< vmsort_situation.
vmsort_action_sit :< vmsort_situation.
vmsort_move_sit :< vmsort_situation.
vmsort_position_sit :< vmsort_situation.
vmsort_temp_sit :< vmsort_situation.
vmsort_mental_sit :< vmsort_situation.
vmsort_time :< vmsort_temporal.
vmsort_entity :< vmsort_space_time.
vmsort_object :< vmsort_entity.
vmsort_agentive :< vmsort_object.
vmsort_human :< vmsort_agentive.
vmsort_animal :< vmsort_agentive. 
vmsort_thing :< vmsort_object.
vmsort_instrument :< vmsort_thing.
vmsort_info_bearer :< vmsort_thing.
vmsort_food :< vmsort_thing.
vmsort_vehicle :< vmsort_thing.
vmsort_substance :< vmsort_object.
vmsort_location :< vmsort_entity.
vmsort_geo_location :< vmsort_location.
vmsort_nongeo_location :< vmsort_location.

; Needed for underspecified "work" of "Kim works" and "Monday works"
work_unspec :< arg1_rel.

; Needed for idiosyncratic decomposition of "why"
cause :< miscprep_rel.

; Used for unknown word lexical entries

generic_verb_rel :< arg134_rel.
generic_noun_rel :< diadic_noarg_nom_rel.
generic_adj_rel :< adj_rel.
generic_adv_rel :< adv_rel.

; You'd never believe it if I told you.
_emailheaderdiv_rel := arg1_rel & [ ARGH thing ].
_ehkeywordersatz_rel :< reg_nom_rel.
_ehmodifierersatz_rel :< abstr_adv_rel.

; For verb spelled ":"
_colon_v_rel :< arg134_rel.

; For new lexical types

_here_rel :< adv_rel.
_now_rel :< adv_rel.
_there_rel :< adv_rel.
_today_rel :< adv_rel.
_tomorrow_rel := adv_rel & dofw_or_poss_rel.
_yesterday_rel := adv_rel & dofw_or_poss_rel.
_tonight_rel := adv_rel & dofw_or_poss_rel.

; IQT-specific relations
iqt_abstr_adj_rel :< abstr_adj_rel.
iqt_adj_arg3_rel :< adj_arg3_rel.
iqt_adj_arg4_rel :< adj_arg4_rel.
iqt_it_adj_arg24_rel :< it_adj_arg24_rel.
iqt_degree_rel :< degree_rel.
iqt_eq_degree_rel :< eq_degree_rel.
iqt_quant_or_wh_rel :< quant_or_wh_rel.
iqt_adv_rel :< adv_rel.
iqt_reg_diadic_nom_rel :< reg_diadic_nom_rel.
iqt_diadic_nom_rel :< diadic_nom_rel.
iqt_basic_prep_mod_rel :< basic_prep_mod_rel.
iqt_neg_rel :< neg_rel.
iqt_arg13_rel :< arg13_rel.
iqt_card_rel :< card_rel.
iqt_named_rel :< named_rel.
iqt_basic_hcomp_nom_rel :< basic_hcomp_nom_rel.
