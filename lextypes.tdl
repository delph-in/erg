;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-2002
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  lextypes.tdl
;;;
;;;  Lexical types (i.e., word classes)
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$

;:message "Lexical types".



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LEXICAL DEFAULTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nonslash := word &
  [ SYNSEM.NON-LOCAL.SLASH 0-dlist ].

; Lexical types that may have subtypes or instances with nonempty QUE values.

nonque := word &
  [ SYNSEM.NON-LOCAL.QUE 0-dlist ].  

nonrel := word &
  [ SYNSEM.NON-LOCAL.REL 0-dlist ].  

nonconj := word &
  [ SYNSEM.LOCAL.CONJ cnil ].

mcna := word &
  [ SYNSEM.LOCAL.CAT.MC na ].

nonmsg := word &
  [ SYNSEM.LOCAL.KEYS.MESSAGE 0-dlist ].

; Exceptions to this default include neg-contracted auxiliaries.
topkey := word &
  [ SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT.--TOPKEY #key ] ].

; Most words combine with their complements (if any) to produce a phrase,
; but a few, like "twenty" as in "twenty-two" and "five" as in "five o'clock",
; produce a sign which is still a word -- one with [ SYNSEM lex_synsem ].

hc-to-phr := word &
  [ SYNSEM.LOCAL.CAT.HC-LEX -* ].

basic_nontopkey := nonconj & nonslash & nonrel &
     	     mcna & non_affix_bearing.

; nontopkey_word's have all the defaults except topkey.
nontopkey := basic_nontopkey & nonque & nonmsg.

; hcons_amalg_word's have all the defaults EXCEPT non_affix_bearing,
; nonslash, nonrel, nonque.
basic_hcons_amalg_word := mcna &
	    nonconj &
	    nonmsg &
	    hc-to-phr &
  [ SYNSEM.LOCAL.KEYS.KEY.WLINK *cons* ].


hcons_amalg_word := basic_hcons_amalg_word & topkey.

basic_norm_word := hcons_amalg_word & nonque & nonslash & nonrel.

basic_norm_no_affix_word := basic_norm_word & non_affix_bearing.

; norm_word's have all the defaults except non_affix_bearing
norm_word := basic_norm_word &
  [ SYNSEM lex_synsem ].
	     
norm_no_affix_word := norm_word & non_affix_bearing.  

norm_mod_no_affix_word := nonconj & nonslash & nonrel & mcna & topkey &
		 non_affix_bearing &
   [ SYNSEM lex_synsem &
	    [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.KEYS.MESSAGE #msg ] >,
		      KEYS.MESSAGE #msg ] ] ].

norm_mod_nonque_no_affix_word := norm_mod_no_affix_word & nonque.

basic_mod_no_affix_notopkey_word := nonconj & nonslash & nonrel &
		 non_affix_bearing.

norm_mod_no_affix_notopkey_word := basic_mod_no_affix_notopkey_word &
   [ SYNSEM lex_synsem &
	    [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.KEYS.MESSAGE #msg ] >,
		      KEYS.MESSAGE #msg ] ] ].

; ERB (04-10-96) I have added nonmsg to the following types, as
; appropriate.

; que_word's have all the defaults EXCEPT nonque & topkey.
que_word := nonconj & non_affix_bearing &
	    mcna &
	    nonslash &
	    nonrel &
	    nonmsg &
	    hc-to-phr.

; rel_word's have all the defaults EXCEPT nonrel.
rel_word := nonque & non_affix_bearing &
	    mcna &
            nonslash &
	    nonconj &
	    nonmsg &
	    topkey &
	    hc-to-phr.

; ERB (04-10-96) msg_word's have all the defaults EXCEPT nonmsg, nonslash,
; mcna, and topkey.
msg_word := nonque & non_affix_bearing &
	    nonrel &
	    nonconj &
	    hc-to-phr.

norm_msg_word := msg_word & nonslash & mcna & topkey.

hcons_amalg_affixed_word := hcons_amalg_word & 
  [ INFLECTED - ].

hcons_amalg_non_affixed_word := hcons_amalg_word & non_affix_bearing.

amalg_word := mcna & 
	    nonconj &
	    nonmsg &
            non_affix_bearing &
	    topkey &
	    hc-to-phr.

msg_amalg_word := nonconj &
            non_affix_bearing &
	    topkey &
	    hc-to-phr.

; hc_word's repeat all the defaults EXCEPT hc-to-phr, which means they can 
; decide to build head_complement structures which are still words (with 
; [ SYNSEM lex_synsem ].  Also, they are not inherently themselves 
; [ SYNSEM lex_synsem ], so we don't use inheritance at the moment, but 
; replicate the inheritable properties, for an experiment.

hc_word := word_or_lexrule &
  [ SYNSEM [ LOCAL [ CAT.MC na,
		     CONT.--TOPKEY #key,
		     KEYS [ KEY #key & [ WLINK *cons* ],
			    MESSAGE 0-dlist ],
		     CONJ cnil ],
	     NON-LOCAL [ QUE 0-dlist,
			 REL 0-dlist,
			 SLASH 0-dlist ] ],
    ROOT -,
    POSSCL - ].

que_no_wlink_word := nonconj &
	    mcna &
	    nonslash &
	    nonrel &
	    nonmsg &
	    hc-to-phr &
  [ INFLECTED + ].

;;;;;
;; Non-local amalgmation types
;;

basic_zero_arg := synsem &
  [ LOCAL.ARG-S < >,
    NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

zero_arg := basic_zero_arg & lex_synsem &
  [ LOCAL.CONT.HCONS <! !> ].

basic_one_arg := canonical_synsem &
  [ LOCAL.ARG-S < [ NON-LOCAL [ SLASH #slash,
				REL #rel,
				QUE #que ],
		    LOCAL.CONT.HOOK.INDEX individual ] >,
    NON-LOCAL [ SLASH #slash,
		REL #rel,
		QUE #que ] ].

one_arg := basic_one_arg &
  [ LOCAL.CONT.HCONS <! !> ].

basic_two_arg := lex_synsem &
  [ LOCAL.ARG-S < [ NON-LOCAL [ SLASH [ LIST #smiddle,
					LAST #slast ],
				REL [ LIST #rmiddle,
				      LAST #rlast ],
				QUE [ LIST #qmiddle,
				      LAST #qlast ] ],
		    LOCAL.CONT.HOOK.INDEX individual ],
		  [ NON-LOCAL [ SLASH [ LIST #sfirst,
					LAST #smiddle ],
				REL [ LIST #rfirst,
				      LAST #rmiddle ],
				QUE [ LIST #qfirst,
				      LAST #qmiddle ] ],
		    LOCAL.CONT.HOOK.INDEX individual ] >,
    NON-LOCAL [ SLASH [ LIST #sfirst,
			LAST #slast ],
		REL [ LIST #rfirst,
		      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

two_arg := basic_two_arg &
  [ LOCAL.CONT.HCONS <! !> ].

basic_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NON-LOCAL [ SLASH [ LIST #smiddle2,
					  LAST #slast ],
				  REL [ LIST #rmiddle2,
					LAST #rlast ],
				  QUE [ LIST #qmiddle2,
					LAST #qlast ] ],
		      LOCAL.CONT.HOOK.INDEX individual ],
                    [ NON-LOCAL [ SLASH [ LIST #sfirst,
					  LAST #smiddle1 ],
				  REL [ LIST #rfirst,
					LAST #rmiddle1 ],
				  QUE [ LIST #qfirst,
					LAST #qmiddle1 ] ],
		      LOCAL.CONT.HOOK.INDEX individual ],
                    [ NON-LOCAL [ SLASH [ LIST #smiddle1,
					  LAST #smiddle2 ],
				  REL [ LIST #rmiddle1,
					LAST #rmiddle2 ],
				  QUE [ LIST #qmiddle1,
					LAST #qmiddle2 ] ],
		      LOCAL.CONT.HOOK.INDEX individual ] > ],
    NON-LOCAL [ SLASH [ LIST #sfirst,
			LAST #slast ],
		REL [ LIST #rfirst,
		      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

three_arg := basic_three_arg &
  [ LOCAL.CONT.HCONS <! !> ].

basic_four_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NON-LOCAL [ SLASH [ LIST #smiddle3,
					  LAST #slast ],
				  REL [ LIST #rmiddle3,
					LAST #rlast ],
				  QUE [ LIST #qmiddle3,
					LAST #qlast ] ],
		      LOCAL.CONT.HOOK.INDEX individual ],
		    [ NON-LOCAL [ SLASH [ LIST #sfirst,
					  LAST #smiddle1 ],
				  REL [ LIST #rfirst,
					LAST #rmiddle1 ],
				  QUE [ LIST #qfirst,
					LAST #qmiddle1 ] ],
		      LOCAL.CONT.HOOK.INDEX individual ],
		    [ NON-LOCAL [ SLASH [ LIST #smiddle1,
					  LAST #smiddle2 ],
				  REL [ LIST #rmiddle1,
					LAST #rmiddle2 ],
				  QUE [ LIST #qmiddle1,
					LAST #qmiddle2 ] ],
		      LOCAL.CONT.HOOK.INDEX individual ],
		    [ NON-LOCAL [ SLASH [ LIST #smiddle2,
					  LAST #smiddle3 ],
				  REL [ LIST #rmiddle2,
					LAST #rmiddle3 ],
				  QUE [ LIST #qmiddle2,
					LAST #qmiddle3 ] ],
		      LOCAL.CONT.HOOK.INDEX individual ] > ],
    NON-LOCAL [ SLASH [ LIST #sfirst,
			LAST #slast ],
		REL [ LIST #rfirst,
		      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

four_arg := basic_four_arg &
  [ LOCAL.CONT.HCONS <! !> ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBCATEGORIZATIONS -- synsems for verbs, adjectives, prepositions, nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nomod_local := local &
  [ CAT.HEAD.MOD < > ].

nomod_synsem := lex_synsem &
  [ LOCAL.CAT [ HEAD.MOD < >,
		VAL.SUBJ < > ] ].

scopal_mod :< local_min.
intersective_mod :< local_min.

scopal_mod_local := scopal_mod & local.
int_mod_local := intersective_mod & local.

; DPF 27-May-99 - Changed [MC na] in NOMP_CAT to [MC na_or_-] to allow 
; acc-verbal-gerunds to be NP complements, even though they are built via the 
; head_subj rule.
; DPF 18-Nov-99 - Removed PRD + since this prevented e.g. "ten past five" where
; "ten" is [PRD -], and "past" requires a nomp_cat specifier.
; DPF 07-Jan-01 - We would like to capture the generalization that nominal
; phrases which have been assigned case (nominative or accusative) must also
; be [ MESSAGE 0-dlist ] to block, e.g., spurious analyses for verbal gerunds
; which have been built via the subj-head rule.  But for now have to stipulate
; this for each occurrence in subcats.
; DPF 21-Mar-01 - Made COMPS for nomp_cat be < > rather than *olist* to avoid
; spurious ambiguity for partitives, as in "some arrived", since they have to
; undergo the n_optcomp pumping rule in order to be able to take a specifier
; as in "almost all arrived".
; DPF 20-Dec-01 - Added SPEC < > in nomp_cat to exclude measure-NPs.
; DPF 8-Feb-02 - But this prevents NPs from ever being specifiers (given the
; constraint on SPR..SPEC in the h-spec rule.  So remove this constraint, and
; try to remember the examples that were supposed to be excluded.
; DPF 20-May-02 - Why MOOD on nomp_cat?
; DPF 27-Oct-02 - Would like to say about all nomp's that they are 
; [DIVISIBLE strict_sort], as we've already been doing (asymmetrically) for
; verbs' subjects for a while now, to avoid spurious ambiguity for e.g.
; "Fridays are inconvenient",  thus extending this to other uses of NPs.
; But AGR.DIVISIBLE is not in CAT, so we can't, and we have to replicate this
; constraint everywhere, as we've already had to do for [CONJ cnil].  Maybe
; a better approach could be found, maybe with defaults?
; DPF 4-Nov-02 - Added MOD < > since we can no longer distinguish modnp guys
; (output of temp_mod rule) by their having a non-empty SUBJ.

nomp_cat_min :< cat_min.

nomp_cat := nomp_cat_min & cat &
  [ HEAD nominal & strict_type &
	 [ POSS -,
           MOD < >,
	   TAM.MOOD ind_or_mod_subj ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS < > ],
    MC na_or_- ].

; DPF (8-Jan-99) Added accusative and nominative subtypes of nomp_cat, since 
; nominative ones are not 'mobile' - see fundamentals.tdl

nomp_cat_nom_min :< nomp_cat_min.
nomp_cat_acc_min :< nomp_cat_min.

nomp_cat_nom := nomp_cat_nom_min & nomp_cat &
  [ HEAD.CASE nom ].

nomp_cat_acc := nomp_cat_acc_min & nomp_cat &
  [ HEAD mobile & [ CASE acc ] ].

np_cat_nom_min :< nomp_cat_nom_min.
np_cat_acc_min :< nomp_cat_acc_min.

np_cat_nom := nomp_cat_nom & np_cat_nom_min &
  [ HEAD noun ].

np_cat_acc := nomp_cat_acc & np_cat_acc_min &
  [ HEAD noun ].

;; DPF (30-Apr-98) In saturated phrase subcats, SUBJ must be < >, not *olist*,
;; since we need to have SUBJ < > unify with the filler in filler_head phrases,
;; and the filler is constrained to be SUBJ *prolist* which has a distinct 
;; synsem type (pro_ss) which is constrained to be [OPT -].
;; DPF 27-May-99 - Having eliminated the need for *prolist* to be OPT -, we
;; can now make saturated phrases require SUBJ to be *olist* rather than < >, 
;; which means verbal gerunds can have an optional SUBJ but still themselves 
;; be subjects or complements.
;; DPF (28-Jul-98) Added MOD < > to exclude non-finite relative clauses, which
;; are otherwise not distinguishable from nomp's.  Maybe also needed to 
;; exclude the second (modifier) entries for temporal NPs like "Tuesday".
;; DPF 09-Jun-99 - Removed MOD < > (see above), since relative clauses are now
;; all marked with non-empty REL, and because this constraint was falsely 
;; blocking "one to three pm" as an NP complement, because it has a 
;; non-empty MOD.

s_cat_unspec := cat &
  [ HEAD verbal & strict_type,
    VAL [ SUBJ *olist*,
	  COMPS *olist* ] ].

s_cat_v_c := s_cat_unspec &
  [ HEAD.INV -,
    VAL.SPR *olist*,
    MC - ].

s_cat_fin_or_inf_unspec := s_cat_unspec &
  [ HEAD [ VFORM fin_or_inf,
           TAM basic_ind_or_mod_subj_tam ] ].

s_cat_fin_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD [ VFORM fin,
           TAM ind_or_mod_subj_tam &
                 [ TENSE real_tense ] ] ].

s_cat_inf_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD.VFORM inf ].

s_cat_fin_or_inf_v_c := s_cat_v_c & s_cat_fin_or_inf_unspec &
  [ HEAD.TAM.MOOD ind_or_mod_subj & strict_sort ].

s_cat_fin_v_c := s_cat_v_c & s_cat_fin_unspec &
  [ HEAD.TAM.MOOD ind_or_mod_subj & strict_sort ].

s_cat_inf_v_c := s_cat_v_c & s_cat_inf_unspec &
  [ HEAD.TAM.MOOD ind_or_mod_subj & strict_sort ].

; Removed HEAD comp, to allow "I demand he be here"
s_cat_bse := s_cat_v_c &
  [ HEAD.VFORM bse ].

s_cat := s_cat_unspec &
  [ HEAD verb ].

s_cat_fin := s_cat & s_cat_fin_unspec &
  [ HEAD.INV -,
    MC + ].

s_cat_fin_or_imp := s_cat &
  [ HEAD [ VFORM fin_or_imp,
	   TAM.MOOD ind_or_mod_subj ],
    MC + ].

n_or_v_cat := cat &
  [ HEAD nominal_or_verbal & strict_type,
    VAL [ SPR < synsem_min & [ LOCAL.KEYS.KEY quant_or_deg_rel ] >,
          COMPS *olist* ] ].

vp_cat := n_or_v_cat &
  [ HEAD verbal &
	 [ INV - ],
    VAL.SUBJ < synsem_min & [ NON-LOCAL [ SLASH 0-dlist,
                                          REL 0-dlist,
                                          QUE 0-dlist ] ] >,
    MC na ].

vp_inf_cat := vp_cat &
  [ HEAD [ VFORM inf,
	   PRD - ] ].

vp_bse_unspec_cat := vp_cat &
  [ HEAD verb &
	 [ VFORM bse_only,
	   PRD - ] ].

; DPF 19-Oct-02 - Changed MOOD from indicative to indicative* to
; allow coord of "I will stay so you should leave"
vp_bse_cat := vp_bse_unspec_cat &
  [ HEAD.TAM.MOOD indicative* ].

; DPF 10-Jun-99 - Removed MOD < > (cf note in templates.tdl)
; DPF 11-Jul-99 - Added restriction that SPR be [HEAD det] to prevent 
; adjectives from modifying partitives and odd nouns like hour_prep words.
; DPF 28-Aug-99 - Removed SPR: OPT - to allow relative clauses to modify
; generic-pro's like "anything" and still have the result look like an NP.
; DPF 10-May-01 - Removed [SPR..HEAD det] to allow modifiers of generic_pro
; entries as in "everyone important to me"
; DPF 2-Nov-01 - Added SPR < synsem > to exclude "happy here" with n_adv "here"

nbar_cat := n_or_v_cat &
  [ HEAD noun_or_nomger &
	 [ POSS - ],
    VAL [ SUBJ < >,
          SPR < synsem >,
          COMPS < > ],
    MC na ].

adverbee_cat := cat &
  [ HEAD adverbee & strict_type ].

; DPF 4-Nov-02 - Added MOD < synsem_min > to block NPs, now that we don't have
; presence of SUBJ synsem on all predicative phrases.
basic_prd_cat := cat &
  [ HEAD strict_type & 
         [ PRD +,
           MOD < synsem_min > ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS *olist* ],
    MC na ].

prd_cat := basic_prd_cat &
  [ HEAD.TAM.TENSE no_tense ].

pp_cat := cat &
  [ HEAD prep_or_modnp & [ PRD - ],
		  VAL [ SPR *olist*,
			COMPS < > ],
    MC na ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Linking Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Linking types specify the relationship between valence positions and 
;; semantic roles.

linking_type :< lex_synsem.

atrans_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local_min &
				   [ CONT.HOOK.INDEX it-ind & #subjind ] ] >,
            CONT.HOOK.XARG #subjind,
	    KEYS.KEY no_role_rel ] ].

arg1_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local_min &
				   [ CONT.HOOK.INDEX #subjind & non_expl-ind,
                                     KEYS.KEY nom_rel,
                                     AGR.DIVISIBLE strict_sort ] ] >,
            CONT.HOOK.XARG #subjind,
	    KEYS.KEY arg1_rel & [ ARG1 #subjind ] ] ].

unacc_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local_min & 
                                   [ CONT.HOOK.INDEX #subjind & 
                                                     non_expl-ind,
                                     AGR.DIVISIBLE strict_sort ] ] >,
            CONT.HOOK.XARG #subjind,
            KEYS.KEY arg2_event_rel & [ ARG2 #subjind ] ] ].

arg12_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS 
                    < [ LOCAL local_min &
                            [ CONT.HOOK.INDEX #objind & non_expl-ind ]], ... >,
            KEYS.KEY arg12_rel & [ ARG2 #objind ] ] ].

trans_lt :< arg12_lt.

arg12h_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				    [ KEYS [ KEY event_rel,
					     MESSAGE 1-dlist ],
				      CONT.HOOK.LTOP #mhand ] ], ... >,
	    KEYS.KEY arg12_rel & [ ARG2 #mhand ] ] ].

; "suppose" which makes its KEY same as its complement's KEY
; - wouldn't need this if had defaults

alt_arg12_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local_min &
				    [ CONT.HOOK.INDEX #subjind & 
                                                      non_expl-ind ] ] >,
		      COMPS < [ LOCAL local_min &
				      [ KEYS [ KEY event_rel,
					       MESSAGE 1-dlist ],
					CONT.HOOK.LTOP #mhand ] ], ... > ],
            CONT.HOOK.XARG #subjind,
	    KEYS.ALTKEY arg12_rel & [ ARG1 #subjind,
				      ARG2 #mhand ] ] ].

; Maybe only for main verb "have" and for possessive "got"

poss_lt := linking_type &         
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local_min &
				     [ CONT.HOOK.INDEX #subjind & ref-ind ]] >,
		      COMPS 
                       < [ LOCAL local_min &
                              [ CONT.HOOK.INDEX #objind & ref-ind ] ], ... > ],
	    CONT [ HOOK.XARG #subjind,
                   RELS <! arg12_rel & 
                         [ ARG1 #subjind,
                           ARG2 #objind ] !> ] ] ].

expl_obj_lt := arg1_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL local_min & 
                                  [ CONT.HOOK.INDEX it-ind ] ], ... > ].

expl_obj_cp_lt := expl_obj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    [ LOCAL local_min &
				    [ KEYS.MESSAGE 1-dlist,
				      CONT.HOOK.LTOP #mhand ] ],
			    ... >,
	    KEYS.KEY arg12_rel & [ ARG2 #mhand ] ] ].

particle_cp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL local_min &
				      [ KEYS [ KEY event_rel,
					       MESSAGE 1-dlist ],
					CONT.HOOK [ LTOP #mhand,
                                                    XARG #xarg ] ] ], ... >,
	    KEYS.KEY arg12_rel & [ ARG2 #mhand,
                                   ARG0 #xarg ] ] ].

; DPF 19-Oct-02 - Removed SORT entity from second COMPS, since want to
; allow "that gives me an hour"
ditrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
                  < [ LOCAL local_min &
                           [ CONT.HOOK.INDEX #obj2ind & non_expl-ind &
                                        [ SORT entity ] ] ], 
                    [ LOCAL local_min &
                           [ CONT.HOOK.INDEX #objind & non_expl-ind ] ], ... >,
            KEYS.KEY arg123_rel & [ ARG2 #objind,
                                    ARG3 #obj2ind ] ] ].

tritrans_lt := ditrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, *top*, 
			    [ LOCAL local_min &
				 [ KEYS [ KEY v_event_rel,
					  MESSAGE 1-dlist ],
				   CONT.HOOK.LTOP #mhand ] ],
				... >,
	    KEYS.KEY arg1234_rel & [ ARG4 #mhand ] ] ].

basic_prep_intrans_lt := linking_type &
  [ LOCAL [ CAT.VAL.COMPS 
			< [ LOCAL local_min &
				  [ CAT.HEAD.TAM.TENSE no_tense,
                                    KEYS.KEY prep_rel & independent_rel,
				    CONT.HOOK.INDEX #index ] ],
			  ... >,
	    CONT [ HOOK.INDEX #index,
		   RELS.LIST < #key, ... > ],
	    KEYS.KEY #key ] ].

prep_intrans_unerg_lt := basic_prep_intrans_lt & arg1_subj_lt.
prep_intrans_lt := prep_intrans_unerg_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
            CONT [ HOOK.LTOP #ltop,
                   RELS <! relation !> ] ] ].
prep_intrans_unacc_lt := basic_prep_intrans_lt & unacc_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
            CONT [ HOOK.LTOP #ltop,
                   RELS <! relation !> ] ] ].
prep_intrans_nosubj_lt := prep_intrans_unerg_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
            KEYS.KEY.LBL #ltop ] ].

;; DPF 14-Sept-00 - This type does not conform to our assumption that only 
;; handles, indices, and external arguments of COMPS synsems can be referred 
;; to in semantic construction.  But we believe we have a better analysis on 
;; the way which collapses these collocation constructions into a more general
;; account of multi-word expressions, so we allow the hack for now.

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

empty_prep_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				      [ KEYS.KEY prep_rel & selected_rel &
						     [ ARG2 #objind ],
					CONT.HOOK.LTOP #ltop ] ], ... >,
	    CONT.HOOK.LTOP #ltop,
	    KEYS.KEY arg12_rel & [ ARG2 #objind ] ] ].
		   

; Argument coercion as in "Kim suggests on Friday"
prep_intrans_event_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			 < [ LOCAL local_min &
				   [ CAT.HEAD.TAM.TENSE no_tense,
                                     KEYS.KEY prep_rel & independent_rel,
				     CONT.HOOK [ LTOP #ltop,
                                                 INDEX #event ] ] ], ... >,
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #key !> ],
	    KEYS.KEY #key & arg12_rel & [ ARG2 #event ] ] ].

basic_prep_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ LOCAL local_min &
				    [ CAT.HEAD [ MOD < synsem_min >,
                                                 TAM.TENSE no_tense ],
				      KEYS.KEY prep_rel & independent_rel ] ],
                            ... >,
            CONT.RELS.LIST < #key, ... >,
            KEYS.KEY #key ] ].

prep_trans_lt := basic_prep_trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #objind ], 
                            [ LOCAL.CONT.HOOK [ LTOP #cltop,
                                                INDEX #objind ] ], ... >,
            CONT [ RELS <! relation, prpstn_rel & [ LBL #hand,
                                                    MARG #arghand ] !>,
                   HCONS <! qeq & [ HARG #arghand,
                                    LARG #cltop ] !> ],
            KEYS.KEY arg123_rel & [ ARG3 #hand ] ] ].

; buy from
prep_trans_nomsg_lt := basic_prep_trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ LOCAL.CONT.HOOK [ LTOP #cltop,
                                                INDEX #index ] ], ... >,
            CONT [ HOOK [ LTOP #cltop,
                          INDEX #index ],
                   RELS <! relation !>,
                   HCONS <! !> ] ] ].

; See discussion of empty_prep_intrans_lt above
;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

empty_prep_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL local_min &
				       [ KEYS.KEY prep_rel & selected_rel &
						      [ ARG2 #objind ],
					 CONT.HOOK.LTOP #ltop ] ], ... >,
	    CONT.HOOK.LTOP #ltop,
	    KEYS.KEY arg123_rel & [ ARG3 #objind ] ] ].
		   
empty_prep_nbar_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nltop,
                                                INDEX #ninst ] ],
                            [ LOCAL local_min &
				       [ KEYS.KEY prep_rel & selected_rel &
						      [ ARG2 #objind ],
					 CONT.HOOK.LTOP #ltop ] ], ... >,
	    CONT [ HOOK.LTOP #ltop,
                   RELS <! relation, udef_rel & [ RSTR #rhand,
                                                  ARG0 #ninst ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nltop ] !> ],
            KEYS.KEY arg123_rel & [ ARG3 #objind ] ] ].

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

basic_prep_particle_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL local_min &
					 [ CAT.HEAD.TAM.TENSE no_tense,
                                           KEYS.KEY prep_rel & [ ARG2 #arg2 ],
                                           CONT.HOOK [ LTOP #ltop,
                                                       XARG #event ] ]], ... >,
	    CONT.HOOK.LTOP #ltop,
	    KEYS.KEY arg12_rel & [ ARG0 #event,
				   ARG2 #arg2 ] ] ].
		   
prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.KEYS.KEY independent_rel ] > ].

empty_prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.KEYS.KEY selected_rel ] > ].

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

prep_particle_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            synsem &
                              [ LOCAL [ CONT.HOOK [ LTOP #ltop,
                                                    XARG #event ],
                                        KEYS.KEY selected_rel ] ], 
                            synsem &
			      [ LOCAL local_min & 
                                      [ CAT.HEAD.TAM.TENSE no_tense,
                                        KEYS.KEY prep_rel & independent_rel &
                                                 [ ARG1 #event ],
                                        CONT.HOOK.LTOP #ltop ] ], ... >,
            CONT.HOOK [ LTOP #ltop,
                        INDEX #event ] ] ].
		   
cp_trans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
			    [ LOCAL local_min &
				 [ KEYS [ KEY event_rel,
					  MESSAGE 1-dlist ],
				   CONT.HOOK.LTOP #mhand ] ], 
			    ...>,
	    KEYS.KEY arg123_rel & [ ARG3 #mhand ] ] ].

; "explain to Kim that ..."
pp_cp_lt := empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*,
			    [ LOCAL local_min &
				  [ KEYS [ KEY event_rel,
					   MESSAGE 1-dlist ],
				    CONT.HOOK.LTOP #mhand ] ],
			    ... >,
	    KEYS.KEY arg123_rel & [ ARG3 #mhand ] ] ].

double_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				    [ CAT.HEAD.TAM.TENSE no_tense,
                                      KEYS.KEY prep_rel & independent_rel,
				      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #event ] ] ], 
			    [ LOCAL local_min &
				    [ CAT.HEAD.TAM.TENSE no_tense,
                                      KEYS.KEY prep_rel & independent_rel,
                                      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #event ] ] ], ... >,
	    CONT.HOOK [ LTOP #ltop,
                        INDEX #event ] ] ].

double_pp_empty_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				    [ CAT.HEAD.TAM.TENSE no_tense,
                                      KEYS.KEY prep_rel & independent_rel,
				      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #event ] ] ], 
			    [ LOCAL local_min &
				    [ CAT.HEAD.TAM.TENSE no_tense,
                                      KEYS.KEY prep_rel & selected_rel &
                                                         [ ARG2 #objind ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #event ] ] ], ... >,
            CONT.HOOK [ LTOP #ltop,
                        INDEX #event ],
            KEYS.KEY.ARG2 #objind ] ].

arg12_double_pp_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ LOCAL local_min &
				    [ CAT.HEAD.TAM.TENSE no_tense,
                                      KEYS.KEY prep_rel & independent_rel,
				      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #event ] ] ], 
			    [ LOCAL local_min &
				    [ CAT.HEAD.TAM.TENSE no_tense,
                                      KEYS.KEY prep_rel & independent_rel,
                                      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #event ] ] ], ... >,
	    CONT.HOOK [ LTOP #ltop,
                        INDEX #event ] ] ].

s_equi_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local_min &
				   [ CONT.HOOK.INDEX #index & ref-ind ] ] >,
            CONT.HOOK.XARG #index,
	    KEYS.KEY arg12_rel & [ arg1 #index ] ] ].
		   

equi_prd_lt := linking_type & 
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL [ KEYS.KEY independent_rel,
				      CONT.HOOK.E-INDEX #event ],
	    CONT.RELS <! relation !>,
	    KEYS.KEY.ARG2 #event ] ].

; ERB (14-12-97) Subj_equi verbs now require that their complement have
; a pro_ss subject.  This might be redundant if some other supertype of
; all equi verbs requires prpstn_rel on the complement.

; ERB (21-01-98) This pro_ss needs to be constrained to be unslashed.

subj_equi_lt := s_equi_lt &
  [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #index ] >,
		    --KEYCOMP.LOCAL local_min &
				    [ CONT.HOOK.XARG #index ] ] ].

; 'try to leave'
subj_equi_inf_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL local_min &
				    [ KEYS.MESSAGE 1-dlist & 
                                                   <! propositional_rel !>,
                                      CAT.VAL.SUBJ < pro_ss >,
				      CONT.HOOK.LTOP #hand ],
	    KEYS.KEY.ARG2 #hand ] ].

subj_equi_prp_or_bse_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL local_min &
				    [ CONT.HOOK.LTOP #hand ],
	    CONT [ RELS <! relation, prpstn_rel & [ LBL #chand,
                                                    MARG #shand ] !>,
                   HCONS <! qeq &
			   [ HARG #shand,
			     LARG #hand ] !> ],
	    KEYS.KEY.ARG2 #chand ] ].

; ERB (14-12-97) comp's subj is a pro_ss.  This is probably redundant since
; the to_c_prop will say that its subject is a pro_ss.

; ERB (21-01-98) The pro_ss needs to be constrained to be unslashed.

; 'persuade Kim to leave'
obj_equi_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL local_min &
				    [ CONT.HOOK.INDEX #index & non_expl-ind ] ],
			      #comp &
			      [ LOCAL local_min &
				      [ CONT.HOOK.XARG #index ] ]>,
                      --KEYCOMP #comp ],
	    KEYS.KEY arg123_rel & [ ARG2 #index ] ] ].

; 'persuade Kim to leave'
obj_equi_inf_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL local_min &
				    [ CAT.VAL.SUBJ 
					 < pro_ss &
                                           [ NON-LOCAL.SLASH 0-dlist ] >,
                                        CONT.HOOK.LTOP #hand,
				      KEYS.MESSAGE 1-dlist ],
	    KEYS.KEY.ARG3 #hand ] ].

prd_comp_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT nom-obj & [ HOOK.INDEX #subjind ]] >,
		      --KEYCOMP.LOCAL [ CONT.HOOK.LTOP #chand,
                                        KEYS.KEY independent_rel ] ],
            CONT [ HOOK.XARG #subjind,
                   RELS <! #key, prpstn_rel & #alt2key & [ MARG #marg ] !>,
		   HCONS <! qeq & [ HARG #marg,
                                    LARG #chand ] !> ],
	    KEYS [ KEY #key,
                   ALT2KEY #alt2key ] ] ].

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				     [ KEYS.KEY.ARG2 #arg2 ] ],
			   [ LOCAL local_min &
				     [ CONT.HOOK.LTOP #hand ] ] >,
	   KEYS.KEY arg123_rel & [ ARG2 #arg2,
				   ARG3 #hand ] ] ].

; 'consider Kim wise'

obj_equi_prd_lt := prd_comp_lt & obj_equi_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				  [ KEYS.KEY basic_nom_rel,
				    CONT.HOOK.INDEX #index ] ],
                            [ LOCAL local_min &
				  [ CONT.HOOK.XARG #index ] ] >,
            KEYS [ KEY.ARG3 #arghand,
                   ALT2KEY.LBL #arghand ] ] ].

; 'promise Kim to leave'
anom_equi_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL 
		   [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #subjind ] >,
		     COMPS < [ LOCAL local_min &
				[ CONT.HOOK [ LTOP #ltop,
                                              INDEX #objind & non_expl-ind ]]],
			     [ LOCAL local_min &
				[ CAT.VAL.SUBJ < pro_ss &
						 [ NON-LOCAL.SLASH 0-dlist ] >,
				  KEYS.MESSAGE 1-dlist,
				  CONT.HOOK [ LTOP #hand,
                                              XARG #subjind ] ] ] > ],
	    CONT.HOOK.LTOP #ltop,
	    KEYS.KEY arg123_rel &
		    [ ARG3 #hand,
		      ARG2 #objind ] ] ].

; 'turn out unreliable' (also resultatives like 'turned up drunk')
anom_equi_prd_lt := equi_prd_lt & s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #chand,
                                             INDEX #index ] ] >,
                  --KEYCOMP #comp,
		  COMPS < *top*,
			  #comp &
			  [ LOCAL local_min &
				  [ CONT.HOOK [ LTOP #chand,
                                                XARG #index ] ] ] > ] ] ].

                                                     

; 'turn out to be red'
anom_equi_particle_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ LOCAL.CONT.HOOK.INDEX #index ] >,
		  COMPS < *top*,
			  [ LOCAL local_min &
				  [ CAT.VAL.SUBJ < pro_ss &
						   [ NON-LOCAL.SLASH 0-dlist]>,
				    KEYS.MESSAGE 1-dlist,
				    CONT.HOOK [ LTOP #hand,
                                                XARG #index ] ] ] > ],
	    KEYS.KEY.ARG2 #hand ] ].

basic_ssr_expr_lt := linking_type &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT.HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !>,
	    KEYS.KEY arg12_event_rel & [ ARG2 #arghand ] ] ].

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

ssr_expr_lt := basic_ssr_expr_lt &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp,
		      COMPS < [ LOCAL.KEYS.KEY.ARG2 #arg ], 
			      #comp, ... > ],
	    KEYS.KEY.ARG1 #arg ] ].

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

ssr_prdp_expr_lt := basic_ssr_expr_lt &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT nom-obj & [ HOOK.INDEX #subjind ]] >,
                      --KEYCOMP #comp,
                      COMPS < #comp,
                              [ LOCAL [ KEYS.KEY _to_rel_s &
                                                 [ ARG2 #arg ],
                                        CONT.HOOK.LTOP #ltop ] ],
                              ... > ],
            CONT [ HOOK [ LTOP #ltop,
                          XARG #subjind ],
		   RELS <! #key !> ],
	    KEYS.KEY #key & [ ARG1 #arg & non_expl-ind ] ] ].

sor_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local_min &
				     [ CONT.HOOK.INDEX #index ] ] >,
                      COMPS < synsem & [ LOCAL local_min ], 
                              [ LOCAL local_min &
                                      [ CONT.HOOK.LTOP #chand ] ] > ],
	    CONT [ HOOK.XARG #index,
                   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !> ],
	    KEYS.KEY arg12_rel & [ ARG2 #arghand,
				   ARG1 #index ] ] ].

expl_it_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local_min & [ CONT.HOOK 
                                                     [ LTOP #hand,
                                                       INDEX it-ind & 
                                                             #subjind ] ] ] >,
                      COMPS < synsem, #comp, ... >,
		      --KEYCOMP #comp & 
			   [ LOCAL local_min &
				   [ KEYS.MESSAGE 1-dlist,
				     CONT.HOOK.LTOP #chand ] ] ],
	    CONT [ HOOK.XARG #subjind,
                   HCONS <! !> ],
	    KEYS.KEY basic_arg1_rel &
		    [ LBL #hand,
		      ARG1 #chand ] ] ].

expl_it_subj_np_cp_lt := expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
                                    [ CONT.HOOK.INDEX #arg2 ] ], ... >,
            KEYS.KEY arg12_event_rel &
		    [ ARG2 #arg2 ] ] ].

expl_it_subj_pp_cp_lt := expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
                                    [ KEYS.KEY.ARG2 #arg ] ], ... >,
            KEYS.KEY arg12_event_rel &
		    [ ARG2 #arg ] ] ].

expl_it_subj_prtcl_cp_lt := expl_it_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

expl_pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL local_min &
				     [ CONT.HOOK.INDEX it-ind ] ],
			       [ LOCAL local_min &
				     [ KEYS.KEY.ARG2 #arg,
				       CONT.HOOK.LTOP #ltop ] ],
			       [ LOCAL local_min &
				     [ CONT.HOOK.LTOP #hand ] ] > ],
	   CONT.HOOK.LTOP #ltop,
           KEYS.KEY arg123_rel & [ ARG2 #arg,
                                   ARG3 #hand ] ] ].

; 'leave it to Kim to find the answer'
;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

expl_pp_inf_oeq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL.COMPS < *top*,
			 [ LOCAL.KEYS.KEY.ARG2 #arg ],
			 [ LOCAL.KEYS.KEY arg1_rel & [ ARG1 #arg ] ] > ].

; 'arrange with Kim to meet her'
;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

pp_inf_seq_lt := pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL local_min &
				  [ CONT.HOOK.INDEX #arg1 ] ] >,
		   COMPS < *top*,
			  [ LOCAL.CONT.HOOK.XARG #arg1 ] > ] ].

; 'arrange it with Kim to meet her'
;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

expl_pp_inf_seq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL local_min &
				  [ CONT.HOOK.INDEX #arg1 ] ] >,
		   COMPS < *top*,
			   *top*,
			   [ LOCAL.CONT.HOOK.XARG #arg1 ] > ]].

; suffice
atrans_inf_lt := linking_type &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				  [ CONT.HOOK.LTOP #hand ] ] >,
	    KEYS.KEY arg12_rel & [ ARG2 #hand ] ] ].

particle_NP_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CONT.HOOK [ LTOP #ltop,
                                                  XARG #event ],
                                      KEYS.KEY selected_rel ] ],
                            [ LOCAL local_min &
				  [ CONT.HOOK.INDEX #index & 
                                               non_expl-ind ] ], ... >,
            CONT.HOOK.LTOP #ltop,
	    KEYS.KEY arg12_rel & [ ARG0 #event,
                                   ARG2 #index ] ] ].

NP_particle_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
                                   [ CONT.HOOK.INDEX #index & non_expl-ind ] ],
                            [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
	    CONT.HOOK.LTOP #ltop,
	    KEYS.KEY arg12_rel & [ ARG2 #index ] ] ].

particle_np_pp_lt := particle_np_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            synsem,
                            synsem &
			      [ LOCAL local_min & 
                                      [ CAT.HEAD.TAM.TENSE no_tense,
                                        KEYS.KEY prep_rel & independent_rel &
                                                 [ ARG1 #event ],
                                        CONT.HOOK.LTOP #ltop ] ], ... >,
            CONT.HOOK [ LTOP #ltop,
                        INDEX #event ] ] ].
		   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Val Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Valence types specify the number and type of subcategorized complements.
  
valence_type :< canonical_synsem.

unsat_subst := valence_type &
  [ LOCAL.CAT.VAL.SUBJ < synsem_min & [ LOCAL [ CAT nomp_cat_min,
                                                AGR.DIVISIBLE strict_sort,
                                                CONJ cnil ] ] > ].
intrans_subst := one_arg & unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < > ].

unsat_two_arg_subst := unsat_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL local_min &
					     [ KEYS.KEY #ckey ] ], ... >,
	    KEYS.--COMPKEY #ckey ] ].

two_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

; For verbs that passivize.
; 21-Apr-00 Changed np_cat_acc_min to nomp_cat_acc_min for e.g. "kim liked 
; hiring abrams"
; DPF 29-May-01 - Removed COMPS..MESSAGE 0-dlist, since this blocked
; acc-gerunds as in "I resent you giving him that"
trans_subst := unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             AGR.DIVISIBLE strict_sort,
					     CONJ cnil,
                                             KEYS.MESSAGE 0-dlist ] ], ... > ].
  
np_trans_subst := trans_subst & two_arg_subst & two_arg & 
  [ LOCAL.CAT.VAL.COMPS < synsem > ].
  
; For verbs with nominal complement but that don't passivize.
non_trans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ KEYS.MESSAGE 0-dlist,
					     CONJ cnil ] ], ... > ].
  
np_non_trans_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             AGR.DIVISIBLE strict_sort,
                                             KEYS.MESSAGE 0-dlist ] ] > ].

basic_cp_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT s_cat_v_c,
				      CONJ cnil ] ] > ] ].

cp_intrans_subst := basic_cp_intrans_subst &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CAT.HEAD.TAM.TENSE real_tense ].
  
prep_intrans_subst := two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT pp_cat,
				    CONJ cnil ] ] > ].

unsat_three_arg_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    synsem & [ LOCAL local_min &
					  [ KEYS.KEY #ckey ] ], ... >,
	    KEYS.--OCOMPKEY #ckey ] ].

basic_three_arg_subst := unsat_three_arg_subst & basic_three_arg.

three_arg_subst := unsat_three_arg_subst & three_arg.

three_arg_trans_subst := three_arg_subst & trans_subst.

basic_three_arg_trans_subst := basic_three_arg_subst & trans_subst.
three_arg_nontrans_subst := three_arg_subst & non_trans_subst.
basic_three_arg_nontrans_subst := basic_three_arg_subst & non_trans_subst.

three_arg_nontrans_raising_subst := basic_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             AGR.DIVISIBLE strict_sort,
					     KEYS.MESSAGE 0-dlist,
					     CONJ cnil ] ], ... > ].

prep_trans_subst := basic_three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             AGR.DIVISIBLE strict_sort,
					     KEYS.MESSAGE 0-dlist,
					     CONJ cnil ] ], 
			  synsem &
			  [ LOCAL [ CAT pp_cat,
				    CONJ cnil ] ] > ].
  
prep_non_trans_subst := three_arg_nontrans_subst & 
  [ LOCAL.CAT.VAL.COMPS < lex_synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                                 AGR.DIVISIBLE strict_sort,
						 KEYS.MESSAGE 0-dlist,
                                                 CONJ cnil ],
                                         LEX +],
			  synsem &
			  [ LOCAL [ CAT pp_cat,
				    CONJ cnil ] ] > ].
  
; For idioms like "take hold of"
prep_nbar_subst := basic_three_arg_nontrans_subst & 
  [ LOCAL.CAT.VAL.COMPS < lex_synsem & [ LOCAL [ CAT nbar_cat &
                                                  [ VAL.SPR < unexpressed > ],
                                                 KEYS.MESSAGE 0-dlist,
                                                 CONJ cnil ],
                                         LEX +],
			  synsem &
			  [ LOCAL [ CAT pp_cat,
				    CONJ cnil ] ] > ].
  
; DPF 15-Apr-02 - Maybe none of these obj_equi_prd verbs should passivize, 
; since the control of the predicative phrase is already the syntactic subject
; when the PrdP is just a VP modifier rather than a complement.  We'll try 
; making all of them prd_non_trans.

prd_non_trans_subst := basic_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             AGR.DIVISIBLE strict_sort,
					     KEYS.MESSAGE 0-dlist,
					     CONJ cnil ] ], 
			  synsem & 
			  [ LOCAL [ CAT basic_prd_cat &
                                        [ HEAD.MOD 
                                          < [ LOCAL.KEYS.KEY norm_relation ]>],
                                    CONJ cnil ] ] > ].

; Removed nonpro_rel from second NP, since we want to get "sell me this" and
; maybe even "sell me them" even if not "*sell Abrams it"
; DPF 2-Jun-02 - Put this back, since deictics no longer pron_rel.  We do give
; up "sell me them", but we really don't want "sell the customers it".

ditrans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             AGR.DIVISIBLE strict_sort,
					     KEYS.MESSAGE 0-dlist,
					     CONJ cnil ] ], 
			  synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             AGR.DIVISIBLE strict_sort,
					     CONJ cnil,
					     KEYS [ KEY nonpro_rel,
                                                    MESSAGE 0-dlist ] ] ] > ].
  
; 'inform Kim that S'
cp_trans_subst := three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                               AGR.DIVISIBLE strict_sort,
					       KEYS.MESSAGE 0-dlist,
					       CONJ cnil ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_v_c,
				      CONJ cnil ] ] > ] ]. 
  
pp_cp_subst := three_arg_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < synsem &
			    [ LOCAL [ CAT pp_cat,
				      CONJ cnil ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ] ] > ] ].
  
np_comp_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             AGR.DIVISIBLE strict_sort,
					     KEYS.MESSAGE 0-dlist,
					     CONJ cnil ] ],
			  [ LOCAL local_min &
				 [ CAT [ HEAD prep & [ TAM.TENSE no_tense ],
                                         VAL.COMPS *olist* ],
                                   CONT.HOOK.XARG individual ] ] > ].
; 'talk to Kim about Sandy'
double_pp_subst := three_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT pp_cat,
				    CONJ cnil ] ], 
			  synsem &
			  [ LOCAL [ CAT pp_cat,
				    CONJ cnil ] ] > ].
  
np_trans_double_pp_subst := four_arg & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            synsem &
                            [ LOCAL [ CAT pp_cat,
                                      CONJ cnil,
                                      KEYS.KEY #ockey ] ], 
                            synsem &
                            [ LOCAL [ CAT pp_cat,
                                      CONJ cnil ] ] >,
            KEYS.--OCOMPKEY #ockey ] ].
  
basic_inf_or_prp_intrans_subst := valence_type &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_or_prp ],
                                      CONT.HOOK.INDEX.E.TENSE no_tense,
                                      CONJ cnil ] ] > ] ].

inf_or_prp_intrans_subst := basic_inf_or_prp_intrans_subst & 
                            unsat_two_arg_subst.

basic_inf_intrans_subst := basic_inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL local_min &
				  [ CAT.HEAD.VFORM inf ] ] > ].

inf_intrans_subst := basic_inf_intrans_subst & unsat_two_arg_subst.

inf_intrans_particle_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp,
                      COMPS < synsem &
			    [ LOCAL.KEYS.KEY independent_rel & 
                                             [ LBL #hand ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT vp_cat & [ HEAD.VFORM inf ],
                                      CONT.HOOK.LTOP #hand,
				      CONJ cnil ] ] > ] ] ].

; for "I will try and find it" - analysis following Pullum and Gazdar

inf_intrans_and_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_and ],
                                      CONJ cnil ] ] > ] ].

for_inf_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & 
			  [ LOCAL [ CAT s_cat_v_c &
					[ HEAD comp &
                                               [ VFORM inf ] ],
                                    CONJ cnil ] ] > ].

inf_trans_subst := three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp, 
		    COMPS < *top*, #comp & synsem &
			           [ LOCAL [ CAT vp_inf_cat,
					     CONJ cnil ] ] > ] ].

inf_trans_raising_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp, 
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

prp_intrans_subst := inf_or_prp_intrans_subst & basic_two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL local_min &
				  [ CAT.HEAD.VFORM prp ] ] > ].

bse_intrans_subst := unsat_two_arg_subst & basic_two_arg &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM bse ],
                                      CONT.HOOK.INDEX.E.TENSE no_tense,
                                      CONJ cnil ] ] > ] ].

; 'make, let, watch' don't passivize.  Some of these have an apparently
; corresponding passive, but with an ordinary 'to-VP' complement, not vform bse
bse_nontrans_raising_subst := three_arg_nontrans_raising_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem &
			  [ LOCAL [ CAT vp_bse_cat,
				    CONJ cnil ] ] > ].

; want (doesn't passivize)
inf_non_trans_subst := basic_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                               AGR.DIVISIBLE strict_sort,
                                               KEYS.MESSAGE 0-dlist ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

basic_pp_inf_subst := valence_type &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < synsem &
			    [ LOCAL [ CAT pp_cat,
				      CONJ cnil,
				      KEYS.KEY selected_rel ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

pp_inf_subst := basic_pp_inf_subst & unsat_three_arg_subst.

prd_nontrans_raising_subst := three_arg_nontrans_raising_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem &
			  [ LOCAL [ CAT prd_cat,
				    CONJ cnil ] ] > ].

; We treat raising as the identification of the CONT attribute of the SUBJ and
; the COMPS.SUBJ, rather than the whole synsem, in part to enable the 
; underspecification of the base/non3sg lex-entry for verbs, where otherwise
; CASE information would clash in examples like "Kim believes Sandy to be 
; ready."  In fact, we only identify the INDEX of the two subjects - see 
; comments by sor_inf_subst.
; 
; DPF 17-Nov-99 - The LTOP handle of the SUBJ must be identified with the
; KEY.LBL of the ssr_subst predicate, since contracted negation auxiliary
; verbs have the LTOP be the neg_rel's handle, but the subject as in 
; "I can't leave" should have its LBL identified with that of the
; can_rel, not the neg_rel.

ssr_subst := two_arg_subst &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local_min & [ CONT.HOOK.INDEX #sind ] ] >,
                      COMPS < [ LOCAL local_min &
                                      [ CAT.VAL.COMPS *olist*,
                                        CONT.HOOK.XARG #sind,
                                        KEYS.MESSAGE 0-dlist ] ] > ],
            CONT.HOOK.XARG #sind ] ].

;;; AAC - added to avoid overspecific glb types

ssr_two_arg_subst := ssr_subst & basic_two_arg.

ssr_inf_subst := ssr_subst & inf_intrans_subst.

ssr_pp_inf_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
	   [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                        INDEX #subj ] ] >,
	     COMPS < synsem &
		     [ LOCAL [ CAT pp_cat,
			       CONJ cnil ] ] ,
		     [ LOCAL local_min &
			  [ CAT [ HEAD verbal & strict_type &
                                       [ VFORM inf ],
                                  VAL [ SUBJ < [ NON-LOCAL [ SLASH 0-dlist,
                                                             REL 0-dlist,
                                                             QUE 0-dlist ]] >,
                                        COMPS *olist* ] ],
                            CONT.HOOK.XARG #subj,
                            KEYS.MESSAGE 0-dlist ] ] > ],
            CONT.HOOK.LTOP #ltop ] ].

ssr_prdp_pp_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
              [ SUBJ < [ LOCAL local_min & [ CONT.HOOK [ LTOP #ltop,
                                                         INDEX #subj ] ] ] >,
		COMPS < [ LOCAL local_min &
			  [ CAT [ HEAD [ PRD +,
                                         TAM.TENSE no_tense ],
				  VAL [ SUBJ *olist*,
                                        SPR *olist*,
					COMPS *olist* ],
				  MC na ],
                            CONT.HOOK.XARG #subj ] ],
                        synsem &
			[ LOCAL [ CAT pp_cat,
				  CONJ cnil ] ] > ],
	    CONT.HOOK.LTOP #ltop ] ].

expl_pp_cp_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
			    [ LOCAL [ CAT pp_cat,
				      CONJ cnil ] ], 
			    synsem &
			           [ LOCAL [ CAT s_cat_fin_v_c,
                                             CONJ cnil ] ] >,
	    KEYS.--COMPKEY _to_rel_s ] ].

expl_np_cp_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
			    [ LOCAL [ CAT nomp_cat_acc_min,
                                      AGR.DIVISIBLE strict_sort,
                                      KEYS.MESSAGE 0-dlist,
				      CONJ cnil ] ], 
			    synsem &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS *olist* ],
                                             CONJ cnil ] ] > ] ].

expl_np_cp_fin_subst := expl_np_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ LOCAL.CAT s_cat_fin_v_c ] > ].

expl_np_cp_inf_subst := expl_np_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ LOCAL.CAT vp_inf_cat ] > ].

expl_prtcl_cp_subst :=  basic_three_arg_subst & particle_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem &
                          [ LOCAL [ CAT s_cat_fin_v_c & [ HEAD comp ],
                                    CONJ cnil ] ] > ].

; Raising synsems have to identify the LOCAL value of the raised synsem with
; that of the VP's subject's synsem, rather than identifying the synsems
; themselves, due to our lexical threading of SLASH: if the raised complement
; is extracted, it will be of type gap, and therefore have a non-empty SLASH,
; but we don't want the lower VP complement's subject to also then have a
; non-empty SLASH.  But cf. note above for subj-subj raising, where maybe we
; even want to restrict the identity to CONT only.
;   Indeed, this seems necessary, since CASE blocks unification for
; 'Kim made him sleep' where our (dual-purpose) 'sleep' requires its subject
; to be [CASE nom] (in order to block the sentence "them sleep"), but when its
; subject is raised to object as with "make", there's a conflict with the
; [CASE acc] on the object of "make".  So here again, we make the raising
; identity hold only for CONT.
; DPF (30-Apr-99) In fact, we now have to further restrict the identity to
; only the INDEX, since if we identify all of CONT, we get the handles of the
; higher NP and the VP's subject being identified, but since we also want to 
; lexically identify a predicate's handle with that of its arguments (subject
; to classes of lexical exceptions like for entries with CP complements), we 
; get an unwanted identity of the handles of the higher and lower verbs through
; the identity of the two NPs.  So if we can't sustain this minimal 
; identification for equi and raising, we'll have to give up on identifying 
; the handles of lexical entries and their arguments.  Possible trouble spots 
; are locative inversions like "On the corner seemed to be an abandoned house".

sor_inf_subst := inf_trans_raising_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CONT.HOOK.INDEX #subj,
                                    AGR #agr ],
			    OPT - ], 
			  [ LOCAL local_min &
				  [ CAT.VAL.SUBJ 
					     < [ LOCAL.AGR #agr,
                                                 NON-LOCAL [ SLASH 0-dlist,
                                                             REL 0-dlist,
                                                             QUE 0-dlist ] ] >,
                                    CONT.HOOK.XARG #subj,
                                    KEYS.MESSAGE 0-dlist ],
				OPT - ] > ].

sor_bse_subst := bse_nontrans_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #subj,
			    OPT - ], 
			  [ LOCAL local_min &
				  [ CAT.VAL.SUBJ 
					  < [ NON-LOCAL [ SLASH 0-dlist,
                                                          REL 0-dlist,
                                                          QUE 0-dlist ] ] >,
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

sor_inf_non_trans_subst := inf_non_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #subj,
			    OPT - ],
			  [ LOCAL local_min &
				  [ CAT.VAL.SUBJ 
					     < [ NON-LOCAL [ SLASH 0-dlist,
							     REL 0-dlist,
							     QUE 0-dlist ] ]>,
                                    CONT.HOOK.XARG #subj,
                                    KEYS.MESSAGE 0-dlist ],
                            OPT - ] > ].

sor_prd_subst := prd_nontrans_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #subj ], 
			  [ LOCAL local_min &
				  [ CONT.HOOK.XARG #subj ],
			    OPT - ] > ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; Instead, identify single-word particles by constraint on RELS - a hack.

particle_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
                            [ LOCAL local_min &
				    [ CAT.HEAD.PRD -,
				      CONT [ HOOK [ LTOP #hand,
                                                    XARG #event ],
                                             RELS <! relation !> ],
				      KEYS.KEY selected_rel ],
			      NON-LOCAL [ SLASH 0-dlist,
					  REL 0-dlist,
					  QUE 0-dlist ] ], ... >,
	    KEYS.KEY [ LBL #hand,
                       ARG0 #event ] ] ].

;; DPF (29-Jan-99) Modified particle_NP_subst to exclude pronominal NP objects,
;; to block *Kim looked up it"

generic_particle_NP_subst := particle_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
			  synsem & 
                          [ LOCAL [ CAT nomp_cat_acc_min,
                                    AGR.DIVISIBLE strict_sort,
                                    CONJ cnil,
                                    KEYS [ KEY nonpro_rel,
                                           MESSAGE 0-dlist ] ] ], ... > ].

particle_NP_subst := generic_particle_NP_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

particle_NP_pp_subst := generic_particle_NP_subst & four_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
                            synsem & [ LOCAL.KEYS.KEY #ockey ],
                            synsem &
                            [ LOCAL [ CAT pp_cat,
                                      CONJ cnil ] ] >,
            KEYS.--OCOMPKEY #ockey ] ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; Instead, identify single-word particles by constraint on RELS - a hack.

generic_NP_particle_subst := trans_subst & 
  [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL.KEYS.MESSAGE 0-dlist ],
			    synsem &
			      [ LOCAL local_min &
				      [ CAT.HEAD.PRD -,
                                        CONT.RELS <! relation !>,
					KEYS.KEY #ckey & selected_rel ],
				NON-LOCAL [ SLASH 0-dlist,
					    REL 0-dlist,
					    QUE 0-dlist ] ], ... >,
	    KEYS.--COMPKEY #ckey ] ].

NP_particle_subst := generic_NP_particle_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

particle_plus_subst := particle_subst & three_arg_subst.

particle_prd_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem & 
			  [ LOCAL [ CAT prd_cat,
				    CONJ cnil ] ] > ].

; 'turn out to be'
particle_inf_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

particle_pp_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem &
			  [ LOCAL [ CAT pp_cat,
				    CONJ cnil ] ] > ].

; 'find out that S'
particle_cp_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ] ] > ] ].

;; 'leave it to Kim to schedule the meeting'
unsat_four_arg_subst := unsat_three_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
                            synsem & [ LOCAL.KEYS.KEY #ockey ],
                            synsem, ... >,
            KEYS.--OCOMPKEY #ockey ] ].

; 'leave it to Kim to find the answer'
expl_pp_inf_subst := unsat_four_arg_subst & trans_subst & four_arg &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < *top*, 
			    synsem &
			    [ LOCAL [ CAT pp_cat,
				      CONJ cnil ] ] ,
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

;; 'put kim through to Sandy'
np_particle_pp_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
                            synsem & [ LOCAL.KEYS.KEY #ockey ], 
                            synsem &
                            [ LOCAL [ CAT pp_cat,
                                      CONJ cnil ] ] >,
            KEYS.--OCOMPKEY #ockey ] ].


;; 'bet Kim a fortune that Sandy would win'
;; DPF (19-Oct-98) Added hack to block extraction from the CP complement, since
;; don't know how to avoid topicalized imperative parse for "Abrams bet Browne
;; Chiang slept with subject of "slept" topicalized.

np_np_cp_subst := unsat_four_arg_subst & trans_subst & four_arg &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                               AGR.DIVISIBLE strict_sort,
					       KEYS.MESSAGE 0-dlist,
					       CONJ cnil ] ],
			    synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                               AGR.DIVISIBLE strict_sort,
					       KEYS.MESSAGE 0-dlist,
					       CONJ cnil ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
			      NON-LOCAL.SLASH 0-dlist ] > ] ].

; E.g., "I'm not doing too badly"

adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < lex_synsem & 
			    [ LOCAL local_min &
				    [ CAT.HEAD adv,
				      CONT.HOOK [ LTOP #hand,
                                                  INDEX #event ],
				      KEYS [ KEY adv_rel,
					     MESSAGE 0-dlist ] ],
                              LEX + ] >,
	    KEYS.KEY [ LBL #hand,
		       ARG0 #event ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERB SYNSEMS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Verb synsems should inherit from one valence type and one linking type.
; The type verb_synsem is given a non-empty SPR value so VPs can be modified
; by PPs, but (hack) the synsem is of type anti_synsem to block unification, 
; to avoid ever picking up an actual specifier.
;   Added VIT links for the moment, to satisfy VIT requirements for visibility
; of TENSE and MOOD information.  (Actually, moved VITTENSE specification to
; the various inflectional affixes in lexrules.tdl, to accommodate the collapse
; of the base and fin-non3sg verb forms.
; DPF (8-Jul-98) Added QUE 0-dlist, REL 0-dlist to block pied piping in verb
; phrases (taking advantage of lexical amalgamation of these features, together
; with our treatment of subject-WH as extraction (where only local features are
; propagated in SLASH).

basic_verb_synsem := synsem &
  [ LOCAL [ STEMHEAD vstem,
            AGR #agr,
            CAT [ HEAD verb*,
		  VAL [ SUBJ < synsem_min & #subj &
			       [ LOCAL local_min &
				       [ AGR #agr ] ] >,
			SPR < anti_synsem >,
			COMPS #comps ] ],
	    CONT.HOOK [ INDEX #event,
                        E-INDEX #event ],
	    ARG-S < #subj . #comps > ],
    NON-LOCAL [ QUE 0-dlist,
		REL 0-dlist ] ].

verb_synsem := basic_verb_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD.TAM.MOOD #mood,
            CONT.HOOK.INDEX.E.MOOD #mood ] ].

atrans_verb := verb_synsem & intrans_subst & atrans_lt.

unerg_verb := verb_synsem & intrans_subst & arg1_subj_lt.
  
passive_or_unacc_synsem :< unsat_subst.
unacc_verb := verb_synsem & intrans_subst & unacc_lt & passive_or_unacc_synsem.
  
; For at least main verb "have" (e.g, "Kim has some rice")
poss_verb := verb_synsem & two_arg_subst & two_arg & poss_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             AGR.DIVISIBLE strict_sort,
					     KEYS.MESSAGE 0-dlist,
					     CONJ cnil ] ] > ].
  
np_trans_verb := verb_synsem & np_trans_subst & trans_lt.
  
np_non_trans_verb := verb_synsem & np_non_trans_subst & two_arg & trans_lt.

np_non_trans_unacc_verb := verb_synsem & np_non_trans_subst & two_arg & 
			   unacc_lt.

basic_prep_intrans_verb := verb_synsem & prep_intrans_subst & basic_two_arg.

;; come to
prep_intrans_verb := basic_prep_intrans_verb & prep_intrans_lt & two_arg.

;; move to
prep_intrans_unacc_verb := basic_prep_intrans_verb & prep_intrans_unacc_lt
                           & two_arg.
;; thanks (hack)
prep_intrans_nosubj_verb := basic_prep_intrans_verb & prep_intrans_nosubj_lt.

;; look for
;;
empty_prep_intrans_verb := verb_synsem & prep_intrans_subst & two_arg & 
			   empty_prep_intrans_lt.

;; suggest on Tuesday
;;
prep_intrans_event_verb := verb_synsem & prep_intrans_subst & two_arg & 
			   prep_intrans_event_lt.

;; put, move
;;
prep_trans_verb := verb_synsem & prep_trans_subst & prep_trans_lt.
  
;; buy (from)
prep_trans_nomsg_verb := verb_synsem & prep_trans_subst & prep_trans_nomsg_lt.

;; thanks
basic_prep_trans_verb := verb_synsem & prep_trans_subst & basic_prep_trans_lt.

;; remind-of
;;
empty_prep_trans_verb := verb_synsem & prep_trans_subst & empty_prep_trans_lt &
  [ LOCAL.CONT.HCONS <! !> ].

;; interest him in X
;;
empty_prep_non_trans_verb := verb_synsem & prep_non_trans_subst & 
			     empty_prep_trans_lt.

;; get-hold-of
;;
empty_prep_nbar_verb := verb_synsem & prep_nbar_subst & 
			     empty_prep_nbar_lt.

;; regard Kim as tall
np_comp_verb := verb_synsem & np_comp_subst & obj_equi_lt &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL [ CAT.VAL.SUBJ *olist*,
                                      CONT.HOOK.LTOP #ltop ],
	    CONT.HOOK.LTOP #ltop ] ].

;; strike Kim as tall
np_comp_obj_verb := verb_synsem & np_comp_subst & 
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #sind ] >,
                      COMPS < [ LOCAL.CONT.HOOK.INDEX #index ],
                              [ LOCAL.CONT.HOOK [ XARG #sind,
                                                  E-INDEX #event ] ] > ],
            CONT.HOOK.XARG #sind,
            KEYS.KEY arg12_rel & [ ARG2 #event,
				   ARG1 #index ] ] ].


; DPF 4-Jun-01 - Changed dative-to to be contentful "to", in order to sustain
; 'underspecified' semantics for "kim sent it to Sandy/Paris".  Verbs like 
; "hand" are now of type empty_to_trans_verb.
to_trans_verb := prep_trans_nomsg_verb &
  [ LOCAL.KEYS.--OCOMPKEY _to_rel ].
  
empty_to_trans_verb := empty_prep_trans_verb &
  [ LOCAL.KEYS.--OCOMPKEY _to_rel_cm ].

ditrans_verb := verb_synsem & ditrans_subst & ditrans_lt.
  
ditrans_only_verb := verb_synsem & ditrans_subst & ditrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

; 'talk to Kim about Sandy'
double_pp_verb := verb_synsem & double_pp_subst & double_pp_lt.

; Unwanted type if freer order of obliques- 'pay with a check for it"
double_pp_empty_pp_verb := verb_synsem & double_pp_subst & 
                           double_pp_empty_pp_lt.

; 'change the meeting from Tuesday to Wednesday'
np_trans_double_pp_verb := verb_synsem & np_trans_double_pp_subst & 
                           arg12_double_pp_lt.

; Raising verbs which take an infinitival complement restrict it to being
; [ MESSAGE 0-dlist ], which ensures that the VP will be headed by the 
; non-propositional "to" complementizer, which identifies its handle with
; that of its VP complement.

ssr_verb := verb_synsem & ssr_inf_subst & basic_two_arg &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT.HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !>,
	    KEYS.KEY.ARG1 #arghand ] ].

ssr_pp_inf_verb := verb_synsem & ssr_pp_inf_subst & ssr_expr_lt.

ssr_prdp_pp_verb := verb_synsem & ssr_prdp_pp_subst & ssr_prdp_expr_lt.

sor_verb := verb_synsem & sor_inf_subst & sor_lt.

sorb_verb := verb_synsem & sor_bse_subst & sor_lt.

sorbpass_verb := verb_synsem & sor_inf_subst & sor_lt.

sor_non_trans_verb := verb_synsem & sor_inf_non_trans_subst & sor_lt.

sor_prd_verb := verb_synsem & sor_prd_subst & sor_lt.

subj_equi_prp_verb := verb_synsem & prp_intrans_subst & 
                      subj_equi_prp_or_bse_lt &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CAT.VAL.SUBJ < pro_ss > ].

subj_equi_bse_verb := verb_synsem & bse_intrans_subst &
                      subj_equi_prp_or_bse_lt.

ssr_two_arg_verb := basic_verb_synsem & ssr_two_arg_subst.

; "K became quiet"
subj_prd_verb := verb_synsem & ssr_two_arg_subst & prd_comp_lt &
  [ LOCAL [ CAT.VAL [ COMPS < synsem & #comp &
                              [ LOCAL [ CAT prd_cat,
                                        CONJ cnil ] ] >,
                      --KEYCOMP #comp ],
            KEYS [ KEY.ARG2 #arghand,
                   ALT2KEY.LBL #arghand ] ] ].


; "K got hired"
subj_equi_prd_verb := subj_prd_verb & subj_equi_lt.

; DPF 15-Apr-02 - Changed these to prd_non_trans_subst, since get spurious 
; ambiguity with alternate analysis of PrdP as adjunct, with right semantics in
; passive case.  

obj_equi_prd_verb := verb_synsem & prd_non_trans_subst & obj_equi_prd_lt.

obj_equi_non_trans_prd_verb := verb_synsem & prd_non_trans_subst & 
			       obj_equi_prd_lt.

; ERB (07-10-96) I am working with the verb 'know' as a prototype for a verb
; that selects by the semantic type (for now expressed as a feature) of its
; sentential complement rather than by the value of CMP or some such hack.  In
; order to do so, I have changed the types around here.  In particular, I am
; adding a new type cp_prop+ques_intrans_verb that takes a sentential
; complement but doesn't care if its a proposition or a question (for verbs
; like 'know').  A further axis of variation is the VFORM of the complement
; (fin vs. inf).  Since my analysis of 'know' never makes use of the resolved
; subtypes (e.g., cp_prop_intrans_verb) I am not adding to the resolved
; subtypes, and just making the old ones inherit from the finite side of
; things for now.  The future inf_cp_prop_intrans_verb will probably be the
; type of subject equi verbs. A further future modification would involve the
; addition of cp_command_intrans_verb and cp_command+prop_intrans_verb for
; verbs like 'insist'.
;
; DPF (19-Jun-98) This type cannot itself simply add the complement CP's 
; (underspecified) message to its RELS, since the generation algorithm requires
; that no relation on RELS will ever get more specialized during parsing.  So 
; we make MESSAGE be list-valued (the empty list for all but complementizers
; and clauses), and have the Head-Complement rule append the values of MESSAGE
; from both of its daughters, since the msg comes from the head if it's a
; complementizer, and from the non-head if the head is a verb.

basic_cp_prop+ques_verb := verb_synsem &
  [ LOCAL [ CAT.VAL [ --KEYCOMP 
			  [ LOCAL local_min &
				  [ CAT [ HEAD verbal & strict_type &
					       [ INV - ] ],
				    KEYS.MESSAGE 1-dlist &
					<! message !> ] ] ],
	    CONT.RELS.LIST < relation, ... > ] ].

cp_prop+ques_verb := basic_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.KEYS.MESSAGE <! prop_ques_rel !> ].

fin_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CAT s_cat_fin_unspec ].

fin_or_inf_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CAT s_cat_fin_or_inf_v_c ].

bse_cp_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CAT s_cat_bse ].

;; DPF 4/21/98 - Moved [ COMPS.FIRST.LOCAL.CAT.MC - ] from cp_ques_intrans_verb
;; to cp_intrans_verb, to block spurious parse for e.g. "Kim knows who left"

cp_intrans_verb := fin_cp_prop+ques_verb & cp_intrans_subst & two_arg &
		   arg12h_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.TAM.MOOD ind_or_mod_subj ] > ].

; 'know'
cp_fin_inf_intrans_verb := fin_or_inf_cp_prop+ques_verb & cp_intrans_subst &
                              two_arg & arg12h_lt.

cp_prop_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.KEYS.MESSAGE 1-dlist &
					       <! propositional_rel !> ] > ].

cp_only_prop_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD comp,
                                    KEYS.MESSAGE 1-dlist &
                                             <! propositional_rel !> ] ] > ].

cp_ques_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.KEYS.MESSAGE 1-dlist &
					       <! int_rel !> ] > ].

;; suppose
cp_prop_raise_key_verb := fin_cp_prop+ques_verb & cp_intrans_subst & two_arg &
			  alt_arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ KEYS [ KEY #key,
					     MESSAGE 1-dlist &
					       <! propositional_rel !> ] ] ] >,
	    CONT.RELS.LIST < #altkey, ... >,
	    KEYS [ KEY #key & mod_role_rel,
		   ALTKEY #altkey ] ] ].

;; tell Kim that/whether S
;; inform Kim that S
np_trans_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt.

np_trans_cp_fin_or_inf_verb := fin_or_inf_cp_prop+ques_verb & cp_trans_subst & 
                               cp_trans_lt.

;; bet Kim ten cents that S
np_np_cp_verb := fin_cp_prop+ques_verb & np_np_cp_subst & tritrans_lt.

;; explain to Kim that S
; DPF 10-Sep-01 - Removed MESSAGE prpstn_rel since want to get e.g.
; 'Can you confirm whether Kim arrived?"
pp_cp_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
			  [ LOCAL.KEYS.MESSAGE 1-dlist ] > ].

;; ask Kim whether S
np_trans_cp_ques_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &

  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.KEYS.MESSAGE 1-dlist &
				    <! int_rel !> ] > ].

;; persuade Kim that S
np_trans_cp_prop_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &

  [ LOCAL.CAT.VAL.COMPS < synsem, 
			  [ LOCAL.KEYS.MESSAGE 1-dlist &
					       <! propositional_rel !> ] > ].

;; ask that Kim be released
cp_bse_intrans_verb := bse_cp_verb & cp_intrans_subst & two_arg &
		   arg12h_lt.

;; try to
subj_equi_verb := cp_prop+ques_verb & inf_intrans_subst & two_arg & 
                  subj_equi_inf_lt.

;; try and find it
;; Allow "I/you/we/they try and find it" but block "*He tries and find it"
;; but allow "I/you/we/they/he will try and find it" and "Try and find it".
subj_equi_and_verb := cp_prop+ques_verb & inf_intrans_and_subst & two_arg & 
                      subj_equi_inf_lt &
  [ LOCAL [ CAT [ HEAD.VFORM strict_sort,
                  VAL.COMPS < [ OPT - ] > ],
            CONT.HOOK.INDEX.E [ ASPECT no_aspect,
                                MOOD ind_or_mod_subj ],
            KEYS [ --COMPKEY #ckey,
                   --+COMPKEY #ckey ] ] ].

;; have yet to find it
ssr_particle_verb := verb_synsem & inf_intrans_particle_subst & 
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local_min & [ CONT.HOOK.INDEX #sind ] ] >,
                      COMPS < [ LOCAL.KEYS.KEY.ARG1 #event ],
                              [ LOCAL local_min &
                                 [ CAT.HEAD verbal & strict_type &
                                            [ INV - ],
                                   CONT.HOOK [ LTOP #cltop,
                                               INDEX #event &
                                                   [ E.ASPECT perf* ],
                                               XARG #sind ],
                                   KEYS [ KEY #key,
                                          MESSAGE 0-dlist ] ] ] > ],
            CONT [ HOOK [ LTOP #ltop,
                          XARG #sind ],
                   RELS <! neg_rel & 
                          [ LBL #ltop,
                            ARG1 #argh ] !>,
                   HCONS <! qeq & [ HARG #argh,
                                    LARG #cltop ] !> ],
            KEYS [ KEY #key & v_event_rel,
                   MESSAGE 0-dlist ] ] ].

;; tell, persuade
obj_equi_verb := cp_prop+ques_verb & inf_trans_subst & obj_equi_inf_lt.

;; appeal, intend
oeq_pp_inf_verb := verb_synsem & pp_inf_subst & three_arg & obj_equi_inf_lt &
		   empty_prep_intrans_lt.

;; arrange with kim to meet
pp_inf_seq_verb := cp_prop+ques_verb & pp_inf_subst & three_arg & 
                   pp_inf_seq_lt.

; promise
anom_equi_verb := cp_prop+ques_verb & inf_non_trans_subst & anom_equi_lt &
  [ LOCAL.CONT.HCONS <! !> ].

; use X to do Y
anom_equi_trans_verb := cp_prop+ques_verb & inf_trans_subst & anom_equi_lt &
  [ LOCAL.CONT.HCONS <! !> ].

particle_inf_verb := cp_prop+ques_verb & particle_inf_subst & 
		     anom_equi_particle_lt.

particle_cp_verb := fin_cp_prop+ques_verb & particle_cp_subst & 
		    particle_cp_lt.

expl_it_subj_pp_cp_verb := basic_cp_prop+ques_verb & expl_pp_cp_subst & 
		     expl_it_subj_pp_cp_lt.

expl_it_subj_np_cp_verb := basic_cp_prop+ques_verb & expl_np_cp_subst & 
                           expl_it_subj_np_cp_lt.

expl_it_subj_np_cp_fin_verb := basic_cp_prop+ques_verb & 
                               expl_np_cp_fin_subst & expl_it_subj_np_cp_lt.

expl_it_subj_np_cp_inf_verb := basic_cp_prop+ques_verb & 
                               expl_np_cp_inf_subst & expl_it_subj_np_cp_lt.

expl_it_subj_prtcl_cp_verb := basic_cp_prop+ques_verb & expl_prtcl_cp_subst & 
		     expl_it_subj_prtcl_cp_lt.

expl_pp_inf_oeq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_oeq_lt.

expl_pp_inf_seq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_seq_lt.

atrans_inf_verb := cp_prop+ques_verb & inf_intrans_subst & two_arg & 
		   atrans_inf_lt.

for_to_verb := verb_synsem & for_inf_intrans_subst & two_arg & arg12h_lt.

particle_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

particle_NP_verb := verb_synsem & particle_NP_subst & particle_NP_lt.

NP_particle_verb := verb_synsem & NP_particle_subst & NP_particle_lt.

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

NP_prep_particle_verb := NP_particle_verb &
  [ LOCAL [ CAT.VAL.COMPS < synsem, [ LOCAL.KEYS.KEY.ARG2 #index ], ...>,
	    KEYS.KEY.ARG2 #index ] ].

particle_prd_verb := verb_synsem & particle_prd_subst & anom_equi_prd_lt.

particle_pp_verb := verb_synsem & particle_pp_subst & 
		    prep_particle_intrans_lt.

particle_empty_pp_verb := verb_synsem & particle_pp_subst & 
                          empty_prep_particle_intrans_lt.

np_particle_pp_verb := verb_synsem & np_particle_pp_subst & 
                       prep_particle_trans_lt.

particle_np_pp_verb := verb_synsem & particle_np_pp_subst & particle_np_pp_lt.

; prefer it if ...
expl_obj_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & expl_obj_cp_lt.

adv_verb := verb_synsem & adv_subst & arg1_subj_lt & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < *top* >,
	    CONT.RELS <! #key !>,
	    KEYS.KEY #key ] ].

; DPF 13-May-02 - Made passive_synsem inherit from basic_verb_synsem rather
; than verb_synsem since we don't want it to be subtype of lex_synsem, since
; simple passives can be post-nominal modifiers, as in "the price quoted is
; too high"
; DPF 2-Jul-02 - Added MOD..PERIPH - to block analysis of "Abrams hired"
; while allowing "anyone hired"

passive_synsem := basic_verb_synsem & passive_or_unacc_synsem &
  [ LOCAL [ CAT.HEAD [ TAM.MOOD #mood,
                       MOD < [ MODIFIED.PERIPH - ] > ],
            CONT.HOOK.INDEX.E.MOOD #mood ] ].

; For using lexical passives as reduced relatives: "the prices quoted are ..."
passive_phr_synsem := passive_synsem & phr_synsem.

ssr_particle_v_lexent := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTED -,
    SYNSEM ssr_particle_verb &
           [ LOCAL.CAT.HEAD verb* & [ AUX -*,
                                      INV -* ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modifier synsems
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; When changing, remember to also modify verb_participle_affix in lexrules.tdl
isect_synsem := canonical_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
	    CONT.HOOK.LTOP #hand,
	    KEYS.KEY.LBL #hand ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The semantics of a main verb consists of the "main" handel for the sentence
; and a list of relations.  A pointer to the main or head relation in the list
; is kept in the KEY attribute.
;
; DPF 26-Jan-01 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.

main_verb_sans_key := nonconj & hc-to-phr &
  [ SYNSEM.LOCAL [ CAT.HEAD verb* & [ AUX -*,
				      INV -* ],
		   CONT.RELS.LIST < v_event_rel, ... >,
                   KEYS [ KEY.WLINK *cons*,
                          ALTKEY role_rel ] ] ].

;;; AAC - all main_verbs have single element RELSs

main_verb := main_verb_sans_key & topkey & mcna & nonmsg &
  [ INFLECTED -,
    SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT.RELS <! #key !> ] ].

main_verb_std := main_verb.

main_verb_mliszt := main_verb_sans_key & topkey & mcna & nonmsg &
  [ INFLECTED -,
    SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT.RELS.LIST < #key, ... > ] ].

main_verb_mliszt_infl := main_verb_sans_key & topkey &
  [ INFLECTED +,
    SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT.RELS.LIST < #key, ... > ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; AUXILIARY VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Auxiliary verbs are subject-to-subject raising verbs which also raise the 
; content of the VP complement, possibly tacking an additional relation on the
; end.  They also raise the context of the VP complement, for now at least to
; propagate tense information.
; AUX verbs are further classified by the type of VP complement they 
; select for.  Also, AUX verbs optionally take a neg (post-head) specifier.

aux_verb := verb_synsem &
  [ LOCAL [ CAT.HEAD.TAM #tam,
	    CONT.HOOK.INDEX.E #tam ] ].
		
aux_verb_ssr := aux_verb & ssr_subst & basic_two_arg &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < #comp, ... > ] ].

aux_verb_word_super := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTED +,
    SYNSEM aux_verb_ssr ]. 

aux_verb_word := aux_verb_word_super &
  [ SYNSEM.LOCAL.CAT [ HEAD.AUX +*,
		       POSTHEAD + ] ].

bse_aux_verb_word := aux_verb_word &
  [ SYNSEM.LOCAL local_min &
		 [ CAT [ VAL [ SUBJ < [ OPT - ] >,
			       COMPS < synsem &
				       [ LOCAL [ CAT vp_bse_unspec_cat,
						 CONJ cnil ],
					 OPT - ] > ] ] ] ].

;; ought, going
inf_aux_verb_word := aux_verb_word_super & 
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL local_min &
		 [ CAT [ HEAD.AUX -,
                         POSTHEAD +,
			 VAL.COMPS < synsem &
				     [ LOCAL [ CAT vp_inf_cat,
					       CONJ cnil ],
				       OPT - ] > ] ] ] ].

;; Only for auxiliary "have"
psp_aux_verb_word := aux_verb_word &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.COMPS < synsem &
				     [ LOCAL [ CAT vp_cat &
						   [ HEAD verb &
							  [ VFORM psp ] ],
					       CONT.HOOK.LTOP #hand,
					       CONJ cnil ],
				       OPT - ] >,
		     KEYS.KEY [ LBL #hand ] ] ] ].
; Only for the copula
; DPF 29-Nov-02 - Predicative copula has to identify COMPS..MOD..INDEX with
; COMPS..XARG since predicative PPs cannot lexically identify XARG with their
; KEY.ARG1, because PPs acting as modifiers of VPs have to project the XARG
; of the VP.

prd_aux_verb_word := aux_verb_word &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.COMPS 
                     < [ LOCAL local_min &
                        [ CAT [ HEAD subst &
                                     [ PRD +,
                                       MOD < [ LOCAL.CONT.HOOK.INDEX #ind ] >],
                                  VAL [ SUBJ *olist*,
                                        COMPS *olist*,
                                        SPR *olist* ],
                                  MC na ],
                            CONT.HOOK [ E-INDEX #event,
                                        XARG #ind & individual ],
                            KEYS.KEY independent_rel ],
                         OPT - ] >,
                     CONT.HOOK.INDEX #event ] ] ].

raise_cont := word_or_lexrule &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
					   [ CONT.HOOK
                                               [ LTOP #hand,
                                                 INDEX #index ] ] ], ... >,
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index ],
			  RELS <! !> ] ] ].

add_cont := word_or_lexrule &
  [ SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT.RELS.LIST < relation & #key, ... > ] ].

; Real modal verbs are auxiliary verbs which select a base form complement.
; They only exist in finite forms.
; DPF 2-Oct-01 - Removed [--KEYCOMP..INDEX.E.TENSE no_tense] since this
; prevented low attachment of "when" in "when can Kim arrive"

generic_modal_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.LTOP #chand,
                     CONT [ HOOK.INDEX #event,
			    HCONS.LIST < qeq &
					   [ HARG #arghand,
					     LARG #chand ], ... > ],
		     KEYS.KEY [ ARG0 #event,
				ARG1 #arghand ] ] ] ].

fin_modal_verb_word := generic_modal_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
				VFORM fin*,
                                TAM ind_or_mod_subj_tam ],
			 POSTHEAD +,
			 VAL.SUBJ < synsem & [ LOCAL 
                                                 [ CAT nomp_cat_nom_min,
                                                   AGR.DIVISIBLE strict_sort,
                                                   KEYS.MESSAGE 0-dlist,
                                                   CONJ cnil ],
                                               OPT - ] > ],
		   CONT psoa ] ].

pres_modal_verb_word := fin_modal_verb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM [ TENSE present*,
                                  ASPECT no_aspect* ],
                       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.TAM.TENSE no_tense ] ].

; Assume for now that all modals have simple present tense semantics,
; ignoring the habitual past readings possible for "would" and "could" -
; these will have to be separate lexical entries.

modal_verb_word := pres_modal_verb_word & bse_aux_verb_word &
  [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin*,
                              PRD -,
                              MOD < [ LOCAL intersective_mod &
                                            [ CAT nbar_cat ] ] > ],
                       VAL.COMPS.FIRST.LOCAL.CAT vp_bse_cat ] ].

pos_modal_verb_word := modal_verb_word & topkey &
  [ SYNSEM.LOCAL [ CAT.HEAD.AUX +*,
		   CONT [ RELS <! #key !>,
			  HCONS <! qeq !> ],
		   KEYS.KEY #key & [ WLINK *cons* ] ] ].

ought_verb_word := pres_modal_verb_word & inf_aux_verb_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL intersective_mod &
                                        [ CAT nbar_cat ] ] > ].

pos_ought_verb_word := ought_verb_word & topkey &
  [ SYNSEM.LOCAL [ KEYS.KEY #key,
		   CONT [ RELS <! #key !>,
			  HCONS <! qeq !> ] ] ].

past_ought_verb_word := fin_modal_verb_word & inf_aux_verb_word & topkey &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TAM [ TENSE past*,
                                    ASPECT no_aspect* ],
                              MOD < [ LOCAL intersective_mod &
                                            [ CAT nbar_cat ] ] > ],
                   CONT [ RELS <! #key !>,
			  HCONS <! qeq !> ],
		   KEYS.KEY #key ] ].

basic_quasimodal_verb_word := aux_verb_word_super &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < anti_synsem >,
                           VAL.COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #hand,
                                                             INDEX #event ] ],
                     CONT [ HOOK [ LTOP #hand,
                                   INDEX #event ],
			    RELS <! !>,
			    HCONS <! !> ],
		     KEYS.KEY.ARG0 #event ] ] ]. 

quasimodal_word := basic_quasimodal_verb_word & inf_aux_verb_word.

quasimodal_psp_word := inf_aux_verb_word & generic_modal_verb_word & topkey &
  [ SYNSEM.LOCAL [ CAT.HEAD [ VFORM psp,
			      TAM.TENSE present*,
			      PRD -],
		   CONT [ RELS <! #key !>,
                          HCONS <! qeq !> ],
		   KEYS.KEY #key & [ WLINK *cons* ] ] ].

quasimodal_bse_word := basic_quasimodal_verb_word & bse_aux_verb_word &
  [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM prp,
                              PRD + ],
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].

; DPF 09-Jan-00 - Removed SLASH 0-dlist from COMPS.FIRST, since it was blocking
; e.g. "When's he leaving"

contracted_aux_word := word &
  [ ALTS.VPELLIP - ].

; copula, 'exists'
; DPF 12-Apr-02 - The second (predicative) complement was being blocked by
; KEY no_rel - avoided unwanted ambiguity, but now prevents e.g. "where is
; there a problem" since we now want to avoid spurious adjunct extraction.
; So removed no_rel, and instead require this second complement to be 
; non_canonical - allows extraction, but not the spuriosity of in-situ PrdPs.
there_verb_synsem := unsat_three_arg_subst & basic_three_arg & verb_synsem &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX there-ind & #subjind &
					   [ PNG [ PN #pn,
                                                   GEN no_gend_there ] ] ] ] >,
		      COMPS < synsem &
			    [ LOCAL [ AGR non_expl-ind &
					  [ PNG [ PN #pn,
                                                  GEN neut ] ],
                                      CAT np_cat_acc_min,
				      CONT.HOOK.INDEX #cind,
				      CONJ cnil,
                                      KEYS.KEY nonpro_rel & [ LBL #chand ]],
                              OPT - ],
                              non_canonical &
			    [ LOCAL local &
				    [ CAT [ HEAD [ PRD +,
                                                   TAM.TENSE no_tense ],
					    VAL [ SPR *olist*,
                                                  SUBJ *olist*,
						  COMPS *olist* ],
					    MC na ],
                                      CONT.HOOK [ LTOP #chand,
                                                  XARG #cind ] ],
                              OPT + ] > ],
            CONT.HOOK.XARG #subjind,
	    KEYS.KEY v_event_arg1_rel &
                    [ ARG1 #cind,
                      WLINK *cons* ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NOUNS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;       TYPE                 ISA                what's it for?
;       nominal_synsem       lex_synsem         all nouns
;       xpro_synsem          nominal_synsem     pro v. non-pro dimension
;       xref_synsem          nominal_synsem     ref v. non-ref dimension
;       pronominal_synsem    xpro_synsem        all pronouns
;       nonpronominal_synsem xpro_synsem        all non-pronominal nouns
;       ref_synsem           xref_synsem        personal pro's & nouns
;       non_ref_synsem       xref_synsem        it, there, wh-pronouns
;       ref_pro_synsem       pronominal_synsem  personal pronouns
;                            & ref_synsem
;       non_ref_pro_synsem   pronominal_synsem  it, there, wh-pronouns
;                            & non_ref_synsem
;       noun_synsem          nonpronominal_synsem all non-pro nouns
;                            & ref_synsem 

; The "default" statement that most nouns identify their AGR and INDEX
; will live on noun_synsem and non_ref_pro_synsem, and then be restated for
; personal pronouns other than my special 'they'.  (All this because I can't
; be bothered now to set up a special default type...) 

basic_nom_synsem := lex_synsem & 
  [ LOCAL [ STEMHEAD nstem,
            CAT.HEAD nominal,
	    CONT nom-obj ] ].

nominal_synsem := basic_nom_synsem &
  [ LOCAL.CAT.HEAD.POSS - ].

xpro_synsem :< nominal_synsem.
xref_synsem :< nominal_synsem.

; DPF 23-Jul-99 - Add missing MOD < >.  Hmm.

pronominal_synsem := xpro_synsem &
  [ LOCAL [ CAT [ HEAD noun* &
		       [ MOD < > ],
		  VAL.SUBJ < > ] ] ].

nonpronominal_synsem :< xpro_synsem.

; AAC - added following types for verbal_gerund, poss_clitic etc

nonpro_nomod_synsem := nomod_synsem & nonpronominal_synsem.
nonpro_onearg_synsem := nonpronominal_synsem & basic_one_arg.
nomod_onearg_synsem := nomod_synsem & one_arg.
nonpro_nomod_onearg_synsem := nonpro_nomod_synsem & basic_one_arg.

ref_synsem := xref_synsem &
  [ LOCAL [ KEYS.KEY #key,
	    CONT [ HOOK.INDEX #inst & ref-ind,
		   RELS.LIST < basic_nom_rel & #key & 
				    [ ARG0 #inst ], ... > ] ] ].

non_ref_synsem := xref_synsem & nomod_synsem & zero_arg &
  [ LOCAL.CAT.VAL [ SPR < >,
		    COMPS < > ] ].

ref_pro_synsem := pronominal_synsem & ref_synsem & nomod_synsem.

non_ref_pro_synsem := pronominal_synsem & non_ref_synsem &
  [ LOCAL [ AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

basic_noun_synsem := nonpronominal_synsem & ref_synsem &
  [ LOCAL.CAT.HEAD noun* ].

noun_synsem := basic_noun_synsem &
  [ LOCAL [ AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

;;
;; Common nouns
;;
;; DPF 16-Nov-00 - Added SPR.NON-LOCAL.SLASH 0-dlist - don't know how we did
;; without this up to now.
;; DPF 14-Jul-01 - Well, we don't actually want SPR..SLASH 0-dlist since it
;; blocks free relative det constructions like "whichever person you hired"
;; where the "whichever" has a non-empty SLASH value.  Don't know what
;; motivated the above addition of 0-dlist, but I'm sure we'll soon see.
; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).

basic_common_noun_synsem := noun_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
	    CAT [ VAL [ SPR < #spr &  synsem &
                              [ LOCAL local_min &
                                      [ CAT [ HEAD det,
                                              VAL [ SUBJ < >,
                                                    SPR *olist*,
                                                    COMPS *olist* ] ] ],
                                OPT - ] >,
                        COMPS #comps ],
                  HS-LEX -* ] ] ].
            

common_noun_synsem := basic_common_noun_synsem &
  [ LOCAL.STEMHEAD countnstem ].

common_noun_nocomp_synsem := common_noun_synsem & basic_one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

basic_mass_or_count_synsem := basic_common_noun_synsem & nonpro_nomod_synsem &
  [ LOCAL [ STEMHEAD masscountnstem,
            CONT.RELS <! relation !> ] ].

mass_or_count_nocomp_synsem := basic_mass_or_count_synsem & one_arg.

noun_nocomp_synsem := common_noun_nocomp_synsem & nonpro_nomod_onearg_synsem.
noun_nonpro_nomod_synsem := basic_common_noun_synsem & nonpro_nomod_synsem.
noun_two_arg_nomod_synsem := noun_nonpro_nomod_synsem & basic_two_arg.

basic_noun_ppcomp_synsem := basic_common_noun_synsem &
  [ LOCAL [ CAT.VAL.COMPS < expressed_synsem &
                            [ LOCAL local_min &
				    [ CAT [ HEAD prep & [ PRD -,
                                                          TAM.TENSE no_tense ],
					    VAL.COMPS *olist* ],
                                      CONT.HOOK [ LTOP #hand,
                                                  INDEX #nind ],
				      KEYS.KEY #ckey ] ], ... >,
            CONT.HOOK.INDEX #nind,
	    KEYS [ KEY.LBL #hand,
		   --COMPKEY #ckey ] ] ].

noun_nondeverb_ppcomp_synsem := basic_noun_ppcomp_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.KEYS.KEY.ARG2 #index ] >,
            KEYS.KEY diadic_nom_rel & [ ARG1 #index ] ] ].

m_or_c_noun_ppcomp_synsem := noun_nondeverb_ppcomp_synsem & 
                             nonpro_nomod_synsem.
noun_ppcomp_synsem := m_or_c_noun_ppcomp_synsem & common_noun_synsem.

noun_deverb_ppcomp_synsem := basic_noun_ppcomp_synsem & nonpro_nomod_synsem &
                             common_noun_synsem & basic_two_arg.

noun_ppcomp_two_arg_synsem := noun_ppcomp_synsem & two_arg.

temp_noun_ppcomp_synsem := basic_noun_ppcomp_synsem & nonpro_nomod_synsem & 
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL.KEYS.KEY _of_rel,
				OPT + ], ... >,
                      SUBJ < >,
		      SPR < [ OPT - ] > ],
	    CONT.RELS <! relation !>,
	    KEYS.KEY temp_abstr_rel ] ].

temp_noun_ppcomp_two_arg_synsem := temp_noun_ppcomp_synsem & two_arg.

; For e.g. "hotel" as in "the hotel Marriott" or "the Marriott hotel Hannover"c
basic_noun_npcomp_synsem := noun_two_arg_nomod_synsem &
  [ LOCAL [ CAT.VAL.COMPS < expressed_synsem & 
                            [ LOCAL [ CAT nomp_cat_acc_min,
                                      AGR.DIVISIBLE strict_sort,
                                      CONJ cnil,
                                      KEYS [ KEY abstr_named_rel,
                                             MESSAGE 0-dlist ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #cindex ] ] ] >,
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #index ],
		   RELS <! relation, 
			    unspec_rel &
			    [ LBL #hand,
			      ARG1 #index,
			      ARG2 #cindex ] !>,
                   HCONS <! !> ],
	    KEYS.KEY.LBL #hand ] ].

common_noun_npcomp_synsem := basic_noun_npcomp_synsem &
  [ LOCAL [ STEMHEAD countnstem,
            CAT.VAL.COMPS < [ OPT - ] > ] ].

common_noun_numcomp_synsem := noun_two_arg_nomod_synsem &
  [ LOCAL [ STEMHEAD countnstem,
            CAT.VAL.COMPS < synsem & [ LOCAL [ CAT [ HEAD intadj,
                                                     VAL [ SPR *olist*,
                                                           COMPS *olist* ] ],
					       CONJ cnil,
					       KEYS.KEY integer_rel &
                                                   [ LBL #hand ],
                                               CONT.HOOK.INDEX #index ],
                                       OPT - ] >,
            KEYS.KEY.LBL #hand,
            CONT [ HOOK.INDEX #index,
		   RELS <! reg_nom_rel !>,
                   HCONS <! !> ] ] ].

; ERB (14-12-97) It might be cleaner in some sense for pro_ss to have that
; pron_rel as its key and then have this construction and others like it
; take the value of that KEY and put it on their RELS.  Also, if we
; ever move to lexical amalgamation of relations, the pron_rel should get
; incorporated automatically. ... So I'm going to try to do it that way.

; ERB (14-12-97) We just decided that there shouldn't be a pron_rel here.
; The feature PRONTYPE is enough to distinguish the instance introduced
; by the pro_ss as one that doesn't have to be bound.

; ERB (21-01-98) The pro_ss should be unslashed.

basic_mass_noun_synsem := basic_common_noun_synsem & nonpro_nomod_synsem &
  [ LOCAL [ STEMHEAD massnstem,
            CONT.HOOK.INDEX [ PNG png & [ PN 3sg* ],
                              DIVISIBLE +* ] ] ].

scoping_noun_synsem := noun_two_arg_nomod_synsem &
  [ LOCAL [ CAT.VAL.--KEYCOMP [ LOCAL [ CONT.HOOK.LTOP #hand,
					KEYS.MESSAGE 1-dlist ] ],
	    KEYS.KEY basic_hcomp_nom_rel & [ ARG1 #hand ] ] ].

;; a way to meet

common_noun_vpcomp_synsem := scoping_noun_synsem & common_noun_synsem &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp,
		      COMPS < #comp & phr_synsem &
			      [ LOCAL [ CAT vp_inf_cat &
					 [ VAL.SUBJ 
					    < pro_ss &
					      [ NON-LOCAL.SLASH 0-dlist ] > ],
					KEYS.MESSAGE 1-dlist &
						       <! propositional_rel !>,
                                        CONT.HOOK.XARG #inst,
					CONJ cnil ],
				OPT - ] > ],
	    CONT [ RELS <! relation, 
                          def_rel & [ RSTR #rhand,
                                      ARG0 #inst ],
                          pron_rel &
			  [ LBL #prohand,
			    ARG0 #inst & [ PRONTYPE zero_pron ] ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #prohand ] !> ] ] ].

basic_common_noun_cpcomp_synsem := scoping_noun_synsem &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp,
		      COMPS < #comp & synsem &
			    [ LOCAL [ CAT.HEAD strict_type,
				      CONJ cnil ],
			      OPT - ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

common_noun_cpcomp_synsem := basic_common_noun_cpcomp_synsem &
  [ LOCAL [ STEMHEAD countnstem,
            CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp ] > ] ].

common_noun_cpcomp_fin_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ].

common_noun_cpcomp_inf_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_inf_v_c ] > ].

common_noun_cpcomp_bse_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_bse ] > ].

mass_count_noun_cpcomp_fin_synsem := basic_common_noun_cpcomp_synsem &
  [ LOCAL [ STEMHEAD masscountnstem,
            CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c & [ HEAD comp ] ] > ] ].

mass_noun_synsem := basic_mass_noun_synsem & one_arg &
  [ LOCAL [ CAT.VAL.COMPS < >,
            CONT.RELS <! relation !> ] ].

mass_noun_ppcomp_synsem := basic_mass_noun_synsem & two_arg &
                           noun_nondeverb_ppcomp_synsem &
  [ LOCAL.CONT.RELS <! relation !> ].

mass_or_count_ppcomp_synsem := basic_mass_or_count_synsem & two_arg &
                               noun_nondeverb_ppcomp_synsem.

mass_noun_npcomp_synsem := basic_mass_noun_synsem & basic_noun_npcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

#|
; DPF 8-Sept-01 - Not currently using deverbal noun typse

; One of the relations in RELS is the support relation nominalize_rel 
; which is a subtype of nom_rel, but also introduces the ARG1 attribute 
; for the handle of the verbal relation.  The other rel is the verbal relation.

deverbal_noun_synsem := noun_nonpro_nomod_synsem &
  [ LOCAL [ STEMHEAD countnstem,
            KEYS.ALTKEY #altkey,
	    CONT [ RELS <! nominalize_rel & [ ARG1 #arghand ],
                          prpstn_rel & [ LBL #arghand,
                                         MARG #marghand ],
                          relation & #altkey & [ LBL #vhand ] !>,
                   HCONS <! qeq & [ HARG #marghand,
                                    LARG #vhand ] !> ] ] ].

deverbal_intr_noun_synsem := deverbal_noun_synsem & noun_nocomp_synsem.

deverbal_trans_noun_synsem := deverbal_noun_synsem & 
                              noun_deverb_ppcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ] > ].

deverbal_mass_noun_synsem := deverbal_noun_synsem & 
                             nonpro_nomod_onearg_synsem &
  [ LOCAL [ CAT.VAL.COMPS < >,
	    CONT.HOOK.INDEX [ PNG png & [ PN 3sg* ],
                              DIVISIBLE +* ] ] ].

deverbal_mass_noun_ppcomp_synsem := deverbal_trans_noun_synsem &
  [ LOCAL.CONT.HOOK.INDEX [ PNG png & [ PN 3sg* ],
		       DIVISIBLE +* ] ].

deverbal_noun_intr_le := hcons_amalg_affixed_word &
  [ SYNSEM deverbal_intr_noun_synsem &
	   [ MODIFIED notmod ] ].

; For e.g. "meetings", where the singular form is a gerund, which is of type
; word, but we can't yet do plural affixation on words, only on lexemes.
deverbal_noun_intr_plural_le := amalg_word &
  [ SYNSEM deverbal_intr_noun_synsem & 
	   [ LOCAL.CONT.HOOK.INDEX.PNG png & [ PN 3pl* ],
	     MODIFIED notmod ] ].

deverbal_noun_trans_word := hcons_amalg_affixed_word &
  [ SYNSEM deverbal_trans_noun_synsem &
	   [ MODIFIED notmod ] ].

deverbal_massn_le := amalg_word &
  [ SYNSEM deverbal_mass_noun_synsem &
	   [ MODIFIED notmod ] ].

deverbal_massn_pp_le := amalg_word &
  [ SYNSEM deverbal_mass_noun_ppcomp_synsem &
	   [ MODIFIED notmod ] ].

|#

; PRD feature used as a hack to avoid partitives in noun-noun compounds,
; pending a better analysis.
; DPF 9-Sept-99 - Changed N-N block to be based on non-empty ALTKEY, rather 
; than PRD. The handle of the of-NP should probably be an argument of the 
; part_of relation, as the value of a feature SET.  But for now we simply 
; identify the handles of the part_of and the of_NP.

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

basic_partitive_noun_synsem := basic_noun_synsem &
  [ LOCAL [ CAT [ HEAD partn &
                       [ MOD < > ],
		  VAL [ SUBJ < >,
                        --KEYCOMP 
                             [ LOCAL local_min &
					[ CAT [ HEAD prep & 
						     [ PRD -,
                                                       TAM.TENSE no_tense ],
						VAL.COMPS *olist* ],
                                          CONT.HOOK [ LTOP #nhand,
                                                      INDEX #index ],
					  KEYS.KEY #ckey & _of_rel ],
                               NON-LOCAL.SLASH 0-dlist ] ] ],
            CONT [ HOOK.INDEX #index,
		   HCONS.LIST < qeq & [ HARG #phand,
                                        LARG #nhand ], ... > ],
	    KEYS [ KEY.LBL #nhand,
		   ALTKEY quant_or_wh_rel &
                       [ ARG0 #index,
                         RSTR #phand ],
		   --COMPKEY #ckey ] ] ].

;; DPF 10-Oct-00 - SPR.KEYS.KEY needs fixing

partitive_noun_synsem := basic_partitive_noun_synsem &
  [ LOCAL [ CAT.VAL [ SPR  < [ LOCAL local_min &
                                     [ CAT.VAL [ SPR  *olist*,
                                                 COMPS *olist* ],
                                       CONT.HOOK.LTOP #hand,
                                       KEYS.KEY degree_rel &
                                               [ DARG #pred ] ],
                               NON-LOCAL [ QUE 0-dlist,
                                           REL 0-dlist ],
                               OPT + ] >,
                      --KEYCOMP.OPT - ],
            CONT.HOOK.LTOP #khand,
            KEYS [ KEY [ LBL #khand,
                         PRED #pred ],
                   ALTKEY.LBL #hand ] ] ].

partitive_noun_ppof_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp & [ LOCAL.KEYS.KEY.ARG2 #arg ],
                      COMPS < #comp > ],
            KEYS.KEY part_of_rel & [ ARG1 #arg & non_expl-ind ] ] ].

partitive_noun_ppof_agr_synsem := partitive_noun_ppof_synsem &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.AGR [ PNG.PN #pn,
                                          DIVISIBLE #div ],
            AGR [ PNG.PN #pn,
                  DIVISIBLE #div ] ] ].

partitive_noun_ppof_noagr_synsem :< partitive_noun_ppof_synsem.

; all the books, half your salary
; DPF 11-Sept-01 - Added COMPS..ALTKEY norm_non_conj_rel to block e.g.
; 'both Abrams or Browne arrived'
; DPF 1-Oct-01 - Replaced the above with ALTKEY explicit_quant_rel to avoid
; spurious parse for "All books".  Maybe no longer need norm_non_conj_rel.

partitive_noun_NP_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
                            [ LOCAL [ CAT nomp_cat_acc_min,
                                      AGR.DIVISIBLE strict_sort,
                                      KEYS [ MESSAGE 0-dlist,
                                             ALTKEY explicit_quant_rel ],
                                      CONJ cnil,
                                      CONT.HOOK.INDEX #arg ],
                              OPT - ] >,
            KEYS.KEY part_of_rel & [ LBL #hand,
                                     ARG0 #index,
                                     ARG1 #arg & non_expl-ind ],
            CONT.RELS <! relation &
                          [ WLINK #wlink ],
                        relation & [ WLINK #wlink ], 
                        _of_rel & 
                        [ LBL #hand,
                          ARG0.E.TENSE no_tense,
                          ARG1 #index,
                          ARG2 #arg ] !> ] ].

partitive_noun_NP_agr_synsem := partitive_noun_NP_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR [ PNG.PN #pn,
                                          DIVISIBLE #div ] ] >,
            AGR [ PNG.PN #pn,
                  DIVISIBLE #div ] ] ].

partitive_noun_NP_noagr_synsem :< partitive_noun_NP_synsem.

; KEY should be generic_nonpro_rel, but apparently somewhere need part_of_rel
partitive_noun_nocomp_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT.VAL.COMPS < >,
            KEYS.KEY part_of_rel ] ].


basic_noun_word :< word.
basic_pronoun_word :< basic_noun_word.
noun_noninfl_word := hcons_amalg_word & basic_noun_word &
  [ INFLECTED - ].

noun_word := hcons_amalg_affixed_word & basic_noun_word.

basic_intr_noun_word := noun_noninfl_word &
  [ SYNSEM common_noun_nocomp_synsem &
	   [ LOCAL.CONT [ RELS <! relation !>,
                          HCONS <! !> ] ] ].

n_intr_lex_entry := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.KEYS.KEY quant_or_wh_rel ] >,
		     KEYS.KEY non_temp_nom_rel ],
	     MODIFIED notmod ] ].

n_intr_le :< n_intr_lex_entry.
n_intr_poss_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.POSS + ] > ].
n_intr_nospr_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < unexpressed > ].
n_intr_temp_le := basic_intr_noun_word & 
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.KEYS.KEY quant_or_wh_rel ] >,
		     KEYS.KEY temp_abstr_rel ],
             MODIFIED notmod ] ].
n_intr_sg_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG.PN 3sg ].

irreg_intr_noun_le := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.KEYS.KEY quant_or_wh_rel ] >,
		     KEYS.KEY basic_nom_rel ],
	     MODIFIED notmod ] ].

basic_noun_ppcomp_word := noun_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL.CONT.RELS <! relation !> ] ].

noun_ppcomp_word := basic_noun_ppcomp_word &
  [ SYNSEM.MODIFIED notmod ].

n_ppcomp_le :< noun_ppcomp_word.

n_ppcomp_oblig_le := noun_ppcomp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

n_ppof_le := noun_ppcomp_word &
  [ SYNSEM.LOCAL.KEYS.--COMPKEY _of_rel ].

n_ppof_oblig_le := noun_ppcomp_word &
  [ SYNSEM.LOCAL [ KEYS.--COMPKEY _of_rel,
                   CAT.VAL.COMPS < [ OPT - ] > ] ].

n_meas_ppof_le := basic_noun_ppcomp_word &
  [ SYNSEM.LOCAL.KEYS.--COMPKEY _of_rel ].

n_ppon_le := noun_ppcomp_word &
  [ SYNSEM.LOCAL.KEYS.--COMPKEY _on_rel ].

noun_ppin_word := noun_ppcomp_word &
  [ SYNSEM.LOCAL.KEYS.--COMPKEY _in_rel_s ].

basic_n_temp_ppcomp_lexent := noun_word &
  [ SYNSEM temp_noun_ppcomp_two_arg_synsem &
           [ LOCAL.STEMHEAD countnstem ] ].

; DPF 22-May-02 - Note that we have to have two entries for the word "time",
; one which must take a determiner, and which can appear in a temp-mod phrase;
; and the other which denotes a temporal chunk and can't appear as temp-mod:
; "He'll stay this time" but "*He stayed time for a meeting" (Cf. "Do you 
; have time for a meeting.")

n_temp_ppcomp_le := basic_n_temp_ppcomp_lexent &
  [ SYNSEM.MODIFIED notmod ].

; DPF 22-May-02 - Changed ALTKEY from basic_nom_rel to quant_or_wh_rel to be 
; consistent with constraints on relative clause modifiees.
n_day_of_week_le := basic_n_temp_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.KEYS.--COMPKEY 
                                        non_day_diadic_modable_rel ] >,
                   KEYS [ KEY dofw_rel,
                          ALTKEY quant_or_wh_rel ] ] ].

; DPF 13-May-02 - Added PERIPH + to prevent these from appearing as heads of
; noun-noun compounds.
; DPF 22-May-02 - But this also blocks "rainy April" - try again.
; DPF 22-May-02 - Changed ALTKEY from basic_nom_rel to quant_or_wh_rel to be 
; consistent with constraints on relative clause modifiees.

n_month_le := basic_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.KEYS.--COMPKEY yofc_rel ] >,
                     KEYS [ KEY mofy_rel,
                            ALTKEY quant_or_wh_rel ] ],
             MODIFIED notmod ] ].

; "way" as in "find a way to do that" -- was used in VM, but analysis changed
; so this type not currently in use.  Its semrel.tdl entry was as follows:
;   _way_rel := hcomp_nom_rel &
;     [ ARG0.SORT entity ].

n_vpcomp_le := noun_word &
  [ SYNSEM common_noun_vpcomp_synsem &
	   [ MODIFIED notmod ] ].

n_cpcomp_fin_le := noun_word &
  [ SYNSEM common_noun_cpcomp_fin_synsem &
	   [ MODIFIED notmod ] ].

; 'way' - The way Kim talked bothered sandy"
n_cpcomp_fin_optthat_le := noun_word &
  [ SYNSEM basic_common_noun_cpcomp_synsem &
	   [ MODIFIED notmod,
             LOCAL [ STEMHEAD countnstem,
                     CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ] ] ].

; 'request'
n_cpcomp_bse_le := noun_word &
  [ SYNSEM common_noun_cpcomp_bse_synsem &
	   [ MODIFIED notmod ] ].

; procedure
n_cpcomp_inf_le := noun_word &
  [ SYNSEM common_noun_cpcomp_inf_synsem &
	   [ MODIFIED notmod ] ].

; notification
n_mass_count_cpcomp_fin_le := noun_word &
  [ SYNSEM mass_count_noun_cpcomp_fin_synsem &
	   [ MODIFIED notmod ] ].

n_npcomp_le := hc_word & basic_noun_word &
  [ INFLECTED -,
    SYNSEM common_noun_npcomp_synsem &
	   [ LOCAL.CAT.HC-LEX +,
	     MODIFIED notmod ] ].

; Leave unmarked for INFLECTED to allow "a $ 500 check" (where $ unifies with
; [INFLECTED -]).
n_numcomp_le := mcna & nonconj & nonmsg & topkey & hc-to-phr & 
                basic_noun_word &
  [ SYNSEM common_noun_numcomp_synsem &
	   [ LOCAL.KEYS.KEY.WLINK *cons*,
             MODIFIED notmod ] ].

n_mass_le := noun_noninfl_word &
  [ SYNSEM mass_noun_synsem &
	   [ MODIFIED notmod ] ].

n_mass_count_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFIED notmod ] ].

n_mass_ppcomp_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ MODIFIED notmod ] ].

n_mass_ppcomp_oblig_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ MODIFIED notmod,
             LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

n_mass_count_ppcomp_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
	   [ MODIFIED notmod ] ].

n_mass_count_ppof_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFIED notmod,
	     LOCAL.KEYS [ KEY reg_diadic_nom_rel,
                          --COMPKEY _of_rel ] ] ].

n_mass_count_ppfor_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFIED notmod,
	     LOCAL.KEYS.--COMPKEY _for_rel ] ].

n_mass_count_ppto_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFIED notmod,
	     LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
                     KEYS.--COMPKEY _to_rel ] ] ].

n_mass_count_ppin_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFIED notmod,
	     LOCAL.KEYS.--COMPKEY _in_rel ] ].

; "late fall 2000"
n_mass_npcomp_le := noun_noninfl_word &
  [ SYNSEM mass_noun_npcomp_synsem &
	   [ MODIFIED notmod ] ].

n_plur_lexent := amalg_word & basic_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL.CONT [ HOOK.INDEX.PNG png & [ PN 3pl* ],
			  RELS <! relation !>,
                          HCONS <! !> ] ] ].

n_plur_le := n_plur_lexent &
  [ SYNSEM.MODIFIED notmod ].

; For plurals like "sixties" which can directly undergo the temp_mod rule.
n_plur_xmod_le :< n_plur_lexent.

n_plur_ppcomp_le := amalg_word & basic_noun_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL.CONT [ HOOK.INDEX.PNG png & [ PN 3pl* ],
			  RELS <! relation !> ],
	     MODIFIED notmod ] ].

; "kind"
n_plur_sing_ppcomp_le := amalg_word & basic_noun_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ AGR.DIVISIBLE -,
                     CONT [ HOOK.INDEX.PNG png & [ PN 3pl* ],
                            RELS <! relation !> ] ],
	     MODIFIED notmod ] ].

n_part_lexent := que_word & basic_noun_word &
  [ SYNSEM partitive_noun_synsem &
	   [ LOCAL [ CONT [ RELS.LIST < #key, #altkey, ... >,
                            HCONS <! qeq !> ],
                     KEYS [ KEY #key,
                            ALTKEY #altkey ] ],
             NON-LOCAL.QUE 0-dlist,
	     MODIFIED notmod ] ].

n_part_ppof_agr_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_agr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !> ] ].

n_part_ppof_noagr_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_noagr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !> ] ].

n_part_npcomp_agr_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_agr_synsem ].

n_part_npcomp_noagr_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_noagr_synsem ].

n_part_nocomp_le := n_part_lexent &
  [ SYNSEM partitive_noun_nocomp_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !> ] ].

;;
;; Lexical NPs
;;
;;   (proper names, pronouns, names of weekdays, ...)

basic_np_synsem := ref_synsem &
  [ LOCAL.CAT [ HEAD noun*,
                VAL.SUBJ < > ] ].

basic_np_word := basic_nontopkey & hc-to-phr & basic_noun_word &
  [ SYNSEM basic_np_synsem ].

non_affixed_np := basic_nontopkey & hc-to-phr & nonque & nonmsg & 
                  basic_noun_word &
  [ SYNSEM [ MODIFIED notmod,
             LOCAL.CAT.VAL.COMPS < > ] ].

np_word := basic_np_word & non_affixed_np &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < > ].

np_synsem := noun_synsem & nomod_synsem.

basic_np_sing_synsem := basic_np_synsem &
  [ LOCAL [ KEYS.KEY.LBL #keyhand,
            CONT [ RELS.LIST < basic_nom_rel &
                                [ ARG0 #ind ],
                                quant_rel &
                                [ ARG0 #ind,
                                  RSTR #rhand ], ... >,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #keyhand ] !> ] ] ].

basic_np_sing_word := basic_np_word &
  [ SYNSEM basic_np_sing_synsem ].

np_sing_synsem := basic_np_sing_synsem & np_synsem &
  [ LOCAL [ CAT.VAL [ SPR < >,
                      COMPS < > ],
            CONT.RELS <! relation, proper_q_rel !> ],
    MODIFIED notmod ].

np_sing_word := basic_np_sing_word & nonque & nonmsg &
  [ SYNSEM np_sing_synsem ].

; DPF 10-Apr-02 - Changed ALTKEY from basic_nom_rel to implicit_quant_rel so
; proper names can form compounds like in "the Kim Browne story"

; DPF 15-May-02 - Changed proper names so they now inflect, allowing plural
; forms as in "they hired two Chiangs"

n_proper_lexent := basic_hcons_amalg_word & nonslash & nonrel & nonque & 
                   basic_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ MODIFIED notmod,
             LOCAL [ CAT.VAL [ SPR < [ LOCAL [ KEYS.KEY quant_or_wh_rel ] ] >,
                               COMPS < > ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #index ],
                            RELS <! relation !>,
                            HCONS <! !> ],
		     KEYS [ KEY named_rel & [ LBL #ltop ],
                            ALTKEY implicit_quant_rel ],
                     AGR #index ] ],
    INFLECTED - ].

; DPF 26-Mar-01 - Added MODIFIED.PERIPH + to prevent (restrictive) post-nom
; modifiers of bare proper names, as in "*Abrams by Browne arrived." though
; this will also block "Abrams from New York just called".  Not clear what
; the contrast is due to.
; DPF 1-Jun-02 - But this was too strong, so relaxed the reduced-rel rule
; but keep this constraint here, since it still serves to prevent proper names
; from appearing as heads of n-n compounds, blocking "interview Sandy"

n_proper_le := n_proper_lexent &
  [ SYNSEM.MODIFIED.PERIPH + ].
n_proper_fem_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.GEN fem ].
n_proper_masc_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.GEN masc ].

proper_n_synsem := np_sing_synsem &
  [ LOCAL [ KEYS.KEY gen_named_rel,
            CONT.HOOK.INDEX.PNG png & [ PN 3sg* ] ] ].

; Add ALTKEY to block these in left position of noun-noun compounds
n_proper_abb_le := np_sing_word & 
  [ SYNSEM proper_n_synsem &
           [ LOCAL.KEYS [ KEY named_abb_rel,
                          ALTKEY pron_rel ] ] ].

; "here, there" as in "get out of here/there" 
; Make SYNSEM pronominal_synsem to block N-N cmpnds like "the there meeting"
; Added PRD + so appositives with left member np_adv won't join in N-N-cmpnds.
; DPF 23-Oct-00 - Since pronominal_synsem no longer constrains left member of
; noun-noun compounds, use alternate hack of making ALTKEY not unify with
; the [ALTKEY no_rel] constraint in the n-n-cmpnd rule.

np_adv_synsem := basic_np_sing_synsem & pronominal_synsem &
  [ LOCAL.KEYS [ ALTKEY relation,
                 ALT2KEY relation ] ].

basic_np_adv_word := basic_np_sing_word & nonmsg &
  [ SYNSEM np_adv_synsem &
	   [ LOCAL [ CONT [ HOOK.INDEX #ind & [ PNG png & [ PN 3sg* ] ],
                            RELS.LIST < relation, #altkey, ... > ],
                     KEYS.ALTKEY #altkey,
		     AGR #ind ] ] ].

; DPF 4-Apr-01 - Made ALTKEY be def_explicit_rel to block these guys as left 
; members of compounds as in "*the there books"
; DPF 11-Mar-02 - Changed SPR from anti_synsem to [KEY just_only_very_deg_rel]
; to allow "kim arrived just yesterday".

np_adv_word := basic_np_adv_word & nonque &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.KEYS.KEY just_only_very_deg_rel ] >,
                           COMPS < > ] ].
                   
np_adv_simple_lexent := np_adv_word &
  [ SYNSEM.LOCAL [ CONT.RELS <! relation, relation !>,
                   KEYS.ALTKEY def_explicit_rel ] ].

np_adv_lexent := np_adv_word &
  [ SYNSEM.LOCAL [ CONT.RELS <! relation & [ LBL #hand,
                                              ARG0 #inst ], 
                               def_rel,
                               #alt2key & [ LBL #hand,
                                            ARG1 #inst ] !>,
                   KEYS.ALT2KEY #alt2key ] ].

n_adv_le :< np_adv_lexent.
n_adv_event_le := np_adv_lexent &
  [ SYNSEM.LOCAL.KEYS.ALT2KEY.ARG0.E.TENSE no_tense ].

; 'there'
n_adv_acc_le := np_adv_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE acc ].

; 'then' -- to block "then Kim left" as N+RelClause.  Hack, since this
; also blocks "right then".
n_adv_nospr_le := np_adv_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < anti_synsem > ].

n_adv_too_le := np_adv_word &
  [ SYNSEM.LOCAL [ CONT.RELS <! relation & [ LBL #hand,
                                              ARG0 #inst ], 
                               def_rel,
                               #alt2key & [ LBL #hand,
                                            ARG0.E.TENSE no_tense,
                                            ARG1 #inst,
                                            PRED #pred ],
                               _too_deg_rel & [ LBL #hand,
                                                DARG #pred ] !>,
                   KEYS.ALT2KEY #alt2key ] ].

n_adv_simp_acc_le := np_adv_simple_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ CASE acc,
                            PRD - ] ].

; For adverbs like 'late' which can take a specifier as in 'fairly late'
n_adv_wspec_le := basic_np_adv_word & nonque &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < synsem & [ LOCAL local_min &
					   [ CAT [ HEAD adv,
						   VAL [ SPR *olist*,
							 COMPS *olist* ] ],
                                             CONT.HOOK.LTOP #hand,
					     KEYS.KEY degree_rel &
						 [ DARG #pred ] ],
				     NON-LOCAL.QUE 0-dlist,
				     OPT + ] >,
                             COMPS < > ],
                   CONT.RELS <! relation & [ LBL #hand,
                                              ARG0 #inst ], 
                               def_explicit_rel,
                               #alt2key & [ LBL #hand,
                                            ARG0.E.TENSE no_tense,
                                            ARG1 #inst,
                                            PRED #pred ] !>,
                   KEYS.ALT2KEY #alt2key ] ].


n_adv_arg_le := basic_np_adv_word & nonque &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < synsem & [ LOCAL local_min &
                                              [ CAT [ HEAD adv,
                                                      VAL [ SPR *olist*,
                                                            COMPS *olist* ] ],
                                                CONT.HOOK.LTOP #hand,
                                                KEYS.KEY degree_rel &
                                                    [ DARG #pred ] ],
                                              NON-LOCAL.QUE 0-dlist,
                                              OPT + ] >,
                             COMPS < synsem &
                                   [ LOCAL [ CAT np_cat_acc_min,
                                             CONT.HOOK.INDEX #intarg ],
                                     OPT + ] > ],
                   CONT.RELS <! [ LBL #hand,
                                   ARG0 #extarg,
                                   WLINK #wlink ], 
                                implicit_quant_rel, 
                                #alt2key &
                                 [ LBL #hand,
                                   ARG0.E.TENSE no_tense,
                                   ARG1 #extarg,
                                   ARG2 #intarg,
                                   PRED #pred,
                                   WLINK #wlink ] !>,
                   KEYS.ALT2KEY #alt2key ] ].
    

; DPF 4-Apr-01 - ALTKEY was abstr_def_rel,
n_comp_adv_le := np_adv_word &
  [ SYNSEM.LOCAL [ CONT.RELS <! modable_rel & 
                               [ LBL #hand, 
				 ARG0 #inst ],
                               def_explicit_rel,
			       basic_arg1_rel & #alt2key &
			       [ LBL #hand,
				 ARG1 #inst ],
                               comp_rel &
                               [ LBL #hand,
                                 ARG1 #inst ] !>,
                   KEYS.ALT2KEY #alt2key ] ].

; DPF 27-Apr-00 - Added [CASE acc] to block spurious parse for "where is kim"
; DPF 19-Oct-02 - But this unfortunately also blocks "when would be a good 
; time to meet".  Leave for now.

n_wh_adv_le := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.CASE acc,
                           VAL [ SPR < anti_synsem >,
                                 COMPS 
                                  < [ OPT +,
                                      LOCAL [ CAT.HEAD wh_adv,
                                              CONJ cnil,
                                              KEYS.KEY wh_the_hell_rel ]]>]],
                     CONT.RELS <! relation, which_rel !> ],
             NON-LOCAL.QUE 1-dlist &
		         [ LIST < handle > ] ] ].

; Lexical NP plurals - maybe only in British English? ("IBM are hiring again.")
;
np_pl_word := np_word &
  [ SYNSEM np_synsem &
	   [ LOCAL.CONT.HOOK.INDEX.PNG png & [ PN 3pl* ] ] ].

np_ersatz_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < >,
                  VAL [ SPR < >,
			SUBJ < >,
			COMPS < > ] ],
            KEYS.KEY #key & [ LBL #hand ],
	    CONT nom-obj &
		[ HOOK [ LTOP #hand,
                         INDEX ref-ind &
                             [ PNG png & [ PN 3sg* ] ] ],
		  RELS.LIST < #key, ... >,
		  HCONS <! !> ] ] ].

np_word_no_quant := non_affixed_np &
  [ SYNSEM np_ersatz_synsem ].

pers_pro_synsem := basic_np_synsem & ref_pro_synsem &
  [ LOCAL.CAT.VAL [ SPR < >,
                    COMPS < > ] ].

personal_pro := np_word & basic_pronoun_word &
  [ SYNSEM pers_pro_synsem &
	   [ LOCAL.CONT [ RELS <! pron_rel & [ LBL #prohand,
                                                ARG0 #inst ],
                                   def_rel & [ RSTR #rhand,
                                               ARG0 #inst ] !>,
                          HCONS <! qeq & [ HARG #rhand,
                                           LARG #prohand ] !> ] ] ].

n_pers_pro_noagr_le := personal_pro &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE nom,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 3sg*,
                                               GEN andro* ],
				   PRONTYPE std_3 ],
                   AGR.PNG png & [ PN 3pl* ] ] ].

n_pers_pro_lexent := personal_pro & 
  [ SYNSEM.LOCAL [ AGR #agr,
		   CONT.HOOK.INDEX #agr &
			        [ PRONTYPE std_pron ] ] ].

n_pers_pro_he_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE nom,
                   KEYS.KEY.ARG0 [ PNG png & [ PN 3sg*,
                                               GEN masc* ],
                                   PRONTYPE std_3 ] ] ].

n_pers_pro_she_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE nom,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 3sg*,
					       GEN fem* ],
				   PRONTYPE std_3 ] ] ].

n_pers_pro_her_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 3sg*,
					       GEN fem* ],
				   PRONTYPE std_3 ] ] ].

n_pers_pro_him_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 3sg*,
					       GEN masc* ],
				   PRONTYPE std_3 ] ] ].

n_pers_pro_i_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE nom,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 1sg* ],
				   PRONTYPE std_1sg ] ] ].

n_pers_pro_me_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 1sg* ],
				   PRONTYPE std_1sg ] ] ].

n_pers_pro_one_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0 [ PNG png & [ PN 3sg*,
					     GEN andro1* ],
				 PRONTYPE std_3 ] ].

n_pers_pro_one_another_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   KEYS.KEY.ARG0.PNG png & [ PN 3sg*,
					     GEN andro1* ] ] ].

; DPF 7-Dec-02 - ACTIVATED is here experimentally, and at present only prevents
; "it" from being topicalized as in "*It I like".

n_pers_pro_it_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ KEYS.KEY.ARG0 [ PNG png & [ PN 3sg*,
					       GEN neut* ],
				       PRONTYPE std_3 ],
		   CTXT.ACTIVATED - ] ].

n_pers_pro_them_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 3pl* ],
				   PRONTYPE std_3 ] ] ].

n_pers_pro_they_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE nom,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 3pl* ],
				   PRONTYPE std_3 ] ] ].

n_pers_pro_us_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 1pl* ],
				   PRONTYPE std_1pl ] ] ].

n_pers_pro_we_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE nom,
		   KEYS.KEY.ARG0 [ PNG png & [ PN 1pl* ],
				   PRONTYPE std_1pl ] ] ].


n_pers_pro_you_le := n_pers_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0 [ PNG png & [ PN 2per ],
				 PRONTYPE std_2 ] ].


n_refl_pro_lexent := personal_pro &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   AGR #agr,
		   CONT.HOOK.INDEX #agr,
		   KEYS.KEY pron_rel &
			    [ ARG0.PRONTYPE refl ] ] ].

n_refl_pro_herself_le := n_refl_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 3sg*,
                                           GEN fem* ] ].
n_refl_pro_himself_le := n_refl_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 3sg*,
					   GEN masc* ] ].
n_refl_pro_itself_le := n_refl_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 3sg*,
					   GEN neut* ] ].
n_refl_pro_myself_le := n_refl_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 1sg* ] ].
n_refl_pro_ourselves_le := n_refl_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 1pl* ] ].
n_refl_pro_themselves_le := n_refl_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 3pl* ] ].
n_refl_pro_yourself_le := n_refl_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 2sg* ] ].
n_refl_pro_yourselves_le := n_refl_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 2pl* ] ].

n_recip_pro_le := np_word &
  [ SYNSEM ref_pro_synsem &
	   [ LOCAL [ CAT.HEAD.CASE acc,
		     AGR #agr,
		     CONT [ HOOK.INDEX #agr,
			    RELS <! recip_pro_rel &
                                     [ ARG0.PRONTYPE recip ] !>,
                            HCONS <! !> ],
                     KEYS.KEY.ARG0.PNG png & [ PN non1sg ] ] ] ].


; 'yours'
; DPF 15-Apr-00 = Changed KEY to be pron_rel rather than pronoun_q_rel, since
; e.g. prepositions want a non_temp_nom_rel as their argument.
; DPF 19-Oct-02 - Replaced SPEC < anti_synsem > with < > to allow "than mine",
; even though this constraint was the hack to keep these from appearing in
; tag questions.  Instead, use contrast in ALTKEY.

n_poss_pro_lexent := basic_nontopkey & nonmsg & hc-to-phr & 
                     basic_pronoun_word &
  [ SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD noun*,
                           VAL [ SPR < >,
				 COMPS < >,
				 SPEC < > ] ],
                     AGR #index,
		     CONT [ HOOK.INDEX #index,
			    RELS <! pron_rel & #key & 
				     [ LBL #prohand,
				       ARG0 #eind &
					      [ PRONTYPE std_pron ] ],
                                     def_rel &
				     [ ARG0 #eind,
				       RSTR #rhand ],
				     pronoun_q_rel &
				     [ ARG0 #index,
				       RSTR #phand ],
                                     part_of_rel &
                                     [ LBL #nhand,
                                       ARG0 #index ],
				     basic_poss_rel & #altkey & 
				     [ LBL #nhand,
                                       ARG0.E.TENSE no_tense,
				       ARG2 #eind,
				       ARG1 #index ] !>,
			    HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ],
                                      qeq & [ HARG #phand,
                                              LARG #nhand ] !> ],
		     KEYS [ KEY #key,
			    ALTKEY #altkey ] ],
             NON-LOCAL.QUE <! !>,
	     MODIFIED notmod ] ].

n_poss_pro_hers_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3sg*,
                                                        GEN fem* ] ].
n_poss_pro_his_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3sg*,
							GEN masc* ] ].
n_poss_pro_its_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3sg*,
							GEN neut* ] ].
n_poss_pro_mine_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1sg* ] ].
n_poss_pro_ours_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1pl* ] ].
n_poss_pro_theirs_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3pl* ] ].
n_poss_pro_yours_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 2per ] ].

; Expletive pronouns "there" and "it"
; DPF 3-Jul-02 - Changed KEY from no_rel to pron_rel, to allow simpler
; generalization about subjects of tag-phrases.  Still have empty RELS

n_expl_it_le := nontopkey & basic_pronoun_word &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ KEYS.KEY pron_rel,
		     CONT [ HOOK.INDEX it-ind,
			    RELS <! !> ] ],
	     MODIFIED notmod ] ].

n_expl_there_le := nontopkey & basic_pronoun_word &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ KEYS.KEY pron_rel,
		     CONT [ HOOK.INDEX there-ind,
			    RELS <! !> ] ],
	     MODIFIED notmod ] ].
			  

; ERB (31-10-96) A hack:  I want the wh_interrogs to be able to
; get their hands on the which_rel so they can put it on the PARAMS
; list, but QSTORE isn't working yet.  So I am making the QUE value
; of wh_pro_word, wh_adverb_word, and wh_poss_word be the handle of
; the which_rel, so that this gets passed up in such a way that I can see it.

; DPF (3-May-99) We can't just put the handle of the which_rel in QUE, since
; in coordinate structures like "which book and which record did sandy buy?"
; we want to unify the NON-LOCALs of "which book" and "which record", but this
; would mean that the handles of the two which_rel's would be wrongly 
; identified. 
; So for now I'm just putting in an unbound handle - we'll have to sort out
; with Ivan what the right solution is.

; who, what

n_wh_pro_lexent := que_word & basic_pronoun_word &
  [ SYNSEM ref_pro_synsem &
	 [ LOCAL [ CAT.VAL [ SPR < >,
			     COMPS < [ OPT +,
                                       LOCAL [ CAT.HEAD wh_adv,
                                               CONJ cnil,
                                               KEYS.KEY wh_the_hell_rel ] ] >],
                   AGR #index,
                   CONT [ HOOK.INDEX #index & [ PNG png & [ PN 3sg* ] ],
			  RELS <! [ LBL #nhand ],
				   which_rel & [ ARG0 #index,
						 RSTR #rhand ] !>,
			  HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !> ] ],
	   NON-LOCAL.QUE 1-dlist &
		         [ LIST < handle > ],
	   MODIFIED notmod ] ].

n_wh_pro_le :< n_wh_pro_lexent.
n_wh_pro_acc_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE acc ].

n_rel_pro_lexent := rel_word & basic_pronoun_word & 
  [ SYNSEM pronominal_synsem &
	 [ LOCAL [ CAT [ HEAD.MOD < >,
			 VAL [ SUBJ < >,
			       SPR < >,
			       COMPS < > ] ],
                   AGR #index,
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index ],
			  RELS <! !>,
			  HCONS <! !> ],
		   KEYS [ KEY non_temp_nom_rel,
                          ALTKEY relation ] ],
           NON-LOCAL.REL 1-dlist &
		         [ LIST < [ LTOP #hand,
				    INDEX #index ] > ] ] ].

n_rel_pro_who_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFIED notmod,
             LOCAL [ CONT.HOOK.INDEX.SORT human,
                     KEYS.KEY reg_nom_rel ] ] ].

n_rel_pro_what_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFIED notmod,
             LOCAL [ CONT.HOOK.INDEX.SORT entity,
                     KEYS.KEY reg_nom_rel ] ] ].

n_rel_pro_acc_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFIED notmod,
             LOCAL [ CAT.HEAD.CASE acc,
                     CONT.HOOK.INDEX.SORT human,
                     KEYS.KEY reg_nom_rel ] ] ].

; Unmarked for MODIFIED, so can undergo temp_np rule to get "the day that I
; arrived"
n_rel_pro_nonwh_le := n_rel_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRD -,
                   CONT.HOOK.INDEX.SORT nominal-sort,
                   KEYS.KEY modable_nom_rel ] ].

; DPF 28-Aug-99 - SPR..KEY no_rel prevents these from undergoing bare_np rule
; DPF 09-Jan-00 - In fact, can now eliminate bogus SPR, since picking up
; post-head adjuncts as complements.

generic_pro_adv_word := que_word & basic_pronoun_word &
  [ SYNSEM np_synsem &
	   [ LOCAL [ CAT.VAL [ SPR < [ LOCAL local_min &
                                             [ CONT.HOOK.LTOP #khand,
                                               KEYS.KEY degree_rel & 
                                                        [ DARG #pred ] ],
                                       NON-LOCAL [ QUE 0-dlist,
                                                   REL 0-dlist ],
                                       OPT + ] >,
                               COMPS < [ OPT +,
                                         LOCAL [ CAT prd_cat & [ HEAD adj* ],
                                                 CONJ cnil,
                                                 CONT.HOOK [ LTOP #nhand,
                                                             INDEX #inst ] ],
                                         NON-LOCAL [ SLASH 0-dlist &
                                                           [ LIST < > ],
                                                     QUE 0-dlist,
                                                     REL 0-dlist ] ] > ],
                     CONT [ HOOK.LTOP #nhand,
                            RELS <! basic_nom_rel,
				   #altkey & quant_rel !>,
			    HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !> ],
		     KEYS [ KEY [ LBL #nhand,
				  ARG0 #inst & [ PNG png & [ PN 3sg* ] ] ],
			    ALTKEY #altkey & 
				      [ LBL #khand,
                                        ARG0 #inst,
					RSTR #rhand,
                                        PRED #pred ] ] ],
	     NON-LOCAL.QUE 0-dlist ] ].

n_generic_pro_adv_le :< generic_pro_adv_word.

; At least for "anytime", which doesn't seem to appear in object position,
; and we want to avoid unwanted parse for "he might cancel anytime"
n_generic_pro_adv_nom_le := generic_pro_adv_word &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom ].

n_generic_pro_le := generic_pro_adv_word &
  [ SYNSEM.MODIFIED notmod ].

n_deictic_pro_lexent := nontopkey & basic_pronoun_word &
  [ SYNSEM ref_pro_synsem &
	   [ LOCAL [ CAT.VAL [ SPR < >,
			       COMPS < > ],
		     CONT [ HOOK.INDEX #index,
			    RELS <! generic_nom_rel, 
				     demonstrative_rel & #altkey &
				     [ ARG0 #ind,
				       RSTR #rhand ] !>,
			    HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #hand ] !> ],
		     AGR #index,
		     KEYS [ KEY [ LBL #hand,
					ARG0 #ind ],
			    ALTKEY #altkey ] ],
	     MODIFIED notmod ] ].

n_deictic_pro_sg_le := n_deictic_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 3sg*,
                                           GEN neut* ] ].

n_deictic_pro_pl_le := n_deictic_pro_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 3pl* ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsems for Auxiliary verb lexical rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ERB (05-10-97) Making this specific to question auxes.  See notes near sai
; in syntax.tdl.
; DPF 26-Jan-01 - Changed HEAD.INV + to HEAD.INV +* to allow for coordination
; of inverted and non-inverted sentences.  Prevent yes-no question rule from
; applying to main verbs by making inverted auxiliaries [MC na], so they have
; to undergo the yes-no rule.

sai_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD verb* & [ INV +*,
				 AUX +*,
                                 PRD -,
                                 MOD < [ LOCAL intersective_mod &
                                               [ CAT.VAL.SPR *cons*,
						 KEYS.KEY no_rel ] ] >,
                                TAM ind_or_mod_subj_tam ],
                  VAL.COMPS #comps & < [ NON-LOCAL.SLASH 0-dlist ], ... >,
                  POSTHEAD +,
		  MC na ],
	    KEYS.MESSAGE 0-dlist,
	    ARG-S #comps ] ].

; DPF 3-Jul-02 Changed to COMPS..KEY pron_rel from COMPS..ALTKEY no_rel,
; since common nouns are often unmarked for ALTKEY, and it was a hack.
; DPF 19-Oct-02 - Were using hack of SPEC < > to keep poss-pronouns like
; "mine" out of COMPS, but this also blocked "than mine", so instead use
; difference in ALTKEY for "she" and "hers".

tag_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD verb &
		       [ AUX -,
			 INV -,
			 TAM ind_or_mod_subj_tam & [ TENSE #tense ],
			 MOD < [ LOCAL scopal_mod &
				       [ CAT s_cat_fin &
					     [ HEAD.TAM.TENSE #tense & 
                                                              strict_sort,
                                               MC + ],
					 AGR.PNG #png & png & 
                                             [ GEN strict_sort,
                                               PN strict_sort ],
					 CONT.HOOK [ LTOP #modhand,
                                                     INDEX #ind &
                                                      [ E.TENSE real_tense ] ],
                                         KEYS [ KEY #key,
						MESSAGE 1-dlist &
						    <! #presup & 
						     propositional_rel !> ] ],
				 NON-LOCAL [ SLASH 0-dlist,
					     REL 0-dlist,
					     QUE 0-dlist ] ] > ],
		  POSTHEAD +,
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < pronominal_synsem &
				[ OPT -,
				  LOCAL [ AGR #tagagr,
					  CONT.HOOK.INDEX.PNG #png,
                                          KEYS [ KEY pron_rel,
                                                 ALTKEY never_unify_rel ]]]> ],
                  MC + ],
            AGR #tagagr,
	    CONT [ HOOK [ LTOP #nehand,
                          INDEX #ind ],
		   HCONS <! qeq &
			   [ HARG #marghand,
			     LARG #modhand ] !> ],
	    KEYS [ KEY #key,
		   MESSAGE 1-dlist &
			 <! ne_rel &
			    [ LBL #nehand,
			      MARG #marghand,
			      PARAMS <! !> ] !> ],
	    CTXT.PRESUP <! #presup !> ] ].

loc_inv_synsem := lex_synsem &
  [ LOCAL [ CAT [ VAL [ SUBJ < >,
                        SPR < >,
                        COMPS < [ OPT -,
                                  LOCAL.KEYS.KEY nonpro_rel ], ... > ],
                  MC + ],
            CONT [ HOOK.LTOP #hand,
                   HCONS <! qeq & [ HARG #marghand,
                                    LARG #vhand ] !> ],
            KEYS [ KEY.LBL #vhand,
                   MESSAGE <! prpstn_rel &
                            [ LBL #hand,
                              MARG #marghand ] !> ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADJECTIVES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (See prep_synsem definition for discussion of ARG1 attribute.)

; Predicative adjectives used to introduce an ARG0 attribute in a separate 
; support relation, as did predicative PPs, but now each introduces its own
; ARG0 attribute directly in the KEY relation.

; Assume that if adjectives have a specifier, it will be either a measure-NP,
; as in "two feet tall', 'a week later"; or a degree_adverb like "very".

; Since most adjectives are underspecified for being predicative, we have to be
; sure that when they act as modifiers, the unexpressed subject's SLASH value 
; gets terminated (given lexical SLASH amalgamation).  We can't just make the
; adjective's SUBJ be 'unexpressed' since it must unify with the real subject
; in a raising construction.  So we identify the SLASH of the MOD value with
; that of the SUBJ - only one of the two will be realized syntactically.

; Most but not all adjectives can be modifiers, so the most basic adj_synsem
; type does not introduce the MOD feature, to allow for adjectives like
; "impossible" as in "it is impossible to find Kim".

;; DPF 3-Feb-01 - Removed SPR..COMPS *olist* to allow for equatives like
;; "as tall as you" where first "as" combines with "tall" and passes up its
;; as-complement.
;; DPF 5-Apr-01 - Added [PERIPH na] to interact correctly with adj-head rule 
;; and noun-noun-cmpnd rule, to block "*towel rusty rack" - the adj-head rule 
;; makes its PERIPH value that of the adjunct dtr, and the n-n-cmpnd rule 
;; blocks all but [PERIPH -] head-dtr.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so adjs can
;; coordinate with VPs (which are necessarily SPR anti_synsem).

;; DPF 10-Oct-00 - SPR.KEYS.KEY needs fixing
;; DPF 25-Sep-01 - Added AGR reentrancy with SUBJ's AGR, like with verbs, to
;; make sure modification works right in no_copula constructions as in "skies
;; light becoming dark.  But for now must also hardwire link between SUBJ's
;; AGR and INDEX, since the bare-np rule necessarily breaks this link to get
;; DIVISIBLE right.  Sigh - this will break a few tag questions, as in
;; "Someone is happy, aren't they?"

basic_adj_synsem_lex_or_phrase := canonical_synsem &
  [ LOCAL [ STEMHEAD astem,
            AGR #agr,
            CAT [ HEAD adj* & [ TAM #tam ],
		  VAL.SUBJ < > ],
            CONT.HOOK.XARG #agr,
            KEYS.KEY basic_adj_rel &
                     [ ARG0.E #tam ] ],
    MODIFIED.PERIPH na ].

; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).

basic_adj_synsem := basic_adj_synsem_lex_or_phrase & lex_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
            CAT [ VAL [ SPR < #spr & synsem_min &
                              [ LOCAL local_min &
                                      [ CAT [ VAL.SPR *olist*,
                                              MC na ],
                                        KEYS.KEY degree_rel &
                                            [ DARG #pred ] ],
                                NON-LOCAL.SLASH 0-dlist,
                                OPT + ] >,
                        COMPS #comps ],
                  HS-LEX +* ],
            CONT.RELS.LIST < #key, ... >,
            KEYS.KEY #key & [ PRED #pred ] ] ].

;; We assume for now, counterfactually, that all modifying adjectives are
;; intersective.

;; ERB (03-02-98) Maybe should add MOD < [ LOCAL.SPR.OPT ] > - to keep 
;; adjectives from modifying partitives.

;; DPF (16-Feb-98) Made XARG be 'ref-ind' rather than non_expl-ind,
;; to ensure that it gets discourse-bound if the adjective is used in a 
;; fragment.

;; DPF (12-Jul-98) Constrain adjectives to only modify nominals with obligatory
;; specifiers (which distinguishes "common" from "proper" nominals).

adj_synsem_lex_or_phrase := basic_adj_synsem_lex_or_phrase & isect_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL [ CAT nbar_cat,
                                     CONT.HOOK.INDEX #ind & ref-ind,
                                     CONJ cnil ] ] >,
            CONT.HOOK [ INDEX #ind,
                        E-INDEX #event,
                        XARG individual ],
	    KEYS.KEY.ARG0 #event ] ].

adj_synsem := basic_adj_synsem & adj_synsem_lex_or_phrase.

; For measure-nouns used as adjectives, as in "ten foot pole"
adj_synsem_phr := adj_synsem_lex_or_phrase & phr_synsem &
  [ LOCAL.CAT [ HEAD [ PRD -,
                       MOD < [ LOCAL.KEYS.ALTKEY no_rel ] > ],
                VAL [ SPR < >,
                      COMPS < > ] ] ].

nomod_adj_synsem := basic_adj_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD no_head ] >,
            CONT.HOOK.E-INDEX #event,
	    KEYS.KEY.ARG0 #event ] ].

nonprd_synsem := lex_synsem &
  [ LOCAL.CAT.HEAD.PRD - ].

prd_synsem := lex_synsem &
  [ LOCAL.CAT.HEAD.PRD + ].

intrans_adj_synsem := adj_synsem & one_arg &
  [ LOCAL.CAT [ VAL.COMPS < >,
		POSTHEAD - ] ].

attr_adj_synsem := intrans_adj_synsem & nonprd_synsem &
  [ NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                QUE 0-dlist & [ LIST < > ],
                REL 0-dlist & [ LIST < > ] ] ].

pred_adj_synsem := adj_synsem & prd_synsem &
  [ LOCAL [ CONT.HOOK.INDEX #ind,
            KEYS.KEY.ARG1 #ind ] ].

;;; FIX
intrans_pred_adj_synsem := intrans_adj_synsem &
  [ LOCAL [ CAT.HEAD.PRD +,
            CONT.HOOK.INDEX #ind,
            KEYS.KEY.ARG1 #ind ] ].

;;; We should have a trans_adj_attr_synsem too, for 'easy' and the likes ...

pred_adj_two_arg_synsem := pred_adj_synsem & two_arg.
adj_two_arg_synsem := adj_synsem & two_arg.

trans_adj_pred_synsem := pred_adj_two_arg_synsem &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
			    [ LOCAL [ CAT pp_cat,
				      CONJ cnil,
				      CONT.HOOK.LTOP #ltop,
                                      KEYS.KEY #ckey & selected_rel &
                                               [ ARG2 #ind ] ] ] >,
            CONT.HOOK.LTOP #ltop,
            KEYS [ KEY.ARG2 #ind,
                   --COMPKEY #ckey ] ] ].

irreg_trans_adj_pred_synsem := pred_adj_two_arg_synsem &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
			    [ LOCAL [ CAT np_cat_acc_min,
                                      KEYS.KEY #ckey ] ] >,
            KEYS.--COMPKEY #ckey ] ].


; e.g. 'able' - Can't use equi_intrans_lt since it specifies an arg12_rel, 
; which is incompatible with adj_rel.  

reg_adj_equi_synsem := pred_adj_synsem & basic_inf_intrans_subst & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ 
                                        < [ NON-LOCAL.SLASH 0-dlist ] >,
                                      CONT.HOOK [ LTOP #hand,
                                                  XARG #subjind ],
                                      KEYS.MESSAGE <! message !> ],
                              OPT - ] >,
            CONT.HOOK.XARG #subjind,
	    KEYS.KEY adj_arg12_rel &
			 [ ARG1 #subjind,
			   ARG2 #hand ] ] ].


scoping_adj_synsem := basic_adj_synsem & prd_synsem &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL [ KEYS.MESSAGE 1-dlist,
				      CONT.HOOK.LTOP #hand ],
	    KEYS.KEY.ARG2 #hand ] ].

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

reg_adj_atrans_synsem := nomod_adj_synsem & scoping_adj_synsem & 
                         basic_pp_inf_subst & basic_three_arg &
  [ LOCAL 
    [ CAT.VAL.COMPS < [ LOCAL [ CONT.HOOK [ LTOP #ahand,
                                            INDEX #ind ],
                                KEYS.KEY _for_rel_s & [ ARG2 #expr ] ],
                        OPT + ],
                      [ LOCAL [ AGR #sind,
                                CAT.VAL.SUBJ < [ NON-LOCAL.SLASH 0-dlist ] >,
                                CONT.HOOK [ INDEX.E.TENSE no_tense,
                                            XARG #sind ] ],
                        OPT - ], ...>,
      CONT [ HOOK [ INDEX #ind,
                    XARG it-ind ],
	     RELS <! relation, 
		      pron_rel &
		      [ LBL #prohand,
			ARG0 #sind & [ PRONTYPE zero_pron ] ],
                      def_rel &
                    [ ARG0 #sind,
                      RSTR #rhand ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #prohand ] !> ],
      KEYS.KEY it_adj_arg123_rel &
              [ LBL #ahand,
                ARG1.PNG.PN 3sg,
                ARG3 #expr ] ] ].


;; DPF (9-Mar-99) It appears that there are no CP-taking adjectives which 
;; select for a 'like-CP' of the kind some verbs take (e.g. 'It sounds like
;; Kim will leave').  So we constrain the --KEYCOMP to be prop_ques_rel.
;; But there are adjectives (like 'doubtful, unclear, unsure') which can take 
;; a whether-CP, so we introduce a subtype of reg_adj_cp_synsem for those that 
;; only take a 'that-CP', and similarly for expletive-it subject-taking 
;; adjectives.

; 'uncertain': '?Kim is uncertain that Sandy left' 
;              'Kim is uncertain whether Sandy left' 
;              'It is uncertain that Sandy left'
;              'It is uncertain whether Sandy left'

reg_adj_cp_synsem := scoping_adj_synsem & nomod_adj_synsem & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
                              [ LOCAL
	                       [ CAT s_cat_fin_or_inf_v_c,
                                 CONJ cnil,
                                 KEYS.MESSAGE <! prop_ques_rel !> ] ] >,
	    CONT.RELS <! relation !>,
	    KEYS.KEY adj_arg12_rel ] ].

; 'unclear' '*Kim is unclear that/whether Sandy left'
;           'It is unclear that Sandy left'
;           'It is unclear whether Sandy left'

reg_adj_atrans_cp_synsem := reg_adj_cp_synsem &
  [ LOCAL [ CONT.HOOK.XARG it-ind,
            KEYS.KEY.ARG1.PNG.PN 3sg ] ].

; 'afraid'  'Kim is afraid that Sandy left'
;           '*Kim is afraid whether Sandy left'
;           '*It is afraid that/whether Sandy left'
reg_adj_that_cp_synsem := reg_adj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    KEYS.MESSAGE 1-dlist &
                                             <! propositional_rel !> ] ] > ].

; 'obvious' '*Kim is obvious that/whether Sandy left'
;           'It is obvious that Sandy left'
;           '*It is obvious whether Sandy left'
;   but cf. 'It is not obvious whether Sandy left' ***Needs fixing***

reg_adj_atrans_that_cp_synsem := reg_adj_atrans_cp_synsem &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    KEYS.MESSAGE 1-dlist &
                                                  <! propositional_rel !> ] ].

adj_word := hcons_amalg_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
                     CONT [ HOOK.XARG #ind,
                            RELS <! abstr_adj_rel !> ],
                     KEYS.KEY.ARG1 #ind ] ] ].

reg_adj_word := adj_word & 
  [ INFLECTED - ].

reg_intrans_adj := reg_adj_word & 
  [ SYNSEM intrans_adj_synsem ].

adj_intrans_le :< reg_intrans_adj.

; Not bare adj-noun : *we arrived last weeks
adj_intrans_notb_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD 
       < [ LOCAL.CAT.VAL.SPR < [ LOCAL.KEYS.KEY explicit_quant_rel ] > ] > ].

adj_attr_intrans_le := reg_adj_word &
  [ SYNSEM attr_adj_synsem ].

adj_pred_intrans_le := reg_intrans_adj & 
  [ SYNSEM intrans_pred_adj_synsem ].

intrans_adj_oddsem := norm_no_affix_word &
  [ SYNSEM intrans_adj_synsem &
           [ LOCAL [ CONT.HOOK.INDEX #ind,
                     KEYS.KEY.ARG1 #ind ] ] ].

adj_atrans_le := basic_norm_word &
  [ SYNSEM basic_adj_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < >,
                           VAL.COMPS < > ],
                     CONT.HOOK.INDEX it-ind ] ],
    INFLECTED - ].

; DPF 23-Oct-01 - Hack for "That costs less than $50"
adj_dollar_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.KEYS.KEY _dollar_rel ] > ].

;; doctor's appointment
adj_compound_le := intrans_adj_oddsem &
  [ SYNSEM attr_adj_synsem &
	 [ LOCAL 
	   [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                INDEX #nind ] ] >,
	     CONT [ HOOK.LTOP #hand,
		    RELS <! relation & [ ARG1 #aind ],
			     unspec_rel & [ LBL #hand,
					    ARG1 #nind,
					    ARG2 #aind ] !> ] ] ] ].

;; {OPT +] is on reg_trans_adj and not on trans_adj_synsem because the 
;; comparison_lr uses trans_adj_synsem and requires OPT -. Same for semantics.

adj_trans_lexent := reg_adj_word &
  [ SYNSEM trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >, 
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !> ] ] ] ].

adj_trans_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT + ] > ].

adj_trans_oblig_le := adj_trans_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
                   KEYS [ --COMPKEY #ckey,
                          --+COMPKEY #ckey ] ] ].

; These 'irregular' types are for multi-word adjectives, which cannot
; be affix-bearing under the current regime.  They should be eliminated
; once we do better with multi-words.

irreg_adj_word := adj_word & non_affix_bearing.

adj_irreg_attr_le := irreg_adj_word &
  [ SYNSEM attr_adj_synsem &
	  [ LOCAL [ CONT.HOOK.XARG #ind & non_expl-ind,
		    KEYS.KEY.ARG1 #ind ] ] ].

adj_irreg_pred_intrans_lexent := irreg_adj_word &
  [ SYNSEM intrans_pred_adj_synsem &
	  [ LOCAL [ CAT.HEAD.PRD +,
                    CONT.HOOK.XARG #ind,
		    KEYS.KEY.ARG1 #ind & non_expl-ind ] ] ].
adj_irreg_pred_intrans_le :< adj_irreg_pred_intrans_lexent.
adj_irreg_pred_intrans_prd_le := adj_irreg_pred_intrans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].


adj_irreg_np_trans_le := irreg_adj_word &
  [ SYNSEM irreg_trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #index,
				       OPT - ] >,
		     CONT.RELS <! [ ARG2 #index ] !> ] ] ].


adj_reg_equi_lexent := hcons_amalg_affixed_word &
  [ INFLECTED -,
    SYNSEM reg_adj_equi_synsem &
	   [ LOCAL.CONT.RELS <! abstr_adj_rel !> ] ].

adj_reg_equi_le := adj_reg_equi_lexent.

; For e.g. "supposed to"
adj_reg_equi_nomod_le := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.KEYS.KEY no_rel ] > ].

adj_reg_atrans_le := hcons_amalg_affixed_word &
  [ SYNSEM reg_adj_atrans_synsem ].

reg_adj_atrans_cp_word := hcons_amalg_affixed_word &
  [ SYNSEM reg_adj_atrans_cp_synsem ].

adj_reg_atrans_cp_le := reg_adj_atrans_cp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

adj_reg_atrans_that_cp_le := reg_adj_atrans_cp_word &
  [ SYNSEM reg_adj_atrans_that_cp_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

reg_adj_cp_word := hcons_amalg_affixed_word &
  [ SYNSEM reg_adj_cp_synsem &
	   [ LOCAL [ CONT.HOOK.XARG #ind,
		     KEYS.KEY.ARG1 #ind ] ] ].

adj_reg_cp_le := reg_adj_cp_word & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

adj_reg_that_cp_le := reg_adj_cp_word &
  [ SYNSEM reg_adj_that_cp_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

; How is Sandy?  How does Tuesday look?
; We adopt the following second-order quantification semantics for these:
;    which (p, property(p), look_seem(proposition_to_property(adj(x),p)))
; where we exploit a type-shifting relation to change the proposition "adj(x)"
; into the associated property "the set of entities of which adj(x) is true",
; so the "which" operator can quantify over that property.

;; ... now archaic? ...
;; DPF 14-Apr-00 - Changed SUBJ.CAT from nomp_cat_nom_min to nomp_cat_min
;; since [CASE nom] conflicts with the CASE hack on pro_ss to prevent the
;; latter from undergoing subject xxtraction (see ERB notes for pro_ss).

adj_wh_le := nonconj & non_affix_bearing & mcna & nonslash & 
                        nonrel & nonmsg &
  [ SYNSEM lex_synsem &
      [ LOCAL [ STEMHEAD astem,
		ARG-S < >,
		CAT [ POSTHEAD +,
		      HEAD adj* & [ MOD < > ],
		      VAL [ SPR < >,
			    COMPS < > ] ],
		CONT [ HOOK [ LTOP #ltop,
                              INDEX #ind,
                              XARG #ind ],
		       RELS <! unspec_adj_rel &
			        [ LBL #ahand,
				  ARG1 #ind ],
			        which_rel & [ ARG0 #pind,
					      RSTR #hand ],
			        property_rel & [ LBL #hand,
						 ARG0 #pind ],
			        prpstn_to_prop_rel & #key &
			        [ LBL #ltop,
				  PRPSTN #ahand,
				  PROP #pind ] !>,
		       HCONS <! !> ],
		KEYS.KEY #key ],
	NON-LOCAL.QUE 1-dlist &
	              [ LIST < handle > ] ] ].

; two-hour meeting, two-foot tall
measure_adj_attr_synsem := zero_arg & isect_synsem &
  [ LOCAL [ CAT [ HEAD adj* &
		       [ PRD -,
			 MOD < [ LOCAL [ CAT nbar_cat,
					 CONT.HOOK.INDEX #ind,
					 CONJ cnil ] ] > ],
		  VAL [ SUBJ < >,
			SPR < synsem &
			      [ LOCAL local_min &
				      [ CAT [ VAL [ SPR *olist*,
						    COMPS *olist* ],
					      MC na ],
					CONT.HOOK [ LTOP #hand,
                                                    INDEX #inst ],
					KEYS.KEY const_rel ],
				OPT - ] >,
			COMPS < > ] ],
	    CONT mrs &
		 [ RELS <! meas_adj_rel & #key &
			    [ LBL #hand,
			      ARG1 #ind,
			      ARG2 #inst ],
			    nom_rel & #altkey & [ LBL #hand,
						  ARG0 #inst ] !> ],
	    KEYS [ KEY #key,
		   ALTKEY #altkey ] ] ].

adj_meas_le := norm_no_affix_word &
 [ SYNSEM measure_adj_attr_synsem ].

compar_superl_adj_word := hcons_amalg_non_affixed_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
                                      ARG1 #ind ],
                                  #altkey &
                                  [ LBL #hand,
                                    ARG1 #ind ] !> ],
                     KEYS.ALTKEY #altkey ] ] ].

basic_compar_adj_word := compar_superl_adj_word &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.KEYS.KEY much_deg_rel ] >,
                   KEYS.ALTKEY comp_rel ] ].

adj_comp_le := basic_compar_adj_word &
  [ SYNSEM intrans_adj_synsem ].

adj_atrans_comp_le := hcons_amalg_non_affixed_word &
  [ SYNSEM basic_adj_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < >,
                           VAL [ SPR < [ LOCAL.KEYS.KEY much_deg_rel ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG it-ind,
                            RELS <! [ LBL #hand ],
                                  #altkey &
                                  [ LBL #hand ] !> ],
                     KEYS.ALTKEY comp_rel & #altkey ] ] ].


;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

adj_comp_trans_le := basic_compar_adj_word &
  [ SYNSEM trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ KEYS.KEY.ARG2 #index,
					       CONT.HOOK.LTOP #ltop ],
				       OPT +] >, 
                     KEYS.KEY.ARG2 #index,
		     CONT.HOOK.LTOP #ltop ] ] ].


adj_more_less_le := basic_compar_adj_word &
  [ SYNSEM adj_two_arg_synsem &
	   [ LOCAL [ CAT.VAL [ SUBJ #subj,
                               SPR *olist*,
			       COMPS < lex_synsem &
					 [ LOCAL 
                                           [ CAT [ HEAD adj &
                                                        [ TAM.TENSE no_tense ],
                                                   VAL [ SUBJ #subj,
                                                         SPR *olist*,
                                                         COMPS < > ] ],
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #ind ] ],
                                           LEX +,
					   OPT -] > ], 
		     KEYS.KEY more_less_adj_rel,
                     CONT.HOOK [ LTOP #ltop,
                                 INDEX #ind ] ] ] ].

basic_superl_adj_word := compar_superl_adj_word &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.KEYS.KEY very_deg_rel ] >,
                   KEYS.ALTKEY superl_rel ] ].

adj_superl_le := basic_superl_adj_word &
  [ SYNSEM intrans_adj_synsem & [ LOCAL.CAT.HEAD.PRD - ] ].

adj_superl_prd_le := basic_superl_adj_word &
  [ SYNSEM intrans_adj_synsem & [ LOCAL.CAT.HEAD.PRD + ] ].

adj_atrans_superl_lexent := hcons_amalg_non_affixed_word &
  [ SYNSEM basic_adj_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < >,
                           VAL [ SPR < [ LOCAL.KEYS.KEY very_deg_rel ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG it-ind,
                            RELS <! [ LBL #hand ],
                                  #altkey &
                                  [ LBL #hand ] !> ],
                     KEYS.ALTKEY superl_rel & #altkey ] ] ].

adj_atrans_superl_le := adj_atrans_superl_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

adj_atrans_superl_prd_le := adj_atrans_superl_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].

adj_most_least_le := basic_superl_adj_word &
  [ SYNSEM adj_two_arg_synsem &
	   [ LOCAL [ CAT.VAL [ SUBJ #subj,
                               SPR *olist*,
			       COMPS < lex_synsem &
					 [ LOCAL 
                                           [ CAT [ HEAD adj &
                                                        [ TAM.TENSE no_tense ],
                                                   VAL [ SUBJ #subj,
                                                         SPR *olist*,
                                                         COMPS < > ] ],
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #ind ] ],
                                           LEX +,
					   OPT -] > ], 
		     KEYS.KEY most_least_adj_rel,
                     CONT.HOOK [ LTOP #ltop,
                                 INDEX #ind ] ] ] ].

; Titles like 'mister', 'professor' which modify proper names
; DPF 5-Apr-01 - Changed MOD..KEY to abstr_named_rel from named_rel, to
; include integers, as in "number ten"
; Removed PERIPH na - it blocked "order fivedigitersatz" since the num-np
; rule cannot accept numerals modified by adjectives or noun-noun compounds -
; we want to block the NP "Toshiba 2000" but allow the NP "order (number) 2000"

title_synsem := basic_zero_arg & lex_synsem &
  [ LOCAL [ CAT [ HEAD adv &
		       [ MOD < [ LOCAL intersective_mod &
				       [ CAT nbar_cat,
					 CONJ cnil,
					 CONT.HOOK.INDEX #nind,
					 KEYS.KEY gen_named_rel & 
                                                  non_temp_nom_rel &
                                                  [ LBL #nhand ] ],
                                 MODIFIED notmod_or_rmod ] > ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < > ] ],
	    CONT [ HOOK.INDEX #ind,
		   RELS <! #key & 
                          [ LBL #khand,
                            ARG0 #ind ],
                            udef_rel & 
                          [ ARG0 #ind,
                            RSTR #rhand ],
                          title_id_rel &
                          [ LBL #nhand,
                            ARG1 #ind,
                            ARG2 #nind ] !>,
                   HCONS <! qeq &
                           [ HARG #rhand,
                             LARG #khand ] !> ],
            KEYS.KEY #key ] ].

n_title_le := nontopkey &
  [ SYNSEM title_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].

n_post_title_le := norm_no_affix_word &
  [ SYNSEM title_synsem &
	   [ LOCAL.CAT.POSTHEAD + ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PREPOSITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Most prepositions can be modifiers.  If they act as a modifier, we'll assume
; they have no subject (leaving for some distinct analysis Carl's "A unicorn
; at the helm, the ship sailed into the horse latitudes."  This lets us use a
; single attribute, ARG, for the index of the phrase modified, or for the
; index of the subject of the PP, in a predicative construction.

; Prepositions also have a distinguished role ARG2 which has as value the
; index of the object of the preposition.  We could introduce distinct role
; names for each preposition (e.g. "ON" for on_rel, "IN" for in-rel) but this
; would complicate the definition of the prep_synsem type, since it needs to
; know the role name to which it assigns the object's index.

; An ARG0 attribute is needed for PPs (and other substs used predicatively)
; occurring as complements of the copula as in "the meeting is on Tuesday",
; but on this analysis not postnominally.  This ARG0 role used to be
; introduced in a separate support_rel, supplied by the copula, but is now
; introduced directly in the relation introduced by the predicate (prep or
; adj or verb).

; Prepositions, like adjectives and participial verbs, can have either
; predicative or nonpredicative synsems, so each ordinary preposition
; (actually the PP headed by the P) can unify with either a pred. or non-pred.
; constraint, which resolves the underspecification.  One assumption here is 
; that there are no contexts which are underspecified for the PRD feature 
; for PPs.

; N.B. The RELS value of basic_prep_synsem cannot be a singleton list, since
; adverbs like "when" inherit this synsem, and add additional rels lexically.

; Here we only amalgamate non-local features from the complements, not the
; subject.  This is so we don't get two identical gaps in an example like "Who
; does kim think is under the bed?".  On the other hand, binding theory
; suggests that the subjects of prepositions really are on the ARG-S list.

; DPF (14-Mar-99) Constrained prepositions to not allow pied-piping in
; free relative constructions, where the QUE value is an index rather than
; a handle.

basic_prep_synsem := canonical_synsem & 
  [ LOCAL [ CAT [ HEAD n_or_p & [ TAM #tam ],
                  VAL.SUBJ < > ],
	    CONT.RELS.LIST < norm_relation & [ ARG0.E #tam ], ... > ] ].

; DPF 18-Apr-01 - Removed ident. of ALTKEY with COMPS..KEY, since it prevents
; selection in v-np-pp verbs for a PP which is temporal or locative: want to
; block "When did kim put the book", but allow "Where did Kim put the book"
; We'll see where this constraint was being used.

prep_synsem := basic_prep_synsem &
  [ LOCAL [ CAT [ HEAD prep*,
                  VAL.COMPS < synsem & 
			      [ LOCAL local_min &
				      [ KEYS.KEY #ckey,
					CONT.HOOK.INDEX #objind ] ], ... >,
		  POSTHEAD + ],
	    CONT.RELS.LIST < #key, ... >,
	    KEYS [ KEY #key & [ ARG2 #objind ],
		   --COMPKEY #ckey ] ] ].

; For predicative Ps and PPs like "when" which have a (non-expletive) NP subj

prep_p_synsem := basic_prep_synsem &
  [ LOCAL [ CAT.VAL.COMPS #comps,
	    ARG-S #comps ] ].

;; DPF 10-Oct-00 - SPR.KEYS.KEY needs fixing
;; DPF 17-Jul-01 - Restricted SPR to be very_deg_rel, to avoid e.g. "much 
;; for Kim".  
;; DPF 16-Nov-01 - But "very for Kim" is also bad", and note "very much for
;; Kim" is good, but not "very very for Kim".  Seems reminiscent of contrast
;; between "*I want much to stay" and "I want very much to stay".  Don't know
;; how to get this, but in any case fixed SPR.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so PPs can
;; coordinate with VPs (which are necessarily SPR anti_synsem).

prep_with_spr_synsem := basic_prep_synsem &
  [ LOCAL [ CAT.VAL.SPR < synsem_min & [ LOCAL local_min &
					   [ CAT [ HEAD adv,
						   VAL [ SPR *olist*,
							 COMPS *olist* ] ],
					     KEYS.KEY much_deg_rel &
						 [ DARG #pred ] ],
                                         NON-LOCAL.QUE 0-dlist ] >,
            KEYS.KEY.PRED #pred ] ].


; Ps and PPs that can be modifiers.
; Block PP modification of infinitival "to" - spurious ambiguity.
; Constrain MOD < [ LOCAL.CONT.HOOK.INDEX > to be non_expl, for fragments like 
; "perhaps in a week"
; DPF 10-Sept-01 - Removed MOD..KEY relation, since it prevents modification
; of no_copula VPs, as in "rain likely tomorrow"

basic_mod_n_or_vp_synsem := isect_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT n_or_v_cat &
                                           [ HEAD n_or_v,
					     MC #mc ],
				       CONT.HOOK.INDEX #ind & non_expl,
				       CONJ cnil,
				       KEYS.MESSAGE #msg ] ] >,
                  MC #mc,
		  POSTHEAD + ],
	    CONT.HOOK.E-INDEX #event,
	    KEYS [ KEY [ ARG1 #ind,
                         ARG0 #event ],
		   MESSAGE #msg ] ] ].

mod_n_or_vp_synsem := basic_mod_n_or_vp_synsem & prep_with_spr_synsem.

prep_p_mod_synsem := prep_p_synsem & mod_n_or_vp_synsem &
  [ LOCAL.CAT.VAL.SPR < [ OPT + ] > ].

prep_prd_or_nonprd_synsem := prep_synsem & prep_p_mod_synsem.

; Strict transitive prepositions which can be either predicative or non-pred:

basic_trans_prep_synsem := prep_prd_or_nonprd_synsem & basic_one_arg &
  [ LOCAL.CONT.RELS.LIST < prep_rel, ... > ].

; DPF 21-Jun-01 - Changed COMPS..INDEX from ref-ind to non_expl-ind so preps
; can be particles.
; DPF 8-Aug-01 - Removed identification of LTOP and COMPS..LTOP - unwanted.

trans_prep_synsem := basic_trans_prep_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX non_expl-ind,
                              NON-LOCAL.QUE.LIST *handlelist* ] >,
            CONT [ RELS <! prep_rel !>,
		   HCONS <! !> ] ] ].

ditrans_prep_synsem := prep_prd_or_nonprd_synsem & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < *top* & [ LOCAL.CONT.HOOK.LTOP #ltop,
                                      NON-LOCAL.QUE.LIST *handlelist* ], 
                            *top* & [ LOCAL.KEYS.KEY.ARG0.E.TENSE no_tense ]>,
            CONT [ HOOK.LTOP #ltop,
		   RELS <! prep_rel !> ] ] ].

basic_lex_pp_synsem := prep_p_synsem & phr_synsem &
  [ LOCAL [ ARG-S < >,
	    CAT.VAL.COMPS < >,
            CONT.HCONS <! !> ] ].

lex_pp_synsem := basic_lex_pp_synsem & mod_n_or_vp_synsem &
  [ LOCAL.CAT.HEAD prep* &
                   [ MOD < [ MODIFIED notmod_or_rmod ] >,
                     PRD + ] ].

; DPF 8-Sep-01 - Hack: Made "ago" only modify VPs, not nbars, to get preferred
; readings for e.g. "He met the guy two weeks ago".
; DPF 20-Dec-01 - Replaced SPR..CAT np_cat_acc with near-spelling-out, 
; excluding SPEC < >, since head-spec rule requires non-empty SPEC.  Could be
; cleaner with defaults, overriding the SPEC < > constraint here.

lex_pp_post_synsem := basic_lex_pp_synsem & basic_mod_n_or_vp_synsem & 
  [ LOCAL [ CAT [ HEAD prep* &
                       [ MOD < [ MODIFIED notmod_or_rmod,
                                 LOCAL.CAT.VAL.SUBJ < synsem > ] > ],
                  VAL.SPR < synsem & 
                            [ LOCAL local_min &
                                    [ CAT [ HEAD noun & [ CASE acc,
                                                          POSS -,
                                                          TAM.MOOD 
                                                           ind_or_mod_subj ],
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ],
                                            MC na_or_- ],
                                      CONT.HOOK.INDEX #index,
                                      KEYS.KEY temp_abstr_rel ],
                              OPT - ] > ],
            KEYS.KEY.ARG2 #index ] ].

; DPF 13-Oct-99 - Restricted MOD value to a comparative adj (lexical like 
; "taller" or phrasal like "more important").

;; DPF 10-Oct-00 - MOD.KEYS.ALTKEY needs fixing
; DPF 19-Oct-02 - Removed PRD -.

compar_adj_prep_synsem := prep_synsem & isect_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL [ CAT [ HEAD adj,
					     VAL.SPR < [ LOCAL.KEYS.KEY 
							 much_deg_only_rel ] >,
                                             MC na ],
                                       CONT.HOOK [ LTOP #ltop,
                                                   INDEX #ind,
                                                   E-INDEX #eind ],
                                       KEYS [ ALTKEY comp_rel &
                                                     [ ARG2 #arg ] ] ] ] > ],
                  VAL [ SPR < >,
                        COMPS < [ LOCAL [ CAT [ HEAD noun,
						VAL [ SPR *olist*,
						      SUBJ *olist*,
                                                      SPEC < >,
						      COMPS < > ] ],
					  CONT.HOOK [ LTOP #ltop,
                                                      INDEX #arg ] ],
				  NON-LOCAL [ SLASH 0-dlist,
					      REL 0-dlist,
					      QUE 0-dlist ],
				  OPT - ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #ind ],
                   RELS <! _compar_than_rel & [ ARG1 #eind ] !>,
                   HCONS <! !> ],
	    KEYS.MESSAGE <! !>,
            CONJ cnil ] ].

; Ordinary prepositions:

; Moved [ OPT - ] specification to subtypes, to allow "the day before" where
; the complement is missing.
; DPF (9-Mar-99) Made basic_prep_word not inherit from nonmsg, since it has
; its MESSAGE identified with that of its modifiee (via the head_modifier rule)
; and that modifiee will sometimes have a non-empty message, as in
; "Is kim happy in Berlin"
; DPF 19-Nov-01 - Removed COMPS..MESSAGE 0-dlist, since now want to get "this
; depends on whether kim arrives" and "I'm interested in who you met"

basic_prep_word := msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                                    AGR.DIVISIBLE strict_sort,
						    CONJ cnil ] ] > ] ].

; Changed ref-ind constraint to non_expl-ind so prep's can be used as particles
; DPF 20-Oct-02 - Made SORT of ARG1 and first COMP be identified, to avoid
; spurious ambiguity for e.g. "ten to five"
; DPF 27-Oct-02 - But this runs afoul of the facts (1) that preps identify 
; their own index with that of their MOD's index (since they're intersective),
; (which is also their ARG's index) and (2) that predicative ones identify 
; their XARG index with their ARG's index.  And anyway, "ten to five" doesn't
; use the preposition, but rather the n_x_to_y lexical entry.

prep_word := basic_prep_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX non_expl-ind ] > ].

; DPF 02-Apr-02 - For now, block measure-phrase specifiers of ordinary 
; prepositions -- too many spurious parses.
p_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS < [ OPT - ] >,
			   SPR < [ LEX + ] > ] ].

p_nmod_le := prep_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >,
                       VAL.COMPS < [ OPT - ] > ] ].

; DPF 8-Jan-02 - Added constraint on SPR to exclude measure-NP specifiers, as
; in "*There are a book in the office"
p_reg_lexent := prep_word &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LEX + ] >,
                           COMPS < [ LOCAL local_min &
                                           [ KEYS.KEY non_temp_nom_rel ],
                                     OPT - ] > ] ].
p_reg_le :< p_reg_lexent.

; DPF 02-Apr-02 - blocks e.g. "an office by Sandy" as in "kim was shown an 
; office by Sandy".  Hack, since it also blocks "Kim lives right by the river"
p_reg_nospec_le := p_reg_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < unexpressed > ].

p_noslash_le := prep_word & 
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             NON-LOCAL.SLASH 0-dlist ] ].

particle_le := prep_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < unexpressed & [ OPT - ] > ].

; DPF 24-Oct-01 - Added identity of AGR..PN, DIV and NP comp's AGR..PN, DIV to
; support agreement in partitives, as in "none of the rice arrives" but "*none
; of the rice arrive"
; DPF 1-Mar-02 - Removed TAM.TENSE no_tense since this blocked predicative 
; of-PP as in "this picture is of Sandy".  Also replaced
; [MOD..KEY never_unify_rel] with never_unify_event_rel since it blocked the 
; no-copula "a chance of rain".

p_nospec_le := prep_word & 
  [ SYNSEM.LOCAL 
           [ CAT [ HEAD [ TAM.ASPECT noasp+progr,
                          MOD < [ LOCAL.KEYS.KEY never_unify_event_rel ] > ],
                   VAL [ SPR < unexpressed >,
                         COMPS < [ OPT -,
                                   LOCAL.AGR [ PNG.PN #pn,
                                               DIVISIBLE #div ] ] > ] ],
             AGR [ PNG.PN #pn,
                   DIVISIBLE #div ] ] ].

p_nogap_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT -,
                                   NON-LOCAL.SLASH 0-dlist ] > ].

; DPF 31-May-02 - Constrain to only modify nominals.
p_nospec_nogap_le := prep_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >,
                       VAL [ SPR < unexpressed >,
                             COMPS < [ OPT -,
                                       NON-LOCAL.SLASH 0-dlist ] > ] ] ].

p_temp_lexent :=  msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT.VAL.COMPS < synsem & 
                                 [ LOCAL [ CAT [ HEAD nominal & strict_type &
                                                      [ CASE acc,
                                                        POSS - ],
                                                 VAL [ SUBJ *olist*,
                                                       SPR *olist*,
                                                       COMPS *olist* ],
                                                 MC na ],
                                           AGR.DIVISIBLE strict_sort,
                                           CONJ cnil ],
                                   OPT - ] > ] ].

p_temp_le :< p_temp_lexent.
p_temp_vmod_le := p_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] > ].

; 'before'
p_temp_spr_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CONT.HOOK.INDEX.SORT time ] >,
                           COMPS < [ OPT - ] > ] ].

; Used e.g. for "from", as in "from under the table"
; DPF 6-Apr-01 - Also used for "worth" as in "ten dollars worth of food"

p_ppcomp_lexent := msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS < synsem &
				   [ LOCAL local_min &
					   [ CAT [ HEAD prep,
						   VAL [ SPR *olist*,
							 COMPS < > ] ],
					     CONT.HOOK.INDEX non_expl-ind,
					     CONJ cnil ] ] > ],
           NON-LOCAL.SLASH 0-dlist ] ].

; 'from'
p_ppcomp_le := p_ppcomp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

; 'worth'

p_ppcomp*_le := p_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >,
                         VAL.COMPS < [ OPT + ] > ],
                   KEYS [ KEY.ARG2 #arg,
                          --COMPKEY _of_rel_s & [ ARG2 #arg ] ] ] ].


; 'from now on', maybe 'from two to four'
p_ditrans_lexent := norm_msg_word &
  [ SYNSEM ditrans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL 
                                               [ CAT nomp_cat_acc_min,
                                                 AGR.DIVISIBLE strict_sort,
                                                 KEYS.MESSAGE 0-dlist,
                                                 CONJ cnil ],
					      OPT - ], 
				   synsem & [ LOCAL local_min &
						    [ CAT [ HEAD.PRD -,
							    MC na ],
						      CONT.HOOK.LTOP #ltop ],
					      NON-LOCAL.QUE.LIST *handlelist*,
                                              OPT - ] >,
		   CONT.HOOK.LTOP #ltop,
                   KEYS [ --COMPKEY #ckey,
                          --+COMPKEY #ckey,
                          --OCOMPKEY #ockey,
                          --+OCOMPKEY #ockey ] ] ] ].

p_ditrans_le :< p_ditrans_lexent.

p_ditrans_from_to_le := p_ditrans_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #arg2 &
                                                      [ SORT #sort ] ], 
				   [ LOCAL [ CAT.VAL.COMPS < >,
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #arg ],
                                             KEYS.KEY.ARG2.SORT #sort ] ] >,
                   CONT.HOOK.LTOP #ltop,
		   KEYS.KEY [ ARG1 #arg,
                              ARG2 #arg2 ] ] ].


; DPF 21-Nov-01 - Replaced all entries of this type with subordinating 
; conjunctions.  Not clear what motive for these was.
#|
p_cp_le := msg_amalg_word &
  [ SYNSEM basic_trans_prep_synsem &
      [ LOCAL [ CAT.VAL.COMPS < synsem &
				[ LOCAL 
				  [ CAT s_cat_fin_v_c & [ HEAD verb ],
				    CONJ cnil,
				    CONT.HOOK [ LTOP #mhand,
                                                INDEX event & #event ],
				    KEYS.MESSAGE 1-dlist &
						 <! prpstn_rel !> ],
                                  NON-LOCAL.QUE.LIST *handlelist*,
				  OPT - ] >,
		CONT [ HOOK.LTOP #mhand,
		       RELS <! prep_rel !>,
		       HCONS <! !> ],
		KEYS.KEY.ARG2 #event ] ] ].
|#

;; DPF 10-Oct-00 - COMPS.KEYS.KEY needs fixing

p_pp_le := msg_amalg_word &
  [ SYNSEM basic_trans_prep_synsem &
      [ LOCAL [ CAT.VAL.COMPS < synsem &
				[ LOCAL [ CAT pp_cat,
					  CONJ cnil,
					  CONT.HOOK.LTOP #ltop,
                                          KEYS.KEY [ ARG2 #arg2 ] ],
				NON-LOCAL.QUE.LIST *handlelist* ] >,
                CONT [ HOOK.LTOP #ltop,
		       RELS <! prep_rel !>,
		       HCONS <! !> ],
                KEYS.KEY [ ARG2 #arg2 ] ] ] ].

; DPF 13-Mar-02 - Changed PRD - to PRD +: "the response was as expected"
; DPF 2-Jul-02 - Added MOD..HEAD verb to prevent spurious analysis for e.g.
; "Abrams sees Browne as being a competent manager."

p_prdp_le := msg_amalg_word &
  [ SYNSEM basic_trans_prep_synsem &
           [ LOCAL [ CAT [ HEAD [ PRD +,
                                  MOD < [ LOCAL.CAT.HEAD verb ] > ],
                           VAL.COMPS 
                                < synsem &
                                  [ LOCAL [ CAT prd_cat & [ HEAD v_or_g_or_a ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #ltop,
                                                        XARG #arg ] ],
                                    NON-LOCAL [ SLASH 0-dlist,
                                                QUE 0-dlist,
                                                REL 0-dlist ],
                                    OPT - ] > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! prep_rel !>,
                            HCONS <! !> ],
                     KEYS.KEY [ ARG1 #arg ] ] ] ].

#|
prep_spr_word := msg_amalg_word &
  [ SYNSEM prep_spr_synsem &
	   [ LOCAL.CAT.VAL [ SPR < [ OPT - ] >,
			     COMPS < synsem & [ LOCAL 
                                                 [ CAT nomp_cat_acc_min,
                                                   AGR.DIVISIBLE strict_sort,
                                                   KEYS.MESSAGE 0-dlist,
                                                   CONJ cnil ],
						OPT - ] > ] ] ].
|#

; Prepositions that don't modify nominals - e.g, 'until'
p_no_n_mod_le := prep_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ < synsem > ] >,
		       VAL.COMPS < [ OPT -,
                                     LOCAL.KEYS.KEY nonpro_rel ] > ] ].

; "Case-marking" prepositions, which cannot be modifiers
; and (let's assume) also cannot be modified, so stipulate [ SUBJ < > ].
;
; DPF 10-Jun-99 - But they can take specifiers: "Kim fell nearly to the bottom"

basic_prep_nomod_synsem := lex_synsem & prep_with_spr_synsem &
  [ LOCAL [ CAT [ HEAD prep* & [ PRD -,
				 MOD < > ],
		  VAL [ SPR < [ OPT + ] >,
                        COMPS < synsem & 
				[ LOCAL local_min &
					[ KEYS.KEY #ckey,
					  CONT.HOOK.INDEX #ind ],
				  NON-LOCAL.QUE.LIST *handlelist*,
				  OPT - ] > ] ],
	    CONT [ HOOK.INDEX #pind,
                   RELS <! #key !> ],
	    KEYS [ KEY prep_rel & #key &
		       [ ARG1 #pind,
                         ARG2 #ind ],
		   --COMPKEY #ckey ] ] ].

prep_nomod_synsem := basic_prep_nomod_synsem & prep_p_synsem & one_arg.

; Removed constraint on [COMPS.FIRST.MOD < >] to allow "of the second"
p_nomod_le := amalg_word &
  [ SYNSEM prep_nomod_synsem & 
	 [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                                    AGR.DIVISIBLE strict_sort,
						    CONJ cnil ] ] > ] ].

; Lexical PPs

pp_word := basic_norm_no_affix_word &
  [ SYNSEM lex_pp_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ OPT + ] >,
                     KEYS.KEY #key,
		     CONT.RELS <! #key !> ] ] ].

; 'astray'
pp_le :< pp_word.
; 'afterwards'
pp_vpmod_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] > ].
; 'available'
pp_nmod_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.KEYS.KEY basic_nom_rel ] > ].
; 'after'
pp_nmod_temp_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CONT.HOOK.INDEX.SORT time,
					  KEYS.KEY basic_nom_rel ] ] > ].

; ago
pp_post_le := basic_norm_no_affix_word &
  [ SYNSEM lex_pp_synsem &
	   [ LOCAL [ CAT [ VAL.SPR < [ OPT - ] >,
                           POSTHEAD + ],
                     KEYS.KEY #key,
		     CONT.RELS <! #key !> ] ] ].

pp_no_n_mod_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ < synsem > ] > ].

; Prepositions with lexically idiosyncratic complements:

; DPF 08-Jan-01 - was built for "as of", but don't remember why, since
; it seems "as of" is an ordinary prep.
p_idiom_le := msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ OPT - ], ... > ] ] ].

p_idiom_nomod_le := amalg_word &
  [ SYNSEM prep_nomod_synsem & 
	   [ LOCAL.CAT.VAL [ COMPS < synsem & [ LOCAL 
                                                 [ CAT nomp_cat_acc_min,
                                                   AGR.DIVISIBLE strict_sort,
                                                   CONJ cnil ] ] >,
			     SPR < unexpressed > ] ] ].

; DPF 29-Nov-02 - Stipulate HOOK.XARG nothing to prevent these from appearing
; as complements of predicative 'be'.
p_nbar_comp_lexent := msg_amalg_word &
  [ SYNSEM basic_trans_prep_synsem &
	   [ LOCAL [ CAT.VAL [ SPR < [ NON-LOCAL.SLASH 0-dlist ] >,
			       COMPS < lex_synsem &
				     [ OPT -,
				       LOCAL [ CAT [ HEAD noun,
						     VAL [ SPR < unexpressed >,
                                                           COMPS < > ] ],
					       CONT.HOOK.LTOP #nhand,
                                               KEYS.ALTKEY no_rel ],
                                       NON-LOCAL.SLASH 0-dlist,
                                       MODIFIED.PERIPH na_or_- ] > ],
		     CONT [ HOOK.XARG nothing,
                            RELS <! prep_rel & [ ARG2 #arg ],
                                    udef_rel & [ ARG0 #arg,
                                                 RSTR #rhand ] !>,
			    HCONS <! qeq & [ HARG #rhand,
                                             LARG #nhand ] !> ] ] ] ].

p_nbar_comp_le := p_nbar_comp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3sg ] > ].

; DPF 24-Jun-01 - Added SUBJ <anti_synsem> to block 'per' reading: "Abrams is 
; a manager"
; DPF 29-Nov-02 - But [E.TENSE no_tense] should be enough

p_nbar_comp_nmod_lexent := p_nbar_comp_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.E [ TENSE no_tense,
                                   ASPECT no_aspect ] ].

; Added MOD..ALTKEY no_rel to prevent "a person" from modifying e.g. gerunds.
; 10-Nov-01 - But now gerunds are unmarked for ALTKEY, since they need to be
; able to appear as left members of noun-noun compounds.  
; DPF 3-Jul-02 - Added [MOD..LEX +] to block spurious analyses as for 
; e.g. "every manager who has a bookcase"
; DPF 30-Aug-01 - Added COMPS <[MODIFIED notmod]> to block "a ten percent
; probability" with a_per.

; 'per'
p_nbar_comp_nmod_le := p_nbar_comp_nmod_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL [ CAT.HEAD noun,
                                            KEYS.ALTKEY no_rel ],
                                    LEX + ] >,
                       VAL.COMPS < [ LOCAL.AGR.PNG.PN 3sg,
                                     MODIFIED notmod ] > ] ].

; 'of' in "what kind of book(s)'
p_nbar_comp_nomod_le := p_nbar_comp_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.KEYS.KEY never_unify_rel ] > ].

;; Temporal prepositions:

; Special type for "at" taking hours
;    'at five oclock'
;    'at fifteen to six'

#|
at_prep_word := msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS
		       < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                            AGR.DIVISIBLE strict_sort,
					    KEYS [ MESSAGE 0-dlist,
                                                   KEY hour_rel ],
					    CONJ cnil ],
				    OPT - ] > ] ] ].
|#

; Prepositions like "before" that take a prep_noun like "now, then".
;   'before now', 'since then'

before_prep_le := norm_msg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS 
		 < [ LOCAL local_min &
			   [ CAT [ HEAD n_or_p & [ PRD - ],
				   VAL [ SPR *olist*,
					 COMPS *olist* ] ],
			     KEYS.KEY temp_loc_indep_rel ],
		     OPT - ], ... > ] ] ].

; "ten minutes to three" - "to" as head
; Use POSTHEAD to allow "half past three" and "three thirty" but block
;      "?thirty past three" and "*three half"
; DPF (12-Jul-98) The specifier on hour_prep_words has to be [ OPT + ] in 
; order to block prenominal adjectives from attaching, since they distinguish 
; proper from common nouns by the optionality (or absence) of the specifier.  
; This distinction doesn't seem to work well here, but it's the only case, so 
; perhaps the analysis of "ten after three" should be reconsidered.
; DPF (11-Jul-99) But this [OPT +] incorrectly predicts that "To five thirty 
; suits me" is good, and worse, it allows "to five thirty" to act like an NP in
; appositive constructions.  So instead of this hack, constrain adjectives to
; only modify nominals with a DET specifier.

n_hour_prep_le := norm_msg_word &
  [ SYNSEM nomod_onearg_synsem &
	 [ LOCAL [ CAT [ HEAD noun* &
			      [ POSS - ],
			 VAL [ SPR < synsem & 
                                     [ LOCAL [ CAT [ HEAD intadj,
                                                     VAL.COMPS < > ],
                                               CONJ cnil,
                                               CONT.HOOK.INDEX #minute,
                                               KEYS.KEY minute_rel ],
                                       OPT - ] >,
                               COMPS < synsem & 
				       [ LOCAL [ CAT nomp_cat_acc_min,
                                                 AGR.DIVISIBLE strict_sort,
						 KEYS [ KEY numbered_hour_rel &
							      #ckey,
							MESSAGE 0-dlist ],
						 CONT.HOOK [ LTOP #ltop,
                                                             INDEX #hour ],
						 CONJ cnil ],
					 OPT - ] > ] ],
		   CONT nom-obj &
		       [ HOOK [ LTOP #ltop,
                                INDEX #ind & ref-ind &
                                    [ PNG png & [ PN 3sg* ] ] ],
			 RELS <! #key !> ],
		   KEYS [ KEY #key & hour_prep_rel &
				     [ ARG0 #ind,
				       MINUTE-IND #minute,
				       HOUR-IND #hour ],
			  --COMPKEY #ckey ] ] ] ].

; ten pm to two am
; Tuesday to Friday
; ten mph to twenty mph
; DPF 3-Jul-02 - If KEY is interval_rel, then we predict wrongly that all of
; these constructions can be modifier NPs like "Tuesday".  But the modifiying
; capability seems to be whatever the interval endpoints are: "Kim stayed
; Tuesday to Saturday" but "*Kim stayed Abrams to Browne".  So let's try 
; making the KEY be the SPR's KEY instead.

n_x_to_y_lexent := norm_msg_word &
  [ SYNSEM basic_two_arg &
	 [ LOCAL [ CAT [ HEAD noun* &
			      [ POSS -,
                                PRD -,
				MOD < > ],
			 VAL [ SUBJ < >,
                               SPR < synsem &
				     [ LOCAL [ CAT nomp_cat_acc_min &
                                                   [ HEAD noun ],
                                               AGR.DIVISIBLE strict_sort,
					       CONJ cnil,
					       CONT.HOOK.INDEX #arg1 &
                                                   [ SORT #sort ],
					       KEYS [ KEY basic_nom_rel & #key,
                                                      MESSAGE 0-dlist ] ],
                                       NON-LOCAL.QUE 0-dlist,
				       OPT - ] >,
			       COMPS < synsem &
				       [ LOCAL [ CAT nomp_cat_acc_min &
                                                   [ HEAD noun ],
                                                 AGR.DIVISIBLE strict_sort,
						 CONJ cnil,
						 CONT.HOOK.INDEX #arg2 &
                                                     [ SORT #sort ],
						 KEYS [ KEY basic_nom_rel,
                                                        MESSAGE 0-dlist ] ],
                                         NON-LOCAL.QUE 0-dlist,
					 OPT - ] > ] ],
                   AGR.DIVISIBLE -,
		   CONT nom-obj &
		       [ HOOK.INDEX #index,
			 RELS <! interval_rel &
                                [ LBL #nhand,
                                  ARG0 #index ],
                                  udef_rel &
                                [ ARG0 #index,
                                  RSTR #rhand ],
                                interval_start_rel &
				[ LBL #nhand,
                                  ARG0.E.TENSE no_tense,
                                  ARG1 #index,
				  ARG2 #arg1 ],
				interval_end_rel &
				[ LBL #nhand,
                                  ARG0.E.TENSE no_tense,
				  ARG1 #index,
				  ARG2 #arg2 ] !>,
			 HCONS <! qeq & [ HARG #rhand,
                                          LARG #nhand ] !> ],
		   KEYS [ KEY #key,
                          ALTKEY never_unify_rel ] ] ] ].

n_x_to_y_sg_le := n_x_to_y_lexent &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL [ AGR.PNG.PN 3sg,
                                           KEYS.KEY nonpro_rel ] ] >, 
                           COMPS < [ LOCAL [ AGR.PNG.PN 3sg,
                                             KEYS.KEY nonpro_rel ] ] > ] ].

n_x_to_y_plur_le := n_x_to_y_lexent &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.KEYS.KEY part_of_rel ] >,
                           COMPS < [ LOCAL.AGR.PNG.PN 3pl ] > ] ].


; DPF 13-Aug-01 - For 'mid to upper' as in "the mid to upper nineties"
; Meaning intended to be something like "the nineties in the interval whose
; start is the mid somethings and whose end is the upper somethings"

adj_x_to_y_le := nontopkey &
  [ SYNSEM 
	 [ LOCAL [ CAT [ HEAD adj* & [ TAM #tam,
                                       PRD -,
                                       MOD < [ LOCAL intersective_mod &
                                                [ CAT nbar_cat,
                                                  CONT.HOOK [ LTOP #hand,
                                                              INDEX #nomarg & 
                                                                  ref-ind ],
                                                  CONJ cnil ] ] > ],
                         VAL [ SUBJ < >,
                               SPR < [ OPT -,
                                       LOCAL [ CAT [ HEAD adj_or_intadj &
                                                        [ TAM.TENSE no_tense ],
                                                     VAL [ SPR *olist*,
                                                           COMPS < > ] ],
                                               CONT.HOOK.INDEX #fromarg,
                                               CONJ cnil ],
                                       NON-LOCAL.SLASH 0-dlist ] >,
                               COMPS < [ OPT -,
                                         LOCAL 
                                          [ CAT [ HEAD adj_or_intadj &
                                                        [ TAM.TENSE no_tense ],
                                                  VAL [ SPR *olist*,
                                                        COMPS < > ] ],
                                            CONT.HOOK.INDEX #toarg,
                                            CONJ cnil ] ] > ] ],
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #nomarg,
                                 E-INDEX #event & [ E #tam ] ],
                          RELS <! interval_end_rel & #key &
                                [ LBL #ihand,
                                  ARG0 #event & [ E.TENSE no_tense ],
                                  ARG1 #intarg & [ DIVISIBLE +* ],
                                  ARG2 #toarg ],
                                interval_start_rel &
                                [ LBL #ihand,
                                  ARG0.E.TENSE no_tense,
                                  ARG1 #intarg,
                                  ARG2 #fromarg ],
                                elliptical_n_rel &
                                [ LBL #fghand,
                                  ARG0 #fromarg ],
                                udef_rel &
                                [ ARG0 #fromarg,
                                  RSTR #fgrhand ],
                                elliptical_n_rel &
                                [ LBL #tghand,
                                  ARG0 #toarg ],
                                udef_rel &
                                [ ARG0 #toarg,
                                  RSTR #tgrhand ],
                                interval_rel &
                                [ LBL #ihand,
                                  ARG0 #intarg ],
                                udef_rel &
                                [ ARG0 #intarg,
                                  RSTR #irhand ],
                                unspec_loc_rel &
                                [ LBL #hand,
                                  ARG0.E.TENSE no_tense,
                                  ARG1 #nomarg,
                                  ARG2 #intarg ] !>,
                         HCONS <! qeq & [ HARG #irhand,
                                          LARG #ihand ],
                                   qeq & [ HARG #fgrhand,
                                           LARG #fghand ],
                                   qeq & [ HARG #tgrhand,
                                           LARG #tghand ] !> ],
                   KEYS.KEY #key,
                   AGR.DIVISIBLE - ],
           MODIFIED.PERIPH na ] ].

p_compar_than_le := norm_mod_nonque_no_affix_word &
  [ SYNSEM compar_adj_prep_synsem ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADVERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Adverbs modify VPs and APs either pre-head or post-head (or both).
; Sentence-initial adverbials are treated as extractions of post-VP modifiers,
; unless the adverbial is a pre-head modifier. Otherwise, it would be hard to
; block post-S attachment along with post-VP attachment, which would give 
; spurious ambiguity.
; DPF 19-Oct-02 - Removed nonprd_synsem parent, since trying to make
; head_adj rule constrain adj to be PRD +.

basic_adverb_synsem := basic_one_arg & lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_adv &
		       [ MOD < [ LOCAL local_basic &
				       [ CAT.MC #mc,
                                         CONT.HOOK.INDEX #vevent & individual,
					 KEYS.MESSAGE #msg,
					 CONJ cnil ] ] > ],
		  VAL [ SUBJ < >,
                        SPR #spr,
			COMPS < > ],
                  MC #mc ],
	    CONT [ HOOK.INDEX #vevent,
		   RELS.LIST < #key, ... > ],
	    KEYS [ KEY #key & mod_rel,
		   MESSAGE #msg ],
            ARG-S #spr ] ].

basic_scopal_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal_mod &
				   [ CAT.HEAD adverbee & strict_type,
				     CONT.HOOK.LTOP #mhand ] ] >,
	    CONT.HCONS.LIST < qeq &
				 [ HARG #hand,
				   LARG #mhand ], ... >,
	    KEYS.KEY.ARG1 #hand & handle ] ].

; DPF 17-Dec-01 - Made MOD..E-INDEX reentrant with E-INDEX, and the INDEX 
; values the same: 
; 'Chairs currently available arrived"
basic_int_adverb_synsem := basic_adverb_synsem & isect_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL [ CAT.MC na,
                                     CONT.HOOK [ INDEX #index,
                                                 E-INDEX #vevent ] ] ] >,
            CONT.HOOK [ INDEX #index,
                        E-INDEX #vevent ],
	    KEYS.KEY.ARG1 #vevent ] ].

;; DPF 10-Oct-00 - SPR.KEYS.KEY needs fixing

spec_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT.VAL.SPR < synsem & 
			  [ LOCAL local_min &
				  [ CAT [ HEAD adv,
					  VAL [ SUBJ < >,
						SPR *olist* ],
					  MC na ],
                                    CONT.HOOK.LTOP #hand,
				    KEYS.KEY degree_rel &
					[ DARG #pred ] ] ] >,
            KEYS.KEY [ LBL #hand,
		       PRED #pred ] ] ].

scopal_spec_adverb_synsem := basic_scopal_adverb_synsem & spec_adverb_synsem &
  [ LOCAL.CAT.HEAD adv ].
intersect_spec_adverb_synsem := basic_int_adverb_synsem & spec_adverb_synsem.

; VP, PP, AP
scopal_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT [ VAL [ SUBJ < synsem_min >,
					       COMPS *olist* ],
                                         MC na_or_- ] ] >,
	    CONT [ RELS <! relation !>,
		   HCONS <! qeq !> ] ] ].

basic_intersect_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ VAL [ SUBJ < synsem_min >,
					     COMPS *olist* ],
				       MC na_or_- ] ] > ].

intersect_adverb_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT.HEAD reg_adv & [ MOD < [ LOCAL.CAT adverbee_cat ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; 'now' but not 'then' - appears after auxiliary as in "You are now ready"
intersect_adverb_auxv_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD lexadv & [ MOD < [ LOCAL [ CAT adverbee_cat &
                                                 [ HEAD v_or_g & strict_type ],
                                                  CONT.HOOK.LTOP #ltop ] ] > ],
                  POSTHEAD - ],
            CONT.HOOK.LTOP #ltop ] ].

; VP only
; Block adj modifiee to avoid spurious parse for "almost empty"
; DPF 09-Aug-99 - Relaxed MOD..HEAD value to be v_or_g_or_a because okay for 
; adjectives as pre-head modifiers ("an apparently difficult problem"), though
; not post-head.
; DPF 25-Oct-01 - Removed MOD..MOD < synsem > constraint since it blocked
; 'I should never have arrived'

scopal_vp_adverb_synsem := scopal_adverb_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g_or_a & strict_type ] >,
            KEYS.KEY abstr_adv_rel ] ].

; Adverbs like "also" that either (pre) modify VPs or appear as complements of
; aux Vs.
; DPF 24-May-00 - Restrict MOD value to be no_aspect, to avoid spurious
; ambiguity for "kim is probably leaving"
; DPF 14-Oct-00 - But this prevents the desired parse for "Kim is not currently
; sleeping" since "not" should modify a pres-participle VP, not the gerund.  So
; as long as the gerund rule is a lexical rule, we're stuck with the ambiguity.
; DPF 13-Mar-02 - Added [MOD..PRD +] to ensure that when these adverbs modify
; deverbal adjectives, they not appear attributively, as in *the not yet 
; finished book
; DPF 18-Mar-02 - But this [PRD +] prevents these adverbs from pre-modifying
; ordinary finite VPs.  So let's instead accept "the not yet finished book" as
; okay.

scopal_vp_aux_adverb_synsem := basic_scopal_adverb_synsem & 
                               spec_adverb_synsem &
  [ LOCAL [ CAT [ HEAD lexadv &
		       [ MOD < [ LOCAL.CAT [ HEAD v_or_g & strict_type,
					     VAL [ SUBJ < synsem >,
						   COMPS *olist* ],
					     MC na ] ] > ],
		  POSTHEAD - ],
	    CONT [ RELS <! relation !>,
		   HCONS <! qeq !> ] ] ].

comp_vp_adverb_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD adv & [ MOD < [ LOCAL.CAT adverbee_cat ] > ],
		  POSTHEAD + ],
	    CONT [ RELS <! #key &
			  [ LBL #hand,
			    ARG1 #ind ],
			  comp_rel &
			  [ LBL #hand,
			    ARG1 #ind ] !>,
                   HCONS <! !> ],
	    KEYS.KEY #key ] ].

; DPF 21-Mar-02 - Added MOD..MESSAGE 0-dlist, which seemingly should have
; been here all along - needed to block e.g. spurious parse for "kindly leave"
; DPF 12-Apr-02 - But this also blocked "Is it available yet", so instead
; change parent's MOD..VAL.SUBJ from < synsem> to < synsem_min >.
intersect_vp_adverb_synsem := intersect_adverb_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g & strict_type ] >,
            KEYS.KEY abstr_adv_rel ] ].

; S (for pre-S scopal adverbs only)
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.

scopal_s_adverb_synsem := spec_adverb_synsem &
  [ LOCAL [ CAT.HEAD adv &
                     [ MOD < [ LOCAL scopal_mod &
                                     [ CAT [ HEAD verb & strict_type,
                                             VAL [ SUBJ *olist*,
                                                   COMPS *olist* ],
                                             MC bool ],
                                       CONT.HOOK.LTOP #mhand,
                                       KEYS.MESSAGE 1-dlist ] ] > ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! relation, prpstn_rel &
			              [ LBL #ltop,
					MARG #marghand ] !>,
		   HCONS <! qeq &
			   [ HARG #marghand,
			     LARG #khand ] !> ],
	    KEYS.KEY [ LBL #khand,
                       ARG1 #mhand ] ] ].

; S or VP (for pre-head intersective adverbs only) 
intersect_s_or_vp_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL [ CAT.HEAD adv &
                     [ MOD < [ LOCAL.CAT adverbee_cat &
                                         [ VAL.COMPS *olist* ] ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; For adverbs like "maybe" which take no degree specifier
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.
scopal_s_adverb_nospec_synsem := basic_scopal_adverb_synsem &
  [ LOCAL [ CAT [ VAL.SPR < anti_synsem >,
		  HEAD adv &
                          [ MOD < [ LOCAL.CAT [ HEAD verb & strict_type,
						VAL [ SUBJ *olist*,
						      COMPS *olist* ],
						MC bool ] ] > ] ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! relation, prpstn_rel &
			              [ LBL #ltop,
					MARG #marghand ] !>,
		   HCONS <! qeq,
			     qeq &
			   [ HARG #marghand,
			     LARG #khand ] !> ],
	    KEYS.KEY.LBL #khand ] ].

intersect_s_or_vp_adverb_nospec_synsem := basic_int_adverb_synsem &
  [ LOCAL [ CAT [ VAL.SPR < anti_synsem >,
		  HEAD adv &
                       [ MOD < [ LOCAL.CAT adverbee_cat &
					 [ VAL.COMPS *olist* ] ] > ] ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

adverb_word := norm_mod_no_affix_word &
  [ SYNSEM scopal_adverb_synsem & 
	   [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g_or_a & 
                                                     strict_type ] >,
                     KEYS.KEY adv_rel ] ] ].
    
adv_le :< adverb_word.

; 'back' of 'back on the table'
adv_int_pp_le := norm_mod_no_affix_word &
  [ SYNSEM basic_intersect_adverb_synsem &
	   [ LOCAL [ CAT [ HEAD adv &
                                [ MOD < [ LOCAL.CAT cat &
                                           [ HEAD prep & strict_type ] ] >],
			   POSTHEAD - ],
		     CONT [ RELS <! relation !>,
                            HCONS <! !> ] ] ] ].

; DPF (27-Apr-99) Assume for now that S-initial adverbs can only modify [INV -]
; S's, in order to block "*Never does kim sleep?"
; DPF 28-Oct-01 - But this blocked e.g. "Meanwhile when does kim sleep"

adv_s_pre_le := norm_mod_no_affix_notopkey_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT [ POSTHEAD -,
			 HEAD.MOD < [ LOCAL.CAT.MC + ] > ] ] ].
    
; 'evidently' - only pre-modifies declaratives, not questions or commands
adv_s_prop_pre_le := norm_mod_no_affix_notopkey_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT [ POSTHEAD -,
			 HEAD.MOD 
                              < [ LOCAL [ CAT.MC +,
                                          KEYS.MESSAGE 
                                                <! propositional_rel !>]]>]]].
    
; DPF 10-Apr-02 - Removed MOD..VFORM imp_vform since this blocked e.g 
; "I would like to know when my order is going to arrive , please"
adv_s_post_word_nospec_le := norm_mod_no_affix_notopkey_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHEAD + ] ].

adv_s_pre_word_nospec_le := norm_mod_no_affix_notopkey_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].
    
adv_s_le := norm_mod_no_affix_notopkey_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.INV - ] > ] ].

adv_pre_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ].

adv_post_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

vp_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM scopal_vp_adverb_synsem ].
    
adv_vp_le := vp_adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] > ].

; 'please'
adv_vp_bse_le := vp_adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb & 
                                                 [ VFORM imp_vform ] ] > ].

adv_comp_vp_le := norm_mod_no_affix_word &
  [ SYNSEM comp_vp_adverb_synsem ].

adv_vp_aux_le := norm_mod_no_affix_word &
  [ SYNSEM scopal_vp_aux_adverb_synsem ].
    
; DPF 7-Jun-00 - To avoid apparently spurious ambiguity of attachment of
; VP-final scopal adverbs in e.g. "I have won too", require these adverbs to
; attach only to finite VP, forcing high attachment.

adv_vp_post_le := vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g & [ VFORM fin ] ] >,
                       POSTHEAD + ] ].

adv_vp_pre_le := vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ].

adv_vp_pre_bse_le := vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.VFORM bse ] >,
                       POSTHEAD - ] ].

adv_int_a_or_p_le := norm_mod_no_affix_word &
  [ SYNSEM intersect_adverb_synsem & 
           [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD a_or_p ] > ] ].
    
int_vp_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM intersect_vp_adverb_synsem ].
    
int_vp_aux_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM intersect_adverb_auxv_synsem ].
    
adv_int_vp_le := int_vp_adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD adv ].

adv_int_vp_aux_le := int_vp_aux_adverb_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! #key !>,
                          HCONS <! !> ],
                   KEYS.KEY #key ] ].

; 'now'
adv_int_vp_aux_now_le := que_no_wlink_word &
  [ SYNSEM intersect_adverb_auxv_synsem &
           [ LOCAL [ CAT.HEAD.TAM #tam,
                     CONT [ HOOK [ LTOP #hand,
                                   INDEX #index ],
                            RELS <! temp_loc_rel &
                                   [ LBL #hand,
                                     WLINK #wlink,
                                     ARG1 #index,
                                     ARG2 #inst ],
                                   time_rel & 
                                   [ LBL #nhand, 
                                     WLINK #wlink & *cons*,
                                     ARG0 #inst ],
                                   def_rel &
                                   [ ARG0 #inst,
                                     RSTR #rhand ],
                                   _now_rel & 
                                   [ LBL #nhand,
                                     ARG1 #inst ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #nhand ] !> ],
                     KEYS.KEY.ARG0.E #tam ] ] ].

adv_int_vp_post_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv,
                       POSTHEAD + ] ].
adv_int_vp_pre_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv,
                       POSTHEAD - ] ].

adv_int_vp_post_nonmob_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob,
                       POSTHEAD + ]].

; ERB (31-10-96) See notes near n_wh_pro_le.
; where, when, how
pp_wh_le := nonconj & non_affix_bearing & mcna & nonslash & nonrel & 
		  topkey &
  [ SYNSEM prep_p_mod_synsem &
      [ LOCAL [ CAT [ HEAD prep* &
			   [ PRD bool,
			     MOD < [ LOCAL.CAT.HEAD v_or_g_or_a & 
						    strict_type ] > ],
		      VAL.COMPS < >,
		      POSTHEAD + ],
		CONT [ RELS <! #key & [ ARG2 #objind,
                                         WLINK #wlink ],
			        which_rel & [ ARG0 #objind,
					      RSTR #rhand ],
			        nom_rel & #altkey &
			                  [ LBL #nhand,
					    ARG0 #objind,
                                            WLINK #wlink ] !>,
		       HCONS <! qeq &
			       [ HARG #rhand,
				 LARG #nhand ] !> ],
		KEYS [ KEY #key,
		       ALTKEY #altkey ] ],
	NON-LOCAL.QUE 1-dlist &
	      [ LIST < handle > ] ] ].
 
;; DPF 10-Oct-00 - SPR.KEYS.KEY needs fixing

pp_rel_le := rel_word &
  [ SYNSEM basic_lex_pp_synsem &
      [ LOCAL [ CAT [ HEAD prep* & 
			   [ PRD +,
			     MOD < [ LOCAL [ CAT vp_cat &
						 [ HEAD verb ],
					     CONT.HOOK.INDEX #event & event,
					     CONJ cnil,
					     KEYS.MESSAGE #msg ] ] > ],
		      VAL.SPR < synsem & [ LOCAL local_min &
					   [ CAT [ HEAD adv,
						   VAL [ SPR *olist*,
							 COMPS *olist* ] ],
                                             CONT.HOOK.LTOP #khand,
					     KEYS.KEY degree_rel &
						 [ DARG #pred ] ],
				     NON-LOCAL.QUE 0-dlist,
				     OPT + ] >,
		      POSTHEAD + ],
		CONT [ HOOK.INDEX #event,
		       RELS <! #key & [ ARG1 #event,
					 ARG2 #objind ] !>,
		       HCONS <! !> ],
		KEYS [ KEY #key & [ LBL #khand,
				    PRED #pred ],
		       MESSAGE #msg ] ],
	NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #objind ] > ] ] ].


; 'on vacation', 'in bed'

prep_p_mod_phr_synsem := prep_p_mod_synsem & phr_synsem.
prep_nomod_phr_synsem := prep_p_synsem & phr_synsem &
  [ LOCAL.CAT.HEAD.MOD < > ].

pp_idiom_lexent := msg_amalg_word &
  [ SYNSEM prep_p_mod_phr_synsem &
	   [ LOCAL [ CAT [ HEAD prep*,
                           VAL.COMPS < > ],
                     KEYS [ KEY #key,
                            ALTKEY #altkey ],
                     CONT [ RELS <! #key & [ ARG2 #inst ],
                                     #altkey & 
                                   [ LBL #nhand,
                                     ARG0 #inst & ref-ind &
                                            [ PNG png & [ PN 3sg,
                                                          GEN neut ] ] ],
                                   udef_rel &
                                   [ ARG0 #inst,
                                     RSTR #rhand ] !>,
                            HCONS <! qeq &  [ HARG #rhand,
                                              LARG #nhand ] !> ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         REL 0-dlist,
                         QUE 0-dlist ] ],
    POSSCL - ].

pp_idiom_le :< pp_idiom_lexent.
pp_idiom_prd_le := pp_idiom_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD +,
                            MOD.FIRST.LOCAL.CAT.HEAD noun ] ].

pp_as_adj_le := msg_amalg_word &
  [ SYNSEM prep_nomod_phr_synsem &
	   [ LOCAL [ CAT [ HEAD prep*,
                           VAL [ SPR < >,
                                 COMPS < > ] ],
                     KEYS [ KEY _as_comp_rel & [ ARG2 #pinst ],
                            ALTKEY #altkey ],
                     CONT [ RELS <! #altkey & 
                                   [ ARG1 #pinst ],
                                   def_rel & [ RSTR #rhand,
                                               ARG0 #pinst ],
                                   pron_rel & [ LBL #prohand,
                                                ARG0 #pinst ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !> ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         REL 0-dlist,
                         QUE 0-dlist ] ],
    POSSCL - ].


adv_comparison_spec_le := norm_no_affix_word &
  [ SYNSEM nomod_synsem &
	  [ LOCAL [ CAT [ HEAD adv,
			  VAL [ COMPS < >,
				SPR < > ] ],
		    CONT [ HOOK [ LTOP #hand,
                                  INDEX #inst ],
			   RELS <! #key &
				    [ LBL #hand,
				      C-ARG0 #inst ] !>,
                           HCONS <! !> ],
		    KEYS.KEY #key ] ] ].
			   

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DETERMINERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Determiners must have the KEY relation be the quantifier, since nouns
; select their determiner in part based on the type of the quantifier rel.
; The basic determiner synsem has a non-null value for its specifier; this is 
; to account for cases like "nearly all books, only his book, exactly which
; book, almost every book".  
;
; Quantifiers need to accommodate expressions like
; 'almost every book'.  One might expect to have the degree_rel of 'almost'
; take the handle of 'every' as its ARG1 value, but this may interfere with 
; the treatment of scope which needs to identify the set of quantifier handles.
; So we do this by adding separate lexical entries for these det-specs.

; DPF 10-Oct-00 - SPR.KEYS.KEY needs fixing

basic_det_synsem := nomod_synsem &
  [ LOCAL [ CAT [ HEAD det,
		  VAL [ SPR < [ LOCAL local_min &
				      [ KEYS.KEY degree_rel & 
						     [ DARG #pred ] ],
				NON-LOCAL [ QUE 0-dlist,
					    REL 0-dlist ],
				OPT + ] >, 
			SPEC < [ LOCAL.CONT.HOOK [ LTOP #nhand,
                                                   INDEX #index ] ] >,
			COMPS < > ] ],
	    CONT nom-obj &
		[ HOOK.INDEX #index,
		  RELS.LIST < quant_or_wh_rel & #key, ... >,
		  HCONS.LIST < qeq &
				[ HARG #rhand,
				  LARG #nhand ], ... > ],
	    KEYS.KEY #key & [ ARG0 #index,
			      RSTR #rhand,
			      PRED #pred ],
	    ARG-S < > ] ].

nonpart_det_synsem := basic_det_synsem &
  [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CONT.HOOK.LTOP #khand ] >,
            KEYS.KEY.LBL #khand ] ].

det_synsem := nonpart_det_synsem &
  [ LOCAL [ CONT [ RELS <! quant_or_wh_rel !>,
                   HCONS <! qeq !> ] ] ].

basic_part_det_synsem :< basic_det_synsem.

part_det_synsem := basic_part_det_synsem &
  [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CONT.HOOK.LTOP #khand ] >,
            KEYS.KEY.LBL #khand ] ].

part_det_synsem_nonwh := part_det_synsem & 
  [ LOCAL.CONT.HCONS <! qeq !>,
    NON-LOCAL.QUE 0-dlist ].

; DPF 21-Nov-01 - Removed BV..DIVISIBLE -* and AGR.DIVISIBLE -: last Christmas
next_last_det_synsem := nonpart_det_synsem &
  [ LOCAL [ CAT.VAL.SPEC < [ LOCAL [ CAT.VAL.COMPS < >,
                                     CONT.HOOK.LTOP #nhand,
				     KEYS.KEY temp_abstr_rel ],
                             MODIFIED notmod ] >,
	    CONT [ RELS <! def_rel &
			    [ ARG0 #ind & [ PNG png & [ PN 3sg* ] ] ],
			    relation & #altkey &
			    [ LBL #nhand,
			      ARG1 #ind ] !>,
		   HCONS <! qeq !> ],
            AGR.PNG.PN 3sg,
            KEYS.ALTKEY #altkey ] ].

basic_det_word :< word.
abstr_det_word := basic_det_word & que_word.
det_word := abstr_det_word &
  [ SYNSEM det_synsem & [ LOCAL.CAT.HEAD.POSS - ] ].

det_word_sing := det_word &
  [ SYNSEM.LOCAL [ KEYS [ KEY.ARG0 [ PNG png & [ PN 3sg* ],
                                     DIVISIBLE -* ],
                          ALTKEY no_rel ],
                   AGR [ PNG.PN 3sg,
                         DIVISIBLE - ] ] ].

det_word_nonque := det_word & nonque.

det_pl_le := det_word_nonque &
  [ SYNSEM [ LOCAL [ KEYS [ KEY.ARG0.PNG png & [ PN 3pl* ],
                            ALTKEY no_rel ],
                     AGR.PNG.PN 3pl ],
	     MODIFIED hasmod ] ].

det_sm_le := det_word_nonque &
  [ SYNSEM [ LOCAL [ KEYS.KEY.ARG0.PNG png & [ PN 3sg* ],
                     AGR.PNG.PN 3sg ],
	     MODIFIED hasmod ] ].

#|
det_plm_le := det_word &
  [ SYNSEM [ LOCAL.KEYS [ KEY.ARG0.DIVISIBLE +*,
                          ALTKEY no_rel ],
	     MODIFIED hasmod ] ].
|#

det_next_last_le := abstr_det_word & nonque &
  [ SYNSEM next_last_det_synsem & 
	   [ LOCAL.CAT.HEAD.POSS -,
             MODIFIED hasmod ] ].  

det_yesterday_tomorrow_le := abstr_det_word & nonque &
  [ SYNSEM next_last_det_synsem & 
	   [ LOCAL.CAT [ HEAD.POSS -,
                         VAL.SPEC < [ LOCAL.KEYS.KEY day_part_rel ] > ],
	     MODIFIED hasmod ] ].  

; DPF 20-Feb-01 - Use SPEC..ALTKEY to block det-N analysis of 
; "both kim and sandy"
; DPF 11-Mar-02 - Use ALTKEY to block phrasal partitive-NP rule
pdet_word := abstr_det_word &
  [ SYNSEM part_det_synsem_nonwh &
	   [ LOCAL [ CAT.VAL.SPEC < [ LOCAL.KEYS.ALTKEY basic_nom_rel ] >,
                     CONT.RELS <! quant_or_wh_rel !>,
                     KEYS.ALTKEY no_rel ],
	     MODIFIED hasmod ] ].

pdet_word_nonque := pdet_word & nonque.

det_part_le :< pdet_word_nonque.

; DPF 19-Oct-02 - Would like to make DIV +* not + to allow coordination of 
; unlike NPs ("my book and some other stuff"), but then we can't block
; spurious "some programmer" whose DIV value ends up +_and_-.  An example
; of problems with this overspecification approach to coordination.

det_part_div_le := pdet_word_nonque &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.DIVISIBLE + ].

det_part_sg_le := pdet_word_nonque &
  [ SYNSEM.LOCAL [ KEYS.KEY.ARG0 [ PNG png & [ PN 3sg* ],
                                   DIVISIBLE -* ],
                   AGR [ PNG.PN 3sg,
                         DIVISIBLE - ] ] ].

det_part_ms_le := pdet_word_nonque &
  [ SYNSEM.LOCAL [ KEYS.KEY.ARG0 [ PNG png & [ PN 3sg* ],
                                   DIVISIBLE +* ],
                   AGR [ PNG.PN 3sg,
                         DIVISIBLE + ] ] ].

det_part_pl_le := pdet_word_nonque &
  [ SYNSEM.LOCAL [ KEYS.KEY.ARG0.PNG png & [ PN 3pl* ],
                   AGR.PNG.PN 3pl ] ].

; This assumes (falsely) that all plurals are divisible (cf "oats", "clothes")
; It also incorrectly blocks coordinations like "Kim and all children" since 
; the alternative (DIVISIBLE +*) would fail to block "all book".

det_part_pl_mass_le := pdet_word_nonque &
  [ SYNSEM [ LOCAL [ KEYS.KEY.ARG0.DIVISIBLE +*,
                     AGR.DIVISIBLE + ],
             MODIFIED hasmod ] ].

det_part_unsp_le := abstr_det_word &
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD.POSS -,
		     CONT [ RELS <! quant_or_wh_rel !>,
			    HCONS <! qeq !> ] ],
	     NON-LOCAL.QUE 1-dlist &
		           [ LIST < handle > ] ] ].

pdet_word_pl_mass_wh := abstr_det_word &
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD.POSS -,
		     CONT [ HOOK.INDEX #mainind,
                            RELS <! udef_rel,
				 which_rel & [ ARG0 #index,
					       RSTR #rhand ],
				 diadic_nom_rel & #altkey &
				   [ LBL #nhand,
				     ARG0 #index ],
                                 unspec_rel &
                                   [ LBL #nhand, 
                                     ARG1 #mainind,
                                     ARG2 #index ] !>,
			    HCONS <! qeq,
				      qeq &
				      [ HARG #rhand,
					LARG #nhand ]!> ],
		     KEYS.ALTKEY #altkey ],
             NON-LOCAL.QUE 1-dlist &
		           [ LIST < handle > ] ] ].

det_part_ms_wh_le := pdet_word_pl_mass_wh &
  [ SYNSEM.LOCAL [ KEYS [ KEY.ARG0 [ PNG png & [ PN 3sg* ],
                                     DIVISIBLE +* ],
                          ALTKEY quantity_rel ],
                   AGR [ PNG.PN 3sg,
                         DIVISIBLE + ] ] ].

det_part_pl_wh_le := pdet_word_pl_mass_wh &
  [ SYNSEM.LOCAL [ KEYS [ KEY.ARG0.PNG png & [ PN 3pl* ],
                          ALTKEY number_rel ],
                   AGR.PNG.PN 3pl ] ].

; DPF 29-May-02 - Added ALTKEY no_rel to block this "one" from appearing as
; specifier of day-of-month as in "one five" for "may five"
det_part_one_le := que_no_wlink_word & basic_det_word &
  [ SYNSEM basic_part_det_synsem &
	   [ LOCAL [ CAT.VAL [ SPR < [ LOCAL.CONT.HOOK.LTOP #nhand ] >,
                               SPEC < [ LOCAL.CONT.HOOK.LTOP #nhand ] > ],
                     CONT [ RELS <! udef_rel &
                                   [ ARG0 #ind & 
                                        [ PNG png & [ PN 3sg* ],
                                          DIVISIBLE -* ], 
                                     WLINK #wlink ],
                                   card_rel &
                                   [ LBL #nhand,
                                     ARG1 #ind,
                                     WLINK #wlink,
                                     CARG "1" ] !>,
                            HCONS <! qeq !> ],
                     KEYS.ALTKEY no_rel,
                     AGR [ PNG.PN 3sg,
                           DIVISIBLE - ] ],
             NON-LOCAL.QUE 0-dlist ] ].


; DPF 10-May-00 - We add subtypes of determiners to distinguish "We met every 
; week" from "*We met the week".  The distinction makes use of the feature 
; MODIFIED, where the head-specifier rule's mother's MODIFIED value is 
; determined by the specifier daughter, so each specifier has to say whether it
; passes on the MODIFIED value from its head, or supplies its own.  Thus "the"
; just passes up the value from the head, "every" supplies its own 'hasmod' 
; value, and "a" supplies the opposite value "notmod", to block "*Kim arrived 
; a big week".

det_lexent := det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPEC < [ MODIFIED #modif ] >,
                     KEYS.ALTKEY no_rel ],
	     MODIFIED #modif ] ].

det_le :< det_lexent.

; 'some'
det_nondiv_le := det_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.DIVISIBLE - ].

; 'the'
det_the_le := det_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.KEYS.KEY just_only_degree_rel ] > ].

; 'half the time'
det_word_modable := det_word &
  [ SYNSEM [ LOCAL.KEYS.ALTKEY no_rel,
             MODIFIED hasmod ] ].

det_wh_le := det_word_modable &
  [ SYNSEM [ LOCAL.KEYS.KEY.LBL #hand,
	     NON-LOCAL.QUE 1-dlist &
			   [ LIST < #hand > ] ] ].

det_modable_le := det_word_modable & nonque.

det_sing_nonque := det_word_sing & nonque.

; 'an'
; DPF 15-Nov-01 - Removed [SPR <anti_synsem>] since this blocke "more than a
; week ago"
det_sg_nomod_le := det_sing_nonque &
  [ SYNSEM.MODIFIED notmod ].
           
; 'every'
det_sg_le := det_sing_nonque &
  [ SYNSEM.MODIFIED hasmod ].

; 'all week'
; DPF 13-Feb-01 - Restrict to lexical nouns, to block e.g. "all sold out last
; week"
det_sg_temp_le := det_sing_nonque &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC < [ LOCAL.KEYS.KEY temp_abstr_rel,
                                    MODIFIED notmod ] >,
             MODIFIED hasmod ] ].

;; We make the non-quantifier relation generically pron_rel, and have each
;; individual pronoun simply constrain the ARG0 index of that pron_rel.
;;   This type is used for both WH "whose" and relative "whose", so it leaves 
;; both  QUE  and  REL  values unspecified, but supplies all other defaults.

poss_word := nonconj & non_affix_bearing & nonslash & nonmsg & 
	     mcna & basic_det_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.POSS +,
		   CONT nom-obj &
			[ HOOK.INDEX #index,
			  RELS.LIST < relation,
				       basic_poss_rel &
				       [ ARG1 #index ], ... > ] ] ].

; ERB (31-10-96) See notes near n_wh_pro_le.

det_wh_poss_le := poss_word & nonrel &
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #nhand ] >,
		     CONT [ RELS <! which_rel & #key,
				     pro_poss_rel & [ LBL #nhand,
                                                      ARG2 #ind ],
				     person_rel & [ LBL #phand,
						    ARG0 #ind ],
				     def_rel & [ ARG0 #ind,
                                                 RSTR #rhand2 ] !>,
			    HCONS <! qeq, 
				      qeq &
				      [ HARG #rhand2,
					LARG #phand ] !> ],
		     KEYS.KEY #key ],
	     NON-LOCAL.QUE 1-dlist &
			   [ LIST < handle > ] ] ].

nonwh_poss_word := poss_word & nonque &
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CONT [ RELS.LIST < relation, #altkey, ... >,
			    HCONS.LIST < qeq, ... > ],
                     KEYS [ KEY abstr_def_rel,
			    ALTKEY #altkey ] ] ] ].

det_poss_lexent := nonwh_poss_word & nonrel &
  [ SYNSEM.LOCAL [ CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #hand ] >,
		   CONT [ RELS <! relation & [ WLINK #wlink ],
                                   pro_poss_rel &
				   [ LBL #hand,
				     ARG2 #ind ],
                                   def_rel & 
                                   [ RSTR #rhand,
                                     ARG0 #ind ],
				   pron_rel &
				   [ LBL #prohand,
                                     WLINK #wlink,
				     ARG0 #ind &
					  [ PRONTYPE std_pron ] ] !>,
                          HCONS <! qeq, qeq & [ HARG #rhand,
                                                LARG #prohand ] !> ] ] ].

det_poss_her_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
                             [ ARG0 [ PNG png & [ PN 3sg*,
                                                  GEN fem* ],
                                      PRONTYPE std_3 ] ] !> ].
det_poss_his_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3sg*,
						    GEN masc* ],
					PRONTYPE std_3 ] ] !> ].
det_poss_its_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3sg*,
						    GEN neut* ],
					PRONTYPE std_3 ] ] !> ].
det_poss_its_robust_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3sg*,
						    GEN neut* ],
					PRONTYPE std_3 ] ] !>,
    ROBUST + ].
det_poss_my_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1sg* ],
					PRONTYPE std_1sg ] ] !> ].
det_poss_our_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1pl* ],
					PRONTYPE std_1pl ] ] !> ].
det_poss_their_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3pl* ],
					PRONTYPE std_3 ] ] !> ].
det_poss_your_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 2per ],
					PRONTYPE std_2 ] ] !> ].

det_rel_poss_le := nonwh_poss_word &
  [ SYNSEM [ LOCAL.CONT [ RELS <! relation,
                                   poss_rel &
                                   [ LBL #hand,
                                     ARG2 #ind ] !>,
                          HCONS <! qeq !> ],
	     NON-LOCAL.REL 1-dlist &
			   [ LIST < [ LTOP #hand,
				      INDEX #ind ] > ] ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Free relatives
;
; One crucial property of free relatives is that they have a non-empty QUE
; value whose single list element is an index (rather than the handle which
; is employed for ordinary question WH-words).
; The other is that they encode the constraints for their S/XP sister in the
; free-relative construction, in their SLASH attribute.

free_rel_pro_word := nonconj & non_affix_bearing & mcna & nonrel & nonmsg &
		     hc-to-phr & basic_pronoun_word &
  [ SYNSEM synsem &
	   [ LOCAL [ CAT.VAL [ SPR < >,
			       SUBJ < >,
			       COMPS < > ],
		     AGR #ind,
		     CONT [ HOOK.INDEX ref-ind & #ind & [ PNG.PN 3sg ],
			    RELS.LIST < free_relative_ever_rel &
					 [ ARG0 #ind,
					   RSTR #rhand ], 
					 [ LBL #nhand,
					   ARG0 #ind ], ... >,
			    HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !> ],
		     ARG-S < > ],
	     NON-LOCAL [ REL 0-dlist,
			 QUE 1-dlist & <! #ind !>,
			 SLASH 1-dlist &
                               <! [ CAT.VAL.COMPS < >,
                                    CONJ cnil ] !> ] ] ].

; whatever, whoever
; DPF 20-Aug-01 - Added SLASH..PRD - to block "what my offers are" with 
; predicative copula.

n_freerel_pro_le := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD noun* &
			      [ MOD < >,
				PRD - ],
		     CONT [ HOOK [ INDEX #ind,
                                   E-INDEX #ind ],
                            RELS <! relation & #altkey, #key !> ],
                     KEYS [ KEY #key,
			    ALTKEY #altkey ] ],
	     NON-LOCAL.SLASH 1-dlist &
                   <! [ CAT.HEAD noun & [ MOD < >,
                                          PRD - ],
                        CONT.HOOK.INDEX #ind,
                        AGR ref-ind & [ PNG.PN 3sg ] ] !> ] ].

; when, where
; DPF 15-Apr-02 - Added SLASH..VAL.SUBJ..INDEX #arg to accommodate predicative
; 'be' as in "Find where Kim is"
; DPF 19-Oct-02 - Removed PRD - since need to allow head_adj_phr to have 
; adjunct be PRD +.

n_freerel_pro_adv_le := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD noun* &
			      [ MOD < > ],
		     CONT [ HOOK.E-INDEX #arg,
                            RELS <! relation, 
                                   #key & [ ARG0 #ind ],
                                   prep_mod_rel & #alt2key &
                                   [ LBL #lochand,
                                     ARG0 [ E [ TENSE no_tense,
                                                 ASPECT no_aspect ] ],
                                     ARG1 #arg,
                                     ARG2 #ind ] !> ],
		     KEYS [ KEY #key,
			    ALTKEY #key,
                            ALT2KEY #alt2key ] ],
	     NON-LOCAL.SLASH 1-dlist &
                   <! [ CAT [ HEAD prep & 
                                   [ MOD < synsem &
                                           [ LOCAL.CONT.HOOK.INDEX #arg ] > ],
                              VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #arg ] > ],
                        CONT.HOOK [ LTOP #lochand,
                                    E-INDEX #arg ] ] !> ] ].

free_rel_det_word_gen := nonconj & non_affix_bearing & mcna & nonrel & nonmsg &
		     hc-to-phr &
  [ SYNSEM basic_det_synsem & 
	   [ LOCAL [ CAT [ HEAD.POSS -,
			   VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #althand ] > ],
		     CONT [ RELS <! free_relative_ever_rel !>,
			    HCONS <! qeq !> ],
		     KEYS.ALTKEY.LBL #althand  ],
	     NON-LOCAL [ QUE 1-dlist &
			     [ LIST < index  > ],
			 SLASH 1-dlist &
			     <! [ CAT.HEAD n_or_p ] !> ] ] ].

; whatever, what
det_freerel_le := free_rel_det_word_gen &
  [ SYNSEM det_synsem & 
           [ LOCAL [ CAT.HEAD.POSS -,
                     KEYS.ALTKEY no_rel ],
             NON-LOCAL.SLASH <! [ CAT.HEAD.CASE acc ] !> ] ].

; whichever
n_freerel_part_le := free_rel_det_word_gen &
  [ SYNSEM part_det_synsem ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Possessives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Possessive "'s" takes an NP[-Poss] specifier and projects either an
;; NP[+Poss] phrase (for "the book of Kim's") or a DetP[+Poss] phrase (for
;; "Kim's book").  Either way, the content of the possessive phrase will be a
;; definite possessive quantifier.  The NP[+Poss] things also work pretty well
;; for things like "Kim's is under the desk" if we allow governed NPs to be
;; +Poss.  The tricky thing will be figuring out exactly where `bare
;; possessives' can show up.  Also, we need to add the restriction that the SPR
;; must be non-pronominal.  We cannot simply make the synsem of the SPR be
;; the type nonpronominal, since that NP might be either lexical or phrasal,
;; distinguished by the synsem types lex_synsem and phr_synsem.  So we use
;; the semantic KEY relation to identify nonpronominals.

;; Another question is what do we do with the scope
;; of quantifiers in the possessor?  This entry assumes that they always have
;; narrow scope.  That should be an empirical question, as the saying goes.

n_poss_clitic_lexent := mcna & nonconj & nonmsg & non_affix_bearing &
  [ SYNSEM nomod_synsem &
     [ LOCAL [ ARG-S < #spr >,
	       CAT [ HEAD poss-able &
			  [ POSS + ],
		     VAL [ SPR < #spr & synsem &
				 [ LOCAL [ CAT nomp_cat_min,
                                           AGR.DIVISIBLE strict_sort,
					   CONJ cnil,
					   KEYS.KEY nonpro_rel,
					   CONT.HOOK.INDEX #pindex & 
                                                           individual ],
				   NON-LOCAL [ SLASH #slash,
					       REL #rel,
					       QUE #que ],
				   OPT - ] >,
			   COMPS < >,
			   SPEC < [ LOCAL.CONT.HOOK [ LTOP #phand,
                                                      INDEX #index ] ] > ] ],
	       CONT [ HOOK.INDEX #index,
		      RELS <! #key & def_explicit_rel & [ ARG0 #index,
                                                           RSTR #rhand ],
                               #altkey & poss_rel & [ LBL #phand,
                                                      ARG2 #pindex,
                                                      ARG1 #index ] !>,
		      HCONS <! qeq & [ HARG #rhand,
                                       LARG #phand ] !> ],
	       KEYS [ KEY #key,
		      ALTKEY #altkey ] ],
       NON-LOCAL [ SLASH #slash,
		   REL #rel,
		   QUE #que ] ] ].

n_poss_clitic_lex_le := n_poss_clitic_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LEX + ] > ].
n_poss_clitic_phr_le := n_poss_clitic_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LEX - ] > ].

;; The possessive "of" takes an NP[+Poss] complement (e.g., "Kim's", "mine")
;; and modifies an N'[-Poss].  Unfortunately, the way the hierarchy of
;; preposition types is built, there wasn't any type this could inherit from.
;; We could probably rearrange things so this inherits some preposition
;; properties, but right now I'm too lazy.  Also, somehow we'll have to make
;; sure that this doesn't modify a pronoun.  The semantic manipulation here is
;; tricky - keep your eyes on the definite quantifier.  This def_rel provided
;; by the apostrophe-s (for its other life as a determiner), is dropped by the
;; possessive-of, analogous to nouns, verbs, and adjectives dropping the
;; semantics of the prepositions that can mark their complements.  This
;; dropping of the relation is effected by having the possessive-of neglect to
;; grab the handle of the def_rel for its complement, but grab instead the
;; handle (and instance variable) of the NP complement of the apostrophe-s.
;; Then the general semantic pruning mechanism will ignore the def_rel, since
;; its handle will not be a value in any other relation.

one_arg_isect := one_arg & isect_synsem.

;; DPF 10-Oct-00 - COMPS.KEYS.ALTKEY needs fixing - may be tricky since we
;; need to get to the n-bar's handle - not supposed to be visible at NP.
;; FIX??

p_poss_of_le := nonque & nonconj & nonslash & nonrel & mcna & 
                non_affix_bearing & hc-to-phr &
  [ SYNSEM one_arg_isect &
     [ LOCAL 
       [ ARG-S #comps,
	 CAT [ HEAD prep* & 
		    [ PRD -,
		      MOD < [ LOCAL [ CAT nbar_cat,
				      CONT.HOOK [ LTOP #hand,
                                                  INDEX #index ],
				      CONJ cnil,
				      KEYS.MESSAGE #msg ] ] > ],
	       VAL [ SUBJ < >,
		     SPR < >,
		     COMPS #comps & < synsem &
				      [ LOCAL [ CAT [ HEAD noun & strict_type &
							   [ POSS + ],
						      VAL [ SPR *olist*,
							    COMPS *olist* ],
						      MC na_or_- ],
						CONJ cnil,
						KEYS.ALTKEY [ LBL #hand,
                                                              ARG1 #index ] ],
                                        OPT - ] > ],
	       POSTHEAD + ],
	 CONT [ HOOK [ LTOP #hand,
                       INDEX #index ],
		RELS <! !> ],
	 KEYS [ KEY no_rel,
		MESSAGE #msg ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBORDINATING CONJUNCTIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; These are not restricted to modifying only main VPs, since e.g. "if" needs
; to take scope over modals as in "I'd be pleased if we made an appointment."
; This lack of constraint means there will be structural ambiguity for 
; if-clauses, but not spurious - get different scopes of "if" and modals.
; But we restrict them to modifying only finite VPs or imperatives.

; DPF (10-Jan-99) Changed these to modify S rather than VP, since they don't
; appear to survive extraction from embedded clauses, nor do they appear inside
; an extraposed subject relative clause.

; DPF (10-Jan-98) For some reason, can't make the HEAD value prep* - fails to
; unify with strict_type in "Kim sleeps if Sandy sleeps".  Solve later.

; DPF 02-Oct-00 Changed subconj_inf_synsem to modify S rather than VP, in 
; order to make semantics consistent with other subord rels.

basic_subconj_synsem := nonprd_synsem &
  [ LOCAL [ CAT [ HEAD prep &
		       [ MOD < [ LOCAL scopal_mod &
				       [ CAT s_cat &
                                             [ MC #mc ],
					 CONT.HOOK [ LTOP #modltop,
                                                     INDEX #ind &
                                                      [ E.TENSE real_tense ] ],
                                         KEYS.MESSAGE 1-dlist,
					 CONJ cnil ],
				 NON-LOCAL.SLASH 0-dlist ] > ],
		  VAL [ SUBJ < >,
			SPR < > ],
                  MC #mc ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #ind ],
		   RELS.LIST < subord_rel & #key &
                                [ LBL #sltop,
                                  MAIN #main,
                                  SUBORD #subord ],
                                prpstn_rel & #msg &
                                [ LBL #ltop,
                                  MARG #marg ], ... >,
		   HCONS.LIST < qeq & [ HARG #main,
                                        LARG #modltop ],
                                 qeq & [ HARG #subord ],
                                 qeq & [ HARG #marg,
                                         LARG #sltop ], ... > ],
            KEYS [ KEY #key,
		   MESSAGE <! #msg !> ] ] ].

basic_onearg_subconj_synsem := basic_subconj_synsem & basic_one_arg &
  [ LOCAL [ ARG-S #comps,
            CAT.VAL.COMPS #comps & < synsem &
                                     [ LOCAL.KEYS.KEY #ckey,
                                       NON-LOCAL [ SLASH 0-dlist,
                                                   REL 0-dlist,
                                                   QUE 0-dlist ],
                                       OPT - ] >,
            KEYS.--COMPKEY #ckey ] ].
                  

subconj_cp_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CONT.HOOK [ LTOP #cltop,
                                                  INDEX event ],
                                      KEYS.MESSAGE 1-dlist &
                                                 <! propositional_rel !> ],
                              NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                          QUE 0-dlist,
                                          REL 0-dlist ] ] >,
            CONT [ RELS <! relation, relation !>,
                   HCONS <! qeq,
                             qeq & [ LARG #cltop ], 
                             qeq !> ] ] ].

subconj_synsem := subconj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT s_cat_fin,
                                    CONT.HOOK.INDEX.E.TENSE real_tense ] ] > ].

subconj_cp_nocop_synsem := subconj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_v_c & 
                            [ HEAD verb &
                                   [ TAM.TENSE no_tense,
                                     MOD < [ LOCAL.CAT.HEAD no_head ] >]]]>].

subconj_inf_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT s_cat_fin_or_imp ] >,
                  VAL.COMPS < [ LOCAL 
                                [ CAT vp_bse_cat &
                                 [ VAL [ SUBJ < unexpressed >,
                                         SPR *olist* ] ],
                                  CONT.HOOK [ LTOP #vpltop,
                                              INDEX event &
                                                [ E [ TENSE no_tense,
                                                      MOOD ind_or_mod_subj ] ],
                                              XARG #sind ],
                                  KEYS.MESSAGE 0-dlist ] ] > ],
            CONT [ RELS <! subord_rel,
                            message,
                            prpstn_rel & [ LBL #cltop,
                                           MARG #hmarg ],
                            def_rel & [ RSTR #rhand,
                                        ARG0 #sind ],
                            pron_rel & [ LBL #prohand,
					 ARG0 #sind &
						[ PRONTYPE zero_pron ] ] !>,
                   HCONS <! qeq,
                             qeq & [ LARG #cltop ], 
                             qeq,
                             qeq & [ HARG #hmarg,
                                     LARG #vpltop ],
                             qeq & [ HARG #rhand,
                                     LARG #prohand ] !> ] ] ].

; DPF 2/6/02 - Changed COMPS..SPR synsem to synsem_min in order to support 
; e.g. 'I slipped while dancing'
; DPF 5/20/02 - Cannot require that COMPS..SUBJ..INDEX be re-entrant with
; the MOD..AGR, since get sentences like "There are age restrictions when
; renting a car" where the AGR is there_expl, but the INDEX is ref-ind.  
; So the subject of the predicative phrase must be discourse-bound.
; DPF 30-May-02 - TO DO - constrain complement to be non-temporal, to allow
; "when there" but block "when Tuesday".

subconj_prd_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT s_cat_fin_or_imp ] >,
                  VAL.COMPS < [ LOCAL [ CAT prd_cat &
                                          [ VAL.SPR < synsem_min > ],
                                        CONT.HOOK.LTOP #prdltop ] ] > ],
            CONT [ RELS <! subord_rel,
                            message,
                            prpstn_rel & [ LBL #cltop,
                                           MARG #hmarg ] !>,
                   HCONS <! qeq,
                             qeq & [ LARG #cltop ], 
                             qeq,
                             qeq & [ HARG #hmarg,
                                     LARG #prdltop ] !> ] ] ].

; DPF 14-May-02 - Cost of having this complementizer-like analysis is that
; we don't get conjoined if-clauses like "If you leave and he stays, I win"
; So why do we have this analysis?  Can't remember ...

subconj_if_synsem := basic_subconj_synsem & basic_two_arg &
  [ LOCAL [ ARG-S #comps,
            CAT [ HEAD [ TAM.MOOD #mood,
                         MOD < [ LOCAL.CAT s_cat_fin_or_imp ] > ],
                  VAL.COMPS < synsem &
                            [ LOCAL [ CAT [ HEAD prep_or_modnp & strict_type &
                                                 [ TAM.TENSE no_tense,
                                                   MOD < [ LOCAL 
                                                          intersective_mod ]>],
                                            VAL.COMPS < > ],
                                      CONT.HOOK [ LTOP #chand,
                                                  INDEX #event ] ],
                              NON-LOCAL [ SLASH 0-dlist,
                                          REL 0-dlist & [ LIST < > ],
                                          QUE 0-dlist ],
                              OPT + ] . #comps & 
                            < synsem &
                              [ LOCAL [ CAT np_cat_nom_min,
                                        CONT.HOOK.INDEX #ind,
                                        AGR #agr,
                                        CONJ cnil ],
                                NON-LOCAL.SLASH 0-dlist,
                                OPT - ],
                              synsem &
                              [ LOCAL local_min &
                                      [ CAT [ HEAD verbal & strict_type &
                                                   [ VFORM fin,
                                                     TAM.MOOD #mood ],
                                              VAL [ SUBJ < synsem &
                                                           [ LOCAL.AGR #agr ]>,
                                                    COMPS *olist* ] ],
                                        CONT.HOOK [ LTOP #chand,
                                                    INDEX #event,
                                                    XARG #ind ],
                                        KEYS.MESSAGE 0-dlist ],
                                OPT - ] > > ],
            CONT [ RELS <! subord_rel,
                            message,
                            prpstn_rel &
                            [ LBL #cmsg,
                              MARG #marg ] !>,
                   HCONS <! qeq, 
                           qeq & [ LARG #cmsg ],
                           qeq,
                           qeq & [ HARG #marg,
                                   LARG #chand ] !> ] ] ].

; DPF 25-Nov-01 - Added parent hc-to-phr
subconj_word := basic_mod_no_affix_notopkey_word & nonque & hc-to-phr &
  [ SYNSEM basic_subconj_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                                     NON-LOCAL.SLASH 0-dlist ] > ] ].
    
p_subconj_le := subconj_word &
  [ SYNSEM subconj_synsem ].

p_subconj_nocop_le := subconj_word &
  [ SYNSEM subconj_cp_nocop_synsem ].

#|
p_subconj_if_indic_le := basic_mod_no_affix_notopkey_word & nonque &
  [ SYNSEM subconj_if_synsem &
           [ LOCAL.CAT.VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAM 
                                                 ind_or_mod_subj_tam ] > ] ].

p_subconj_if_subjnct_le := basic_mod_no_affix_notopkey_word & nonque &
  [ SYNSEM subconj_if_synsem &
           [ LOCAL.CAT.VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAM 
                                                 subjnct_tam ] > ] ].
|#

; DPF 14-Oct-02 - Collapse above two, just specifying real_tense.

p_subconj_if_unspec_le := basic_mod_no_affix_notopkey_word & nonque &
  [ SYNSEM subconj_if_synsem &
           [ LOCAL.CAT.VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAM.TENSE real_tense ] >]].

p_subconj_inf_le := basic_mod_no_affix_notopkey_word & nonque &
  [ SYNSEM subconj_inf_synsem ].

p_subconj_prd_le := basic_mod_no_affix_notopkey_word & nonque &
  [ SYNSEM subconj_prd_synsem ].

p_subconj_prd_v_or_p_le := basic_mod_no_affix_notopkey_word & nonque &
  [ SYNSEM subconj_prd_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD v_or_p &
                                         [ TAM.ASPECT strict_nonprg ] ] > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Coordinating conjunctions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; HACK: For efficiency, restrict conjunctions to only coordinate phrases which 
; are saturated for COMPS.  This falsely excludes "Kim bought and sold a car".

; DPF (25-Apr-98) Removed COMPS..HEAD subst constraint, to allow 
; "your and my offices"

; DPF 8-Jun-99 - Removed hack on saturated COMPS - was blocking e.g. "between
; eleven and one p.m."

; AAC I am not at all convinced that conj_word's shouldn't 
; be non_affix_bearing and INFLECTED -, but replicate existing 
; behaviour for now

conj_word := word &
  [ INFLECTED +,
    SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD #head,
		     MC #mc,
		     VAL [ SUBJ #subj,
			   SPR #spr,
			   COMPS < synsem &
				   [ LOCAL local_min &
					   [ CAT [ HEAD #head,
						   MC #mc,
						   VAL [ SUBJ #subj,
							 SPR #spr,
							 COMPS #comps ],
                                                   HC-LEX #hclex ],
                                             CONT.HOOK.XARG #xarg,
					     AGR.DIVISIBLE #div,
					     KEYS [ KEY #key,
						    MESSAGE #msg ] ],
                                     LEX #lex,
				     OPT - ] 
				   . #comps > ],
                     HC-LEX #hclex ],
               AGR.DIVISIBLE #div,
               CONT.HOOK.XARG #xarg,
	       KEYS [ KEY #key,
		      MESSAGE #msg ] ],
       LEX #lex ] ].

; A coordinating conjunction needs to "prime" the CONJ.LBLS and
; CONJ.INDICES lists, so that the right side of a binary coordination looks
; like an iterated coordination.

conj_complex_lexent := conj_word &
  [ SYNSEM.LOCAL [ CONJ lex-conj,
		   CONT [ HOOK [ LTOP #chand,
                                 INDEX #cind ],
			  RELS <! #altkey & relation &
				 [ LBL #chand,
                                   WLINK *cons*,
				   C-ARG #cind ] !>,
			  HCONS <! !> ],
		   KEYS.ALTKEY #altkey ] ].

conj_complex_and_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _and_rel !>,
                   AGR.PNG png & [ PN 3pl* ] ] ].

conj_complex_and_both_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < both > ],
		   CONT.RELS <! _and_rel !>,
                   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_and_then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS *olist* ] ] ] >,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _and_rel !> ] ].

conj_complex_then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL.COMPS *olist* ] ] >,
		   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _and_rel !> ] ].

conj_complex_or_else_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS *olist* ] ] ] >,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _or_rel !> ] ].

conj_complex_except_that_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS *olist* ] ] ] >,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _except_that_rel !> ] ].

conj_complex_as_well_as_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _as_well_as_rel !>,
                   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_as_well_as_both_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < both > ],
                   CONT.RELS <! _as_well_as_rel !>,
                   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_but_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX event,
		   CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! _but_rel !> ] ].

conj_complex_nor_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _nor_rel !>,
                   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_nor_neither_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & 
			[ CHEAD.LEFT < neither > ],
		   CONT.RELS <! _nor_rel !>,
		   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_or_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _or_rel !> ] ].  

conj_complex_or_either_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD.LEFT < either > ],
		   CONT.RELS <! _or_rel !> ] ].

conj_complex_plus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! _plus_rel !>,
                   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_so_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX event,
		   CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! _so_conj_rel !> ] ].

conj_complex_vs_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _versus_rel !> ] ].

conj_complex_minus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! _minus_coord_rel !>,
                   AGR.PNG png & [ PN 3sg ] ] ].

conj_complex_but_not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _but_not_rel !> ] ].

conj_complex_amp_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _and_rel !>,
                   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_amp_both_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < both > ],
		   CONT.RELS <! _and_rel !>,
                   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_rather_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _rather_than_rel !> ] ].  

conj_complex_and_or_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _and_or_rel !>,
                   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD noun,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! _but_not_rel !> ] ].

conj_atomic_lexent := conj_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ CONT.HOOK.LTOP #hand,
					       CONJ cnil ],
		   CONJ atomic-conj,
		   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

conj_atomic_both_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ both ].
conj_atomic_either_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ either ].
conj_atomic_neither_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ neither ].

; two hundred and fifty
conj_and_num_le := conj_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST [ LOCAL [ CAT.HEAD intadj2-,
                                                 KEYS.ALTKEY #altkey &
                                                          [ LBL #hand ],
                                                 CONJ cnil ],
                                         MODIFIED.PERIPH + ],
		   CONJ num-conj,
		   KEYS [ KEY integer_rel,
                          ALTKEY #altkey ],
		   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].


etc_conj_le := phrase &
  [ INFLECTED +,
    POSSCL -,
    SYNSEM synsem &
     [ LOCAL [ CAT.VAL.COMPS < >,
               CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
               AGR.PNG png & [ PN 3pl ],
               CONT [ HOOK [ LTOP #chand,
                             INDEX #cind ],
                      RELS <! #altkey & relation &
                             [ LBL #chand,
                               C-ARG #cind ] !>,
                      HCONS <! !> ],
               KEYS.ALTKEY #altkey ] ] ].



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NEG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; not

; "not" requires its VP complement to be [VFORM non_fin], which is a supersort
; for all non-finite vforms except imp_vform, which is a subsort of bse; the
; other subsort of bse, bse_only, is a subsort of non_fin.  Most verbs with
; base morphology are [VFORM bse], and hence (the VPS they project) can be
; modified by "not", and they can also head imperative clauses, which require
; the head to be [VFORM imp_vform].  Only if modified by "not" will a base
; VP be unable to project an imperative clause; in contrast, "never sleep" is 
; fine as an imperative, since "never" does not further restrict its VP 
; complement leaving it [VFORM bse], which is consistent with the imperative 
; rule.  This fine distinction is due to Rob M.
; DPF 2-Feb-01 - Changed MOD..HEAD from verbal to v_or_g, to allow e.g.
; "I tried not hiring kim"

adv_not_lexent := norm_mod_nonque_no_affix_word &
  [ SYNSEM lex_synsem & 
	 [ LOCAL [ CAT [ HEAD negadv &
			      [ MOD < [ LOCAL scopal_mod &
					    [ CAT [ HEAD v_or_g & strict_type &
                                                         [ VFORM non_fin ],
                                                    VAL [ SUBJ < synsem_min >,
                                                          COMPS *olist* ],
                                                    MC na ],
                                              CONT.HOOK [ LTOP #mhand,
                                                          INDEX #vevent,
                                                          XARG #xarg ],
                                              CONJ cnil,
                                              KEYS.MESSAGE #msg ] ] > ],
                         VAL [ SUBJ < >,
			       COMPS < >,
			       SPR < > ],
                         MC na,
			 POSTHEAD - ],
		   CONT [ HOOK [ INDEX #vevent,
                                 XARG #xarg ],
			  RELS <! neg_rel & #key &
				 [ ARG1 #hand ] !>,
			  HCONS <! qeq &
				  [ HARG #hand,
				    LARG #mhand ] !> ],
		   KEYS [ KEY #key,
			  MESSAGE #msg ] ] ] ].

adv_not_le :< adv_not_lexent.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; COMPLEMENTIZERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Complementizers except for 'to' are marked [SUBJ < >] which prevents them
; from having PP modifiers.

; ERB (07-10-96) 'whether' clauses are made with the regular hcomp rule, so
; the polar_q_rel must come from 'whether' itself.  This means that whether
; can't identify its KEY with its COMPKEY.  Also, I made complementizer_word
; inherit from msg_word (see comments near that type).  This has the effect of
; making non_affix_bearing be inherited by this type, instead of the lower
; types.

; ERB (14-12-97) to_c_prop needs to be MC + for infinitival relatives
; (see notes near to and non_wh_rel_cl) so this type can't say MC -.
; There is no convenient supertype to all of the MC - ones, so I'm
; just going to put it in on each for now.

; ERB (14-12-97) Complementizer_word can't be nonmod_local because 
; to_c_nonprop is going to have a non-empty mod value.  Again, For
; now I'm scattering this constraint among the lower types as appropriate.

; ERB (13-01-98) In fact, complementizer_word can't even be MC bool,
; because to_c_nonprop has to be MC na in order to head hcomps that
; serve as modifiers, as in "a teacher to talk to Sandy".

;;; DPF 01-Mar-00 - Reconsider, now that support_rel has been eliminated.
; DPF (27-Sept-98) Made KEY be v_event_rel, since "to" needs to pass up the
; KEY.LBL of its complement, in order to get the desired semantics for e.g.
; "Kim is going to lose" where the copula's support_rel identified its LBL
; with that of its complement's KEY.
; 
; DPF (13-Jan-99) Generalized to make KEY be v_event_rel for all 
; complementizers, needed in particular to avoid treating complementizers as 
; particles, which are selected by KEY value.

complementizer_word := msg_word & 
  [ SYNSEM.LOCAL local_min &
		 [ CAT [ HEAD comp &
			      [ POSS -,
				INV - ],
			 VAL.SPR *olist* ],
		   AGR.PNG.PN 3sg*,
		   CONT.HOOK.INDEX non_expl ] ].

plain_compl_word := complementizer_word &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #subj >,
			     COMPS #comps & 
				    < [ LOCAL local_min &
					      [ KEYS.KEY #ckey,
						CONT.HOOK.INDEX #ind ],
					OPT - ], ... > ],
		   CONT.HOOK.INDEX #ind,
		   ARG-S < #subj . #comps >,
		   KEYS [ --COMPKEY #ckey ] ] ].

; These are the subject-to-object raising complementizers.  We're giving a
; funny three-constituent analysis to CPs: "that [Kim] [walks]" and "for [Kim]
; [to walk]".  One (beneficial) side effect of this is that finite and
; non-finite CPs get a uniform analysis, and we also can do real subject
; extraction without running afoul of the dreaded that-trace filter
; (Perlmutter 1971).  

; We also need another "that", one that combines with an adverbial and an
; S/Adv.  This accounts for why you get preposed modifiers with that clauses
; and not with for/to clauses, and why you don't get the that-t effect when
; you have an adverb in there.  But, that second "that" is going to have to
; bind off a SLASH value, sort of like the tough-movement cases, and that will
; have to wait for lexicalized SLASH passing.

; ERB (14-12-97) See notes at complementizer_word.

; DPF (25-Mar-00) Removed re-entrancy between --COMPKEY and KEY - not clear 
; what it was supposed to do, but it prevents WLINK from working as intended.
; AAC - killed WLINK 
; DPF 2-Apr-01 - Added PP modifier argument to COMPS, to allow for sentence-
; initial modification, as in "I knew that on Tuesday I would be early", and in
; particular for "how come when I arrive he leaves" (given that we treat this
; "how come" as a main-clause-compatible complementizer).

two_place_compl_word := complementizer_word & 
  [ SYNSEM basic_two_arg & 
	 [ LOCAL nomod_local &
	   [ ARG-S #comps,
	     CAT [ HEAD [ VFORM #vform,
                          TAM #tam & [ TENSE #tense,
                                       ASPECT #aspect,
                                       MOOD #mood ] ],
                   VAL [ SUBJ < >,
			 COMPS 
			      < synsem &
                                [ LOCAL [ CAT [ HEAD prep_or_modnp & 
                                                     strict_type &
                                                     [ TAM.TENSE no_tense,
                                                       MOD < [ LOCAL 
                                                          intersective_mod ]>],
                                                VAL.COMPS < > ],
                                          CONT.HOOK [ LTOP #chand,
                                                      INDEX #event ] ],
                                  NON-LOCAL [ SLASH 0-dlist,
                                              REL 0-dlist & [ LIST < > ],
                                              QUE 0-dlist ],
                                  OPT + ] . #comps & 
                                < synsem & [ NON-LOCAL #nloc &
                                                       [ SLASH 0-dlist ] ],
                                  [ LOCAL local_min &
					[ CAT [ HEAD verbal & strict_type &
						     [ VFORM #vform,
                                                       TAM #tam ],
						VAL [ SUBJ 
                                                       < [ NON-LOCAL #nloc ] >,
                                                      COMPS *olist* ] ],
                                          CONT.HOOK [ LTOP #chand,
                                                      INDEX #event ],
					  KEYS [ KEY #ckey,
						 MESSAGE 0-dlist ] ],
                                    OPT - ] > > ] ],
	     CONT [ HOOK [ LTOP #mhand,
                           INDEX #event & [ E [ TENSE #tense,
                                                ASPECT #aspect,
                                                MOOD #mood ] ] ],
                    RELS.LIST < #msg, ... >,
		    HCONS.LIST < qeq &
                                  [ HARG #marghand,
                                    LARG #chand ], ... > ],
	     KEYS [ --COMPKEY #ckey,
		    MESSAGE 1-dlist &
			<! #msg & [ LBL #mhand,
				    MARG #marghand ] !> ] ] ] ].

; Instead of doing raising here by identifying whole synsems, only identify
; semantic indices, as with regular raising for verbs above.  This lets us get
; "I prefer that he be here early" treating the second (VP) complement of 
; "that" as a simple base-form VP, rather than some new morphological form.

sor_compl_word := two_place_compl_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < synsem,
                                 synsem &
				 [ LOCAL [ CAT nomp_cat_min,
                                           CONT.HOOK.INDEX #ind,
                                           AGR #agr &
                                               [ DIVISIBLE strict_sort ],
                                           KEYS.MESSAGE 0-dlist,
					   CONJ cnil ],
				   OPT - ],
				 [ LOCAL [ CAT.VAL.SUBJ < synsem &
                                                          [ LOCAL.AGR #agr ] >,
                                           CONT.HOOK.XARG #ind ] ] > ].

comp_that_le := sor_compl_word & 
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin,
				TAM.MOOD #mood & ind_or_mod_subj,
                                CASE nom,
				AUX - ],
			 VAL.COMPS < synsem, 
                                     [ LOCAL.CAT np_cat_nom_min ],
				     [ LOCAL.CAT.HEAD.TAM [ TENSE real_tense,
                                                            MOOD #mood ] ] >,
                         MC - ],
                   CONT [ RELS <! relation !>,
                          HCONS <! qeq !> ],
		   KEYS [ KEY verb_aspect_rel,
                          MESSAGE 1-dlist &
                          <! prpstn_rel !> ] ] ].

;; "I prefer that he be here early"
comp_that_subj_le := sor_compl_word & 
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM bse,
				TAM.MOOD #mood & subjunctive,
				AUX - ],
			 VAL.COMPS < synsem, 
                                     [ LOCAL.CAT np_cat_nom_min ],
                                     [ LOCAL.CAT.HEAD.TAM.MOOD #mood ] >,
                         MC - ],
                   CONT [ RELS <! relation !>,
                          HCONS <! qeq !> ],
		   KEYS [ KEY verb_aspect_rel,
                          MESSAGE 1-dlist &
                              <! prpstn_rel !> ] ] ].

comp_for_le := sor_compl_word & 
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM inf,
                                AUX - ],
                         VAL.COMPS < [ LOCAL.KEYS.KEY no_rel ],
                                     [ LOCAL.CAT np_cat_acc_min ],
                                     [ NON-LOCAL.SLASH 0-dlist ] >,
                         MC - ],
                   CONT [ RELS <! relation !>,
                          HCONS <! qeq !> ],
		   KEYS [ KEY verb_aspect_rel,
                          MESSAGE 1-dlist &
                              <! prpstn_rel !> ] ] ].

comp_like_le := sor_compl_word & 
  [ SYNSEM.LOCAL 
           [ CAT [ HEAD [ VFORM fin,
                          AUX - ],
                   VAL.COMPS < synsem,
                               [ LOCAL.CAT np_cat_nom_min ],
                               [ LOCAL.CAT.HEAD.TAM.MOOD ind_or_mod_subj ] >,
                   MC - ],
             CONT [ RELS <! relation !>,
                    HCONS <! qeq !> ],
             KEYS [ KEY verb_aspect_rel,
                    MESSAGE 1-dlist &
                        <! _like_mood_rel !> ] ] ].

; ERB (13-01-98) to_compl_word says SUBJ < unexpressed >, but I don't
; how that can be, unless the analysis of raising has changed drastically.
; (With it that way, raising is broken).  So I am getting rid of it.

; ERB (19-01-98) SUBJ < unexpressed > was in there because something
; had to take care of giving that subject a SLASH value.  The solution
; we've opted for is this: the subject of to_c_prop is always PRO, and
; the subject of to_c_nonprop is always raised (that is, all
; infinitival tos except those in raising constructions are to_c_prop).
; So there is no constraint on to_compl_word, but to_c_prop says
; SUBJ < pro_ss > and to_c_nonprop says SUBJ canonical_synsem.

; ERB (03-02-98) KEY should be no_rel.  It used to be identified with
; COMPKEY, but that causes at least one problem: to was able to be the
; SPR of the, since the constrains its choice of SPR by a semantic
; constraint on the KEY.
; DPF (13-Jan-99) This problem should be solved by the above decision to
; make all complementizers have the KEY be of type v_event_rel.
; DPF 17-Sep-01 - Removed INDEX.E.TENSE no_tense, since it prevents e.g. 
; "I am going to arrive".
; DPF 14-Nov-01 - Returned to identifying KEY with --COMPKEY, in order to get
; intended constraint on --COMPKEY.E.ASPECT for e.g. "I have yet to arrive"

to_compl_word := plain_compl_word &
  [ SYNSEM basic_two_arg &
     [ LOCAL [ CAT [ HEAD [ AUX +,
                            PRD - ],
                     VAL [ SUBJ < [ LOCAL [ CONT #cont,
                                            AGR #agr ] ] >,
                           COMPS 
                              < synsem &
				[ LOCAL 
                                  [ CAT vp_bse_cat &
                                        [ VAL.SUBJ 
                                           < [ LOCAL [ CONT #cont,
                                                       AGR #agr ],
                                               NON-LOCAL
                                                     [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ],
                                    CONT.HOOK [ INDEX #ind,
                                                XARG #xarg ] ] ] > ] ],
               CONT.HOOK.XARG #xarg,
               KEYS.KEY verb_aspect_rel & [ ARG0 #ind ] ] ] ].


; ERB (14-12-97) Why is the SUBJ here specified as acc?? I'm taking it
; out because that follows now from pro_ss.

; ERB (08-01-98) Presumably that had to do with "for him/*he to sleep..."
; but that's the other to: to_c_nonprop.

; ERB (14-12-97) In order to implement infinitival relatives (I found
; a teacher to talk to Sandy, I found a teacher to talk to), I am
; making to_c_prop MC +.  The reasons for this is that the relevant
; cx (non_wh_rel_cl) needs to be able to take subjh_decl and hcomps
; headed by to_c_prop as its head-dtr, but not an extrasubj phrase.

; ERB (19-01-98) This to has to have a mod value so that it can
; head the infinitival relatives.  Something needs to be said about
; the features mentioned in nomod_local, probably, but I'm not sure
; what yet.  It also needs to be MC na so it can feed extrasubj.

basic_comp_to_prop_lexent := to_compl_word & 
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL intersective_mod &
                                            [ CAT nbar_cat ] ] >,
			 VAL [ SUBJ < pro_ss >,
			       COMPS < [ LOCAL [ CONT.HOOK.LTOP #chand,
                                                 AGR #agr ] ] > ],
			 MC na_or_-,
			 POSTHEAD + ],
		   CONT [ --TOPKEY #topkey,
			  RELS <! #topkey !>,
			  HCONS <! qeq &
				  [ HARG #marghand,
				    LARG #chand ] !> ],
                   AGR #agr,
		   KEYS.MESSAGE 1-dlist &
                       <! prpstn_rel & #topkey &
                        [ MARG #marghand ] !> ] ].

comp_to_prop_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM inf ].

comp_inf_and_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM inf_and ].

; ERB (14-12-97) This one will have a non-empty MOD value in order to
; build things like "Kim found a friend to talk to Sandy" where the
; subject of talk has to be bound to friend (unlike in "Kim found a
; friend to talk to" where we're convinced it is discourse bound.)
;
; The semantics are probably not right -- as a place holder in the
; modcont I put a appropriate_rel.  The idea is that "I found a person
; to talk to Sandy" means something like "I found a person who is willing/
; appropriate/suitable to talk to Sandy."  But I don't see how to make
; (something like) the appropriate_rel take the comlement of the to
; as an argument.  There is also the question of whether there should be
; any message associated with this.  One would think not, given that we've
; decided the relevant to is the nonprop one...
;   For now, we're not including this rel.

; ERB (13-01-98) to_compl_nonprop_word must be MC na if it is
; to head hcomps that serve as modifiers as in "a teacher to talk to Sandy".
;
; ERB (19-01-98) All infinitival relatives are now headed by
; to_c_prop.  To_c_nonprop only appears in raising constructions.
; Accordingly, it has no MOD value, and its subject is constrained
; to be canonical_synsem.  I'm not sure the latter constraint is
; actually doing any work for us, but I believe it to be true.
; It can also now inherit from nomod_local.  The MC value might
; could be changed, as well.

comp_to_nonprop_le := to_compl_word & 
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD.VFORM inf,
                         VAL [ SUBJ < canonical_synsem >,
			       COMPS < [ LOCAL local_min &
					       [ CONT.HOOK.LTOP #hand ] ] > ],
			 MC na ],
		   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ],
		   KEYS.MESSAGE 0-dlist ] ].

;;; DPF (21-Oct-98) Added types for elided "to", since we can't use the lexical
;; rule of auxiliary verbs, since we need to block the NP "the book to", which
;; would be built by that lexical rule, then by the application of subject
;; extraction, and then the infinitival relative rule.

to_compl_elided_word := msg_word &
  [ SYNSEM basic_one_arg &
	   [ LOCAL nomod_local &
		   [ CAT [ HEAD comp &
				[ VFORM inf,
				  INV -,
				  AUX +,
				  PRD - ],
			   VAL [ SUBJ #subj & 
				      < [ LOCAL.CONT.HOOK.INDEX #index,
					  NON-LOCAL.SLASH 0-dlist ] >,
				 SPR *olist*,
				 COMPS < > ],
			   MC na ],
		     CONT [ HOOK [ INDEX #event,
                                   XARG #index ],
			    RELS.LIST < ellipsis_rel & #key &
					 [ ARG0 #event,
					   ROLE #index ], ... > ],
		     ARG-S #subj,
		     KEYS.KEY #key ] ] ].

comp_to_prop_elided_le := to_compl_elided_word & 
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < pro_ss >,
		   CONT [ RELS <! ellipsis_rel &
				   [ LBL #chand ], 
				   #msg !>,
			  --TOPKEY #topkey,
			  HCONS <! qeq &
				    [ HARG #marghand,
				      LARG #chand ] !> ],
		   KEYS.MESSAGE 1-dlist &
				<! prpstn_rel & #msg & #topkey &
				     [ MARG #marghand ] !> ] ].

comp_to_nonprop_elided_le := to_compl_elided_word & topkey &
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < canonical_synsem >,
		   CONT [ RELS <! ellipsis_rel !>,
			  HCONS <! !> ],
		   KEYS.MESSAGE 0-dlist ] ].

; ERB (08-10-96) Whether was previously a que_word so that things selecting
; for questions could select by QUE values.  This is clearly a hack, and
; further, one that is no longer necessary now that we have semantic selection.
; I have split the old type whether_compl_word into two types: finite and
; nonfinite.  I have also gotten rid of the feature CMP.  
; As for the semantics, whether contributes a polar_q_rel (see notes near
; polar_q_rel in fundamentals.tdl).  Now, according to Rob, things that
; take complements with message-type semantics usually take the handle of
; those complements as the argument in their KEYs.  However, also according
; to Rob, if we did that here, it would imply that "whether Kim left every
; party" has more readings than "Kim left every party", which doesn't seem
; to be true.  Accordingly, whether will identify its handle with the
; handle of its complement, and take the complement's INDEX as the value
; of the ARG1 in the polar_q_rel.  Now, if whether further identified its
; INDEX with that one, things would be getting pretty twisty, so whether
; will have its own INDEX of type event.

; ERB (24-10-96) MESSAGE now functions like KEY as a pointer to
; a certain rel on the RELS.  Both wh and yn questions will have an
; int_rel on their RELS.  This is actually sewn into the RELS
; by the constructions.  Whether just carries it in its MESSAGE value
; so that it unifies with the right constructions.  In this way, we
; even kind of get Rob's intuition -- whether doesn't, in a sense,
; have a message, because that message isn't on its RELS.
; Anyway, all of this makes the polar_q_rel irrelevant, so I am removing
; it.  The hcomp_yn_nr construction will make sure the MARG value
; of the int_rel takes the LBL of whether's complement.   I don't
; know what to do about whether's LBL, KEY, and ARG0 now, so I am 
; leaving them unspecified.

; ERB (14-12-97) See notes at complementizer_word.

whether_compl_word := complementizer_word &
  [ SYNSEM [ LOCAL nomod_local &
		   [ CONT.RELS.LIST < #msg, ... >,
		     KEYS.MESSAGE 1-dlist &
				    <! int_rel & #msg &
				     [ PARAMS <! !> ] !> ],
	     NON-LOCAL.SLASH 0-dlist ] ].

comp_whether_if_fin_lexent := whether_compl_word & sor_compl_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin,
                                TAM.MOOD #mood & strict_sort ],
			 VAL.COMPS < synsem, 
                                     [ LOCAL.CAT np_cat_nom_min ],
                                     [ LOCAL.CAT.HEAD.TAM.MOOD #mood ] >,
                         MC - ],
                   CONT [ RELS <! relation !>,
                          HCONS <! qeq !> ],
                   KEYS.KEY verb_aspect_rel ] ].

comp_whether_fin_le := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT 
        [ HEAD.TAM.MOOD ind_or_mod_subj,
          VAL.COMPS < synsem, 
                      synsem, 
                      [ LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam ] > ] ].

comp_if_indic_le := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE acc,
                       VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAM 
                                                 ind_or_mod_subj_tam ] > ] ].

comp_if_subjnct_le := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE acc,
                       VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAM subjnct_tam ] > ] ].

; DPF 13-Mar-02 - Blocked first (optional PP) complement from being picked up
; to avoid misparse for e.g. "I need an explanation of how to return the 
; order to you"
how_compl_lexent := sor_compl_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin,
                                TAM.MOOD ind_or_mod_subj ],
                         VAL.COMPS < synsem & [ LOCAL.KEYS.KEY no_rel ], 
                                    [ LOCAL.CAT np_cat_nom_min ],
                                    [ LOCAL [ CAT.HEAD.TAM.MOOD ind_or_mod_subj
                                                                & strict_sort,
                                              CONT.HOOK [ LTOP #cltop,
                                                          INDEX #cind ] ]] > ],
                   CONT [ HOOK.INDEX #cind,
                          RELS <! message,
                                 #key & [ LBL #cltop,
                                          ARG0.E.TENSE no_tense,
                                          ARG1 #cind,
                                          ARG2 #objind ],
                                 which_rel & [ ARG0 #objind,
                                               RSTR #rhand ],
                                 #altkey &
                                 [ LBL #nhand,
                                   ARG0 #objind ] !>,
                          HCONS <! qeq, 
                                  qeq &
                                  [ HARG #rhand,
                                    LARG #nhand ] !> ],
                   KEYS [ KEY #key,
                          ALTKEY #altkey ] ] ].


; 'how come they left'
how_compl_mc_le := how_compl_lexent & whether_compl_word &
  [ SYNSEM.LOCAL.CAT.MC + ].

; 'the way how they did that'
how_compl_le := how_compl_lexent &
  [ SYNSEM [ LOCAL [ CAT.MC -,
                     CONT.RELS.LIST < #msg, ... >,
                     KEYS.MESSAGE 1-dlist & <! #msg & prpstn_rel !> ],
             NON-LOCAL.SLASH 0-dlist ] ].

; ERB (08-10-96) In the older version, I had whether_compl_word_inf 
; selecting for something that was just vp_inf_cat.  I never
; tested for this, but this probably allowed Sandy knew whether whether
; to leave, etc.  One way to get around this is for whether to
; select for something that is MESSAGE 0-dlist.  In order to do 
; this, I need to build to CPs that are no_rel, but we want this
; anyway (even though I talked Dan out of it at one point).
; DPF 09-Jan-00 - Made "whether" be MC -, not MC na, since e.g. "know"
; wants [MC -] CP complements.

comp_whether_inf_le := whether_compl_word & plain_compl_word &
  [ SYNSEM ssr_two_arg_subst &
	   [ LOCAL [ CAT [ HEAD.VFORM inf,
			   VAL.COMPS < [ LOCAL [ CAT [ HEAD comp &
							  [ VFORM inf ],
						       VAL [ COMPS *olist*,
							     SPR *olist* ] ],
						 CONT.HOOK.LTOP #chand ] ] >,
			   MC - ],
		     CONT [ HOOK.LTOP #mhand,
			    RELS <! #msg !>,
			    HCONS <! qeq &
				    [ HARG #marghand,
				      LARG #chand ] !> ],
		     KEYS [ KEY verb_aspect_rel,
                            MESSAGE 1-dlist &
                                <! #msg & [ LBL #mhand,
					    MARG #marghand ] !> ] ] ] ].
	    
s_compl_phrase_lexent := msg_word &
  [ SYNSEM [ LOCAL nomod_local &
		 [ CAT [ HEAD verb & 
			      [ INV -,
				VFORM fin ],
			 VAL [ SUBJ < >,
			       SPR *olist*,
			       COMPS < > ] ],
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #event ],
			  RELS.LIST < ellipsis_rel &
                                       [ LBL #khand,
                                         ARG0 #event ], #msg, ... >,
                          HCONS.LIST < qeq &
                                        [ HARG #marg,
                                          LARG #khand ], ... > ],
                   KEYS.MESSAGE <! message & #msg &
                                   [ LBL #hand,
                                     MARG #marg ] !>,
                   ARG-S < > ],
	     NON-LOCAL.SLASH 0-dlist ] ].

; 'so'
s_compl_phrase_le := s_compl_phrase_lexent &
  [ SYNSEM.LOCAL [ CONT [ RELS <! relation & #key, prpstn_rel !>,
                          HCONS <! qeq !> ],
                   KEYS.KEY v_event_rel & #key ] ].

s_compl_wh_phrase_le := s_compl_phrase_lexent &
  [ SYNSEM.LOCAL [ CONT [ RELS <! relation & 
                                 [ LBL #hand,
                                   ARG0 #event ],
                                 int_rel, 
                                 #key & prep_mod_rel &
                                 [ LBL #hand,
                                   ARG0.E.TENSE no_tense,
                                   ARG1 #event,
                                   ARG2 #objind,
                                   WLINK #wlink ],
                                 which_rel & [ ARG0 #objind,
                                               RSTR #rhand ],
                                 #altkey & [ LBL #nhand,
                                             ARG0 #objind,
                                             WLINK #wlink ] !>,
		       HCONS <! qeq, 
                                 qeq &
                               [ HARG #rhand,
                                 LARG #nhand ] !> ],
                   KEYS [ KEY #key,
                          ALTKEY #altkey ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Imperative words "don't" and "let's"

; ERB (05-10-97) In order to conflate hcomp_root and hcomp_nc into just one
; hcomp, root_marker_words have to identify their value for mc with that of
; their complement.  (Hcomp_root identified MC for mother and non-head
; daughter.)

root_marker_word := nonque & non_affix_bearing & nonrel & nonconj & hc-to-phr &
  [ SYNSEM synsem &
	 [ LOCAL [ CAT [ HEAD verb* & [ TAM.MOOD #mood,
					AUX -,
					INV - ],
			 VAL.COMPS < synsem &
                                     [ LOCAL local_min &
                                             [ CAT [ HEAD.TAM.MOOD #mood,
                                                     VAL.COMPS *olist* ],
                                               CTXT #ctxt ],
                                       NON-LOCAL [ SLASH 0-dlist,
                                                   QUE 0-dlist,
                                                   REL 0-dlist ] ] > ],
                   CTXT #ctxt ],
	   NON-LOCAL.SLASH 0-dlist ] ].

lex_imperative := root_marker_word &
  [ SYNSEM.LOCAL 
	   [ CAT [ HEAD.MOD < anti_synsem >,
                   VAL 
		    [ SUBJ < anti_synsem >,
                      SPR < anti_synsem >,
		      COMPS < [ LOCAL 
                                 [ CAT [ HEAD verb & [ VFORM bse_only ],
                                         VAL.SUBJ 
                                             < synsem &
                                               [ NON-LOCAL [ SLASH 0-dlist,
                                                             QUE 0-dlist,
                                                             REL 0-dlist ] ] >,
                                         MC na ],
                                   CONT.HOOK [ LTOP #khand,
                                               INDEX #ind,
                                               XARG #inst ] ],
                                OPT + ] > ],
		   MC + ],
	     AGR #inst,
	     CONT [ HOOK [ LTOP #hand,
                           INDEX #ind & [ E.TENSE present ] ],
		    RELS.LIST < #msg, 
                                 def_rel & [ RSTR #rhand,
                                             ARG0 #inst ],
				 pron_rel & 
				 [ LBL #prohand,
				   ARG0 #inst &
					  [ PRONTYPE std_pron ] ], ... >,
		    HCONS.LIST < qeq &
				  [ HARG #marg ], 
                                  qeq &
                                  [ HARG #rhand,
                                    LARG #prohand ], ... > ],
	     KEYS [ KEY no_rel & [ LBL #khand ],
		    MESSAGE 1-dlist &
			  <! imp_rel & #msg &
			     [ LBL #hand,
			       MARG #marg ] !> ] ] ].

va_lets_imp_le := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
		   AGR [ PNG png & [ PN 1pl* ],
			 PRONTYPE std_1pl ],
		   CONT [ HCONS <! [ LARG #chand ], qeq !>,
			  RELS <! relation, relation, relation !> ] ] ].

va_dont_imp_le := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CONT.HOOK.LTOP #chand,
                                             KEYS.ALTKEY non_conj_rel ] ] >,
		   AGR [ PNG png & [ PN 2per ],
			 PRONTYPE std_2 ],
		   CONT [ RELS <! relation,
				   relation,
                                   relation,
				   neg_rel &
				 [ LBL #neghand,
				   ARG1 #arg ] !>,
			  HCONS <! [ LARG #neghand ],
                                    qeq,
				    qeq &
				    [ HARG #arg,
				      LARG #chand ] !> ] ] ].

; 09-09-97  Added ARG0 and BODY attributes temporarily for VM2, since the
; whq external relation for how_about is like a quantifier, needing four args.
; Had to change the relation introduced by "how about" to '_which_rel'
; rather than '_how_about_rel' because of some property of vitADT.  Similar
; change made to the 'frag-msg' instance in syntax.tdl.
; 06-Oct-98 DPF - Changed MC value from na to +, to allow "okay, how about kim"

how_about_word := root_marker_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < >,
                         VAL [ SUBJ < >,
                               SPR < >,
                               COMPS 
                                    < [ LOCAL.CAT [ HEAD subst,
                                                    VAL [ SPR *olist*,
                                                          COMPS *olist* ]]]> ],
                         MC + ],
		   CONT [ HOOK.LTOP #ltop,
			  RELS.LIST < #msg,
                                       generic_verb_rel & 
                                       [ LBL #arghand ],
                                       relation & #key &
                                       [ LBL #rhand,
                                         ARG1 #arg ], ... >,
                          HCONS.LIST < qeq &
                                        [ HARG #cltop,
                                          LARG #rhand ],
                                        qeq &
                                        [ HARG #arg,
                                          LARG #arghand ], ... > ],
                   KEYS [ KEY #key,
                          MESSAGE 1-dlist &
				<! int_rel & #msg &
				   [ LBL #ltop,
				     MARG #cltop ] !> ] ] ].

comp_how_about_n_or_p_le := how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD n_or_p & strict_type,
                                             CONT.HOOK.INDEX #ind ],
                                     OPT - ] >,
                   CONT [ HOOK.INDEX #event & event,
                          RELS <! relation, 
                                 [ ARG0 #event,
                                   ARG2 #ind ], 
                                 relation !>,
                          HCONS <! qeq, qeq !> ] ] ].

comp_how_about_s_le := how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD verb & strict_type,
                                                   MC bool ],
                                             CONT.HOOK.LTOP #ltop ],
                                     OPT - ] >,
                   CONT [ HOOK.INDEX #event,
                          RELS <! relation, 
                                 [ ARG0 #event,
                                   ARG1 #ltop ], 
                                   relation !>,
                          HCONS <! qeq, qeq !> ] ] ].

; DPF 25-Nov-01 - Removed INDEX..TENSE no_tense since root_strict requires
; real_tense.
comp_how_about_or_why_vp_lexent := how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD verb & strict_type,
                                                   VAL.SUBJ < synsem > ],
                                             CONT.HOOK.LTOP #cltop ],
                                     OPT + ] >,
                   CONT [ HOOK.INDEX #ind & event,
                          RELS <! relation, 
                                 [ ARG0 #ind,
                                   ARG1 #mltop ], 
                                 relation,
                                 prpstn_rel & [ LBL #mltop,
                                                MARG #marg ] !>,
                          HCONS <! qeq, qeq,
                                    qeq & [ HARG #marg,
                                            LARG #cltop ] !> ] ] ].


; DPF 17-Apr-01 - Changed COMPS.FIRST..SUBJ from canonical_synsem to synsem
; since the former blocked "Why be late"

comp_how_about_vp_le := comp_how_about_or_why_vp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM prp ] > ].

comp_why_vp_le := comp_how_about_or_why_vp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM bse_only ] > ].

; Discourse-related sentential adverbs
;   (e.g. 'then, but')
; DPF 06-Oct-98 - Added MC + to MOD, to block "Kim says but sandy left"
; DPF 15-Oct-98 - Changed HEAD from adv to root-marker, to get "yes, okay"
; DPF 22-Oct-98 - Added MC + to the SYNSEM itself to block the relative clause
;   in "a programmer but he hired".
; DPF 09-Jun-99 - Added SLASH 0-dlist to MOD, to block e.g. "when yes Kim left"
; DPF 03-Oct-99 - Added SUBJ *olist* to MOD specific. - why wasn't it here 
; before?
; DPF 17-Apr-00 - Removed CONJ cnil to enable e.g. "yes and Kim left"
; DPF 22-Nov-01 - We have to make sure that disc_adv_words propagate the MC 
; feature of their modifiee, to block e.g. yes-no parse for "I would like to 
; arrive"

basic_disc_adv_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD root-marker &
		       [ PRD -,
			 MOD < [ LOCAL scopal_mod &
				       [ CAT [ VAL [ SPR *olist*,
                                                     COMPS *olist* ],
                                               MC #mc ],
                                         CONT.HOOK.INDEX #ind,
					 KEYS.MESSAGE #msg ],
				 NON-LOCAL.SLASH 0-dlist ] > ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < > ],
                  MC #mc ],
	    CONT.HOOK.INDEX event_or_index & #ind,
	    KEYS.MESSAGE #msg,
	    CONJ cnil ],
    NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

disc_adv_synsem := basic_disc_adv_synsem &
  [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD disc_adverbee & strict_type,
                                         VAL.SUBJ *olist* ] ] >,
                MC + ] ].

;; DPF 24-Oct-98 Removed [MC +] from disc_adv_word, since this runs afoul of
;; the carefully balanced constraint on head-modifier structures which requires
;; [MC na], to allow relative clauses as modifiers while preventing ordinary
;; finite clauses from being modifiers.

disc_adv_word := msg_word &
  [ SYNSEM disc_adv_synsem &
	   [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK [ LTOP #mltop,
                                                        INDEX #mindex ] ] >,
                     CONT [ HOOK [ LTOP #chand & handle,
                                   INDEX #cind ],
			    RELS <! #key & [ LBL #khand ],
				     discourse_rel &
				   [ LBL #chand,
				     C-ARG #cind,
				     L-HNDL #khand,
				     R-HNDL #mltop,
				     R-INDEX #mindex ] !>,
                            HCONS <! !> ],
                     KEYS.KEY #key & abstr_excl_rel ] ] ].

adv_disc_le :< disc_adv_word.
adv_disc_preh_le := disc_adv_word &
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ].
adv_disc_posth_le := disc_adv_word &
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

disc_adv_sat_le := disc_adv_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ < > ] > ].

; This is like really necessary
disc_adv_like_synsem := basic_disc_adv_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD subst,
                                       MC na_or_+ ] ] > ].

adv_disc_like_lexent := msg_word & topkey &
  [ SYNSEM disc_adv_like_synsem &
	   [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                        INDEX #index ] ] >,
                     CONT [ HOOK [ LTOP #ltop & handle,
                                   INDEX #index ],
			    RELS <! !>,
                            HCONS <! !> ],
		     KEYS.KEY abstr_excl_rel ] ] ].

adv_disc_like_le :< adv_disc_like_lexent.
adv_disc_like_preh_le := adv_disc_like_lexent &
 [ SYNSEM.LOCAL.CAT.POSTHEAD - ].

; General sentence or phrase particle
disc_adv_any_synsem := basic_disc_adv_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD subst ] > ].

; Tell me please if my account is closed
; DPF 13-Feb-01 - Temporarily remove #key from RELS since K2Y is unhappy
adv_disc_please_le := msg_word & topkey &
  [ SYNSEM disc_adv_any_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT.MC na_or_-,
                                                CONT.HOOK.LTOP #ltop ] ] >,
                           POSTHEAD - ],
                     CONT [ HOOK.LTOP #ltop & handle,
			    RELS <! !>,
                            HCONS <! !> ],
		     KEYS.KEY abstr_excl_rel ] ] ].


; Semantically empty particle: e.g. "-" as in "He arrived -"
adv_disc_nosem_le := msg_word & topkey &
  [ SYNSEM disc_adv_any_synsem &
	   [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
		     CONT [ HOOK.LTOP #ltop & handle,
			    RELS <! !>,
                            HCONS <! !> ],
		     KEYS.KEY no_rel ] ] ].

wh_the_hell_le := msg_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD wh_adv &
                                [ MOD < > ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ] ],
		     CONT [ RELS <! !>,
                            HCONS <! !> ],
                     KEYS.KEY wh_the_hell_rel ],
             NON-LOCAL [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Temporal nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Extend to COMPS of temporal nouns the hack blocking extraction of subjects of
; inverted auxiliaries, which exploits CASE value.
; Block N-N compound of "a two meeting" by stipulating that hour_words are
; PRD +, incompatible with requirement of compound rule.  In contrast, e.g.,
; day_of_week words are unmarked for PRD.
;
; Made CONT.HOOK.LTOP be the handle of the numbered_hour_rel rather than that of
; the implicit def_rel, since hour_words can be modified, as in "two o'clock
; on the sixteenth".  Since the PP unifies its LTOP handle with the LTOP handle
; of the phrase it modifies, that handle can't be the handle of the quantifier,
; so must be that of the numbered_hour_rel.

; DPF (18-Oct-98) - Removed PRD + from hour_word, so it can combine with its
; minute or am-pm complements and still be a prenominal adjective, as in
; "a ten thirty am meeting"

; DPF (22-Dec-98) - SYNSEM is typed phr_synsem in order to block 
; "a two meeting" while admitting "a two o'clock meeting" - this works because
; "two o'clock" combines with "meeting" using the noun-noun compound rule, 
; which requires the left member to have SYNSEM of type lex_synsem.

; DPF 10-Oct-00 - SPR.KEYS.KEY needs fixing
; DPF 13-May-01 - Added [PERIPH +] to prevent hour words from being modified
; (especially by relative clauses), and therefore added optional prd-pp 
; complement to still get e.g. "three in the morning"
; DPF 9-Oct-02 - Can't have these be phr_synsem, since that prevents them from
; undergoing the (necessary) noptcomp rule (which is constrained to lex_synsem
; dtrs in order to prevent spurious ambiguity from n-n-cmpnds).  So instead
; make it LEX - without commitment to the synsem type.
; DPF 27-Oct-02 - Changed HC-LEX from + to +* so we can get coordination of
; "two and two thirty".

abstr_hour_word := hc_word & non_affix_bearing & basic_noun_word &
  [ SYNSEM synsem &
    [ LOCAL nomod_local &
            [ STEMHEAD nstem,
              CAT [ HEAD noun* & [ POSS - ],
                    VAL [ SUBJ < >,
                          SPR < [ LOCAL local_min &
                                  [ CAT [ HEAD adv,
                                          VAL [ SPR  *olist*,
                                                COMPS *olist*,
                                                SPEC < [ LOCAL.CAT.VAL.COMPS 
                                                                  < > ] > ] ],
                                    CONT.HOOK.LTOP #nhand,
                                    KEYS.KEY degree_rel &
                                        [ DARG #pred ] ],
                                  OPT + ] >,
                          COMPS < expressed_synsem &
                                  [ LOCAL [ CAT [ HEAD intadj2,
                                                  VAL.COMPS < > ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #minute ],
                                            KEYS.KEY minute_rel ],
                                    NON-LOCAL.SLASH 0-dlist,
                                    OPT + ],
                                  expressed_synsem &
                                  [ LOCAL [ CAT.HEAD no_head,
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #ampm ],
                                            KEYS.KEY am_pm_rel ],
                                    NON-LOCAL.SLASH 0-dlist,
                                    OPT + ],
                                  expressed_synsem & 
                                  [ LOCAL [ CAT prd_cat &
                                            [ HEAD prep &
                                                   [ MOD < [ LOCAL [ CONT.HOOK
                                                           [ LTOP #nhand,
                                                             INDEX #index],
                                                                     KEYS.KEY
                                                           #key ]]>]],
                                            KEYS.KEY temp_loc_rel,
                                            CONJ cnil ],
                                    NON-LOCAL.SLASH 0-dlist ] > ],
                    HC-LEX +* ],
              CONT nom-obj &
                       [ HOOK.INDEX #index,
                         RELS.LIST < numbered_hour_rel & #key &
				      [ LBL #nhand,
					ARG0 #index,
					MIN #minute,
					AM-PM #ampm,
					PRED #pred ],
				      def_rel &
				      [ ARG0 #index,
					RSTR #rhand ], ... >,
			 HCONS <! qeq &
                                  [ HARG #rhand,
                                    LARG #nhand ] !> ],
		   AGR #index,
		   ARG-S < >,
		   KEYS.KEY #key ],
           MODIFIED notmod & [ PERIPH + ],
      LEX -* ] ].

n_hour_le := abstr_hour_word &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation !> ].

; sixish
n_approx_hour_le := abstr_hour_word &
  [ SYNSEM.LOCAL.CONT.RELS <! relation &
			         [ LBL #hand,
				   PRED #pred ],
			         relation, 
			         approx_grad_rel &
			         [ LBL #hand,
				   DARG #pred ] !> ].

n_four_digit_hour_le := hc_word & non_affix_bearing & basic_noun_word &
  [ SYNSEM phr_synsem &
    [ LOCAL nomod_local &
            [ STEMHEAD nstem,
              CAT [ HEAD noun* & [ POSS - ],
                    VAL [ SUBJ < >,
                          SPR < [ LOCAL local_min &
                                  [ CAT [ HEAD adv,
                                          VAL [ SPR  *olist*,
                                                COMPS *olist*,
                                                SPEC < [ LOCAL.CAT.VAL.COMPS 
                                                                  < > ] > ] ],
                                    CONT.HOOK.LTOP #nhand,
                                    KEYS.KEY degree_rel &
                                        [ DARG #pred ] ],
                                  OPT + ] >,
                          COMPS < expressed_synsem &
                                  [ LOCAL [ CAT.HEAD no_head,
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #ampm ],
                                            KEYS.KEY hours_am_pm_rel ],
                                    NON-LOCAL.SLASH 0-dlist,
                                    OPT + ] > ],
                    HC-LEX + ],
              CONT nom-obj &
                       [ HOOK.INDEX #index,
                         RELS <! numbered_hour_rel & #key &
                                [ LBL #nhand,
                                  ARG0 #index,
                                  AM-PM #ampm,
                                  PRED #pred ],
                                def_rel &
                                [ ARG0 #index,
                                  RSTR #rhand ] !>,
                         HCONS <! qeq &
                                  [ HARG #rhand,
                                    LARG #nhand ] !> ],
		   AGR #index,
		   ARG-S < >,
		   KEYS.KEY #key ],
           MODIFIED notmod & [ PERIPH + ] ] ].


abstr_minute_word := np_word_no_quant &
  [ SYNSEM [ LOCAL [ CAT.HEAD intadj2,
		     KEYS.KEY minute_rel &
			      [ LBL #hand,
				ARG1 #inst ],
		     CONT.HOOK [ LTOP #hand,
                                 INDEX #inst ] ],
	     MODIFIED notmod ] ].

adj_minute_lexent := abstr_minute_word &
  [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].

adj_minute_preh_le := adj_minute_lexent &
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ].

adj_minute_posth_le := adj_minute_lexent &
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

adj_approx_minute_le := abstr_minute_word &
  [ SYNSEM.LOCAL [ CAT.POSTHEAD +,
                   CONT [ HOOK.LTOP #hand,
                          RELS <! relation, approx_grad_rel &
                                 [ LBL #hand,
                                   DARG #pred ] !> ],
                   KEYS.KEY.PRED #pred ] ].

xp_am_pm_le := np_word_no_quant &
  [ SYNSEM.LOCAL [ CAT.HEAD no_head,
		   KEYS.KEY am_pm_rel,
		   CONT [ HOOK.INDEX #inst,
			  RELS <! [ ARG0 #inst ] !> ] ] ].

;; DPF 10-Oct-00 - SPR.KEYS.KEY needs fixing

n_mealtime_le := que_word & nonque & basic_noun_word &
  [ SYNSEM noun_synsem & nomod_synsem &
	 [ LOCAL [ CAT [ HEAD [ POSS -,
				PRD + ],
			 VAL [ SPR < [ LOCAL local_min &
					     [ CAT [ HEAD adv,
						     VAL [ SPR  *olist*,
							   COMPS *olist* ] ],
                                               CONT.HOOK.LTOP #nhand,
					       KEYS.KEY degree_rel &
						   [ DARG #pred ] ],
				       OPT + ] >,
			       COMPS < > ] ],
		   CONT nom-obj &
		       [ HOOK.INDEX #index,
			 RELS <! hour_rel & #key &
				  [ LBL #nhand,
				    ARG0 #index ],
				  def_rel &
				  [ ARG0 #index,
				    RSTR #rhand,
                                    PRED #pred ] !>,
			 HCONS <! qeq &
			   [ HARG #rhand,
			     LARG #nhand ] !> ],
		   ARG-S < >,
		   KEYS.KEY #key ],
	     MODIFIED notmod ] ].

month_synsem := nonpro_nomod_onearg_synsem &
  [ LOCAL [ ARG-S #comps,
            CAT [ HEAD noun*,
                  VAL [ SPR < [ LOCAL.KEYS.KEY quant_or_wh_rel,
                                OPT - ] >,
                        COMPS #comps &
                            < [ LOCAL local_min &
                                      [ CAT [ VAL [ SUBJ < >,
                                                    COMPS *olist*,
                                                    SPR *olist* ],
                                              MC na ],
                                        CONJ cnil,
                                        CONT.HOOK.INDEX #yearind ],
                                NON-LOCAL.SLASH 0-dlist ] > ] ],
            AGR #ind,
            CONT [ HOOK.INDEX #ind,
                   RELS <! #key, _of_rel & 
                                  [ LBL #hand,
                                    ARG0.E.TENSE no_tense,
                                    ARG1 #ind,
                                    ARG2 #yearind ] !>,
                   HCONS <! !> ],
            KEYS.KEY #key &
                  [ LBL #hand,
                    ARG0 #ind &
                         [ PNG png & [ PN 3sg*,
                                       GEN neut* ] ] ] ],
    MODIFIED notmod ].

; June, June 1996, June of 1996

month_no_of_year_synsem := month_synsem &
  [ LOCAL [ CAT.VAL.COMPS < expressed_synsem & 
                            [ LOCAL [ CAT nomp_cat_acc_min,
                                      AGR.DIVISIBLE strict_sort,
                                      KEYS.KEY yofc_rel ],
                              OPT - ] >,
            KEYS.KEY mofy_rel ] ].


;;n_month_le := nontopkey &
;;  [ SYNSEM month_of_year_synsem ].

n_month_year_le := nontopkey & basic_noun_word &
  [ SYNSEM month_no_of_year_synsem ].

; DPF 22-May-01 Added ALTKEY relation to block year names appearing as heads
; in n-n compounds.
n_year_le := non_affixed_np & 
  [ SYNSEM noun_nocomp_synsem &
         [ LOCAL [ CAT [ HEAD.MOD < >,
                         VAL.SPR < [ LOCAL.AGR [ PNG.PN 3sg,
                                                 DIVISIBLE - ] ] > ],
                   AGR.DIVISIBLE -,
		   CONJ cnil,
		   KEYS [ KEY yofc_rel,
                          ALTKEY quant_or_wh_rel ],
		   CONT [ HOOK.INDEX.PNG png & [ PN 3sg* ],
                          RELS <! relation !>,
                          HCONS <! !> ] ],
           MODIFIED notmod ] ].

; 'the first', 'October first', 'the first of October'
; Need to find way to block '*October first of October'
; DPF 20-Nov-99 - Added PRD + to block membership in N-N-compounds

basic_dom_synsem := common_noun_synsem & two_arg &
  [ LOCAL [ CAT.VAL.SPR < expressed_synsem &
                          [ LOCAL.KEYS.KEY quant_or_wh_rel ] >,
            CONT [ HOOK [ LTOP #hand,
                          INDEX.DIVISIBLE -* ],
		   RELS.LIST < dofm_rel &
                                [ LBL #hand,
                                  ARG0.PNG png & [ PN 3sg*,
                                                   GEN neut* ] ], ... > ] ] ].
                             
basic_dom_ord_synsem := basic_dom_synsem &
  [ LOCAL.CAT [ HEAD.PRD +,
                VAL [ SPR < [ LOCAL.KEYS.KEY abstr_def_rel ] >,
                      COMPS < [ NON-LOCAL.SLASH 0-dlist ] > ] ] ].

dom_ord_synsem := basic_dom_ord_synsem & temp_noun_ppcomp_synsem & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.KEYS [ KEY _of_rel,
                                           --COMPKEY mofy_rel ],
                              OPT + ] >,
            STEMHEAD countnstem ] ].

dom_ord_yofc_synsem := basic_dom_ord_synsem & basic_noun_npcomp_synsem &
  [ LOCAL.CAT.VAL [ SPR < [ LOCAL.KEYS.ALTKEY mofy_rel ] >,
                    COMPS < [ LOCAL.KEYS.KEY yofc_rel,
                              OPT - ] > ] ].

; DPF 31-May-02 - Changed SPR..KEY from implicit_quant_rel to def_rel, to make
; sure these dom's don't undergo the robust bare_pl_sg rule.
dom_card_synsem := basic_dom_synsem & basic_noun_npcomp_synsem & 
  [ LOCAL [ CAT [ HEAD.PRD -,
                  VAL [ SPR < [ LOCAL.KEYS [ KEY def_rel,
                                             ALTKEY mofy_rel ] ] >,
                        COMPS < [ LOCAL.KEYS.KEY yofc_rel,
                                  OPT + ] > ] ],
            KEYS.ALTKEY relation ] ].

abstr_n_day_of_month_lexent := hc_word & non_affix_bearing & basic_noun_word &
  [ SYNSEM basic_dom_synsem ].

n_day_of_month_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_ord_synsem ].

n_day_of_month_card_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_card_synsem ].

; 'Tuesday (the first (of October))', 'Tuesday (October first)'
; 'Tuesday of that week'
; DPF 31-Jul-99 - Made SYNSEM be nonpro_nomod_onearg_synsem instead of 
; nomod_basic_onearg_synsem since they can appear in noun-noun compounds,
; and also in appositive constructions.


; 'morning' of 'each morning', 'Tuesday morning'
; DPF 19-Oct-02 - Broke this up into two entries, one with empty COMPS
; that excludes "the" to block "I arrived the morning"; and the other with
; PP-of to allow "I arrived the morning of the fifth."

basic_n_day_part_lexent := que_word & basic_noun_word &
  [ SYNSEM [ LOCAL [ STEMHEAD countnstem,
                     CAT [ HEAD noun*,
			   VAL.SPR < synsem &
                                     [ LOCAL local_min &
					  [ CAT [ HEAD det,
						  VAL [ SUBJ < >,
							COMPS *olist* ] ],
                                            CONT.HOOK.INDEX #ind,
					    KEYS.KEY quant_or_wh_rel ],
                                       OPT - ] > ],
                     AGR #ind,
                     CONT [ HOOK.INDEX #ind,
			    RELS <! #key !>,
			    --TOPKEY #key,
                            HCONS <! !> ],
		     KEYS.KEY #key & day_part_rel &
			   [ ARG0 #ind ] ],
	     MODIFIED notmod ] ].

n_day_part_nocomp_lexent := basic_n_day_part_lexent &
  [ SYNSEM nonpro_nomod_onearg_synsem &
	   [ LOCAL [ ARG-S < #spr >,
                     CAT.VAL [ SPR < #spr &
                                     [ LOCAL.KEYS.ALTKEY dofw_or_poss_rel ] >,
                               COMPS < > ] ] ] ].

n_day_part_ppcomp_lexent := basic_n_day_part_lexent &
  [ SYNSEM noun_two_arg_nomod_synsem &
	   [ LOCAL [ ARG-S < #spr . #comps >,
                     CAT.VAL [ SPR < #spr >,
                               COMPS #comps &
                                 < [ LOCAL [ CAT.VAL.COMPS < >,
					     CONT.HOOK [ LTOP #nhand,
                                                         INDEX #ind ],
					     KEYS [ KEY _of_rel,
						    --COMPKEY dofm_rel ] ],
				     NON-LOCAL.SLASH 0-dlist,
                                     OPT - ] > ],
                     KEYS.KEY.LBL #nhand,
                     AGR #ind ] ] ].

n_day_part_nocomp_le := n_day_part_nocomp_lexent.

n_day_part_sg_le := n_day_part_ppcomp_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 3sg*,
                                           GEN neut* ] ].

n_day_part_pl_le := n_day_part_ppcomp_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 3pl* ] ].

n_holiday_le := basic_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL [ KEYS [ KEY holiday_rel,
                            ALTKEY basic_nom_rel ],
                     CONT.HOOK.INDEX.PNG png & [ PN 3sg* ] ],
             MODIFIED notmod ] ].

; 'Advent', 'summer', 'Christmas'
n_season_pp_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
           [ LOCAL [ KEYS [ KEY season_rel,
                            ALTKEY basic_nom_rel,
                            --COMPKEY _of_rel ],
                     CONT.HOOK.INDEX.PNG png & [ PN 3sg* ] ],
             MODIFIED notmod ] ].

n_season_np_le := noun_noninfl_word &
  [ SYNSEM mass_noun_npcomp_synsem &
           [ LOCAL [ KEYS [ KEY season_rel,
                            ALTKEY basic_nom_rel ],
                     CONT.HOOK.INDEX.PNG png & [ PN 3sg* ] ],
             MODIFIED notmod ] ].

; "the morning" etc.
; DPF 14-Oct-02 - Added ALTKEY relation to prevent these entries from 
; appearing as complements of "per", to avoid spurious ambiguity for e.g.
; "per night"

n_def_day_part_lexent := norm_no_affix_word & basic_noun_word &
  [ SYNSEM nomod_onearg_synsem &
	   [ LOCAL [ ARG-S < #spr >,
		     CAT [ HEAD noun*,
			   VAL 
			    [ SPR < synsem & #spr &
				  [ LOCAL local_min &
					  [ CAT [ HEAD det,
						  VAL [ SUBJ < >,
							COMPS *olist* ] ],
					    CONT [ HOOK.INDEX #inst,
                                                   RELS <! relation !> ],
					    KEYS.KEY abstr_def_rel ],
                                    OPT - ] >,
			      COMPS < expressed_synsem &
                                      [ LOCAL [ CAT [ HEAD prep & 
                                                        [ PRD -,
                                                          TAM.TENSE no_tense ],
                                                      VAL.COMPS < > ],
                                                CONT.HOOK [ LTOP #nhand,
                                                            INDEX #inst ],
                                                KEYS [ KEY _of_rel &
                                                           [ ARG2 #arg2 ],
                                                       --COMPKEY dofm_rel ] ],
                                        NON-LOCAL.SLASH 0-dlist ] > ],
                           POSTHEAD + ],
		     AGR #inst,
                     CONT [ HOOK.INDEX #inst,
			    RELS <! #key !> ],
		     KEYS [ KEY def_day_part_rel & #key &
                                [ LBL #nhand,
                                  ARG0 #inst,
                                  ARG1 #arg2 ],
                            ALTKEY relation ] ],
             MODIFIED notmod ] ].

n_def_day_part_sg_le := n_def_day_part_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0 [ PNG png & [ PN 3sg*,
                                             GEN neut* ],
                                 DIVISIBLE - ] ].

n_def_day_part_pl_le := n_def_day_part_lexent &
  [ SYNSEM.LOCAL.KEYS.KEY.ARG0.PNG png & [ PN 3pl* ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Degree specifiers for adjectives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 'very, really, much, a lot, almost';
; Treated as measure phrases, selected as specifiers by adjectives.

;; DPF 10-Oct-00 - SPR.KEYS.KEY and SPEC.KEYS.KEY need fixing
;; DPF 27-Aug-01 - Removed INDEX ref-ind constraint, which was blocking
;; e.g. "kim is just behind the door"
;; DPF 8-Sep-01 - Added MODIFIED.PERIPH na to make sure that "about two weeks"
;; has this value, to block its appearing as head in in n_n_compounds.
;; DPF 25-Sep-01 - Block specification of conjoined phrase for now, since we
;; don't know what to do with the semantics anyway.

basic_degree_spec_synsem := canonical_synsem &
  [ LOCAL nomod_local &
          [ CAT [ HEAD adv_or_partn,
                  VAL [ SUBJ < >,
                        SPR < [ LOCAL local_min &
                                      [ CAT [ HEAD adv,
                                              VAL.SPR *olist* ],
                                        KEYS.KEY degree_rel &
                                            [ LBL #khand,
                                              DARG #pred ] ],
                                NON-LOCAL.QUE 0-dlist,
                                OPT + ] >,
                        SPEC < [ LOCAL [ KEYS.ALTKEY non_conj_rel,
                                         CONT.HOOK #hook ] ] > ]],
            CONT.HOOK #hook,
            KEYS.KEY degree_rel &
                     [ LBL #khand,
                       PRED #pred ] ] ].

degree_spec_synsem := basic_degree_spec_synsem &
  [ LOCAL [ CAT.VAL [ COMPS < >,
                      SPEC < [ LOCAL.KEYS.KEY.LBL #hand ] > ],
            KEYS.KEY.LBL #hand ] ].

; DPF 11-Feb-02 - Can't have this be POSTHEAD - (and why did we want it?), 
; since the spec-head rule takes the value of POSTHEAD from the head's spr
; value, which blocked "kim arrives really soon".
basic_lex_degree_spec_synsem := basic_degree_spec_synsem & lex_synsem &
  [ LOCAL.CAT [ HEAD adv,
                VAL.COMPS < > ],
    MODIFIED.PERIPH na ].

lex_degree_spec_synsem := degree_spec_synsem & basic_leX_degree_spec_synsem.

; For measure_nps as in "two foot tall"
; DPF 4-Nov-02 - Removed [ LOCAL.CONT.HOOK.XARG nothing ], since now identify
; XARGs of modifier and modifiee.  Why was it added before?

phr_degree_spec_synsem := degree_spec_synsem & phr_synsem.

; For "as" of "as soon as possible"
eq_degree_spec_synsem := basic_degree_spec_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD adv,
                  VAL [ SPEC < [ LOCAL [ CAT.HEAD adverbee,
                                         CONT.HOOK.INDEX #adjind,
                                         KEYS.KEY.LBL #hand ] ] >,
                        COMPS < [ LOCAL [ CAT [ HEAD prep,
                                                VAL.COMPS *olist* ],
                                          KEYS.KEY _as_comp_rel &
                                                        [ ARG2 #cind ] ] ] >]],
            KEYS.KEY eq_degree_rel & [ LBL #hand,
                                       ARG1 #adjind,
                                       ARG2 #cind ] ] ].

basic_degree_spec_word := que_word &
  [ SYNSEM basic_lex_degree_spec_synsem &
           [ LOCAL [ KEYS.KEY #key,
                     CONT.RELS.LIST < #key, ... > ] ] ].

degree_spec_word := basic_degree_spec_word & nonque &
  [ SYNSEM lex_degree_spec_synsem &
           [ LOCAL.CONT [ RELS <! degree_rel !>,
                          HCONS <! !> ] ] ].

adv_degree_spec_le :< degree_spec_word.

; 'all'
adv_degree_spec_div_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.DIVISIBLE + ].

; 'under'
adv_degree_spec_int_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.KEYS.KEY integer_rel ] > ].

adv_degree_spec_noprep_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD adverbee & strict_type ] > ]. 

; 'any' - want to block e.g. phrase "a lapltop any" in "have a lapltop any more"
adv_degree_spec_nospec_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.KEYS.KEY no_rel ] > ]. 

; 'this/that tall'
; DPF 25-Nov-01 - Added ALTKEY this_that_rel to allow partitive "how much"
; while blocking the other partitives.
; DPF 9-May-02 - Changed SPEC..HEAD from adverbee to a_or_p_or_adv to allow
; "this quickly" (and since we don't want verbs anyway as specs of "this").

adv_degree_spec_noprep_this_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL [ CAT.HEAD a_or_p_or_adv & strict_type,
                                          KEYS [ KEY this_that_rel,
                                                 ALTKEY this_that_rel ] ]] > ].

; "how tall"
adv_wh_degree_spec_le := basic_degree_spec_word &
  [ SYNSEM [ LOCAL.CONT [ RELS <! abstr_deg_rel &
				 [ LBL #hand,
                                   ARG0 #arg0 ],
			         which_rel &
			         [ ARG0 #arg0,
				   RSTR #hand ] !>,
			  HCONS <! !> ],
	     NON-LOCAL.QUE 1-dlist & [ LIST < handle > ] ] ].

eq_degree_spec_le := que_word &
  [ SYNSEM eq_degree_spec_synsem &
           [ LOCAL [ KEYS.KEY #key,
                     CONT [ RELS <! #key !>,
                            HCONS <! !> ] ] ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Numbers
;;
;; DPF 14-Apr-01 - Numerals combine with their complements and specifiers as
;; laid out in Smith 2000, but since the specifier-head rule makes the TOP
;; handle of the phrase be that of the spr dtr, we can't have numerals simply
;; identify their LTOP value with their KEY.LBL value or something similar.
;; Hence, numerals combine using the LBL of the attribute ALTKEY, which
;; points to the KEY for simple numerals like "two", but to the plus_rel or
;; the times_rel for more interesting numerals like "hundred".  
;;   The LTOP handle is identified with the SPEC's handle, so when a numeral is
;; built using the specifier-head rule, the resulting LTOP handle will be the 
;; same as the LTOP handle of the head-dtr.  This is useful because of two other
;; regularities:
;;   (1) the MOD's handle is identified with the ALTKEY's handle; and
;;   (2) the intersective modifier-head rule identifies the MOD's handle with
;;       the modifier's LTOP handle.
;; This ensures that the LTOP handle of a numeral modifier will be identified
;; with the ALTKEY's handle, as desired.

; For numerals
num_synsem := basic_zero_arg &
  [ LOCAL [ CAT.VAL.SUBJ < >,
	    CONT.RELS.LIST < integer_rel, ... > ] ].

int_adj_synsem := canonical_synsem &
  [ LOCAL [ CAT [ HEAD intadj,
                  HC-LEX +,
                  VAL.SUBJ < >,
		  POSTHEAD - ],
	    CONT.HOOK.INDEX non_expl-ind,
	    KEYS.KEY integer_rel ] ].

; DPF 6-Jun-01 - Added MODIFIED.PERIPH - to avoid unwanted reading for 
; "two hundred three chairs".
; But this blocks "two competent programmers", so make [PERIPH na].

anycard_norm_num_synsem := num_synsem & int_adj_synsem.
basic_norm_num_synsem := anycard_norm_num_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL intersective_mod &
                                     [ CAT nbar_cat,
                                       CONT.HOOK [ LTOP #mhand,
                                                   INDEX #index ],
                                       KEYS.KEY nonpro_rel,
                                       CONJ cnil,
                                       AGR #index ],
                               MODIFIED.PERIPH na ] >,
                  VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #ltop ] > ],
            CONT.HOOK [ LTOP #ltop,
                        INDEX #index ],
            KEYS [ KEY.ARG1 #index,
                   ALTKEY.LBL #mhand ] ],
    MODIFIED.PERIPH + ].

norm_num_synsem := basic_norm_num_synsem & zero_arg &
  [ LOCAL [ CONT.RELS.LIST.FIRST #key,
            KEYS.KEY #key ] ].

phr_norm_num_synsem := basic_norm_num_synsem & phr_synsem &
  [ LOCAL.CONT.HCONS <! !> ].

norm_num_word := nontopkey &
  [ SYNSEM norm_num_synsem &
           [ LOCAL.CAT.HEAD.PRD - ] ].

;; some norm_card-words must remain unspecified for ORDINAL
;; DPF 10-Apr-02 - Moved MOD..DIVISIBLE +* from norm_num_word to norm_card_word
;; since ordinals don't require this: "the eleventh child"

norm_card_word := norm_num_word &
  [ SYNSEM.LOCAL [ KEYS.KEY card_rel,
                   CAT.HEAD [ PRD -,
                              MOD < [ LOCAL.AGR.DIVISIBLE +* ] > ] ] ].

;; those cardinals that take no complements may be safely specified as 
;; -ORDINAL, and as plural (since they're normal)

card_only_word := norm_card_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.ORDINAL -,
                   CONT.HOOK.INDEX.PNG png & [ PN 3pl ] ] ].

; should be POSTHEAD -
; These are adjectives only

ord_word := norm_num_word & 
  [ SYNSEM.LOCAL [ CAT [ HEAD.ORDINAL +,
			 VAL.COMPS < > ],
		   KEYS.KEY ord_rel ] ].

;;  Specifiers and modifiers will agree with heads on the value
;; of the head feature ORDINAL -- this allows propagation
;; of such a feature from complements, where (on the current account)
;; the ORDINAL feature gets a value from the lexicon.

;; distribution of ORDINAL:
;;   ordinal lex_entries are ORDINAL +
;;   complement_free lex_entries are ORDINAL -
;;   all lex_entries for "one" are ORDINAL - 
;;   other lex_entries are unspecified for ORDINAL
;; Since (the HEAD feature of) the determiner "one" is outside this 
;; hierarchy, it can't appear as a specifier or complement.


;; The sorts below refer only to lexical entries, so there's presumably no
;; harm in making conventions about the order of the RELs on their RELSs
;; No particular order is assumed for any phrase containing these entries.

;; It will be hard to do optional complements here and get the RELSs to
;; come out right.  Another problem with optional complementation is that
;; entries with complements must be -ORD, while their complement-taking
;; counterparts must be underspecified for ORD 
;;   (cf. "twenty" vs. "twenty one" vs. "twenty first")


complement_free_number := norm_num_word &
			  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

complemented_number := norm_num_word &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD.ORDINAL #ord,
		    VAL.COMPS < [ OPT -,
				  LOCAL [ CAT [ HEAD intadj & 
						    [ ORDINAL #ord ],
						VAL [ SPR *olist*,
						      COMPS < > ] ],
					  CONT.HOOK.INDEX #arg & [ PNG #num ]],
                                  NON-LOCAL.SLASH 0-dlist ] > ],
	      CONT [ HOOK.INDEX.PNG #num,
		     RELS.LIST < relation, plus_rel, ... > ],
	      KEYS.KEY.ARG1 #arg ] ] ].
		   

; Non-identity stipulated for handle of SPR and handle of CONT in order to
; prevent the regular head-spec rule (non-head-compositional) from applying.
; Need head-compositional since the handle of the phrase "two hundred" must
; be the handle of the times_rel from the head "hundred" (which contains as
; arguments the other two handles).

specified_number := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < synsem &
			       [ OPT -,
				 LOCAL [ CAT [HEAD intadj & 
						   [ ORDINAL - ],
					      VAL [ COMPS < >,
						    SPR *olist* ] ] ] ] >].
				 
;; DPF 10-Oct-00 - SPR.KEYS.KEY needs fixing

unspecified_num := norm_num_word &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL local_min &
					   [ CAT [ HEAD adv,
						   VAL [ SPR  *olist*,
							 COMPS *olist* ] ],
                                             CONT.HOOK.LTOP #khand,
					     KEYS.KEY degree_rel &
						 [ DARG #pred ] ],
				   OPT + ] >,
		   KEYS.KEY [ LBL #khand,
			      PRED #pred ] ] ].

unspecified_num_without_complements := complement_free_number & 
                                       unspecified_num &

  [ SYNSEM.LOCAL [ CONT.RELS <! const_rel !>,
                   KEYS [ KEY #key,
                          ALTKEY #key ] ] ].

approx_unspecified_num_without_complements := complement_free_number & 
                                              unspecified_num &
  [ SYNSEM.LOCAL [ CONT.RELS <! const_rel,
                                approx_grad_rel &
                                 [ DARG #pred ]  !>,
                   KEYS [ KEY #key & [ PRED #pred ],
                          ALTKEY #key ] ] ].

unspecified_num_with_complements := complemented_number & unspecified_num &
  [ SYNSEM.LOCAL 
     [ CAT.VAL.COMPS < [ LOCAL.KEYS [ KEY const_rel,
                                      ALTKEY.LBL #chandle ] ] >,
       CONT.RELS <! const_rel &
                     [ LBL #khandle,
                       ARG1 #arg ],
                     #altkey &
                     [ ARG1 #arg,
                       TERM1  #khandle,
                       TERM2  #chandle] !>,
       KEYS.ALTKEY #altkey ] ].

specified_num_without_complements := complement_free_number & 
                                     specified_number &
  [ SYNSEM.LOCAL 
	[ CAT.VAL.SPR < [ LOCAL.KEYS [ KEY.ARG1 #arg,
                                       ALTKEY.LBL #shandle ] ] >,
          CONT.RELS <! const_rel & [ LBL #khandle,
                                      ARG1 #arg ],
                        times_rel & #altkey &
                        [ FACTOR1  #shandle,
                          FACTOR2  #khandle,
                          ARG1 #arg & [ PNG.PN 3pl ] ] !>,
          KEYS.ALTKEY #altkey ] ].

specified_num_with_complements := complemented_number & specified_number & 
  [ SYNSEM.LOCAL 
    [ CAT.VAL [ SPR < [ LOCAL.KEYS [ KEY.ARG1 #arg,
                                     ALTKEY.LBL #shandle ] ] >,
                COMPS < [ LOCAL.KEYS.ALTKEY.LBL #chandle ] > ],
      CONT.RELS <! [ LBL #khandle,
                      ARG1 #arg ],
                    #altkey &
		    [ TERM1  #thandle,
		      TERM2  #chandle,
                      ARG1 #arg ],
		    times_rel &
                    [ LBL #thandle,
                      FACTOR1 #shandle,
                      FACTOR2 #khandle,
                      ARG1 #arg ] !>,
      KEYS.ALTKEY #altkey ] ].

adj_bare_unspecified_card_lexent := card_only_word & 
                                    unspecified_num_without_complements.
adj_bare_unspecified_card_one_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].
adj_bare_unspecified_card_two_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].
adj_bare_unspecified_card_three_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj3 ].
adj_bare_unspecified_card_six_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj6 ].
adj_bare_unspecified_card_nine_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj9 ].
adj_bare_unspecified_card_twelve_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj12 ].

adj_bare_specified_card_lexent := card_only_word & 
                                  specified_num_without_complements.
adj_bare_specified_card_hundred_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].
adj_bare_specified_card_dozen_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj2,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].
adj_bare_specified_card_thousand_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
adj_bare_specified_card_million_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
adj_bare_specified_card_billion_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].

adj_complemented_unspecified_card_le := norm_card_word & 
                                        unspecified_num_with_complements &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj2,
                       VAL.COMPS.FIRST.LOCAL.CAT.HEAD intadj1 ] ].


adj_complemented_specified_card_lexent := norm_card_word & 
                                          specified_num_with_complements.
adj_complemented_specified_card_hundred_le := 
                                  adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj2-,
                             COMPS.FIRST [ LOCAL.CAT.HEAD intadj2-,
                                           MODIFIED.PERIPH + ] ] ] ].
adj_complemented_specified_card_thousand_le := 
                                      adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj3- ] ] ].
adj_complemented_specified_card_million_le := 
                                     adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj6- ] ] ].
adj_complemented_specified_card_billion_le := 
                                      adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj9- ] ] ].

adj_bare_unspecified_ord_lexent := ord_word & 
                                   unspecified_num_without_complements.
adj_bare_unspecified_ord_one_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].
adj_bare_unspecified_ord_two_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].
adj_bare_unspecified_ord_three_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj3 ].
adj_bare_unspecified_ord_six_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj6 ].
adj_bare_unspecified_ord_nine_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj9 ].
adj_bare_unspecified_ord_twelve_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj12 ].

adj_bare_specified_ord_lexent := ord_word & specified_num_without_complements.
adj_bare_specified_ord_hundred_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
adj_bare_specified_ord_thousand_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
adj_bare_specified_ord_million_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj6- ] ].

adj_approx_bare_unspecified_card_le := card_only_word & 
			           approx_unspecified_num_without_complements &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].

;; the constraints appropriate for all lexical entries for "one"
;; DPF 2-Feb-01 - Removed [ SPEC..OPT - ], since blocked "the one year old b0y"
;; and it's not clear what it was for.
;; DPF 17-Nov-01 - Added PERIPH + like with other numbers.  Don't know why
;; a_one_sing and a_one_plur were marked [PERIPH -], but need PERIPH + to block
;; application of nominal modifier rules to measure_nps including "an inch"

one_num_synsem := anycard_norm_num_synsem & zero_arg &
  [ LOCAL [ CAT [ HEAD intadj & 
                       [ MOD < >,
                         ORDINAL - ],
                  VAL [ SPR < [ LOCAL local_min &
                                      [ CAT [ HEAD adv,
                                              VAL [ SPR  *olist*,
                                                    COMPS *olist* ] ],
                                        CONT.HOOK.LTOP #khand,
                                        KEYS.KEY degree_rel &
                                            [ DARG #pred ] ],
                                OPT + ] >,
                        COMPS < >,
                        SPEC < [ LOCAL.CONT.HOOK.LTOP #ltop ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #index ],
                   RELS <! card_rel & #key &
                          [ LBL #khand,
                            ARG1 #index,
                            CARG "1",
                            PRED #pred ] !> ],
            KEYS [ KEY #key,
                   ALTKEY #key ] ],
    MODIFIED.PERIPH + ].

one_word := non_affix_bearing &
  [ SYNSEM one_num_synsem ].

; DPF 29-May-02 - Made adj_one_sing_lexent be HEAD intadj1 not intadj, to
; avoid "let's meet at five one" meaning "five oh one"

adj_one_sing_lexent := one_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD intadj1,
                   CONT.HOOK.INDEX.PNG.PN 3sg* ] ].

; DPF 31-May-02 - Added PRD stipulation to distinguish "one" from "a/an" for
; e.g. partitive-num and num-noun rules.

adj_one_sing_nonprd_le := adj_one_sing_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].
adj_one_sing_prd_le := adj_one_sing_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].
; Added PRD + to prevent this from undergoing partitive_num rule
adj_one_plur_le := one_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD intadj1 & [ PRD + ],
                   CONT.HOOK.INDEX.PNG.PN 3pl* ] ].

; Temporary types to cope with unknown words - used in PET
basic_unknown_word := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTED +,
    SYNSEM.LOCAL.KEYS.KEY.Wlink *cons* ].

unknown_word := basic_unknown_word & topkey.

generic_v_np*_trans_lex_entry := unknown_word &
  [ SYNSEM np_trans_verb &
	   [ LOCAL [ CAT.VAL.COMPS < [ OPT + ] >,
		     CONT.RELS <! #key !>,
                     KEYS.KEY #key & generic_verb_rel ] ] ].

v_np*_trans_bse_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL bse_verb ].
v_np*_trans_pres3sg_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL third_sg_fin_verb ].
v_np*_trans_presn3sg_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL non_third_sg_fin_verb ].
v_np*_trans_past_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL past_or_subj_verb ].
v_np*_trans_psp_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL psp_verb ].
v_np*_trans_prp_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL prp_verb ].

generic_n_intr_lex_entry := unknown_word &
  [ SYNSEM noun_nondeverb_ppcomp_synsem & 
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.KEYS.KEY quant_or_wh_rel ] >,
                     CONT.RELS <! #key !>,
		     KEYS [ KEY #key & generic_noun_rel,
                            --COMPKEY _of_rel ] ],
             MODIFIED notmod ] ].

n_intr_sg_nale := generic_n_intr_lex_entry &
  [ SYNSEM noun_ppcomp_two_arg_synsem & [ LOCAL sing_noun ] ].

n_intr_mass_nale := generic_n_intr_lex_entry &
  [ SYNSEM mass_noun_ppcomp_synsem & [ LOCAL mass_noun ] ].

n_intr_pl_nale := generic_n_intr_lex_entry &
  [ SYNSEM mass_or_count_ppcomp_synsem & [ LOCAL plur_noun ] ].

n_proper_nale := basic_unknown_word & nonslash & nonrel & nonque &
  [ SYNSEM proper_n_synsem &
           [ LOCAL.KEYS.KEY named_abb_rel &
                            [ CARG 'noname ] ] ].

n_title_nale := unknown_word &
  [ SYNSEM title_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].

adj_intrans_nale := unknown_word &
  [ SYNSEM intrans_adj_synsem &
           [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
                     CONT [ HOOK.XARG #ind,
                            RELS <! #key !> ],
                     KEYS.KEY #key & generic_adj_rel & [ ARG1 #ind ] ] ] ].

adj_intrans_compar_nale := unknown_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
                           VAL.SPR < [ LOCAL.KEYS.KEY much_deg_rel ] > ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
                                      ARG1 #ind ],
                                  #altkey &
                                  [ LBL #hand,
                                    ARG1 #ind ] !> ],
                     KEYS.ALTKEY #altkey & comp_rel ] ] ].

adj_intrans_superl_nale := unknown_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
                           VAL.SPR < [ LOCAL.KEYS.KEY much_deg_rel ] > ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
                                      ARG1 #ind ],
                                  #altkey &
                                  [ LBL #hand,
                                    ARG1 #ind ] !> ],
                     KEYS.ALTKEY #altkey & superl_rel ] ] ].

adv_word_nale := unknown_word & nonque & nonslash & nonrel &
  [ SYNSEM intersect_adverb_synsem & 
            [ LOCAL [ CAT.HEAD adv_nonmob &
                               [ MOD < [ LOCAL.CAT.HEAD v_or_g_or_a & 
                                                        strict_type ] > ],
                      KEYS.KEY generic_adv_rel ] ] ].

; A bogus verb for handling the colon in email headers
eheader_verb_word := main_verb_mliszt_infl &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < >,
                           VAL [ SUBJ < [ LOCAL [ KEYS.KEY 
                                                        _ehkeywordersatz_rel,
                                                  CONT.HOOK.INDEX #subj ] ] >,
                                 SPR < >,
                                 COMPS < synsem &
                                         [ LOCAL.KEYS.KEY 
                                                    _ehmodifierersatz_rel &
                                                          [ LBL #hand,
                                                            ARG1 #event ] ],
                                         synsem &
                                         [ NON-LOCAL [ SLASH 0-dlist,
                                                       REL 0-dlist ] ] > ],
                           MC na ],
                     CONT [ HOOK [ LTOP #hand,
                                   XARG #subj ],
                            RELS <! #key !>,
                            HCONS <! !> ],
                     AGR.PNG.PN non3sg,
                     KEYS [ KEY _emailheaderdiv_rel & #key &
                                [ LBL #hand,
                                  ARG0 #event & 
                                         [ E [ TENSE present,
                                               ASPECT no_aspect,
                                               MOOD indicative ] ],
                                  ARG1 #subj ],
                            MESSAGE <! prpstn_rel !> ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ] ] ].

; oe believes this might be unnecessary.
eheader_verb_np_word := eheader_verb_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < synsem, 
                                   [ LOCAL [ CAT nomp_cat,
                                             CONT.HOOK.INDEX #index,
                                             KEYS.MESSAGE 0-dlist ] ] >,
                   CONT.HOOK.INDEX #index,
                   KEYS.KEY.ARGH #index ] ].
    
eheader_verb_non_np_word := eheader_verb_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < synsem,
                                   [ LOCAL.CONT.HOOK.LTOP #cltop ] >,
                   CONT.HOOK.INDEX #event,
                   KEYS.KEY [ ARG0 #event,
                              ARGH #cltop ] ] ].

eheader_verb_np_le := eheader_verb_np_word & 
  [ INFLECTED + ].

eheader_verb_non_np_le := eheader_verb_non_np_word & 
  [ INFLECTED + ].

ehmodifierersatz_le := norm_mod_no_affix_word &
  [ SYNSEM basic_int_adverb_synsem &
   [ LOCAL [ CAT [ HEAD adv &
                        [ MOD < lex_synsem &
                                [ LOCAL.KEYS.KEY _emailheaderdiv_rel &
                                                 [ LBL #hand,
                                                   ARG0 #event ] ] > ],
                   POSTHEAD +,
                   VAL.SPR < [ LOCAL.KEYS.KEY _ehmodifierersatz_rel &
                                              [ LBL #hand,
                                                ARG1 #event ] ] > ],
             CONT [ RELS <! #key !>,
                    HCONS <! !> ],
             KEYS.KEY #key & [ LBL #hand,
                               WLINK *cons*,
                               ARG1 #event ] ] ] ].

; Type for 'verbs' spelled ":"
colon_verb_word := main_verb &
  [ SYNSEM [ LOCAL [ CAT.VAL.SUBJ < expressed_synsem >,
                     KEYS.KEY _colon_v_rel ],
             NON-LOCAL non-local_none,
             MODIFIED hasmod ] ].

