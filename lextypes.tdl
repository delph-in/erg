;;; -*- Mode: tdl; coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2013
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see LICENSE for conditions
;;;
;;;  lextypes.tdl
;;;
;;;  Lexical types (i.e., word classes)
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id: lextypes.tdl 7479 2010-02-21 23:11:30Z danf $

;:message "Lexical types".

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LEXICAL DEFAULTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nonconj := word &
  [ SYNSEM [ LOCAL.CONJ cnil,
             PUNCT no_punctuation_min ] ].

nonque := word &
  [ SYNSEM.NONLOC.QUE 0-dlist ].  

nonrel := word &
  [ SYNSEM.NONLOC.REL 0-dlist ].  

nonslash := word &
  [ SYNSEM.NONLOC.SLASH 0-dlist ].

; Most words combine with their complements (if any) to produce a phrase,
; but a few, like "twenty" as in "twenty-two" and "five" as in "five o'clock",
; produce a sign which is still a word -- one with [ SYNSEM lex_synsem ].

hc-to-phr := word &
  [ SYNSEM.LOCAL.CAT.HC-LEX - ].

mcna := word &
  [ SYNSEM.LOCAL.CAT.MC na ].

non_affix_bearing := word &
  [ INFLECTD + ].

;; Relevant combinations of these seven lexical defaults

nons-m := nonslash & mcna.
noncs-m := nons-m & nonconj.
nonc-h := nonconj & hc-to-phr.
nonc-m-nab := nonconj & mcna & non_affix_bearing.
noncs-m-nab := nonc-m-nab & nonslash.
noncs-hm := noncs-m & hc-to-phr.
noncs-hm-nab := noncs-hm & noncs-m-nab.
noncrs-hm := noncs-hm & nonrel.
noncqrs-hm := noncrs-hm & nonque.
noncqrs-hm-nab := noncqrs-hm & noncs-m-nab.
nonrs := nonrel & nonslash.
nonrs-hm := nons-m & hc-to-phr & nonrs.
noncrs := nonrs & nonconj.
noncqrs := noncrs & nonque.
noncrs-nab := noncrs & non_affix_bearing.
noncqrs-nab := noncqrs & non_affix_bearing.
noncrs-m := noncs-m & noncrs.
noncqrs-m := noncrs-m & nonque.
noncrs-m-nab := noncrs-m & noncs-m-nab.
noncqrs-m-nab := noncrs-m-nab & nonque.
nonc-hm := nonconj & hc-to-phr & mcna.
noncqs := nonconj & nonque & nonslash.
noncqs-hm := noncs-hm & noncqs.
noncqs-m-nab := noncqs & noncs-m-nab.
noncqs-hm-nab := noncqs-hm & noncs-m-nab.
nonc-h-nab := nonconj & hc-to-phr & non_affix_bearing.
noncr-h-nab := nonc-h-nab & nonrel.
noncqr-h-nab := noncr-h-nab & nonque.
nonc-hm-nab := nonc-h-nab & mcna.
noncqrs-h-nab := noncqrs & nonc-h-nab.
noncr-hm-nab := noncr-h-nab & mcna.
noncrs-hm-nab := noncrs-hm & noncs-m-nab.
nonrs-nab := nonrs & non_affix_bearing.

; que_word's have all the defaults EXCEPT nonque
que_word := noncrs-hm-nab.

; For words with non-default PUNCT
non-qr-h-nab := basic_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT.HC-LEX -,
		     CONJ cnil ],
	     NONLOC [ QUE 0-dlist,
		      REL 0-dlist ] ] ].

norm_nonconj_word := nonc-hm-nab.

;;;;;
;; Non-local amalgmation types

basic_zero_arg := synsem &
  [ LOCAL.ARG-S < >,
    NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ] ].

zero_arg := basic_zero_arg & lex_synsem &
  [ LOCAL.CONT.HCONS <! !> ].

;; DPF 13-may-09 Removed identif of --SLTOP with that of ARG-S: see next.
;; DPF 2012-12-12 - In fact, we don't want the --SLTOP of the subject to be
;; bound in general (not just for the one-args, but for all arities), since
;; (1) subject gaps don't get entangled in across-the-board extraction like
;; complements and modifiers do (because we conjoin and then extract); and
;; (2) identifying the subject's --SLTOP with that of its head can lead to
;; circularity in scoping, as in sentences with both a conjoined subject and
;; a conjoined VP, such as |Kim and Lee would dance and smile|.  This is
;; because the coordination rules identify the mother's LTOP and --SLTOP,
;; and the LTOP of |Kim and Lee| is as usual identified with that of |would|,
;; but |would|'s --SLTOP is also identified with that of its complement, and
;; that complement, since it is conjoined, also identifies its own LTOP and
;; --SLTOP.  So if |would| also identified its subject's --SLTOP with its
;; own, we would get by transitivity the identity of |would|'s LTOP with
;; its complement's LTOP.
;
basic_one_arg := canonical_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH #slash,
			       REL #rel,
			       QUE #que ] ] > ],
    NONLOC [ SLASH #slash,
             REL #rel,
             QUE #que ] ].

one_arg := basic_one_arg &
  [ LOCAL.CONT.HCONS <! !> ].

basic_two_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle,
				       LAST #slast ],
			       REL [ LIST #rmiddle,
				     LAST #rlast ],
			       QUE [ LIST #qmiddle,
				     LAST #qlast ] ] ],
		    [ LOCAL.CONT.HOOK.--SLTOP #sltop,
		      NONLOC [ SLASH [ LIST #sfirst,
				       LAST #smiddle ],
			       REL [ LIST #rfirst,
				     LAST #rmiddle ],
			       QUE [ LIST #qfirst,
				     LAST #qmiddle ] ] ] >,
	    CONT.HOOK.--SLTOP #sltop ],
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ],
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

two_arg := basic_two_arg &
  [ LOCAL [ CONT [ HOOK.--SLTOP #sltop,
		   HCONS <! !> ],
	    ARG-S < [], [ LOCAL.CONT.HOOK.--SLTOP #sltop ] > ] ].

; 'Kim is worth admiring.'
;
worth_two_arg := lex_synsem &
  [ LOCAL.ARG-S < [ NONLOC [ SLASH #slash,
                             REL [ LIST #rmiddle,
                                   LAST #rlast ],
                             QUE [ LIST #qmiddle,
                                   LAST #qlast ] ] ],
                  [ LOCAL.CONT.HOOK.--SLTOP #sltop,
		    NONLOC [ REL [ LIST #rfirst,
                                   LAST #rmiddle ],
                             QUE [ LIST #qfirst,
                                   LAST #qmiddle ] ] ] >,
    LOCAL.CONT.HOOK.--SLTOP #sltop,
    NONLOC [ SLASH #slash,
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

generic_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ REL [ LIST #rmiddle2,
                                     LAST #rlast ],
                               QUE [ LIST #qmiddle2,
                                     LAST #qlast ] ] ],
                    [ NONLOC [ REL [ LIST #rfirst,
                                     LAST #rmiddle1 ],
                               QUE [ LIST #qfirst,
                                     LAST #qmiddle1 ] ] ],
                    [ NONLOC [ REL [ LIST #rmiddle1,
                                     LAST #rmiddle2 ],
                               QUE [ LIST #qmiddle1,
                                     LAST #qmiddle2 ] ] ] > ],
    NONLOC [ REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

;; DPF 2013-02-13 - Don't unify --SLTOP of second complement, since it is
;; often a scopal argument.  Push down to the few relevant (nonscope-comp) 
;; subtypes
;;
basic_three_arg := generic_three_arg &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle2,
                                   LAST #slast ] ],
                  [ LOCAL.CONT.HOOK.--SLTOP #sltop,
		    NONLOC.SLASH [ LIST #sfirst,
                                   LAST #smiddle1 ] ],
                  [ NONLOC.SLASH [ LIST #smiddle1,
                                   LAST #smiddle2 ] ] >,
    LOCAL.CONT.HOOK.--SLTOP #sltop,
    NONLOC.SLASH [ LIST #sfirst,
                   LAST #slast ] ].

three_arg := basic_three_arg &
  [ LOCAL.CONT.HCONS <! !> ].

; Don't amalgamate SLASH of last complement
tough_three_arg := generic_three_arg &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle1,
                                   LAST #slast ] ],
                  [ NONLOC.SLASH [ LIST #sfirst,
                                   LAST #smiddle1 ] ],
                  synsem >,
    NONLOC.SLASH [ LIST #sfirst,
                   LAST #slast ] ].

; Don't amalgamate REL of last complement (it-cleft, 'have X to finish')
norel_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle2,
                                       LAST #slast ],
                               REL [ LIST #rmiddle,
                                     LAST #rlast ],
                               QUE [ LIST #qmiddle2,
                                     LAST #qlast ] ] ],
                    [ LOCAL.CONT.HOOK.--SLTOP #sltop,
		      NONLOC [ SLASH [ LIST #sfirst,
                                       LAST #smiddle1 ],
                               REL [ LIST #rfirst,
                                     LAST #rmiddle ],
                               QUE [ LIST #qfirst,
                                     LAST #qmiddle1 ] ] ],
                    [ LOCAL.CONT.HOOK.--SLTOP #sltop,
		      NONLOC [ SLASH [ LIST #smiddle1,
                                       LAST #smiddle2 ],
                               QUE [ LIST #qmiddle1,
                                     LAST #qmiddle2 ] ] ] > ],
    LOCAL.CONT.HOOK.--SLTOP #sltop,
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ],
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].
four_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle3,
                                       LAST #slast ],
                               REL [ LIST #rmiddle3,
                                     LAST #rlast ],
                               QUE [ LIST #qmiddle3,
                                     LAST #qlast ] ] ],
		    [ LOCAL.CONT.HOOK.--SLTOP #sltop,
		      NONLOC [ SLASH [ LIST #sfirst,
                                       LAST #smiddle1 ],
                               REL [ LIST #rfirst,
                                     LAST #rmiddle1 ],
                               QUE [ LIST #qfirst,
                                     LAST #qmiddle1 ] ] ],
		    [ LOCAL.CONT.HOOK.--SLTOP #sltop,
		      NONLOC [ SLASH [ LIST #smiddle1,
                                       LAST #smiddle2 ],
                               REL [ LIST #rmiddle1,
                                     LAST #rmiddle2 ],
                               QUE [ LIST #qmiddle1,
                                     LAST #qmiddle2 ] ] ],
		    [ LOCAL.CONT.HOOK.--SLTOP #sltop,
		      NONLOC [ SLASH [ LIST #smiddle2,
                                       LAST #smiddle3 ],
                               REL [ LIST #rmiddle2,
                                     LAST #rmiddle3 ],
                               QUE [ LIST #qmiddle2,
                                     LAST #qmiddle3 ] ] ] > ],
    LOCAL.CONT.HOOK.--SLTOP #sltop,
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ],
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBCATEGORIZATIONS -- synsems for verbs, adjectives, prepositions, nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nomod_local := local &
  [ CAT.HEAD.MOD < > ].

nomod_synsem := lex_synsem &
  [ LOCAL.CAT [ HEAD.MOD < >,
		VAL.SUBJ < > ] ].

scopal_mod := mod_local.
intersective_mod := mod_local.

scopal_mod_local := scopal_mod & local.
int_mod_local := intersective_mod & local.

; DPF 27-May-99 - Changed [MC na] in NOMP_CAT to [MC na_or_-] to allow 
; acc-verbal-gerunds to be NP complements, even though they are built via the 
; head_subj rule.
; DPF 18-Nov-99 - Removed PRD + since this prevented e.g. "ten past five" where
; "ten" is [PRD -], and "past" requires a nomp_cat specifier.
; DPF 07-Jan-01 - We would like to capture the generalization that nominal
; phrases which have been assigned case (nominative or accusative) must also
; be [ MSG no_msg ] to block, e.g., spurious analyses for verbal gerunds
; which have been built via the subj-head rule.  But for now have to stipulate
; this for each occurrence in subcats.
; DPF 21-Mar-01 - Made COMPS for nomp_cat be < > rather than *olist* to avoid
; spurious ambiguity for partitives, as in "some arrived", since they have to
; undergo the n_optcomp pumping rule in order to be able to take a specifier
; as in "almost all arrived".
; DPF 20-Dec-01 - Added SPEC < > in nomp_cat to exclude measure-NPs.
; DPF 8-Feb-02 - But this prevents NPs from ever being specifiers (given the
; constraint on SPR..SPEC in the h-spec rule.  So remove this constraint, and
; try to remember the examples that were supposed to be excluded.
; DPF 20-May-02 - Why MOOD on nomp_cat?
; DPF 27-Oct-02 - Would like to say about all nomp's that they are 
; [DIV strict_sort], as we've already been doing (asymmetrically) for
; verbs' subjects for a while now, to avoid spurious ambiguity for e.g.
; "Fridays are inconvenient",  thus extending this to other uses of NPs.
; But AGR.DIV is not in CAT, so we can't, and we have to replicate this
; constraint everywhere, as we've already had to do for [CONJ cnil].  Maybe
; a better approach could be found, maybe with defaults?
; DPF 4-Nov-02 - Added MOD < > since we can no longer distinguish modnp guys
; (output of npadv_mod rule) by their having a non-empty SUBJ.
; DPF 7-jul-04 - Removed [ TAM.MOOD ind_or_mod_subj ] from nomp_cat, since
; it's not clear what it was supposed to do.
; DPF 27-aug-04 - Removed [PRD -] constraint, since we want "as much rice
; as possible" which is [PRD +].
; DPF 04-mar-06 - Re 4-Nov-02, removed MOD < > since some NPs (e.g. yofc) have
; non-empty MOD, and np_adv_c's have INDEX event rather than index.
; DPF 09-apr-09 - Changed HEAD from nominal to supnoun to exclude modnp.

nomp_cat_min := cat_min.

nomp_cat := nomp_cat_min & cat &
  [ HEAD supnoun &
	 [ POSS -,
           MOD < > ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS < > ],
    MC na_or_- ].

; DPF (8-Jan-99) Added accusative and nominative subtypes of nomp_cat, since 
; nominative ones are not 'mobile' - see fundamentals.tdl, and still want to
; keep _min types to reduce size of feature structures, even with CASE
; restriction.

nomp_cat_nom_min := nomp_cat_min.
nomp_cat_acc_min := nomp_cat_min.
nomp_cat_nonnom_min := nomp_cat_min.

nomp_cat_nom := nomp_cat_nom_min & nomp_cat &
  [ HEAD.CASE nom ].

nomp_cat_acc := nomp_cat_acc_min & nomp_cat &
  [ HEAD.CASE acc ].

nomp_cat_nonnom := nomp_cat_nonnom_min & nomp_cat &
  [ HEAD.CASE non_nom ].

np_cat_min := nomp_cat_min.
np_cat_nom_min := nomp_cat_nom_min & np_cat_min.
np_cat_acc_min := nomp_cat_acc_min & np_cat_min.
np_cat_nonnom_min := nomp_cat_nonnom_min & np_cat_min.

np_cat_nom := nomp_cat_nom & np_cat_nom_min &
  [ HEAD supnoun ].

np_cat_nonnom := nomp_cat_nonnom & np_cat_nonnom_min &
  [ HEAD supnoun ].

np_cat_acc := nomp_cat_acc & np_cat_acc_min & np_cat_nonnom &
  [ HEAD supnoun ].

;; DPF (30-Apr-98) In saturated phrase subcats, SUBJ must be < >, not *olist*,
;; since we need to have SUBJ < > unify with the filler in filler_head phrases,
;; and the filler is constrained to be SUBJ *prolist* which has a distinct 
;; synsem type (pro_ss) which is constrained to be [OPT -].
;; DPF 27-May-99 - Having eliminated the need for *prolist* to be OPT -, we
;; can now make saturated phrases require SUBJ to be *olist* rather than < >, 
;; which means verbal gerunds can have an optional SUBJ but still themselves 
;; be subjects or complements.
;; DPF (28-Jul-98) Added MOD < > to exclude non-finite relative clauses, which
;; are otherwise not distinguishable from nomp's.  Maybe also needed to 
;; exclude the second (modifier) entries for temporal NPs like "Tuesday".
;; DPF 09-Jun-99 - Removed MOD < > (see above), since relative clauses are now
;; all marked with non-empty REL, and because this constraint was falsely 
;; blocking "one to three pm" as an NP complement, because it has a 
;; non-empty MOD.

s_cat_unspec := cat &
  [ HEAD verbal,
    VAL [ SUBJ *olist*,
	  COMPS < > ] ].

;; DPF 2013-02-11 - Constrain MC to bool, in order to exclude relative
;; clauses, as in ecoc:2065708
;;
basic_s_cat_v_c := s_cat_unspec &
  [ VAL.SPR *olist*,
    MC bool ].

s_cat_v_c := basic_s_cat_v_c &
  [ HEAD.INV -,
    VAL.SUBJ *olist*,
    MC - ].

s_cat_fin_or_inf_unspec := s_cat_unspec &
  [ HEAD.VFORM fin_or_inf ].

s_cat_fin_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD [ VFORM fin,
           TAM indic_tam ] ].

s_cat_inf_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD.VFORM inf ].

basic_s_cat_fin_or_inf_v_c := basic_s_cat_v_c & s_cat_fin_or_inf_unspec.

s_cat_fin_or_inf_v_c := basic_s_cat_fin_or_inf_v_c & s_cat_v_c.

s_cat_fin_v_c := s_cat_v_c & s_cat_fin_unspec.

s_cat_inf_v_c := s_cat_v_c & s_cat_inf_unspec.

; Removed HEAD comp, to allow "I demand he be here"
s_cat_bse := s_cat_v_c &
  [ HEAD [ VFORM bse,
	   TAM.TENSE real_tense ] ].

s_cat := s_cat_unspec &
  [ HEAD verb & [ TAM.TENSE real_tense ] ].

s_cat_fin := s_cat & s_cat_fin_unspec &
  [ HEAD.INV - ].

; DPF 17-Jul-03 - Removed MC + since blocked e.g. "I assume you stayed to chat"
s_cat_fin_or_imp := s_cat &
  [ HEAD.VFORM fin_or_imp,
    MC bool ].

n_or_v_cat_min := cat_min.
n_or_v_cat := n_or_v_cat_min & cat &
  [ HEAD nominal_or_verbal,
    VAL.COMPS < > ].

vp_cat := n_or_v_cat &
  [ HEAD verbal &
	 [ INV -,
           MOD *anti_list* ],
    VAL.SUBJ < synsem_min & [ NONLOC [ SLASH 0-dlist,
                                       REL 0-dlist,
                                       QUE 0-dlist ] ] >,
    MC na ].

vp_inf_cat := vp_cat &
  [ HEAD [ VFORM inf,
	   PRD - ],
    VAL.SUBJ < synsem > ].

vp_bse_unspec_cat := vp_cat &
  [ HEAD verb &
	 [ VFORM bse_only,
	   PRD - ] ].

vp_prp_cat := vp_cat &
  [ HEAD.VFORM prp ].

; DPF 19-Oct-02 - Changed MOOD from indicative to indicative* to
; allow coord of "I will stay so you should leave"
vp_bse_cat := vp_bse_unspec_cat &
  [ HEAD.TAM [ MOOD indicative,
               TENSE no_tense ] ].

s_or_vp_inf_cat := cat &
  [ HEAD verbal &
         [ VFORM inf,
           MOD *anti_list* ],
    VAL [ COMPS < > ],
    MC - ].

; DPF 10-Jun-99 - Removed MOD < > (cf note in templates.tdl)
; DPF 11-Jul-99 - Added restriction that SPR be [HEAD det] to prevent 
; adjectives from modifying partitives and odd nouns like hour_prep words.
; DPF 28-Aug-99 - Removed SPR: OPT - to allow relative clauses to modify
; generic-pro's like "anything" and still have the result look like an NP.
; DPF 10-May-01 - Removed [SPR..HEAD det] to allow modifiers of generic_pro
; entries as in "everyone important to me"
; DPF 2-Nov-01 - Added SPR < synsem > to exclude "happy here" with n_adv "here"
; DPF 03-may-04 - Consider adding SPEC < anti_synsem_min > to nbar_cat, so 
; these aren't tempted to unify with measure_nps.

nbar_cat_min := n_or_v_cat_min.

basic_nbar_cat := n_or_v_cat &
  [ HEAD noun_or_nomger_or_nadj &
	 [ POSS - ],
    VAL [ SUBJ < >,
          SPR < synsem_min, ... >,
          COMPS < > ],
    MC na ].

; DPF 18-mar-09 - Restricted SPR to quant_rel, to avoid spurious ambiguity
; since bare NPs otherwise act like nbars.

nbar_cat := nbar_cat_min & basic_nbar_cat &
  [ HEAD noun_or_nomger,
    VAL.SPR < synsem & [ --MIN quant_rel ], ... > ].

adverbee_cat := cat &
  [ HEAD adverbee ].

; DPF 4-Nov-02 - Added MOD < synsem_min > to block NPs, now that we don't have
; presence of SUBJ synsem on all predicative phrases.
; DPF 24-Jun-03 - Removed MOD, since verbs now MOD empty.  Instead, use
; HEAD v_or_a_or_p to exclude NPs.
; DPF 12-oct-05 - Can't constrain MOD to synsem, to exclude e.g. adj "a":
; "*find it a", since verbs have non-empty MOD constrained to anti_synsem.
; So instead constrain semantics of this "a".

prd_or_adv_cat := cat &
  [ HEAD non_noun_or_adv &
         [ PRD +,
           MOD < [ LOCAL intersective_mod ] >,
           TAM.TENSE tense ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS < > ],
    MC na ].

basic_prd_cat := prd_or_adv_cat &
  [ HEAD v_or_a_or_p ].

; DPF 18-oct-03 - Restricted prd_cat to phrases which can modify nouns, in 
; order to avoid spurious ambiguity for e.g. prepositions that are lexically
; split between noun-modifying and verb-modifying, as "make the check to Kim".
; DPF 01-sept-06 - Added SPR *cons* to block infinitival relatives as
; ordinary prd_cats, to block spurious analysis for e.g. "Kim turned out to
; be tall", while still allowing such relatives to appear as complements of
; the copula 'be' as in "Kim is to be elected."
; DPF 27-sept-06 - Re 01-sept-06: But this prevents "Kim got very tall", so
; instead require AUX -, which still blocks infinitival relatives.

prd_cat := basic_prd_cat &
  [ HEAD [ MOD < [ LOCAL.CAT.HEAD basic_noun ] >,
           AUX -,
           TAM.TENSE untensed ] ].

basic_pp_cat := cat &
  [ HEAD prep_or_modnp,
    VAL [ SPR *olist*,
          COMPS < > ],
    MC na ].

; Only for complements of verbs, to avoid spurious ambiguity (e.g with 'into')
pp_cat := basic_pp_cat &
  [ HEAD [ MOD < [ LOCAL.CAT.HEAD verb ] >,
           PRD + ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Linking Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Linking types specify the relationship between valence positions and 
;; semantic roles.

linking_type := lex_synsem.

atrans_lt := linking_type &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN no_role_rel,
                  VAL.SUBJ < [ --SIND it-ind & #subjind ] > ],
            CONT.HOOK.XARG #subjind ],
    LKEYS.--+ARGIND it-ind ].

arg1_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ --MIN nom_or_mnp_rel,
                             --SIND #subjind & basic_non_expl,
			     LOCAL.CONT.HOOK.LTOP #ltop ] >,
            CONT.HOOK [ LTOP #ltop,
			XARG #subjind ] ],
    LKEYS.KEYREL arg1_relation & [ ARG1 #subjind ] ].

; DPF 12-Mar-03 - As per agreement with AAC, changed treatment of unaccusatives
; so they introduce an ARG1, not an ARG2 - they are to be related to their
; causative alternation (if any) via lexical rule which introduces an 
; additional cause_rel.
; unacc_lt := arg1_subj_lt.

basic_arg12_lt := arg1_subj_lt & 
  [ LOCAL.CAT.VAL.COMPS 
            < [ --SIND #objind & basic_non_expl ], ... >,
    LKEYS.KEYREL arg12_relation & [ ARG1 non_expl-ind,
				    ARG2 #objind ] ].

arg12_lt := basic_arg12_lt &
  [ LOCAL.CAT.VAL.COMPS 
            < [ LOCAL.CONT.HOOK.LTOP #lbl ], ... >,
    LKEYS.KEYREL.LBL #lbl ].

trans_lt := arg12_lt &
  [ LKEYS.KEYREL.ARG2 basic_non_expl ].

arg12h_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], ... >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel &
	         [ ARG1 non_expl-ind,
		   ARG2 handle & #mhand ] ].

; Maybe only for main verb "have" and for possessive "got"

poss_lt := linking_type &         
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						 INDEX #subjind & 
						    non_expl-ind ] ] >,
		      COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #objind & 
						    non_expl-ind ] 
						], ... > ],
            CONT [ HOOK [ INDEX #arg0,
                          XARG #subjind ],
                   RELS <! arg12_relation & 
                         [ LBL #lbl,
			   ARG0 #arg0,
                           ARG1 #subjind,
                           ARG2 #objind ] !> ] ] ].

expl_obj_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND it-ind ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS [ KEYREL #keyrel & [ ARG1 non_expl-ind ],
	    --+ARGIND it-ind ] ].

; 'prefer it if ...'
; 'make it clear that ...'
expl_obj_cp_lt := expl_obj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    [ LOCAL.CONT.HOOK.LTOP #vhand ],
			    ... >,
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL arg12_relation & [ ARG2 handle & #mhand ] ].

expl_obj_prdp_lt := expl_obj_lt & basic_control_expr_lt &
  [ LOCAL.CAT.VAL [ COMPS < [ --SIND #objind ], 
                            #keycomp &
                            [ LOCAL.CONT.HOOK.XARG #objind ],
                            ... >,
                    KCMP #keycomp ],
    LKEYS.KEYREL arg12_relation ].

particle_cp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], ... >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ ARG1 non_expl-ind,
					      ARG2 handle & #mhand ] ].

particle_pp_cp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ --MIN selected_rel,
			      --SIND #cind & basic_non_expl ],
                            [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], ... >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ ARG1 non_expl-ind,
					      ARG2 #cind,
					      ARG3 handle & #mhand ] ].

particle_oeq_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < synsem,
                              [ --SIND #index & non_expl-ind ],
			      #comp &
			      [ LOCAL.CONT.HOOK [ LTOP #chand,
						  XARG #index ] ] >,
                      KCMP #comp ],
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand, LARG #chand ] !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ ARG1 non_expl-ind,
					       ARG2 #index,
					       ARG3 handle & #mhand ] ].

; DPF 19-Oct-02 - Removed SORT entity from second COMPS, since want to
; allow "that gives me an hour"
ditrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
                  < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #obj2ind & non_expl-ind &
					     [ SORT non-time-sort ] ] ],
		    [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #objind & 
					     non_expl-ind ] ], ... > ],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG1 non_expl-ind,
				     ARG2 #objind,
                                     ARG3 #obj2ind ] ].

tritrans_lt := ditrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, *top*, 
			    [ --MIN v_event_rel,
                              LOCAL.CONT.HOOK.LTOP #chand ],
				... >,
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #chand ] !> ] ],
    LKEYS.KEYREL arg1234_relation & #keyrel & [ ARG4 handle & #mhand ] ].

basic_prep_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			< [ --MIN prep_rel,
                            LOCAL [ CAT.HEAD.TAM #tam & [ TENSE no_tense,
                                                          ASPECT no_aspect ],
                                    CONT [ HOOK [ INDEX [ E #tam,
                                                          --TPC #tpc ],
                                                  XARG #index ] ] ] ],
			  ... >,
            CONT [ HOOK.INDEX #index & [ --TPC #tpc ],
		   RELS.LIST < #keyrel, ... > ] ],
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].

prep_intrans_lt := basic_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
            CONT [ HOOK.LTOP #ltop,
                   RELS <! relation !> ] ] ].

prep_intrans_nosubj_lt := basic_prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
    LKEYS.KEYREL.LBL #ltop ].

;; DPF 14-Sept-00 - This type does not conform to our assumption that only 
;; handles, indices, and external arguments of COMPS synsems can be referred 
;; to in semantic construction.  But we believe we have a better analysis on 
;; the way which collapses these collocation constructions into a more general
;; account of multi-word expressions, so we allow the hack for now.
;; DPF 24-jun-08 - Re 14-Sept-00: Now fixed.

basic_empty_prep_intrans_lt := arg1_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
                            LOCAL [ CAT.HEAD.PRD -,
				    CONT.HOOK.LTOP #lbl ] ], ... >,
    LKEYS.KEYREL [ LBL #lbl,
		   ARG1 non_expl-ind ] ].
		   
empty_prep_intrans_lt := basic_empty_prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #objind & 
                                                  non_expl-ind ], ... >,
    LKEYS.KEYREL arg12_relation & [ ARG2 #objind ] ].

; Kim gave to worthy causes
empty_prep_intrans_arg3_lt := basic_empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #objind & 
						    non_expl-ind ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ ARG3 #objind ] ].

; Argument coercion as in "Kim suggests on Friday"
prep_intrans_event_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			 < [ --MIN prep_rel,
                             LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                    ASPECT no_aspect ],
                                     CONT.HOOK [ LTOP #ltop,
                                                 INDEX #event ] ] ], ... >,
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel & arg12_relation & [ ARG1 non_expl-ind,
					      ARG2 #event ] ].

prep_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND #objind ], 
                            [ --MIN prep_rel,
			      LOCAL [ CAT.HEAD [ MOD < synsem_min >,
                                               TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ] ],
				      CONT.HOOK [ LTOP #cltop,
						  INDEX.SF prop,
						  XARG #objind ] ] ], ... >,
            CONT [ RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #hand,
                                    LARG #cltop ] !> ] ],
    LKEYS.KEYREL #keyrel & arg123_relation & [ ARG3 handle & #hand ] ].

empty_prep_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ --MIN selected_rel,
				     LOCAL.CONT.HOOK [ LTOP #lbl,
						       INDEX #objind & 
							non_expl-ind ] ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ LBL #lbl,
					       ARG3 #objind ] ].
		   
basic_prep_particle_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ ARG1 non_expl-ind ] ].
		   
prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ --MIN independent_rel ] > ].

empty_prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ --MIN selected_rel,
                            --SIND #arg2 & non_expl-ind ] >,
    LKEYS.KEYREL.ARG2 #arg2 ].

cp_trans_lt := basic_arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
			    [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], 
			    ...>,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel &
	         [ ARG3 handle & #mhand ] ].

; "explain to Kim that ..."
pp_cp_lt := basic_empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND #index ],
			    [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ],
			    ... >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #chand,
				    LARG #vhand ] !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel &
	         [ ARG2 handle & #chand,
		   ARG3 #index ] ].

double_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN prep_rel,
                              LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #event ] ] ], 
                            [ --MIN prep_rel,
                              LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #event ] ] ], ... >,
            CONT [ HOOK [ LTOP #ltop,
			  INDEX #event ],
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel ].


double_pp_empty_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN prep_rel,
                              LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                      CONT.HOOK.LTOP #ltop ] ], 
                            [ --MIN selected_rel,
			      LOCAL.CONT.HOOK [ LTOP #ltop,
						INDEX #objind & 
						     non_expl-ind ] ], ... >,
            CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG2 #objind ] ].

arg12_double_pp_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                          [ --MIN selected_rel,
                            --SIND #ind1 & non_expl-ind ], 
                          [ --MIN selected_rel,
			    LOCAL.CONT.HOOK [ LTOP #lbl,
					      INDEX #ind2 & 
						   non_expl-ind ] ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ LBL #lbl,
			     ARG3 #ind1,
			     ARG4 #ind2 ] ].

; DPF 24-jun-08 - FIX: should make this a subtype of arg1_subj_lt ...
s_equi_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK 
					[ LTOP #lbl,
					  INDEX #index & non_expl-ind ],
			     --SIND #index ] >,
	    CONT.HOOK.XARG #index ],
    LKEYS.KEYREL arg12_relation &
	         [ LBL #lbl,
		   ARG1 #index & non_expl-ind ] ].

equi_prd_lt := linking_type & 
  [ LOCAL [ CAT.VAL.KCMP [ --MIN independent_rel,
                           --SIND #event ],
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ ARG2 #event ] ].

; ERB (14-12-97) Subj_equi verbs now require that their complement have
; a pro_ss subject.  This might be redundant if some other supertype of
; all equi verbs requires prpstn_m_rel on the complement.

; ERB (21-01-98) This pro_ss needs to be constrained to be unslashed.

subj_equi_lt := s_equi_lt &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #xarg ] >,
                    KCMP.LOCAL.CONT.HOOK.XARG #xarg ] ].

; 'try to leave'
subj_equi_inf_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT [ HOOK [ LTOP #vhand,
					     INDEX.SF basic-prop ] ],
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG2 handle & #mhand ] ].

subj_equi_prp_or_bse_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #hand,
                                           INDEX [ E.TENSE no_tense,
                                                   SF prop ] ],
            CONT [ RELS <! #keyrel !>,
                   HCONS <! qeq &
			   [ HARG #chand,
			     LARG #hand ] !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG2 handle & #chand ] ].

; 'need not'
subj_equi_bse_n3sg_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #hand,
                                           INDEX [ E.TENSE no_tense,
                                                   SF prop ] ],
            CONT [ HOOK.LTOP #ltop,
                   RELS <! #keyrel & [ LBL #vtop ],
                           #altkeyrel &
                           [ LBL #ltop,
                             ARG1 #arg ] !>,
                   HCONS <! qeq &
			   [ HARG #chand,
			     LARG #hand ],
                            qeq &
			   [ HARG #arg,
			     LARG #vtop ] !> ] ],
    LKEYS [ KEYREL #keyrel & [ ARG2 handle & #chand ],
            ALTKEYREL #altkeyrel ] ].

obj_equi_prp_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL [ KCMP.LOCAL.CONT.HOOK [ LTOP #hand,
                                             INDEX [ E.TENSE no_tense,
                                                     SF prop ] ],
                      COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #lbl,
						    INDEX #ind ] ],
            CONT [ RELS <! #keyrel !>,
                   HCONS <! qeq &
			   [ HARG #chand,
			     LARG #hand ] !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #lbl,
			     ARG2 #ind,
			     ARG3 handle & #chand ] ].

; ERB (14-12-97) comp's subj is a pro_ss.  This is probably redundant since
; the to_c_prop will say that its subject is a pro_ss.

; ERB (21-01-98) The pro_ss needs to be constrained to be unslashed.

; 'persuade Kim to leave'
obj_equi_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK 
					   [ LTOP #lbl,
					     INDEX #index & non_expl-ind ],
				--SIND #index ],
			      #comp &
			      [ LOCAL.CONT.HOOK.XARG #index ] >,
                      KCMP #comp ],
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg123_relation & #keyrel &
	         [ LBL #lbl,
		   ARG1 non_expl-ind,
		   ARG2 #index ] ].

;; DPF 27-oct-09 - Maybe collapse the following two types now?

; 'persuade Kim to leave'
obj_equi_inf_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #vhand,
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL.ARG3 handle & #mhand ].

; 'help Kim leave'
obj_equi_bse_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL [ CAT.VAL.SUBJ < unexpressed_reg >,
                                 CONT.HOOK [ LTOP #vhand,
                                             INDEX.SF prop ] ],
            CONT [ RELS <! relation !>,
                   HCONS <! qeq & [ HARG #mhand,
                                    LARG #vhand ] !> ] ],
    LKEYS.KEYREL.ARG3 handle & #mhand ].

basic_prd_comp_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind ] >,
		      KCMP.LOCAL.CONT [ HOOK.LTOP #chand ] ],
            CONT [ HOOK.XARG #subjind,
                   RELS <! #keyrel !>,
		   HCONS <! qeq & [ LARG #chand ] !> ] ],
    LKEYS.KEYREL #keyrel ].

prd_comp_lt := basic_prd_comp_lt &
  [ LOCAL.CAT.VAL.KCMP [ --MIN independent_rel,
                         --SIND.E.TENSE untensed ] ].

obj_equi_sel_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK 
					 [ LTOP #lbl,
					   INDEX #cindex & non_expl-ind ] ], 
                            [ LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #c2index &
						      non_expl-ind ] ] >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel &
	         [ LBL #lbl,
		   ARG1 non_expl-ind,
		   ARG2 #cindex,
		   ARG3 #c2index ] ].

pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					       INDEX #arg2 ] ],
			   [ LOCAL.CONT.HOOK.LTOP #chand ] >,
	   CONT [ RELS <! #keyrel !>,
		  HCONS <! qeq & [ HARG #arg3, LARG #chand ] !> ] ],
   LKEYS.KEYREL arg123_relation & #keyrel &
	        [ LBL #lbl,
		  ARG1 non_expl-ind,
		  ARG2 #arg2,
		  ARG3 handle & #arg3 ] ].

; 'consider Kim wise'

obj_equi_prd_lt := prd_comp_lt & obj_equi_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN basic_nom_or_mnp_rel,
			      LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #index ] ],
                            [ LOCAL.CONT.HOOK.XARG #index ] >,
            CONT.HCONS <! [ HARG #arghand ] !> ],
    LKEYS.KEYREL [ LBL #lbl,
		   ARG3 handle & #arghand ] ].

; 'promise Kim to leave'
anom_equi_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind ] >,
                      COMPS < [ LOCAL.CONT.HOOK 
					   [ LTOP #lbl,
					     INDEX #objind & non_expl-ind ] ],
			      [ LOCAL.CONT.HOOK [ LTOP #vhand,
						  XARG #subjind ] ] > ],
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel &
          [ LBL #lbl,
	    ARG3 handle & #mhand,
            ARG2 #objind ] ].

; 'turn out unreliable' (also resultatives like 'turned up drunk')
anom_equi_prd_lt := equi_prd_lt & s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ LOCAL.CONT.HOOK.INDEX #index ] >,
                  KCMP #comp,
		  COMPS < *top*,
			  #comp &
			  [ LOCAL.CONT.HOOK [ LTOP #vhand,
                                              XARG #index ] ] > ],
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL.ARG3 #mhand ].

; 'turn out to be red'
anom_equi_particle_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ --SIND #index ] >,
		  COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ],
                          [ LOCAL.CONT.HOOK [ LTOP #vhand,
					      XARG #index ] ] > ],
            CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #mhand,
                                    LARG #vhand ] !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG2 handle & #mhand ] ].

basic_control_expr_lt := linking_type &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #chand,
                                           INDEX.SF prop ],
	    CONT [ RELS <! #keyrel !>,
                   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ ARG2 handle & #mhand ] ].

ssr_expr_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ.FIRST.--SIND #ind,
		      COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #ppind ] ],
			      [ LOCAL.CONT.HOOK.LTOP #cltop ] > ],
            CONT [ HOOK.XARG #ind,
		   RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #arg, LARG #cltop ] !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #lbl,
			     ARG1 #ppind & non_expl,
			     ARG2 #arg ] ].

basic_seq_prdp_expr_lt := basic_control_expr_lt &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						 INDEX #subjind ],
			       --SIND #subjind ] >,
                      KCMP #comp,
                      COMPS < #comp,
                              [ --MIN #ocmin & selected_rel,
                                --SIND #arg ],
                              ... > ],
            CONT.HOOK.XARG #subjind ],
    LKEYS [ KEYREL [ LBL #lbl,
		     ARG1 #subjind,
		     ARG3 #arg & non_expl-ind ],
            --OCOMPKEY #ocmin ] ].

seq_prdp_expr_lt := basic_seq_prdp_expr_lt &
  [ LKEYS.--OCOMPKEY _to_p_sel_rel ].

sor_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK 
					  [ LTOP #lbl,
					    INDEX #index & non_expl-ind ],
			       --SIND #index ] >,
                      COMPS < [ LOCAL.CONT.HOOK.LTOP #lbl ],
                              [ LOCAL.CONT.HOOK.LTOP #chand ] > ],
            CONT [ HOOK.XARG #index,
                   RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #arg,
				    LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel &
	         [ LBL #lbl,
		   ARG1 #index,
		   ARG2 handle & #arg ] ].
sor_prop_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK 
					  [ LTOP #lbl,
					    INDEX #index & non_expl-ind ],
			       --SIND #index ] >,
                      COMPS < synsem,
                              [ LOCAL.CONT.HOOK [ LTOP #chand,
                                                  INDEX.SF prop ] ] > ],
            CONT [ HOOK.XARG #index,
                   RELS <! #keyrel !>,
                   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ LBL #lbl,
					      ARG1 #index,
					      ARG2 handle & #mhand ] ].

basic_expl_it_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                 INDEX it-ind & #subjind ] ] >,
                      KCMP.LOCAL.CONT.HOOK.LTOP #chand ],
            CONT [ HOOK.XARG #subjind,
                   HCONS.LIST < qeq & [ HARG #mhand, LARG #chand ], ... > ] ],
    LKEYS.KEYREL arg1_relation &
          [ LBL #hand,
            ARG1 handle & #mhand ] ].

expl_it_subj_lt := basic_expl_it_subj_lt &
  [ LOCAL.CONT.HCONS <! qeq !> ].

expl_it_subj_np_cp_lt := expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #arg2 ] ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg12_relation & #keyrel &
                        [ LBL #lbl,
			  ARG2 #arg2 ] ].

expl_it_subj_cp_cp_lt := basic_expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ], 
			    synsem >,
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq, qeq & [ HARG #mhand, LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ ARG2 #mhand ] ].

; take, cost
expl_it_subj_np_np_cp_or_vp_lt := expl_it_subj_np_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CONT.HOOK [ LTOP #lbl,
					      INDEX #ind ] ],
                          ... >,
    LKEYS.KEYREL arg123_relation &
                        [ LBL #lbl,
			  ARG3 #ind ] ].

; cost: "It will cost (me) ten dollars for you to come along"
expl_it_subj_np_np_cp_lt := expl_it_subj_np_np_cp_or_vp_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT.VAL.SUBJ < anti_synsem_min > ].

; cost, take: "it took me ten minutes to leave"
expl_it_subj_np_np_vp_lt := expl_it_subj_np_np_cp_or_vp_lt &
  [ LOCAL.CAT.VAL [ COMPS < [ --SIND #ind ], ... >,
                    KCMP.LOCAL.CONT.HOOK.XARG #ind ] ].

; make: "it makes him angry that S"
expl_it_subj_np_prdp_cp_lt := expl_it_subj_np_cp_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ LOCAL.CONT.HOOK.LTOP #lbl ],
			    ... >,
	    CONT.HCONS.LIST < qeq, qeq & [ HARG #harg, LARG #lbl ], ... > ],
    LKEYS.KEYREL arg123_relation &
	         [ ARG3 #harg ] ].

expl_it_subj_pp_cp_lt := expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #arg ] ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg12_relation & #keyrel &
                        [ LBL #lbl,
			  ARG2 #arg & non_expl-ind ] ].

expl_it_subj_prtcl_cp_lt := expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, synsem >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg1_relation & #keyrel ].

; 'It follows that ..."
expl_it_subj_cp_lt := expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg1_relation & #keyrel ].

expl_pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL [ COMPS < [ --SIND it-ind ],
                             [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                 INDEX #arg ] ],
			       [ LOCAL.CONT.HOOK.LTOP #chand ] > ],
	   CONT [ HOOK.LTOP #ltop,
		  RELS <! #keyrel !>,
		  HCONS <! qeq & [ HARG #mhand, LARG #chand ] !> ] ],
   LKEYS [ KEYREL arg123_relation & #keyrel &
		  [ ARG1 non_expl-ind,
		    ARG2 #arg,
		    ARG3 handle & #mhand ],
           --+ARGIND it-ind ] ].

; 'leave it to Kim to find the answer'

expl_pp_inf_oeq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL.COMPS < *top*,
			 [ LOCAL.CONT.HOOK.INDEX #arg ],
			 [ LOCAL.CONT.HOOK.XARG #arg ] > ].

; 'arrange with Kim to meet her'

pp_inf_seq_lt := pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #arg1 ] >,
		   COMPS < *top*,
			   [ LOCAL.CONT.HOOK.XARG #arg1 ] > ] ].

; 'arrange it with Kim to meet her'
;
expl_pp_inf_seq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #arg1 ] >,
		   COMPS < *top*,
			   *top*,
			   [ LOCAL.CONT.HOOK.XARG #arg1 ] > ] ].

; suffice
atrans_inf_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ.FIRST.--SIND #sind & it-ind,
		      COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] > ],
	    CONT [ HOOK.XARG #sind,
		   RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ] ],
    LKEYS [ KEYREL arg12_relation & #keyrel & [ ARG2 handle & #arg ],
	    --+ARGIND it-ind ] ].

particle_NP_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN selected_rel ],
                            [ LOCAL.CONT.HOOK 
				    [ LTOP #lbl,
				      INDEX #index & non_expl-ind ] ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ LBL #lbl,
					      ARG1 non_expl-ind,
					      ARG2 #index ] ].

NP_particle_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK
                                         [ LTOP #ltop,
					   INDEX #index & non_expl-ind ] ], 
			    synsem, ... >,
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ LBL #ltop,
					      ARG1 non_expl-ind,
					      ARG2 #index ] ].

np_particle_pp_lt := np_particle_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            synsem,
                            synsem &
                            [ --MIN selected_rel,
			      LOCAL.CONT.HOOK 
				    [ LTOP #lbl,
				      INDEX #objind & non_expl-ind ] ], ... >],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG3 #objind ] ].

np_particle_np_lt := np_particle_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          synsem,
                          synsem &
                          [ LOCAL.CONT.HOOK 
				    [ LTOP #lbl,
				      INDEX #objind & non_expl-ind ] ], ... >,
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG3 #objind ] ].
		   
np_particle_cp_lt := np_particle_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            synsem,
                            synsem &
                            [ LOCAL.CONT.HOOK.LTOP #cltop ], ... >,
	    CONT.HCONS <! qeq & [ HARG #arg3,
				  LARG #cltop ] !> ],
    LKEYS.KEYREL arg123_relation & [ ARG3 #arg3 ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Val Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Valence types specify the number and type of subcategorized complements.
  
valence_type := canonical_synsem.

unsat_subst := valence_type &
  [ LOCAL.CAT.VAL.SUBJ < synsem_min & [ LOCAL [ CAT nomp_cat_min,
                                                CONJ cnil ],
                                        --SIND basic_non_event ] > ].
intrans_subst := one_arg & unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < > ].

unsat_two_arg_subst := unsat_subst & abstr_lex_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ --MIN #cmin,
                                     PUNCT.LPUNCT pair_or_no_punct ], ... >,
    LEX +,
    LKEYS.--COMPKEY #cmin ].

two_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

norm_two_arg_subst := two_arg_subst & basic_two_arg.

; For verbs that passivize.
; 21-Apr-00 Changed np_cat_acc_min to nomp_cat_acc_min for e.g. "kim liked 
; hiring abrams"
; DPF 29-May-01 - Removed COMPS..MSG no_msg, since this blocked
; acc-gerunds as in "I resent you giving him that" -- later reconsidered?
; DPF 26-May-03 - We don't have one obvious place to state the constraint that
; VPs are REL empty (no pied piping within VP - Ross 67?), so let's at least
; catch a good bunch of cases with this type.
trans_subst := unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     NONLOC.REL 0-dlist,
                                     --SIND basic_non_event &
  				     [ SORT basic-entity-or-event ] ], ... > ].
  
np_trans_subst := trans_subst & norm_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem >,
	    CONT.HCONS <! !> ] ].
  
; For verbs with nominal complement but that don't passivize.
non_trans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL.CONJ cnil,
                                     NONLOC.REL 0-dlist ], ... > ].
  
np_non_trans_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & 
                          [ LOCAL.CAT nomp_cat_nonnom_min,
                            --SIND index ] > ].

; became president
;; DPF 2012-12-21 - Block spurious non-empty SLASH
;;
nbar_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem & 
                          [ --MIN norm_nom_rel,
                            LOCAL.CAT nbar_cat_min,
			    NONLOC.SLASH 0-dlist ] > ].

basic_cp_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp &
                         [ LOCAL.CAT.HEAD.TAM.TENSE real_tense ],
                    COMPS < #comp & synsem &
			    [ LOCAL [ CAT basic_s_cat_v_c,
				      CONJ cnil ],
                              NONLOC.REL 0-dlist,
                              OPT - ] > ] ].

; Impose constraints stored in --ADDIN for base_or_non3sg verb
; Note that this has to allow for exceptional behavior for e.g.
; `demand that he be hired' where we don't what these --ADDIN constraints
cp_addin_tam_pn := synsem &
  [ LOCAL.CAT.VAL.KCMP.LOCAL [ CAT.HEAD [ TAM #tam,
					  --ADDIN [ ADDTAM #tam,
						    ADDPN #pn ] ],
			       AGR.PNG.PN #pn ] ].

cp_intrans_subst := basic_cp_intrans_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_v_c ].

; For input to nom-gerund lexical rule
basic_prep_intrans_subst := two_arg_subst.

prep_intrans_subst := basic_prep_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT basic_pp_cat,
				    CONJ cnil ],
                            NONLOC.REL 0-dlist ] > ].

unsat_three_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem & [ --MIN #ocmin ], ... >,
    LKEYS.--OCOMPKEY #ocmin ].

basic_three_arg_subst := unsat_three_arg_subst & basic_three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ NONLOC.REL 0-dlist ] > ].

three_arg_subst := unsat_three_arg_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ NONLOC.REL 0-dlist ] > ].

three_arg_trans_subst := three_arg_subst & trans_subst.

;; DPF 2013-02-05 - Don't unify the --SLTOP of the second complement, which is
;; usually scopal.
;;
basic_three_arg_trans_subst := unsat_three_arg_subst & generic_three_arg &
			       trans_subst &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle2,
                                   LAST #slast ] ],
                  [ LOCAL.CONT.HOOK.--SLTOP #sltop,
		    NONLOC.SLASH [ LIST #sfirst,
                                   LAST #smiddle1 ] ],
                  [ NONLOC.SLASH [ LIST #smiddle1,
                                   LAST #smiddle2 ] ] >,
    LOCAL.CONT.HOOK.--SLTOP #sltop,
    NONLOC.SLASH [ LIST #sfirst,
                   LAST #slast ] ].

three_arg_nontrans_subst := three_arg_subst & non_trans_subst.
basic_three_arg_nontrans_subst := basic_three_arg_subst & non_trans_subst.

three_arg_raising_subst := basic_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event ], ... > ].

; DPF 17-sept-07 - Restricted PP compl to be non-nmod, to disambiguate e.g.
; "to" as in "bring X to Y"

basic_prep_trans_subst := basic_three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event ], 
                          synsem &
                          [ LOCAL [ CAT [ HEAD prep_or_modnp,
                                          VAL [ SPR *olist*,
                                                COMPS < > ],
                                          MC na ],
                                    CONJ cnil ] ] > ].
  
prep_trans_subst := basic_prep_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem &
                          [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD noun ]>] > ].

prep_non_trans_subst := three_arg_nontrans_subst & 
  [ LOCAL.CAT.VAL.COMPS < lex_synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                                 CONJ cnil ],
                                         --SIND index,
                                         LEX + ],
			  synsem &
			  [ LOCAL [ CAT basic_pp_cat,
				    CONJ cnil ] ] > ].
  
; DPF 15-Apr-02 - Maybe none of these obj_equi_prd verbs should passivize, 
; since the control of the predicative phrase is already the syntactic subject
; when the PrdP is just a VP modifier rather than a complement.  We'll try 
; making all of them prd_non_trans.
; DPF 11-sep-09 - Exclude gerunds as first complements, to avoid spurious
; analysis for e.g. "he likes going on vacation"
; DPF 14-may-10 - Re 11-sep-09: But this blocks "they got parsing right."
; so remove [ SORT entity ] constraint from first complement.
;; DPF 2013-02-06 - Add COMPS..MOD..HEAD noun to avoid ambig of preps like
;; `to' with double entries.

basic_prd_subst := unsat_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event,
                                     OPT - ], 
			  synsem & 
			  [ LOCAL [ CAT prd_cat &
                                        [ HEAD.MOD 
                                          < [ --MIN norm_rel,
					      LOCAL.CAT.HEAD noun,
					      OPT +] > ],
                                    CONJ cnil ],
                            OPT - ], ... > ].

prd_trans_subst := basic_prd_subst & trans_subst.
; DPF 14-mar-05 - Constraining NP to be definite, to block annoying spurious
; parses for e.g. "I have a meeting on Tuesday".
; DPF 20-mar-05 - But this also blocks "I have a lot of mornings free" and
; "I'll get a room ready".  So it seems we have to pay this price with
; ambiguity. Sigh.
prd_non_trans_subst := basic_prd_subst & non_trans_subst & 
		       basic_three_arg_subst.

; Removed nonpro_rel from second NP, since we want to get "sell me this" and
; maybe even "sell me them" even if not "*sell Abrams it"
; DPF 2-Jun-02 - Put this back, since deictics no longer pron_rel.  We do give
; up "sell me them", but we really don't want "sell the customers it".
; DPF 21-may-04 - Changed nonpro_rel to nonpro_or_num_rel, consistent with
; recent treatment of number nouns.
; DPF 24-feb-05 - And then further generalized to nonpro_or_refl_or_num_rel,
; so we still get ditrans reading for "Abrams gave Browne himself"

basic_ditrans_subst := basic_three_arg_subst & 
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
                          [ LOCAL.CONJ cnil,
                            --SIND basic_non_event,
                            NONLOC.REL 0-dlist ], 
			  synsem & 
                          [ LOCAL [ CONJ cnil,
				    CONT.HOOK.--SLTOP #sltop ],
                            --MIN nonpro_or_refl_or_num_rel,
                            --SIND basic_non_event ] >,
	    CONT.HOOK.--SLTOP #sltop ] ].
  
;; DPF 18-feb-10 - We want to catch "She taught student the lesson", so
;; remove --BARE - from first daughter, and see what happens.
ditrans_subst := basic_ditrans_subst & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT nomp_cat_acc_min ],
                            [ LOCAL.CAT nomp_cat_acc_min &
					[ HEAD.--BARE -  ] ] >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! !> ] ],
    LKEYS.KEYREL #keyrel ].
  
; 'elected him president'
ditrans_np_nbar_subst := basic_ditrans_subst & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ --MIN norm_nom_rel,
                              LOCAL [ CAT nbar_cat_min,
                                      CONT.HOOK [ LTOP #nhand,
                                                  INDEX #arg ] ],
                              NONLOC.SLASH 0-dlist ] >,
            CONT [ RELS <! relation, 
			   #altkeyrel &
                           [ PRED udef_q_rel,
                             ARG0 #arg,
                             RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].
                                           
  
; 'see picture, page 2'
ditrans_nbar_np_subst := basic_ditrans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN norm_nom_rel,
                              LOCAL [ CAT nbar_cat_min,
                                      CONT.HOOK [ LTOP #nhand,
                                                  INDEX #arg ] ],
                              NONLOC.SLASH 0-dlist ],
                            [ LOCAL.CAT nomp_cat_acc_min ] >,
            CONT [ RELS <! relation, 
			   #altkeyrel &
                           [ PRED udef_q_rel,
                             ARG0 #arg,
                             RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

  
; 'inform Kim that S'
basic_cp_trans_subst := basic_three_arg_trans_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONJ cnil ],
                                       --SIND basic_non_event,
				       OPT - ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_unspec,
				      CONJ cnil ],
                              OPT - ] > ] ]. 
  
; Impose MC - on complement
cp_trans_subst := basic_cp_trans_subst &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_v_c ].

basic_pp_cp_subst := basic_three_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem &
			    [ LOCAL [ CAT basic_pp_cat,
				      CONJ cnil ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT.MC -,
				      CONJ cnil ],
                              OPT - ] > ] ].
  
pp_cp_subst := basic_pp_cp_subst &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_fin_or_inf_unspec ].
  
np_comp_subst := basic_three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event,
                                     OPT - ],
			  [ LOCAL.CAT [ HEAD prep,
                                        VAL.COMPS < > ],
                            OPT - ] > ].
; 'talk to Kim about Sandy'
double_pp_subst := three_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT pp_cat,
                                    CONJ cnil ] ], 
			  synsem &
			  [ LOCAL [ CAT [ HEAD prep_or_modnp,
                                          VAL [ SPR *olist*,
                                                COMPS < > ],
                                          MC na ],
				    CONJ cnil ] ] > ].
  
np_trans_double_pp_subst := four_arg & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                          synsem &
                          [ --MIN #ocmin & selected_rel,
                            LOCAL [ CAT basic_pp_cat,
                                    CONJ cnil ],
                            NONLOC.REL 0-dlist ], 
                          synsem &
                          [ --MIN selected_rel,
                            LOCAL [ CAT basic_pp_cat,
                                    CONJ cnil ],
                            NONLOC.REL 0-dlist ] >,
	    CONT.HCONS <! !> ],
    LKEYS.--OCOMPKEY #ocmin ].
  
basic_inf_or_prp_intrans_subst := valence_type &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat,
                                      CONJ cnil ],
                              --SIND.E.TENSE no_tense,
                              OPT - ] > ] ].

inf_or_prp_intrans_subst := basic_inf_or_prp_intrans_subst & 
                            unsat_two_arg_subst.

basic_inf_intrans_subst := basic_inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT vp_inf_cat ] > ].

inf_intrans_subst := basic_inf_intrans_subst & unsat_two_arg_subst.

inf_intrans_from_subst := basic_inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD.VFORM inf_from,
					VAL.SUBJ < synsem > ] ] > ].

inf_intrans_particle_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
                      COMPS < abstr_lex_synsem &
                              [ --MIN selected_rel,
                                LOCAL [ CAT.HEAD a_or_p,
					CONT.HOOK.LTOP #hand ],
                                NONLOC.REL 0-dlist ],
                              #comp & synsem &
                              [ LOCAL [ CAT vp_inf_cat,
                                        CONT.HOOK.LTOP #hand,
                                        CONJ cnil ] ] > ] ] ].

; for "I will try and find it" - analysis following Pullum and Gazdar

inf_intrans_and_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_and,
					    VAL.SUBJ < synsem > ],
                                      CONJ cnil ] ] > ] ].

; for "couldn't help but notice"
inf_intrans_but_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_but,
					    VAL.SUBJ < synsem > ],
                                      CONJ cnil ] ] > ] ].


for_inf_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & 
			  [ LOCAL [ CAT s_cat_v_c &
					[ HEAD comp &
                                               [ VFORM inf ] ],
                                    CONJ cnil ],
                            OPT - ] > ].

inf_trans_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < [ OPT - ], 
                            #comp & synsem &
                            [ LOCAL [ CAT vp_inf_cat,
                                      CONJ cnil ],
                              OPT - ] > ] ].

inf_trans_from_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < [ OPT - ], 
                            #comp & synsem &
                            [ LOCAL [ CAT vp_cat &
                                          [ HEAD.VFORM inf_from,
					    VAL.SUBJ < synsem > ],
                                      CONJ cnil ],
                              OPT - ] > ] ].

inf_trans_raising_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

prp_intrans_subst := inf_or_prp_intrans_subst & basic_two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD.VFORM prp,
					VAL.SUBJ < synsem > ] ] > ].

bse_intrans_subst := unsat_two_arg_subst & basic_two_arg &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM bse ],
                                      CONJ cnil ],
                              --SIND.E.TENSE no_tense,
                              OPT - ] > ] ].

; 'make, let, watch' don't passivize.  Some of these have an apparently
; corresponding passive, but with an ordinary 'to-VP' complement, not vform bse
bse_nontrans_raising_subst := three_arg_raising_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem &
			  [ LOCAL [ CAT vp_bse_cat,
				    CONJ cnil ],
                            OPT - ] > ].

; want (doesn't passivize)
basic_inf_non_trans_subst := unsat_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL.CAT nomp_cat_acc_min,
                                       --SIND index ],
                            #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

inf_non_trans_subst := basic_inf_non_trans_subst & basic_three_arg_subst.

prp_non_trans_subst := basic_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL.CAT nomp_cat_acc_min,
                                       --SIND index,
                                       OPT - ],
			    #comp & synsem &
			    [ LOCAL [ CAT vp_prp_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

basic_pp_vp_subst := valence_type &
  [ LOCAL.CAT.VAL [ KCMP #comp,
                    COMPS < synsem &
                            [ --MIN selected_rel,
                              LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ],
                              NONLOC.REL 0-dlist,
                              PUNCT.LPUNCT no_punct ],
                            #comp & synsem &
                            [ LOCAL [ CAT vp_cat,
                                      CONJ cnil ],
                              PUNCT.LPUNCT no_punct,
                              OPT - ] > ] ].

basic_pp_inf_subst := basic_pp_vp_subst &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT vp_inf_cat ].

pp_inf_subst := basic_pp_inf_subst & unsat_three_arg_subst.

; We treat raising as the identification of the CONT attribute of the SUBJ and
; the COMPS.SUBJ, rather than the whole synsem, in part to enable the 
; underspecification of the base/non3sg lex-entry for verbs, where otherwise
; CASE information would clash in examples like "Kim believes Sandy to be 
; ready."  In fact, we only identify the INDEX of the two subjects - see 
; comments by sor_inf_subst.
; 
; DPF 17-Nov-99 - The LTOP handle of the SUBJ must be identified with the
; KEY.LBL of the ssr_subst predicate, since contracted negation auxiliary
; verbs have the LTOP be the neg_rel's handle, but the subject as in 
; "I can't leave" should have its LBL identified with that of the
; can_rel, not the neg_rel.

subj_control_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #sind & basic_non_event ] >,
                    COMPS < [ LOCAL [ CAT.VAL.COMPS < >,
                                      CONT.HOOK.XARG #sind ],
                              OPT - ], ... > ] ].

ssr_subst := subj_control_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #xarg ] >,
            CONT.HOOK.XARG #xarg ] ].

ssr_two_arg_subst := ssr_subst & basic_two_arg.

ssr_inf_subst := ssr_subst & inf_intrans_subst.

ssr_pp_inf_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
	   [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                        INDEX #subj ] ] >,
	     COMPS < synsem &
		     [ --MIN _to_p_sel_rel,
                       LOCAL [ CAT basic_pp_cat & 
                                   [ HEAD.MOD < > ],
                               CONJ cnil ] ] ,
		     [ LOCAL [ CAT [ HEAD comp & [ VFORM inf ],
                                     VAL [ SUBJ < synsem >,
					   COMPS < > ] ],
                               CONT.HOOK.XARG #subj ],
                       OPT - ] > ],
            CONT.HOOK.LTOP #ltop ] ].

seq_prdp_pp_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
            [ COMPS < [ LOCAL 
			[ CAT [ HEAD [ PRD +,
				       TAM.TENSE no_tense,
				       MOD < [ LOCAL intersective_mod,
					       OPT + ] > ],
				VAL [ SUBJ *olist*,
				      SPR *olist*,
				      COMPS < > ],
				MC na ],
			  CONT.HOOK.XARG #xarg ],
			OPT - ],
		      synsem &
		      [ LOCAL [ CAT basic_pp_cat &
				    [ HEAD.MOD < > ],
				CONT.HOOK.--SLTOP #sltop,
				CONJ cnil ] ] > ],
	    CONT.HOOK [ XARG #xarg,
			--SLTOP #sltop ] ] ].

expl_pp_cp_subst :=  basic_three_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ] ], 
                            synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c,
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

expl_np_cp_subst :=  basic_three_arg_subst & trans_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < [ OPT - ], 
                            synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD verbal &
							[ VFORM fin_or_inf,
							  MOD *anti_list* ],
                                                   VAL [ SUBJ *anti_list*,
							 COMPS < > ] ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].

expl_cp_cp_subst :=  basic_three_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c &
					  [ HEAD comp &
						 [ TAM #tam,
						   --ADDIN [ ADDTAM #tam,
							     ADDPN #pn ] ],
					    VAL.COMPS < > ],
				      AGR.PNG.PN #pn,
				      CONJ cnil ],
			      OPT - ],
                            canonical_synsem & #keycomp &
			    [ LOCAL [ CAT s_cat_fin_v_c &
					  [ HEAD comp,
					    VAL.COMPS < > ],
				      CONJ cnil ],
			      OPT - ] >,
                    KCMP #keycomp ] ].

four_arg_subst := unsat_three_arg_subst & four_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem & [ --MIN #ocmin,
                                     NONLOC.REL 0-dlist ],
                          synsem, ... >,
    LKEYS.--OCOMPKEY #ocmin ].

; 'cost/take' - restrict first NP to non-measure-NP, and the second to MNP.
; But this is too strong for second argument, since "a couple of days" is not
; analyzed as a MNP.
expl_np_np_cp_subst :=  four_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT nomp_cat_acc_min &
                                          [ VAL.SPEC < anti_synsem_min > ],
				      CONJ cnil ],
                              --SIND basic_non_event ], 
			    synsem &
			    [ LOCAL [ CAT [ HEAD supnoun &
                                                 [ POSS -,
                                                   MOD *anti_list* ],
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ],
                                            MC na_or_- ],
				      CONJ cnil ] ], 
			    synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].
                                                 
expl_np_np_cp_inf_subst := expl_np_np_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem,
                          [ LOCAL.CAT.HEAD.VFORM inf ] > ].

; `it matters a lot to him that S'
expl_np_pp_cp_subst :=  four_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT nomp_cat_acc_min &
                                          [ VAL.SPEC < anti_synsem_min > ],
				      CONJ cnil ],
                              --SIND basic_non_event ], 
			    synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ],
			      --MIN selected_rel ],
			    synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].

; `makes him angry that S'
expl_np_np_prdp_cp_subst :=  prd_trans_subst & four_arg_subst & 
			     cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem,
			    synsem,
			    synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].
                                                 
expl_prtcl_cp_subst :=  basic_three_arg_subst & particle_subst &
			cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem, 
                            synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c,
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

expl_cp_subst :=  norm_two_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c & [ HEAD comp ],
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

expl_vp_subst :=  norm_two_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem & #keycomp &
                            [ LOCAL [ CAT vp_inf_cat,
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

; Raising synsems have to identify the LOCAL value of the raised synsem with
; that of the VP's subject's synsem, rather than identifying the synsems
; themselves, due to our lexical threading of SLASH: if the raised complement
; is extracted, it will be of type gap, and therefore have a non-empty SLASH,
; but we don't want the lower VP complement's subject to also then have a
; non-empty SLASH.  But cf. note above for subj-subj raising, where maybe we
; even want to restrict the identity to CONT only.
;   Indeed, this seems necessary, since CASE blocks unification for
; 'Kim made him sleep' where our (dual-purpose) 'sleep' requires its subject
; to be [CASE nom] (in order to block the sentence "them sleep"), but when its
; subject is raised to object as with "make", there's a conflict with the
; [CASE acc] on the object of "make".  So here again, we make the raising
; identity hold only for CONT.
; DPF (30-Apr-99) In fact, we now have to further restrict the identity to
; only the INDEX, since if we identify all of CONT, we get the handles of the
; higher NP and the VP's subject being identified, but since we also want to 
; lexically identify a predicate's handle with that of its arguments (subject
; to classes of lexical exceptions like for entries with CP complements), we 
; get an unwanted identity of the handles of the higher and lower verbs through
; the identity of the two NPs.  So if we can't sustain this minimal 
; identification for equi and raising, we'll have to give up on identifying 
; the handles of lexical entries and their arguments.  Possible trouble spots 
; are locative inversions like "On the corner seemed to be an abandoned house".

sor_inf_subst := inf_trans_raising_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ --SIND #subj,
                            OPT - ], 
			  [ LOCAL [ CONT.HOOK [ XARG #subj,
                                                INDEX.E.TENSE no_tense ] ],
				OPT - ] > ].

;; DPF 10-nov-09 - Added PRF - to VP complement, to block e.g.
;; "*They had him have arrived".
;;
sor_bse_subst := bse_nontrans_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj,
			    OPT - ], 
                          canonical_synsem &
			  [ LOCAL [ CAT [ HEAD.TAM.ASPECT.PRF -,
					  VAL.SUBJ 
					  < [ NONLOC [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ],
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

sor_inf_non_trans_subst := inf_non_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj,
			    OPT - ],
			  [ LOCAL.CONT.HOOK.XARG #subj ]  > ].


sor_prd_subst := three_arg_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj ], 
			  [ LOCAL [ CAT basic_prd_cat &
                                        [ HEAD [ TAM.TENSE untensed,
						 AUX - ] ],
				    CONJ cnil,
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

sor_prd_trans_subst := sor_prd_subst & trans_subst.
sor_prd_nontrans_subst := sor_prd_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CAT prd_cat ] > ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; DPF 20-jun-07 - Instead, make first comp be abstr_lex_synsem, rather than
; the hack we tried for awhile of requiring the RELS list to be <! !> - this
; sort of worked, but we don't want to depend on unification failure for
; features that we will sometimes restrict for efficiency, and it was ugly.

particle_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < abstr_lex_synsem &
                          [ --MIN selected_rel,
                            LOCAL.CAT.HEAD a_or_p & [ PRD - ],
                            NONLOC [ SLASH 0-dlist,
                                     REL 0-dlist,
                                     QUE 0-dlist ],
                            OPT - ], ... > ].


;; DPF (29-Jan-99) Modified particle_NP_subst to exclude pronominal NP objects,
;; to block *Kim looked up it"
; DPF 2-Sept-04 - Changed COMPS.REST.FIRST..CAT from nomp_cat_acc_min to
; nomp_cat_nonnom_min to allow np_cp's like "We wrote down who won".

particle_NP_subst := particle_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
			  synsem & 
                          [ LOCAL [ CAT nomp_cat_nonnom_min,
                                    CONJ cnil ],
                            --MIN nonpro_or_refl_or_num_rel,
                            --SIND basic_non_event,
                            NONLOC.REL 0-dlist,
                            OPT - ], ... > ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; Instead, identify single-word particles by constraint on RELS - a hack.
; DPF 2010-08-31 - Re 28-Oct-01: Removed this hack, instead constraining
; particle to be abstr_lex_synsem.

generic_NP_particle_subst := trans_subst & abstr_lex_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ],
			    abstr_lex_synsem &
			    [ --MIN #cmin & selected_rel,
			      LOCAL.CAT.HEAD a_or_p & [ PRD - ],
			      NONLOC [ SLASH 0-dlist,
				       REL 0-dlist,
				       QUE 0-dlist ],
			      OPT - ], ... > ],
    LEX +,
    LKEYS.--COMPKEY #cmin ].

NP_particle_subst := generic_NP_particle_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

NP_particle_pp_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
                          synsem,
                          synsem &
                          [ --MIN #ocmin,
                            LOCAL [ CAT basic_pp_cat,
                                    CONJ cnil ],
                            NONLOC.REL 0-dlist,
                            OPT - ] >,
	    CONT.HCONS <! !> ],
    LKEYS.--OCOMPKEY #ocmin ].

NP_particle_np_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
                          synsem,
                          synsem &
                          [ LOCAL [ CAT nomp_cat_acc_min,
                                    CONJ cnil ],
                            --SIND basic_non_event,
                            NONLOC.REL 0-dlist,
                            OPT - ] >,
	    CONT.HCONS <! !> ] ].

NP_particle_cp_subst := generic_NP_particle_subst & four_arg &
			cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem, 
                            synsem,
                            synsem & #keycomp &
                            [ LOCAL [ CAT [ HEAD comp &
						 [ VFORM fin_or_inf,
						   MOD *anti_list* ],
					    VAL.COMPS < > ],
				      CONT.HOOK.INDEX.SF prop,
				      CONJ cnil ],
			      NONLOC.REL 0-dlist,
			      OPT - ] >,
		    KCMP #keycomp ] ].

particle_plus_subst := particle_subst & basic_three_arg_subst.

particle_prd_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem & 
			  [ LOCAL [ CAT prd_cat,
				    CONJ cnil ],
                            NONLOC.REL 0-dlist,
                            OPT - ] > ].

; 'turn out to be'
particle_inf_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

; 'keep on driving'
particle_prp_subst := particle_subst & basic_three_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_prp_cat,
				      CONJ cnil ],
			      OPT - ] > ] ].

particle_pp_subst := particle_plus_subst &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
                            synsem &
                            [ LOCAL [ CAT basic_pp_cat,
				      CONT.HOOK.--SLTOP #sltop,
                                      CONJ cnil ],
                              NONLOC.REL 0-dlist ] >,
            CONT [ HOOK.--SLTOP #sltop,
		   HCONS <! !> ] ] ].

; 'find out that S'
particle_cp_subst := particle_plus_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
                              OPT - ] > ] ].

; 'point out to Kim that S'
particle_pp_cp_subst := particle_subst & four_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ],
                              NONLOC.REL 0-dlist ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
                              OPT - ] > ] ].

particle_oeq_subst := particle_NP_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem, synsem,
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

; 'leave it to Kim to find the answer'
expl_pp_inf_subst := four_arg_subst & trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < [ OPT - ], 
			    synsem &
			    [ LOCAL [ CAT basic_pp_cat,
				      CONJ cnil ],
                              NONLOC.REL 0-dlist,
                              OPT - ] ,
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

;; 'bet Kim a fortune that Sandy would win'
;; DPF (19-Oct-98) Added hack to block extraction from the CP complement, since
;; don't know how to avoid topicalized imperative parse for "Abrams bet Browne
;; Chiang slept with subject of "slept" topicalized.

np_np_cp_subst := four_arg_subst & trans_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONJ cnil ],
                                       --SIND basic_non_event ],
			    synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONJ cnil ],
                                       --SIND basic_non_event,
                                       NONLOC.REL 0-dlist ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
			      NONLOC.SLASH 0-dlist ] > ] ].

; E.g., "I'm not doing too badly"
; DPF 30-aug-04 - Changed COMPS..HEAD p_or_adv to just adv, since we were
; overgenerating "Kim did in Paris", and it's not clear why we wanted prep.

adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
			    [ LOCAL 
			      [ CAT [ HEAD adv &
                                       [ MOD < [ LOCAL intersective_mod ] > ],
                                      VAL [ SPR *olist*,
                                            COMPS < > ],
				      POSTHD + ],
                                CONT.HOOK [ LTOP #hand,
                                            INDEX #event ] ],
                              NONLOC.REL 0-dlist,
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

np_adv_subst := trans_subst & three_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    synsem & 
			    [ LOCAL 
			      [ CAT [ HEAD adv &
                                       [ MOD < [ LOCAL intersective_mod ] > ],
                                      VAL [ SPR *olist*,
                                            COMPS < > ] ],
                                CONT.HOOK [ LTOP #hand,
                                            INDEX #event ] ],
                              NONLOC.REL 0-dlist,
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERB SYNSEMS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Verb synsems should inherit from one valence type and one linking type.
; The type verb_synsem is given a non-empty SPR value so VPs can be modified
; by PPs, but (hack) the synsem is of type anti_synsem_min to block unification, 
; to avoid ever picking up an actual specifier.
;   Added VIT links for the moment, to satisfy VIT requirements for visibility
; of TENSE and MOOD information.  (Actually, moved VITTENSE specification to
; the various inflectional affixes in lexrules.tdl, to accommodate the collapse
; of the base and fin-non3sg verb forms.
; DPF (8-Jul-98) Added QUE 0-dlist, REL 0-dlist to block pied piping in verb
; phrases (taking advantage of lexical amalgamation of these features, together
; with our treatment of subject-WH as extraction (where only local features are
; propagated in SLASH).
; DPF 8-dec-03 - Removed QUE 0-dlist, since we may now be ready for in-situ
; WH-questions.

basic_verb_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD verb & [ MOD < anti_synsem_min > ],
                  VAL [ SUBJ < synsem_min & #subj >,
			SPR < anti_synsem_min >,
			COMPS #comps,
			SPCMPS < > ] ],
	    ARG-S < #subj . #comps > ],
    LKEYS.KEYREL event_relation,
    NONLOC.REL 0-dlist,
    MODIFD notmod ].

norm_basic_verb_synsem := basic_verb_synsem &
  [ LOCAL.CAT.HEAD.MINORS.MIN v_event_rel,
    LKEYS.KEYREL.ARG0 non_conj_event ].

norm_verb_synsem := norm_basic_verb_synsem &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.AGR.PNG #png ] >,
            AGR.PNG #png ] ].

verb_synsem := norm_verb_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD.TAM #tam,
            CONT.HOOK.INDEX.E #tam ] ].

; DPF 20-apr-09
; For output of lexical rules like re-prefixation, to prevent the output
; from undergoing other lexical rules which are constrained by synsem type.
; DPF 2010-10-23 - But we do want to allow (nominal) gerunds as in
; |the redecorating amazed Kim|.  So add subtype for this case.
;
derived_verb_synsem := verb_synsem.
derived_trans_verb_synsem := derived_verb_synsem & trans_subst.

atrans_verb_min := synsem_min.
atrans_verb := verb_synsem & intrans_subst & atrans_lt & atrans_verb_min &
  [ LOCAL [ CAT.HEAD.MINORS.MIN weather_v_rel,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel ].

onearg_verb := verb_synsem & intrans_subst & arg1_subj_lt &
  [ LOCAL.CONT.RELS <! #keyrel !>,
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].
unerg_verb_min := synsem_min.
unerg_verb := onearg_verb & unerg_verb_min.
unerg_imp_verb_min := synsem_min.
unerg_imp_verb := unerg_verb & unerg_imp_verb_min &
  [ LOCAL.CAT.HEAD.VFORM imp_vform ].
unerg_bse_verb_min := synsem_min.
unerg_bse_verb := unerg_verb & unerg_bse_verb_min &
  [ LOCAL.CAT.HEAD [ VFORM bse_only,
		     TAM.TENSE future ] ].
unerg_prp_verb_min := synsem_min.
unerg_prp_verb := unerg_verb & unerg_prp_verb_min &
  [ LOCAL [ CAT.HEAD.VFORM prp,
	    CONT [ RELS <! relation !>,
		   HCONS <! !> ] ] ].

twoarg_verb_synsem := verb_synsem & two_arg.
passive_or_unacc_synsem := unsat_subst.
unacc_verb_min := synsem_min.
unacc_verb := onearg_verb & passive_or_unacc_synsem & unacc_verb_min.
  
; For at least main verb "have" (e.g, "Kim has some rice")
; DPF 04-sep-09 - Block gerund complements: "*Kim has hiring Abrams"
poss_verb_min := synsem_min.
poss_verb := twoarg_verb_synsem & two_arg_subst & poss_lt &
	     poss_verb_min &
  [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc &
						   [ HEAD noun_or_nomger ],
			        	       CONJ cnil ],
                                       --SIND index,
                                       NONLOC.REL 0-dlist,
				       OPT - ] >,
            CONT.RELS.LIST.FIRST #keyrel ],
    LKEYS.KEYREL #keyrel ].
  
poss_got_verb_min := synsem_min.
poss_got_verb := poss_verb & poss_got_verb_min &
  [ LOCAL non_fin_verb &
	  [ CAT [ HEAD [ VFORM psp,
			 PRD - ],
		  VAL.COMPS < [ LOCAL.CAT.HEAD.MINORS.NORM no_rel ] >,
		  MC na ],
	    CONT.RELS <! relation !> ] ].

np_trans_verb_min := synsem_min.
np_trans_verb := verb_synsem & np_trans_subst & trans_lt &
		 np_trans_verb_min &
  [ LOCAL.CONT.RELS <! #keyrel !>,
    LKEYS.KEYREL #keyrel ].
  
np_trans_nfin_verb_min := synsem_min.
np_trans_nfin_verb := np_trans_verb & np_trans_nfin_verb_min &
  [ LOCAL.CAT [ HEAD [ VFORM bse,
		       TAM [ TENSE present,
			     MOOD indicative ] ],
		VAL.COMPS < [ OPT + ] > ] ].


np_non_trans_verb_min := synsem_min.
np_non_trans_verb := twoarg_verb_synsem & np_non_trans_subst & trans_lt &
		     np_non_trans_verb_min &
  [ LOCAL.CONT.RELS <! #keyrel !>,
    LKEYS.KEYREL #keyrel ].


np_non_trans_nb_verb_min := synsem_min.
np_non_trans_nb_verb := np_non_trans_verb & np_non_trans_nb_verb_min &
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem &
			  [ OPT -,
			    LOCAL.CAT.VAL.SPEC < > ] > ].

np_trans_refl_verb_min := synsem_min.
np_trans_refl_verb := twoarg_verb_synsem & np_non_trans_subst & trans_lt &
		      np_trans_refl_verb_min &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #arg2,
			      OPT - ] >,
	    CONT [ HOOK.XARG #arg1 ,
		   RELS <! #keyrel & [ LBL #lbl ], 
			   #altkeyrel & [ LBL #lbl,
					  PRED id_rel,
					  ARG1 #arg1 & [ PNG #png ],
					  ARG2 #arg2 & [ PNG #png ] ] !> ] ],
    LKEYS [ KEYREL #keyrel,
	    ALTKEYREL #altkeyrel ] ].

basic_do_be_verb := basic_verb_synsem & unsat_subst &
  [ LOCAL [ CAT [ HEAD [ MINORS.MIN _do_v_be_rel,
			 TAM #tam ],
		  VAL.SUBJ < [ LOCAL.AGR.PNG #png,
			       NONLOC.SLASH 0-dlist ] > ],
	    AGR.PNG #png,
	    CONJ cnil,
	    CONT [ HOOK.INDEX non_conj_event & [ E #tam ],
		   RELS.LIST.FIRST #keyrel,
		   HCONS <! !> ] ],
    LEX +,
    PUNCT no_punctuation_min,
    LKEYS [ KEYREL #keyrel,
	    --+COMPKEY _be_v_do_rel ] ].

;; |the thing we did was hire a manager|
;;
do_be_verb_min := synsem_min.
do_be_verb := basic_do_be_verb & arg1_subj_lt & do_be_verb_min &
  [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN role_rel,
		  VAL.COMPS < > ],
	    CONT [ HOOK [ LTOP #lbl,
			  XARG #xarg ],
		   RELS <! #keyrel & [ LBL #lbl ] !> ] ],
    NONLOC.SLASH 1-dlist & <! [ CAT [ HEAD basic_noun & [ MOD < > ],
				      VAL.SPR *olist* ],
				CONJ cnil,
				CONT.HOOK [ INDEX #cind &
						  [ SORT do-event ],
					    XARG #xarg ] ] !>,
    LKEYS.KEYREL #keyrel & [ ARG2 #cind ] ].

;; |the first thing that must be done is get ready|
do_be_verb_passive_min := synsem_min.
do_be_verb_passive := basic_do_be_verb & do_be_verb_passive_min &
  [ LOCAL [ CAT [ HEAD [ VFORM pas,
			 MINORS.ALTMIN passive_rel ],
		  VAL [ COMPS *obliquecons* &
			     < synsem & 
			       [ --MIN _by_p_cm_rel,
				 LOCAL local &
				       [ CAT [ HEAD prep,
					       VAL [ SUBJ < >,
						     SPR *olist*,
						     COMPS < > ] ],
					 CONT.HOOK.INDEX #byind ],
				 NONLOC.REL 0-dlist,
				 OPT + ] > ] ],
	    CONT [ HOOK [ LTOP #lbl,
			  INDEX #event,
			  XARG #xarg & [ SORT do-event ] ],
		   RELS <! [ LBL #lbl,
			     CFROM #cfrom, CTO #cto ],
			   [ LBL #lbl,
			     PRED parg_d_rel,
			     ARG0 event & [ E.TENSE no_tense ],
			     ARG1 #event,
			     ARG2 #xarg,
			     CFROM #cfrom, CTO #cto ] !>,
		   HCONS <! !> ] ],
    NONLOC.SLASH 0-dlist,
    LKEYS.KEYREL [ ARG1 #byind,
		   ARG2 #xarg ] ].

nbar_verb_min := synsem_min.
nbar_verb := verb_synsem & basic_two_arg & nbar_subst & basic_arg12_lt &
	     nbar_verb_min &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nhand,
                                                INDEX #arg & basic_non_expl ],
			      OPT - ] >,
            CONT [ RELS <! relation,
			   #altkeyrel &
                           [ PRED udef_q_rel,
                             ARG0 #arg,
                             RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

basic_prep_intrans_verb := verb_synsem & prep_intrans_subst & basic_two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT basic_pp_cat ] > ].

;; come to
prep_intrans_verb_min := synsem_min.
prep_intrans_verb := basic_prep_intrans_verb & prep_intrans_lt & two_arg &
		     prep_intrans_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT pp_cat ] > ].

;; fall into
prep_intrans_unacc_verb_min := synsem_min.
prep_intrans_unacc_verb := basic_prep_intrans_verb & prep_intrans_lt &
			   prep_intrans_unacc_verb_min &
                           two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN dir_or_unsp_loc_rel,
			    OPT +,
                            LOCAL.CAT [ HEAD prep_or_modnp &
                                             [ MOD < [ LOCAL.CAT.HEAD noun ]>],
                                        VAL [ SPR *olist*,
                                              COMPS < > ],
                                        MC na ] ] > ].

;; thanks (hack)
prep_intrans_nosubj_verb := basic_prep_intrans_verb & prep_intrans_nosubj_lt.

;; look for
;;
empty_prep_intrans_verb_min := synsem_min.
empty_prep_intrans_verb := twoarg_verb_synsem & prep_intrans_subst &
			   empty_prep_intrans_verb_min &
			   empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel ].

empty_prep_intrans_bse_verb_min := synsem_min.
empty_prep_intrans_bse_verb := empty_prep_intrans_verb &
			       empty_prep_intrans_bse_verb_min &
  [ LOCAL.CAT.HEAD [ VFORM bse,
		     TAM [ TENSE present,
			   MOOD indicative ] ],
    LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin ] ].


;; gave to 
;;
empty_prep_intrans_arg3_verb_min := synsem_min.
empty_prep_intrans_arg3_verb := twoarg_verb_synsem & prep_intrans_subst &
			        empty_prep_intrans_arg3_lt &
				empty_prep_intrans_arg3_verb_min.

;; run for mayor
empty_prep_nospr_verb := verb_synsem & prep_intrans_subst & basic_two_arg & 
                         empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nhand,
                                                INDEX #nind,
						--SLTOP #sltop ] ] >,
            CONT [ HOOK.--SLTOP #sltop,
		   RELS <! relation & #keyrel,
			   #altkeyrel & [ PRED udef_q_rel,
					  ARG0 #nind,
					  RSTR #rhand ] !>,
		   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ],
    LKEYS [ KEYREL #keyrel,
	    ALTKEYREL #altkeyrel ] ].


;; suggest on Tuesday
;;
prep_intrans_event_verb_min := synsem_min.
prep_intrans_event_verb := twoarg_verb_synsem & prep_intrans_subst &
			   prep_intrans_event_verb_min &
			   prep_intrans_event_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT pp_cat,
			    OPT - ] > ].

;; verbs of motion
prep_intrans_dir_verb_min := synsem_min.
prep_intrans_dir_verb := twoarg_verb_synsem & basic_prep_intrans_subst &
			 prep_intrans_dir_verb_min &
                         prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN dir_or_unsp_loc_rel,
                            LOCAL.CAT [ HEAD prep_or_modnp &
                                             [ MOD < synsem &
                                                     [ LOCAL.CAT.HEAD noun ]>],
                                        VAL [ SPR *olist*,
                                              COMPS < > ],
                                        MC na ] ] > ].

;; put, move
;;
; DPF 17-sept-07 - Restricted PP compl to be non-nmod, to disambiguate e.g.
; "to" as in "bring X to Y"
; DPF 14-may-10 - Re 17-sept-07: But this excludes of-PPs, so try
; constraining to noun instead of v_or_a_or_p.
;
basic_prep_trans_verb := verb_synsem & prep_trans_subst & prep_trans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >]> ].

;; `put'
prep_trans_verb_min := synsem_min.
prep_trans_verb := basic_prep_trans_verb & prep_trans_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ OPT - ] > ].
  
prep_trans_dir_verb_min := synsem_min.
prep_trans_dir_verb := prep_trans_verb & prep_trans_dir_verb_min &
  [ LOCAL.CAT.VAL.COMPS < synsem,
			  [ LOCAL.CAT.HEAD.MINORS
				       [ MIN dir_or_state_nontemp_rel ] ] > ].

;; change one's mind about X (where 'about' is only noun-modifier)
prep_trans_verb_nmod_min := synsem_min.
prep_trans_verb_nmod := basic_prep_trans_verb &
			prep_trans_verb_nmod_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ LOCAL.CAT.HEAD.PRD +,
                                       OPT - ] > ].
;; |we raced each other across the street|
prep_trans_dir_noprop_verb_min := synsem_min.
prep_trans_dir_noprop_verb := verb_synsem & prep_trans_subst & trans_lt &
			      prep_trans_dir_noprop_verb_min &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ LOCAL [ CAT.HEAD.MINORS.MIN dir_rel,
				      CONT.HOOK [ LTOP #ltop,
						  XARG #event,
						  --SLTOP #sltop ] ],
			      OPT - ] >,
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #event,
			  --SLTOP #sltop ],
		   RELS <! #keyrel !>,
		   HCONS <! !> ] ],
    LKEYS.KEYREL #keyrel ].

;; remind-of
;;
empty_prep_trans_verb_min := synsem_min.
empty_prep_trans_verb := verb_synsem & basic_prep_trans_subst & 
			 empty_prep_trans_verb_min &
                         empty_prep_trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    [ LOCAL [ CAT basic_pp_cat,
				      CONT.HOOK.--SLTOP #sltop ] ] >,
            CONT [ HOOK.--SLTOP #sltop,
		   HCONS <! !> ] ] ].

;; interest him in X
;;
empty_prep_non_trans_verb_min := synsem_min.
empty_prep_non_trans_verb := verb_synsem & prep_non_trans_subst & 
			     empty_prep_non_trans_verb_min &
			     empty_prep_trans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ OPT - ] >,
    LKEYS [ --OCOMPKEY #ocmin,
	    --+OCOMPKEY #ocmin ] ].


;; get-hold-of
;;
;empty_prep_nbar_verb := verb_synsem & prep_nbar_subst & 
;			     empty_prep_nbar_lt.


;; regard Kim as tall
np_as_verb_min := synsem_min.
np_as_verb := verb_synsem & np_comp_subst & basic_prd_comp_lt & 
	      np_as_verb_min &
	      obj_equi_inf_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ --MIN _as_p_sel_rel & #min,
			    --SIND event,
                            LOCAL.CAT.VAL.SUBJ *olist* ] >,
    LKEYS [ --OCOMPKEY #min,
            --+OCOMPKEY #min ] ].

;; strike Kim as tall
np_as_seq_verb_min := synsem_min.
np_as_seq_verb := verb_synsem & np_comp_subst & basic_prd_comp_lt &
		  np_as_seq_verb_min &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #index ] ],
                              #comp & 
                              [ --MIN _as_p_sel_rel & #min,
                                LOCAL.CONT.HOOK.XARG #sind ] >,
                      KCMP #comp ],
            CONT [ HOOK.XARG #sind,
                   HCONS <! [ HARG #arg2 ] !> ] ],
    LKEYS [ KEYREL arg12_relation & [ LBL #lbl,
				      ARG1 #index,
                                      ARG2 #arg2 ],
            --OCOMPKEY #min,
            --+OCOMPKEY #min ] ].

; DPF 4-Jun-01 - Changed dative-to to be contentful "to", in order to sustain
; 'underspecified' semantics for "kim sent it to Sandy/Paris".  Verbs like 
; "hand" are now of type empty_to_trans_verb.
; DPF 3-May-03 - But since then we've altered our views again, and are now
; treating "send" as taking an empty to-PP, so we do the same for derived
; to-datives as well.
  
empty_to_trans_verb_min := synsem_min.
empty_to_trans_verb := empty_prep_trans_verb &
		       empty_to_trans_verb_min &
  [ LKEYS.--OCOMPKEY _to_p_sel_rel ].

ditrans_verb_min := synsem_min.
ditrans_verb := verb_synsem & ditrans_subst & ditrans_lt & ditrans_verb_min.
  
ditrans_only_verb_min := synsem_min.
ditrans_only_verb := verb_synsem & ditrans_subst & ditrans_lt &
		     ditrans_only_verb_min &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

; 'elect him president'
ditrans_np_nbar_verb_min := synsem_min.
ditrans_np_nbar_verb := verb_synsem & ditrans_np_nbar_subst & arg1_subj_lt &
			ditrans_np_nbar_verb_min &
  [ LOCAL.CAT.VAL.COMPS 
                  < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #obj2ind & non_expl-ind &
					     [ SORT non-time-sort ] ],
		      OPT - ],
		    [ LOCAL.CONT.HOOK [ INDEX #objind & non_expl-ind ],
		      OPT - ], ... >,
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG1 non_expl-ind,
				     ARG2 #objind,
                                     ARG3 #obj2ind ] ].

; 'see picture, page 2.'
ditrans_nbar_np_verb_min := synsem_min.
ditrans_nbar_np_verb := verb_synsem & ditrans_nbar_np_subst & arg1_subj_lt &
			ditrans_nbar_np_verb_min &
  [ LOCAL.CAT [ HEAD.VFORM imp_vform,
		VAL.COMPS 
                  < [ LOCAL.CONT.HOOK.INDEX #obj2ind & non_expl-ind &
					     [ SORT non-time-sort ],
		      OPT - ],
		    [ LOCAL.CONT.HOOK 
				 [ LTOP #lbl,
				   INDEX #objind & non_expl-ind ] ], ... > ],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG1 non_expl-ind,
				     ARG2 #objind,
                                     ARG3 #obj2ind ] ].

; 'talk to Kim about Sandy'
; DPF 26-aug-04 - Counter-intuitively, constrain second complement to be
; noun-modifying PP, to avoid spurious ambiguity (at present) for e.g.
; 'they range from low prices to high prices'
double_pp_verb_min := synsem_min.
double_pp_verb := verb_synsem & double_pp_subst & double_pp_lt &
		  double_pp_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD
                                   < [ LOCAL.CAT.HEAD verb ] > ],
                          [ LOCAL.CAT.HEAD.MOD
                                   < [ LOCAL.CAT.HEAD noun ] > ] > ].

; Unwanted type if freer order of obliques- 'pay with a check for it"
double_pp_empty_pp_verb_min := synsem_min.
double_pp_empty_pp_verb := verb_synsem & double_pp_subst & 
			   double_pp_empty_pp_verb_min &
                           double_pp_empty_pp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ OPT - ] > ].

; 'change the meeting from Tuesday to Wednesday'
; 'pay the money to Browne for the ticket'
np_trans_double_pp_verb := verb_synsem & np_trans_double_pp_subst & 
                           arg12_double_pp_lt &
  [ LOCAL.CAT [ HEAD.MINORS.MIN #ocmin,
		VAL.COMPS < [ ], [ OPT + ], [ OPT - ] > ],
    LKEYS.--+OCOMPKEY #ocmin ].

np_trans_double_ppto_verb_min := synsem_min.
np_trans_double_ppto_verb := np_trans_double_pp_verb &
			     np_trans_double_ppto_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ ], [ ], 
			  [ LOCAL.CAT.HEAD.MINORS.MIN _to_p_sel_rel ] > ].

np_trans_double_ppfor_verb_min := synsem_min.
np_trans_double_ppfor_verb := np_trans_double_pp_verb &
			      np_trans_double_ppfor_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ], [ ], 
			  [ LOCAL.CAT.HEAD.MINORS.MIN _for_p_sel_rel ] > ].

; Raising verbs which take an infinitival complement restrict it to being
; [ MSG no_msg ], which ensures that the VP will be headed by the 
; non-propositional "to" complementizer, which identifies its handle with
; that of its VP complement.

ssr_verb_min := synsem_min.
ssr_verb := verb_synsem & ssr_inf_subst & basic_two_arg &
	    ssr_verb_min &
  [ LOCAL [ CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		      KCMP.LOCAL.CONT.HOOK.LTOP #chand ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !> ] ],
    LKEYS.KEYREL arg1_relation & #keyrel & [ ARG1 handle & #arghand ] ].

ssr_noimp_verb_min := synsem_min.
ssr_noimp_verb := ssr_verb &
		  ssr_noimp_verb_min &
  [ LOCAL.CAT.HEAD.VFORM fin_or_non_fin ].

; 'It started raining'
ssr_prp_verb_min := synsem_min.
ssr_prp_verb := verb_synsem & ssr_subst & prp_intrans_subst &
		ssr_prp_verb_min &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !> ] ],
    LKEYS.KEYREL arg1_relation & #keyrel & [ ARG1 handle & #arghand ] ].

ssr_pp_inf_verb_min := synsem_min.
ssr_pp_inf_verb := verb_synsem & ssr_pp_inf_subst & ssr_expr_lt &
		   ssr_pp_inf_verb_min &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT + ].


; It became obvious that Kim had arrived.
ssr_prdp_verb_min := synsem_min.
ssr_prdp_verb := verb_synsem & ssr_subst & prd_comp_lt & basic_two_arg & 
		 ssr_prdp_verb_min &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND it-ind ] >,
		      COMPS < synsem & #comp &
                              [ LOCAL [ CAT.HEAD v_or_a &
						 [ TAM [ TENSE no_tense,
							 ASPECT.PROGR - ] ],
                                        CONJ cnil ],
				OPT - ], ... >,
                      KCMP #comp ],
            CONT.HCONS <! [ HARG #arghand ] !> ],
    LKEYS [ KEYREL.ARG2 handle & #arghand ] ].

seq_prdp_pp_verb := verb_synsem & seq_prdp_pp_subst & seq_prdp_expr_lt.

seq_ap_pp_verb_min := synsem_min.
seq_ap_pp_verb := seq_prdp_pp_verb &
		  seq_ap_pp_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD basic_adj ], 
			  [ OPT + ] > ].

seq_pp_pp_verb_min := synsem_min.
seq_pp_pp_verb := seq_prdp_pp_verb &
		  seq_pp_pp_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep ], 
			  [ OPT + ] >,
    LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin ] ].

;; DPF 2011-09-25 - This type, only for `seem', was too restrictive with
;; COMPS..HEAD a_or_p, since it excludes lexical passives, such as in
;; |that seemed overdone|, so generalize to v_or_a_or_p, but PROGR -, to
;; still exclude present participles: |*he seemed laughing|
;; 
seq_aorp_pp_verb_min := synsem_min.
seq_aorp_pp_verb := seq_prdp_pp_verb &
		    seq_aorp_pp_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD v_or_a_or_p & [ TAM.ASPECT.PROGR -]],
			  [ OPT + ] > ].

seq_prdp_pp_about_verb_min := synsem_min.
seq_prdp_pp_about_verb := verb_synsem & seq_prdp_pp_subst & 
			  seq_prdp_pp_about_verb_min &
                          basic_seq_prdp_expr_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD v_or_a ], 
			  [ OPT + ] >,
    LKEYS.--OCOMPKEY _about_p_sel_rel ].

; DPF 13-may-09 - Restrict VP to be non-elliptical, to block spurious parse
; for "Kim was [shown to] herself.
;; DPF 2011-07-01 - Re 13-may-09: but this also blocks |he expects them to|.
;; And anyway, the parse with |shown to| is actually okay, given the raising
;; analysis of |shown|.
sor_verb_min := synsem_min.
sor_verb := verb_synsem & sor_inf_subst & sor_lt & sor_verb_min.

sor_psv_verb_min := synsem_min.
sor_psv_verb := sor_verb &
		sor_psv_verb_min &
  [ LOCAL verb_participle_affix &
	  [ CAT [ HEAD.VFORM pas,
		  VAL [ SUBJ < [ OPT - ] >,
			COMPS < [ OPT - ], ... > ] ],
	    CONT psoa & [ RELS <! relation !> ] ] ].

sorb_verb_min := synsem_min.
sorb_verb := verb_synsem & sor_bse_subst & sor_prop_lt & sorb_verb_min.

sor_non_trans_verb_min := synsem_min.
sor_non_trans_verb := verb_synsem & sor_inf_non_trans_subst & sor_lt &
		      sor_non_trans_verb_min.

sor_pp_inf_verb := verb_synsem & pp_inf_subst & basic_three_arg_subst
                   & sor_lt.

sor_prd_verb_min := synsem_min.
sor_prd_verb := verb_synsem & sor_prd_trans_subst & sor_lt &
		sor_prd_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ],
                          [ LOCAL.CAT prd_cat & [ HEAD adj ] ] > ].

sor_prd_nontrans_verb := verb_synsem & sor_prd_nontrans_subst & sor_lt.

subj_equi_prp_verb_min := synsem_min.
subj_equi_prp_verb := verb_synsem & prp_intrans_subst & 
		      subj_equi_prp_verb_min &
                      subj_equi_prp_or_bse_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT [ HEAD verb,
                                        VAL.SUBJ < pro_ss > ] ].

subj_equi_bse_verb_min := synsem_min.
subj_equi_bse_verb := verb_synsem & bse_intrans_subst &
		      subj_equi_bse_verb_min &
                      subj_equi_prp_or_bse_lt.

; 'go'
subj_equi_bse__or_n3sg_verb_min := synsem_min.
subj_equi_bse__or_n3sg_verb := subj_equi_bse_verb &
			       subj_equi_bse__or_n3sg_verb_min &
  [ LOCAL bse_or_non3sg_verb ].

; 'You need not stay'
subj_equi_bse_n3sg_verb_min := synsem_min.
subj_equi_bse_n3sg_verb := verb_synsem & bse_intrans_subst &
			   subj_equi_bse_n3sg_verb_min &
                           subj_equi_bse_n3sg_lt &
  [ LOCAL pres_verb & [ CAT.HEAD.VFORM fin ] ].

ssr_two_arg_verb_min := synsem_min.
ssr_two_arg_verb := ssr_two_arg_verb_min & ssr_two_arg_subst & aux_verb.

; "K became quiet"
;; DPF 2013-02-06 - Add COMPS..MOD..HEAD noun to avoid ambig of preps like
;; `to' with double entries.
;;
subj_prd_verb := verb_synsem & subj_control_subst &
                 basic_prd_comp_lt &
  [ LOCAL [ CAT.VAL [ COMPS < synsem & #comp &
                              [ LOCAL [ CAT.HEAD 
					    [ TAM [ TENSE no_tense,
						    ASPECT.PROGR - ],
					      MOD < [ LOCAL.CAT.HEAD noun ] > ],
					CONJ cnil ] ], ... >,
                      KCMP #comp ],
            CONT.HCONS <! [ HARG #arghand ] !> ],
    LKEYS [ KEYREL.ARG2 handle & #arghand ] ].

subj_equi_prd_verb_min := synsem_min.
subj_equi_prd_verb := subj_prd_verb & prd_comp_lt & basic_two_arg & 
                      subj_equi_lt & subj_equi_prd_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT basic_prd_cat ] > ].

#|
subj_equi_prd_nogap_verb_min := synsem_min.
subj_equi_prd_nogap_verb := subj_equi_prd_verb & subj_equi_prd_nogap_verb_min &
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem > ].
|#

subj_equi_prd_adj_verb_min := synsem_min.
subj_equi_prd_adj_verb := subj_equi_prd_verb &
			  subj_equi_prd_adj_verb_min &
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem &
                          [ OPT -,
                            LOCAL.CAT.HEAD adj,
			    --MIN norm_adj_rel ] > ].

subj_equi_prd_prep_verb_min := synsem_min.
subj_equi_prd_prep_verb := subj_equi_prd_verb &
			   subj_equi_prd_prep_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                            LOCAL.CAT.HEAD prep ] > ].

; "K got hired"
; DPF 3-Jul-03 - Need to block "*Kim got hiring" - seems to be same need to
; distinguish passive from pres-participle - group passive with A and P.
subj_equi_prd_v_a_verb_min := synsem_min.
subj_equi_prd_v_a_verb := subj_equi_prd_verb &
			  subj_equi_prd_v_a_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                            LOCAL.CAT.HEAD v_or_a ] > ].

; 'shows as empty'
subj_equi_empty_prep_verb_min := synsem_min.
subj_equi_empty_prep_verb := subj_prd_verb & s_equi_lt & basic_two_arg &
			     subj_equi_empty_prep_verb_min &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #index ] >,
                    COMPS < [ OPT -,
                              --MIN selected_rel,
                              LOCAL [ CAT [ HEAD prep,
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ] ],
                                      CONT.HOOK.INDEX #index ] ] > ] ].

; DPF 15-Apr-02 - Changed these to prd_non_trans_subst, since get spurious 
; ambiguity with alternate analysis of PrdP as adjunct, with right semantics in
; passive case.  
; DPF 13-Oct-03 - But that adjunct analysis gives the wrong semantics for
; "Kim was made angry" where we what result proposition, not state of Kim
; while she was made. So changing back to 

obj_equi_prd_verb_min := synsem_min.
obj_equi_prd_verb := verb_synsem & prd_trans_subst & obj_equi_prd_lt &
		     obj_equi_prd_verb_min & basic_three_arg_subst.

obj_equi_prd_adj_verb_min := synsem_min.
obj_equi_prd_adj_verb := obj_equi_prd_verb &
			 obj_equi_prd_adj_verb_min &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CAT.HEAD adj ] > ].

obj_equi_non_trans_prd_verb_min := synsem_min.
obj_equi_non_trans_prd_verb := verb_synsem & prd_non_trans_subst & 
			       obj_equi_non_trans_prd_verb_min &
			       obj_equi_prd_lt.

; 'I have X to get rid of'
; VFORM fin_or_non_fin prevents imperative "*Have Kim to get rid of." which
; led to spurious ambiguity.
obj_equi_vpslash_prd_verb_min := synsem_min.
obj_equi_vpslash_prd_verb := verb_synsem & basic_inf_non_trans_subst & 
			     obj_equi_vpslash_prd_verb_min &
                             tough_three_arg & arg1_subj_lt &
  [ LOCAL [ CAT [ HEAD.VFORM fin_or_non_fin,
                  VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #ind & non_expl-ind ],
				OPT - ],
                              [ LOCAL.CONT [ HOOK [ LTOP #vltop,
                                                    XARG #xarg ] ],
                                NONLOC.SLASH <! [ CAT np_cat_nonnom_min &
                                                      [ HEAD.MOD < > ],
                                                CONT.HOOK.INDEX #ind ] !> ] >],
            CONT [ HOOK.XARG #xarg,
		   RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #mltop,
                                    LARG #vltop ] !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ LBL #lbl,
					       ARG1 non_expl-ind,
					       ARG2 #ind,
					       ARG3 #mltop ] ].


; ERB (07-10-96) I am working with the verb 'know' as a prototype for a verb
; that selects by the semantic type (for now expressed as a feature) of its
; sentential complement rather than by the value of CMP or some such hack.  In
; order to do so, I have changed the types around here.  In particular, I am
; adding a new type cp_prop+ques_intrans_verb that takes a sentential
; complement but doesn't care if its a proposition or a question (for verbs
; like 'know').  A further axis of variation is the VFORM of the complement
; (fin vs. inf).  Since my analysis of 'know' never makes use of the resolved
; subtypes (e.g., cp_prop_intrans_verb) I am not adding to the resolved
; subtypes, and just making the old ones inherit from the finite side of
; things for now.  The future inf_cp_prop_intrans_verb will probably be the
; type of subject equi verbs. A further future modification would involve the
; addition of cp_command_intrans_verb and cp_command+prop_intrans_verb for
; verbs like 'insist'.
;
; DPF (19-Jun-98) This type cannot itself simply add the complement CP's 
; (underspecified) message to its RELS, since the generation algorithm requires
; that no relation on RELS will ever get more specialized during parsing.  So 
; we make MSG be list-valued (the empty list for all but complementizers
; and clauses), and have the Head-Complement rule append the values of MSG
; from both of its daughters, since the msg comes from the head if it's a
; complementizer, and from the non-head if the head is a verb.

basic_cp_prop+ques_verb := norm_basic_verb_synsem &
  [ LOCAL [ CAT.VAL.KCMP [ LOCAL.CAT.HEAD verbal,
                           OPT - ],
            CONT.RELS.LIST < relation, ... > ] ].

;; DPF 2011-jun-11 - For all but the base-subjunctive-CP-taking verbs, 
;; add in the agreement constraints to distinguish base from non3sg verbs.
;;
norm_cp_prop+ques_verb := basic_cp_prop+ques_verb & verb_synsem &
			  cp_addin_tam_pn.

cp_prop+ques_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.--SIND [ E.MOOD ind_or_modal_subj,
                                SF prop-or-ques ] ].

fin_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_fin_unspec ].

fin_cp_prop+ques_unspec_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT s_cat_unspec &
				   [ HEAD.VFORM fin_or_imp ],
			 --SIND.E.MOOD ind_or_modal_subj ] ].

fin_or_inf_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT basic_s_cat_fin_or_inf_v_c ].

cp_like_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT s_cat_fin_v_c & [ HEAD comp ],
                         --SIND.SF like-iforce ] ].

;; DPF 2011-jun-11 - Note that embedded filler-head clauses fail to parse as
;; complements of these verbs (|we demand that Kim, they admire|), since
;; the filler-head rule imposes the add-in constraints which preclude a
;; base-form VP.  To fix, would have to distinguish main-clause from
;; non-main-clause non-WH filler-heads (or abandon this collapsing of 
;; verb forms).  FIX someday?
;;
bse_cp_verb := basic_cp_prop+ques_verb & verb_synsem &
  [ LOCAL.CAT.VAL.KCMP canonical_synsem & [ LOCAL.CAT s_cat_bse ] ].

;; DPF 4/21/98 - Moved [ COMPS.FIRST.LOCAL.CAT.MC - ] from cp_ques_intrans_verb
;; to cp_intrans_verb, to block spurious parse for e.g. "Kim knows who left"

basic_cp_intrans_verb := fin_cp_prop+ques_verb & cp_intrans_subst & 
			 basic_two_arg & arg12h_lt.

cp_intrans_verb_min := synsem_min.
cp_intrans_verb := basic_cp_intrans_verb & cp_intrans_verb_min.

cp_intrans_verb_comp_min := synsem_min.
cp_intrans_verb_comp := cp_intrans_verb & cp_intrans_verb_comp_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp ] > ].

#|
cp_intrans_invable_verb_min := synsem_min.
cp_intrans_invable_verb := basic_cp_intrans_verb & cp_comp_verb &
			   cp_intrans_invable_verb_min.
|#

cp_like_intrans_verb_min := synsem_min.
cp_like_intrans_verb := cp_like_verb & cp_intrans_subst & basic_two_arg &
                        arg12h_lt & cp_like_intrans_verb_min &
  [ LOCAL.CAT.VAL.COMPS 
                   < canonical_synsem &
                     [ --SIND.SF like-iforce ] > ].
; Type for inputs to cp_passive lexical rule
cp_passivable_verb := norm_basic_verb_synsem.

; Type for inputs to inverted_quote_lr for "Kim arrived, said Abrams"
cp_comp_verb := norm_basic_verb_synsem.

basic_cp_fin_inf_intrans_verb := fin_or_inf_cp_prop+ques_verb & 
			   basic_cp_intrans_subst & basic_two_arg & arg12h_lt &
			   cp_passivable_verb & cp_comp_verb.

cp_fin_inf_intrans_verb_min := synsem_min.
cp_fin_inf_intrans_verb := basic_cp_fin_inf_intrans_verb & cp_intrans_subst &
			   cp_fin_inf_intrans_verb_min.

;; 'ask', allowing main clause question complements
;; FIX: generalize to other verbs, but still block extraction out of 
;; complement WH-clauses, as in |who did they ask arrived?|, while allowing
;; extraction of the whole clause, as in |who arrived, they asked?|
;;
basic_cp_ques_fin_inf_intrans_verb_min := synsem_min.
basic_cp_ques_fin_inf_intrans_verb := basic_cp_fin_inf_intrans_verb &
				      basic_cp_ques_fin_inf_intrans_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ *anti_list*,
                            --SIND.SF ques ] > ].

; 'wonder'
cp_ques_fin_inf_intrans_verb_min := synsem_min.
cp_ques_fin_inf_intrans_verb := basic_cp_ques_fin_inf_intrans_verb &
				cp_intrans_subst & 
				cp_ques_fin_inf_intrans_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < >,
			    NONLOC.SLASH 0-dlist ] > ].

cp_intrans_passivable_verb := cp_intrans_verb & cp_passivable_verb &
			      cp_comp_verb.

cp_prop_intrans_verb_min := synsem_min.
cp_prop_intrans_verb := cp_intrans_passivable_verb & cp_prop_intrans_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND.SF basic-prop ] > ].

cp_prop_intrans_nfin_verb_min := synsem_min.
cp_prop_intrans_nfin_verb := cp_prop_intrans_verb & 
			     cp_prop_intrans_nfin_verb_min &
  [ LOCAL.CAT.HEAD [ VFORM bse,
		     TAM [ TENSE present,
			   MOOD indicative ] ] ].

cp_only_prop_intrans_verb_min := synsem_min.
cp_only_prop_intrans_verb := cp_intrans_passivable_verb &
			     cp_only_prop_intrans_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp,
                            --SIND.SF basic-prop ] > ].

cp_ques_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < >,
                            --SIND.SF ques ] > ].

;; suppose
cp_prop_raise_key_verb_min := synsem_min.
cp_prop_raise_key_verb := basic_cp_prop+ques_verb & cp_intrans_subst & 
                          basic_two_arg & arg12h_lt & cp_passivable_verb &
                          cp_comp_verb & cp_prop_raise_key_verb_min &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                  VAL [ KCMP.LOCAL.CAT s_cat_fin_unspec &
                                       [ HEAD.INV - ],
                        COMPS < [ --MIN #min,
                                  LOCAL [ CONT.HOOK.INDEX.SF basic-prop,
                                          AGR #agr ],
                                  OPT - ] > ] ],
            CONT.RELS <! relation !>,
            AGR #agr ] ].

cp_prop_raise_key_3sg_verb_min := synsem_min.
cp_prop_raise_key_3sg_verb := cp_prop_raise_key_verb &
			      cp_prop_raise_key_3sg_verb_min &
  [ LOCAL fin_verb & [ CAT [ HEAD.TAM indic_tam & 
				      [ TENSE nonpast,
					ASPECT no_aspect ],
			     VAL.SUBJ < [ LOCAL.AGR.PNG.PN 3s ] > ] ] ].

cp_prop_raise_key_n3sg_verb_min := synsem_min.
cp_prop_raise_key_n3sg_verb := cp_prop_raise_key_verb &
			       cp_prop_raise_key_n3sg_verb_min &
  [ LOCAL fin_verb & [ CAT [ HEAD.TAM indic_tam & 
				      [ TENSE nonpast,
					ASPECT no_aspect ],
			     VAL.SUBJ < [ LOCAL.AGR.PNG.PN -3s ] > ] ] ].

cp_prop_raise_key_pst_verb_min := synsem_min.
cp_prop_raise_key_pst_verb := cp_prop_raise_key_verb &
			      cp_prop_raise_key_pst_verb_min &
  [ LOCAL past_or_subj_verb ].

cp_prop_raise_key_prp_verb_min := synsem_min.
cp_prop_raise_key_prp_verb := cp_prop_raise_key_verb &
			      cp_prop_raise_key_prp_verb_min &
  [ LOCAL prp_verb ].

cp_prop_raise_key_psp_verb_min := synsem_min.
cp_prop_raise_key_psp_verb := cp_prop_raise_key_verb &
			      cp_prop_raise_key_psp_verb_min &
  [ LOCAL psp_verb ].

; Make lexical entries inflected (manual entries for each form, sigh) since 
; can't use inflectional rules to do it since they constrain AGR which is 
; here instead identified with complement's AGR.
v_cp_prop_raise_key_lexent := main_verb_sans_key & 
  [ INFLECTD +,
    SYNSEM cp_prop_raise_key_verb ].

;; tell Kim that/whether S
;; inform Kim that S
np_trans_cp_verb_min := synsem_min.
np_trans_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &
		    np_trans_cp_verb_min.

np_trans_cp_fin_or_inf_verb_min := synsem_min.
np_trans_cp_fin_or_inf_verb := fin_or_inf_cp_prop+ques_verb & cp_trans_subst & 
                               cp_trans_lt & np_trans_cp_fin_or_inf_verb_min &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_fin_or_inf_v_c ].

;; bet Kim ten cents that S
np_np_cp_verb_min := synsem_min.
np_np_cp_verb := fin_cp_prop+ques_verb & np_np_cp_subst & tritrans_lt &
		 np_np_cp_verb_min.

#|
;; explain to Kim that S
;; DPF 16-jul-2010 - Maybe all pp_cp_verbs take finite complements?
;;
pp_cp_verb := cp_prop+ques_verb & pp_cp_subst & pp_cp_lt & cp_passivable_verb &
              cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND non_expl-ind ], 
			  synsem > ].
|#

basic_pp_cp_fin_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
                  cp_passivable_verb & cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND non_expl-ind ],
                          synsem > ].

pp_cp_fin_prop_verb_min := synsem_min.
pp_cp_fin_prop_verb := basic_pp_cp_fin_verb & pp_cp_fin_prop_verb_min &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT + ],
			    [ LOCAL.CAT.HEAD verbal,
			      --SIND.SF prop ] >,
	    CONT.RELS <! relation !> ] ].

pp_cp_fin_pq_verb_min := synsem_min.
pp_cp_fin_pq_verb := basic_pp_cp_fin_verb &
		     pp_cp_fin_pq_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ],
			  [ --SIND.SF prop-or-ques ] > ].

pp*_cp_fin_verb_min := synsem_min.
pp*_cp_fin_verb := basic_pp_cp_fin_verb &
		   pp*_cp_fin_verb_min &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT + ].

pp_cp_fin_verb_min := synsem_min.
pp_cp_fin_verb := basic_pp_cp_fin_verb &
		  pp_cp_fin_verb_min &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

pp_cp_fin_unspec_verb_min := synsem_min.
pp_cp_fin_unspec_verb := fin_cp_prop+ques_unspec_verb & basic_pp_cp_subst & 
			 pp_cp_fin_unspec_verb_min &
			 pp_cp_lt & cp_passivable_verb & cp_comp_verb &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT +,
			      --SIND non_expl-ind ],
			    [ LOCAL.CAT.HEAD verbal ] >,
	    CONT.RELS <! relation !> ] ].

pp_expl_cp_verb_min := synsem_min.
pp_expl_cp_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
		   pp_expl_cp_verb_min &
                   cp_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND it-ind,
			    OPT - ], 
			  synsem > ].

;; ask Kim whether S
;; Changed COMPS..SUBJ < > to SUBJ *antilist* to allow embedded inverted
;; clauses, as in |Kim asked, where are they|
np_trans_cp_ques_verb_min := synsem_min.
np_trans_cp_ques_verb := fin_cp_prop+ques_verb & basic_cp_trans_subst & 
			cp_trans_lt & cp_comp_verb & np_trans_cp_ques_verb_min &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL [ CAT [ VAL.SUBJ *anti_list*,
						  MC bool ],
                                            CONT.HOOK.INDEX.SF ques ] ]> ].

;; persuade Kim that S
np_trans_cp_prop_verb_min := synsem_min.
np_trans_cp_prop_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &
			 np_trans_cp_prop_verb_min &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
			  [ --SIND.SF basic-prop ] > ].

;; ask that Kim be released
cp_bse_intrans_verb_min := synsem_min.
cp_bse_intrans_verb := bse_cp_verb & basic_cp_intrans_subst & basic_two_arg &
                       arg12h_lt & cp_passivable_verb & cp_bse_intrans_verb_min.

;; wish that he were here.
cp_sbjnct_intrans_verb_min := synsem_min.
cp_sbjnct_intrans_verb := norm_cp_prop+ques_verb & cp_intrans_subst &
			  basic_two_arg & arg12h_lt & cp_passivable_verb &
			  cp_sbjnct_intrans_verb_min &
  [ LOCAL.CAT.VAL.KCMP [ --SIND.E.MOOD subjunctive,
			 LOCAL.CAT.HEAD.VFORM fin ] ].

;; try to
subj_equi_verb_min := synsem_min.
subj_equi_verb := cp_prop+ques_verb & inf_intrans_subst & basic_two_arg & 
                  subj_equi_inf_lt & subj_equi_verb_min.

; refrain from Ving
subj_equi_from_verb_min := synsem_min.
subj_equi_from_verb := cp_prop+ques_verb & inf_intrans_from_subst & 
                       basic_two_arg & subj_equi_inf_lt &
		       subj_equi_from_verb_min.

;; try and find it
;; Allow "I/you/we/they try and find it" but block "*He tries and find it"
;; but allow "I/you/we/they/he will try and find it" and "Try and find it".
subj_equi_and_verb := cp_prop+ques_verb & inf_intrans_and_subst & 
                      basic_two_arg & subj_equi_inf_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
            CONT.HOOK.INDEX.E.ASPECT no_aspect ],
    LKEYS [ --COMPKEY #cmin,
            --+COMPKEY #cmin ] ].

subj_equi_and_fin_verb_min := synsem_min.
subj_equi_and_fin_verb := subj_equi_and_verb &
			  subj_equi_and_fin_verb_min &
  [ LOCAL [ CAT.HEAD.VFORM fin,
	    AGR.PNG.PN -3s ] ].

subj_equi_and_bse_verb_min := synsem_min.
subj_equi_and_bse_verb := subj_equi_and_verb &
			  subj_equi_and_bse_verb_min &
  [ LOCAL.CAT.HEAD.VFORM bse ].

;; couldn't help but notice
subj_equi_but_verb_min := synsem_min.
subj_equi_but_verb := cp_prop+ques_verb & inf_intrans_but_subst & 
		      subj_equi_but_verb_min &
                      basic_two_arg & subj_equi_inf_lt &
  [ LOCAL [ CAT [ HEAD.VFORM bse,
		  VAL.COMPS < [ OPT - ] > ],
            CONT.HOOK.INDEX.E.ASPECT no_aspect ],
    LKEYS [ --COMPKEY #cmin,
            --+COMPKEY #cmin ] ].

;; have yet to find it
ssr_particle_verb_min := synsem_min.
ssr_particle_verb := verb_synsem & inf_intrans_particle_subst & 
		     ssr_particle_verb_min &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min & v_event_rel,
                  VAL [ SUBJ < [ --SIND #sind ] >,
                        COMPS < [ OPT - ],
                                [ --MIN #min,
                                  LOCAL [ CAT.HEAD verbal & [ INV - ],
                                          CONT.HOOK [ LTOP #cltop,
                                                      XARG #sind ] ],
                                  OPT - ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
                          XARG #sind ],
                   RELS <! [ LBL #ltop,
                             PRED #pred,
                             ARG1 #argh,
			     CFROM #cfrom, CTO #cto ] !>,
                   HCONS <! qeq & [ HARG #argh,
                                    LARG #cltop ] !> ] ],
    LKEYS.KEYREL [ PRED #pred,
		   CFROM #cfrom, CTO #cto ] ].

;; tell, persuade
obj_equi_verb_min := synsem_min.
obj_equi_verb := cp_prop+ques_verb & inf_trans_subst & obj_equi_inf_lt &
		 obj_equi_verb_min.

;; get: 'Kim got abrams to stay'
obj_equi_non_trans_verb_min := synsem_min.
obj_equi_non_trans_verb := cp_prop+ques_verb & inf_non_trans_subst & 
			   obj_equi_non_trans_verb_min &
			   obj_equi_inf_lt &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

;; help
obj_equi_bse_verb_min := synsem_min.
obj_equi_bse_verb := verb_synsem & sor_bse_subst & obj_equi_bse_lt &
		     obj_equi_bse_verb_min.


;; appeal, intend
oeq_pp_inf_verb_min := synsem_min.
oeq_pp_inf_verb := verb_synsem & pp_inf_subst & basic_three_arg & 
		   oeq_pp_inf_verb_min &
                   obj_equi_inf_lt & empty_prep_intrans_lt.

;; listened to him sing
oeq_pp_bse_verb_min := synsem_min.
oeq_pp_bse_verb := verb_synsem & basic_pp_vp_subst & basic_three_arg & 
		   oeq_pp_bse_verb_min &
		   unsat_three_arg_subst &
                   obj_equi_bse_lt & empty_prep_intrans_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT vp_bse_cat ].


;; gear up the team to ...
particle_oeq_verb_min := synsem_min.
particle_oeq_verb := cp_prop+ques_verb & particle_oeq_subst & four_arg &
		     particle_oeq_verb_min &
                     particle_oeq_lt.

;; arrange with kim to meet
pp_inf_seq_verb_min := synsem_min.
pp_inf_seq_verb := cp_prop+ques_verb & pp_inf_subst & basic_three_arg & 
		   pp_inf_seq_verb_min &
                   pp_inf_seq_lt.

; promise
anom_equi_verb_min := synsem_min.
anom_equi_verb := cp_prop+ques_verb & inf_non_trans_subst & anom_equi_lt &
		  anom_equi_verb_min.

; use X to do Y
anom_equi_trans_verb_min := synsem_min.
anom_equi_trans_verb := cp_prop+ques_verb & inf_trans_subst & anom_equi_lt &
			anom_equi_trans_verb_min &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

; take too long to do X
anom_equi_oblig_verb_min := synsem_min.
anom_equi_oblig_verb := anom_equi_verb &
			anom_equi_oblig_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
                          [ --MIN non_ellipt_rel ] > ].

; have trouble sleeping
anom_equi_prp_verb_min := synsem_min.
anom_equi_prp_verb := verb_synsem & prp_non_trans_subst & obj_equi_prp_lt &
		      anom_equi_prp_verb_min.

; prevent X from Ving
obj_equi_from_verb_min := synsem_min.
obj_equi_from_verb := cp_prop+ques_verb & inf_trans_from_subst & 
		      obj_equi_from_verb_min &
                      obj_equi_inf_lt.

particle_inf_verb_min := synsem_min.
particle_inf_verb := cp_prop+ques_verb & particle_inf_subst & 
		     particle_inf_verb_min &
		     anom_equi_particle_lt.

particle_prp_verb_min := synsem_min.
particle_prp_verb := verb_synsem & particle_prp_subst & 
		     particle_prp_verb_min &
		     subj_equi_prp_or_bse_lt.

particle_cp_verb_min := synsem_min.
particle_cp_verb := fin_cp_prop+ques_verb & particle_cp_subst & 
		    particle_cp_verb_min &
		    particle_cp_lt & cp_passivable_verb.

particle_pp_cp_verb_min := synsem_min.
particle_pp_cp_verb := fin_cp_prop+ques_verb & particle_pp_cp_subst & 
		       particle_pp_cp_verb_min &
		       particle_pp_cp_lt & cp_passivable_verb.

basic_expl_it_subj_pp_cp_verb := norm_cp_prop+ques_verb & expl_pp_cp_subst & 
				 expl_it_subj_pp_cp_lt.

basic_expl_it_subj_ppto_cp_verb := basic_expl_it_subj_pp_cp_verb &
  [ LKEYS.--COMPKEY _to_p_sel_rel ].

expl_it_subj_pp*_cp_verb_min := synsem_min.
expl_it_subj_pp*_cp_verb := basic_expl_it_subj_ppto_cp_verb &
			    expl_it_subj_pp*_cp_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ], 
			  [ LOCAL.CONT.HOOK.INDEX.SF basic-prop ] > ].

expl_it_subj_pp_cp_verb_min := synsem_min.
expl_it_subj_pp_cp_verb := basic_expl_it_subj_ppto_cp_verb &
			   expl_it_subj_pp_cp_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ LOCAL.CONT.HOOK.INDEX.SF prop-or-like ] > ].

expl_it_subj_pp_cp_like_verb_min := synsem_min.
expl_it_subj_pp_cp_like_verb := basic_expl_it_subj_ppto_cp_verb &
				expl_it_subj_pp_cp_like_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ], 
			  [ LOCAL [ CAT.HEAD comp,
				    CONT.HOOK.INDEX.SF like-iforce ] ] > ].

expl_it_subj_pp_cp_unsp_verb_min := synsem_min.
expl_it_subj_pp_cp_unsp_verb := basic_expl_it_subj_ppto_cp_verb &
				expl_it_subj_pp_cp_unsp_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ], 
			  [ LOCAL.CONT.HOOK.INDEX.SF prop-or-ques ] > ].

expl_it_subj_ppnoto_cp_verb_min := synsem_min.
expl_it_subj_ppnoto_cp_verb := basic_expl_it_subj_pp_cp_verb &
			       expl_it_subj_ppnoto_cp_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ LOCAL.CONT.HOOK.INDEX.SF prop-or-like ] > ].

expl_it_subj_np_cp_verb_min := synsem_min.
expl_it_subj_np_cp_verb := norm_cp_prop+ques_verb & expl_np_cp_subst & 
			   expl_it_subj_np_cp_verb_min &
                           expl_it_subj_np_cp_lt.

; To admit e.g. "That Kim lost suggests that Sandy won.", where CP-subjects
; normally come from VPs with a CP-gap and an expletive-it subject.
; 
expl_it_subj_cp_cp_verb_min := synsem_min.
expl_it_subj_cp_cp_verb := norm_cp_prop+ques_verb & expl_cp_cp_subst & 
			   expl_it_subj_cp_cp_verb_min &
                           expl_it_subj_cp_cp_lt.

; 'It costs me ten dollars for you to enter'
expl_it_subj_np_np_cp_inf_verb_min := synsem_min.
expl_it_subj_np_np_cp_inf_verb := norm_cp_prop+ques_verb & 
				  expl_it_subj_np_np_cp_inf_verb_min &
                          expl_np_np_cp_inf_subst & expl_it_subj_np_np_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ], 
			  [ OPT + ],
			  [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].

expl_it_subj_np_np_vp_inf_verb_min := synsem_min.
expl_it_subj_np_np_vp_inf_verb := norm_cp_prop+ques_verb & 
				  expl_it_subj_np_np_vp_inf_verb_min &
                          expl_np_np_cp_inf_subst & expl_it_subj_np_np_vp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ ], [ ], [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].

; `it makes him angry that S'
expl_it_subj_np_prdp_cp_verb_min := synsem_min.
expl_it_subj_np_prdp_cp_verb := norm_cp_prop+ques_verb & 
				expl_it_subj_np_prdp_cp_verb_min &
			 expl_np_np_prdp_cp_subst & expl_it_subj_np_prdp_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ OPT -,
			    LOCAL.CAT.HEAD adj ],
			  [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].


; `it makes him the winner that S'
expl_it_subj_np_np_cp_verb_min := synsem_min.
expl_it_subj_np_np_cp_verb := norm_cp_prop+ques_verb & 
			      expl_it_subj_np_np_cp_verb_min &
                          expl_np_np_cp_subst & expl_it_subj_np_np_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ OPT - ],
			  [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].


; `it matters a lot to him that S'
expl_it_subj_np_pp_cp_verb_min := synsem_min.
expl_it_subj_np_pp_cp_verb := norm_cp_prop+ques_verb & 
			      expl_it_subj_np_pp_cp_verb_min &
			 expl_np_pp_cp_subst & expl_it_subj_np_np_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ OPT +,
			    --MIN _to_p_sel_rel ],
			  [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].


expl_it_subj_prtcl_cp_verb_min := synsem_min.
expl_it_subj_prtcl_cp_verb := norm_cp_prop+ques_verb & expl_prtcl_cp_subst & 
			      expl_it_subj_prtcl_cp_verb_min &
                              expl_it_subj_prtcl_cp_lt.

expl_it_subj_cp_verb_min := synsem_min.
expl_it_subj_cp_verb := norm_cp_prop+ques_verb & expl_cp_subst & 
			expl_it_subj_cp_verb_min &
                        expl_it_subj_cp_lt.

expl_it_subj_vp_verb_min := synsem_min.
expl_it_subj_vp_verb := norm_cp_prop+ques_verb & expl_vp_subst & 
			expl_it_subj_vp_verb_min &
                        expl_it_subj_cp_lt.

expl_pp_inf_oeq_verb_min := synsem_min.
expl_pp_inf_oeq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_oeq_verb_min &
			expl_pp_inf_oeq_lt.

expl_pp_inf_seq_verb_min := synsem_min.
expl_pp_inf_seq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_seq_verb_min &
			expl_pp_inf_seq_lt.

atrans_inf_verb_min := synsem_min.
atrans_inf_verb := cp_prop+ques_verb & inf_intrans_subst & basic_two_arg & 
		   atrans_inf_lt & atrans_inf_verb_min.

for_to_verb_min := synsem_min.
for_to_verb := verb_synsem & for_inf_intrans_subst & basic_two_arg & arg12h_lt &
	       for_to_verb_min.

particle_verb_min := synsem_min.
particle_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
		 particle_verb_min &
  [ LOCAL [ CAT.VAL.COMPS < *top* >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].

; 'going on'
particle_3only_verb_min := synsem_min.
particle_3only_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
		       particle_3only_verb_min &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND.PNG.PN 3 ] >,
		      COMPS < *top* > ],
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].

generic_particle_NP_verb := verb_synsem & particle_NP_subst & particle_NP_lt.

generic_NP_particle_verb := verb_synsem & generic_NP_particle_subst & 
                            NP_particle_lt.

np_particle_verb_min := synsem_min.
NP_particle_verb := generic_NP_particle_verb & NP_particle_subst &
		    np_particle_verb_min.

; 'credit back the money to the account'
NP_particle_pp_verb := generic_NP_particle_verb & NP_particle_pp_subst &
                       NP_particle_pp_lt &
  [ LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin,
	    --OCOMPKEY #ocmin,
	    --+OCOMPKEY #ocmin ] ].

np_particle_ppto_verb_min := synsem_min.
NP_particle_ppto_verb := NP_particle_pp_verb &
			 np_particle_ppto_verb_min &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _to_p_sel_rel ]> ].

np_particle_ppof_verb_min := synsem_min.
NP_particle_ppof_verb := NP_particle_pp_verb &
			 np_particle_ppof_verb_min &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _of_p_sel_rel ]> ].

np_particle_ppfor_verb_min := synsem_min.
NP_particle_ppfor_verb := NP_particle_pp_verb &
			  np_particle_ppfor_verb_min &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _for_p_sel_rel ]> ].

np_particle_ppfrom_verb_min := synsem_min.
NP_particle_ppfrom_verb := NP_particle_pp_verb &
			   np_particle_ppfrom_verb_min &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _from_p_sel_rel ]> ].

; 'give him back his dog'
np_particle_np_verb_min := synsem_min.
NP_particle_np_verb := generic_NP_particle_verb & NP_particle_np_subst &
		       np_particle_np_verb_min &
                       NP_particle_np_lt.

; `make up her mind to leave'
; `make up her mind that she would leave'
np_particle_cp_verb_min := synsem_min.
NP_particle_cp_verb := generic_NP_particle_verb & NP_particle_cp_subst &
		       np_particle_cp_verb_min &
                       NP_particle_cp_lt.

np_particle_noalt_verb_min := synsem_min.
NP_particle_noalt_verb := NP_particle_verb & np_particle_noalt_verb_min.

particle_prd_verb_min := synsem_min.
particle_prd_verb := verb_synsem & particle_prd_subst & anom_equi_prd_lt &
		     particle_prd_verb_min.

particle_pp_verb_min := synsem_min.
particle_pp_verb := verb_synsem & particle_pp_subst & 
		    particle_pp_verb_min &
		    prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CAT pp_cat,
				    OPT - ] >,
    LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin,
	    --OCOMPKEY #ocmin,
	    --+OCOMPKEY #ocmin ] ].

particle_empty_pp_verb_min := synsem_min.
particle_empty_pp_verb := verb_synsem & particle_pp_subst & 
			  particle_empty_pp_verb_min &
                          empty_prep_particle_intrans_lt.

; prefer it if ...
expl_obj_cp_verb_min := synsem_min.
expl_obj_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & expl_obj_cp_lt &
		    expl_obj_cp_verb_min &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

expl_obj_cpcmp_verb_min := synsem_min.
expl_obj_cpcmp_verb := expl_obj_cp_verb & expl_obj_cpcmp_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL [ CAT.HEAD comp,
					 CONT.HOOK.INDEX.SF prop ] ] >,
    LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin ] ].

expl_obj_cpprop_verb_min := synsem_min.
expl_obj_cpprop_verb := expl_obj_cp_verb & expl_obj_cpprop_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].


; make it clear that ...
; This type should be redundant with the sor_prd_verb type, but CP-taking
; adjs constrain their MOD..HEAD to be no_head (for some doubtless good
; reason), so they won't unify with the prd_cat constraint on the second
; complement of sor_prd_verbs.  FIX? ...

expl_obj_prd_verb_min := synsem_min.
expl_obj_prd_verb := verb_synsem & sor_prd_trans_subst & expl_obj_prdp_lt &
		     expl_obj_prd_verb_min &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND it-ind,
                            OPT - ], 
                          [ LOCAL.CAT.HEAD adj ] > ].

; 'i am doing fine/badly/well', but also 'how are you doing?'
adv_verb_min := synsem_min.
adv_verb := verb_synsem & adv_subst & arg1_subj_lt & two_arg &
	    adv_verb_min &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].

; 'he put it very well'
np_adv_verb_min := synsem_min.
np_adv_verb := verb_synsem & np_adv_subst & trans_lt &
	       np_adv_verb_min &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ], [ OPT - ] >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel ].

; Inverted verbs of saying: "Kim left, said Sandy"
; DPF 2011-jan-07 - Added constraint [POSTHD -] to block these inverted 
; sentences from being admitted as that-less relatives, as in
; |*the [cats [said Kim purred]] arrived| (contrast with |the cats Kim said 
; purred arrived| 
;; DPF 2014-05-20 - Changed SPR < > to SPR *anti_list* so we can get post
;; modification of the inverted phrase, as in |we arrived, said Kim yesterday|
;;
quoting_verb_inv_synsem_min := synsem_min.
quoting_verb_inv_synsem := basic_two_arg & quoting_verb_inv_synsem_min &
  [ LOCAL [ CAT [ HEAD verb & 
                       [ VFORM fin,
                         TAM #tam ],
		  POSTHD -,
                  VAL [ SUBJ *anti_list*,
			SPR *anti_list* ] ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #event & [ E #tam ] ],
                   RELS.LIST < #keyrel, ... > ],
            CONJ cnil ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     ARG0 #event ] ].

; DPF 13-May-02 - Made passive_synsem inherit from basic_verb_synsem rather
; than verb_synsem since we don't want it to be subtype of lex_synsem, since
; simple passives can be post-nominal modifiers, as in "the price quoted is
; too high"
; DPF 04-sep-09 - Make SUBJ synsem instead of synsem_min, to distinguish
; passive VPs from CPs.

basic_passive_synsem := norm_verb_synsem & passive_or_unacc_synsem & 
                        lex_synsem &
  [ LOCAL [ CAT [ HEAD [ AUX -,
                         VFORM pas ],
                  VAL [ SUBJ < synsem &
                               [ LOCAL [ CAT nomp_cat_min,
					 CONT.HOOK.INDEX #ind,
                                         CONJ cnil ],
                                 --SIND #ind & basic_non_event ] >] ],
            CONJ cnil ] ].

passive_synsem := basic_passive_synsem &
  [ LOCAL.CAT.VAL.COMPS *obliquecons* &
                        < synsem & 
                          [ --MIN _by_p_cm_rel,
                            LOCAL local &
                                  [ CAT [ HEAD prep,
                                          VAL [ SUBJ < >,
                                                SPR *olist*,
                                                COMPS < > ] ] ],
                            NONLOC.REL 0-dlist,
                            OPT + ], ... > ].

passive_atrans_synsem_min := synsem_min.
passive_atrans_synsem := passive_synsem & atrans_lt & 
			 passive_atrans_synsem_min &
  [ LOCAL.CAT.VAL.SUBJ < synsem > ].

basic_passive_unerg_synsem := passive_synsem & basic_two_arg &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --MIN nom_or_mnp_rel,
                               --SIND #sindex & basic_non_expl ] >,
                      COMPS < [ --SIND #cindex ] > ],
            CONT [ HOOK [ INDEX #index,
                          XARG #sindex ],
                   RELS.LIST < #keyrel &
			       [ LBL #lbl,
				 ARG0 #index,
                                 ARG1 #cindex,
                                 ARG2 #sindex ], 
			       #alt2keyrel &
			       [ LBL #lbl,
				 PRED parg_d_rel,
				 ARG0 event & [ E.TENSE no_tense ],
				 ARG1 #index,
				 ARG2 #sindex ], ... > ] ],
    LKEYS [ KEYREL #keyrel,
	    ALT2KEYREL #alt2keyrel ] ].

; born
passive_unerg_synsem_min := synsem_min.
passive_unerg_synsem := basic_passive_unerg_synsem &
			passive_unerg_synsem_min &
  [ LOCAL.CONT [ HOOK.LTOP #ltop,
                 RELS <! [ LBL #ltop ], relation !>,
		 HCONS <! !> ] ].

; unevaluated
passive_unerg_neg_synsem_min := synsem_min.
passive_unerg_neg_synsem := basic_passive_unerg_synsem &
			    passive_unerg_neg_synsem_min &
  [ LOCAL [ CAT.MC na,
            CONT [ HOOK.LTOP #ltop,
                   RELS <! [ LBL #lbl ], 
			  relation, 
			   #altkeyrel &
                           [ PRED neg_rel,
                             LBL #ltop,
                             ARG0.E.TENSE no_tense,
                             ARG1 #arg ] !>,
                   HCONS <! qeq & [ HARG #arg,
                                    LARG #lbl ] !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

; 'Kim was referred to often'
prep_passive_synsem_min := synsem_min.
prep_passive_synsem := basic_passive_synsem & particle_subst &
		       prep_passive_synsem_min &
  [ LOCAL.CAT.VAL.COMPS *obliquecons* &
                        < synsem & [ LOCAL.CAT [ HEAD prep,
						 VAL.COMPS *cons* ] ],
			  synsem & 
                          [ --MIN _by_p_cm_rel,
                            LOCAL local &
                                  [ CAT [ HEAD prep,
                                          VAL [ SUBJ < >,
                                                SPR *olist*,
                                                COMPS < > ] ] ],
                            NONLOC.REL 0-dlist,
                            OPT + ], ... > ].

ssr_particle_v_lexent := nonc-hm &
  [ INFLECTD -,
    SYNSEM ssr_particle_verb &
           [ LOCAL.CAT.HEAD verb & [ AUX -,
                                     INV - ],
	     LKEYS.KEYREL.ARG0 non_conj_event ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modifier synsems
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; When changing, remember to also modify verb_participle_affix in lexrules.tdl
;; DPF 2012-08-29 - Mysteriously, this type imposes REL 0-dlist, but that can't
;; be right since we want e.g. |the cat whose long tail twitched|.  What were
;; we thinking?  Let's see if anything goes awry when we remove this constraint.

isect_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
	    CONT.HOOK.LTOP #hand ],
    LKEYS.KEYREL.LBL #hand ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The semantics of a main verb consists of the "main" handel for the sentence
; and a list of relations.  A pointer to the main or head relation in the list
; is kept in the LKEYS.KEYREL attribute.
;
; DPF 26-Jan-01 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.

basic_main_verb_sans_key := basic_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ AUX -,
                                       INV -,
                                       TAM [ TENSE #tense,
                                             ASPECT #aspect,
                                             MOOD ind_or_subj ] ],
			   HC-LEX - ],
                     CONT [ HOOK.INDEX #index & [ E [ TENSE #tense,
                                                      ASPECT #aspect ] ],
                            RELS.LIST < relation & #keyrel, ... > ],
		     CONJ cnil ],
             LKEYS.KEYREL #keyrel & [ ARG0 #index ] ] ].

main_verb_sans_key := basic_main_verb_sans_key &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN v_event_rel,
				       ALTMIN role_rel ],
		     CONT.HOOK.LTOP #ltop ],
             LKEYS.KEYREL.LBL #ltop ] ].

basic_main_verb := main_verb_sans_key &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN nonaux_event_rel,
		       MC na ] ].

norm_basic_main_verb := basic_main_verb & nonc-h.

main_verb_newltop := basic_main_verb_sans_key & nonc-h &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD.MINORS [ MIN v_event_rel,
				   ALTMIN role_rel ] ].

main_verb := norm_basic_main_verb &
  [ INFLECTD - ].

main_verb_mliszt := basic_main_verb & nonc-h &
  [ INFLECTD - ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; AUXILIARY VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Auxiliary verbs are subject-to-subject raising verbs which also raise the 
; content of the VP complement, possibly tacking an additional relation on the
; end.  They also raise the context of the VP complement, for now at least to
; propagate tense information.
; AUX verbs are further classified by the type of VP complement they 
; select for.  Also, AUX verbs optionally take a neg (post-head) specifier.

aux_verb := basic_verb_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD [ TAM #tam,
			 MINORS.MIN v_event_rel ],
		  VAL.SUBJ < [ LOCAL.AGR.PNG #png ] > ],
	    CONT.HOOK.INDEX.E #tam,
	    AGR.PNG #png ] ].
		
aux_verb_ssr_subst := aux_verb & ssr_subst.

aux_verb_ssr_min := synsem_min.
aux_verb_ssr := aux_verb_ssr_subst & basic_two_arg & aux_verb_ssr_min &
  [ LOCAL.CAT [ HEAD.MINORS [ MIN #min,
                              ALTMIN #altmin ],
                VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		      KCMP #comp & [ LOCAL.CAT.HEAD.MINORS.ALTMIN #altmin ],
                      COMPS < #comp > ] ],
    LKEYS.KEYREL [ LBL #ltop,
		   PRED #min ] ].

aux_verb_ellip_min := synsem_min.
aux_verb_ellip := aux_verb & aux_verb_ellip_min &
  [ LOCAL.CAT.VAL.COMPS < > ].

aux_verb_word_super := nonc-hm &
  [ INFLECTD + ]. 

aux_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
           [ LOCAL.CAT [ HEAD.AUX +,
                         POSTHD + ] ] ].

bse_aux_verb_ssr := aux_verb_ssr &
  [ LOCAL.CAT [ POSTHD +,
		VAL.COMPS < synsem &
			    [ LOCAL [ CAT vp_bse_unspec_cat,
				      CONJ cnil ],
			      OPT - ] > ] ].

bse_aux_verb_word := aux_verb_word &
  [ SYNSEM bse_aux_verb_ssr ].

inf_aux_verb_ssr := aux_verb_ssr &
  [ LOCAL.CAT [ POSTHD +,
		VAL.COMPS < canonical_synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
			      --SIND.SF basic-prop,
			      OPT - ] > ] ].
;; ought, going
inf_aux_verb_word := aux_verb_word_super &
  [ SYNSEM inf_aux_verb_ssr,
    ALTS.VPELLIP - ].

psp_aux_verb_ssr := aux_verb_ssr &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT vp_cat &
					[ HEAD verb &
					       [ VFORM psp ] ],
				    CONJ cnil ],
			    OPT - ] > ].

;; Only for auxiliary "have" and "should+of"
psp_aux_verb_word := aux_verb_word &
  [ SYNSEM psp_aux_verb_ssr ].

; Only for the copula
; DPF 29-Nov-02 - Predicative copula has to identify COMPS..MOD..INDEX with
; COMPS..XARG since predicative PPs cannot lexically identify XARG with their
; KEY.ARG1, because PPs acting as modifiers of VPs have to project the XARG
; of the VP.
; DPF 20-Nov-03 - But now identifying INDEX of PP with its event, not its XARG.
; DPF 30-aug-05 - Note that we can't make the complement be REL 0-dlist since
; we use the relative clause for the purposive "Kim is to stay."
; DPF 01-Dec-06 - To avoid circularity in generator for e.g. "We could have
; been hiring Browne.", we depend on hack which makes "have" be POSTHD -,
; while other auxiliaries are POSTHD +, to block "been having been ..." 
; FIX?

prd_aux_verb_ssr_min := synsem_min.
prd_aux_verb_ssr := aux_verb_ssr & prd_aux_verb_ssr_min &
  [ LOCAL [ CAT [ HEAD [ AUX +, 
			 MINORS.MIN be_v_prd_rel ],
		  POSTHD +,
		  VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
			COMPS 
		       < [ LOCAL [ CAT basic_prd_cat &
				       [ HEAD.MINORS [ MIN independent_rel,
						       NORM norm_rel ],
					 VAL.SUBJ *olist*,
					 POSTHD + ],
				   CONT.HOOK [ LTOP #ltop,
					       INDEX #index &
						     [ E.TENSE tense ],
					       XARG #ind,
					       --SLTOP #sltop ] ],
			   --SIND #index,
			   NONLOC.REL 0-dlist,
			   OPT - ] > ] ],
	    CONT.HOOK [ INDEX #index,
			XARG #ind,
			--SLTOP #sltop ],
	    ARG-S < [ NONLOC [ SLASH [ LIST #smiddle,
				       LAST #slast ],
			       REL #rel,
			       QUE [ LIST #qmiddle,
				     LAST #qlast ] ] ],
		    [ NONLOC [ SLASH [ LIST #sfirst,
				       LAST #smiddle ],
			       QUE [ LIST #qfirst,
				     LAST #qmiddle ] ] ] > ],
    LKEYS.KEYREL.LBL #ltop,
    NONLOC [ SLASH [ LIST #sfirst,
		     LAST #slast ],
	     REL #rel,
	     QUE [ LIST #qfirst,
		   LAST #qlast ] ] ].

prd_aux_verb_word := aux_verb_word_super &
  [ SYNSEM prd_aux_verb_ssr ].

raise_cont := word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                       INDEX #index ] ], ... >,
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index ],
			  RELS <! !> ] ] ].

add_cont := word &
  [ SYNSEM [ LOCAL.CONT.RELS.LIST < relation & #keyrel, ... >,
             LKEYS.KEYREL #keyrel ] ].
		   
; Real modal verbs are auxiliary verbs which select a base form complement.
; They only exist in finite forms.
; DPF 2-Oct-01 - Removed [KCMP..INDEX.E.TENSE no_tense] since this
; prevented low attachment of "when" in "when can Kim arrive"

generic_modal_verb_super_synsem := aux_verb_ssr &
  [ LOCAL [ CAT [ VAL.KCMP.LOCAL [ CAT.VAL.SUBJ.FIRST 
						[ LOCAL.CAT.HEAD basic_noun ],
				   CONT.HOOK.INDEX.E.TENSE no_tense ] ],
	    CONT [ HOOK.INDEX #event,
		   HCONS.LIST < qeq &
				[ HARG #arghand ], ... > ] ],
    LKEYS.KEYREL arg1_relation &
	  [ ARG0 #event & non_conj_event,
	    ARG1 handle & #arghand ] ].

generic_modal_verb_word_super := aux_verb_word_super &
  [ SYNSEM generic_modal_verb_super_synsem ].

generic_modal_verb_synsem := generic_modal_verb_super_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT.HCONS.LIST < [ LARG #chand ], ... > ] ].

generic_modal_verb_word := generic_modal_verb_word_super &
  [ SYNSEM generic_modal_verb_synsem ].

fin_modal_verb_synsem := generic_modal_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ PRD -,
			 VFORM fin ],
		  POSTHD +,
		  VAL.SUBJ < synsem & [ LOCAL 
					      [ CAT nomp_cat_nom_min,
						CONJ cnil ],
					--SIND basic_non_event,
					OPT - ] > ],
	    CONT psoa ] ].

fin_modal_verb_word := generic_modal_verb_word &
  [ SYNSEM fin_modal_verb_synsem ].

ought_verb_synsem := fin_modal_verb_synsem & inf_aux_verb_ssr &
  [ LOCAL.CAT [ HEAD [ AUX -,
		       TAM [ TENSE present,
			     ASPECT no_aspect ] ],
		VAL.COMPS.FIRST canonical_synsem &
		     [ LOCAL.CAT.HEAD.TAM.TENSE no_tense ] ] ].

ought_verb_word := fin_modal_verb_word & inf_aux_verb_word &
  [ SYNSEM ought_verb_synsem,
    ALTS.CSAI - ].

; Assume for now that all modals have simple present tense semantics,
; ignoring the habitual past readings possible for "would" and "could" -
; these will have to be separate lexical entries.
; DPF 26-Jun-03 - Changed this to allow underspecification of tense for at
; least 'could'

modal_verb_synsem := fin_modal_verb_synsem & bse_aux_verb_ssr &
  [ LOCAL.CAT.VAL [ SUBJ < [ OPT - ] >,
		    COMPS.FIRST [ LOCAL.CAT vp_bse_cat,
				  --SIND.SF basic-prop ] ] ].

modal_verb_word := fin_modal_verb_word & bse_aux_verb_word &
  [ SYNSEM modal_verb_synsem ].

pos_modal_verb_synsem_min := synsem_min.
pos_modal_verb_synsem := modal_verb_synsem & pos_modal_verb_synsem_min &
  [ LOCAL [ CAT [ HEAD [ AUX +,
			 TAM indic_tam ],
		  VAL.COMPS.FIRST canonical_synsem ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel & [ PRED modal_rel,
			     LBL #ltop ] ].

modal_pos_lex_ent := modal_verb_word & add_cont &
  [ SYNSEM pos_modal_verb_synsem ].

modal_pos_indic_lexent := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD indicative ].

pos_ought_verb_synsem_min := synsem_min.
pos_ought_verb_synsem := ought_verb_synsem & pos_ought_verb_synsem_min &
  [ LOCAL.CONT [ HOOK.LTOP #ltop,
		 RELS <! #keyrel !>,
		 HCONS <! qeq !> ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

pos_ought_verb_word := ought_verb_word &
  [ SYNSEM pos_ought_verb_synsem ].

past_ought_verb_synsem_min := synsem_min.
past_ought_verb_synsem := inf_aux_verb_ssr & fin_modal_verb_synsem &
			  past_ought_verb_synsem_min &
  [ LOCAL [ CAT [ HEAD [ AUX -,
			 TAM [ TENSE past,
			       ASPECT no_aspect ] ],
		  VAL.COMPS < [ MODIFD notmod_or_rmod ] > ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

; 'used (to)' - Exclude modifiers intervening before VP-inf complement.
;
past_ought_verb_word := fin_modal_verb_word & inf_aux_verb_word &
  [ ALTS.ADVADD -,
    SYNSEM past_ought_verb_synsem ].

basic_quasimodal_verb_synsem := generic_modal_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ MINORS.MIN _going+to_v_qmodal_rel,
			 TAM.TENSE real_tense ],
		  VAL [ COMPS.FIRST #comp & canonical_synsem,
			KCMP #comp ] ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     PRED will_modal_rel ] ].

;; DPF 24-Jun-03 ***FIX?:  [ HEAD.MOD < anti_synsem_min >,
basic_quasimodal_verb_word := generic_modal_verb_word &
  [ SYNSEM basic_quasimodal_verb_synsem,
    ALTS.CSAI - ].

quasimodal_verb_synsem_min := synsem_min.
quasimodal_verb_synsem := basic_quasimodal_verb_synsem & inf_aux_verb_ssr &
			  quasimodal_verb_synsem_min &
  [ LOCAL.CAT.HEAD [ AUX +,
		     TAM.ASPECT.PROGR + ] ].

quasimodal_word := basic_quasimodal_verb_word & inf_aux_verb_word &
  [ SYNSEM quasimodal_verb_synsem ].

quasimodal_psp_synsem_min := synsem_min.
quasimodal_psp_synsem := inf_aux_verb_ssr & generic_modal_verb_synsem &
			 quasimodal_psp_synsem_min &
  [ LOCAL [ CAT.HEAD [ VFORM psp,
		       TAM.TENSE present,
		       AUX -,
		       PRD - ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel &
	  [ LBL #ltop ] ].

quasimodal_psp_word := inf_aux_verb_word & generic_modal_verb_word &
  [ SYNSEM quasimodal_psp_synsem,
    ALTS.CSAI - ].

quasimodal_psp_bse_synsem_min := synsem_min.
quasimodal_psp_bse_synsem := generic_modal_verb_synsem & bse_aux_verb_ssr &
			     quasimodal_psp_bse_synsem_min &
  [ LOCAL [ CAT.HEAD [ VFORM psp,
		       TAM.TENSE present,
		       PRD -],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel &
	  [ LBL #ltop ] ].

; "we've |gotta| win"
quasimodal_psp_bse_word := generic_modal_verb_word & bse_aux_verb_word &
  [ SYNSEM quasimodal_psp_bse_synsem,
    ALTS.CSAI - ].

quasimodal_bse_synsem_min := synsem_min.
quasimodal_bse_synsem := basic_quasimodal_verb_synsem & bse_aux_verb_ssr &
			 quasimodal_bse_synsem_min &
  [ LOCAL.CAT [ HEAD [ VFORM prp,
		       PRD + ],
		VAL.COMPS < [ LOCAL.CAT vp_bse_cat,
			      --SIND.SF basic-prop ] > ] ].

quasimodal_bse_word := basic_quasimodal_verb_word & bse_aux_verb_word &
  [ SYNSEM quasimodal_bse_synsem ].


nonfin_modal_verb_synsem_min := synsem_min.
nonfin_modal_verb_synsem := generic_modal_verb_synsem &
			    nonfin_modal_verb_synsem_min &
  [ LOCAL [ CAT [ HEAD [ PRD -,
			 VFORM bse,
			 AUX -,
			 TAM [ TENSE past,
			       ASPECT [ PRF -,
					PROGR - ] ] ],
		  VAL.COMPS < canonical_synsem &
			      [ LOCAL.CAT vp_inf_cat,
				--SIND.SF basic-prop ] >],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

; 'didn't he used to sing?'
nonfin_modal_word := generic_modal_verb_word &
  [ SYNSEM nonfin_modal_verb_synsem ].

; DPF 09-Jan-00 - Removed SLASH 0-dlist from COMPS.FIRST, since it was blocking
; e.g. "When's he leaving"
; DPF 13-apr-05 - Instead, make COMPS.FIRST be expressed_synsem.  Also seems
; to make ALTS.VPELLIP - unnecessary.
; DPF 18-aug-09 - Re 13-apr-05: But expressed_synsem isn't quite right, since
; this still unifies with 'gap', so change to canonical_synsem.
; DPF 06-apr-10 - Re 18-aug-09: But we want gaps, as in "where's Kim?", so
; revert to expressed_synsem.  Sigh.

contracted_aux_word := word &
  [ ALTS [ VPELLIP -,
           SQPNCT -,
	   CSAI - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST expressed_synsem,
    GENRE nonformal ].

; copula, 'exists'
; DPF 12-Apr-02 - The second (predicative) complement was being blocked by
; MIN no_rel - avoided unwanted ambiguity, but now prevents e.g. "where is
; there a problem" since we now want to avoid spurious adjunct extraction.
; So removed no_rel, and instead require this second complement to be 
; non_canonical - allows extraction, but not the spuriosity of in-situ PrdPs.
; DPF 01-Feb-03 - Since we're now allowing adjunct extraction for independent
; reasons, let's try abandoning that second complement of the 'there'-copula
; altogether.  Then we avoid the awkward semantic composition problem of
; having to find the LBL of the noun_rel inside the first complement - does
; violence to our semantic algebra.
; DPF 28-oct-03 - Restored the three-arg there-copula since we need it at
; least for extractions like "what is there to do" (& "there is nothing to do")
; where the last complement has a non-empty rel (to avoid spurious ambig).
; Since the optional second complement will be RELS non-empty, can't use the
; default appending of non-local feats, so have to do cumbersome repeat here,
; to avoid propagating that non-empty RELS.  But don't want to say explicitly
; here that it's non-empty, since then constraint on *olist* not satisfied.
; DPF 28-jun-07 - Constrain second complement to be non-extracted, to avoid
; spurious ambiguity for "In Berlin, there are cats"

; there-copula and it-cleft copula

expl_verb_synsem := unsat_three_arg_subst & verb_synsem & norel_three_arg &
  [ LOCAL [ CAT [ VAL [ SUBJ < [ --SIND expl-ind & #subjind ] >,
                        COMPS < synsem &
			    [ LOCAL [ AGR non_expl,
				      CONJ cnil ],
                              --SIND #cind,
                              NONLOC.REL 0-dlist,
                              OPT - ],
			    [ LOCAL local &
				    [ CAT [ HEAD 
                                             [ MOD < synsem &
                                                     [ --SIND #cind ]> ],
                                            VAL [ SPR *olist*,
                                                  SUBJ *olist*,
						  COMPS < > ],
					    MC na ],
                                      CONT.HOOK.XARG #cind ],
                              NONLOC.SLASH 0-dlist ] > ] ],
            CONT.HOOK.XARG #subjind ],
    LKEYS.KEYREL arg1_relation &
          [ ARG1 #cind & non_expl ] ].

; DPF 25-oct-05 - Removed second comp's [PRD -] since PP's need to be + (see 
; note (same date) for p_reg_lexent), while (most) relative clauses are [PRD -]
there_verb_synsem := expl_verb_synsem &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND there-ind & #sind &
                                      [ PNG [ PN #pn,
                                              GEN no_gend_there ] ],
			     LOCAL [ AGR.PNG.PN #pn,
				     CONT.HOOK.INDEX #sind ] ] >,
		      COMPS < [ --MIN nonpro_or_refl_or_num_rel & #min ,
                              LOCAL [ CAT np_cat_acc_min & [ HEAD #head ],
				      CONT.HOOK.INDEX.SORT 
					  basic-entity-or-event,
                                      AGR.PNG [ PN #pn,
                                                GEN neut ] ] ],
                            [ LOCAL [ CAT [ HEAD v_or_a_or_p &
                                            [ MOD < [ LOCAL intersective_mod &
                                                         [ CAT.HEAD #head ],
                                                      --MIN #min ] > ],
                                            MC na,
                                            POSTHD + ],
                                      CONT.HOOK [ LTOP #lbl,
                                                  INDEX.E.TENSE no_tense ],
                                      CONJ cnil ],
                              LEX -,
                              OPT + ] > ] ],
    LKEYS.KEYREL.LBL #lbl ].

there_verb_nohc_synsem_min := synsem_min.
there_verb_nohc_synsem := there_verb_synsem & there_verb_nohc_synsem_min &
  [ LOCAL.CONT [ RELS <! #keyrel !>,
		 HCONS <! !> ],
    LKEYS.KEYREL #keyrel ].

; DPF 19-jan-08 - Try removing AUX + so we can parse e.g. "In Paris it
; was Kim who laughed."
;; DPF 2011-08-01 - Constrained first COMP to be --MIN independent_rel, to
;; exclude selected-for PPs (spurious ambig), since these are no longer [PRD -].
;;
itcleft_verb_synsem_min := synsem_min.
itcleft_verb_synsem := expl_verb_synsem & aux_verb & itcleft_verb_synsem_min &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN be_v_it_rel,
		  VAL [ SUBJ < [ --SIND it-ind & [ PNG.GEN no_gend_it ] ] >,
			COMPS < synsem & [ LOCAL [ CAT [ HEAD n_or_p &
                                                            [ POSS -,
                                                              PRD + ],
                                                       VAL [ SUBJ *olist*,
                                                             SPR *olist*,
                                                             COMPS < > ],
                                                       MC na_or_- ],
                                                 CONT.HOOK.LTOP #cltop ],
					   NONLOC non-local_none,
					   --MIN independent_rel ],
				canonical_synsem &
				[ LOCAL 
                                 [ CAT [ HEAD verb & 
                                        [ VFORM fin,
                                          MOD < [ LOCAL 
                                                  [ CAT.HEAD supnoun,
						    CONT.HOOK.LTOP #vlbl ],
						--MIN norm_rel ] > ],
					VAL.SUBJ *olist*,
                                        MC na ],
                                   CONT.HOOK.LTOP #cltop ],
				  OPT - ] > ] ] ],
    LKEYS [ KEYREL [ LBL #vlbl,
		     PRED _be_v_itcleft_rel,
                     ARG2 #cltop ],
            --+ARGIND it-ind ] ].

; 'In the corner is a chair'
; 'Especially popular is Rondane'
; POSTHD - is hack to prevent these from undergoing adjunct extraction
; DPF 12-nov-05 - Generalized subj to be v_or_a_or_p (from just a_or_p)
; to get e.g. "Also contributing to their success was ..."
; Also prevent spurious gapping of complements
; DPF 09-may-06 - SUBJ..ALTMIN blocks np_adv_c phrases, to avoid spurious
; ambiguity for e.g. "There is Kim."
; DPF 06-jul-06 - But this also blocks "Here is Kim." and "There stood Kim".
; So instead constrain NORM, but only for the copula.
; DPF 10-sept-07 - Changed COMPS..--MIN from nonpro_rel to reg_or_temp_nom_rel
; to avoid unwanted analyses with gerunds, as in "...in the tree is arising..."
; DPF 13-may-09 - Restrict SUBJ to be MOD anti_synsem, to exclude infinitival
; relatives, which otherwise look much like e.g. passive VPs
;; DPF 2011-09-30 - Added SUBJ..NORM no_rel to block non-depictives like |so|
;; as in |so was Browne|

loc_inv_verb_word := noncqrs-hm &
  [ SYNSEM twoarg_verb_synsem & 
     [ LOCAL [ CAT [ HEAD [ AUX -, 
                            INV -,
                            MINORS.MIN aux_arg1_rel ],
                     VAL [ SUBJ < canonical_synsem &
                                  [ --MIN independent_rel,
                                    LOCAL
                                    [ CAT basic_prd_cat &
                                          [ HEAD v_or_a_or_p &
                                                 [ MOD < anti_synsem &
							 [ --SIND #sind ] >,
						   MINORS.NORM no_rel ],
                                            VAL.SUBJ *olist* ],
                                      CONT.HOOK 
                                          [ INDEX event,
                                            XARG #sind & individual_min ] ],
                                    OPT - ] >,
                           COMPS < synsem_min & 
                                   [ LOCAL [ CAT nomp_cat_min,
                                             AGR #agr,
                                             CONJ cnil ],
                                     --MIN reg_or_temp_nom_rel,
                                     --SIND ref-ind,
                                     OPT - ] > ] ],
               AGR #agr,
               CONT.HOOK [ LTOP #ltop,
			   INDEX.--TPC + ] ],
       NONLOC non-local_none,
       LKEYS.KEYREL.LBL #ltop ] ].

loc_inv_be_synsem_min := synsem_min.
loc_inv_be_synsem := loc_inv_be_synsem_min & twoarg_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ PRD -,
			 TAM.MOOD indicative ],
		  VAL [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
						   INDEX #ind &
							[ E.TENSE tense ],
						   XARG #xarg ] ] >,
			COMPS < [ --SIND #xarg ] > ],
		  POSTHD - ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #ind & [ SF prop-or-ques ],
			  XARG #xarg ],
		   RELS <! !> ] ],
    LKEYS.KEYREL.PRED no_rel ].

basic_loc_inv_be_word := loc_inv_verb_word &
  [ INFLECTD +,
    SYNSEM loc_inv_be_synsem ].

loc_inv_be_word := basic_loc_inv_be_word &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin ].

loc_inv_mv_synsem_min := synsem_min.
loc_inv_mv_synsem := loc_inv_mv_synsem_min & twoarg_verb_synsem &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK [ LTOP #ltop,
						   INDEX #xarg,
						   XARG #index ] ]] >,
		      COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
						  INDEX #cind ] ] > ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #index,
			  XARG #xarg ],
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     ARG0 #index,
			     ARG1 #cind ] ].

; 'lie, stand'
; DPF 20-apr-08 - Added identity of SUBJ..INDEX and own XARG, to block
; spurious analysis of "Kim would ride the horse."
loc_inv_mv_word := loc_inv_verb_word &
  [ INFLECTD -,
    SYNSEM loc_inv_mv_synsem ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NOUNS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;       TYPE                 ISA                what's it for?
;       nominal_synsem       lex_synsem         all nouns
;       xpro_synsem          nominal_synsem     pro v. non-pro dimension
;       xref_synsem          nominal_synsem     ref v. non-ref dimension
;       pronominal_synsem    xpro_synsem        all pronouns
;       nonpronominal_synsem xpro_synsem        all non-pronominal nouns
;       ref_synsem           xref_synsem        personal pro's & nouns
;       non_ref_synsem       xref_synsem        it, there, wh-pronouns
;       ref_pro_synsem       pronominal_synsem  personal pronouns
;                            & ref_synsem
;       non_ref_pro_synsem   pronominal_synsem  it, there, wh-pronouns
;                            & non_ref_synsem
;       noun_synsem          nonpronominal_synsem all non-pro nouns
;                            & ref_synsem 

; The "default" statement that most nouns identify their AGR and INDEX
; will live on noun_synsem and non_ref_pro_synsem, and then be restated for
; personal pronouns other than my special 'they'.  (All this because I can't
; be bothered now to set up a special default type...) 

; DPF 3-May-03 - Why can't we make [MODIFD notmod] true for all nouns, rather
; than stipulating it on (almost) all subtypes?  Who wants to stay unmarked?
; Answer: day-of-month nouns like "tenth", which can combine with the simple
; determiner "the" and still be modifiers: "He arrived the tenth" but "*He
; arrived the week"

nominal_synsem := basic_lex_synsem & 
  [ LOCAL [ CAT [ HEAD.POSS -,
		  VAL.SPCMPS < > ],
	    CONT nom-obj ] ].

xpro_synsem := nominal_synsem.
xref_synsem := nominal_synsem.

; DPF 23-Jul-99 - Add missing MOD < >.

pronominal_synsem := xpro_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD partn,
		  VAL.SUBJ < > ] ] ].

nonpronominal_synsem := xpro_synsem.

; AAC - added following types for verbal_gerund, poss_clitic etc

nonpro_nomod_synsem := nomod_synsem & nonpronominal_synsem.
nomod_onearg_synsem := nomod_synsem & one_arg.
nonpro_nomod_onearg_synsem := nonpro_nomod_synsem & basic_one_arg.

ref_synsem := xref_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN basic_nom_rel,
                  VAL.SPEC < anti_synsem_min > ],
            CONT [ HOOK.INDEX #inst & non_expl-ind,
                   RELS.LIST < nom_relation & #keyrel & 
                               [ ARG0 #inst ], ... > ] ],
    LKEYS.KEYREL #keyrel ].

non_ref_synsem := xref_synsem & nomod_synsem & zero_arg &
  [ LOCAL.CAT.VAL [ SPR < >,
		    COMPS < >,
                    SPEC < anti_synsem_min > ] ].

ref_pro_synsem := pronominal_synsem & ref_synsem & nomod_synsem.

non_ref_pro_synsem := pronominal_synsem & non_ref_synsem &
  [ LOCAL [ AGR #agr,
	    CAT.HEAD.MOD < >,
	    CONT.HOOK.INDEX #agr ] ].

basic_noun_synsem := nonpronominal_synsem & ref_synsem &
  [ LOCAL.CAT.HEAD noun_or_ttl ].

noun_synsem := basic_noun_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD noun,
            AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

mass_or_count_synsem := basic_noun_synsem.
count_noun_synsem := mass_or_count_synsem &
  [ LOCAL.CONT.HOOK.INDEX.IND + ]. 

;;
;; Common nouns
;;
;; DPF 16-Nov-00 - Added SPR.NONLOC.SLASH 0-dlist - don't know how we did
;; without this up to now.
;; DPF 14-Jul-01 - Well, we don't actually want SPR..SLASH 0-dlist since it
;; blocks free relative det constructions like "whichever person you hired"
;; where the "whichever" has a non-empty SLASH value.  Don't know what
;; motivated the above addition of 0-dlist, but I'm sure we'll soon see.
; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).
; DPF 8-Jun-03 - Removed SPR..COMPS *olist* since want to allow discontinuous
; analysis for e.g. "a week and a half"
; DPF 8-Jun-03 - Try requiring sprs of nouns to be LEX +, to block "*a and a
; half week" while enabling "a week and a half".  May want to consider making
; the head-spec rule impose this constraint on all specifiers, given similar
; need for allowing "kim is as tall as Sandy" but blocking "*Kim is as as 
; Sandy tall"

basic_unsp_common_noun_synsem := basic_noun_synsem & lex_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
	    CAT [ HEAD.MINORS.ALTMIN #spmin,
                  VAL [ SPR < #spr & synsem &
                              [ --MIN #spmin & quant_rel,
                                LOCAL.CAT [ HEAD det,
                                            VAL [ SUBJ < >,
                                                  SPR *olist* ] ],
                                LEX + ] >,
                        COMPS #comps,
                        SPEC < anti_synsem_min > ] ] ] ].

; Exclude dom nouns, to allow "the January 11 meeting"
unsp_common_noun_synsem := basic_unsp_common_noun_synsem &
  [ LOCAL.CAT [ HS-LEX -,
                VAL.SPR < [ OPT - ] > ] ].
            
basic_common_noun_synsem := unsp_common_noun_synsem & noun_synsem.

basic_count_noun_synsem := basic_common_noun_synsem & count_noun_synsem.
common_noun_synsem := basic_count_noun_synsem.

unsp_count_noun_nocomp_synsem := unsp_common_noun_synsem & count_noun_synsem &
                                 basic_one_arg & nonpro_nomod_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

common_noun_nocomp_synsem := basic_count_noun_synsem & basic_one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

unsp_mass_or_count_synsem := unsp_common_noun_synsem & nonpro_nomod_synsem &
                              mass_or_count_synsem.

; For nouns which will remain underspecified for mass/count.
basic_mass_or_count_synsem := unsp_mass_or_count_synsem.

basic_mass_or_count_nocomp_synsem := basic_mass_or_count_synsem & one_arg &
  [ LOCAL.CONT.RELS <! relation !> ].

mass_or_count_nocomp_synsem := basic_mass_or_count_nocomp_synsem & 
                               basic_common_noun_synsem.

noun_nocomp_synsem := common_noun_nocomp_synsem & nonpro_nomod_onearg_synsem.

noun_nonpro_nomod_synsem := basic_common_noun_synsem & nonpro_nomod_synsem.
noun_two_arg_nomod_synsem := noun_nonpro_nomod_synsem & basic_two_arg.

; DPF 22-Jul-03 - Constraint on COMPS < expressed_synsem, ... > ensures that
; this complement is either realized or discharged via hdn_optcmp_c, to avoid
; spurious ambiguity.
;; DPF 2011-08-29 - Re 22-Jul-03: But this discharging is independently ensured,
;; and insisting on expressed_synsem blocks measure_np rule applying to
;; |an| in |an hour and a half|, so remove constraint here.

unsp_noun_ppcomp_synsem := unsp_common_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN #cmin,
                            LOCAL [ CAT [ HEAD prep & [ PRD - ],
					  VAL.COMPS < > ],
				    CONT.HOOK.LTOP #lbl ],
                            PUNCT.LPUNCT no_punct ], ... >,
    LKEYS [ KEYREL.LBL #lbl,
	    --COMPKEY #cmin ] ].

basic_noun_ppcomp_synsem := unsp_noun_ppcomp_synsem & basic_common_noun_synsem.

noun_nondeverb_ppcomp_synsem := basic_noun_ppcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #index ] >,
    LKEYS.KEYREL.ARG1 #index ].

unsp_ppcomp_two_arg_synsem := unsp_noun_ppcomp_synsem & basic_two_arg &
                              nonpro_nomod_synsem & count_noun_synsem.

noun_ppcomp_two_arg_synsem := unsp_ppcomp_two_arg_synsem &
                              basic_noun_ppcomp_synsem & common_noun_synsem.

noun_ppcomp_three_arg_synsem := basic_noun_ppcomp_synsem & three_arg &
                                nonpro_nomod_synsem & common_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          synsem &
                          [ --MIN #ocmin,
                            LOCAL [ CAT [ HEAD prep & [ PRD - ],
                                          VAL.COMPS < > ],
                                    CONT.HOOK.LTOP #hand ],
                            PUNCT.LPUNCT no_punct ] >,
    LKEYS [ KEYREL.LBL #hand,
            --OCOMPKEY #ocmin ] ].

; DPF 25-mar-05 - Added MODIFD notmod to avoid spurious ambig with adjN rules.
; DPF 26-mar-05 - But this conflicts with the constraint in the NP-ADV rule
; which distinguishes "we arrived the week before" from "*we arrived the week"
; since we also want "We arrived Tuesday".  So try just excluding lmod value.

temp_noun_comp_two_arg_synsem := basic_two_arg & count_noun_synsem & 
                                 nonpro_nomod_synsem & 
  [ LOCAL [ CAT [ HEAD noun & [ MINORS.MIN temp_abstr_rel ], 
                  VAL [ SUBJ < >,
                        SPR < [ OPT - ] >,
                        SPEC < anti_synsem_min > ] ],
	    CONT.HOOK.INDEX.SORT time ] ].

temp_noun_ppcomp_two_arg_synsem := temp_noun_comp_two_arg_synsem &
                                   basic_noun_ppcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
			    LOCAL.CONT.HOOK.INDEX #index & non_expl-ind ] >,
    LKEYS.KEYREL.ARG1 #index,
    MODIFD notmod_or_rmod ].

; For e.g. "hotel" as in "the hotel Marriott" or "the Marriott hotel Hannover"c
abstr_noun_nomcomp_synsem := unsp_common_noun_synsem & nonpro_nomod_synsem &
  [ LOCAL [ CAT.VAL.KCMP expressed_synsem & 
                         [ LOCAL.CONJ cnil,
			   OPT - ],
	    AGR #agr,
            CONT [ HOOK [ LTOP #hand,
			  INDEX #agr ],
		   RELS.LIST < relation, ... > ] ],
    LKEYS.KEYREL.LBL #hand ].

basic_noun_nomcomp_synsem := abstr_noun_nomcomp_synsem & 
			     noun_nonpro_nomod_synsem.

abstr_noun_npcomp_synsem := abstr_noun_nomcomp_synsem &
  [ LOCAL [ CAT.VAL.KCMP [ --MIN abstr_named_rel,
                           LOCAL [ CAT nomp_cat_acc_min,
                                   CONT.HOOK [ LTOP #hand,
                                               INDEX index ] ],
			   --SIND #cindex ],
            CONT [ HOOK [ LTOP #hand,
			  INDEX #index ],
                   RELS <! relation & [ CFROM #cfrom, CTO #cto ],
			   prep_notense_relation & 
                                     [ PRED compound_rel,
				       LBL #hand,
				       ARG1 #index,
				       ARG2 #cindex,
				       CFROM #cfrom, CTO #cto ] !>,
                   HCONS <! !> ] ] ].

basic_noun_npcomp_synsem := basic_noun_nomcomp_synsem &
			    abstr_noun_npcomp_synsem.

basic_common_noun_npcomp_synsem := basic_noun_npcomp_synsem & basic_two_arg &
                                   count_noun_synsem &
  [ LOCAL.CAT.VAL [ COMPS < #comp & [ PUNCT.LPUNCT no_punct ] >,
                    KCMP #comp ] ].

common_noun_npcomp_synsem := basic_common_noun_npcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
    LKEYS.KEYREL reg_diadic_nom_relation ].

; 'kinda' as in "what kinda chair is that"
common_noun_nbarcomp_synsem := basic_noun_nomcomp_synsem & basic_two_arg &
                               count_noun_synsem &
  [ LOCAL [ CAT.VAL [ SPR < [ NONLOC.SLASH 0-dlist ] >,
                      COMPS < #comp & abstr_lex_synsem &
                              [ LOCAL [ CAT nbar_cat_min & [ HEAD noun ],
                                        CONT.HOOK [ LTOP #nhand,
                                                    INDEX #arg ] ],
                                NONLOC.SLASH 0-dlist,
                                OPT - ] >,
                      KCMP #comp ],
            CONT [ RELS <! [ ARG1 #arg ],
			   #alt2keyrel &
			 [ PRED udef_q_rel,
                           ARG0 #arg,
                           RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ],
    LKEYS [ KEYREL reg_diadic_nom_relation,
	    ALT2KEYREL #alt2keyrel ] ].

; DPF 08-apr-08 - Added NORM norm_rel to prevent these from heading appositive
;; DPF 2012-08-29 - Changed this type (for |$|) to have an anti_synsem 
;; complement, to avoid seeing this dependent lexical entry as a stand-alone
;; phrase, to avoid massive spurious ambiguity.  Concede that one does see
;; |We need $ to live| in informal writing, but we'll undergenerate for now,
;; in the interest of efficiency.  FIX someday?
;;
common_noun_numcomp_synsem := basic_count_noun_synsem & 
			      nonpro_nomod_synsem &
  [ LOCAL.CAT.HEAD [ MINORS [ MIN mnp_symb_rel,
			      NORM norm_rel ],
                     PRD + ] ].

; ERB (14-12-97) It might be cleaner in some sense for pro_ss to have that
; pron_rel as its MIN and then have this construction and others like it
; take the value of that MIN and put it on their RELS.  Also, if we
; ever move to lexical amalgamation of relations, the pron_rel should get
; incorporated automatically. ... So I'm going to try to do it that way.

; ERB (14-12-97) We just decided that there shouldn't be a pron_rel here.
; The feature PT is enough to distinguish the instance introduced
; by the pro_ss as one that doesn't have to be bound.

; ERB (21-01-98) The pro_ss should be unslashed.

basic_mass_noun_synsem := unsp_mass_or_count_synsem & noun_synsem &
  [ LOCAL [ CONT.HOOK.INDEX [ PNG png & [ PN 3s ],
                              DIV +,
                              IND - ] ] ].

basic_scoping_noun_synsem := noun_nonpro_nomod_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #ltop,
	    CONT.HCONS.LIST < qeq & [ HARG #arg1, LARG #ltop ], ... > ],
    LKEYS.KEYREL basic_hcomp_nom_relation & [ ARG1 handle & #arg1 ] ].

scoping_noun_synsem := basic_scoping_noun_synsem & noun_two_arg_nomod_synsem.

;; a way to meet

basic_noun_vpcomp_synsem := basic_scoping_noun_synsem & 
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < #comp &
			      [ LOCAL [ CAT vp_inf_cat,
                                        CONT.HOOK.INDEX.SF basic-prop,
                                        CONJ cnil ],
				--MIN non_ellipt_rel,
				PUNCT.LPUNCT no_punct,
				OPT - ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! qeq !> ] ] ].

basic_common_noun_vpcomp_synsem := basic_noun_vpcomp_synsem &
                                   common_noun_synsem.
common_noun_vpcomp_synsem := basic_common_noun_vpcomp_synsem & 
                             scoping_noun_synsem.
mass_noun_vpcomp_synsem := basic_noun_vpcomp_synsem & scoping_noun_synsem &
                           basic_mass_noun_synsem.
mass_count_noun_vpcomp_synsem := basic_noun_vpcomp_synsem & scoping_noun_synsem
                                 & basic_mass_or_count_synsem.

; pleasure: "it is a pleasure to visit Abrams"

; It is a pleasure to visit abrams.
common_noun_vpcomp_expl_synsem := common_noun_vpcomp_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN prednom_rel,
                  VAL [ SPR < [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
                        COMPS < [ NONLOC.SLASH 0-dlist,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG it-ind ],
    MODIFD notmod,
    LKEYS.--+ARGIND it-ind ].

; It is sheer drudgery to visit abrams.
mass_noun_vpcomp_expl_synsem := basic_noun_vpcomp_synsem &
                                basic_mass_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN prednom_rel,
                  VAL [ SPR < [ --MIN implicit_q_rel ] >,
                        COMPS < [ NONLOC.SLASH 0-dlist,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG it-ind ],
    MODIFD notmod,
    LKEYS.--+ARGIND it-ind ].

; Abrams is a pleasure to visit.
common_noun_vpcomp_slash_synsem := basic_common_noun_vpcomp_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN prednom_rel,
                  VAL [ SPR < [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
                        COMPS < [ NONLOC.SLASH 1-dlist & 
                                         <! [ CAT nomp_cat_min,
                                              CONT.HOOK.INDEX #xarg &
                                                  index ] !>,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG #xarg ],
    NONLOC.SLASH 0-dlist,
    MODIFD notmod ].

basic_common_noun_cpcomp_synsem := scoping_noun_synsem &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < #comp & synsem &
			    [ LOCAL [ CAT s_cat_unspec,
				      CONJ cnil ],
                              NONLOC.SLASH 0-dlist,
			      LEX -,
			      OPT - ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! qeq !> ] ] ].

basic_count_noun_cpcomp_synsem := basic_common_noun_cpcomp_synsem & 
                                  count_noun_synsem &
				  cp_addin_tam_pn.

common_noun_cpcomp_synsem := basic_count_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp,
			    PUNCT.LPUNCT no_punct,
			    LEX - ] >,
    LKEYS.KEYREL basic_hcomp_nom_relation ].

common_noun_cpcomp_fin_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ].

common_noun_cpcomp_inf_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_inf_v_c ] > ].

common_noun_cpcomp_bse_synsem := basic_common_noun_cpcomp_synsem &
				 count_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_bse & [ HEAD comp ],
			    PUNCT.LPUNCT no_punct,
			    LEX - ] >,
    LKEYS.KEYREL hcomp_nom_relation ].

basic_mass_count_noun_cpcomp_fin_synsem := basic_common_noun_cpcomp_synsem &
					   basic_mass_or_count_synsem &
					   cp_addin_tam_pn &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c,
			      PUNCT.LPUNCT no_punct ] >,
            CONT.RELS <! relation !> ],
    LKEYS.KEYREL hcomp_nom_relation ].

mass_count_noun_cpcomp_fin_synsem := basic_mass_count_noun_cpcomp_fin_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp ] > ].

;; DPF 2012-12-21 - Removed [HEAD comp] to allow thatless S-comp.
;;
mass_noun_cpcomp_synsem := basic_common_noun_cpcomp_synsem &
                           basic_mass_noun_synsem & cp_addin_tam_pn &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c,
			      PUNCT.LPUNCT no_punct ] >,
            CONT.RELS <! relation !> ],
    LKEYS.KEYREL hcomp_nom_relation ].

mass_noun_onearg_synsem := basic_mass_noun_synsem & one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

mass_noun_synsem := mass_noun_onearg_synsem &
  [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
            CONT.RELS <! reg_nom_relation !> ] ].

basic_mass_noun_ppcomp_synsem := basic_mass_noun_synsem & basic_two_arg &
                                 noun_nondeverb_ppcomp_synsem &
  [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ].

mass_noun_ppcomp_synsem := basic_mass_noun_ppcomp_synsem & two_arg &
  [ LOCAL.CONT.RELS <! reg_diadic_nom_relation !> ].

mass_noun_ppcomp_nospr_synsem := basic_mass_noun_synsem & basic_two_arg &
				 basic_common_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
		  VAL.COMPS < [ --MIN #cmin,
				LOCAL [ CAT [ HEAD prep & [ PRD - ],
					      VAL.COMPS < > ],
					CONT.HOOK [ LTOP #nhand,
						    INDEX #nind ] ],
				PUNCT.LPUNCT no_punct ] > ],
            CONT [ RELS <! [ ARG1 #nind ],
			   #altkeyrel & [ PRED udef_q_rel,
					  ARG0 #nind,
					  RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    --COMPKEY #cmin ] ].

basic_mass_or_count_ppcomp_synsem := basic_mass_or_count_synsem & two_arg &
                                     noun_nondeverb_ppcomp_synsem & 
  [ LOCAL [ CAT.HEAD.MINORS.MIN diadic_nom_rel,
            CONT.RELS <! relation !> ],
    LKEYS.KEYREL diadic_nom_relation ].

mass_or_count_ppcomp_synsem := basic_mass_or_count_ppcomp_synsem &
  [ LKEYS.KEYREL reg_diadic_nom_relation ].

mass_noun_npcomp_synsem := basic_mass_noun_synsem & basic_noun_npcomp_synsem &
                           basic_two_arg &
  [ LOCAL.CAT.VAL [ COMPS < #comp & [ OPT -,
                                      PUNCT.LPUNCT no_punct,
				      --SIND #cind ] >,
                    KCMP #comp ],
    LKEYS.KEYREL reg_diadic_nom_relation &
		  [ ARG1 #cind ] ].

; PRD feature used as a hack to avoid partitives in noun-noun compounds,
; pending a better analysis.
; DPF 9-Sept-99 - Changed N-N block to be based on non-empty ALTMIN, rather 
; than PRD. The handle of the of-NP should probably be an argument of the 
; part_of relation, as the value of a feature SET.  But for now we simply 
; identify the handles of the part_of and the of_NP.
; DPF 17-Apr-03 - Changed set-up so the MIN of partitives will be the MIN of
; the of-PP's NP if there is a complement and an underspecified nom_rel as
; the default.
; DPF 2-May-03 - Changed SPR..MIN from degree_rel to just_only_very_deg_rel
; to block a lot of overgeneration, but still leaving a little (e.g. 
; "very all chairs arrived").  We'll fix this once we move to relation names
; as values of PRED feature in relation.
; DPF 27-Jul-03 - Removed SPR..MIN, since it needs to preserve the constraints
; from the non-partitive determiner (the input to the lexical rule for which
; this type is the output), as in "too much of the rice was spilled".
; DPF 31-Oct-03 - But need some SPR..MIN constraint since not all partitives
; are constructed via that lexical rule, and they need some kind of 
; restriction.  So added this constraint to n_part_lexent below.
; DPF 13-Nov-03 - Removed SPR..COMPS *olist* since want these to be able to
; take comparative degree specifiers (which have a non-empty COMPS list), 
; like in "kim hired as many as sandy"
; DPF 22-feb-04 - Identified INDEX and AGR, as with noun_synsem -- was there
; a reason this wasn't done earlier?  It's needed to get the right agreement
; for e.g. "we climbed peaks all of which are tall".
; DPF 09-may-04 - Changed SPEC < > to SPEC < anti_synsem_min > so partitives can
; appear as complements of empty-preps, as in "kim relied on all the chairs"

partitive_noun_synsem := nonpronominal_synsem & xref_synsem &
  [ LOCAL [ CAT [ HEAD partn &
                       [ MOD < >,
                         MINORS [ MIN basic_nom_rel,
                                ALTMIN quant_or_wh_rel & #altmin ] ],
                  VAL [ SUBJ < >,
                        SPR < synsem &
                              [ LOCAL 
				[ CAT [ HEAD.MINORS.MIN #min & 
							just_only_deg_rel,
					VAL.SPR  *olist* ],
				  CONT.HOOK.LTOP #althand ],
				NONLOC [ QUE 0-dlist,
					 REL 0-dlist ],
				--MIN #min ],
			      anti_synsem_min & [ OPT - ] >,
			SPEC < anti_synsem_min >,
                        KCMP [ --MIN #cmin & _of_p_sel_rel,
			       --SIND.SORT #sort,
                               LOCAL.CAT [ HEAD prep & 
                                                [ PRD -,
                                                  TAM.TENSE nontense ],
                                           VAL.COMPS < > ],
                               NONLOC.SLASH 0-dlist,
                               OPT - ] ],
		  HS-LEX - ],
            CONT [ HOOK [ LTOP #nhand,
                          INDEX #index & basic_non_expl-ind &
			       [ SORT #sort ] ],
		   HCONS.LIST < qeq & [ HARG #phand,
                                        LARG #nhand ], ... > ],
	    AGR #index ],
    LKEYS [ KEYREL instance_relation &
                   [ LBL #nhand,
                     ARG0 #index ],
            ALTKEYREL quant_or_wh_relation &
                        [ PRED #altmin,
                          LBL #althand,
                          ARG0 #index,
                          RSTR #phand ],
            --COMPKEY #cmin ] ].

; DPF 17-Apr-03 - Identify MIN relation with the of-PP's complement's ALTMIN,
; (the MIN of that PP's NP complement) to maintain visibility of that NP's
; relation, for example to block "*Kim arrives one of these chairs" but allow
; "Kim arrives one of these days".
; DPF 17-dec-03 - Changed KEYREL from reg_diadic_nom_relation to just
; diadic_nom_relation to avoid [SORT entity] constraint, so we can get e.g.
; "hiring sandy is (only) some of the challenge".

basic_partitive_noun_ppof_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                  VAL.KCMP [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #min,
                                     CONT.HOOK [ LTOP #lbl,
						 INDEX #arg ] ],
                             NONLOC.REL #rel,
                             PUNCT.LPUNCT no_punct ] ] ],
    NONLOC.REL #rel,
    LKEYS.KEYREL basic_diadic_nom_relation &
          [ PRED part_of_rel,
	    LBL #lbl,
            ARG1 #arg & basic_non_expl-ind ] ].

partitive_noun_ppof_synsem := basic_partitive_noun_ppof_synsem &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
                      COMPS < #comp > ],
            CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS.KEYREL #keyrel ].

partitive_noun_ppof_agr_synsem := partitive_noun_ppof_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.AGR [ PNG.PN #pn,
                                          DIV #div ],
            AGR [ PNG.PN #pn,
                  DIV #div ] ] ].

partitive_noun_ppof_noagr_synsem := partitive_noun_ppof_synsem.

; all the books, half your salary
; DPF 11-Sept-01 - Added COMPS..ALTMIN norm_non_conj_rel to block e.g.
; 'both Abrams or Browne arrived'
; DPF 1-Oct-01 - Replaced the above with ALTMIN explicit_q_rel to avoid
; spurious parse for "All books".  Maybe no longer need norm_non_conj_rel.
; DPF 25-apr-04 - Deleted the spurious of_p_sel_rel from RELS.

basic_partitive_noun_NP_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                  VAL.COMPS < synsem & 
                            [ LOCAL [ CAT nomp_cat_acc_min &
                                      [ HEAD.MINORS [ MIN #min,
                                                      ALTMIN explicit_q_rel ]],
                                      CONT.HOOK [ LTOP #lbl,
						  INDEX index ],
                                      CONJ cnil ],
                              NONLOC non-local_none,
                              --SIND #arg,
                              OPT -,
                              PUNCT.LPUNCT no_punct ] > ],
            CONT.RELS.LIST < reg_diadic_nom_relation & #keyrel &
                         [ PRED part_of_rel,
			   LBL #lbl,
                           ARG1 #arg & non_expl-ind ],
                         relation & #altkeyrel, ... > ],
    NONLOC.REL 0-dlist,
    LKEYS [ KEYREL #keyrel,
	    ALTKEYREL #altkeyrel ] ].

partitive_noun_NP_synsem := basic_partitive_noun_NP_synsem &
  [ LOCAL.CONT.RELS <! relation, relation !> ].

; DPF 18-aug-09 - Exclude pronouns: "*All us arrived"
; DPF 2010-11-09 - But generalize nonpro_rel to basic_nonpro_rel so we
; can accept |all that|
; 
partitive_noun_NP_agr_synsem := partitive_noun_NP_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR [ PNG.PN #pn,
					  DIV #div ],
			      --MIN basic_nonpro_rel ] >,
            AGR [ PNG.PN #pn,
                  DIV #div ] ],
    LKEYS.ALTKEYREL.PRED explicit_quant_agr_q_rel ].

; both
partitive_noun_NP_noagr_synsem := partitive_noun_NP_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3p ] > ].

; not all
partitive_noun_NP_neg_synsem := basic_partitive_noun_NP_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR [ PNG.PN #pn,
                                          DIV #div ] ] >,
            AGR [ PNG.PN #pn,
                  DIV #div ],
	    CONT.RELS <! relation, 
		       [ LBL #lbl,
			 CFROM #cfrom, CTO #cto ],
		       [ PRED "not_x_deg_rel",
			 LBL #lbl,
			 ARG0 event,
			 ARG1 semarg,
			 CFROM #cfrom, CTO #cto ] !> ] ].

; DPF 03-Dec-03 - Added LPERIPH na to prevent these from appearing as heads
; of appositive phrases: "both abrams"
; DPF 06-dec-03 - Moved COMPS < > to le-type using this synsem, so the lexrule
; for partitives with no of-PP can still propagate any other comps of that
; det, in particular for free-rels like "whichever".
; DPF 11-dec-03 - Made MIN part_of_rel so these fit with constraint on "than"
; as in "Kim has more (of the chairs) to offer than Kim"
; DPF 26-aug-07 - Added NORM norm_rel to prevent these from appearing in
; appositives, blocking spurious ambiguity for e.g. "all the cats"
;; DPF 2012-07-22 - Added [SORT basic-entity-or-event] to prevent spurious 
;; do-be as in |*some he does is arise|
;
partitive_noun_nocomp_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT.HEAD.MINORS [ MIN part_of_rel,
                              NORM norm_rel ],
            CONT.HOOK.INDEX [ PNG.PN 3,
			      SORT basic-entity-or-event ] ],
    MODIFD.LPERIPH na,
    NONLOC.REL 0-dlist,
    LKEYS.KEYREL.PRED generic_entity_rel ].

basic_noun_word := word &
  [ SYNSEM.PUNCT no_punctuation_min ] .

basic_noun_noaffix_word := nonc-hm-nab & basic_noun_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

basic_pronoun_word := basic_noun_word.

noun_noninfl_word := nonc-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

noun_word := nonc-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

basic_intr_noun_word := noun_noninfl_word &
  [ SYNSEM common_noun_nocomp_synsem &
	   [ LOCAL.CONT [ RELS <! relation !>,
                          HCONS <! !> ] ] ].

basic_intr_lex_entry := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	  [ LOCAL.CAT.VAL.SPR < [ --MIN quant_or_wh_rel ] >,
            MODIFD notmod ] ].

n_intr_lex_entry := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_-_c_le">
; <description>Intransitive count noun (icn)    
; <ex>The dog barked.
; <nex>
; <todo>
; </type>
n_-_c_le := n_intr_lex_entry.

; <type val="n_-_c-ed_le">
; <description>Icn, okay for derived adj        
; <ex>C is a long-eared cat.
; <nex>
; <todo>
; </type>
n_-_c-ed_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN n-ed_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_-_c-ed-nocnh_le">
; <description>Icn, ok drvd adj, no nonhd cmpnd 
; <ex>C is a strong-willed cat.
; <nex>
; <todo>
; </type>
n_-_c-ed-nocnh_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN n-ed_rel,
				     NORM norm_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

;; DPF 2011-10-24 - Added LPERIPH na_or_+ to prevent |Abrams will| as cmpnd.
;;
; <type val="n_-_mc-ed-nocnh_le">
; <description>mass noun, ok drvd adj, no nonhd cmpnd 
; <ex>C is a strong-willed cat.
; <nex>
; <todo>
; </type>
n_-_mc-ed-nocnh_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod & [ LPERIPH na_or_+ ],
             LOCAL.CAT.HEAD.MINORS [ MIN n-ed_rel,
				     NORM norm_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

;; DPF 2012-12-15 - Note that `point' should also have MIN be subtype of
;; temp_abstr_rel, in order to admit |from that point on|.  But this would
;; complicate the type hierarchy noticeably.  FIX someday?
;;
; 'end'
; <type val="n_-_c-ed-ns_le">
; <description>Icn, ok drvd adj, unspec sort    
; <ex>It is a wide-ended valley.
; <nex>
; <todo>
; </type>
n_-_c-ed-ns_le := basic_intr_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN n-ed_rel ].

; 'handheld'
; DPF 06-sept-07 - Let's try adding the hack --BARE - here to prevent these
; from undergoing the robust bare-singular rule.  May be too sweeping, but
; avoids a lot of unwanted ambiguity, e.g. for 'remove'
;
; <type val="n_-_c-nocnh_le">
; <description>Icn, excl nonhd in n-n           
; <ex>B bought a classic.
; <nex>
; <todo>
; </type>
n_-_c-nocnh_le := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD [ MINORS [ MIN norm_nom_rel,
                                         NORM norm_rel ],
				--BARE - ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

; e.g. 'other' as in "the other will be ready soon" but "*the chair other"
; <type val="n_-_c-nocpd_le">
; <description>Icn, excl head and nonhd in n-n            
; <ex>The other arrived.
; <nex>
; <todo>
; </type>
n_-_c-nocpd_le := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD notmod & [ LPERIPH bool ],
             LOCAL [ CAT [ HEAD [ MINORS [ MIN norm_nom_rel,
					   NORM norm_rel ],
				  --BARE - ],
			   VAL.SPR < [ --MIN quant_or_wh_rel ] >],
                     CONT.RELS <! relation !> ] ] ].

; e.g. 'Mr'
; <type val="n_-_c-nochd_le">
; <description>Title nouns, excl nonhd in n-n, and head everywhere
; <ex>The young Mr. Browne arrived.
; <nex>
; <todo>
; </type>
n_-_c-nochd_le := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD lmod & [ LPERIPH + ],
             LOCAL [ CAT [ HEAD [ MINORS [ MIN norm_nom_rel,
					   NORM norm_rel ],
				  --BARE - ],
			   VAL.SPR < [ --MIN quant_or_wh_rel ] >],
                     CONT.RELS <! relation !> ] ] ].

; Block some frequently occurring nouns from appearing in title constructions
; ("no title compound")
; <type val="n_-_c-ntc_le">
; <description>Icn, no title compound           
; <ex>The well is empty.
; <nex>
; <todo>
; </type>
n_-_c-ntc_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM no_rel ].

;;; To avoid unwanted ambiguity with eg. |disagreements over wages and cuts|
;;; as all nbar coord, constrain this to plurals
; <type val="n_-_c-ncmp-nttl_le">
; <description>Count, excl nonhd in n-n and excl nonhd in np_title cmpnd
; <ex>The overs [Br.E.] were unexpected.
; <nex>
; <todo>
; </type>
n_-_c-ncmp-nttl_le := n_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod & [ LPERIPH na ],
             LOCAL [ CAT.HEAD [ MINORS [ MIN norm_nom_rel,
					 NORM norm_rel ],
				--BARE - ],
                     CONT.RELS <! reg_nom_relation !>,
		     AGR.PNG.PN 3p ] ] ].


; phone (like number, order)
; No constraint on ARG0.SORT, so can appear in identity copula constructions
; or conjunctions with verbal projections; e.g. "the idea is to win."
;; DPF 2012-02-01 - The constraint [SORT non-time-sort] prevents
;; |the morning is the best part of the day|.  FIX throughout for *-ns* types.
;
; <type val="n_-_c-ns_le">
; <description>Icn, underspec ARG0.SORT         
; <ex>The goal was to win.
; <nex>
; <todo>
; </type>
n_-_c-ns_le := basic_intr_lex_entry &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT.HOOK.INDEX.SORT non-time-sort ] ].

; For determinerless-PPs: 'within range'
; DPF 25-apr-04 - Added ALTMIN quant_or_wh_rel to prevent these from
; appearing as left members of N-N compounds.
; DPF 17-may-05 - But now using NORM to block compounding

basic_n_bare_lex_entry := noun_noninfl_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN bare_nom_rel,
					 NORM norm_rel ],
                           VAL.SPR < unexpressed > ],
                     AGR.PNG.PN 3s ] ],
    IDIOM + ].

intr_n_bare_lex_entry := basic_n_bare_lex_entry & basic_intr_lex_entry &
  [ SYNSEM.LKEYS.KEYREL reg_nom_relation ].

n_bare_ppcomp_lex_entry := basic_n_bare_lex_entry & noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ --MIN quant_or_wh_rel ] >,
		     CONT [ RELS <! relation !>,
			    HCONS <! !> ] ],
	     MODIFD notmod ] ].

n_bare_lex_entry := intr_n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE obliq ].

; 'in (family/open) court'
; <type val="n_-_c-br_le">
; <description>Icn, no det, free mod            
; <ex>We spoke in order.
; <nex>
; <todo>
; </type>
n_-_c-br_le := n_bare_lex_entry.

; 'at eye level' ('*at level')
; <type val="n_-_c-brn_le">
; <description>Icn, no det, obl mod by n        
; <ex>B was at eye level.
; <nex>
; <todo>
; </type>
n_-_c-brn_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_nmod_rel,
             MODIFD.LPERIPH na ] ].

; 'on (summer) vacation' ('*on long vacation')
; <type val="n_-_c-brn*_le">
; <description>Icn, no det, opt mod by n        
; <ex>B was on vacation.
; <nex>
; <todo>
; </type>
n_-_c-brn*_le := n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN bare_n_nmod_rel ].

; 'at close range' ('*at range')
; <type val="n_-_c-brj_le">
; <description>Icn, no det, obl mod by adj      
; <ex>B was on course.
; <nex>
; <todo>
; </type>
n_-_c-brj_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_jmod_rel,
             MODIFD.LPERIPH - ] ].

; 'in (sharp) contrast'
; 'at (long) last'
; <type val="n_-_c-brj*_le">
; <description>Icn, no det, opt mod by adj      
; <ex>B was in view.
; <nex>
; <todo>
; </type>
n_-_c-brj*_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_jmod_rel,
             MODIFD.LPERIPH bool ] ].

; 'at (considerable/company) expense' ('*at expense')
; <type val="n_-_c-brnj_le">
; <description>Icn, no det, obl mod by n,j      
; <ex>B went at great expense.
; <nex>
; <todo>
; </type>
n_-_c-brnj_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_nom_rel,
             MODIFD.LPERIPH na_or_- ] ].

; 'on top', 'of course'
; <type val="n_-_c-brno_le">
; <description>Icn, no det, no mod              
; <ex>B was in line.
; <nex>
; <todo>
; </type>
n_-_c-brno_le := n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN bare_n_nomod_rel ].

; <type val="n_pp_c-brno-of_le">
; <description>Icn, PP-of comp, no det, no mod  
; <ex>B was on top of the hill.
; <nex>
; <todo>
; </type>
n_pp_c-brno-of_le := n_bare_ppcomp_lex_entry &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN bare_n_nomod_rel,
		       VAL.COMPS < [ --MIN _of_p_sel_rel ] > ] ].

; his own
; <type val="n_-_c-poss_le">
; <description>Icn, oblig poss det ('own')      
; <ex>Our own won.
; <nex>
; <todo>
; </type>
n_-_c-poss_le := n_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ ALTMIN def_explicit_q_rel,
				       NORM norm_rel ],
			 VAL.SPR < [ LOCAL.CAT.HEAD.POSS + ] > ],
	     MODIFD.LPERIPH -,
             LKEYS.ALTKEYREL relation ] ].

; Idiom nouns: e.g.
; ahold: 'I got ahold of sandy'
; part: 'I took part in the meeting'

; <type val="n_-_c-br-idm_le">
; <description>Icn, no det, idiomatic           
; <ex>B took part.
; <nex>
; <todo>
; </type>
n_-_c-br-idm_le := intr_n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN bare_n_nomod_rel,
                              CASE non_nom ] ] ].

; <type val="n_-_c-brj-idm_le">
; <description>Icn, no det, idiomatic, modifiable by adj
; <ex>B took unfair advantage of C.
; <nex>
; <todo>
; </type>
n_-_c-brj-idm_le := intr_n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN bare_n_jmod_rel,
                              CASE non_nom ] ] ].

basic_n_intr_temp_lexent := basic_intr_noun_word & 
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN temp_abstr_rel,
                           VAL.SPR < [ --MIN quant_or_wh_rel ] > ],
                     CONT.HOOK.INDEX.SORT time ] ] ].

n_intr_temp_lexent := basic_n_intr_temp_lexent &
  [ SYNSEM.MODIFD notmod ].

; <type val="n_-_c-day_le">
; <description>Temporal noun - day              
; <ex>B won on a weekday.
; <nex>
; <todo>
; </type>
n_-_c-day_le := n_intr_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN unnamed_day_rel ].

; <type val="n_-_c-ssn_le">
; <description>Temporal noun - season           
; <ex>B will sing this season.
; <nex>
; <todo>
; </type>
n_-_c-ssn_le := n_intr_temp_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN season_rel,
             LKEYS.KEYREL.PRED season_rel ] ].

n_-_c-sg_lexent := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS [ MIN norm_nom_rel,
				     ALTMIN quant_or_wh_rel ],
             LKEYS.KEYREL.ARG0.PNG.PN 3s ] ].

; 'grasp, dearth'
; <type val="n_-_c-sg_le">
; <description>Icn, singular only               
; <ex>B's grasp was strong.
; <nex>
; <todo>
; </type>
n_-_c-sg_le := n_-_c-sg_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! reg_nom_relation !> ].

; 'divine'
; <type val="n_-_c-sg-nocnh_le">
; <description>Icn, singular only, excl nonhd in n-n
; <ex>The divine is inaccessible.
; <nex>
; <todo>
; </type>
n_-_c-sg-nocnh_le := n_-_c-sg_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.NORM norm_rel,
		   CONT.RELS <! reg_nom_relation !> ] ].

; 'impetus'
; <type val="n_-_c-sg-ns_le">
; <description>Icn, singular only, unspec sort
; <ex>The main impetus was that Kim arrived.
; <nex>
; <todo>
; </type>
n_-_c-sg-ns_le := n_-_c-sg_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT [ HOOK.INDEX.SORT non-time-sort,
			  RELS <! reg_nom_relation !> ] ] ].

; 'the DFKI'

basic_n_intr_named_lexent := nonc-hm &
  [ INFLECTD -,
    SYNSEM 
     [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                     VAL.SPR < [ --MIN quant_or_wh_rel ] >],
               CONT [ HOOK.LTOP #ltop,
                      RELS <! relation !>,
                      HCONS <! !> ],
               CONJ cnil ],
       MODIFD notmod,
       LKEYS.KEYREL named_nom_relation &
             [ LBL #ltop,
               PRED named_n_rel ] ] ].

n_intr_named_lexent := basic_n_intr_named_lexent &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL.CAT.VAL.SPR < [ OPT - ] > ] ].

; <type val="n_-_c-nm_le">
; <description>Icn, named                       
; <ex>B read the Iliad.
; <nex>
; <todo>
; </type>
n_-_c-nm_le := n_intr_named_lexent &
  [ SYNSEM.PUNCT no_punctuation_min ].

; 'the Alps'
; <type val="n_-_c-nm-pl_le">
; <description>Icn, named, plural only          
; <ex>B visited the Alps.
; <nex>
; <todo>
; </type>
n_-_c-nm-pl_le := n_intr_named_lexent &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.PNG.PN 3p,
             PUNCT no_punctuation_min ] ].

; For period-final names like "u.s."
; <type val="n_-_c-nm-pd_le">
; <description>Icn, named, end in period        
; <ex>B visited the U.S.
; <nex>
; <todo>
; </type>
n_-_c-nm-pd_le := n_intr_named_lexent &
  [ SYNSEM.PUNCT [ LPUNCT no_punct,
                   RPUNCT clause_or_no_punct ] ].

; For robust period-final names like "u.s." lacking specifier
; <type val="n_-_c-nm-pd-nf_le">
; <description>Icn, named, end in period, nonformal
; <ex>U.S. and France argued.
; <nex>
; <todo>
; </type>
n_-_c-nm-pd-nf_le := basic_n_intr_named_lexent &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.NORM norm_rel,
			 VAL.SPR < unexpressed > ],
	     PUNCT [ LPUNCT no_punct,
		     RPUNCT clause_or_no_punct ] ],
    GENRE nonformal ].

; <type val="n_-_c-gen_le">
; <description>Icn, generic                     
; <ex>C is a generic-noun.
; <nex>
; <todo>
; </type>
n_-_c-gen_le := basic_intr_lex_entry & basic_generic_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation &
			  [ PRED generic_nom_rel ] ] ].


basic_noun_ppcomp_word := noun_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem ].

norm_noun_ppcomp_word := basic_noun_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ --MIN independent_rel,
                                       LOCAL.CONT.HOOK.XARG #index ] >,
                     CONT [ RELS <! relation !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL.ARG1 #index ] ].

; DPF 12-mar-05 - Added MODIFD notmod to prevent spurious rule for prenom
; adjectives
noun_empty_ppcomp_word := basic_noun_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
                                     --SIND #index & non_expl-ind ] >,
             LKEYS.KEYREL.ARG1 #index & non_expl ] ].

norm_noun_empty_ppcomp_word := noun_empty_ppcomp_word &
  [ SYNSEM [ MODIFD notmod,
	     LOCAL.CONT [ RELS <! relation !>,
			  HCONS <! !> ] ] ].

noun_ppcomp_word := norm_noun_ppcomp_word &
  [ SYNSEM [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN unspec_diadic_nom_rel ] ].

n_ppcomp_lexent := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
	     MODIFD notmod,
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

; <type val="n_pp_c_le">
; <description>Common noun with PP complement   
; <ex>B has an incentive to win.
; <nex>
; <todo>
; </type>
n_pp_c_le := n_ppcomp_lexent &
  [ SYNSEM.LOCAL.CONT [ RELS <! relation !>,
                        HCONS <! !> ] ].

;; DPF 2012-12-17 - Changed LPERIPH from - to na_or_- in order to admit
;; |a two-mile stretch of highway|
;;
n_ppcomp_nbar_lexent := noun_word &
  [ SYNSEM noun_ppcomp_j_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN diadic_nom_rel,
			   VAL.COMPS < [ OPT -,
					 LOCAL [ CAT [ HEAD prep & [ PRD - ],
						       VAL.COMPS < > ] ],
					 PUNCT.LPUNCT no_punct,
					 --MIN #cmin & selected_rel,
					 --SIND #index & non_expl-ind ] > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! !> ] ],
             MODIFD notmod & [ LPERIPH na_or_- ],
             LKEYS [ KEYREL reg_diadic_nom_relation &
			    [ ARG1 #index & non_expl ],
		     --COMPKEY #cmin ] ] ].

; <type val="n_pp_c-of-brn_le">
; <description>Cn with detless of-PP            
; <ex>That kind of horse wins.
; <nex>
; <todo>
; </type>
n_pp_c-of-brn_le := n_ppcomp_nbar_lexent &
  [ SYNSEM.LKEYS.--COMPKEY _of_p_nbar_rel ].

; <type val="n_pp_c-for-brn_le">
; <description>Cn with detless for-PP            
; <ex>The election for class president was rigged.
; <nex>
; <todo>
; </type>
n_pp_c-for-brn_le := n_ppcomp_nbar_lexent &
  [ SYNSEM.LKEYS.--COMPKEY _for_p_trgt_rel ].

; 'thing about X'
;
; <type val="n_pp_c-obl_le">
; <description>Cn with oblig PP comp            
; <ex>B has a policy on dogs.
; <nex>
; <todo>
; </type>
n_pp_c-obl_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN diadic_nom_rel,
			 VAL.COMPS < [ OPT - ] > ],
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

; 'rest': modable
; 'rest of X': "I am here the rest of the day"
; 
; <type val="n_pp_c-ns-obl_le">
; <description>Cn, oblig PP, unmarked sort      
; <ex>The rest of it arrived.
; <nex>
; <todo>
; </type>
n_pp_c-ns-obl_le := noun_empty_ppcomp_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN modable_nom_rel,
			 VAL.COMPS < [ OPT -,
				       LOCAL.AGR.PNG.PN #pn ] > ],
		   AGR.PNG.PN #pn,
		   CONT [ HOOK.INDEX.SORT non-time-sort,
			  RELS <! relation !>,
			  HCONS <! !> ] ] ].

; <type val="n_pp_c-of_le">
; <description>Cn, PP-of                        
; <ex>B's the winner of the race
; <nex>
; <todo>
; </type>
n_pp_c-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; No title compounds
; <type val="n_pp_c-ntc-of_le">
; <description>Icn, PP-of comp, no title cmpnd  
; <ex>The show of support faded.
; <nex>
; <todo>
; </type>
n_pp_c-ntc-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM no_rel ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; <type val="n_pp_c-ns-of_le">
; <description>Cn, PP-of, unmarked sort         
; <ex>The network of sites won.
; <nex>
; <todo>
; </type>
n_pp_c-ns-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.HOOK.INDEX.SORT non-time-sort ],
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

; <type val="n_pp_c-nt-of_le">
; <description>Cn, PP-of, non-temporal          
; <ex>We got a meeting of chiefs
; <nex>
; <todo>
; </type>
n_pp_c-nt-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN reg_diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; DPF 10-sept-07 - Type for e.g. 'thing' which we don't want as left member
; of compounds.
; <type val="n_pp_c-nsnc-of_le">
; <description>Cn, PP-of, unmrkd sort, no cmpnd 
; <ex>That is the thing of it.
; <nex>
; <todo>
; </type>
n_pp_c-nsnc-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
				       NORM norm_rel ],
		     CONT.HOOK.INDEX.SORT non-time-sort ],
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

; <type val="n_pp_c-ns-nocnh_le">
; <description>Cn, PP, unmrkd sort, no cmpnd 
; <ex>That is the thing of it.
; <nex>
; <todo>
; </type>
n_pp_c-ns-nocnh_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
				     NORM norm_rel ],
		   CONT.HOOK.INDEX.SORT non-time-sort ] ].

; <type val="n_pp_c-of-obl_le">
; <description>Cn, oblig PP-of                  
; <ex>B used a myriad of colors.
; <nex>
; <todo>
; </type>
n_pp_c-of-obl_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         VAL.COMPS < [ OPT - ] > ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; Since partitive rule already applies to measure NPs to produce
; "ten feet of rope", remove the pp-of complement here to avoid spurious
; ambiguity.
; DPF 13-nov-05 - Make NORM quantity_rel so it won't undergo n-n-cmpnd
; rule, but also won't undergo relcl to avoid silly "' huts were"
; DPF 23-apr-09 - Added SPR expressed_synsem to prevent these from being
; bare plurals, as in *|% succeed|
; DPF 20-aug-09 - Re 23-apr-09: But this is wrong, blocking "many gallons"
; which is determiner-less.
;
; <type val="n_-_c-meas_le">
; <description>Icn, measure noun                
; <ex>Ten meters is enough.
; <nex>
; <todo>
; </type>
n_-_c-meas_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN meas_nom_rel,
				     NORM quantity_rel ],
	     LKEYS.KEYREL reg_nom_relation ] ].

;; DPF 2012-09-14 - Added type of measure noun that does not normally appear
;; as a bare NP, such as |*the price fell dollars| or |?Kim is dollars richer|
;; DPF 2012-10-16 - Changed LPERIPH from + to na_or_+ to still allow these
;; as heads in N-N compounds, as in "U.S. dollars"
;;
n_-_c-meas-nb_lexent := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL.CAT [ HEAD [ MINORS [ MIN meas_nom_rel,
					 NORM quantity_rel ],
				CASE real_case ],
			 VAL.SPR < [ --MIN quant_or_wh_rel ] > ],
	     LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_-_c-meas-nb_le">
; <description>Icn, measure noun, not bare,
; <ex>.
; <nex>The price rises dollars.
; <todo>
; </type>
n_-_c-meas-nb_le := n_-_c-meas-nb_lexent &
  [ SYNSEM.MODIFD notmod & [ LPERIPH na_or_+ ] ].

; <type val="n_-_c-meas-frct_le">
; <description>Icn, measure noun, not bare,
; <ex>.
; <nex>Two thirds of the cats arose.
; <todo>
; </type>
n_-_c-meas-frct_le := n_-_c-meas-nb_lexent &
  [ SYNSEM [ MODIFD rmod,
	     LOCAL.CAT.HEAD.MINORS.ALTMIN udef_q_rel ] ].

; <type val="n_-_c-meas-abb_le">
; <description>Icn, measure noun                
; <ex>Ten meters is enough.
; <nex>
; <todo>
; </type>
n_-_c-meas-abb_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN meas_nom_rel,
				     NORM quantity_rel ],
	     LKEYS.KEYREL reg_nom_relation ],
    GENRE written ].

;; DPF 2012-09-27 - Add PRD + to prevent the percent sign from being the 
;; solitary left member of an N-N compound (spurious ambiguity)
;;
; <type val="n_-_c-meas-spr_le">
; <description>Icn, measure noun, only in meas-NP phrases (no overt spr)
; <ex>Ten % is enough.
; <nex>
; <todo>
; </type>
n_-_c-meas-spr_le := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL.CAT [ HEAD [ MINORS [ MIN meas_nom_rel,
					 ALTMIN udef_q_rel,
					 NORM quantity_rel ],
				PRD + ],
			 VAL.SPR < expressed_synsem > ],
	     MODIFD hasmod,
	     LKEYS.KEYREL reg_nom_relation ] ].

; For unusual measure nouns incl. 'some' of 'fifty some feet' and 'plus' of
; 'fifty plus floors'.
;
; <type val="n_-_c-meas-nocnh_le">
; <description>Icn, measure, excl nonhd in n-n  
; <ex>Ten some is enough.
; <nex>
; <todo>
; </type>
n_-_c-meas-nocnh_le := noun_noninfl_word &
  [ SYNSEM count_noun_synsem &
       [ LOCAL [ CAT [ HEAD [ MINORS [ MIN meas_nom_rel,
				       NORM quantity_rel ],
			      MOD < > ],
		       VAL [ SPR < #spr & canonical_synsem &
				   [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
			     SUBJ < >,
			     COMPS < >,
			     SPEC < anti_synsem_min > ] ],
                 CONT [ HOOK.INDEX.DIV +,
			RELS <! relation !>,
			HCONS <! !> ],
		 ARG-S < #spr > ],
         MODIFD rmod,
         LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_pp_c-plc-of_le">
; <description>Cn, PP-of, place noun            
; <ex>This is a place of study.
; <nex>
; <todo>
; </type>
n_pp_c-plc-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN _place_n_1_rel,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

; alternative
; <type val="n_pp_c-ns_le">
; <description>Cn, PP comp, no sort             
; <ex>The idea was to win.
; <nex>
; <todo>
; </type>
n_pp_c-ns_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.HOOK.INDEX.SORT non-time-sort ],
             LKEYS.KEYREL diadic_nom_relation ] ].


; 'way': modable and nosort
;
; <type val="n_pp_c-mod-of_le">
; <description>Cn, PP-of, can modify            
; <ex>B fell that way.
; <nex>
; <todo>
; </type>
n_pp_c-mod-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN modable_nom_rel,
             LKEYS [ KEYREL diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; For abbrev "no." and similarly for "north, south, east, west"

;; Added RPERIPH - to prevent spurious |make synthesized| in n-v-cmpnd

; <type val="n_pp_c-nocnh-of_le">
; <description>Cn, PP-of, excl nonhd in n-n     
; <ex>This make of cars is good.
; <nex>
; <todo>
; </type>
n_pp_c-nocnh-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM norm_rel ],
	     MODIFD.RPERIPH na_or_+,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; <type val="n_pp_c-nocnh_le">
; <description>Cn, PP, excl nonhd in n-n     
; <ex>One alternate to Kim is Browne.
; <nex>
; <todo>
; </type>
n_pp_c-nocnh_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM norm_rel ],
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

noun_ppcomp_j_synsem := basic_two_arg & nonpro_nomod_synsem & 
			common_noun_synsem.

;; For `opposite of happy'
; <type val="n_pp_c-nocnh-ofj_le">
; <description>Cn, PP-of-AP, excl nonhd in n-n     
; <ex>B is the opposite of happy.
; <nex>
; <todo>
; </type>
n_pp_c-ofj_le := noun_word &
  [ SYNSEM noun_ppcomp_j_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT [ HEAD.MINORS.MIN diadic_nom_rel,
			   VAL.COMPS < expressed_synsem &
				       [ OPT -,
					 --MIN #cmin,
					 LOCAL [ CAT [ HEAD prep & [ PRD - ],
						       VAL.COMPS < > ],
						 CONT.HOOK.LTOP #cltop ],
					 PUNCT.LPUNCT no_punct ] > ],
		     CONT [ RELS <! relation !>,
			    HCONS <! qeq & [ HARG #arg1, LARG #cltop ] !> ] ],
             LKEYS [ KEYREL basic_diadic_nom_relation &
			    [ ARG1 #arg1 ],
                     --COMPKEY #cmin & _of_p_comp_rel ] ] ].

noun_double_ppcomp_word := noun_word &
  [ SYNSEM noun_ppcomp_three_arg_synsem &
         [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         VAL.COMPS < [ --MIN selected_rel,
                                       --SIND #index1 & non_expl-ind ],
                                     [ --MIN selected_rel,
                                       --SIND #index2 & non_expl-ind ] > ],
                   CONT.RELS <! relation !> ],
           LKEYS.KEYREL reg_triadic_nom_relation &
                        [ ARG1 #index1,
                          ARG2 #index2 ] ] ].

; <type val="n_pp-pp_c_le">
; <description>Cn, two PP comps                 
; <ex>Gifts of B to C are rare.
; <nex>
; <todo>
; </type>
n_pp-pp_c_le := noun_double_ppcomp_word.

basic_n_temp_ppcomp_lexent := noun_word &
  [ SYNSEM temp_noun_ppcomp_two_arg_synsem ].

norm_n_temp_ppcomp_lexent := basic_n_temp_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --MIN _of_p_sel_rel ] >,
                   CONT [ RELS <! relation !>,
                          HCONS <! !> ] ] ].

; DPF 22-May-02 - Note that we have to have two entries for the word "time",
; one which must take a determiner, and which can appear in a temp-mod phrase;
; and the other which denotes a temporal chunk and can't appear as temp-mod:
; "He'll stay this time" but "*He stayed time for a meeting" (Cf. "Do you 
; have time for a meeting.")

; DPF 05-dec-03 - Added NORM as hack to prevent these from appearing as 
; left members of n-n-cmpnds like 'afternoon Monday' though maybe actually OK.
; DPF 06-dec-03 - Removed of-PP complement since possessive of-PP now does the
; work, and we avoid spurious ambiguity.
; DPF 22-sept-04 - Changed SPR from expressed_synsem to synsem so these will
; undergo the hdn_bnp_c rule, which requires the SPR to be 'unexpressed'.

n_temp_lexent := n_intr_temp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < synsem > ].

; <type val="n_pp_c-day_le">
; <description>Temporal noun - day, PP comp     
; <ex>B arrived the day C won.
; <nex>
; <todo>
; </type>
n_pp_c-day_le := norm_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN unnamed_day_rel,
             MODIFD notmod ] ].

; <type val="n_pp_c-t-of-nb_le">
; <description>Temporal noun, detless PP-of     
; <ex>The time of day was clear.
; <nex>
; <todo>
; </type>
n_pp_c-t-of-nb_le := basic_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL 
              [ CAT [ HEAD.MINORS.MIN non_day_time_rel,
		      VAL.COMPS < [ OPT -,
				    --MIN _of_p_nbar_rel,
				    LOCAL.CONT.HOOK [ INDEX #nind,
						      XARG #nhand ] ]> ],
                CONT [ RELS <! relation, 
			       #altkeyrel & [ PRED udef_q_rel,
					      ARG0 #nind,
					      RSTR #rhand ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #nhand ] !> ] ],
             MODIFD notmod & [ LPERIPH - ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; <type val="n_-_c-min_le">
; <description>Temp noun - minute               
; <ex>B arrives in ten minutes.
; <nex>
; <todo>
; </type>
n_-_c-min_le := n_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN _minute_n_1_rel ].

; <type val="n_-_c-nday_le">
; <description>Temporal noun - nonday           
; <ex>B won in the first week.
; <nex>
; <todo>
; </type>
n_-_c-nday_le := n_temp_lexent & 
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN nonday_n_rel ].

; <type val="n_-_c-nday-pl_le">
; <description>Temporal noun - nonday, plural   
; <ex>B won in the first two weeks
; <nex>
; <todo>
; </type>
n_-_c-nday-pl_le := n_temp_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN nonday_n_rel,
                   CONT.HOOK.INDEX.PNG.PN 3p ] ].

; <type val="n_-_c-week_le">
; <description>Temporal noun - only |week|
; <ex>B arrived in/on the first week.
; <nex>
; <todo>
; </type>
n_-_c-week_le := n_temp_lexent & 
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN _week_n_1_rel ].

; <type val="n_-_c-hour_le">
; <description>Temporal noun - only hour? - with either at, in, on
; <ex>B won in the first hour.
; <nex>
; <todo>
; </type>
n_-_c-hour_le := n_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN hour_or_time_rel ].

; <type val="n_-_c-year_le">
; <description>Temporal noun - year             
; <ex>B won in that year.
; <nex>
; <todo>
; </type>
n_-_c-year_le := n_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN year_n_rel ].

; <type val="n_-_c-year-pl_le">
; <description>Temporal noun - year, plural     
; <ex>B was two yrs. old.
; <nex>
; <todo>
; </type>
n_-_c-year-pl_le := n_temp_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN year_n_rel,
                   CONT.HOOK.INDEX.PNG.PN 3p ] ].

;; DPF 2010-10-02 - Added NORM norm_rel to block spurious compound analysis
;; for |Friday morning|
n_-_c-day_lexent := basic_n_intr_temp_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN dofw_rel,
                                       ALTMIN quant_or_wh_rel,
				       NORM norm_rel ],
                         VAL.SPR < synsem > ],
             MODIFD notmod_or_rmod,
             LKEYS.ALTKEYREL.PRED quant_or_wh_rel ] ].

; <type val="n_-_c-dow_le">
; <description>Temporal noun - day of week      
; <ex>B won on Monday.
; <nex>
; <todo>
; </type>
n_-_c-dow_le := n_-_c-day_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED dofw_rel ].

; <type val="n_-_day-crd-gen_le">
; <description>Temporal noun - day, generic     
; <ex>B won on generic-noun.
; <nex>
; <todo>
; <native> n_-_c-day_le & [ SYNSEM.LKEYS.KEYREL.PRED dofm_rel ]
; </type>
n_-_day-crd-gen_le := n_-_c-day_lexent & generic_ne_lex_entry &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR.FIRST unexpressed,
	     LKEYS.KEYREL.PRED dofm_rel ] ].

; DPF 13-May-02 - Added LPERIPH + to prevent these from appearing as heads of
; noun-noun compounds.
; DPF 22-May-02 - But this also blocks "rainy April" - try again.
; DPF 22-May-02 - Changed ALTMIN from basic_nom_rel to quant_or_wh_rel to be 
; consistent with constraints on relative clause modifiees.
; DPF 26-jun-09 - Added NORM norm_rel to enable blocking of spurious
; noun-n-cmpnd for "January meeting" (want np-n-cmpnd instead).
;; DPF 2011-10-22 - Re 26-jun-09: the [LPERIPH -] constraint prevented
;; analysis of |January meeting| as np-n-cmpnd, so changed to LPERIPH bool,
;; and we'll see why it was here.
;
; <type val="n_-_c-month_le">
; <description>Temporal noun - month            
; <ex>B won in January.
; <nex>
; <todo>
; </type>
n_-_c-month_le := n_temp_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN mofy_rel,
                                     ALTMIN quant_rel,
				     NORM norm_rel ],
             LKEYS [ KEYREL generic_named_nom_relation &
			    [ PRED mofy_rel ],
                     ALTKEYREL.PRED quant_or_wh_rel ],
             MODIFD notmod & [ LPERIPH bool ] ] ].

; "way" as in "find a way to do that" -- was used in VM, but analysis changed
; so this type not currently in use.  Its semrel.tdl entry was as follows:
;   _way_rel := hcomp_nom_rel &
;     [ ARG0.SORT entity ].

; <type val="n_vp_c_le">
; <description>Cn, VP comp                      
; <ex>B has the ability to win.
; <nex>
; <todo>
; </type>
n_vp_c_le := noun_word &
  [ SYNSEM common_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; 'permission'
; <type val="n_vp_m_le">
; <description>Mass noun, VP comp               
; <ex>B has permission to stay.
; <nex>
; <todo>
; </type>
n_vp_m_le := noun_word &
  [ SYNSEM mass_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; 'clearance(s)'
; <type val="n_vp_mc_le">
; <description>Mass-count, VP comp              
; <ex>B has clearance to stay.
; <nex>
; <todo>
; </type>
n_vp_mc_le := noun_word &
  [ SYNSEM mass_count_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

#|
; <type val="n_cp_c-fin_le">
; <description>Cn, finite CP comp               
; <ex>The fact that B fell irks.
; <nex>
; <todo>
; </type>
n_cp_c-fin_le := noun_word &
  [ SYNSEM common_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].
|#

; 'reason' - The reason Kim left bothered sandy"
n_cpcomp_optthat_lexent := noun_word &
  [ SYNSEM basic_count_noun_cpcomp_synsem & 
	   [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT [ HEAD [ VFORM fin,
						     TAM indic_tam,
						     INV - ],
					      VAL.SPR *olist* ] ],
	     MODIFD notmod ] ].

; <type val="n_cp_c-optc_le">
; <description>Cn, finite CP comp, opt cmplzer  
; <ex>B has a feeling C fell.
; <nex>
; <todo>
; </type>
n_cp_c-optc_le := n_cpcomp_optthat_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
		       VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ] ].

;; DPF 2012-03-09 - Maybe we don't need this type after all, since at least
;; for `question' it's an issue of polarity: 
;; |there is no question that Kim arrived|

#|
; `question'
; <type val="n_cp_c-q_le">
; <description>Cn, finite CP comp, question
; <ex>The question "who won" is important.
; <nex>
; <todo>
; </type>
n_cp_c-q_le := n_cpcomp_optthat_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
		       VAL.COMPS < [ LOCAL [ CAT s_cat_fin_unspec &
						 [ HEAD verb & 
						     [ TAM.TENSE real_tense ],
						   MC + ],
					     CONT.HOOK.INDEX.SF ques ] ] > ] ].
|#

; 'way': modable
; <type val="n_cp_c-mod_le">
; <description>Cn, cp comp, can modify          
; <ex>B fell the way C did.
; <nex>
; <todo>
; </type>
n_cp_c-mod_le := n_cpcomp_optthat_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN modable_nom_rel,
		       VAL.COMPS < [ LOCAL.CAT.MC - ] > ] ].

; 'request'
; <type val="n_cp_c-bse_le">
; <description>Cn, base form CP comp            
; <ex>B's wish that C be in irks
; <nex>
; <todo>
; </type>
n_cp_c-bse_le := noun_word &
  [ SYNSEM common_noun_cpcomp_bse_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; procedure
; <type val="n_cp_c-inf_le">
; <description>Cn, inf CP comp                  
; <ex>Procedures for C to go won
; <nex>
; <todo>
; </type>
n_cp_c-inf_le := noun_word &
  [ SYNSEM common_noun_cpcomp_inf_synsem &
	   [ MODIFD notmod ] ].

#|
; notification
; <type val="n_cp_mc-fin_le">
; <description>Mass-count, fin CP comp          
; <ex>B got proof that C won.
; <nex>
; <todo>
; </type>
n_cp_mc-fin_le := noun_word &
  [ SYNSEM mass_count_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].
|#

; news
; <type val="n_cp_m-optc_le">
; <description>Mass, fin CP comp          
; <ex>B got news that C won.
; <nex>
; <todo>
; </type>
n_cp_m-optc_le := noun_word &
  [ SYNSEM mass_noun_cpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; chance
; <type val="n_cp_mc-optc_le">
; <description>Mass-count, fin CP or S comp
; <ex>There is little chance he'll win.
; <nex>
; <todo>
; </type>
n_cp_mc-optc_le := noun_word &
  [ SYNSEM basic_mass_count_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; build head_complement structure which is still words (with 
; [ SYNSEM lex_synsem ].

noun_hclex_word := noncqrs-m & basic_noun_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

; <type val="n_np_c_le">
; <description>Cn, NP comp                      
; <ex>The hotel B collapsed.
; <nex>
; <todo>
; </type>
n_np_c_le := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM common_noun_npcomp_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         HC-LEX + ],
	     MODIFD notmod ] ].

; <type val="n_nb_c_le">
; <description>Cn, nbar comp ('term')           
; <ex>B knew the term ace.
; <nex>
; <todo>
; </type>
n_nb_c_le := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM common_noun_nbarcomp_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         HC-LEX + ],
	     MODIFD notmod ] ].

; 'the word "chair"', 'the term "whippletree"'

; <type val="n_nb_c-qt_le">
; <description>Cn, nbar quoted ('term')         
; <ex>B knew the term "ace".
; <nex>
; <todo>
; </type>
n_nb_c-qt_le := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM common_noun_nbarcomp_synsem &
	   [ LOCAL.CAT [ HEAD [ MINORS.MIN norm_nom_rel,
				--BARE - ],
                         VAL.KCMP [ PUNCT [ LPUNCT pair_or_no_punct,
                                            RPUNCT pair_or_no_punct ],
                                    OPT -,
				    LOCAL.CAT.HEAD.--BARE - ],
                         HC-LEX + ],
	     MODIFD notmod ] ].

; Use special inflectional rule to produce plural inflected form without 's'
;; DPF 18-jul-2010 - Added constraint on --BARE as hack to prevent appositive
;; analysis of |$ ten million|.  FIX?
n_numcomp_lexent := nonc-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM common_noun_numcomp_synsem &
	   [ LOCAL [ CAT.HEAD.--BARE +,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL.LBL #ltop,
             MODIFD notmod ] ].

; <type val="n_-_c-cur_le">
; <description>Icn, currency                    
; <ex>The price was $100.
; <nex>
; <todo>
; </type>
n_-_c-cur_le := n_numcomp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < anti_synsem_min > ].

#|
; <type val="n_-_c-cur-gen_le">
; <description>Icn, currency, generics          
; <ex>The price was US$100.
; <nex>
; <todo>
; </type>
n_-_c-cur-gen_le := n_numcomp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
	     LKEYS.KEYREL named_nom_relation &
				 [ PRED gen_currency_rel ] ] ].
|#

; <type val="n_-_m_le">
; <description>Intransitive mass noun (imn)     
; <ex>Dignity is desirable.
; <nex>
; <todo>
; </type>
n_-_m_le := noun_noninfl_word &
  [ SYNSEM mass_noun_synsem &
	   [ MODIFD notmod ] ].

; <type val="n_-_m-ns_le">
; <description>Intransitive mass noun, unspecified sort
; <ex>Losing is no fun.
; <nex>
; <todo>
; </type>
n_-_m-ns_le := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.RELS <! nom_relation !> ] ] ].

; <type val="n_-_m-time_le">
; <description>Intransitive mass noun, only for `time'
; <ex>We arrived at breakfast time.
; <nex>
; <todo>
; </type>
n_-_m-time_le := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN time_nomod_rel,
		     CONT.RELS <! relation !> ],
	     MODIFD notmod ] ].

; <type val="n_-_m-ed_le">
; <description>Mass, okay for derived adj       
; <ex>C is a good-natured cat.
; <nex>
; <todo>
; </type>
n_-_m-ed_le := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS.MIN n-ed_rel,
                     CONT.RELS <! reg_nom_relation !> ] ] ].

; The inevitable
; <type val="n_-_m-def_le">
; <description>Mass, definite det               
; <ex>The inevitable happened.
; <nex>
; <todo>
; </type>
n_-_m-def_le := noun_noninfl_word &
  [ SYNSEM mass_noun_synsem &
	   [ MODIFD notmod,
	     LOCAL.CAT [ HEAD.MINORS.NORM norm_rel,
			 VAL.SPR < expressed_synsem &
				   [ --MIN def_q_rel ] > ],
	     LKEYS.KEYREL reg_nom_relation ] ].


; Removed LPERIPH na because it prevents these from heading NP-N cmpnds.
; <type val="n_-_mc_le">
; <description>Intrans noun, underspec mss-cnt  
; <ex>B feared disaster.
; <nex>
; <todo>
; </type>
n_-_mc_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_-_mc-ntc_le">
; <description>Intrans noun, underspec mss-cnt, not title compounds
; <ex>B had his say.
; <nex>
; <todo>
; </type>
n_-_mc-ntc_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS [ MIN norm_nom_rel,
				     NORM no_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

; For e.g. `dinner' to avoid spurious appositive for 
; <type val="n_-_mc-time_le">
; <description>Intrans noun, SORT time
; <ex>Dinner follows lunch.
; <nex>
; <todo>
; </type>
n_-_mc-time_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.HOOK.INDEX.SORT time ],
             LKEYS.KEYREL nom_relation ] ].

n_-_mc-ns_lexent := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.HOOK.INDEX.SORT non-time-sort ],
             LKEYS.KEYREL nom_relation ] ].

; Removed LPERIPH na because it prevents these from heading NP-N cmpnds.
; <type val="n_-_mc-ns_le">
; <description>Intr mc, no sort                 
; <ex>B's intent was that C won.
; <nex>
; <todo>
; </type>
n_-_mc-ns_le := n_-_mc-ns_lexent.

; For "_guess_" unknown-noun entry
; <type val="n_-_mc-ns-g_le">
; <description>Intr mc, 'guessed' noun (obs?)   
; <ex>The _guess_ was happy.
; <nex>
; <todo>
; <native> n_-_mc-ns_le
; </type>
n_-_mc-ns-g_le := n_-_mc-ns_lexent & generic_lex_entry &
  [ SYNSEM.LKEYS.KEYREL.PRED string ].

; <type val="n_-_mc-nocnh_le">
; <description>Intr mc, no non-hd compound      
; <ex>B's potential was high.
; <nex>
; <todo>
; </type>
n_-_mc-nocnh_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                     NORM norm_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

; 'time': modable
; LPERIPH is na_or_- so it can be head of N-N-cmpnd rule as in "work times"
; DPF 16-aug-09 - Block as non-head in N-N-cmpnd, to avoid spurious ambig with
; n_-_m_le variant

; <type val="n_-_c-time_le">
; <description>Intr mc, temporal                
; <ex>B fell that time.
; <nex>
; <todo>
; </type>
n_-_c-time_le := noun_noninfl_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD notmod & [ LPERIPH na_or_- ],
             LOCAL [ CAT.HEAD.MINORS.MIN non_day_time_rel,
                     CONT [ HOOK.INDEX.SORT time,
                            RELS <! relation !>,
                            HCONS <! !> ] ] ] ].


; <type val="n_-_c-pl-mod_le">
; <description>Intr mc, plural, modable: maybe only |fold| and |times|
; <ex>B fell four-fold.  B is ten times faster.
; <nex>
; <todo>
; </type>
n_-_c-pl-mod_le := n_plur_lexent &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD notmod & [ LPERIPH na_or_- ],
	     LOCAL.CAT.HEAD.MINORS.MIN non_day_modable_rel ] ].

; <type val="n_-_mc-ed_le">
; <description>Mass-count, okay for derived adj 
; <ex>C is a high-powered cat.
; <nex>
; <todo>
; </type>
n_-_mc-ed_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN n-ed_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_-_c-cpd_le">
; <description>Intransitive count noun, left member of compounds only
; <ex>The Abrams Co. president won.
; <nex>
; <todo>
; </type>
n_-_c-cpd_le := n_intr_lex_entry &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                           VAL.SPR < [ LOCAL.AGR.PNG.PN 3p ] > ],
                     CONT.HOOK.INDEX [ PNG png & [ PN 3s ],
                                       DIV - ] ],
             LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_pp_m_le">
; <description>Mass, PP comp                    
; <ex>Love of candy is common.
; <nex>
; <todo>
; </type>
n_pp_m_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ MODIFD notmod ] ].

; <type val="n_pp_m-obl_le">
; <description>Mass, oblig PP comp              
; <ex>Love for candy is common.
; <nex>
; <todo>
; </type>
n_pp_m-obl_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

; 'home of X' - avoid spurious ambiguity with 'the home of X'
; <type val="n_pp_m-brn_le">
; <description>Mass, detless PP comp            
; <ex>B has status as leader.
; <nex>
; <todo>
; </type>
n_pp_m-brn_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_nospr_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL [ SPR < unexpressed >,
                             COMPS < [ OPT - ] > ] ] ].

; <type val="n_pp_mc_le">
; <description>Mass-count (mc), PP comp         
; <ex>B has a desire for candy.
; <nex>
; <todo>
; </type>
n_pp_mc_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
	   [ MODIFD notmod ] ].

; <type val="n_pp_mc_le">
; <description>Mass-count (mc), PP comp         
; <ex>B has a desire for candy.
; <nex>
; <todo>
; </type>
n_pp_mc-ns_le := noun_noninfl_word &
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN reg_diadic_nom_rel,
		     CONT.HOOK.INDEX.SORT non-time-sort ],
             MODIFD notmod ] ].

; <type val="n_pp_mc-obl_le">
; <description>Mc, oblig PP comp                
; <ex>B has experience with cats
; <nex>
; <todo>
; </type>
n_pp_mc-obl_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

; <type val="n_pp_mc-of_le">
; <description>Mc, PP-of comp                   
; <ex>Loss of memory is common.
; <nex>
; <todo>
; </type>
n_pp_mc-of_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

; <type val="n_pp_mc-nocnh-of_le">
; <description>Mc, PP-of comp, no nonhd cmpnd   
; <ex>That make of car is rare.
; <nex>
; <todo>
; </type>
n_pp_mc-nocnh-of_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM norm_rel ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; For "order" as in "my order, number 12345" where appositive rule requires
; compatibility of sorts.

; <type val="n_pp_mc-of-ns_le">
; <description>Mc, PP-of comp, no sort          
; <ex>Invention of ice was easy.
; <nex>
; <todo>
; </type>
n_pp_mc-of-ns_le := noun_noninfl_word &
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
           [ LOCAL [ CAT.HEAD.MINORS.MIN reg_diadic_nom_rel,
		     CONT.HOOK.INDEX.SORT non-time-sort ],
             MODIFD notmod,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

; <type val="n_pp_mc-for_le">
; <description>Mc, PP-for comp                  
; <ex>B found reasons for cats.
; <nex>
; <todo>
; </type>
n_pp_mc-for_le := noun_noninfl_word &
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
	     LKEYS.--COMPKEY _for_p_sel_rel ] ].

; <type val="n_pp_mc-to_le">
; <description>Mc, PP-to comp                   
; <ex>Shipment to China is easy.
; <nex>
; <todo>
; </type>
n_pp_mc-to_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
	     LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS.--COMPKEY _to_p_sel_rel ] ].

; <type val="n_pp_mc-in_le">
; <description>Mc, PP-in comp                   
; <ex>Interest in cats is rare.
; <nex>
; <todo>
; </type>
n_pp_mc-in_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
	     LKEYS.--COMPKEY _in_p_sel_rel ] ].

; <type val="n_pp_mc-of-lhc_le">
; <description>mc, PP-of comp, HC-LEX +
; <ex>The University of Washington professor arrives.
; <nex>
; <todo>
; </type>
n_pp_mc-of-lhc_le := basic_noun_word & nonconj & mcna &
  [ INFLECTD na_or_-,
    SYNSEM mass_or_count_ppcomp_synsem &
	   [ LOCAL [ CAT.HC-LEX +,
		     CONT.HOOK.LTOP #ltop ],
	     MODIFD notmod,
             LKEYS [ KEYREL.LBL #ltop,
		     --COMPKEY _of_p_sel_rel ] ] ].

n_pp_c-of-lhc_le := basic_noun_word & nonconj & mcna &
  [ INFLECTD na_or_-,
    SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
			   HC-LEX +,
			   VAL.COMPS < [ --MIN selected_rel,
                                     --SIND #index & non_expl-ind ] > ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !>,
                            HCONS <! !> ] ],
	     MODIFD notmod,
             LKEYS [ KEYREL [ LBL #ltop,
			      ARG1 #index & non_expl ],
		     --COMPKEY _of_p_sel_rel ] ] ].

; Don't appear as left or right members of compounds: e.g. 'last'
n_mass_no_cmpnd_lexent := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                       NORM norm_rel ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

; <type val="n_-_m-nocnh_le">
; <description>Mass, excl nonhd in n-n          
; <ex>Some slack would be nice.
; <nex>
; <todo>
; </type>
n_-_m-nocnh_le := n_mass_no_cmpnd_lexent.

; <type val="n_-_m-nochd_le">
; <description>Mass, excl head and non-head in n-n          
; <ex>The next is Kim.
; <nex>
; <todo>
; </type>
n_-_m-nochd_le := n_mass_no_cmpnd_lexent &
  [ SYNSEM [ MODIFD.LPERIPH +,
	     LOCAL.CAT.VAL.SPR < expressed_synsem > ] ].

; <type val="n_-_m-ncmp-nttl_le">
; <description>Mass, excl nonhd in n-n and excl nonhd in np_title cmpnd
; <ex>The above illustrates the point.
; <nex>
; <todo>
; </type>
n_-_m-ncmp-nttl_le := n_mass_no_cmpnd_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR.FIRST expressed_synsem,
	     MODIFD.LPERIPH na ] ].

; 'they hunted bear.'  Prevent from compounds, from and subject position,
; but can't easily prevent ambiguity for "bear hunting was popular"), 
; with 'bear' as subject of verbal gerund.  Also prevent specifier,
; to avoid spurious ambiguity for "the bear has four legs." - here, rather
; want underspecification, probably.

; <type val="n_-_m-kind_le">
; <description>Mass, kind                       
; <ex>B hunted bear.
; <nex>
; <todo>
; </type>
n_-_m-kind_le := n_mass_no_cmpnd_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE non_nom,
                       VAL.SPR < unexpressed_reg > ] ].

; 'red', 'blue' - don't appear as left members of compounds, but can
; appear as either mass or count.
; DPF 15-jan-08 - Added hack PRD + to these, and removed [NORM norm_rel],
; since we want "orange-encrusted" but still want to block n-n compound
; for "orange cat".  Maybe FIX?
; DPF 31-dec-08 - No longer treating colors as adjs derived from nouns,
; but rather treating adj as basic, and deriving color noun from it.
;; DPF 2012-02-06 - Added NORM no_rel to block spurious ambiguity with copula,
;; as in |The city is northwest|.
;; DPF 2012-11-10 - Re 15-jan-08: Since this type is now only used for
;; directional nouns, and we want |north wall|, remove PRD +, and change
;; HEAD from noun_adjable to just noun.

n_-_mc-ntoj_lexent := noun_noninfl_word &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD noun &
                              [ MINORS [ MIN norm_nom_rel,
					 NORM no_rel ] ],
		     AGR #agr,
                     CONT [ HOOK.INDEX #agr,
                            RELS <! relation !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_-_c-dir_le">
; <description>Icn, directional                 
; <ex>The north is often cold.
; <nex>
; <todo>
; </type>
n_-_c-dir_le := n_-_mc-ntoj_lexent &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
           [ MODIFD.LPERIPH na_or_+ ] ].

basic_n_plur_lexent := noun_noninfl_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL.CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                          HCONS <! !> ] ] ].

n_plur_lexent := basic_n_plur_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                               DIV + ] ] >,
                   CONT.RELS <! relation !> ] ].

; <type val="n_-_c-pl_le">
; <description>Icn, plur only                   
; <ex>Cattle grazed.
; <nex>
; <todo>
; </type>
n_-_c-pl_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; Bi-partite nouns like "scissors" or "sunglasses".  The basic entry is
; unmarked for INDEX.IND, but constrained to be GENRE informal, so we will
; parse "many sunglasses were cracked".  But there is a lexical rule which
; stamps [GENRE prescrip] and [IND -] on these entries, so the generator
; can be constrained to only generate "many pairs of sunglasses" (using
; a semantically empty classifier noun "pair").

; <type val="n_-_bipart_le">
; <description>Mc, bipartite                    
; <ex>These scissors are sharp.
; <nex>
; <todo>
; </type>
n_-_bipart_le := noun_noninfl_word &
  [ SYNSEM basic_mass_or_count_nocomp_synsem &
           [ LOCAL [ CAT.HEAD noun &
                              [ MINORS.MIN norm_nom_rel,
				PRD - ],
                     CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                            HCONS <! !> ] ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ],
    GENRE informal ].

; 'systems analyst' - 'systems' is uninflected, and the constraint on the
; SPR is a hack to prevent it from undergoing plural inflectional rule.
; Maybe a better constraint would be to make SPR < anti-synsem >, but
; this would require adjusting the hierarchy of noun synsems - FIX.
;; DPF 2012-10-24 - Changed hack to use [LOCAL noninfl_noun_local]
;; to block inflectional rule (avoiding |the systemsses arose| etc.

; <type val="n_-_c-pl-cpd_le">
; <description>Icn, plur, compound non-hd only  
; <ex>B hired a systems analyst.
; <nex>
; <todo>
; </type>
n_-_c-pl-cpd_le := basic_n_plur_lexent &
  [ SYNSEM [ LOCAL noninfl_noun_local &
		   [ CAT [ HEAD.MINORS.MIN norm_nom_rel ],
                     CONT.RELS <! relation !> ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; DPF 28-jun-07 - Constrained SPR to be expressed_synsem, to avoid e.g.
; spurious analysis for "many arrived".  Note that this fails to block
; nbar coordination without a determiner as in "proud and domestic animals"
; since the coord rule cannot propagate the whole unified synsems from the
; two dtrs (because of unwanted resulting circularity in feature structure).
; FIX.
; DPF 20-aug-09 - Added LPERIPH - to prevent these in NP-title compounds,
; such as the spurious analysis of "many cats"
;
; 'the few', 'the proud'
; <type val="n_-_c-pl-def_le">
; <description>Icn, plur, definite det          
; <ex>The poor are numerous.
; <nex>
; <todo>
; </type>
n_-_c-pl-def_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN norm_nom_rel,
                                       NORM norm_rel ],
                         VAL.SPR < expressed_synsem &
                                   [ --MIN def_q_rel ] > ],
             MODIFD notmod & [ LPERIPH - ],
             LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_-_c-pl-idm_le">
; <description>Icn, plur, idiom                 
; <ex>B kept tabs on C.
; <nex>
; <todo>
; </type>
n_-_c-pl-idm_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ],
    IDIOM + ].

; "euro's" which the preprocessor turns into "euro 's"
n_plur_mwe_lexent := nonc-hm & basic_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                               DIV + ] ] >,
                     CONT [ HOOK [ LTOP #ltop,
				   INDEX.PNG png & [ PN 3p ] ],
			    HCONS <! !> ] ],
	     LKEYS.KEYREL.LBL #ltop ] ].

; <type val="n_-_c-pl-mwe_le">
; <description>Icn, plur, multi-word            
; <ex>B spent many euro's.
; <nex>
; <todo>
; </type>
n_-_c-pl-mwe_le := n_plur_mwe_lexent & nonc-hm-nab &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.RELS <! relation !> ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; <type val="n_-_c-pl-one_le">
; <description>Icn, plur, ones                  
; <ex>The ones B supported won.
; <nex>
; <todo>
; </type>
n_-_c-pl-one_le := basic_n_plur_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN _one_n_1_rel,
                           VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                                   DIV + ] ] > ],
                     CONT.RELS <! [ LBL #lbl,
                                    PRED generic_entity_rel,
                                    ARG0 #arg0 ],
				  #altkeyrel &
				  [ LBL #lbl,
				    PRED card_rel,
				    ARG0 event & [ E [ TENSE no_tense,
						       ASPECT no_aspect ] ],
				    ARG1 #arg0,
				    CARG "2+" ] !> ],
             MODIFD notmod_or_rmod,
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; For plurals like "sixties" which can directly undergo the npadv_mod rule.
; DPF 8-nov-03 - Can't see why we want "sixties" under npadv_mod rule, so
; changed gen_numval_rel to not inherit from modable_rel.
;; DPF 2012-09-12 - Also added MODIFD notmod to prevent spurious analysis of
;; |$10 million| with noun_adjn compound rule.

n_-_c-pl-num_lexent := n_plur_mwe_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN gen_numval_rel,
				PRD + ],
		     CONT.RELS <! [ LBL #lbl,
				    PRED generic_entity_rel,
				    ARG0 #index ],
			        #altkeyrel & const_relation &
			        [ LBL #lbl,
				  PRED card_rel,
				  ARG0 event & [ E [ TENSE no_tense,
						     ASPECT no_aspect ] ],
				  ARG1 #index ] !> ],
	     MODIFD notmod,
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; <type val="n_-_c-pl-num_le">
; <description>Icn, plur, numbers               
; <ex>Millions arrived.
; <nex>
; <todo>
; </type>
n_-_c-pl-num_le := n_-_c-pl-num_lexent &
  [ INFLECTD - ].

n_intr_infl_lex_entry := nonc-hm & basic_noun_word &
  [ INFLECTD +,
    SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
			   VAL.SPR < [ --MIN quant_or_wh_rel ] > ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !>,
			    HCONS <! !> ] ],
	     MODIFD notmod,
	     LKEYS.KEYREL reg_nom_relation & [ LBL #ltop ] ] ].

; For singular nouns which are already inflected
; <type val="n_-_c-sg-ifl_le">
; <description>Icn, singular, already inflected
; <ex>A strange being appeared.
; <nex>
; <todo>
; </type>
n_-_c-sg-ifl_le := n_intr_infl_lex_entry &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3s,
					       DIV - ] ] >,
		   CONT.HOOK.INDEX [ PNG.PN 3s,
				     DIV - ] ] ].

; For singular nouns which are already inflected, no post-modif.
; <type val="n_-_c-sg-ifl-nmd_le">
; <description>Icn, singular, already inflected, no post-modif
; <ex>They stayed for a long while.
; <nex>
; <todo>
; </type>
n_-_c-sg-ifl-nmd_le := n_intr_infl_lex_entry &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.NORM no_rel,
			   VAL.SPR < [ LOCAL.AGR [ PNG.PN 3s,
						   DIV - ] ] > ],
		     CONT.HOOK.INDEX [ PNG.PN 3s,
				       DIV - ] ],
	     MODIFD [ LPERIPH bool,
		      RPERIPH + ] ] ].

; <type val="n_-_c-sg-cpd_le">
; <description>Icn, singular, compound non-hd only  
; <ex>B arrived in A.D. 1066.
; <nex>
; <todo>
; </type>
n_-_c-sg-cpd_le := n_-_c-sg_lexent &
  [ SYNSEM [ LOCAL [ CAT [ VAL.SPR < unexpressed & [ OPT - ]  > ],
                     CONT.RELS <! relation !> ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; For plural nouns which are already inflected
; <type val="n_-_c-pl-ifl_le">
; <description>Icn, plur, inflected    
; <ex>These beings have disappeared.
; <nex>
; <todo>
; </type>
n_-_c-pl-ifl_le := n_intr_infl_lex_entry &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
					       DIV + ] ] >,
		   CONT.HOOK.INDEX [ PNG.PN 3p,
				     DIV + ] ] ].

;; DPF 2014-06-12 - The terms |percent| and |%| create unwanted ambiguity if
;; allowed to combine without of-PP complements, so add plural-only nominative
;; case entry to admit |ten percent arise| while limiting ambiguity.
;;
; <type val="n_-_c-pl-nom_le">
; <description>Icn, plur, inflected, nominative case - maybe only "percent"
; <ex>Ten percent have disappeared.
; <nex>
; <todo>
; </type>
n_-_c-pl-nom_le := n_intr_infl_lex_entry &
  [ SYNSEM.LOCAL [ CAT [ HEAD.CASE nom,
			 VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
						 DIV + ] ] > ],
		   CONT.HOOK.INDEX [ PNG.PN 3p,
				     DIV + ] ] ].

n_plur_ppcomp_lexent := noun_noninfl_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                           VAL [ COMPS < [ --SIND #index ] >,
				 SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                                     DIV + ] ] > ] ],
                     CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                            RELS.LIST.FIRST diadic_nom_relation,
                            HCONS <! !> ] ],
	     MODIFD notmod,
             LKEYS.KEYREL.ARG1 #index ] ].

; <type val="n_pp_c-pl_le">
; <description>Cn, plr, PP cmp                  
; <ex>The people of Spain sang.
; <nex>
; <todo>
; </type>
n_pp_c-pl_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! reg_diadic_nom_relation !> ].

; 'millions of ...'
; <type val="n_pp_c-pl-crd_le">
; <description>Cn, plr, PP cmp, card            
; <ex>Millions of birds flew.
; <nex>
; <todo>
; </type>
n_pp_c-pl-crd_le := n_plur_ppcomp_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ OPT -,
				       LOCAL.CONT.HOOK.INDEX.SORT #sort ] >,
		     CONT.RELS <! [ LBL #lbl,
				    PRED generic_entity_rel,
				    ARG0 #index & [ SORT #sort ] ],
				  #altkeyrel & const_relation &
				  [ LBL #lbl,
				    PRED card_rel,
				    ARG1 #index ] !> ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; 'others of you'
; <type val="n_pp_c-pl-obl_le">
; <description>Cn, plr, oblig PP comp           
; <ex>Others of them swam.
; <nex>
; <todo>
; </type>
n_pp_c-pl-obl_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
		   CONT.RELS <! reg_diadic_nom_relation !> ] ].

; "kind"
; <type val="n_pp_c-pl-sg_le">
; <description>Cn, plr-sing, PP comp            
; <ex>This kind of birds fly.
; <nex>
; <todo>
; </type>
n_pp_c-pl-sg_le := basic_noun_noaffix_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                           VAL.COMPS < [ --SIND #index ] > ],
                     AGR.DIV -,
                     CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                            RELS <! reg_diadic_nom_relation !>,
                            HCONS <! !> ] ],
	     MODIFD notmod,
             LKEYS.KEYREL.ARG1 #index ] ].

; 'bunch', 'lot', 'number'
; DPF 30-sept-06 - Replaced MIN norm_nom_rel with nonpro_rel, and
; unify with COMPS..MIN, to admit e.g. "We arose a number of times."  Also
; removed MODIFD notmod.
; DPF 05-oct-06 - But this blocks "group of us', so generalize to nom_rel.
; DPF 08-mar-10 - Changed relation type from reg_diadic_nom_relation to just
; diadic_nom_relation, to relax constraint on SORT, to allow e.g.
; `singing is a lot of work'.
; DPF 2010-10-31 - Re 05-oct-06: MODIFD notmod prevents spurious ambiguity
; for "the big range of mountains appeared" (avoiding aj-hdn_adj_c).  So
; why did we remove it?  Let's try again...

n_group_ppof_lexent := noun_word &
  [ SYNSEM unsp_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD noun &
                                [ MINORS.MIN nom_rel & #min ],
                           VAL.COMPS < synsem &
				       [ LOCAL.CAT.HEAD.MINORS.ALTMIN #min,
                                         --SIND #ind,
                                         OPT - ] > ],
                     CONT [ RELS <! diadic_nom_relation !>,
                            HCONS <! !> ] ],
	     MODIFD notmod,
             LKEYS [ KEYREL.ARG1 #ind,
                     --COMPKEY _of_p_sel_rel ] ] ].

; DPF 28-jun-07 - Restrict to nominative case, to avoid spurious ambig with 
; ordinary n_pp_c_of.
; DPF 07-nov-07 - But this blocks e.g. "there are the majority of houses..."
; since the number mismatch with "are" forces the group noun, but "are" wants
; the complement to be [CASE acc].  FIX...
; DPF 19-jan-08 - Removed that CASE nom restriction, since it now blocks
; 'We hired a group of citizens.'

; 'the row of houses are ...'
; <type val="n_pp_c-gr-of_le">
; <description>Cn, group, PP-of comp            
; <ex>A lot of birds fly.
; <nex>
; <todo>
; </type>
n_pp_c-gr-of_le := n_group_ppof_lexent &
  [ SYNSEM.LOCAL.AGR.DIV - ].

; 'plenty of'
; <type val="n_pp_m-gr-of_le">
; <description>Mass, group, PP-of               
; <ex>Plenty of birds fly.
; <nex>
; <todo>
; </type>
n_pp_m-gr-of_le := n_group_ppof_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < unexpressed_reg >,
                             COMPS < [ LOCAL.AGR.PNG.PN #pn ] > ],
                   AGR [ PNG.PN #pn,
                         DIV + ] ] ].

; 'piece of', 'pair of'
; <type val="n_pp_c-gr-of-ns_le">
; <description>Cn, group, PP-of comp, unsp sort 
; <ex>A piece of cake fell.
; <nex>
; <todo>
; </type>
n_pp_c-gr-of-ns_le := n_group_ppof_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED quantum_n_of_rel,
	     LOCAL.CONT.HOOK.INDEX.SORT non-time-sort ] ].

;;; DPF 13-feb-08 - Block "number" from undergoing n-adj rule: Add HEAD noun

n_group_nocomp_lexent := noun_word &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
	   [ LOCAL [ CAT.HEAD noun & [ MINORS.MIN norm_nom_rel ],
                     CONT [ RELS <! nom_relation !>,
                            HCONS <! !> ] ],
	     MODIFD notmod ] ].

; <type val="n_-_c-gr_le">
; <description>Icn, group                       
; <ex>A long series ensued.
; <nex>
; <todo>
; </type>
n_-_c-gr_le := n_group_nocomp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

; <type val="n_-_c-gr-nocnh_le">
; <description>Icn, group, no non-hd in compound
; <ex>A third are left.
; <nex>
; <todo>
; </type>
n_-_c-gr-nocnh_le := n_group_nocomp_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD [ --BARE -,
			      MINORS.NORM norm_rel ],
	     MODIFD.RPERIPH + ] ].

; <type val="n_-_m-gr_le">
; <description>Mass, group                      
; <ex>Plenty happened.
; <nex>
; <todo>
; </type>
n_-_m-gr_le := n_group_nocomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < unexpressed_reg >,
		   CONT.HOOK.INDEX.PNG.PN 3s,
                   AGR.DIV + ] ].

n_part_lexent := basic_noun_noaffix_word &
  [ SYNSEM partitive_noun_synsem &
	   [ LOCAL [ CAT.VAL.SPR.FIRST [ LOCAL.CAT.HEAD adv,
					 --MIN just_only_deg_rel ],
                     CONT [ RELS.LIST < #keyrel, #altkeyrel, ... >,
                            HCONS <! qeq !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ],
             NONLOC [ SLASH 0-dlist,
                         QUE 0-dlist ] ] ].

; <type val="n_pp_mc-a-of_le">
; <description>Partitive, agr w/PP-of           
; <ex>Half of the birds fly.
; <nex>
; <todo>
; </type>
n_pp_mc-a-of_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_agr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !>,
             LKEYS.ALTKEYREL.PRED explicit_quant_agr_q_rel ] ].

; <type val="n_pp_mc-pl-of_le">
; <description>Partitive, plural w/PP-of, informal
; <ex>The both of the birds fly.
; <nex>
; <todo>
; </type>
n_pp_mc-pl-of_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_agr_synsem &
           [ LOCAL [ CONT.RELS <! relation, relation !>,
                     AGR.PNG.PN 3p ] ],
    GENRE informal ].

; <type val="n_pp_c-pl-of-obl_le">
; <description>Partitive, plural w/oblig PP-of, 
; <ex>Certain of the birds fly.
; <nex>
; <todo>
; </type>
n_pp_c-pl-of-obl_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_agr_synsem &
           [ LOCAL [ CAT.VAL.COMPS.FIRST.OPT -,
		     CONT.RELS <! relation, relation !>,
                     AGR.PNG.PN 3p ] ] ].

; <type val="n_pp_mc-na-of_le">
; <description>Partitive, no agr w/PP-of        
; <ex>None of the birds flies.
; <nex>
; <todo>
; </type>
n_pp_mc-na-of_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_noagr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !> ] ].

; <type val="n_pp_mc-pl-na-of_le">
; <description>Partitive, no agr w/PP-of        
; <ex>Neither one of them flies.
; <nex>
; <todo>
; </type>
n_pp_mc-pl-na-of_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_noagr_synsem &
           [ LOCAL [ CONT.RELS <! relation, relation !>,
                     AGR.PNG.PN 3p ] ] ].

; <type val="n_np_mc-a_le">
; <description>Partitive, agr w/NP comp         
; <ex>B bought half a loaf.
; <nex>
; <todo>
; </type>
n_np_mc-a_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_agr_synsem ].

; <type val="n_np_mc-a-def_le">
; <description>Partitive, agr w/NP comp, must be definite
; <ex>B paid twice the price.
; <nex>
; <todo>
; </type>
n_np_mc-a-def_le := n_part_lexent &
 [ SYNSEM partitive_noun_np_agr_synsem &
  [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN 
						  def_or_udef_or_demon_q_rel]].

; <type val="n_np_mc-na_le">
; <description>Partitive, no agr w/NP comp      
; <ex>Both the birds flew.
; <nex>
; <todo>
; </type>
n_np_mc-na_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_noagr_synsem ].

; <type val="n_-_mc-prt_le">
; <description>Partitive, no comp               
; <ex>None flew.
; <nex>
; <todo>
; </type>
n_-_mc-prt_le := n_part_lexent &
  [ SYNSEM partitive_noun_nocomp_synsem &
           [ LOCAL [ CAT.VAL.COMPS < >,
                     CONT.RELS <! #keyrel, relation !> ],
             MODIFD notmod,
             LKEYS.KEYREL #keyrel ] ].

; <type val="n_np_mc-neg_le">
; <description>Partitive, negated               
; <ex>Not all the cats jumped.
; <nex>
; <todo>
; </type>
n_np_mc-neg_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_neg_synsem ].

; pleasure
; <type val="n_vp_c-it_le">
; <description>Cn, VP comp, it-subj             
; <ex>It's a pleasure to sleep.
; <nex>
; <todo>
; </type>
n_vp_c-it_le := noun_word &
  [ SYNSEM common_noun_vpcomp_expl_synsem ].

; drudgery
; <type val="n_vp_m-it_le">
; <description>Mass, VP comp it-subj 'drudgery' 
; <ex>It is drudgery to do that.
; <nex>
; <todo>
; </type>
n_vp_m-it_le := noun_word &
  [ SYNSEM mass_noun_vpcomp_expl_synsem ].

; pleasure to VP/NP
; <type val="n_vpslnp_c_le">
; <description>Cn, VP/NP comp                   
; <ex>Kim is a pleasure to mmet.
; <nex>
; <todo>
; </type>
n_vpslnp_c_le := noun_word &
  [ SYNSEM common_noun_vpcomp_slash_synsem ].

noun_one_arg_synsem := basic_noun_synsem & one_arg.

;; Use AGR hack of incompatible values for PN and DIV to exclude all normally
;; inflected nouns.

n_pred_lexent := nonc-hm & basic_noun_word &
  [ INFLECTD +,
    SYNSEM noun_one_arg_synsem &
	   [ LOCAL [ CAT [ HEAD noun &
				[ MINORS [ MIN norm_nom_rel,
					   NORM norm_rel ],
				  MOD < anti_synsem_min >,
				  CASE nom ],
			   VAL [ SPR < unexpressed_reg &
				       [ LOCAL.CAT.HEAD det,
					 OPT - ] >,
				 COMPS < > ] ],
		     AGR [ PNG.PN 3p,
			   DIV - ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! reg_nom_relation &
				    [ LBL #ltop ] !> ] ],
	     MODIFD notmod,
	     NONLOC non-local_none ] ].

n_-_c-prd_le := n_pred_lexent.

;; For nouns heading subject NP in do-be construction, such as `thing'
;;
noun_do_be_synsem := nonpro_nomod_onearg_synsem &
  [ LOCAL 
    [ CAT [ HEAD basic_noun,
	    VAL [ COMPS < synsem &
			  [ LOCAL [ CAT [ HEAD verbal & 
					       [ MOD < [ --SIND #modind &
							    [ SORT do-event ],
							 LOCAL.CONT.HOOK.XARG 
								#xarg ] >,
						 INV -,
						 VFORM fin_or_inf ],
					  VAL [ SUBJ *unexplist*,
						COMPS < > ],
					  MC na ],
				    CONT.HOOK [ LTOP #ltop,
						XARG #modind ],
				    CONJ cnil ],
			    NONLOC.SLASH 0-dlist,
			    OPT - ] >,
		  SPEC < anti_synsem_min > ] ],
      CONT [ HOOK [ LTOP #ltop,
		    INDEX #modind,
		    XARG #xarg ],
		   RELS.LIST < #keyrel, ... > ] ],
    NONLOC non-local_none,
    MODIFD notmod,
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     ARG0 #modind ] ].

noun_do_be_spr_synsem := noun_do_be_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS [ MIN norm_nom_rel,
				ALTMIN #spmin ],
		  VAL [ SPR < synsem &
			      [ --MIN #spmin & quant_rel,
				LOCAL.CAT [ HEAD det,
					    VAL [ SUBJ < >,
						  SPR *olist* ] ],
				LEX +,
				OPT - ] >,
			COMPS < [ LOCAL.CAT.HEAD.MOD < synsem > ] > ] ],
	    CONT.HCONS <! !> ] ].

noun_do_be_thing_synsem := noun_do_be_spr_synsem &
  [ LOCAL.CONT.RELS <! relation !> ].

; For `thing'
n_cp_do-be-th-sg_lexent := basic_noun_word & nonc-hm &
  [ INFLECTD +,
    SYNSEM noun_do_be_thing_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN #pn,
						 DIV #div ] ] >,
		     CONT.HOOK.INDEX [ PNG.PN #pn,
				       DIV #div ] ] ] ].

n_cp_do-be-th-sg_le := n_cp_do-be-th-sg_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR.FIRST expressed_synsem,
		   CONT.HOOK.INDEX.PNG.PN 3s ] ].

n_cp_do-be-th-pl_le := n_cp_do-be-th-sg_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.PN 3s,
				   DIV + ] ].

; For `best, worst, most, least'
noun_do_be_sup_synsem := noun_do_be_spr_synsem &
  [ LOCAL [ CAT.VAL.SPR < expressed_synsem &
			      [ --MIN _the_q_rel ] >,
	    CONT.RELS <! [ LBL #hand,
			 PRED generic_entity_rel,
			 ARG0 #index,
			 CFROM #cfrom, CTO #cto ],
		       #altkeyrel &
		       [ LBL #hand,
			 ARG0 #event,
			 ARG1 #index ],
		       [ LBL #hand,
			 PRED superl_rel,
			 ARG1 #event,
			 CFROM #cfrom, CTO #cto ] !> ],
    LKEYS.ALTKEYREL #altkeyrel ].

n_cp_do-be-sup_le := basic_noun_word & nonc-hm &
  [ INFLECTD +,
    SYNSEM noun_do_be_sup_synsem ].

noun_do_be_something_synsem := noun_do_be_synsem &
  [ LOCAL [ CAT [ HEAD partn &
		       [ MINORS [ MIN norm_nom_rel,
				  ALTMIN #spmin ] ],
		  VAL [ SPR < >,
			COMPS < [ LOCAL.CAT.HEAD.MOD < synsem > ] > ] ],
	    CONT [ RELS <! [ LBL #nhand,
			     ARG0 #ind & [ PNG.PN 3s ],
			     CFROM #cfrom, CTO #cto ],
			   [ PRED _some_q_rel & #spmin,
			     ARG0 #ind,
			     RSTR #rhand,
			     CFROM #cfrom, CTO #cto ] !>,
		   HCONS <! qeq & [ HARG #rhand,
				    LARG #nhand ] !> ] ] ].

;; |something we could do is hire a consultant|
n_cp_do-be-sth_le := basic_noun_word & nonc-hm &
  [ INFLECTD +,
    SYNSEM noun_do_be_something_synsem ].

noun_do_be_part_synsem := noun_do_be_synsem &
  [ LOCAL [ CAT [ HEAD partn &
		       [ MINORS [ MIN part_of_rel,
				  ALTMIN #qpred,
				  NORM norm_rel ] ],
		  VAL [ SPR < anti_synsem &
			      [ LOCAL.CONT.HOOK.LTOP #qlbl,
				OPT - ] >,
			COMPS < [ LOCAL.CAT.HEAD.VFORM fin ] > ] ],
	    CONT [ RELS <! [ PRED generic_entity_rel,
			     LBL #nlbl,
			     ARG0 #arg0 ],
			   #altkeyrel &
			   [ LBL #qlbl,
			     PRED #qpred,
			     ARG0 #arg0,
			     RSTR #rstr ] !>,
		   HCONS <! qeq & [ HARG #rstr,
				    LARG #nlbl ] !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

n_cp_do-be-part_lexent := basic_noun_word & nonc-hm &
  [ INFLECTD +,
    SYNSEM noun_do_be_part_synsem &
	   [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD < synsem > ] > ] ].

;; For |what is easiest to do is leave the room|
n_vp_do-be-part_lexent := basic_noun_word & nonc-hm &
  [ INFLECTD +,
    SYNSEM noun_do_be_part_synsem &
      [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD.MOD < anti_synsem >,
					      VAL.SUBJ < [ LEX + ] > ],
					CONT.HOOK.INDEX.SORT do-event ] ] > ] ].

;; |all (that) we did|
;;
n_cp_do-be-all_le := n_cp_do-be-part_lexent.

;; Exclude overt relative pronoun for `what': *|what that we did|
;; Take advantage of non-wh rel-cl being distinguished from filler-head rel-cl
;; in the constraint on MODIFD.RPERIPH.  
;; 
n_cp_do-be-what_le := n_cp_do-be-part_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ MODIFD.RPERIPH - ] > ].

n_vp_do-be-what_le := n_vp_do-be-part_lexent.

;;
;; Lexical NPs
;;
;;   (proper names, pronouns, names of weekdays, ...)

basic_np_synsem := ref_synsem &
  [ LOCAL.CAT [ HEAD basic_noun &
                     [ MINORS.ALTMIN def_q_rel ],
                VAL.SUBJ < > ] ].

basic_np_word := noncrs-hm-nab & basic_noun_word &
  [ SYNSEM basic_np_synsem ].

basic_non_affixed_np := noncqrs-hm-nab & basic_noun_word &
  [ SYNSEM.MODIFD notmod ].

non_affixed_np := basic_non_affixed_np &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

np_word := basic_np_word & basic_non_affixed_np &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < > ].

;np_synsem := noun_synsem & nomod_synsem.
np_synsem := nonpronominal_synsem & ref_synsem & nomod_synsem &
  [ LOCAL [ CAT.HEAD basic_noun,
	    AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

basic_np_sing_synsem := basic_np_synsem &
  [ LOCAL.CONT [ RELS.LIST < nom_relation &
                             [ PRED basic_nom_rel,
                               ARG0 #ind ],
			     #altkeyrel &
                             [ PRED quant_rel,
                               ARG0 #ind,
                               RSTR #rhand ], ... >,
                 HCONS <! qeq & [ HARG #rhand,
                                  LARG #keyhand ] !> ],
    LKEYS [ KEYREL.LBL #keyhand,
	    ALTKEYREL #altkeyrel ] ].

basic_np_sing_word := basic_np_word &
  [ SYNSEM basic_np_sing_synsem ].

np_sing_synsem := basic_np_sing_synsem & np_synsem &
  [ LOCAL [ CAT.VAL [ SPR < >,
                      COMPS < > ],
            CONT.RELS <! relation, [ PRED proper_q_rel ] !> ],
    MODIFD notmod ].

; DPF 10-Apr-02 - Changed ALTMIN from basic_nom_rel to implicit_q_rel so
; proper names can form compounds like in "the Kim Browne story"

; DPF 15-May-02 - Changed proper names so they now inflect, allowing plural
; forms as in "they hired two Chiangs"
; DPF 5-Sep-03 - Changed ALTMIN from implicit_q_rel to proper_q_rel to
; block compound "the Browne hired Chiang".  Later changed.
; DPF 7-may-04 - Removed nonque supertype, since we want to allow e.g.
; "which Elvis did you see"
; DPF 24-aug-04 - Added RPERIPH + to enable blocking of red-rel analysis
; of "Abrams hired" while still allowing "people hired"
; PDF 19-apr-08 - Added INDEX nonconj_ref-ind to block spurious analysis
; of uninflected "sunny Pittsburgh" as proper_np_conj.
;
basic_n_proper_lexent := noncrs-hm & basic_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT [ HEAD.MINORS [ MIN named_np_rel,
                                       ALTMIN quant_or_wh_rel ],
                           VAL [ SPR < [ --MIN quant_or_wh_rel,
                                         NONLOC.QUE #que ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #index & nonconj_ref-ind ],
                            RELS <! relation !>,
                            HCONS <! !> ],
                     AGR #index ],
             NONLOC.QUE #que,
             LKEYS [ KEYREL named_nom_relation &
                            [ PRED named_np_rel,
                              LBL #ltop ],
                     ALTKEYREL.PRED implicit_q_rel ] ] ].

norm_n_proper_lexent := basic_n_proper_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED named_rel,
    INFLECTD - ].

; Distinguish ordinary proper names like "Kim" from city proper names like
; "Paris", which allow a following comma as in "Paris, France".
;; DPF 2012-09-10 - But this does not scale well, since any proper name
;; can be used as the name of a city.  So accept the modest additional
;; ambiguity, and collapse this distinction.
;;
n_proper_lexent := norm_n_proper_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN named_np_rel ].

#|
; MIN allows specialization to named_rel ('Kim') or named_city_rel ('Paris')
; to enable correct treatment of commas: '*Kim, Abrams' but 'Paris, France'
; <type val="n_-_pn-city_le">
; <description>Pn - city                        
; <ex>B lives in Paris, France.
; <nex>
; <todo>
; </type>
n_-_pn-city_le := norm_n_proper_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN named_np_rel ].
|#

; DPF 26-Mar-01 - Added MODIFD.LPERIPH + to prevent (restrictive) post-nom
; modifiers of bare proper names, as in "*Abrams by Browne arrived." though
; this will also block "Abrams from New York just called".  Not clear what
; the contrast is due to.
; DPF 1-Jun-02 - But this was too strong, so relaxed the reduced-rel rule
; but keep this constraint here, since it still serves to prevent proper names
; from appearing as heads of n-n compounds, blocking "interview Sandy"
; DPF 2011-02-08 - This [LPERIPH +] constraint was preventing "two Kims", so
; since the unwanted N-N construction is independently blocked by the value
; for MINORS.MIN, removed the constraint.

; <type val="n_-_pn_le">
; <description>Proper noun (pn)                 
; <ex>Abrams arrived.
; <nex>
; <todo>
; </type>
n_-_pn_le := n_proper_lexent.
; <type val="n_-_pn-fem_le">
; <description>Pn - feminine                    
; <ex>Sara arrived.
; <nex>
; <todo>
; </type>
n_-_pn-fem_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.GEN fem ].
; <type val="n_-_pn-msc_le">
; <description>Pn - masculine                   
; <ex>John arrived.
; <nex>
; <todo>
; </type>
n_-_pn-msc_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.GEN masc ].

; For "i", which we don't want as plural "is"
; <type val="n_-_pn-sg_le">
; <description>Pn - singular only               
; <ex>B speaks Norwegian.
; <nex>
; <todo>
; </type>
n_-_pn-sg_le := n_proper_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE nom,
		   AGR.PNG.PN 3s ] ].

; <type val="n_-_pn-pl_le">
; <description>Pn - plural only                 
; <ex>Rondane are in Norway.
; <nex>
; <todo>
; </type>
n_-_pn-pl_le := basic_n_proper_lexent &
  [ INFLECTD +,
    SYNSEM [ LKEYS.KEYREL.PRED named_rel,
	     LOCAL plur_noun & [ CAT.HEAD.MINORS.MIN named_rel ] ] ].

; Restrict plurals to nominative case, for 'ersatz' names like "OSCARCOMPOUND"
n_-_pn-pl-nom_le := basic_n_proper_lexent &
  [ INFLECTD +,
    SYNSEM [ LKEYS.KEYREL.PRED named_rel,
	     LOCAL plur_noun & [ CAT.HEAD [ MINORS.MIN named_rel,
					    CASE nom ] ] ] ].

; <type val="n_-_pn-pl-def_le">
; <description>Pn - plural and definite only                 
; <ex>The Giants play today.
; <nex>
; <todo>
; </type>
n_-_pn-pl-def_le := basic_n_proper_lexent &
  [ INFLECTD +,
    SYNSEM [ LKEYS.KEYREL.PRED named_rel,
	     LOCAL plur_noun & [ CAT [ HEAD.MINORS.MIN named_rel,
				       VAL.SPR.FIRST expressed_synsem ] ] ] ].

; <type val="n_-_pn-nocnh_le">
; <description>Proper noun (pn) excluded from non-head of compounds, and sg
; <ex>Italian is a Romance language.
; <nex>
; <todo>
; </type>
n_-_pn-nocnh_le := n_proper_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.NORM no_rel,
                     AGR.PNG.PN 3s ],
             MODIFD.LPERIPH + ] ].

; <type val="n_-_pn-nonom_le">
; <description>Proper noun (pn), non-inflecting, only for |I| noun in cmpnds
; <ex>The I and J columns are filled
; <nex>
; <todo>
; </type>
n_-_pn-nonom_le := n_proper_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.CASE non_nom,
		     AGR [ PNG.PN 3p,
			   DIV - ] ],
	     MODIFD [ LPERIPH +,
		      RPERIPH + ] ] ].

; <type val="n_-_pn-nounif_le">
; <description>Non-unifying, only for noun |A| to block generic NP
; <ex>
; <nex>*A number arose.
; <todo>
; </type>
n_-_pn-nounif_le := n_proper_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE non_nom,
				MINORS.NORM no_rel ],
		     AGR [ PNG.PN 3p,
			   DIV - ] ],
	     MODIFD [ LPERIPH +,
		      RPERIPH + ] ] ].

; DPF 19-sept-08 - Can we collapse the following two entries?  Why is CARG
; set in the pn-unk type but not in the pn-gen one?

; DPF 04-jan-2010 - Changed MIN named_rel to named_np_rel in order to allow
; for unknown city names as in "Ottawa, Canada"

; <type val="n_-_pn-gen_le">
; <description>Pn - generic                     
; <ex>Genericpn arrived.
; <nex>
; <todo>
; <native> n_-_pn_le
; </type>
n_-_pn-gen_le := basic_n_proper_lexent & generic_ne_lex_entry &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN named_np_rel,
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL [ PRED named_rel ] ] ].

; <type val="n_-_pn-unk_le">
; <description>Pn - unknowns                    
; <ex>Literalpn arrived.
; <nex>
; <todo>
; <native> n_-_pn_le
; </type>
n_-_pn-unk_le := basic_n_proper_lexent & basic_unknown_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN named_rel,
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL [ PRED named_rel,
			    CARG #carg ],
	     PHON.ONSET unk_onset ],
    TOKENS.+LIST < [ +CARG #carg ] > ].

; <type val="n_-_pn-pl-unk_le">
; <description>Pn - unknowns, plural
; <ex>Literalpn arrived.
; <nex>
; <todo>
; <native> n_-_pn-pl_le
; </type>
n_-_pn-pl-unk_le := basic_n_proper_lexent & basic_unknown_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN named_rel,
		     AGR [ PNG.PN 3p, DIV + ] ],
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL [ PRED named_rel,
			    CARG #carg ],
	     PHON.ONSET unk_onset ],
    TOKENS.+LIST < [ +CARG #carg ] > ].

; Add NORM to block these in left position of noun-noun compounds
; <type val="n_-_pn-abb_le">
; <description>Pn - abbrev.                     
; <ex>B lives in NY.
; <nex>
; <todo>
; </type>
n_-_pn-abb_le := norm_n_proper_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN named_abb_rel,
                                     ALTMIN proper_q_rel ],
             LKEYS.KEYREL.ARG0.PNG.PN 3s ] ].

; Block left quote on name of letter "s" to avoid spurious ambig for "'s"
; while we still tokenize with an added space preceding "s".
; <type val="n_-_pn-nq_le">
; <description>Pn - no left quote: |S|          
; <ex>We saw S after R.
; <nex>
; <todo>
; </type>
n_-_pn-nq_le := n_proper_lexent &
  [ SYNSEM.MODIFD.LPERIPH +,
    ALTS.SQPNCT - ].

; "here, there" as in "get out of here/there" 
; Make SYNSEM pronominal_synsem to block N-N cmpnds like "the there meeting"
; Added PRD + so appositives with left member np_adv won't join in N-N-cmpnds.
; DPF 23-Oct-00 - Since pronominal_synsem no longer constrains left member of
; noun-noun compounds, use alternate hack of making ALTMIN not unify with
; the [ALTMIN no_rel] constraint in the n-n-cmpnd rule.

basic_np_adv_synsem := basic_np_sing_synsem & pronominal_synsem &
  [ LOCAL [ CAT [ HEAD [ MINORS [ MIN #min,
				  ALTMIN def_explicit_q_rel,
				  NORM never_unify_rel ] ],
		  NEGPOL - ],
            CONT.HOOK.LTOP #ltop ],
    LKEYS [ KEYREL [ LBL #ltop,
                     PRED #min ],
            ALTKEYREL relation,
            ALT2KEYREL relation ] ].

; DPF 24-apr-09 - Recently added anti_synsem to SPR list, but don't recall
; what the motivation is.  Note that it's convenient in blocking these as
; heads in appositives, so don't discard lightly.

np_adv_synsem := basic_np_adv_synsem &
  [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.VAL [ SPR *olist*,
                                          SPEC < synsem_min > ] ],
			anti_synsem_min & [ OPT - ] > ].

basic_np_adv_word := basic_np_sing_word &
  [ SYNSEM basic_np_adv_synsem &
	   [ LOCAL [ CONT [ HOOK.INDEX #ind & [ PNG png & [ PN 3s ] ],
                            RELS.LIST < relation, #altkeyrel, ... > ],
		     AGR #ind ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

basic_np_adv_lexent := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
		     CONT.RELS.LIST < relation & [ LBL #hand,
						   ARG0 #inst ], 
				      [ PRED def_implicit_q_rel ],
				      #alt2key & [ LBL #hand,
						   ARG0 event & 
						       [ E [ TENSE untensed,
							     ASPECT no_aspect]],
						   ARG1 #inst ], ... > ],
	     LKEYS.ALT2KEYREL #alt2key ] ].

; 6-jun-04 - Changed SPR..HEAD from adv to n_or_adv to allow measure NPs
; as specifiers, as in "two weeks early"
np_adv_lexent := basic_np_adv_lexent &
  [ SYNSEM np_adv_synsem &
           [ LOCAL.CAT.VAL.SPR.FIRST [ LOCAL [ CAT.HEAD n_or_adv,
					       CONT.HOOK [ LTOP #ltop,
							   XARG #arg0 ] ],
				       NONLOC.QUE #que ],
	     NONLOC.QUE #que,
	     LKEYS.ALT2KEYREL [ LBL #ltop,
                                ARG0 #arg0 ] ] ].

norm_np_adv_lexent := np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < >,
			 VAL.SPR.FIRST.LOCAL.CAT.HEAD.MINORS
					[ MIN just_only_much_deg_rel,
					  ALTMIN basic_adv_rel ] ],
		   CONT.RELS <! relation, relation, relation !> ] ].

; DPF 9-oct-05 - Try making these [CASE obliq] to block them from ordinary
; direct objects, as in the object-extraction reading of "Here kim plunged t
; into the water"

; <type val="n_-_ad-pl_le">
; <description>N, can modify, locative (place)
; <ex>B lives overseas.
; <nex>
; <todo>
; </type>
n_-_ad-pl_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
                              CASE obliq ],
                   CONT.HOOK.INDEX.SORT place ] ].

; <type val="n_-_ad-pl-nomod_le">
; <description>N, can modify, locative (place), blocks modifiers of self
; <ex>B stayed home
; <nex> B went from home in Paris to home in London
; <todo>
; </type>
n_-_ad-pl-nomod_le := norm_np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
				CASE obliq,
				--BARE - ],
		     CONT.HOOK.INDEX.SORT place ],
	     MODIFD.RPERIPH + ] ].

; <type val="n_-_ad-time_le">
; <description>N, can modify, temporal          
; <ex>B arrives today.
; <nex>
; <todo>
; </type>
n_-_ad-time_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN time_n_rel,
                   CONT.HOOK.INDEX.SORT time ] ].

; e.g. 'early', which allows "too/so early", unlike 'now', 'then'
; <type val="n_-_ad-time-ns_le">
; <description>N, can modify, temp, no sort     
; <ex>B stayed until early today
; <nex>
; <todo>
; </type>
n_-_ad-time-ns_le := np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MOD < >,
				MINORS.MIN time_n_rel ],
                         VAL.SPR.FIRST [ --MIN very_this_that_rel ] ],
                   CONT [ HOOK.INDEX.SORT time,
			  RELS <! relation, relation, relation !> ] ] ].

n_adv_event_lexent := norm_np_adv_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN place_n_rel,
             LKEYS.ALT2KEYREL.ARG0 [ E [ TENSE no_tense,
                                         ASPECT no_aspect ],
                                     SORT place ] ] ].

; <type val="n_-_ad-loc_le">
; <description>N, can modify, location          
; <ex>B slid downward.
; <nex>
; <todo>
; </type>
n_-_ad-loc_le := n_adv_event_lexent.

; 'there'
; <type val="n_-_ad-acc_le">
; <description>N, can modify, acc case only     
; <ex>B slept there.
; <nex>
; <todo>
; </type>
n_-_ad-acc_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD [ CASE acc,
                              MINORS.MIN place_n_rel ],
                   CONT.HOOK.INDEX.SORT place ] ].

; 'north' etc, which take degree specifiers like "far" or "ten miles",
; and an optional of-PP complement.
; <type val="n_pp_ad-dir_le">
; <description>N, can modify, directional       
; <ex>B went west.
; <nex>
; <todo>
; </type>
n_pp_ad-dir_le := basic_np_adv_word &
  [ SYNSEM np_adv_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < >,
				  MINORS.MIN place_n_rel ],
                           VAL [ SPR.FIRST [ --MIN much_deg_rel,
					     LOCAL [ CAT.HEAD n_or_adv,
						     CONT.HOOK [ LTOP #ltop,
								 XARG #arg0 ]],
					     NONLOC.QUE #que ],
				 COMPS < [ --MIN _of_p_sel_rel,
                                           LOCAL
                                           [ CAT [ HEAD prep & [ PRD - ],
                                                   VAL.COMPS < > ],
                                             CONT.HOOK [ LTOP #hand,
                                                         INDEX #ppind ] ],
                                           NONLOC [ SLASH #slash,
                                                    REL #rel,
                                                    QUE 0-dlist ],
                                           PUNCT.LPUNCT no_punct ] > ] ],
                     CONT [ HOOK.INDEX.SORT place,
                            RELS <! relation & [ LBL #hand,
                                                 ARG0 #inst ], 
                                  [ PRED def_implicit_q_rel ],
                                  #alt2key & [ LBL #hand,
                                               ARG1 #inst ] !> ] ],
             NONLOC [ SLASH #slash,
                      QUE #que,
                      REL #rel ],
             LKEYS.ALT2KEYREL #alt2key &
                              [ LBL #ltop,
                                ARG0 #arg0,
                                ARG2 #ppind ] ] ].

; 'then' -- to block "then Kim left" as N+RelClause.  Hack, since this
; also blocks "right then".
; [ACTIVATED -] prevents "then" from being topicalized, to avoid filler-head
; reading for "then kim arrived"
; <type val="n_-_ad-br_le">
; <description>N, can modify, no spr            
; <ex>B arrived then.
; <nex>
; <todo>
; </type>
n_-_ad-br_le := basic_np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < >,
				  MINORS.MIN time_n_rel ],
                           VAL.SPR < anti_synsem_min & [ OPT - ] > ],
                     CONT [ HOOK.INDEX.SORT time,
			    RELS <! relation, relation, relation !> ],
                     CTXT.ACTIVATED - ],
             NONLOC.QUE 0-dlist ] ].

; 'long' as in 'Kim stayed for too long', 'Kim stayed too long', and
; 'it took too long to finish'

basic_n_adv_gradable_lexent := np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN time_n_rel ],
                           VAL.SPR.FIRST [ --MIN degree_rel,
					   LEX + ] ],
                     CONT.HOOK [ LTOP #lbl,
                                 INDEX.SORT time ] ],
             LKEYS.KEYREL.LBL #lbl ] ].

;; DPF 2011-09-24 - Re 07-may-04 (on n_-_ad-gr-nm_le): But we also want 
;; to block |soon arose| with `soon' as subject, so constrain MOD to 
;; be < anti_synsem_min >.

norm_n_adv_gradable_lexent := basic_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < anti_synsem_min > ].

; <type val="n_-_ad-gr_le">
; <description>N, can modify, gradable          
; <ex>B stayed late.
; <nex>
; <todo>
; </type>
n_-_ad-gr_le := basic_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD grad_n & [ MOD < > ],
			 VAL.SPR.FIRST [ --MIN very_this_that_rel ] ],
		   CONT.RELS <! relation, relation, relation !> ] ].

; longer
; <type val="n_-_ad-gr-cmp_le">
; <description>N, can modify, grad, compar      
; <ex>B stayed longer.
; <nex>
; <todo>
; </type>
n_-_ad-gr-cmp_le := norm_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD grad_n,
			 VAL.SPR.FIRST [ --MIN much_deg_rel ] ],
		   CONT.RELS <! relation, relation, 
			        [ LBL #lbl,
				  ARG0 #arg0,
				  CFROM #cfrom, CTO #cto ],
			        [ LBL #lbl,
				  PRED comp_rel,
				  ARG1 #arg0,
				  CFROM #cfrom, CTO #cto ] !> ] ].

; soon
; DPF 07-may-04 - Added CASE nom as hack to prevent e.g. 'until soon'
;; DPF 2011-09-24 - Re 07-may-04: But we also want to block |soon arose| with
;; `soon' as subject, so constrain MOD to be < anti_synsem_min >.
; <type val="n_-_ad-gr-nm_le">
; <description>N, can modify, grad, nom case    
; <ex>B leaves soon.
; <nex>
; <todo>
; </type>
n_-_ad-gr-nm_le := norm_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.CASE nom,
			 VAL.SPR.FIRST.--MIN very_this_that_rel ],
		   CONT.RELS <! relation, relation, relation !> ] ].
;sooner
; <type val="n_-_ad-gr-cmp-nm_le">
; <description>N, can modify, grad, comp, nom   
; <ex>B left sooner.
; <nex>
; <todo>
; </type>
n_-_ad-gr-cmp-nm_le := norm_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.CASE nom,
			 VAL.SPR.FIRST [ --MIN much_deg_rel ] ],
		   CONT.RELS <! relation, relation,
			        [ LBL #lbl,
				  ARG0 #arg0,
				  CFROM #cfrom, CTO #cto ],
			        [ LBL #lbl,
				  PRED comp_rel,
				  ARG1 #arg0,
				  CFROM #cfrom, CTO #cto ] !> ] ].

; 'awhile'
; DPF 4-Apr-01 - Made ALTMIN be def_explicit_q_rel to block these guys as left 
; members of compounds as in "*the there books"
; DPF 11-Mar-02 - Changed SPR from anti_synsem_min to [MIN just_only_very_deg_rel]
; to allow "kim arrived just yesterday".
; DPF 04-Feb-03 - Can't make this [PRD -] because hadj rule now wants [PRD +]
; adjunct, but this means we overgenerate "the event awhile" since there's no
; way to say that "awhile" once turned into a modifier doesn't want to modify
; a nominal phrase.

; <type val="n_-_ad-time-acc_le">
; <description>N, can modify, temp, acc case    
; <ex>B stayed awhile.
; <nex>
; <todo>
; </type>
n_-_ad-time-acc_le := basic_np_adv_word &
  [ SYNSEM np_adv_synsem &
	   [ LOCAL [ CAT [ HEAD [ CASE acc,
				  MOD < >,
                                  MINORS.MIN time_n_rel ],
                           VAL [ SPR.FIRST [ --MIN just_only_very_deg_rel,
					     LOCAL [ CAT.HEAD adv,
						     CONT.HOOK [ LTOP #ltop,
								 XARG #arg0 ]]],
				 COMPS < > ] ],
                     CONT [ HOOK.INDEX.SORT time,
                            RELS <! relation, relation !> ] ],
             NONLOC.QUE 0-dlist,
             LKEYS [ ALTKEYREL [ LBL #ltop,
				 PRED def_explicit_q_rel ],
                     ALT2KEYREL.ARG0 #arg0 ] ] ].

; later (in the day)
; <type val="n_-_ad-cmp_le">
; <description>N, can modify, comparative       
; <ex>B left earlier.
; <nex>
; <todo>
; </type>
n_-_ad-cmp_le := basic_np_adv_word &
  [ SYNSEM np_adv_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < >,
			   VAL [ SPR.FIRST [ --MIN just_only_very_deg_rel,
					     LOCAL [ CAT.HEAD n_or_adv,
						     CONT.HOOK [ LTOP #hand,
								 XARG #carg0]]],
				 COMPS < > ] ],
                     CONT [ RELS <! [ LBL #hand, 
                                      PRED modable_rel,
                                      ARG0 #inst,
				      CFROM #cfrom,
				      CTO #cto ],
                                  [ PRED def_explicit_q_rel ],
                                  arg1_relation & #alt2key &
                                  [ LBL #hand,
				    ARG0 #arg0 &
					[ E [ TENSE no_tense,
					      ASPECT no_aspect ] ],
				    ARG1 #inst ],
                                  [ LBL #hand,
                                    PRED comp_rel,
				    ARG0 #carg0 & [ E [ TENSE no_tense,
                                                        ASPECT no_aspect ] ],
                                    ARG1 #arg0,
				    CFROM #cfrom,
				    CTO #cto ] !> ] ],
	     NONLOC.QUE 0-dlist,
	     LKEYS.ALT2KEYREL #alt2key ] ].

; DPF 27-Apr-00 - Added [CASE acc] to block spurious parse for "where is kim"
; DPF 19-Oct-02 - But this unfortunately also blocks "when would be a good 
; time to meet", and besides, "where would be a good place to meet" is okay.
; DPF 9-Jun-03 - Still, what's worse? extra parses for "where does kim work?"
; or no parse for "where would please sandy"?  Maybe we treat the latter as
; the result of robust parsing with relaxation of the CASE constraint, and
; exclude it as strictly grammatical (and likewise for "when would be a good
; time?").

n_wh_adv_lexent := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ CASE acc,
				  MOD < > ],
                           VAL [ SPR < anti_synsem_min & [ OPT - ] >,
                                 COMPS 
                                   < [ OPT +,
                                       --MIN wh_the_hell_rel,
                                       LOCAL [ CAT.HEAD wh_adv,
                                               CONJ cnil  ],
                                       NONLOC.SLASH 0-dlist ] > ] ],
                     CONT.RELS <! relation, [ PRED which_q_rel ] !> ],
             NONLOC.QUE 1-dlist &
		         [ LIST < param > ] ] ].

; <type val="n_-_ad-wh-pl_le">
; <description>N, can modify, WH-place          
; <ex>B wondered where C lived.
; <nex>
; <todo>
; </type>
n_-_ad-wh-pl_le := n_wh_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN place_n_rel,
                   CONT.HOOK.INDEX.SORT place ] ].

; <type val="n_-_ad-wh-tm_le">
; <description>N, can modify, WH-time           
; <ex>B wondered when C left.
; <nex>
; <todo>
; </type>
n_-_ad-wh-tm_le := n_wh_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN time_n_rel,
                   CONT.HOOK.INDEX.SORT time ] ].

; For "the town where we come from"
n_rel_np_lexent := basic_noun_word & noncqs-hm-nab &
  [ SYNSEM nomod_synsem &
           [ LOCAL [ CAT [ HEAD noun &
                                [ MINORS.ALTMIN def_q_rel,
                                  CASE obliq ],
                           VAL [ SPR < anti_synsem_min >,
                                 SPEC < >,
                                 COMPS < > ] ],
                     CONT [ HOOK.INDEX #ind,
                            RELS <! !>,
                            HCONS <! !> ],
                     AGR #ind ],
             MODIFD notmod,
             NONLOC.REL 1-dlist & [ LIST < [ INDEX #ind ] > ],
	     LKEYS.KEYREL.PRED no_rel ] ].
    
; Lexical NP plurals - maybe only in British English? ("IBM are hiring again.")
;
np_pl_word := np_word &
  [ SYNSEM np_synsem &
	   [ LOCAL.CAT.VAL.COMPS < >,
             --SIND.PNG png & [ PN 3p ] ] ].

; DPF 25-May-03 - Added MOD..LTOP so "o'clock" and "fifteen" can both be
; combined with hour-words the same way, by getting at the MOD..LTOP value
; of the complement phrase (necessary since intersective adjectives do not
; lexically bind their LTOP to their key's LBL).
np_ersatz_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < anti_synsem_min & 
                               [ LOCAL.CONT.HOOK.LTOP #hand ] >,
                         MINORS.ALTMIN no_rel ],
                  VAL [ SPR < >,
			SUBJ < >,
			COMPS < >,
                        SPEC < > ] ],
	    CONT nom-obj &
		[ RELS.LIST < #keyrel, ... > ] ],
    MODIFD.LPERIPH -,
    LKEYS.KEYREL #keyrel & [ LBL #hand ] ].

np_word_no_aff := non_affixed_np &
  [ SYNSEM np_ersatz_synsem ].

ref_pro_np_synsem := basic_np_synsem & ref_pro_synsem.

; DPF 19-dec-04 - Added non-empty specifier to allow restrictive relatives 
; with pronouns: "He who saves...", "you who have...", and "that which you
; did will be rewarded".  But want to restrict this to nominative pronouns,
; to avoid spurious structures: "Kim hired [them in Paris]". So push SPR
; constraint down to various subtypes.
; DPF 03-jul-08 - Re 19-dec-04: Pull back up to pers_pro_synsem, since we
; now use this non-empty SPR property to force application of bare_np_q.
; Distinguish "we in Paris" from "*them in Paris" by further constraining
; the --MIN of the SPR.

pers_pro_synsem := ref_pro_np_synsem &
  [ LOCAL.CAT.VAL.SPR < anti_synsem & 
			[ LOCAL.CONT.HOOK.LTOP #ltop,
			  OPT - ] >,
    LKEYS.ALTKEYREL.LBL #ltop ].

; For 'them all' as in 'we read them all', but not "*they hired me all"
;
pro_wcomps_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL [ COMPS 
                     < [ LOCAL [ CAT [ HEAD partn &
                                            [ MINORS [ MIN nonpro_rel,
						       ALTMIN both_all_q_rel]],
                                       VAL [ SPR *olist*,
					     COMPS < > ] ],
                                 CONT.HOOK.INDEX #cind ],
                         NONLOC non-local_none,
                         OPT -,
                         LEX +,
                         PUNCT.LPUNCT no_punct ] > ],
            CONT [ HOOK.INDEX #ind,
                   RELS <! [ LBL #lbl ], relation & #altkeyrel, 
			   #alt2keyrel & [ LBL #lbl,
					   PRED id_rel,
					   ARG0.E.TENSE no_tense,
					   ARG1 #ind,
					   ARG2 #cind ] !> ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    ALT2KEYREL #alt2keyrel ] ].


; For 'we/us/you humans' but not '*they/them humans' (and not '*he/she humans')
; DPF 12-Oct-06 - Re-use the general referential-identity pred 'appos_rel' 
; rather than the idiosyncratic 'id_rel' used in tag questions.
pro_wcomps_plur_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL [ COMPS 
                      < [ LOCAL [ CAT [ HEAD basic_noun & 
                                        [ MINORS 
					    [ MIN nonpro_rel,
					      ALTMIN both_all_udef_q_rel ] ],
					VAL [ SPR *olist*,
					      SUBJ < >,
					      COMPS < >,
					      SPEC < anti_synsem_min > ] ],
				  CONT.HOOK.INDEX #cind & nonconj_ref-ind,
				  AGR.PNG.PN pl ],
                           OPT - ] > ],
            CONT [ HOOK.INDEX #ind,
                   RELS <! [ LBL #lbl ], relation & #altkeyrel,
			   #alt2keyrel & [ LBL #lbl,
					   PRED appos_rel,
					   ARG0.E.TENSE no_tense,
					   ARG1 #ind,
					   ARG2 #cind ] !> ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    ALT2KEYREL #alt2keyrel ] ].



basic_personal_pro := basic_np_word & basic_pronoun_word & 
                      basic_non_affixed_np &
  [ SYNSEM pers_pro_synsem &
	   [ LOCAL.CONT [ HOOK.LTOP #prohand,
                          RELS.LIST < [ LBL #prohand,
                                        PRED pron_rel,
                                        ARG0 #inst ],
                                      #altkeyrel &
                                      [ PRED pronoun_q_rel,
                                        RSTR #rhand,
                                        ARG0 #inst ], ... >,
                          HCONS <! qeq & [ HARG #rhand,
                                           LARG #prohand ] !> ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

personal_pro := basic_personal_pro &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT.RELS <! relation, relation !> ] ].

; <type val="n_-_pr-na_le">
; <description>Pronoun, no agreement            
; <ex>Someone sings, don't they
; <nex>
; <todo>
; </type>
n_-_pr-na_le := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE nom,
                                MINORS.MIN pron_rel ],
                     AGR.PNG png & [ PN 3p ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                             GEN andro ],
				 DIV -,
                                 SORT entity,
                                 PT std ] ] ].

basic_n_pers_pro_lexent := basic_personal_pro & 
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                   AGR #agr,
		   CONT.HOOK.INDEX #agr &
			        [ PT std ] ] ].

n_pers_pro_lexent := basic_n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ HOOK.INDEX.SORT entity,
                          RELS <! relation, relation !> ] ] ].

n_pers_pro_nom_lexent := n_pers_pro_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom ].

n_pers_pro_acc_lexent := n_pers_pro_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE non_nom,
		       VAL.SPR < [ --MIN no_rel ] > ] ].

n_-_pr-he_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN masc ],
			       DIV -,
                               PT std ] ].

; <type val="n_-_pr-he_le">
; <description>Pronoun 'he'                     
; <ex>He arrived.
; <nex>
; <todo>
; </type>
n_-_pr-he_le := n_-_pr-he_lexent.

; <type val="n_-_pr-he-mal_le">
; <description>Pronoun 'he', robust                     
; <ex>He - he arrived.
; <nex>
; <todo>
; </type>
n_-_pr-he-mal_le := n_-_pr-he_lexent &
  [ GENRE robust ].

n_-_pr-he_le_rbst := n_-_pr-he_lexent &
  [ GENRE robust ].

n_-_pr-she_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN fem ],
			       DIV -,
                               PT std ] ].

; <type val="n_-_pr-she_le">
; <description>Pronoun 'she'                    
; <ex>She arrived.
; <nex>
; <todo>
; </type>
n_-_pr-she_le := n_-_pr-she_lexent.

; <type val="n_-_pr-she-mal_le">
; <description>Pronoun 'she', robust                    
; <ex>She she arrived.
; <nex>
; <todo>
; </type>
n_-_pr-she-mal_le := n_-_pr-she_lexent &
  [ GENRE robust ].

n_-_pr-she_le_rbst := n_-_pr-she_lexent &
  [ GENRE robust ].

; <type val="n_-_pr-her_le">
; <description>Pronoun 'her'                    
; <ex>B hired her.
; <nex>
; <todo>
; </type>
n_-_pr-her_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN fem ],
			       DIV -,
                               PT std ] ].

; <type val="n_-_pr-him_le">
; <description>Pronoun 'him'                    
; <ex>B hired him.
; <nex>
; <todo>
; </type>
n_-_pr-him_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN masc ],
			       DIV -,
                               PT std ] ].

n_-_pr-i_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
			       DIV -,
                               PT std ] ].

; <type val="n_-_pr-i_le">
; <description>Pronoun 'i'                      
; <ex>I arrived.
; <nex>
; <todo>
; </type>
n_-_pr-i_le := n_-_pr-i_lexent.

; <type val="n_-_pr-i-mal_le">
; <description>Pronoun 'i', robust
; <ex>I I arrived.
; <nex>
; <todo>
; </type>
n_-_pr-i-mal_le := n_-_pr-i_lexent &
  [ GENRE robust ].

n_-_pr-i_le_rbst := n_-_pr-i_lexent &
  [ GENRE robust ].

; <type val="n_-_pr-me_le">
; <description>Pronoun 'me'                     
; <ex>B hired me.
; <nex>
; <todo>
; </type>
n_-_pr-me_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
			       DIV -,
                               PT std ] ].

n_-_pr-you_lexent := n_pers_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
			       PT std,
			       SORT entity ] ].

; <type val="n_-_pr-you_le">
; <description>Pronoun 'you'                    
; <ex>You arrived.
; <nex>
; <todo>
; </type>
n_-_pr-you_le := n_-_pr-you_lexent.

; <type val="n_-_pr-you-mal_le">
; <description>Pronoun 'you', robust
; <ex>You you arrived.
; <nex>
; <todo>
; </type>
n_-_pr-you-mal_le := n_-_pr-you_lexent &
  [ GENRE robust ].

n_-_pr-you_le_rbst := n_-_pr-you_lexent &
  [ GENRE robust ].

; DPF 7-Dec-02 - ACTIVATED is here experimentally, and at present only prevents
; "it" from being topicalized as in "*It I like".

n_-_pr-it_lexent := basic_n_pers_pro_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR < [ --MIN no_rel ] >,
			       COMPS < > ],
                     CONT.RELS <! relation, relation !>,
                     CTXT.ACTIVATED - ],
	     MODIFD.RPERIPH +,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                             GEN neut ],
                                 PT std ] ] ].

; <type val="n_-_pr-it_le">
; <description>Pronoun 'it'                     
; <ex>It arrived.
; <nex>
; <todo>
; </type>
n_-_pr-it_le := n_-_pr-it_lexent.

; <type val="n_-_pr-it-mal_le">
; <description>Pronoun 'it', robust                     
; <ex>It - it arrived.
; <nex>
; <todo>
; </type>
n_-_pr-it-mal_le := n_-_pr-it_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.DIV -,
    GENRE robust ].

n_-_pr-it_le_rbst := n_-_pr-it_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.DIV -,
    GENRE robust ].

n_-_pr-we_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                               PT std,
                               SORT entity ] ].
; <type val="n_-_pr-we_le">
; <description>Pronoun 'we'                     
; <ex>We arrived.
; <nex>
; <todo>
; </type>
n_-_pr-we_le := n_-_pr-we_lexent.

; <type val="n_-_pr-we-mal_le">
; <description>Pronoun 'we', robust                     
; <ex>We - we arrived.
; <nex>
; <todo>
; </type>
n_-_pr-we-mal_le := n_-_pr-we_lexent &
  [ GENRE robust ].

n_-_pr-we_le_rbst := n_-_pr-we_lexent &
  [ GENRE robust ].

; <type val="n_-_pr-us_le">
; <description>Pronoun 'us'                     
; <ex>B hired us.
; <nex>
; <todo>
; </type>
n_-_pr-us_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                               PT std,
                               SORT entity ] ].

n_-_pr-they_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                               PT std ] ].

; <type val="n_-_pr-they_le">
; <description>Pronoun 'they'                   
; <ex>They arrived.
; <nex>
; <todo>
; </type>
n_-_pr-they_le := n_-_pr-they_lexent.

; <type val="n_-_pr-they-mal_le">
; <description>Pronoun 'they', robust
; <ex>They they arrived.
; <nex>
; <todo>
; </type>
n_-_pr-they-mal_le := n_-_pr-they_lexent &
  [ GENRE robust ].

n_-_pr-they_le_rbst := n_-_pr-they_lexent &
  [ GENRE robust ].

; <type val="n_-_pr-them_le">
; <description>Pronoun 'them'                   
; <ex>B hired them.
; <nex>
; <todo>
; </type>
n_-_pr-them_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                               PT std ] ].

; <type val="n_-_pr-thou_le">
; <description>Pronoun 'thou'                   
; <ex>Thou must sleep.
; <nex>
; <todo>
; </type>
n_-_pr-thou_le := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                               PT std,
                               SORT entity ] ].

; <type val="n_-_pr-thee_le">
; <description>Pronoun 'thee                    
; <ex>B hired thee.
; <nex>
; <todo>
; </type>
n_-_pr-thee_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                               PT std,
                               SORT entity ] ].
; 'yours truly'
; <type val="n_-_pr-1sg-na_le">
; <description>Pronoun 'yours truly'            
; <ex>Yours truly arrived.
; <nex>
; <todo>
; </type>
n_-_pr-1sg-na_le := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                     AGR.PNG png & [ PN 3s ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
				 DIV -,
                                 PT std ] ] ].

; <type val="n_np_pr-us_le">
; <description>Pro with plur NP comp 'us'       
; <ex>B saw us players.
; <nex>
; <todo>
; </type>
n_np_pr-us_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_plur_synsem &
           [ LOCAL [ CAT [ HEAD.CASE non_nom,
			   VAL.SPR < [ --MIN no_rel ] > ],
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                                 PT std ] ] ].
            
; <type val="n_np_pr-we_le">
; <description>Pro with plur NP comp 'we'       
; <ex>We players arrived.
; <nex>
; <todo>
; </type>
n_np_pr-we_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_plur_synsem &
           [ LOCAL [ CAT.HEAD.CASE nom,
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                                 PT std ] ] ].


n_np_pr-you_lexent := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_plur_synsem &
           [ LOCAL.CONT.HOOK.INDEX.SORT entity,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                                 PT std ] ] ].

; <type val="n_np_pr-you_le">
; <description>Pro with plur NP comp 'you'      
; <ex>You players arrived.
; <nex>
; <todo>
; </type>
n_np_pr-you_le := n_np_pr-you_lexent.

; <type val="n_np_pr-it_le">
; <description>Pro with NP comp 'it'            
; <ex>It all was good.
; <nex>
; <todo>
; </type>
n_np_pr-it_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.VAL.SPR < [ --MIN no_rel ]  >,
		     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s ],
				 DIV -,
                                 PT std ] ] ].
            
n_np_pr-they_lexent := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.HEAD.CASE nom,
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                                 PT std ] ] ].

; <type val="n_np_pr-they_le">
; <description>Pro with NP comp 'they'          
; <ex>They all left.
; <nex>
; <todo>
; </type>
n_np_pr-they_le := n_np_pr-they_lexent.
            
; <type val="n_np_pr-they-mal_le">
; <description>Pro with NP comp 'they', robust
; <ex>They they all left.
; <nex>
; <todo>
; </type>
n_np_pr-they-mal_le := n_np_pr-they_lexent &
  [ GENRE robust ].

; <type val="n_np_pr-them_le">
; <description>Pro with NP comp 'them'          
; <ex>We hired them both.
; <nex>
; <todo>
; </type>
n_np_pr-them_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT [ HEAD.CASE non_nom,
			   VAL.SPR < [ --MIN no_rel ] > ],
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                                 PT std ] ] ].
            
n_refl_pro_lexent := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE non_nom,
				MINORS.MIN refl_pron_rel ],
		     AGR #agr,
                     CONT.HOOK.INDEX #agr ],
             LKEYS.KEYREL [ PRED pron_rel,
                            ARG0 [ PT refl,
                                   SORT entity ] ] ] ].

; <type val="n_-_pr-herself_le">
; <description>Reflexive pro 'herself'          
; <ex>She saw herself.
; <nex>
; <todo>
; </type>
n_-_pr-herself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN fem ] ].
; <type val="n_-_pr-himself_le">
; <description>Reflexive pro 'himself'          
; <ex>He saw himself.
; <nex>
; <todo>
; </type>
n_-_pr-himself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN masc ] ].
; <type val="n_-_pr-itself_le">
; <description>Reflexive pro 'itself'           
; <ex>It saw itself.
; <nex>
; <todo>
; </type>
n_-_pr-itself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN neut ] ].
; <type val="n_-_pr-myself_le">
; <description>Reflexive pro 'myself'           
; <ex>I saw myself.
; <nex>
; <todo>
; </type>
n_-_pr-myself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 1s ] ].
; <type val="n_-_pr-ourslves_le">
; <description>Reflexive pro 'ourselves'        
; <ex>We saw ourselves
; <nex>
; <todo>
; </type>
n_-_pr-ourslves_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 1p ] ].
; <type val="n_-_pr-themslves_le">
; <description>Reflexive pro 'themselves'       
; <ex>They saw themselves.
; <nex>
; <todo>
; </type>
n_-_pr-themslves_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ].
; <type val="n_-_pr-yourself_le">
; <description>Reflexive pro 'yourself'         
; <ex>You saw yourself.
; <nex>
; <todo>
; </type>
n_-_pr-yourself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 2s ] ].
; <type val="n_-_pr-yourslves_le">
; <description>Reflexive pro 'yourselves'       
; <ex>You saw yourselves.
; <nex>
; <todo>
; </type>
n_-_pr-yourslves_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 2p ] ].
; <type val="n_-_pr-oneself_le">
; <description>Reflexive pro 'oneself'          
; <ex>One saw oneself.
; <nex>
; <todo>
; </type>
n_-_pr-oneself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN andro ] ].

; 'see it yourself!'
; DPF 25-aug-07 - Restricted MOD..HEAD to AUX - to avoid spurious ambiguity 
; for e.g. "He was hired himself."

basic_adv_refl_pro_lexent := noncrs-hm &
  [ INFLECTD +,
    SYNSEM basic_int_adverb_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT adverbee_cat &
                                                  [ HEAD.AUX -,
                                                    VAL [ SUBJ *synlist*,
                                                          COMPS < > ] ],
                                        MODIFD.RPERIPH na_or_- ] >,
                           VAL.SPR < anti_synsem > ],
                     CONT [ RELS <! [ PRED refl_mod_rel,
                                      ARG2 #inst ],
                                    #altkeyrel &
                                    [ LBL #prohand, 
                                      PRED pron_rel,
                                      ARG0 #inst & [ PT refl,
                                                     SORT entity ] ],
				    #alt2keyrel &
                                    [ PRED pronoun_q_rel,
                                      RSTR #rhand,
                                      ARG0 #inst ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !> ] ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

adv_refl_pro_lexent := basic_adv_refl_pro_lexent &
  [ SYNSEM.LOCAL.CAT.POSTHD + ].

; <type val="av_-_pr-herself_le">
; <description>Refl pro modifier of VP          
; <ex>She did it herself.
; <nex>
; <todo>
; </type>
av_-_pr-herself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN fem ] ].
; <type val="av_-_pr-himself_le">
; <description>Refl pro modifier of VP          
; <ex>He did it himself.
; <nex>
; <todo>
; </type>
av_-_pr-himself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN masc ] ].
; <type val="av_-_pr-itself_le">
; <description>Refl pro modifier of VP          
; <ex>It did it itself.
; <nex>
; <todo>
; </type>
av_-_pr-itself_le := basic_adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN neut ] ].
; <type val="av_-_pr-myself_le">
; <description>Refl pro modifier of VP          
; <ex>I did it myself.
; <nex>
; <todo>
; </type>
av_-_pr-myself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 1s ] ].
; <type val="av_-_pr-ourslvs_le">
; <description>Refl pro modifier of VP          
; <ex>We did it ourselves.
; <nex>
; <todo>
; </type>
av_-_pr-ourslvs_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 1p ] ].
; <type val="av_-_pr-thmslvs_le">
; <description>Refl pro modifier of VP          
; <ex>They did it themselves.
; <nex>
; <todo>
; </type>
av_-_pr-thmslvs_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3p ] ].
; <type val="av_-_pr-yrself_le">
; <description>Refl pro modifier of VP          
; <ex>You did it yourself.
; <nex>
; <todo>
; </type>
av_-_pr-yrself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 2s ] ].
; <type val="av_-_pr-yrslvs_le">
; <description>Refl pro modifier of VP          
; <ex>You did it yourselves.
; <nex>
; <todo>
; </type>
av_-_pr-yrslvs_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 2p ] ].
; <type val="av_-_pr-oneself_le">
; <description>Refl pro modifier of VP          
; <ex>One did it oneself.
; <nex>
; <todo>
; </type>
av_-_pr-oneself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN andro ] ].

; <type val="n_-_pr-recip_le">
; <description>Reciprocal pronoun               
; <ex>We saw each other.
; <nex>
; <todo>
; </type>
n_-_pr-recip_le := np_word &
  [ SYNSEM ref_pro_np_synsem &
	   [ LOCAL [ CAT [ HEAD [ CASE non_nom,
                                  MINORS.MIN recip_pro_rel ],
                           VAL.COMPS < > ],
                     AGR #ind,
                     CONT [ HOOK.INDEX #ind,
			    RELS <! [ LBL #prohand,
                                      PRED recip_pro_rel,
                                      ARG0.PT recip ],
				    #altkeyrel &
                                    [ PRED pronoun_q_rel,
                                      ARG0 #ind,
                                      RSTR #rhand ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !> ] ],
             LKEYS [ KEYREL.ARG0.PNG png & [ PN pl ],
		     ALTKEYREL #altkeyrel ] ] ].

; 'yours'
; DPF 15-Apr-00 = Changed MIN to be pron_rel rather than pronoun_q_rel, since
; e.g. prepositions want a non_temp_nom_rel as their argument.

n_poss_pro_lexent := noncrs-hm-nab & basic_pronoun_word &
  [ SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD partn & [ MINORS [ MIN pron_rel,
						   ALTMIN poss_rel ] ],
                           VAL [ COMPS < >,
				 SPR < anti_synsem_min & [ OPT - ] >,
				 SPEC < anti_synsem_min > ] ],
                     AGR #index,
		     CONT [ HOOK.INDEX #index,
			    RELS <! #keyrel & 
				     [ LBL #prohand,
                                       PRED pron_rel,
                                       ARG0 #pind &
                                           [ PT std,
                                             SORT entity ],
				       CFROM #from,
				       CTO #to ],
                                     [ PRED pronoun_q_rel,
                                       ARG0 #pind,
				       RSTR #rhand,
				       CFROM #from,
				       CTO #to ],
				     #alt2keyrel &
				     [ PRED def_implicit_q_rel,
                                       ARG0 #index,
				       RSTR #phand ],
                                     nom_relation &
                                     [ LBL #nhand,
                                       PRED generic_entity_rel,
                                       ARG0 #index,
				       CFROM #from,
				       CTO #to ],
                                     #altkeyrel & prep_relation &
				     [ LBL #nhand,
                                       PRED poss_rel,
                                       ARG0.E [ TENSE no_tense,
                                                ASPECT no_aspect ],
				       ARG1 #index,
				       ARG2 #pind ] !>,
			    HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ],
                                      qeq & [ HARG #phand,
                                              LARG #nhand ] !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel,
                     ALT2KEYREL #alt2keyrel ],
             NONLOC.QUE <! !>,
	     MODIFD notmod ] ].

; <type val="n_-_pr-hers_le">
; <description>Possessive pro 'hers'            
; <ex>Hers arrived.
; <nex>
; <todo>
; </type>
n_-_pr-hers_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
                                                       GEN fem ] ].
; <type val="n_-_pr-his_le">
; <description>Possessive pro 'his'             
; <ex>His arrived.
; <nex>
; <todo>
; </type>
n_-_pr-his_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
                                                       GEN masc ] ].
; <type val="n_-_pr-its_le">
; <description>Possessive pro 'its'             
; <ex>Its has arrived.
; <nex>
; <todo>
; </type>
;; DPF 24-apr-09 - Removed pronominal |its| since it is of dubious use and
;; leads to unwanted ambiguity.  FIX someday?
;;n_-_pr-its_le := n_poss_pro_lexent &
;;  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
;;                                                       GEN neut ] ].

; <type val="n_-_pr-mine_le">
; <description>Possessive pro 'mine'            
; <ex>Mine arrived.
; <nex>
; <todo>
; </type>
n_-_pr-mine_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1s ] ].
; <type val="n_-_pr-ours_le">
; <description>Possessive pro 'ours'            
; <ex>Ours arrived.
; <nex>
; <todo>
; </type>
n_-_pr-ours_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1p ] ].
; <type val="n_-_pr-theirs_le">
; <description>Possessive pro 'theirs'          
; <ex>Theirs arrived.
; <nex>
; <todo>
; </type>
n_-_pr-theirs_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3p ] ].
; <type val="n_-_pr-yours_le">
; <description>Possessive pro 'yours'           
; <ex>Yours arrived.
; <nex>
; <todo>
; </type>
n_-_pr-yours_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 2 ] ].

; Expletive pronouns "there" and "it"
; DPF 3-Jul-02 - Changed MIN from no_rel to pron_rel, to allow simpler
; generalization about subjects of tag-phrases.  Still have empty RELS

norm_pronoun_word := noncqrs-m-nab & basic_pronoun_word.

; <type val="n_-_pr-it-x_le">
; <description>Expletive pro 'it'               
; <ex>It rained.
; <nex>
; <todo>
; </type>
n_-_pr-it-x_le := norm_pronoun_word &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                     CONT [ HOOK.INDEX it-ind,
                            RELS <! !> ] ],
             LKEYS.KEYREL.PRED pron_rel,
	     MODIFD notmod ] ].

; <type val="n_-_pr-there-x_le">
; <description>Expletive pro 'there'            
; <ex>There are cats here.
; <nex>
; <todo>
; </type>
n_-_pr-there-x_le := norm_pronoun_word &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                     CONT [ HOOK.INDEX there-ind,
                            RELS <! !> ] ],
             LKEYS.KEYREL.PRED pron_rel,
	     MODIFD notmod ] ].
			  

; ERB (31-10-96) A hack:  I want the wh_interrogs to be able to
; get their hands on the which_q_rel so they can put it on the PARAMS
; list, but QSTORE isn't working yet.  So I am making the QUE value
; of wh_pro_word, wh_adverb_word, and wh_poss_word be the handle of
; the which_q_rel, so that this gets passed up in such a way that I can see it.

; DPF (3-May-99) We can't just put the handle of the which_q_rel in QUE, since
; in coordinate structures like "which book and which record did sandy buy?"
; we want to unify the NONLOCs of "which book" and "which record", but this
; would mean that the handles of the two which_q_rel's would be wrongly 
; identified. 
; So for now I'm just putting in an unbound handle - we'll have to sort out
; with Ivan what the right solution is.
; DPF 16-jan-08 - Tried changing MIN from norm_nom_rel to pron_rel in order
; to block "*Who's cat", but this runs afoul of constraint on ditransitives
; like "show" to avoid "*he showed Browne it."  So find a better solution...
; FIX
; DPF 2010-08-31 - Changed [SPR anti_synsem_min]  to unexpressed since this 
; was blocking e.g. |who in this town ...|.  But note "Exactly who won?", so
; FIX to allow some limited range of specifiers.

; 'who, what'
n_wh_pro_lexent := que_word & basic_pronoun_word &
  [ SYNSEM ref_pro_synsem &
	 [ LOCAL [ CAT [ HEAD.MINORS.MIN pron_nonlocal_rel,
                         VAL [ SPR < unexpressed & 
				     [ OPT -,
				       --MIN deg_rel ] >,
			       COMPS < [ OPT +,
                                         --MIN wh_the_hell_rel,
                                         LOCAL [ CAT.HEAD wh_adv,
                                                 CONJ cnil ],
                                         PUNCT.LPUNCT no_punct ] > ] ],
                   AGR #index,
                   CONT [ HOOK [ INDEX #index,
                                 XARG #nhand ],
                          RELS <! [ LBL #nhand ],
				  #altkeyrel &
                                  [ PRED which_q_rel,
                                    ARG0 #index,
                                    RSTR #rhand ] !>,
			  HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !> ] ],
	   NONLOC.QUE 1-dlist &
		         [ LIST < param > ],
	   MODIFD notmod,
	   LKEYS.ALTKEYREL #altkeyrel ] ].

; <type val="n_-_pr-wh_le">
; <description>WH pro                           
; <ex>B wondered what arrived.
; <nex>
; <todo>
; </type>
n_-_pr-wh_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nominal-sort ].

; <type val="n_-_pr-who_le">
; <description>WH pro, singular                 
; <ex>B wondered who arrives.
; <nex>
; <todo>
; </type>
n_-_pr-who_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.PN 3s,
				   SORT human ] ].

; <type val="n_-_pr-wh-acc_le">
; <description>WH pro, acc case                 
; <ex>B wondered whom to hire.
; <nex>
; <todo>
; </type>
n_-_pr-wh-acc_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE non_nom,
		   CONT.HOOK.INDEX [ PNG.PN 3s,
				     SORT human ] ] ].

; DPF 2010-09-17 - Since n-adj-redrel rule now requires that the head have
; SPR value `synsem', change the SPR value here from anti_synsem_min to 
; unexpressed.

basic_n_rel_pro_lexent := noncqs-hm & basic_pronoun_word & 
  [ SYNSEM pronominal_synsem &
	 [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN pronoun_q_rel,
			 VAL [ SUBJ < >,
			       SPR < unexpressed & 
				     [ OPT - ] >,
			       COMPS < > ] ],
                   AGR #index,
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index,
                                 XARG #xarg ],
			  RELS <! !>,
			  HCONS <! !> ] ],
           LKEYS [ KEYREL [ LBL #hand,
                            PRED no_rel ],
                   ALTKEYREL relation ],
           NONLOC.REL 1-dlist &
		         [ LIST < [ LTOP #hand,
				    INDEX #index,
                                    XARG #xarg ] > ] ] ].

n_rel_pro_lexent := basic_n_rel_pro_lexent &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN pron_nonlocal_rel,
			    MOD < > ] ].

; <type val="n_-_pr-rel-who_le">
; <description>Relative pro 'who'               
; <ex>Kids who sang danced.
; <nex>
; <todo>
; </type>
n_-_pr-rel-who_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFD notmod,
             LOCAL.CONT.HOOK.INDEX.SORT human ] ].

; <type val="n_-_pr-rel-what_le">
; <description>Relative pro 'what'              
; <ex>Things what fell broke.
; <nex>
; <todo>
; </type>
n_-_pr-rel-what_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFD notmod,
             LOCAL.CONT.HOOK.INDEX.SORT nominal-sort ] ].

; Not notmod to let us get "the day that I arrived"/"*the day which i arrived"

; <type val="n_-_pr-rel-acc_le">
; <description>Relative pro, acc case           
; <ex>Kids to whom B spoke sang.
; <nex>
; <todo>
; </type>
n_-_pr-rel-acc_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD.CASE non_nom,
                     CONT.HOOK.INDEX.SORT human ] ] ].

; Unmarked for MODIFD, so can undergo temp_np rule to get "the day that I
; arrived"  But to get this, also need to make SPR be non-empty, since the
; extracted-adj-temp rule only allows n-bar slashed elements.
; DPF 19-dec-03 - In fact, need two entries for 'that', since we want to
; allow "the place that Kim stood" but not "*the car that Kim stood" (cf
; "the car where Kim stood".  The one entry is the nbar-filler for the gap
; for the np_adv_c.
;; DPF 2012-03-14 - Should remind ourselves of where the [INFLECTD na] move
;; helps, since it means the rule for reduced-relatives has to allow the
;; head-dtr to be na_or_+, to get |the cat that on Tuesday was sick is happy|
;; DPF 2012-08-29 - Added LPERIPH + to avoid |true that| with aj-hdn_adjn_c rule
;; now that we have removed the spurious REL 0-dlist from isect_synsem.
;;
; <type val="n_-_pr-rel-nwh_le">
; <description>Relative pro, non-WH, only `that'
; <ex>Things that fell broke.
; <nex>
; <todo>
; </type>
n_-_pr-rel-nwh_le := basic_n_rel_pro_lexent &
  [ INFLECTD na,
    SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN pron_nonlocal_rel,
				PRD -,
				MOD < > ],
		     CONT.HOOK.INDEX.SORT nominal-sort ],
	     MODIFD.LPERIPH + ] ].

; DPF 28-Aug-99 - SPR..MIN no_rel prevents these from undergoing hdn_bnp_c rule
; DPF 09-Jan-00 - In fact, can now eliminate bogus SPR, since picking up
; post-head adjuncts as complements.
; DPF 06-May-03 - Removed COMPS..HEAD adj* restriction, since we need to have
; these guys pick up post-head PPs as complements so "anytime after three"
; can still be compatible with the npadv_mod rule's requirement that the dtr
; be [HODIFIED lmod], in order to get the desired analysis for "Kim arrived
; sometime after three".
; DPF 03-Dec-03 - But now getting posthead PPs as modifiers, so go back to
; only allowing adjectival complements.
; DPF 03-Dec-06 - Since also get modifier analysis for all phrases, restrict
; this complement to LEX +, to allow "anyone tall" which would not parse 
; with a modifier analysis.

generic_pro_adv_word := que_word & basic_pronoun_word &
  [ SYNSEM np_synsem &
     [ LOCAL 
        [ CAT [ HEAD #head & 
                     [ MINORS.ALTMIN nondef_explicit_q_rel ],
                VAL [ SPR < [ --MIN degree_rel,
                              LOCAL [ CAT.HEAD adv,
				      CONT.HOOK [ LTOP #khand,
						  XARG #inst ] ],
                              NONLOC [ QUE 0-dlist,
                                       REL 0-dlist ] ],
			    anti_synsem_min & [ OPT - ] >,
                      COMPS < [ OPT +,
                                LEX +,
                                LOCAL 
                                 [ CAT prd_cat & 
                                       [ HEAD v_or_a &
                                         [ MOD < synsem &
						 [ LOCAL.CAT.HEAD #head ] > ]],
                                   CONJ cnil,
                                   CONT.HOOK [ LTOP #nhand,
                                               XARG #inst ] ],
                                NONLOC non-local_none,
                                PUNCT.LPUNCT no_punct ] > ] ],
          CONT [ HOOK.LTOP #nhand,
                 RELS <! relation,
                         #altkeyrel & [ PRED quant_rel ] !>,
                 HCONS <! qeq &
                        [ HARG #rhand,
                          LARG #nhand ] !> ] ],
       LKEYS [ KEYREL [ LBL #nhand,
                        ARG0 #inst & [ PNG png & [ PN 3s ] ] ],
               ALTKEYREL #altkeyrel & 
                      [ LBL #khand,
                        ARG0 #inst,
                        RSTR #rhand ] ],
       NONLOC.QUE 0-dlist ] ].

; <type val="n_-_pr-ad_le">
; <description>Lexical det-n, can modify        
; <ex>B lives somewhere.
; <nex>
; <todo>
; </type>
n_-_pr-ad_le := generic_pro_adv_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN modable_rel ].

n_generic_pro_lexent := generic_pro_adv_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.SORT non-time-sort,
             MODIFD notmod ] ].

; <type val="n_-_pr_le">
; <description>Lexical det-n                    
; <ex>Something fell.
; <nex>
; <todo>
; </type>
n_-_pr_le := n_generic_pro_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ].
                     
; 'one'
; DPF 23-sept-04 - Curious note: If we don't make COMPS < anti_synsem_min >,
; then we get an asymmetry in how PET and the LKB process "one should": PET
; allows "one" to undergo hd_optcmp_c rule in addition to hdn_optcmp_c rule, even
; though hd_optcmp_c says head is MIN event_rel while 'one' says MIN is not
; (obviously) a subtype of event_rel.  FIX...
;; DPF 2011-08-29 - Re 23-sept-04: This asymmetry no longer appears, so 
;; removed this hack, to be consistent with treatment of optional nominal
;; complements.
;;
; <type val="n_-_pr-one_le">
; <description>Pronoun 'one'                    
; <ex>One should sleep.
; <nex>
; <todo>
; </type>
n_-_pr-one_le := n_generic_pro_lexent &
  [ SYNSEM.LOCAL 
           [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                   VAL [ SPR.FIRST [ --MIN just_only_deg_rel ] ] ],
             CONT.HOOK.INDEX [ PNG.GEN andro,
			       SORT entity ] ] ].

n_deictic_pro_lexent := norm_pronoun_word &
  [ SYNSEM ref_pro_synsem &
    [ LOCAL 
      [ CAT [ HEAD.MINORS [ MIN generic_nom_rel,
                            ALTMIN demonstrative_q_rel ],
              VAL [ SPR < [ --MIN just_only_deg_rel,
                            LOCAL.CONT.HOOK.LTOP #khand,
                            NONLOC [ QUE 0-dlist,
                                     REL 0-dlist ] ],
			  anti_synsem_min & [ OPT - ] >,
                    COMPS < [ LOCAL.CAT 
                             [ HEAD partn &
                                    [ MINORS [ MIN part_of_rel,
					       ALTMIN both_all_q_rel ] ],
                               VAL [ SPR < synsem &
					   [ LOCAL.CAT.HEAD adv ] >,
                                     COMPS < unexpressed &
                                             [ LOCAL 
                                               [ CAT nomp_cat_min,
                                                 CONT.HOOK.INDEX index,
                                                 AGR #index ],
					       OPT +,
                                               --SIND #index ] > ] ],
                              OPT +,
                              LEX +,
                              PUNCT.LPUNCT no_punct ] > ] ],
        CONT [ HOOK [ LTOP #nhand,
                      INDEX #index,
                      XARG #nhand ],
               RELS <! [ LBL #nhand,
                         PRED generic_entity_rel ], 
                     #altkeyrel &
                     [ LBL #khand,
                       PRED demonstrative_q_rel,
                       ARG0 #ind,
                       RSTR #rhand ] !>,
               HCONS <! qeq &
                      [ HARG #rhand,
                        LARG #hand ] !> ],
        AGR #index ],
      LKEYS [ KEYREL [ LBL #hand,
                       ARG0 #ind ],
              ALTKEYREL #altkeyrel ],
      MODIFD notmod ] ].

; 'those of us who ...'
; <type val="n_pp_pr-dei-3pl_le">
; <description>Deictic pro, 'those of us who'   
; <ex>Those of us who sang won.
; <nex>
; <todo>
; </type>
n_pp_pr-dei-3pl_le := noncqrs-m-nab & basic_pronoun_word &
  [ SYNSEM ref_pro_synsem &
    [ LOCAL [ CAT [ HEAD.MINORS [ MIN generic_nom_rel,
                                  ALTMIN demonstrative_q_rel ],
                    VAL [ SPR < [ --MIN just_only_deg_rel,
                                  LOCAL.CONT.HOOK.LTOP #dhand,
                                  NONLOC [ QUE 0-dlist,
                                           REL 0-dlist ] ],
				anti_synsem_min & [ OPT - ] >,
                          COMPS < [ --MIN _of_p_sel_rel,
                                    LOCAL [ CAT [ HEAD prep & 
                                                       [ PRD -,
                                                         TAM.TENSE nontense ],
                                                  VAL.COMPS < > ],
                                            CONT.HOOK.INDEX #pind ],
                                    OPT -,
                                    PUNCT.LPUNCT no_punct ] > ] ],
              CONT [ HOOK [ LTOP #hand,
                            INDEX #ind & [ PNG.PN 3p ],
                            XARG #hand ],
                     RELS <! #keyrel & 
                             [ LBL #hand,
                               PRED part_of_rel,
                               ARG0 #ind,
                               ARG1 #pind & non_expl-ind ], 
                             #altkeyrel &
                             [ LBL #dhand,
                               PRED _those_q_dem_rel,
                               ARG0 #ind,
                               RSTR #rhand ] !>,
                     HCONS <! qeq &
                              [ HARG #rhand,
                                LARG #hand ] !> ],
              AGR #ind ],
      LKEYS [ KEYREL #keyrel,
              ALTKEYREL #altkeyrel ],
      MODIFD notmod ] ].

; DPF 16-oct-03 - Added NORM norm_rel to prevent singular deictics from
; being modified, to get contrast of "*that he bought yesterday arrived" vs
; "those he bought yesterday arrived".
; DPF 19-dec-04 - But this also rules out relative clauses with "which", as
; in 'that which you need will be provided'.  Not clear how to exclude the
; thatless-relatives for singular deictics: odd constraint.  For now, remove
; the old constraint, and overgenerate the first example above.
; DFP 25-oct-05 - Since this overgeneration continues to be costly, we 
; distinguish singular from plural deictics in NORM, and constrain the
; fin_non_wh_rel_cl rule to require its MOD to be NORM norm_rel, so we
; block "*This he bought was nice" but admit "Those he bought were nice".

; <type val="n_-_pr-dei-sg_le">
; <description>Deictic pro, sing                
; <ex>This works.
; <nex>
; <todo>
; </type>
n_-_pr-dei-sg_le := n_deictic_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM deictic_sg_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3s,
                                           GEN neut ] ] ].

; <type val="n_-_pr-dei-pl_le">
; <description>Deictic pro, plur                
; <ex>Those work.
; <nex>
; <todo>
; </type>
n_-_pr-dei-pl_le := n_deictic_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsems for Auxiliary verb lexical rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ERB (05-10-97) Making this specific to question auxes.  See notes near sai
; in syntax.tdl.
; DPF 26-Jan-01 - Changed HEAD.INV + to HEAD.INV +* to allow for coordination
; of inverted and non-inverted sentences.  Prevent yes-no question rule from
; applying to main verbs by making inverted auxiliaries [MC na], so they have
; to undergo the yes-no rule.
; ERB (2003-10-13) Need a supertype to allow mal_sai_synsem: making
; basic_sai_synsem.

basic_sai_synsem_min := synsem_min.
basic_sai_synsem := lex_synsem & basic_sai_synsem_min &
  [ LOCAL [ CAT [ HEAD verb & [ INV +,
                                PRD - ],
                  VAL [ COMPS #comps & < [ NONLOC.SLASH 0-dlist ], ... >,
			SPCMPS < > ],
		  MC na ],
	    ARG-S #comps ] ].

sai_synsem := basic_sai_synsem &
  [ LOCAL.CAT [ HEAD [ AUX +,
		       TAM indic_tam,
		       MOD < [ --MIN no_rel,
			       LOCAL intersective_mod &
				     [ CAT.VAL.SPR *cons* ] ] > ],
		POSTHD + ] ].

; DPF 3-Jul-02 Changed to COMPS..MIN pron_rel from COMPS..ALTMIN no_rel,
; since common nouns are often unmarked for ALTMIN, and it was a hack.
; DPF 19-Oct-02 - Were using hack of SPEC < > to keep poss-pronouns like
; "mine" out of COMPS, but this also blocked "than mine", so instead use
; difference in ALTMIN for "she" and "hers".
; DPF 9-Feb-03 Changed HEAD value from 'verb' to 'tagaux' so bare tag
; questions don't show up as root clauses (we can't just make them MC -,
; since the MC of a head-mod phrase comes from the modifier daughter).
; DPF 20-apr-05 Since we now make lexical NPs by default have an ALTMIN
; of def_q_rel (but don't (yet) for possessive pronouns like 'mine'),
; changed ALTMIN on complement to def_q_rel.

tag_synsem_min := synsem_min.
tag_synsem := lex_synsem & tag_synsem_min &
  [ LOCAL [ CAT [ HEAD tagaux &
		       [ AUX -,
			 INV -,
			 TAM indic_tam &
                             [ TENSE #tense ],
			 MOD < [ --MIN #min,
                                 LOCAL scopal_mod &
				       [ CAT s_cat_fin &
					     [ HEAD.TAM.TENSE #tense,
                                               MC + ],
					 AGR.PNG #png & png,
					 CONT.HOOK.INDEX [ E.TENSE real_tense,
                                                           SF prop ] ],
                                 NONLOC [ SLASH 0-dlist,
                                          REL 0-dlist,
                                          QUE 0-dlist ],
                                 PUNCT.RPUNCT comma_or_no_punct ] >,
                         MINORS.MIN #min ],
		  POSTHD +,
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < [ OPT -,
				  LOCAL [ CAT.HEAD.MINORS 
                                                 [ MIN pron_rel,
                                                   ALTMIN def_q_rel ],
                                          AGR #tagagr ],
                                  --SIND.PNG #png,
                                  PUNCT.RPUNCT clause_or_no_punct & 
                                               [ PSF #sf ] ] >,
			SPCMPS < > ],
                  MC + ],
            CONT.HOOK.INDEX.SF #sf & prop-or-ques,
            AGR #tagagr ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADJECTIVES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (See prep_synsem definition for discussion of ARG1 attribute.)

; Predicative adjectives used to introduce an ARG0 attribute in a separate 
; support relation, as did predicative PPs, but now each introduces its own
; ARG0 attribute directly in the MIN relation.

; Assume that if adjectives have a specifier, it will be either a measure-NP,
; as in "two feet tall', 'a week later"; or a degree_adverb like "very".

; Since most adjectives are underspecified for being predicative, we have to be
; sure that when they act as modifiers, the unexpressed subject's SLASH value 
; gets terminated (given lexical SLASH amalgamation).  We can't just make the
; adjective's SUBJ be 'unexpressed' since it must unify with the real subject
; in a raising construction.  So we identify the SLASH of the MOD value with
; that of the SUBJ - only one of the two will be realized syntactically.

; Most but not all adjectives can be modifiers, so the most basic adj_synsem
; type does not introduce the MOD feature, to allow for adjectives like
; "impossible" as in "it is impossible to find Kim".

;; DPF 3-Feb-01 - Removed SPR..COMPS *olist* to allow for equatives like
;; "as tall as you" where first "as" combines with "tall" and passes up its
;; as-complement.
;; DPF 5-Apr-01 - Added [LPERIPH na] to interact correctly with adj-head rule 
;; and noun-noun-cmpnd rule, to block "*towel rusty rack" - the adj-head rule 
;; makes its LPERIPH value that of the adjunct dtr, and the n-n-cmpnd rule 
;; blocks all but [LPERIPH -] head-dtr.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so adjs can
;; coordinate with VPs (which are necessarily SPR anti_synsem_min).

;; DPF 25-Sep-01 - Added AGR reentrancy with SUBJ's AGR, like with verbs, to
;; make sure modification works right in no_copula constructions as in "skies
;; light becoming dark.  But for now must also hardwire link between SUBJ's
;; AGR and INDEX, since the bare-np rule necessarily breaks this link to get
;; DIV right.  Sigh - this will break a few tag questions, as in
;; "Someone is happy, aren't they?"
;; DPF 14-Oct-03 - Changed LPERIPH value from na to + since we want "same day"
;; to be LPERIPH +, not na.  Needed in particular for tempnp rule as in
;; 'Kim arrived the same day' since it requires the NP to be modified and
;; LPERIPH +.
;; DPF 22-Nov-03 - But now make LPERIPH bool since we need "annual report"
;; to be compatible with LPERIPH na_or_- in order to get "IBM annual report"
;; DPF 24-aug-06 - Moved LPERIPH bool down to subtypes, since want to make
;; comparative "more" be LPERIPH na, to prevent further modification as in
;; "*happy more cats"
;; DPF 2010-08-21 - Added INDEX non_conj_sement to ensure that right-node-raise
;; rule does not apply to non-conjoined adjectives.  (Without this constraint,
;; RNR applied in |sequences are the same in every person|).

basic_adj_synsem_lex_or_phrase := canonical_synsem &
  [ LOCAL [ AGR #agr,
            CAT [ HEAD [ MINORS.MIN basic_adj_rel ],
		  VAL [ SUBJ < >,
			SPCMPS < > ] ],
            CONT.HOOK [ INDEX non_conj_sement,
			XARG #agr ] ] ].

; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).
; DPF 8-Jun-03 -Added SPR..LEX + to block "Kim is as as Sandy tall" but allow
; "Kim is as tall as Sandy"
; DPF 11-Sep-03 - But this prevents measure-phrase specifiers, so remove, and
; look for an alternative to block above.  **FIX**
; DPF 21-oct-03 - Fixed, since MNPs are now LEX +.
; DPF 19-aug-04 - But then we block "the structures forty feet tall" (along
; with "*the structures very tall").  So we'll try making the HS-LEX value
; be constrained by the specifier, and adjust the relevant head_spec rule
; accordingly.
; DPF 03-sept-09 - Added surprising anti_synsem_min to SPR list, since we want
; PPs to modify N-bars (but not NPs) as well as VPs and APs, and this Nbar-NP
; contrast is made by requiring the SPR to be non-empty.  But after an adj
; has picked up a degree specifier, as in "too angry", we have to make sure it
; still has a non-empty SPR, in order to get e.g. "Kim was too angry in Paris"

basic_adj_abstr_lex_synsem := basic_adj_synsem_lex_or_phrase & 
                              abstr_lex_synsem &
  [ LOCAL.CONT.RELS.LIST.FIRST basic_adj_relation ].

basic_adj_lex_synsem := basic_adj_abstr_lex_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
            CAT [ HEAD adj_or_intadj,
                  VAL [ SPR 
                        < #spr & synsem_min &
                          [ --MIN degree_rel,
                            LOCAL
                            [ CAT [ VAL [ SPR *olist*,
                                          SPEC < [ LOCAL.CAT.HS-LEX #hslex ]>],
                                    MC na ],
                              CONT.HOOK.LTOP #ltop ],
                            NONLOC.SLASH 0-dlist,
                            OPT + ],
			  anti_synsem_min &
			  [ --MIN degree_rel ] >,
                        COMPS #comps ],
                  HS-LEX #hslex ],
            CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

basic_adj_synsem := basic_adj_lex_synsem &
  [ MODIFD.LPERIPH bool,
    LOCAL [ CAT [ HEAD adj_or_intadj &
		       [ MINORS.ALTMIN #altmin,
			 TAM #tam ],
		  VAL.SPR.FIRST [ LOCAL.CAT.HEAD.MINORS.ALTMIN #altmin ] ],
	    CONT.HOOK.INDEX.E #tam ] ].

norm_adj_lex_synsem := basic_adj_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_adj,
                  VAL.SPR.FIRST.LOCAL.CONT.HOOK.XARG #arg0 ],
            CONT.HOOK.INDEX #arg0 ],
    LKEYS.KEYREL.ARG0 #arg0 & non_conj_event ].

;; We assume for now, counterfactually, that all modifying adjectives are
;; intersective.

;; ERB (03-02-98) Maybe should add MOD < [ LOCAL.SPR.OPT ] > - to keep 
;; adjectives from modifying partitives.

;; DPF (16-Feb-98) Made XARG be 'ref-ind' rather than non_expl-ind,
;; to ensure that it gets discourse-bound if the adjective is used in a 
;; fragment.

;; DPF (12-Jul-98) Constrain adjectives to only modify nominals with obligatory
;; specifiers (which distinguishes "common" from "proper" nominals).
;; DPF 9-oct-05 - Try constraining the MOD..MIN to nonpro_rel to block
;; modification of number-nouns ("*old one arrives"), analogous to blocking
;; in n-n compounds.
;; DPF 5-oct-06 - But this conflicts now with making 'group' nouns propagate
;; the MIN of their complement's NP.  And the combination of adj+numnoun is
;; not really out: "Unlucky 13 is often avoided".  So let's take the hit in
;; added ambiguity.
;; DPF 31-jul-07 - Removed mysterious [MOD..OPT -], which was surely not right.

adj_synsem_lex_or_phrase := basic_adj_synsem_lex_or_phrase &
  [ LOCAL [ CAT.HEAD.MOD
             < synsem_min &
               [ LOCAL [ CAT [ HEAD basic_nom_or_ttl &
                                    [ POSS - ],
                               VAL [ SUBJ < >,
                                     SPR.FIRST synsem & 
					  [ --MIN quant_or_deg_rel ],
                                     COMPS < > ],
                               MC na ],
                         CONJ cnil ],
                 --SIND #ind ] >,
            CONT.HOOK.XARG #ind ] ].

norm_adj_synsem := adj_synsem_lex_or_phrase &
  [ LOCAL [ CAT.HEAD.TAM #tam,
	    CONT.HOOK [ INDEX.E #tam,
			XARG basic_non_expl ] ] ].

adj_synsem := norm_adj_lex_synsem & norm_adj_synsem & isect_synsem.
adj_onearg_lex_synsem := norm_adj_lex_synsem & isect_synsem & one_arg.
adj_twoarg_lex_synsem := norm_adj_lex_synsem & isect_synsem & two_arg.
basic_adj_onearg_synsem := basic_adj_synsem & one_arg &
  [ LOCAL.CAT [ HEAD adj,
                VAL.COMPS < > ] ].
adj_twoarg_synsem := adj_synsem & two_arg.
; For comparatives and other semantically complex adjectives with new INDEX
adj_unsp_ind_synsem := basic_adj_lex_synsem & lex_synsem & 
                       adj_synsem_lex_or_phrase & isect_synsem &
  [ LOCAL [ CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK.XARG #ind,
	    CONT.HOOK.INDEX #ind ],
    LKEYS.KEYREL.ARG0 #ind ].

adj_unsp_ind_onearg_synsem := adj_unsp_ind_synsem & one_arg &
  [ LOCAL.CAT [ HEAD.MINORS.MIN abstr_adj_rel,
                VAL.COMPS < > ] ].
adj_unsp_ind_twoarg_synsem := adj_unsp_ind_synsem & two_arg.

basic_adj_synsem_constr := norm_adj_synsem &
  [ LOCAL [ CAT [ HEAD adj &
		       [ MOD < synsem &
			       [ LOCAL intersective_mod,
				 NONLOC.REL 0-dlist ] >,
			 MINORS [ MIN norm_adj_rel,
				  NORM norm_rel ] ],
		  VAL [ SPR < [ --MIN more_or_very_deg_rel,
				LOCAL [ CAT.HS-LEX #hslx ],
				LEX + ], anti_synsem_min >,
			SPEC < > ],
		  HS-LEX #hslx ] ],
    NONLOC non-local_none ].

adj_synsem_constr := basic_adj_synsem_constr &
  [ LOCAL [ CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK [ LTOP #hand,
						XARG #index ],
	    CONT [ HOOK [ LTOP #hand,
			  INDEX #index ],
		   RELS.LIST.FIRST.LBL #hand ] ] ].

adj_synsem_lex_constr := basic_adj_synsem_constr & norm_adj_lex_synsem.

adj_synsem_lex_rule := basic_adj_synsem_constr & abstr_lex_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

; 'cat-like', `two-dimensional'
;
adj_synsem_n_spr := basic_adj_abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD adj &
		       [ MOD < synsem &
			       [ LOCAL intersective_mod &
				       [ AGR #ind,
					 CAT [ HEAD basic_nom_or_ttl &
						    [ POSS - ],
					       VAL [ SUBJ < >,
						     SPR < synsem & 
						       [ --MIN 
							 quant_or_deg_rel ] >,
						     COMPS < >,
						     SPCMPS < > ],
					       MC na ] ],
				 NONLOC.REL 0-dlist,
				 --SIND #ind ] >,
			 TAM #tam,
			 MINORS [ MIN norm_adj_rel,
				  NORM norm_rel ] ],
		  VAL [ SPR < [ LOCAL [ CAT [ HEAD noun,
					      VAL [ SPR < synsem_min >,
						    COMPS < > ] ],
					CONT.HOOK [ LTOP #nhand,
						    INDEX #nind ] ],
				PUNCT.RPUNCT hyphen_sgl_or_no_punct,
				MODIFD notmod,
				OPT -,
				LEX + ] >,
			COMPS < >,
			SPEC < > ] ],
	    CONT [ HOOK [ LTOP #hand,
			  INDEX.E #tam,
			  XARG #ind ],
		   RELS <! #keyrel &
			   [ LBL #hand,
			     ARG1 #ind,
			     ARG2 #nind ],
			   #altkeyrel &
			   [ PRED udef_q_rel,
			     ARG0 #nind,
			     RSTR #rhand ] !>,
		   HCONS <! qeq &
                           [ HARG #rhand,
                             LARG #nhand ] !> ] ],
    NONLOC non-local_none,
    MODIFD notmod,
    LKEYS [ KEYREL #keyrel,
	    ALTKEYREL #altkeyrel ] ].

nomod_adj_synsem := norm_adj_lex_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD no_head ] > ].

nonprd_synsem := lex_synsem &
  [ LOCAL.CAT.HEAD.PRD - ].

prd_synsem := lex_synsem &
  [ LOCAL [ CAT.HEAD.PRD + ] ].

intrans_adj_synsem := adj_synsem & one_arg &
  [ LOCAL.CAT [ HEAD.MINORS.MIN abstr_adj_rel,
                VAL.COMPS < > ] ].

basic_attr_adj_synsem := intrans_adj_synsem & nonprd_synsem &
  [ LOCAL.CAT.POSTHD -,
    NONLOC.REL 0-dlist ].

; DPF 27-nov-04 - Block SPR for these, to avoid e.g. "*a very mere child"
attr_adj_synsem := basic_attr_adj_synsem &
  [ LOCAL [ CAT [ HEAD adj & [ MOD < [ --SIND #ind ] > ],
                  VAL.SPR.FIRST anti_synsem_min ],
            CONT.HOOK.XARG #ind ],
    NONLOC.QUE 0-dlist,
    LKEYS.KEYREL.ARG1 #ind & basic_non_expl-ind ].

pred_adj_synsem := adj_unsp_ind_synsem & prd_synsem &
  [ LOCAL [ CAT [ HEAD adj &
                       [ MINORS.ALTMIN #altmin ],
                  VAL.SPR.FIRST [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #altmin,
					  CONT.HOOK.XARG #arg0 ] ],
		  POSTHD + ],
            CONT.HOOK.INDEX #arg0 ],
    MODIFD.LPERIPH bool ].

; Not marked for LEX

intrans_pred_adj_synsem := basic_adj_synsem & one_arg & isect_synsem &
                           norm_adj_synsem &
  [ LOCAL [ CAT [ HEAD adj &
                       [ PRD +,
                         MOD < [ --SIND #ind & non_expl-ind ] >,
                         MINORS.MIN adj_rel ],
                  VAL [ SPR.FIRST.LOCAL [ CAT.HEAD n_or_adv &
                                          [ MINORS.ALTMIN abstr_meas_nom_rel ],
					  CONT.HOOK.XARG #arg0 ],
			COMPS < > ] ],
            CONT [ HOOK [ INDEX #arg0,
			  XARG #ind ],
                   RELS <! adj_relation !> ] ],
    LKEYS.KEYREL [ ARG0 #arg0,
                   ARG1 #ind ] ].

;;; We should have a trans_adj_attr_synsem too, for 'easy' and the likes ...

pred_adj_two_arg_synsem := pred_adj_synsem & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < [ PUNCT.LPUNCT no_punct ] >,
            CONT.HOOK.XARG #ind & basic_non_expl ],
    LKEYS.KEYREL.ARG1 #ind ].

basic_trans_adj_pred_synsem := pred_adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < canonical_or_unexpressed &
			    [ --MIN #cmin,
                              LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil,
				      CONT.HOOK [ LTOP #ltop,
						  INDEX #ind &
							non_expl-ind ] ],
			      PUNCT.LPUNCT no_punct ], ... >,
            CONT.HOOK [ LTOP #ltop,
			XARG #xind & basic_non_expl ] ],
    LKEYS [ KEYREL [ ARG1 #xind,
		     ARG2 #ind ],
            --COMPKEY #cmin ] ].

trans_adj_pred_two_arg_synsem := basic_trans_adj_pred_synsem & adj_synsem &
				 two_arg.
trans_adj_pred_three_arg_synsem := basic_trans_adj_pred_synsem & adj_synsem & 
				   three_arg.

; For adjectives like "accessible (by car)" which take a contentful PP compl.
trans_adj_pp_ind_synsem := pred_adj_two_arg_synsem & adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < canonical_or_unexpressed &
			    [ --MIN #cmin & independent_rel,
                              LOCAL [ CAT basic_pp_cat & [ HEAD.PRD + ],
                                      CONJ cnil,
				      CONT.HOOK [ LTOP #ltop,
                                                  XARG #ind &
                                                        non_expl-ind ] ] ] >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS [ KEYREL.ARG2 #ind,
            --COMPKEY #cmin ] ].

irreg_trans_adj_pred_synsem := pred_adj_two_arg_synsem & adj_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem &
                          [ --MIN nom_rel & #cmin,
                            LOCAL [ CAT np_cat_acc_min,
                                    CONT.HOOK.INDEX non_expl-ind ] ] >,
    LKEYS.--COMPKEY #cmin ].

; 'worth the price'
; <type val="aj_np_i_le">
; <description>Adj, NP comp                     
; <ex>B isn't worth the effort.
; <nex>
; <todo>
; </type>
aj_np_i_le := reg_adj_word &
  [ SYNSEM irreg_trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ --SIND #index & [ SORT entity ],
				       OPT - ] >,
		     CONT.RELS <! [ ARG2 #index ] !> ] ] ].

; "arr.": "Plane arr. 10:40."
; <type val="aj_np_i-unsp_le">
; <description>Adj, NP comp, unspec: |arr.|     
; <ex>Plane arr. 10:40.       
; <nex>
; <todo>
; </type>
aj_np_i-unsp_le := reg_adj_word &
  [ SYNSEM irreg_trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < canonical_or_unexpressed &
				     [ --SIND #index,
				       OPT - ] >,
		     CONT.RELS <! [ ARG2 #index ] !> ] ] ].

; 'how much is it worth?'
; <type val="aj_np_gap_le">
; <description>Adj, only 'worth' with gap       
; <ex>B saw how much it is worth
; <nex>
; <todo>
; </type>
aj_np_gap_le := reg_adj_word &
  [ SYNSEM adj_synsem &
	   [ LOCAL [ CAT [ HEAD.PRD +,
                           VAL.COMPS < > ],
		     CONT [ RELS <! [ ARG2 #index ] !>,
                            HCONS <! !> ] ],
             NONLOC [ SLASH 1-dlist &
                            <! [ CAT np_cat_acc_min &
                                     [ HEAD.MINORS.MIN reg_nom_rel ],
                                 CONT.HOOK.INDEX #index ] !>,
                      REL 0-dlist,
                      QUE 0-dlist ] ] ].

; e.g. 'able' - Can't use equi_intrans_lt since it specifies an arg12_rel, 
; which is incompatible with adj_rel.  

basic_adj_vpcomp_synsem := pred_adj_synsem & basic_inf_or_prp_intrans_subst &
                           basic_two_arg & norm_adj_lex_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN adj_rel,
                VAL.COMPS < canonical_or_unexpressed &
			    [ LOCAL.CAT.VAL.SUBJ < synsem &
						   [ NONLOC.SLASH 0-dlist ] >,
                              OPT -,
                              PUNCT.LPUNCT no_punct ] > ] ].

basic_adj_equi_synsem := basic_adj_vpcomp_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #subjind ] >,
            CONT.HOOK.XARG #subjind & non_expl ],
    LKEYS.KEYREL adj_arg12_relation &
                   [ ARG1 #subjind ] ].

reg_adj_equi_synsem := basic_adj_equi_synsem & basic_inf_intrans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT [ HOOK.LTOP #vhand ] ] >,
            CONT [ RELS <! adj_relation !>,
                   HCONS <! qeq & [ HARG #hand,
                                    LARG #vhand ] !> ] ],
    LKEYS.KEYREL.ARG2 handle & #hand ].

adj_vpcomp_prp_synsem := basic_adj_vpcomp_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.VFORM prp,
                                      CONT.HOOK.LTOP #hand ] ] >,
            CONT [ RELS <! relation !>,
                   HCONS <! qeq & [ HARG #chand,
                                    LARG #hand ] !> ] ],
    LKEYS.KEYREL.ARG2 handle & #chand ].

; 'done working'
adj_equi_prp_synsem := adj_vpcomp_prp_synsem & basic_adj_equi_synsem.

; 'it is worth reading that book'
adj_atrans_prp_synsem := adj_vpcomp_prp_synsem &
  [ LOCAL.CONT.HOOK.XARG it-ind,
    LKEYS.--+ARGIND it-ind ].

adj_ssr_synsem := basic_adj_vpcomp_synsem & basic_inf_intrans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #cltop,
						XARG #subjind ] ] >,
            CONT [ HOOK.XARG #subjind,
		   RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #arg1, LARG #cltop ] !> ] ],
    LKEYS.KEYREL adj_arg1_relation & #keyrel &
                   [ ARG1 #arg1 ] ].

;; DPF 18-jul-10 - Don't want to inherit from prd_synsem, since this prevents
;; e.g |tough problem to solve|.  Likewise for basic_adj_atrans_synsem.  So
;; push this down to subtypes like for |pretty|, which do inherit PRD +.
;;
scoping_adj_synsem := norm_adj_lex_synsem & isect_synsem &
  [ LOCAL.CAT [ HEAD.MINORS [ MIN adj_rel,
                              ALTMIN norm_rel ],
                VAL.KCMP [ PUNCT.LPUNCT no_punct ] ] ].

basic_adj_atrans_synsem := norm_adj_lex_synsem & basic_pp_vp_subst & 
  [ LOCAL 
    [ CAT [ HEAD.MINORS [ MIN adj_rel,
                          ALTMIN norm_rel ],
            VAL [ COMPS < canonical_or_unexpressed &
			  [ --MIN selected_rel & #cmin,
                            LOCAL.CONT.HOOK [ LTOP #ahand,
                                              INDEX #expr & non_expl-ind ] ],
                          #comp & canonical_or_unexpressed &
                          [ LOCAL 
                             [ CAT [ HEAD.VFORM inf_or_prp,
				     VAL.SUBJ < synsem &
						[ NONLOC.SLASH 0-dlist ] > ],
			       CONT.HOOK [ INDEX.E.TENSE no_tense,
					   XARG #expr ] ],
			    PUNCT.LPUNCT no_punct,
                            OPT - ], ...>,
                  KCMP #comp ] ] ],
    LKEYS [ KEYREL it_adj_arg12_relation &
                   [ LBL #ahand,
                     ARG2 #expr ],
            --COMPKEY #cmin ] ].

; DPF 30-aug-04 - Generalize to take either inf or prp VP complements, as in
; 'it is tough climbing that hill' or 'it is tough to climb that hill'
reg_adj_atrans_synsem := basic_adj_atrans_synsem & basic_three_arg &
                         nomod_adj_synsem & prd_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
            CONT [ HOOK [ LTOP #ltop,
                          XARG it-ind ],
                   RELS <! relation !>,
                   HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ] ],
    LKEYS [ KEYREL [ LBL #ltop,
                     ARG1 handle & #arg ],
            --+ARGIND it-ind ] ].

; 'Kim is easy to please'

tough_adj_atrans_synsem := basic_adj_atrans_synsem & basic_pp_inf_subst &
                           scoping_adj_synsem & tough_three_arg &
                           norm_adj_synsem &
  [ LOCAL [ CAT.VAL 
		[ COMPS < synsem,
			  [ LOCAL.CONT.HOOK.LTOP #ltop,
			    NONLOC [ SLASH <! [ CAT np_cat_acc_min &
						    [ HEAD.MOD < > ],
						CONT.HOOK.INDEX #slind ] !>,
				     QUE 0-dlist ] ] >,
		  SPR.FIRST.LOCAL.CONT.HOOK.XARG #arg0 ],
	    CONT [ HOOK [ INDEX #arg0,
                          XARG #slind & basic_non_expl-ind ],
                   RELS <! relation & [ ARG1 #arg ] !>,
                   HCONS <! qeq & [ HARG #arg, LARG #ltop ] !> ] ],
    LKEYS.--COMPKEY _for_p_sel_rel ].

; 'Kim is worth admiring.'
worth_adj_atrans_synsem := basic_inf_or_prp_intrans_subst & isect_synsem &
                           worth_two_arg & norm_adj_synsem &
                           basic_adj_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN adj_rel,
                  VAL [ COMPS < [ LOCAL [ CAT [ HEAD.VFORM prp,
                                                VAL.SUBJ 
                                                < synsem &
						  [ NONLOC.SLASH 0-dlist ] > ],
                                          CONT.HOOK [ LTOP #ltop,
                                                      INDEX event &
                                                       [ E.TENSE no_tense,
                                                         SF prop-or-ques ] ] ],
                                  NONLOC.SLASH 
                                        <! [ CAT np_cat_acc_min &
                                                 [ HEAD.MOD < > ],
                                             CONT.HOOK.INDEX #slind ] !>,
                                  PUNCT.LPUNCT no_punct,
                                  OPT - ] >,
                        SPR.FIRST.LOCAL.CONT.HOOK.XARG #event ] ],
	    CONT [ HOOK.XARG #slind & ref-ind,
                   RELS <! relation & #keyrel & [ ARG1 #mlbl,
                                                  ARG0 #event ] !>,
                   HCONS <! qeq & [ HARG #mlbl,
                                    LARG #ltop ] !> ] ],
    LKEYS.KEYREL #keyrel ].

;; DPF (9-Mar-99) It appears that there are no CP-taking adjectives which 
;; select for a 'like-CP' of the kind some verbs take (e.g. 'It sounds like
;; Kim will leave').  So we constrain the KCMP to be prop-or-ques_m_rel.
;; But there are adjectives (like 'doubtful, unclear, unsure') which can take 
;; a whether-CP, so we introduce a subtype of reg_adj_cp_synsem for those that 
;; only take a 'that-CP', and similarly for expletive-it subject-taking 
;; adjectives.
;;
; 'uncertain': '?Kim is uncertain that Sandy left' 
;              'Kim is uncertain whether Sandy left' 
;              'It is uncertain that Sandy left'
;              'It is uncertain whether Sandy left'
;; DPF 2012-05-31 - It appears that S complements of adjectives cannot be
;; extracted, so we want to block that extraction.  See e.g. |*They lost he 
;; was sad|.  But since we treat "intraposition" via extraction, as in
;; |That kim won was obvious|, we want to block extraction for S but not
;; for CP.  Rather than duplicating lexical entries for S-or-CP-taking
;; adjectives, we constrain the type of the SLASH list to only allow CPs.
;;
basic_adj_cp_synsem := scoping_adj_synsem & basic_two_arg & prd_synsem &
		       cp_addin_tam_pn &
  [ LOCAL [ CAT.VAL [ COMPS < synsem & #comp &
                              [ LOCAL
                               [ CAT s_cat_v_c,
                                 CONJ cnil,
                                 CONT.HOOK.INDEX.SF prop-or-ques ],
				NONLOC.SLASH.LIST *cplist* ] >,
		      KCMP #comp ],
	    CONT.RELS <! relation !> ] ].

adj_cp_fin_inf_synsem := basic_adj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_or_inf_v_c ] > ].

; 'unclear' '*Kim is unclear that/whether Sandy left'
;           'It is unclear that Sandy left'
;           'It is unclear whether Sandy left'
; DPF 10-jul-04 - FIX -- Why is the ARG1 constrainted to PNG.PN 3s?  
; Shouldn't that ARG1 be for an optional (experiencer) to-PP (not yet
; provided)?
; DPF 21-dec-05 - Removed CAT.HEAD comp to allow "it's obvious why we did it"

adj_atrans_cp_fin_inf_synsem := adj_cp_fin_inf_synsem & nomod_adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
            CONT [ HOOK.XARG it-ind,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ] ],
    LKEYS [ KEYREL it_adj_arg1_relation & [ ARG1 handle & #arg ],
            --+ARGIND it-ind ] ].

; 'imperative': 'it is imperative that you be here'
adj_atrans_bse_cp_synsem := basic_adj_cp_synsem & nomod_adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT s_cat_bse,
                                      CONT.HOOK.LTOP #chand ] ] >,
            CONT [ HOOK.XARG it-ind,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ] ],
    LKEYS [ KEYREL it_adj_arg1_relation & [ ARG1 handle & #arg ],
            --+ARGIND it-ind ] ].

reg_adj_cp_synsem := adj_cp_fin_inf_synsem & adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
	    CONT.HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ],
    LKEYS.KEYREL [ ARG1 non_expl,
                   ARG2 handle & #arg ] ].

; 'afraid'  'Kim is afraid that Sandy left'
;           '*Kim is afraid whether Sandy left'
;           '*It is afraid that/whether Sandy left'
reg_adj_that_cp_synsem := reg_adj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    CONT.HOOK.INDEX.SF basic-prop ] ] > ].

; 'obvious' '*Kim is obvious that/whether Sandy left'
;           'It is obvious that Sandy left'
;           '*It is obvious whether Sandy left'
;   but cf. 'It is not obvious whether Sandy left' ***Needs fixing***

adj_atrans_that_cp_synsem := adj_atrans_cp_fin_inf_synsem &
  [ LOCAL.CAT.VAL.KCMP.LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    CONT.HOOK.INDEX.SF basic-prop ] ].

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking of "more many"
;; DPF 2011-08-15 - Tried adding SPEC < > to stop positive adjs from undergoing
;; partitive_intadj rule, which should only apply to comparatives and
;; superlatives.  (Now that we use ALTMIN to distinguish morphological -er
;; adjectives fromo more+adj ones, that way of distinguishing comp/superl
;; from positive adjs no long serves.)  But, SPEC is passed from hd-dtr to
;; mother in head-spec rule, so |most beautiful| has same SPEC as |beautiful|,
;; which blocks |the most beautiful|, sadly.  
;;
norm_adj_word := nonc-hm-nab &
  [ SYNSEM [ LOCAL.CAT [ HEAD adj & [ MINORS.ALTMIN non_ellipt_rel ],
			 VAL.SPR.FIRST synsem &
			      [ --MIN more_or_very_deg_rel,
				LOCAL.CAT.HS-LEX #hslex ],
			 HS-LEX #hslex ],
	     MODIFD notmod ] ].

; DPF 25-may-09 - Tried adding MOD..LPERIPH - to block "the tall many cats"
; but proper names are LPERIPH +, so this hack doesn't work.
reg_adj_word := norm_adj_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT.HEAD [ MOD < [ --SIND #ind ] >,
                                MINORS.MIN adj_rel ],
                     CONT [ HOOK [ INDEX.SORT basic-entity-or-event,
				   XARG #ind ],
                            RELS <! adj_relation !> ] ],
             LKEYS.KEYREL.ARG1 #ind & non_event ] ].

reg_intrans_adj := reg_adj_word & 
  [ SYNSEM intrans_adj_synsem ].

; DPF 2010-09-20 - Removed LPERIPH -, since it blocks "big dog Fido", and
; since we independently block "big many cats" now.
;
; <type val="aj_-_i_le">
; <description>Adj (intersective), no comp      
; <ex>The beautiful dog won.
; <nex>
; <todo>
; </type>
aj_-_i_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

; <type val="aj_-_i-er_le">
; <description>Adj (intersective), no comp, only -er comparative
; <ex>The big dog won.
; <nex>
; <todo>
; </type>
aj_-_i-er_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS [ MIN norm_adj_rel,
				   ALTMIN comp_er_rel ] ].

; <type val="aj_-_i-unsp_le">
; <description>Adj, no constraint on LPERIPH
; <ex>B slept the whole afternoon.
; <nex>
; <todo>
; </type>
aj_-_i-unsp_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

; DPF 21-oct-09 - Removed LPERIPH -, since it blocks "He arrived the next day"
;
; <type val="aj_-_i-oblsp_le">
; <description>Adj (intersective), no comp, requires spr for modified N
; <ex>The next dog won.
; <nex> *Next dogs won.
; <todo>
; </type>
aj_-_i-oblsp_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT [ HEAD 
		       [ MINORS.MIN norm_adj_rel,
			 MOD.FIRST.LOCAL.CAT.VAL.SPR < expressed_synsem > ],
		       POSTHD - ] ].

; <type val="aj_-_i-nopn_le">
; <description>Adj (intersective), no comp, no mod of proper NPs
; <ex>We respond with all due respect.
; <nex>The due 1998 arrived.
; <todo>
; </type>
aj_-_i-nopn_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ --MIN norm_nom_rel ] >,
			    MINORS.MIN norm_adj_rel ] ].

aj_-_i-color_lexent := norm_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN color_rel,
		     CONT [ HOOK.XARG #ind,
			    RELS <! relation !> ] ],
             LKEYS.KEYREL.ARG1 #ind & basic_non_expl-ind ] ].

; <type val="aj_-_i-color_le">
; <description>Adj, color                       
; <ex>The cat is gray.
; <nex>
; <todo>
; </type>
aj_-_i-color_le := aj_-_i-color_lexent.

; <type val="aj_-_i-color-er_le">
; <description>Adj, color, only -er comparative
; <ex>The cat is gray.
; <nex>
; <todo>
; </type>
aj_-_i-color-er_le := aj_-_i-color_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN comp_er_rel ].

; For adjs like 'far' which don't get used as depictives: 
; constrain NORM to be norm_rel (hack).
; DPF 27-jan-08 - But this prevents coordination with ordinary adjectives
; like "pleasant but far from ...".  So live with ambiguity of e.g.
; "Kim lived far from the city."

; <type val="aj_-_i-ndpt_le">
; <description>Adj, not depictive               
; <ex>B swam to the far shore.
; <nex>
; <todo>
; </type>
aj_-_i-ndpt_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS [ MIN norm_adj_rel,
				   NORM no_rel ] ].


; only: 'his only books'
; <type val="aj_-_i-only_le">
; <description>Adj, 'only', not pred., allows n-adj compound 'residents-only'
; <ex>B's only dog won.
; <nex>
; <todo>
; </type>
aj_-_i-only_le := reg_intrans_adj &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN norm_adj_rel,
				     NORM no_rel ],
	     MODIFD.LPERIPH + ] ].

; own: 'his own books'
; <type val="aj_-_i-poss_le">
; <description>Adj, only 'own'                  
; <ex>B's own dog won.
; <nex>
; <todo>
; </type>
aj_-_i-poss_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD 
     [ MINORS.MIN norm_adj_rel,
       PRD -,
       MOD < [ LOCAL.CAT.VAL.SPR < [ --MIN explicit_q_rel,
				     LOCAL.CAT.HEAD.POSS + ] > ] > ] ].

; Not bare adj-noun : 
;   *we arrived last weeks
;   'many chairs' - avoid spurious ambig with determiner 'many'
;; DPF 2012-02-01 - Added NORM no_rel to prevent these from appearing as
;; subord modifiers (spurious ambiguity): |he arrived last.|

adj_intrans_notb_lexent := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD 
     [ MINORS [ MIN norm_adj_rel,
		NORM no_rel ],
       MOD < [ LOCAL.CAT.VAL.SPR.FIRST.--MIN explicit_q_rel ] > ] ].

; <type val="aj_-_i-spn_le">
; <description>Adj, mod nouns w/explicit spr    
; <ex>The last dog won.
; <nex>
; <todo>
; </type>
aj_-_i-spn_le := adj_intrans_notb_lexent.

; <type val="aj_-_i-spn-att_le">
; <description>Adj, attrib, mod n w/expl spr    
; <ex>That very dog won.
; <nex>
; <todo>
; </type>
aj_-_i-spn-att_le := adj_intrans_notb_lexent &
  [ SYNSEM basic_attr_adj_synsem ].

; 'many/much' - allows QUE specifier ('how many')
; DPF 12-jul-06 - Added LPERIPH + to block e.g. "*the tall many chairs"
; DPF 16-apr-11 - Making these [PRD -] blocks e.g. |this many|, |this much|.
; So change SYNSEM from basic_attr_adj_synsem to intrans_adj_synsem and
; add POSTHD -, to still block *|cats many|.
adj_attr_intrans_que_lexent := nonc-hm-nab &
  [ SYNSEM intrans_adj_synsem &
    [ LOCAL [ CAT [ HEAD compar_adj &
                         [ MOD < [ --SIND #ind ] >,
                           MINORS.MIN meas_adj_rel ],
		    POSTHD -,
                    VAL.SPR.FIRST synsem &
			 [ --MIN very_this_that_rel ] ],
	      CONT [ HOOK.XARG #ind,
                     RELS <! adj_relation !> ] ],
      MODIFD notmod & [ LPERIPH + ],
      NONLOC.REL 0-dlist,
      LKEYS.KEYREL [ ARG1 #ind & non_event ] ] ].

; 'many, few'
; DPF 28-mar-10 - Constrain LPERIPH to block spurious "many more cats"
; <type val="aj_-_i-many_le">
; <description>Adj, only 'many'                 
; <ex>Many dogs ran.
; <nex>
; <todo>
; </type>
aj_-_i-many_le := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ AGR.PNG.PN 3p,
                                          CONT.HOOK.INDEX.IND + ],
				  MODIFD.LPERIPH - ] > ].

; 'much, little'
; <type val="aj_-_i-much_le">
; <description>Adj, only 'much'                 
; <ex>B didn't win much money.
; <nex>
; <todo>
; </type>
aj_-_i-much_le := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR [ PNG.PN 3s,
                                              DIV + ] ] > ].

; 'several, a few': exclude QUE specifier
; DPF 3-May-08 - Add MOD..NORM norm_rel to block "a few cat" from being
; left member of n-n-cmpnd.

; <type val="aj_-_i-svrl_le">
; <description>Adj, vague number                
; <ex>Our several cats fell.
; <nex>
; <todo>
; </type>
aj_-_i-svrl_le := adj_attr_intrans_que_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ LOCAL [ AGR.PNG.PN 3p,
					    CAT.HEAD.MINORS 
						     [ ALTMIN def_or_udef_q_rel,
						       NORM norm_rel ],
					    CONT.HOOK.INDEX.IND + ] ] >,
	     NONLOC.QUE 0-dlist ] ].

; 'not many' - Can't easily do this compositionally since 'not + Adj' usually
; holds only for predicative adjectives: "kim is occasionally not clever" but
; "*The not clever consultant".  We now treat 'many' as sitting in the
; syntactic position of an attributive adjective, yet it can appear with a
; 'not' modifier.  So we'll treat it for now as a multi-word.
; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"

attr_adj_onearg_synsem := norm_adj_synsem & basic_one_arg & 
                          basic_adj_synsem & nonprd_synsem &
  [ LOCAL.CAT [ HEAD adj & [ MINORS.MIN norm_adj_rel ],
                POSTHD -,
                VAL [ SPR.FIRST synsem &
				[ --MIN more_or_very_deg_rel,
				  LOCAL.CAT.HS-LEX #hslex ],
		      COMPS < > ],
                HS-LEX #hslex ],
    NONLOC.REL 0-dlist ].

; <type val="aj_-_i-mneg_le">
; <description>Adj, only 'not many/not much'    
; <ex>Not many dogs ran.
; <nex>
; <todo>
; </type>
aj_-_i-mneg_le := norm_adj_word &
  [ SYNSEM attr_adj_onearg_synsem &
           [ LOCAL [ CAT.HEAD.MOD 
                           < [ LOCAL 
                               [ CAT.VAL.SPR < [ LOCAL.CONT.HOOK.LTOP #lbl ] >,
                                 CONT.HOOK [ LTOP #albl,
                                             INDEX #ind ] ] ] >,
                     CONT [ HOOK [ LTOP #albl,
                                   XARG #ind ],
                            RELS <! [LBL #albl,
                                      PRED much-many_a_rel ], 
				    #altkeyrel &
                                    [ LBL #lbl,
                                      PRED neg_rel,
                                      ARG0.E.TENSE no_tense ] !>,
                            HCONS <! !> ] ],
             LKEYS [ KEYREL.ARG1 #ind & non_event,
		     ALTKEYREL #altkeyrel ] ] ].

; <type val="aj_-_i-att_le">
; <description>Adj, attributive                 
; <ex>The inner ring is small.
; <nex>
; <todo>
; </type>
aj_-_i-att_le := reg_adj_word &
  [ SYNSEM basic_attr_adj_synsem ].

; <type val="aj_-_i-att-er_le">
; <description>Adj, attributive, only -er comparative
; <ex>The early ring is small.
; <nex>
; <todo>
; </type>
aj_-_i-att-er_le := reg_adj_word &
  [ SYNSEM basic_attr_adj_synsem &
	   [ LOCAL.CAT.HEAD.MINORS.ALTMIN comp_er_rel ] ].

; <type val="aj_-_i-att-nsp_le">
; <description>Adj, attrib, no specifier        
; <ex>A mere beginner won.
; <nex>
; <todo>
; </type>
; DPF 25-may-09 - Added LPERIPH bool to block "Kim other gems"
;; DPF 2012-03-13 - Added NORM no_rel to block |these cat and other dogs|
;; DPF 2012-12-14 - Constrain MINORS.MIN to norm_adj_rel to prevent unif with
;; selected_adj_rels.
;;
aj_-_i-att-nsp_le := nonc-hm-nab &
  [ SYNSEM attr_adj_synsem &
           [ LOCAL [ CAT [ HEAD adj &
				[ MINORS [ MIN norm_adj_rel,
					   NORM no_rel ] ],
                           VAL.SPEC < > ],
                     CONT.RELS <! adj_relation !> ],
	     MODIFD notmod & [ LPERIPH bool ] ] ].

; <type val="aj_-_i-att-pn_le">
; <description>Adj, attributive, only modifies proper names: for deverbal adjectives that overcome reluctance to have passive participles modify unspecified proper names.
; <ex>They acquired closely held Compaq.
; <nex>
; <todo>
; </type>
aj_-_i-att-pn_le := reg_adj_word &
  [ SYNSEM basic_attr_adj_synsem & 
	   [ LOCAL.CAT.HEAD.MOD < [ --MIN named_np_or_num_rel,
				    LOCAL.CAT.VAL.SPR.FIRST unexpressed ] > ] ].

; <type val="aj_-_i-prd_le">
; <description>Adj, predicative                 
; <ex>C is awake.
; <nex>
; <todo>
; </type>
aj_-_i-prd_le := norm_adj_word &
  [ SYNSEM intrans_pred_adj_synsem &
	      [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ],
    ALTS.ATTRJ - ].

; nuts: only complement of copula, or depictive.
; <type val="aj_-_i-prd-nmd_le">
; <description>Adj, pred, cannot modify         
; <ex>C is nuts.
; <nex>
; <todo>
; </type>
aj_-_i-prd-nmd_le := norm_adj_word &
  [ SYNSEM intrans_pred_adj_synsem & 
              [ LOCAL.CAT [ HEAD [ MINORS.MIN norm_adj_rel,
                                   MOD < anti_synsem_min > ],
                            POSTHD + ] ] ].

; 'else': not even as depictive
;; DPF 2012-11-09 - Added OPT - to prevent these from appearing as depictives,
;; since we can't use NORM no_rel, since the ordinary copula wants norm_rel
;; for its complement, and we want |that was so| where `so' the adjective
;; meaning `true' is also of this type.
;;
; <type val="aj_-_i-prd-ndpt_le">
; <description>Adj, pred, no mod incl depictve  
; <ex>The race is over with.
; <nex>
; <todo>
; </type>
aj_-_i-prd-ndpt_le := nonc-hm-nab &
  [ SYNSEM basic_adj_abstr_lex_synsem &
           [ LOCAL [ CAT [ HEAD adj &
                                [ PRD +,
                                  MINORS [ MIN norm_adj_rel,
					   NORM norm_rel ],
				  TAM #tam,
                                  MOD < anti_synsem_min &
					[ --SIND event ] > ],
                           VAL [ SPR.FIRST anti_synsem_min,
                                 COMPS < > ],
                           POSTHD + ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #arg0 & [ E #tam ],
                                   XARG #xarg ],
                            RELS <! #keyrel & adj_relation !>,
			    HCONS <! !> ] ],
             NONLOC non-local_none,
	     OPT -,
             MODIFD notmod & [ LPERIPH bool ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
				      ARG0 #arg0,
				      ARG1 #xarg & non_expl-ind ] ] ].

intrans_adj_oddsem := noncqrs-hm-nab &
  [ SYNSEM intrans_adj_synsem &
           [ LOCAL [ CAT [ POSTHD -,
                           HEAD.MINORS.MIN norm_adj_rel ],
                     CONT.HOOK [ LTOP #ltop,
                                 XARG #ind ] ],
             LKEYS.KEYREL [ LBL #ltop,
                            ARG1 #ind ],
	     MODIFD notmod ] ].

; DPF 10-Jun-03 - Added MOD..HEAD no_head to prevent these from appearing as
; modifiers. They have to be MOD nonempty in order to combine with the copula, 
; and in fact MOD < synsem> to combine with base form "be".
; <type val="aj_-_i-wthr_le">
; <description>Adj, weather, expl it subj       
; <ex>It is cloudy.
; <nex>
; <todo>
; </type>
aj_-_i-wthr_le := norm_adj_word &
  [ SYNSEM adj_onearg_lex_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < synsem & [ LOCAL.CAT.HEAD no_head ] >,
                                  MINORS.MIN expl_adj_rel ],
                           VAL.COMPS < > ],
                     CONT [ HOOK.XARG it-ind,
                            RELS <! relation !> ] ],
             NONLOC non-local_none,
             LKEYS.--+ARGIND it-ind ] ].

; <type val="aj_pp_i-time_le">
; <description>Adj, only 'time', expl it subj   
; <ex>It is time for the race.
; <nex>
; <todo>
; </type>
aj_pp_i-time_le := norm_adj_word &
  [ SYNSEM adj_twoarg_lex_synsem &
    [ LOCAL [ CAT [ HEAD [ MOD < synsem & [ LOCAL.CAT.HEAD no_head ] >,
                           MINORS.MIN expl_adj_rel ],
                    VAL.COMPS < canonical_or_unexpressed &
				[ --MIN selected_rel & #cmin,
                                  LOCAL [ CAT basic_pp_cat,
                                          CONT.HOOK.INDEX #ind &
                                              non_expl-ind,
                                          CONJ cnil ],
                                  NONLOC.SLASH 0-dlist,
                                  OPT - ] > ],
              CONT [ HOOK.XARG it-ind,
                     RELS <! relation & [ ARG1 #ind ] !> ] ],
      NONLOC non-local_none,
      LKEYS [ --COMPKEY #cmin,
              --+ARGIND it-ind ] ] ].

;; doctor's appointment
; <type val="aj_-_i-cmpd_le">
; <description>Adj, human poss cmpnd            
; <ex>The doctor's office called
; <nex>
; <todo>
; </type>
aj_-_i-cmpd_le := intrans_adj_oddsem &
  [ SYNSEM attr_adj_synsem &
	 [ LOCAL 
	   [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                INDEX #nind & non_expl-ind]] >,
             CONT [ HOOK.LTOP #hand,
		    RELS <! relation & [ ARG1 #aind ],
			    #altkeyrel &
                            prep_notense_relation &
                            [ LBL #hand,
                              PRED compound_rel,
                              ARG1 #nind,
                              ARG2 #aind ] !> ] ],
	   LKEYS.ALTKEYREL #altkeyrel ] ].

;; {OPT +] is on reg_trans_adj and not on trans_adj_synsem because the 
;; comparison_lr uses trans_adj_synsem and requires OPT -. Same for semantics.

adj_trans_lexent := reg_adj_word &
  [ SYNSEM trans_adj_pred_two_arg_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [] >,
		     CONT.RELS <! relation !> ] ] ].

; <type val="aj_pp_i_le">
; <description>Adj, pp comp w/sem empty prep    
; <ex>B is sure of C.
; <nex>
; <todo>
; </type>
aj_pp_i_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

; <type val="aj_pp_i-er_le">
; <description>Adj, pp comp w/sem empty prep, only -er comparative
; <ex>B is sure of C.
; <nex>
; <todo>
; </type>
aj_pp_i-er_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS [ MIN norm_adj_rel,
				   ALTMIN comp_er_rel ] ].

; <type val="aj_pp_i-prd_le">
; <description>Adj, predicative, pp comp        
; <ex>B is akin to C.
; <nex>
; <todo>
; </type>
aj_pp_i-prd_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD +,
                            MINORS.MIN norm_adj_rel ],
    ALTS.ATTRJ - ].

; <type val="aj_pp_i-obl_le">
; <description>Adj, oblig pp comp               
; <ex>B is flush with cash.
; <nex>
; <todo>
; </type>
aj_pp_i-obl_le := adj_trans_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ] ].

; <type val="aj_pp_i-obl-er_le">
; <description>Adj, oblig pp comp, only -er comparative
; <ex>B is good at games.
; <nex>
; <todo>
; </type>
aj_pp_i-obl-er_le := adj_trans_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ] ].

; <type val="aj_pp_i-ind_le">
; <description>Adj, pp comp w/sem-cont PP       
; <ex>B is accessible by foot.
; <nex>
; <todo>
; </type>
aj_pp_i-ind_le := reg_adj_word &
  [ SYNSEM trans_adj_pp_ind_synsem &
           [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !> ] ] ] ].

adj_reg_equi_lexent := nonc-hm-nab &
  [ SYNSEM reg_adj_equi_synsem & 
           [ LOCAL.CAT [ HEAD adj,
                         VAL.SPR.FIRST synsem &
			      [ --MIN more_or_very_deg_rel,
				LOCAL.CAT.HS-LEX #hslex ],
                         HS-LEX #hslex ],
	     MODIFD notmod ] ].

; <type val="aj_vp_i-seq_le">
; <description>Adj, vp comp, subj equi          
; <ex>B is eager to win.
; <nex>
; <todo>
; </type>
aj_vp_i-seq_le := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

; For e.g. "supposed to"
; <type val="aj_vp_i-seq-nmd_le">
; <description>Adj, vp comp, sequi, no modify   
; <ex>B is supposed to win.
; <nex>
; <todo>
; </type>
aj_vp_i-seq-nmd_le := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    MOD < anti_synsem > ] ].

; <type val="aj_vp_i-seq-prp_le">
; <description>Adj, vp comp pr-part, sequi      
; <ex>B is done running.
; <nex>
; <todo>
; </type>
aj_vp_i-seq-prp_le := norm_adj_word &
  [ SYNSEM adj_equi_prp_synsem & [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ] ].

; <type val="aj_pp-vp_i-it_le">
; <description>Adj, opt PP, VP comps, it-subj   
; <ex>It is easy for B to win.
; <nex>
; <todo>
; </type>
aj_pp-vp_i-it_le := norm_adj_word &
  [ SYNSEM reg_adj_atrans_synsem &
           [ LKEYS.--COMPKEY _for_p_sel_rel ] ].

; incumbent on X
; <type val="aj_pp-vp_i-on-it_le">
; <description>Adj, opt PP-on, VP comps, it-sbj 
; <ex>It's incumbent on B to go.
; <nex>
; <todo>
; </type>
aj_pp-vp_i-on-it_le := norm_adj_word &
  [ SYNSEM reg_adj_atrans_synsem &
           [ LKEYS.--COMPKEY _on_p_sel_rel ] ].

; it is nice of X to Y
; <type val="aj_pp-vp_i-of-it_le">
; <description>Adj, PP-of, VP comp, it-sbj 
; <ex>It's nice of B to go.
; <nex>
; <todo>
; </type>
aj_pp-vp_i-of-it_le := norm_adj_word &
  [ SYNSEM reg_adj_atrans_synsem &
           [ LOCAL.CAT.VAL.COMPS.FIRST.OPT -,
	     LKEYS.--COMPKEY _of_p_sel_rel ] ].

; 'it is worth reading that book.'
; <type val="aj_vp_i-it-prp_le">
; <description>Adj, vp comp it-subj, presprt    
; <ex>B is worth following.
; <nex>
; <todo>
; </type>
aj_vp_i-it-prp_le := norm_adj_word &
  [ SYNSEM adj_atrans_prp_synsem ].

; <type val="aj_vp_i-ssr_le">
; <description>Adj, vp comp, raising, 
; <ex>There are destined to be unicorns in the garden.
; <nex>
; <todo>
; </type>
aj_vp_i-ssr_le := norm_adj_word &
  [ SYNSEM adj_ssr_synsem ].

reg_adj_atrans_cp_word := norm_adj_word &
  [ SYNSEM adj_atrans_cp_fin_inf_synsem ].

; <type val="aj_pp-cp_i-it_le">
; <description>Adj, opt PP, CP comps, it-subj   
; <ex>It is possible B won.
; <nex>
; <todo>
; </type>
aj_pp-cp_i-it_le := reg_adj_atrans_cp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

; <type val="aj_pp-cp_i-it-c_le">
; <description>Adj, PP, CP w/obl cmpzr, it-sbj  
; <ex>It is odd that B won.
; <nex>
; <todo>
; </type>
aj_pp-cp_i-it-c_le := reg_adj_atrans_cp_word &
  [ SYNSEM adj_atrans_that_cp_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

; <type val="aj_pp-vp_i-tgh_le">
; <description>Adj, PP, VP/NP, it-subj          
; <ex>The race is tough to win.
; <nex>
; <todo>
; </type>
aj_pp-vp_i-tgh_le := norm_adj_word &
  [ SYNSEM tough_adj_atrans_synsem ].

; <type val="aj_vp_i-wrth_le">
; <description>Adj, only 'worth'                
; <ex>The race is worth winning.
; <nex>
; <todo>
; </type>
aj_vp_i-wrth_le := norm_adj_word &
  [ SYNSEM worth_adj_atrans_synsem ].

reg_adj_cp_word := norm_adj_word &
  [ SYNSEM reg_adj_cp_synsem &
	   [ LOCAL.CONT.HOOK.XARG #ind,
             LKEYS.KEYREL.ARG1 #ind ] ].

; <type val="aj_cp_i_le">
; <description>Adj, fin/inf CP comp             
; <ex>B is sure C won.
; <nex>
; <todo>
; </type>
aj_cp_i_le := reg_adj_cp_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
		       VAL.COMPS < [ OPT - ] > ] ].

; <type val="aj_cp_i-fin_le">
; <description>Adj, fin CP comp                 
; <ex>B is aware C won.
; <nex>
; <todo>
; </type>
aj_cp_i-fin_le := reg_adj_cp_word &
  [ SYNSEM reg_adj_that_cp_synsem &
           [ LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
			 VAL.COMPS < [ OPT - ] > ] ] ].

; <type val="aj_cp_i-bse_le">
; <description>Adj, base-form CP comp, it-sbj   
; <ex>It's imperative that C win
; <nex>
; <todo>
; </type>
aj_cp_i-bse_le := norm_adj_word &
  [ SYNSEM adj_atrans_bse_cp_synsem ].

; How is Sandy?  How does Tuesday look?
; We adopt the following second-order quantification semantics for these:
;    which (p, property(p), look_seem(proposition_to_property(adj(x),p)))
; where we exploit a type-shifting relation to change the proposition "adj(x)"
; into the associated property "the set of entities of which adj(x) is true",
; so the "which" operator can quantify over that property.
; DPF 14-Apr-00 - Changed SUBJ.CAT from nomp_cat_nom_min to nomp_cat_min
; since [CASE nom] conflicts with the CASE hack on pro_ss to prevent the
; latter from undergoing subject xxtraction (see ERB notes for pro_ss).

; <type val="aj_-_i-wh_le">
; <description>Adj, only 'how'                  
; <ex>B sees how C feels.
; <nex>
; <todo>
; </type>
aj_-_i-wh_le := noncrs-m-nab &
  [ SYNSEM lex_synsem &
      [ LOCAL [ ARG-S < >,
		CAT [ POSTHD +,
		      HEAD adj & [ MOD < synsem &
					 [ LOCAL intersective_mod &
                                                 [ CAT nbar_cat_min,
                                                   CONJ cnil ],
                                           --SIND #ind & non_expl-ind ] >,
                                   MINORS [ MIN adj_abstract_rel,
					    ALTMIN no_rel ] ],
		      VAL [ SPR < >,
			    COMPS < > ] ],
		CONT [ HOOK [ LTOP #ltop,
                              INDEX #arg0,
                              XARG #ind ],
		       RELS <! [ LBL #ahand,
                                 PRED unspec_adj_rel,
				 ARG0 #arg0,
                                 ARG1 #ind,
				 CFROM #from,
				 CTO #to ],
			       #altkeyrel &
			        [ PRED which_q_rel,
                                  ARG0 #pind,
                                  RSTR #hand ],
			       #alt2keyrel &
			        [ LBL #hand,
                                  PRED property_rel,
                                  ARG0 #pind ],
			        prpstn_to_prop_relation & #keyrel &
			        [ LBL #ltop,
				  ARG1 handle & #ahand,
				  ARG2 #pind,
				  CFROM #from,
				  CTO #to ] !>,
		       HCONS <! !> ] ],
        LKEYS [ KEYREL #keyrel,
		ALTKEYREL #altkeyrel,
		ALT2KEYREL #alt2keyrel ],
	MODIFD notmod,
	NONLOC.QUE 1-dlist &
	           [ LIST < param > ] ] ].

; "cat-like"
; DPF 09-dec-08 - Would like to restrict spr to be non-inflected, but not
; currently possible.  So at least constrain to singular, to avoid spurious
; '*cats-like'.
; DPF 2010-09-17 - Re 09-dec-09: Here as well, use the dastardly combination 
; of PN 3p, DIV - to effect uninflected.  Hack.
;; DPF 2012-10-24 - Re 2010-09-17: and unfortunately, one that prevents mass
;; nouns as left members, as in |lumber-like|.  So modify the hack to use
;; [LOCAL noninfl_noun_local] instead.
;
; <type val="aj_-_i-nspr_le">
; <description>Adj, with noun specifier         
; <ex>The cat-like kid won.
; <nex>
; <todo>
; </type>
aj_-_i-nspr_le := nonc-hm-nab &
  [ SYNSEM adj_synsem_n_spr &
	   [ LOCAL.CAT.VAL.SPR.FIRST [ --MIN nonpro_rel,
				       LOCAL noninfl_noun_local &
					     [ CAT.VAL.SPR.FIRST synsem & 
								 [ OPT - ] ],
				       MODIFD notmod ] ] ].
#|
; <type val="aj_-_i-mn-spr_le">
; <description>Adj, with measure_noun specifier         
; <ex>The $10-a-share price rose. (|-a- share|)
; <nex>
; <todo>
; </type>
aj_-_i-mn-spr_le := nonc-hm-nab &
  [ SYNSEM adj_synsem_n_spr &
	   [ LOCAL.CAT.VAL.SPR.FIRST.--MIN meas_nom_rel ] ].
|#

; "2-dimensional"
; <type val="aj_-_i-numspr_le">
; <description>Adj, with noun specifier         
; <ex>The cat-like kid won.
; <nex>
; <todo>
; </type>
aj_-_i-numspr_le := nonc-hm-nab &
  [ SYNSEM adj_synsem_n_spr &
	   [ LOCAL.CAT.VAL.SPR.FIRST [ --MIN named_num_rel,
				       LOCAL.CAT.VAL [ SPR.FIRST synsem &
								 [ OPT - ],
						       SPCMPS < > ] ] ] ].

; DPF 03-Feb-06 - Changed analysis so INDEX is now the ARG0 of the comp_rel
; rather than of the basic predicate, to give a more plausible semantics
; for e.g. 'Dogs are 5 cm. taller than horses.'
; DPF 09-may-06 - But this is unnecessary, and creates an unwanted asymmetry
; with '5 cents more expensive', since in the first case the ARG0 of the
; proposition is the ARG0 of the comp_rel, but in the second it's the ARG0
; of the adjective's relation (since we use the head_compositional head-spr
; variant to build 'more expensive').  So let's go back to making the INDEX
; the ARG0 of the basic adjective relation, and still hook up the comp_rel's 
; argument as desired, but by referring to the adj's SPR value.
;; DPF 2011-09-22 - Added MODIFD hasmod to avoid spurious ambig for e.g.
;; |quickly different|.  Cannot be the normal notmod value, since the rule for
;; partitives as in |the highest| requires the daughter to have value hasmod.

compar_superl_adj_word := nonc-hm-nab &
  [ SYNSEM adj_unsp_ind_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind & non_expl ] >,
				  TAM #tam,
				  MINORS.MIN abstr_adj_rel ],
                           VAL.SPR.FIRST.LOCAL.CONT.HOOK.XARG #altarg0 ],
		     CONT [ HOOK [ XARG #ind,
                                   INDEX #arg0 & [ E #tam ] ],
                            RELS.LIST < [ LBL #hand,
                                          ARG1 #ind ],
                                        #altkeyrel &
                                        [ LBL #hand,
                                          ARG0 event & #altarg0,
                                          ARG1 #arg0 ], ... > ] ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

; DPF 03-Feb-06 - Changed analysis so INDEX is now the ARG0 of the comp_rel
; rather than of the basic predicate, to give a more plausible semantics
; for e.g. 'Dogs are 5 cm. taller than horses.'

basic_adj_comp_lexent := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_twoarg_synsem &
	   [ LOCAL [ CAT.VAL [ COMPS < canonical_or_unexpressed &
                                     [ --MIN #cmin,
                                       LOCAL [ CAT basic_pp_cat,
                                               CONJ cnil,
                                               CONT.HOOK [ LTOP #ltop,
                                                           INDEX #ind ] ] ] > ],
                     CONT.HOOK [ LTOP #ltop,
                                 XARG #xarg ] ],
             LKEYS [ KEYREL.ARG1 #xarg,
                     ALTKEYREL.ARG2 #ind,
                     --COMPKEY #cmin ] ] ].

adj_comp_lexent := basic_adj_comp_lexent &
  [ SYNSEM.LKEYS [ --COMPKEY _than_p_compar_rel,
                   ALTKEYREL.PRED comp_rel ] ].

norm_adj_comp_lexent := adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN comp_rel ],
                           VAL.SPR.FIRST.--MIN much_deg_rel ],
		     CONT.RELS <! relation, 
				  relation & #altkeyrel !> ],
             MODIFD.LPERIPH bool,
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; <type val="aj_pp_i-cmp_le">
; <description>Adj, compar "-er" adj, PP-than   
; <ex>B is richer than C.
; <nex>
; <todo>
; </type>
aj_pp_i-cmp_le := norm_adj_comp_lexent.

;; DPF 2012-09-12 - To block spurious analyis of |we arrived earlier| with
;; subconj-prd for `earlier', given the existence of the np-adv `earlier', 
;; we try a hack of making this class of adjectives itself [OPT -], even
;; though this feature is otherwise almost exclusively used inside of VAL
;; specifications.  The other half of the hack is to make the dtr in the
;; subconj rule be unifiable with OPT + (which all other adjectives will
;; presumably do).  Maybe FIX in a better fashion someday.
;; 
; <type val="aj_pp_i-cmp-nsb_le">
; <description>Adj, compar "-er" adj, PP-than, block as subord predicatives
; <ex>The earlier cat arrived.
; <nex>
; <todo>
; </type>
aj_pp_i-cmp-nsb_le := norm_adj_comp_lexent &
  [ SYNSEM.OPT - ].

; 'more'
; <type val="aj_pp_i-more_le">
; <description>Adj, only 'more'                 
; <ex>B has more cats than C.
; <nex>
; <todo>
; </type>
aj_pp_i-more_lexent := adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD compar_adj &
                              [ MOD < [ LOCAL [ AGR #agr & [ DIV + ],
                                                CAT.HEAD.MINORS.ALTMIN 
                                                        implicit_q_rel ] ] > ],
                           VAL [ SPR.FIRST [ --MIN card_or_much_rel,
					     LOCAL.CAT.VAL.COMPS < > ],
				 COMPS < [ LOCAL.AGR #agr ] >,
                                 SPEC *synlist* ],
                           POSTHD - ],
                     CONT.RELS <! relation, 
				  relation & #altkeyrel !> ],
             MODIFD.LPERIPH na,
	     LKEYS.ALTKEYREL #altkeyrel ] ].

aj_pp_i-more_le := aj_pp_i-more_lexent.
aj_pp_i-more-obl_le := aj_pp_i-more_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

; 'one more'
; <type val="aj_pp_i-onemore_le">
; <description>Adj, only 'one more'             
; <ex>B has one more cat than C.
; <nex>
; <todo>
; </type>
aj_pp_i-onemore_le := adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD intadj1 &
                              [ MOD < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN 
                                                        implicit_q_rel,
                                                CONT.HOOK [ LTOP #lbl,
                                                            INDEX #index & 
                                                              [ PNG.PN 3s ] ],
                                                AGR [ PNG.PN 3s,
                                                      DIV - ] ],
                                        MODIFD.LPERIPH bool ] > ],
                           POSTHD - ],
                     CONT.RELS <! relation & 
                                  [ LBL #lbl,
                                    ARG1 #index ], 
                                  relation & #altkeyrel,
                                  integer_relation & #alt2keyrel &
                                  [ PRED card_rel,
                                    LBL #lbl,
                                    ARG1 #index,
                                    CARG "1" ] !> ],
             MODIFD.LPERIPH na,
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].


; For 'different from/than', 'similar_to'
; (Takes both 'very' and 'much' specifiers.)
; <type val="aj_pp_i-cmp-dif_le">
; <description>Adj, only 'different'            
; <ex>B is different from C.
; <nex>
; <todo>
; </type>
aj_pp_i-cmp-dif_le := basic_adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj,
                           VAL.SPR.FIRST.--MIN much_or_very_deg_rel ],
                     CONT.RELS <! relation, 
				  relation !> ],
             MODIFD.LPERIPH bool,
             LKEYS.ALTKEYREL.PRED comp_rel ] ].

; For 'same as' - Note "*Kim is same", "*A same car arrived"
; <type val="aj_pp_i-cmp-sme_le">
; <description>Adj, only 'same'                 
; <ex>B has the same cat as C.
; <nex>
; <todo>
; </type>
aj_pp_i-cmp-sme_le := basic_adj_comp_lexent &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD superl_adj &
                         [ PRD -,
                           MOD < [ LOCAL.CAT.VAL.SPR 
                                       < [ --MIN def_or_demon_q_rel ] > ] > ],
                    VAL.SPR.FIRST.--MIN much_deg_rel ],
              CONT.RELS <! relation, relation !> ],
      MODIFD.LPERIPH bool,
      LKEYS [ ALTKEYREL.PRED comp_equal_rel,
              --COMPKEY _as_p_comp_rel ] ] ].

; <type val="aj_pp_i-cmp-wthr_le">
; <description>Adj, comparative weather         
; <ex>B is rainer than C.
; <nex>
; <todo>
; </type>
aj_pp_i-cmp-wthr_le := nonc-hm-nab &
  [ SYNSEM norm_adj_lex_synsem &
        [ LOCAL [ CAT [ HEAD [ MOD < >,
                               MINORS.ALTMIN comp_rel ],
                        VAL [ SPR.FIRST.--MIN much_deg_rel,
                              COMPS < > ] ],
                  CONT [ HOOK [ LTOP #hand,
                                XARG it-ind ],
                         RELS <! [ LBL #hand ],
                               #altkeyrel &
                               [ LBL #hand,
                                 ARG0 event ] !> ] ],
          LKEYS [ ALTKEYREL #altkeyrel & [ PRED comp_rel ],
                  --+ARGIND it-ind ] ] ].

aj_pp-pp_i-cmp_lexent := compar_superl_adj_word &
  [ SYNSEM trans_adj_pred_three_arg_synsem &
	   [ LOCAL [ CAT [ HEAD adj,
                           VAL [ COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                             INDEX #ind1 ],
					   --MIN #cmin & selected_rel ],
					 canonical_or_unexpressed &
					 [ --MIN #ocmin & selected_rel,
					   LOCAL [ CAT basic_pp_cat,
						   CONJ cnil,
						   CONT.HOOK [ LTOP #ltop,
							       INDEX #ind2 &
  							       non_expl-ind ]],
					   PUNCT.LPUNCT no_punct ] >, 
				 SPR.FIRST.--MIN much_deg_rel ] ],
		     CONT [ HOOK.LTOP #ltop,
                            RELS <! relation, relation !> ] ],
             LKEYS [ KEYREL [ ARG2 #ind1 ],
                     ALTKEYREL [ PRED comp_rel,
				 ARG2 #ind2 ],
		     --COMPKEY #cmin,
		     --OCOMPKEY #ocmin & _than_p_compar_rel ] ] ].

; <type val="aj_pp-pp_i-cmp_le">
; <description>Adj, compar, two PP comps, both optional
; <ex>B is closer to C (than D).
; <nex>
; <todo>
; </type>
aj_pp-pp_i-cmp_le := aj_pp-pp_i-cmp_lexent.


; DPF 14-jul-06 - Added LPERIPH + to block spurious analysis of "next 
; tallest" as adj-head; only want spr-head analysis.  But this isn't quite
; right - make LPERIPH na.
; DPF 06-sept-07 - Require MOD nbar to have an explicit determiner, to 
; block e.g. "biggest dogs barked."
; DPF 15-jan-08 - Re: 14-jul-06 But this blocks "the two tallest trees",
; so remove, and find alternative to block "next tallest".  FIX...

; <type val="aj_-_i-sup_le">
; <description>Adj, superlative                 
; <ex>The fastest runner won.
; <nex>
; <todo>
; </type>
aj_-_i-sup_le := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
    [ LOCAL [ CAT [ HEAD superl_adj & [ MINORS.ALTMIN superl_rel,
                                         MOD < [ LOCAL.CAT.HEAD.MINORS.ALTMIN
                                                   explicit_q_rel ] > ],
                    VAL.SPR.FIRST.--MIN ord_or_very_rel ],
              CONT.RELS <! relation, relation !> ],
      LKEYS.ALTKEYREL.PRED superl_rel ] ].

superl_adj_synsem := basic_adj_abstr_lex_synsem & one_arg &
  [ LOCAL [ CAT.HEAD.TAM #tam,
	    CONT [ HOOK.INDEX.E #tam,
		   RELS <! #keyrel, #altkeyrel & relation !> ] ],
    MODIFD.LPERIPH bool,
    LKEYS [ KEYREL #keyrel,
	    ALTKEYREL #altkeyrel ] ].

adj_atrans_superl_lexent := nonc-hm-nab &
  [ SYNSEM norm_adj_lex_synsem &
       [ LOCAL [ CAT [ HEAD [ MOD < >,
                              MINORS.ALTMIN superl_rel ],
                       VAL [ SPR.FIRST.--MIN ord_or_very_rel,
                             COMPS < > ] ],
                 CONT [ HOOK [ LTOP #hand,
                               XARG it-ind ],
                        RELS <! [ LBL #hand ],
                              #altkeyrel &
                              [ LBL #hand ] !> ] ],
         LKEYS [ ALTKEYREL #altkeyrel & [ PRED superl_rel ],
                 --+ARGIND it-ind ] ] ].

; <type val="aj_-_i-sup-it_le">
; <description>Adj, superl, it-subj             
; <ex>B is the rainiest place.
; <nex>
; <todo>
; </type>
aj_-_i-sup-it_le := adj_atrans_superl_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

; <type val="aj_-_else_le">
; <description>Only `else', modifier of `anything, somewhere, anyplace, etc'
; <ex>Something else appeared.
; <nex>
; <todo>
; </type>
aj_-_i-else_le := reg_intrans_adj &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MINORS.MIN norm_adj_rel,
				PRD +,
				MOD < [ LOCAL.CAT 
					[ HEAD partn,
					  VAL [ SPR < [ --MIN 
							 just_only_deg_rel ] >,
						COMPS < > ] ],
					LEX + ] > ],
			 POSTHD + ],
		   CONT.HOOK.INDEX.E.TENSE no_tense ] ].

; Titles like 'mister', 'professor' which modify proper names
; DPF 5-Apr-01 - Changed MOD..MIN to abstr_named_rel from named_rel, to
; include integers, as in "number ten"
; Removed LPERIPH na - it blocked "order fivedigitersatz" since the num-np
; rule cannot accept numerals modified by adjectives or noun-noun compounds -
; we want to block the NP "Toshiba 2000" but allow the NP "order (number) 2000"
; DPF 12-Nov-03 - Removed MOD.MODIFD notmod_or_rmod since it prevented
; "number 222" where "222" is MODIFD lmod.  We'll see what that constraint
; was trying to block.
; DPF 03-may-04 - Added LPERIPH + to distinguish "number five" from "five",
; so the former can appear in appositives but not the latter.
; DPF 01-sep-05 - Changed MOD..MIN from gen_named_rel to named_np_or_num_rel
; to block "my summer house" as post_title.
; DPF 08-sep-06 - Changed SPR < anti_synsem_min > to synsem with unexpr SPR
; to allow Adj-N titles as in "federal highway 66".
; DPF 23-may-10 - Removed MOD..MIN named_np_or_num_rel since it blocked
; "Itel Systems Inc.", but instead ensure that SPR is unexpressed, to avoid
; spurious ambiguity for "the Stigen farm"
;; DPF 2012-12-15 - Restrict to modifying proper names.
;; DPF 2014-06-05 - Since now using this only for post-titles, remove the
;; MOD..SPR.FIRST unexpressed, so we can get |the defunct Smith Inc.|
;;
basic_title_synsem := basic_zero_arg & count_noun_synsem &
  [ LOCAL [ CAT [ HEAD ttl &
                  [ MOD < [ LOCAL intersective_mod &
                                  [ CAT basic_nbar_cat &
                                    [ HEAD.MINORS.MIN named_or_part_nom_rel,
                                      VAL.SPR < [ OPT - ] > ],
                                    CONJ cnil,
                                    CONT.HOOK [ INDEX #nind,
                                                XARG #nhand ] ],
                            NONLOC non-local_none,
                            PUNCT.RPUNCT comma_or_rbc_or_clause_or_no_punct ]>,
                    MINORS [ MIN generic_entity_rel,
                             ALTMIN no_rel ] ],
                  VAL [ SUBJ < >,
                        SPR < unexpressed &
                              [ --MIN explicit_q_rel ] >,
                        COMPS < > ] ],
            AGR #ind,
	    CONT [ HOOK [ LTOP #nhand,
			  INDEX #ind,
                          XARG #khand ],
		   RELS.LIST 
			< #keyrel & 
                          [ LBL #khand,
			    ARG0 #ind ],
                          [ PRED udef_q_rel,
                            ARG0 #ind,
                            RSTR #rhand ],
                          [ LBL #nhand,
                            PRED compound_rel,
                            ARG1 #nind,
                            ARG2 #ind ], ... >,
                   HCONS.LIST < qeq &
                           [ HARG #rhand,
                             LARG #khand ], ... > ] ],
    MODIFD notmod & [ LPERIPH + ],
    LKEYS.KEYREL #keyrel ].

title_synsem := basic_title_synsem &
  [ LOCAL.CONT [ RELS <! relation, 
		         relation & #altkeyrel,
		       relation & #alt2keyrel !>,
		 HCONS <! qeq !> ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    ALT2KEYREL #alt2keyrel ] ].

; DPF 7-mar-05 - Added MOD..MODIFD notmod to remove spurious analysis of e.g.
; '[Abrams in Berlin] river rises.'
; DPF 25-may-10 - Added [PN 3s] to block |Kim is| with plural roman numeral
; <type val="n_-_tt-post_le">
; DPF 2011-02-11 - Added constraint that modifiee must be a singular proper 
; name, to avoid analysis of |dogs' house|.
;
; <description>Title noun, follows head         
; <ex>B street appeared.
; <nex>
; <todo>
; </type>
n_-_tt-post_le := noncqrs-hm &
  [ INFLECTD -,
    SYNSEM title_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
			   HEAD [ MOD < [ MODIFD notmod,
					  LOCAL.AGR.PNG.PN 3s ] >,
				  PRD - ] ],
		     AGR.PNG.PN 3s ] ] ].

; <type val="n_-_tt-post-pl_le">
; <description>Title noun, follows head, plural 
; <ex>Desert Lanes closed.
; <nex>
; <todo>
; </type>
n_-_tt-post-pl_le := noncqrs-hm &
  [ INFLECTD -,
    SYNSEM basic_title_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
                            HEAD.MOD < [ MODIFD notmod ] > ],
                     AGR.PNG.PN 3p,
		     CONT [ RELS <! relation, 
				    relation & #altkeyrel,
				    relation & #alt2keyrel !>,
			    HCONS <! qeq !> ] ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

;; DPF 2012-04-07 - Added LEX - to avoid spurious analysis for |Kim Browne Inc.|
;; (avoid using title-compound rule with |Inc.| as head).
; <type val="n_-_tt-post-npt_le">
; <description>Title noun, follows head, head optionally comma or clause marked
; <ex>Lee Browne, Esq appeared.
; <nex>
; <todo>
; </type>
n_-_tt-post-npt_le := basic_word &
  [ INFLECTD +,
    SYNSEM title_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
			   HEAD [ MOD < [ MODIFD notmod ] >,
				  PRD - ],
			   MC na ],
		     CONJ cnil ],
	     NONLOC non-local_none,
	     LEX -,
	     PUNCT [ LPUNCT no_punct,
		     RPUNCT comma_or_clause_or_no_punct,
		     RCLSTR [ RPAREN -,
			      RFP - ] ] ] ].

; For 'high mountain lodges' until a better solution emerges ...
; <type val="n_-_tt-post-mwe_le">
; <description>Title noun, follows hd, multiwd  
; <ex>Bygdin high mtn lodge is.
; <nex>
; <todo>
; </type>
n_-_tt-post-mwe_le := noncqrs-hm &
  [ INFLECTD -,
    SYNSEM basic_title_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
			   HEAD.MOD < [ MODIFD notmod ] > ],
		     CONT [ RELS <! [ LBL #khand,
				      ARG0 #kind,
				      CFROM #from, CTO #to ],
				    relation & [ CFROM #from, CTO #to ],
				    relation & [ CFROM #from, CTO #to ],
				    #altkeyrel & 
				    [ LBL #lhand,
 				      ARG0 #lind ],
				    [ PRED udef_q_rel,
				      ARG0 #lind,
				      RSTR #lrstr,
				      CFROM #from, CTO #to ],
				    [ LBL #khand,
				      PRED compound_rel,
				      ARG1 #kind,
				      ARG2 #lind,
				      CFROM #from, CTO #to ],
				    #alt2keyrel &
				    [ LBL #khand,
				      ARG0.E [ TENSE untensed, 
					       ASPECT no_aspect ],
				      ARG1 #kind ] !>,
			    HCONS <! qeq, qeq & [ HARG #lrstr,
						  LARG #lhand ] !> ] ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PREPOSITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Most prepositions can be modifiers.  If they act as a modifier, we'll assume
; they have no subject (leaving for some distinct analysis Carl's "A unicorn
; at the helm, the ship sailed into the horse latitudes."  This lets us use a
; single attribute, ARG, for the index of the phrase modified, or for the
; index of the subject of the PP, in a predicative construction.

; Prepositions also have a distinguished role ARG2 which has as value the
; index of the object of the preposition.  We could introduce distinct role
; names for each preposition (e.g. "ON" for on_rel, "IN" for in-rel) but this
; would complicate the definition of the prep_synsem type, since it needs to
; know the role name to which it assigns the object's index.

; An ARG0 attribute is needed for PPs (and other substs used predicatively)
; occurring as complements of the copula as in "the meeting is on Tuesday",
; but on this analysis not postnominally.  This ARG0 role used to be
; introduced in a separate support_rel, supplied by the copula, but is now
; introduced directly in the relation introduced by the predicate (prep or
; adj or verb).

; Prepositions, like adjectives and participial verbs, can have either
; predicative or nonpredicative synsems, so each ordinary preposition
; (actually the PP headed by the P) can unify with either a pred. or non-pred.
; constraint, which resolves the underspecification.  One assumption here is 
; that there are no contexts which are underspecified for the PRD feature 
; for PPs.

; N.B. The RELS value of basic_prep_synsem cannot be a singleton list, since
; adverbs like "when" inherit this synsem, and add additional rels lexically.

; Here we only amalgamate non-local features from the complements, not the
; subject.  This is so we don't get two identical gaps in an example like "Who
; does kim think is under the bed?".  On the other hand, binding theory
; suggests that the subjects of prepositions really are on the ARG-S list.

; DPF (14-Mar-99) Constrained prepositions to not allow pied-piping in
; free relative constructions, where the QUE value is an index rather than
; a handle.

; DPF 18-Nov-04 - FIX - make HEAD be prep rather than n_or_p: no longer any
; visible motive for n_or_p.
; DPF 20-oct-09 - Changed HEAD to p_or_adv, to allow "how" and "why" to be
; underspecified for prep or adv.

basic_prep_synsem := canonical_synsem & 
  [ LOCAL.CAT [ HEAD p_or_adv,
                VAL [ SUBJ < >,
		      SPCMPS < > ] ] ].

; DPF 18-Apr-01 - Removed ident. of ALTMIN with COMPS..MIN, since it prevents
; selection in v-np-pp verbs for a PP which is temporal or locative: want to
; block "When did kim put the book", but allow "Where did Kim put the book"
; We'll see where this constraint was being used.
; DPF 28-jun-07 - Made contentful preps PRD + so they take the right kind
; of measure-NP specifiers: "miles under the ice" but not "mile under the ice"

norm_prep_synsem := basic_prep_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_prep & 
                       [ MINORS.MIN #min,
                         TAM #tam ],
                  VAL.COMPS < synsem &
                              [ LOCAL.CAT.NEGPOL #negpol,
				PUNCT.LPUNCT pair_or_no_punct ], ... >,
                  POSTHD +,
		  NEGPOL #negpol ],
	    CONT.HOOK.INDEX.E #tam ],
    LKEYS.KEYREL.PRED #min ].

prep_synsem := norm_prep_synsem &
  [ LOCAL [ CAT.HEAD prep,
	    CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS.KEYREL #keyrel ].

; For predicative Ps and PPs like "when" which have a (non-expletive) NP subj

prep_p_synsem := basic_prep_synsem &
  [ LOCAL [ CAT [ HEAD basic_prep,
		  VAL.COMPS #comps ],
	    ARG-S #comps ] ].

;; DPF 17-Jul-01 - Restricted SPR to be very_deg_rel, to avoid e.g. "much 
;; for Kim".  
;; DPF 16-Nov-01 - But "very for Kim" is also bad", and note "very much for
;; Kim" is good, but not "very very for Kim".  Seems reminiscent of contrast
;; between "*I want much to stay" and "I want very much to stay".  Don't know
;; how to get this, but in any case fixed SPR.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so PPs can
;; coordinate with VPs (which are necessarily SPR anti_synsem_min).
;; DPF 27-Apr-03 - Note that making SPR be much_deg_rel means that for now we
;; have to have two degree specifier lex-entries for the just_only_deg ones,
;; since we want them to work for positive adjectives, and cannot underspecify
;; much_deg vs. very_deg yet.  Once we move to PRED for relation names, we
;; should be able to get rid of those duplicate deg-spec entries.
;; DPF 18-jul-06 - Removed SPR..MODIFD notmod_or_lmod since this interacted
;; badly with degree-specs identifying their MODIFD value with their SPEC's,
;; blocking examples like "directly down under Berlin".  Believe this was here
;; to block e.g. (((ten meters) (in Paris)) (under Berlin)), but we can now
;; instead block this in rule pumping measure-NPs to degree-specs.

prep_with_spr_synsem := basic_prep_synsem & abstr_lex_synsem &
  [ LOCAL 
    [ CAT [ HEAD.MINORS.MIN #min,
            VAL.SPR < synsem_min & 
                      [ LOCAL
                        [ CAT [ HEAD n_or_adv,
                                VAL [ COMPS *olist*,
                                      SPEC < [ LOCAL.CAT.VAL.COMPS < > ] > ]]],
                        NONLOC.QUE 0-dlist ] > ] ],
    LKEYS.KEYREL.PRED #min ].

; Ps and PPs that can be modifiers.
; Block PP modification of infinitival "to" - spurious ambiguity.
; Constrain MOD < [ --SIND > to be non_expl, for fragments like 
; "perhaps in a week"
; DPF 10-Sept-01 - Removed MOD..MIN relation, since it prevents modification
; of no_copula VPs, as in "rain likely tomorrow"
; DPF 19-Feb-03 - Added link between HOOK.INDEX and KEY.ARG1 - don't know why
; this went missing (example: "Can kim arrive on tuesday after four").
; DPF 11-Nov-03 - Removed reentrancy of LTOP and MOD..LTOP since this is being
; supplied by the head-modifier constructions generally, as required by the
; solution to the "apparently unsolvable problem" Kasper scoping examples.
; One extra benefit of this division of labor is that we now also get the 
; right scoping for "On Tuesday who arrives?" where the PP does not want to 
; share the handle with the filler-head phrase that it modifies.
; DPF 12-Mar-04 - Added MOD..SPEC < anti_synsem_min > to block modification by
; PPs of measure-NPs.  Though this prevents "Five kilometers on snow is
; difficult", so we should reconsider.
; DPF 19-nov-04 - Okay, we reconsidered, and removed this constraint, in order
; to provide an analysis for "five kilometers on artificial snow is difficult".
; The apparently spurious additional ambiguity seems to be manageable.
; DPF 11-mar-05 - Finally decided to take the plunge and allow PPs to modify
; other PPs (along with Nbars, VPs, and APs), so we can get rid of the
; spurious ambiguity for "Kim will arrive on Tuesday":  also constrain
; MOD to AUX -.  Note that this analysis assumes that elided VPs are not
; marked for AUX: 'Kim can on Tuesdays'.

basic_mod_n_or_vp_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ --MIN independent_rel,
                               LOCAL intersective_mod &
                                     [ CAT [ HEAD subst &
                                                  [ AUX - ],
                                             VAL [ SPR < synsem_min, ... >,
                                                   COMPS < > ],
                                             MC #mc ],
				       CONJ cnil ],
                               --SIND #ind & basic_non_expl ] >,
                  MC #mc,
                  POSTHD + ],
            CONT [ HOOK [ LTOP #hand,
                          INDEX #event,
                          XARG #ind ] ] ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event & non_conj_event,
                   ARG1 #ind ] ].

prep_spr_mod_synsem := basic_mod_n_or_vp_synsem & prep_with_spr_synsem.

prep_p_mod_synsem := prep_p_synsem & prep_spr_mod_synsem.

prep_prd_or_nonprd_synsem := prep_synsem & prep_p_mod_synsem.

; Strict transitive prepositions which can be either predicative or non-pred:

basic_one_arg_prep_synsem := prep_prd_or_nonprd_synsem & basic_one_arg &
  [ LOCAL.CONT.RELS.LIST < prep_relation, ... > ].

one_arg_norel_prep_synsem := prep_p_synsem & norm_prep_synsem.

one_arg_prep_synsem := basic_one_arg_prep_synsem &
  [ LOCAL.CAT.VAL.SPR < [ LOCAL 
                          [ CAT [ HEAD.MINORS [ MIN much_deg_rel,
                                                ALTMIN abstr_meas_nom_rel],
                                  VAL [ SPR *olist*,
                                        SPEC < synsem >,
                                        COMPS < > ] ],
                            CONT.HOOK [ LTOP #ltop,
                                        XARG #arg0 ] ] ] >,
    LKEYS.KEYREL [ LBL #ltop,
                   ARG0 #arg0 ] ].

; DPF 14-may-09 - Changed SPR..COMPS from < > to *olist*, to allow
; |most probably from Kim|
basic_trans_prep_synsem := basic_one_arg_prep_synsem &
  [ LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
                    SPR < [ LOCAL.CAT.VAL [ SPEC < synsem >,
                                            COMPS *olist* ] ] > ],
    LKEYS.KEYREL.ARG2 #ind & non_expl ].

; DPF 21-Jun-01 - Changed COMPS..INDEX from ref-ind to non_expl-ind so preps
; can be particles.
; DPF 8-Aug-01 - Removed identification of LTOP and COMPS..LTOP - unwanted.

basic_norm_trans_prep_synsem := basic_trans_prep_synsem &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL [ COMPS < [ --SIND overt_non_expl-ind,
                                  --MIN #cmin,
				  LOCAL.CONT.HOOK.LTOP #ltop,
                                  NONLOC.QUE.LIST *paramlist* ] >,
                      SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                             [ MIN just_only_notvery_deg_rel ],
					    VAL.SPR *olist* ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #arg0 ] ] ] > ] ],
            CONT [ RELS <! prep_relation &
                           [ LBL #ltop,
                             ARG0 #arg0 ] !>,
		   HCONS <! !> ] ],
    LKEYS.--COMPKEY #cmin ].

; Exclude possessive `of'
norm_trans_prep_synsem := basic_norm_trans_prep_synsem &
  [ LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN abstr_meas_nom_rel ].

; DPF 27-sept-04 - Added TAM.TENSE tense to enable blocking of coordination
; of ordinary PPs with nbar-complement PPs like "per unit" or "a person"

trans_prep_synsem := norm_trans_prep_synsem &
  [ LOCAL.CAT.HEAD.TAM.TENSE tense ].

ditrans_prep_synsem := prep_prd_or_nonprd_synsem & basic_two_arg &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL [ SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                 [ MIN much_deg_rel,
                                                   ALTMIN abstr_meas_nom_rel ],
                                            VAL [ SPR *olist*,
                                                  SPEC < synsem >,
                                                  COMPS < > ] ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #arg0 ] ] ] >,
                      COMPS < [ --MIN #cmin,
                                NONLOC.QUE.LIST *paramlist*,
                                --SIND #objind ], 
                              [ --MIN #ocmin,
                                LOCAL [ CAT.HEAD.TAM [ ASPECT no_aspect ],
					CONT.HOOK.LTOP #ltop ] ] > ] ],
	    CONT.RELS.LIST < prep_relation &
                             [ ARG2 #objind & overt_non_expl-ind,
                               LBL #ltop,
                               ARG0 #arg0 ], ... > ],
    LKEYS [ --COMPKEY #cmin,
            --OCOMPKEY #ocmin ] ].

basic_lex_pp_synsem := prep_p_synsem & abstr_lex_synsem &
  [ LOCAL [ ARG-S < >,
	    CAT [ VAL.COMPS < >,
		  NEGPOL - ],
            CONT.HCONS <! !> ],
    LEX - ].

; Try excluding lexical PPs modifing PPs, to avoid spurious ambiguity
; DPF 21-apr-08 - Added ALTMIN no_rel to let us exclude these from v_mod
; rule, to avoid spurious ambiguity for e.g. "We brought up the cat"
; DPF 19-jun-08 - Re 21-apr-08: But this ambiguity is not spurious - note
; also "We brought aboard the new arrivals" "We have since departed" etc.
; DPF 03-jun-10 - Move exclusion of PP modifee down to subtype, so we can
; still get e.g. colon-as-PP modifying PPs, as in |in this way :|
;; DPF 2012-09-30 - Removed MOD synsem constraint, since this prevented
;; extraction in copula constructions, as in |when is the game over?|,
;; where the extracted-adj rule imposes MOD anti_synsem on mother (and hence
;; on head-dtr).
;
norm_lex_pp_synsem := basic_lex_pp_synsem & basic_mod_n_or_vp_synsem &
  [ LOCAL [ CAT.HEAD [ MOD < [ MODIFD notmod_or_rmod ] >,
                       MINORS.MIN #min,
                       PRD + ],
            CONT.RELS.LIST.FIRST #keyrel & [ PRED #min ] ],
    LKEYS.KEYREL #keyrel & [ ARG0 event,
                             ARG1 individual ] ].

; DPF 26-aug-07 - Restrict NORM to prevent these from appearing in
; v_mod constructions as in "moving on the river"
; DPF 20-apr-08 - Re 26-aug-07: But this also blocks ordinary copula-be+PP
; so remove, and revisit.  FIX??
;
lex_pp_synsem := norm_lex_pp_synsem & prep_with_spr_synsem &
  [ LOCAL.CAT.VAL.SPR < [ --MIN much_deg_rel,
              	          LOCAL [ CAT.VAL [ SPR *olist*,
                                            COMPS < >,
                                            SPEC < synsem > ],
                                  CONT.HOOK [ LTOP #ltop,
                                              XARG #arg0 ] ] ] >,
    LKEYS.KEYREL [ LBL #ltop,
                   ARG0 #arg0 ] ].

; Ordinary prepositions:

; Moved [ OPT - ] specification to subtypes, to allow "the day before" where
; the complement is missing.
; DPF (9-Mar-99) Made basic_prep_word not inherit from nonmsg, since it has
; its MSG identified with that of its modifiee (via the head_modifier rule)
; and that modifiee will sometimes have a non-empty message, as in
; "Is kim happy in Berlin"
; DPF 19-Nov-01 - Removed COMPS..MSG no_msg, since now want to get "this
; depends on whether kim arrives" and "I'm interested in who you met"
; DPF 25-may-09 - Added MODIFD notmod to avoid spurious ambig for e.g.
; 'barely in Paris'

basic_prep_word := nonc-h-nab &
  [ INFLECTD +,
    SYNSEM [ PUNCT no_punctuation_min,
	     MODIFD notmod ] ].

norm_prep_word := basic_prep_word &
  [ SYNSEM basic_norm_trans_prep_synsem &
	 [ LOCAL.CAT.VAL.COMPS < synsem & 
                                 [ LOCAL [ CAT nomp_cat_nonnom_min,
                                           CONT.HOOK.INDEX index,
                                           CONJ cnil ] ] > ] ].

; Changed ref-ind constraint to non_expl-ind so prep's can be used as particles
; DPF 20-Oct-02 - Made SORT of ARG1 and first COMP be identified, to avoid
; spurious ambiguity for e.g. "ten to five"
; DPF 27-Oct-02 - But this runs afoul of the facts (1) that preps identify 
; their own index with that of their MOD's index (since they're intersective),
; (which is also their ARG's index) and (2) that predicative ones identify 
; their XARG index with their ARG's index.  And anyway, "ten to five" doesn't
; use the preposition, but rather the n_x_to_y lexical entry.

prep_word := norm_prep_word &
  [ SYNSEM trans_prep_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ --SIND overt_non_expl-ind ] > ] ].

; DPF 02-Apr-02 - For now, block measure-phrase specifiers of ordinary 
; prepositions -- too many spurious parses.
; DPF 17-Jul-03 - But we're losing too many good sentences, such as "Kim
; arrived a week after me" so removed SPR..LEX +.

; <type val="p_np_i_le">
; <description>Prep, np, intersective           
; <ex>B sang for C.
; <nex>
; <todo>
; </type>
p_np_i_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

; DPF 24-aug-04 - For prepositions like "as" that exclude verbal gerund 
; complements (to avoid spurious ambiguity)
; DPF 29-sept-05 - Also make PRD - to prevent e.g. "*Kim arrived from as 
; Abrams"
; DPF 12-nov-05 - But this prevents these PPs from ever being modifiers,
; so instead tighten constraints on complements of e.g. 'from' to exclude
; these.
; DPF 11-sep-07 - Added SPR < anti_synsem_min > to avoid spurious reading
; for "(as) well as .."

; <type val="p_np_i-nger_le">
; <description>Prep, np, no gerund              
; <ex>B was hired as a writer.
; <nex>
; <todo>
; </type>
p_np_i-nger_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < anti_synsem_min >,
                           COMPS < [ OPT -,
                                     LOCAL.CAT.HEAD basic_noun ] > ] ].

basic_p_nmod_lexent := norm_prep_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun_or_nomger ] >,
                       VAL.COMPS < [ OPT -,
                                     --SIND non_expl-ind ] > ] ].

; DPF 25-oct-05 - Collapsed this type with the following - need PRD + on PPs
; in order to force measure-NPs to be inflected: "ten feet under them" not
; "*ten foot under them".  (was only used for 'about')
;p_nmod_prd_le := basic_p_nmod_lexent & 
;  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].
; DPF 13-mar-10 - Moved SLASH 0-dlist down to subtypes, so we can analyze e.g.
; `the trip to and from Paris'

p_nmod_lexent := basic_p_nmod_lexent &
  [ SYNSEM norm_trans_prep_synsem &
	   [ LOCAL.CAT.HEAD.PRD + ] ].


; <type val="p_np_i-nm_le">
; <description>Prep, np, noun mod               
; <ex>B knew a lot about C.
; <nex>
; <todo>
; </type>
p_np_i-nm_le := p_nmod_lexent.

; 'than' of "kim had more of them than sandy"
; 13-mar-06 - But we also need this, for now, to get "more to offer than Kim".
; So we'll live with the spurious ambiguity for the simple case.
; DPF 14-may-10 - To allow for the hyper-correct "taller than I", copy the
; relevant constraints from intervening types, and make it basic_prep_word.
;
; <type val="p_np_i-than_le">
; <description>Prep, np, 'than' FIX (eliminate) 
; <ex>B has more to say than C.
; <nex>
; <todo>
; </type>
p_np_i-than_le := basic_prep_word &
  [ SYNSEM norm_trans_prep_synsem &
	   [ LOCAL.CAT [ HEAD [ PRD +,
				MOD < [ LOCAL.CAT.HEAD noun_or_nomger,
					--MIN part_nom_rel ] > ],
			 VAL.COMPS < synsem & 
				     [ OPT -,
                                       --SIND non_expl-ind,
				       LOCAL [ CAT nomp_cat_min,
					       CONT.HOOK.INDEX index,
					       CONJ cnil ] ] > ],
             NONLOC.SLASH 0-dlist,
             LKEYS.KEYREL.ARG0.E.TENSE nontense ] ].


; For "to", to avoid so much ambiguity for e.g. "ten to twelve"
; DPF 3-nov-03 - Changed MOD..MIN from non_temp_nom_rel to norm_nom_rel to
; prevent attachment to proper names.
; DPF 21-dec-05 - Changed COMPS..MIN from non_temp_nonpro_rel to 
; non_temp_nom_rel, since we want 'the road to it is open'
; DPF 30-sept-06 - Re: 3-nov-03 - But this blocks eg. "Berlin to the north
; is cooler."  FIX.
; DPF 10-oct-06 - Okay, made named_np_rel be subtype of this MIN, so now
; get attachment to proper names, and will live with added ambiguity.
; DPF 16-oct-06 - Replaced MOD..MIN norm_nom_or_place_rel with old and better
; non_temp_nom_rel to include partitives as modifiees: "two to Paris"

; <type val="p_np_i-nm-no-tm_le">
; <description>Prep, np, non-temp noun mod      
; <ex>B went into the house.
; <nex>
; <todo>
; </type>
p_np_i-nm-no-tm_le := p_nmod_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ --MIN non_temp_nom_rel,
                                      LOCAL.CAT.HEAD basic_noun ] >,
                         VAL.COMPS < [ --MIN non_temp_nom_rel ] > ],
                   CONT.HOOK.INDEX.E.TENSE no_tense ] ].

; possessive 'of'
; DPF 28-mar-05 - Removed ARG0..TENSE nontense since this prevents e.g.
; 'Pollock is of what nationality?'  Also removed PRD - for same reason.
; DPF 17-apr-05 - Block SPR from being realized, to avoid spurious analyis
; of e.g. 'bits of rope'
; DPF 18-jul-07 - But this also blocks "mainly of Kim's", so let's instead
; restrict the SPR to being a degree adv.
; DPF 24-jul-07 - Still want to avoid having PPs modify these of-PPs, so
; add hack [AUX +] here.  FIX someday.  Note that currently fail to analyze
; |In Paris, he is of considerable interest.|
; DPF 18-jul-07 - While it was tempting to make the COMP be basic_nonpro_rel,
; to contrast "cats of mine" vs. "*cats of me", this also blocks ordinary
; constructions like "the intensity of it" "the presence of us (in the room)".
; So relax constraint to nom_rel, and wait for more insight about how to
; block "the cats of us".
; DPF 15-apr-08 - Re 24-jul-07: Note that this blocks "This paper is of high
; quality today".  But the extra ambiguity is still a pain, so leave hack in
; for now.
; DPF 2010-11-05 - Constrain ALTMIN to no_rel in order to prevent meas-NP-deg
; phrases as in spurious analysis of |three miles of roads|.

p_np_i-nm-poss_lexent := basic_p_nmod_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD 
	      [ MOD < [ LOCAL.CAT.VAL.SPR < [ --MIN quant_or_deg_rel ], ... >,
			NONLOC.REL 0-dlist ] >,
		AUX + ],
	      VAL [ SPR < [ LOCAL.CAT.HEAD adv &
					   [ MINORS.ALTMIN no_rel ] ] >,
		    COMPS < synsem &
			    [ --MIN nom_rel,
			      LOCAL.CAT.VAL.SPEC < anti_synsem_min > ]>]],
	CONT.HOOK.XARG ref-ind ],
      NONLOC.SLASH 0-dlist ] ].

; <type val="p_np_i-nm-poss_le">
; <description>Prep, np, poss 'of'              
; <ex>The cities of France grew.
; <nex>
; <todo>
; </type>
p_np_i-nm-poss_le := p_np_i-nm-poss_lexent.

; <type val="p_np_i-nm-poss-mal_le">
; <description>Prep, np, poss 'of'              
; <ex>The cities of of France grew.
; <nex>
; <todo>
; </type>
p_np_i-nm-poss-mal_le := p_np_i-nm-poss_lexent &
  [ GENRE robust ].

; 'of mine', 'of Kim's'
; DPF 11-jan-10 - Removed COMPS..MIN implicit_q_rel since this blocked
; `of Kim's', since `Kim's' now has def_explicit_q_rel.
;
; <type val="p_np_i-poss-gen_le">
; <description>Prep, np, genitive NP            
; <ex>Those dogs of B's barked.
; <nex>
; <todo>
; </type>
p_np_i-poss-gen_le := basic_prep_word &
  [ SYNSEM one_arg_prep_synsem &
     [ LOCAL 
        [ CAT [ HEAD [ PRD -,
                       AUX +,
                       TAM.TENSE tense,
                       MOD < [ LOCAL [ CAT [ HEAD noun,
                                             VAL.SPR 
                                                  < [ LOCAL.CAT.HEAD det,
						      --MIN nodef_q_rel ] > ],
                                       CONT.HOOK.LTOP #ltop ] ] > ],
                VAL.COMPS < synsem &
                            [ LOCAL [ CAT [ HEAD det &
                                               [ MINORS.ALTMIN poss_rel,
						 POSS + ],
                                            VAL [ SPR *olist*,
                                                  SPEC < anti_synsem_min > ] ],
                                      CONT.HOOK.INDEX #cind,
                                      CONJ cnil ],
                              OPT - ] > ],
          CONT [ HOOK.LTOP #ltop,
                 RELS <! prep_relation &
                       [ LBL #ltop,
                         PRED poss_rel,
                         ARG0 [ E [ TENSE no_tense,
                                    ASPECT no_aspect ],
                                --TPC - ],
                         ARG2 #cind ] !>,
                 HCONS <! !> ] ],
       NONLOC.SLASH 0-dlist ] ].

; e.g. since
; <type val="p_np_i-ngap_le">
; <description>Prep, np, no gap                 
; <ex>B has grown since 1990.
; <nex>
; <todo>
; </type>
p_np_i-ngap_le := prep_word & 
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             NONLOC.SLASH 0-dlist ] ].

; For particles
; DPF 31-may-07 - Removed COMPS..INDEX non_expl since we want to allow
; 'We saw to it that Kim left' where "to it" needs expletive "it".
;; DPF 2011-jul-30 - Removed PRD -, since we want these to unify in context
;; where need PRD +, namely in small clauses for gapping: |Kim relies on
;; speed, and Terry on stamina|

gen_p_prtcl_lexent := basic_prep_word &
  [ SYNSEM gen_prep_nomod_synsem &
     [ LOCAL [ CAT [ HEAD [ MINORS [ MIN selected_prep_rel,
                                     ALTMIN #min ],
                            TAM [ TENSE untensed,
                                  ASPECT no_aspect ] ],
                     VAL [ SPR < anti_synsem_min & 
				 [ --MIN just_only_deg_rel ] >,
                           COMPS < synsem &
                                   [ --MIN #min,
                                     LOCAL [ CAT [ VAL [ SUBJ *olist*,
                                                         SPR *olist*,
                                                         COMPS < > ],
                                                   MC na_or_- ],
                                             CONJ cnil ],
                                     OPT - ] > ] ] ] ] ].

basic_p_prtcl_lexent := gen_p_prtcl_lexent &
  [ SYNSEM basic_prep_nomod_synsem &
	   [ LOCAL.CONT [ RELS <! !>,
			  HCONS <! !> ] ] ].

; DPF 06-may-04 - Changed COMPS..CASE from acc to non_nom to allow obliq
; complement NPs, including WH-S NPs, as in "that depends on who stays"
; DPF 29-may-07 - FIX semantics for "Kim's belief only in Abrams" where
; the LTOP and XARG of "only" need to get bound to something reasonable.

p_prtcl_lexent := basic_p_prtcl_lexent &
  [ SYNSEM.LOCAL 
           [ CAT.VAL [ SPR < [ LOCAL.CONT.HOOK.LTOP #sprtop ] >,
                       COMPS < synsem &
                             [ LOCAL [ CAT [ HEAD nominal &
                                                  [ POSS -,
                                                    MOD < >,
                                                    CASE non_nom ],
                                             VAL.COMPS < > ],
                                       CONT.HOOK #hook ] ] > ],
             AGR #index,
             CONT.HOOK #hook & [ LTOP #sprtop,
				 INDEX #index ] ] ].

; Disallow measure-NPs for most particle preps (except 'of')
;; DPF 2012-09-21 - The above is a strange constraint, doubly so since now
;; MNPs without an overt determiner already have a non-empty SPEC, so all
;; this was doing was blocking |we rely on a meager $10 to survive|
;; Let's see what else goes wrong by changing it to *anti_list*.
norm_p_prtcl_lexent := p_prtcl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SPEC *anti_list* ] >].

; <type val="p_np_ptcl_le">
; <description>Prep, np, sem empty              
; <ex>B relies on C.
; <nex>
; <todo>
; </type>
p_np_ptcl_le := norm_p_prtcl_lexent.

; DPF - This is a place-holder solution for equative and comparative phrases,
; until we work out an adequate semantics for e.g. "taller than Abrams" or
; "as soon as convenient"
; DPF 31-mar-05 COMPS..MOD *anti_list* excludes subord-preps as in spurious
; analysis for "(as soon) as possible"
; DPF 13-nov-05 - But this also prevents lexical PPs like "before" which
; make MOD be synsem.  So let's use NORM norm_non_num_rel instead, 
; DPF 15-jul-07 - Removed COMPS..CASE non_nom, since we want "taller than he"
; in formal written English. 

; For VP,AP,PP complements, where need to bind LTOP
p_noslash_prtcl_lexent := basic_p_prtcl_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT.VAL.COMPS < synsem &
                        [ LOCAL [ CAT [ HEAD 
                                        [ MINORS [ MIN norm_rel,
						   NORM norm_non_num_rel ] ],
                                        VAL [ SUBJ *olist*,
                                              COMPS < > ] ],
				  CONT.HOOK.INDEX #index ],
			  NONLOC.SLASH #slash ] >,
	CONT.HOOK.INDEX #index ],
      NONLOC.SLASH #slash ] ].

; For VP,AP,PP complements, where need to bind LTOP
; 30-aug-05 - Can't have PRD + on COMPS since this would block
; 'as soon as Kim arrives'
; 14-nov-05 - But to block "than in" we'll try constraining the COMPS..MOD
; to be an *anti_list* which excludes lexical PPs.
;; 2010-10-23 - Re 14-nov-05: But this blocks "easier than before".  So to
;; distinguish "in" from "before", constrain MOD to be [HEAD verb], even
;; though this blocks adjectives; make separate type for these.

p_prd_ptcl-ngap_lexent := p_noslash_prtcl_lexent &
  [ SYNSEM.LOCAL 
           [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD v_or_a_or_p &
                                             [ MINORS [ MIN independent_rel,
							ALTMIN role_rel ] ],
					     VAL.SUBJ *synlist* ],
				       CONT.HOOK [ LTOP #ltop,
                                                   INDEX.SF basic-prop ] ],
                               NONLOC.REL 0-dlist ] >,
             CONT.HOOK.LTOP #ltop ] ].

; <type val="p_prd_ptcl-ngap_le">
; <description>Prep, prdp (PP or VP), no gap
; <ex>B was better than in Paris.
; <nex>
; <todo>
; </type>
p_prd_ptcl-ngap_le := p_prd_ptcl-ngap_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD 
					     < [ LOCAL.CAT.HEAD verb ] > ] > ].

; <type val="p_prd_ptcl-j_le">
; <description>Prep, AP comp, no gap
; <ex>B was the opposite of happy.
; <nex>
; <todo>
; </type>
p_prd_ptcl-j_le := p_prd_ptcl-ngap_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adj & 
						  [ PRD +,
						    MOD < synsem > ] ] > ].

; For NP complements, where cannot bind LTOP (given that for some lexical NPs
; like 'anyone' or 'that', the LTOP exposes the nominal relation's LBL, in
; order to support intersective post-nom modification, e.g. 'anyone in Paris')
; DPF 23-jun-08 - With improved treatment of lexical NPs, can now bind LTOP
; as we should.
; DPF 25-may-09 - Changed COMPS..HEAD back from noun_or_gerund to nominal,
; since no record of why changed, and we were blocking "higher than now"
;; 2010-10-24 - Added COMPS..PRD + to avoid spurious ambiguity for 
;; npadv measure-NPs as in |as big as a dollar|
;; DPF 2012-11-07 - Added COMPS..MOD < > to block predicative NPs, as in
;; |than president|

; <type val="p_np_ptcl-ngap_le">
; <description>Prep, np, sem empty, no gap      
; <ex>B is taller than C.
; <nex>
; <todo>
; </type>
p_np_ptcl-ngap_le := p_noslash_prtcl_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD nominal & 
						      [ PRD +,
							MOD < > ],
					     CONT.HOOK [ LTOP #ltop,
							 INDEX ref-ind ] ] ] >,
		   CONT.HOOK.LTOP #ltop ] ].

; <type val="p_np_ptcl-of_le">
; <description>Prep, np, sem empty, meas-np ok  
; <ex>B reached a height of 3 ft
; <nex>
; <todo>
; </type>
p_np_ptcl-of_le := p_prtcl_lexent.

addin_cp_basic_prep_synsem := basic_prep_nomod_synsem & cp_addin_tam_pn.
addin_cp_prep_nomod_synsem := gen_prep_nomod_synsem & cp_addin_tam_pn.

; 'Kim hired more consultants than Abrams did'
; <type val="p_cp_ptcl-ell_le">
; <description>Prep, S-elided, particle         
; <ex>B hired more than C did.
; <nex>
; <todo>
; </type>
p_cp_ptcl-ell_le := basic_p_prtcl_lexent &
  [ SYNSEM addin_cp_basic_prep_synsem &
    [ LOCAL 
      [ CAT.VAL [ COMPS < synsem & #keycomp &
                        [ LOCAL [ CAT [ HEAD verb & 
                                             [ MINORS.ALTMIN ellipsis_rel ],
                                        VAL [ SUBJ *anti_list*,
                                              COMPS < > ],
                                        MC - ],
                                  CONT.HOOK.LTOP #ltop ],
                          NONLOC non-local_none ] >,
		  KCMP #keycomp ],
        CONT.HOOK.INDEX #ltop ],
      NONLOC.SLASH 0-dlist ] ].

p_cp_ptcl-gap_lexent := gen_p_prtcl_lexent &
  [ SYNSEM addin_cp_prep_nomod_synsem &
    [ LOCAL 
      [ CAT.VAL [ COMPS < synsem & #keycomp &
                        [ LOCAL [ CAT [ HEAD verb & 
                                             [ MINORS.ALTMIN non_ellipt_rel,
					       TAM indic_tam ],
                                        VAL [ SUBJ *anti_list*,
                                              COMPS < > ],
                                        MC - ],
                                  CONT.HOOK [ LTOP #ltop,
					      INDEX.SF basic-prop ] ] ] >,
		  KCMP #keycomp ],
        CONT.HOOK.INDEX #ltop ],
      NONLOC.SLASH 0-dlist ] ].

; <type val="p_cp_ptcl-npgap_le">
; <description>Prep, S-with-NP-gap, particle       
; <ex>B hired more than C hired.
; <nex>
; <todo>
; </type>
p_cp_ptcl-npgap_le := p_cp_ptcl-gap_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ NONLOC.SLASH <! [ CAT.HEAD noun,
						       CONT.HOOK [ LTOP #nhand,
								   INDEX #ind &
								      ref-ind],
						       AGR #slagr ] !> ] >,
		   CONT [ HOOK.XARG #ind,
			  RELS <! [ PRED udef_q_rel,
				    ARG0 #ind,
				    RSTR #rhand,
				    CFROM #cfrom, CTO #cto ],
				  [ LBL #nhand,
				    ARG0 #ind,
				    PRED generic_entity_rel,
				    CFROM #cfrom, CTO #cto ] !>,
			  HCONS <! qeq & [ HARG #rhand,
					   LARG #nhand ] !> ],
		   AGR #slagr ],
    ORTH [ FROM #cfrom, TO #cto ] ].

; <type val="p_cp_ptcl-ppgap_le">
; <description>Prep, S-with-PP-gap, particle       
; <ex>B arrived as soon as we disappeared.
; <nex>
; <todo>
; </type>
p_cp_ptcl-ppgap_le := p_cp_ptcl-gap_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ NONLOC.SLASH <! [ CAT.HEAD mobile & 
							    [ MOD < synsem > ],
						       CONT.HOOK.XARG #event &
							  non_expl ] !> ] >,
		   CONT [ HOOK.XARG #event,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

; DPF 8-Jan-02 - Added constraint on SPR to exclude measure-NP specifiers, as
; in "*There are a book in the office"
; DPF 1-Jun-09 - Re 8-Jan-02: But this also excludes coordinated sprs, as in
; 'Kim arrived nearly but not entirely in readiness.'  So 
p_reg_lexent := prep_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN non_temp_nom_rel,
				   OPT - ] > ].


; DPF 25-oct-05 - Make [PRD +] to force measure-NP specs to be inflected:
; "ten feet under the ground" not "*ten foot under the ground".  
; <type val="p_np_i-reg_le">
; <description>Prep, np, non-temp               
; <ex>B stood behind C.
; <nex>
; <todo>
; </type>
p_np_i-reg_le := p_reg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].

; DPF 02-Apr-02 - blocks e.g. "an office by Sandy" as in "kim was shown an 
; office by Sandy".  Hack, since it also blocks "Kim lives right by the river"
; DPF 31-oct-03 - Changed this constraint from SPR < unexpressed > to 
; restriction excluding measure NPs which are now [HEAD noun].
; DPF 18-mar-05 - Further constrained to locative sense which does not take
; gerundive complements, and introduce separate "by" for "by means of", to
; enable blocking of unwanted coordinations such as "from here and by arriving"
; And further constrained to prevent stranding, though this may be too strong:
; "?Which library is that tree by?"

; <type val="p_np_i-dgsp_le">
; <description>Prep, np, no meas-np specifier   
; <ex>B stood right by C.
; <nex>
; <todo>
; </type>
p_np_i-dgsp_le := p_reg_lexent &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                           COMPS < canonical_synsem &
                                   [ --SIND.SORT entity ] > ] ].

; For "from" of "ten weeks from now" where in AmEng we block "he'll be here
; from now".

; <type val="p_np_i-oblsp_le">
; <description>Prep, np, obl specifier          
; <ex>B arrives a week from now.
; <nex>
; <todo>
; </type>
p_np_i-oblsp_le := p_temp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < expressed_synsem >,
                             COMPS < [ OPT -,
                                       LEX + ] > ],
             LKEYS.--COMPKEY temp_abstr_rel ] ].

; 'by hiring Abrams'
; <type val="p_np_i-ger_le">
; <description>Prep, np, gerund                 
; <ex>B won by singing well.
; <nex>
; <todo>
; </type>
; DPF 29-may-09 - Relaxed MOD..HEAD to include nominals, as in
; 'Kim, by arriving, surprised us.'
p_np_i-ger_le := p_reg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD n_or_v_or_a ] >,
                       VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                             COMPS < canonical_synsem &
                                     [ LOCAL.CAT.HEAD supnoun,
                                       --SIND.SORT nom-event ] > ] ] ].

; DPF 24-Oct-01 - Added identity of AGR..PN, DIV and NP comp's AGR..PN, DIV to
; support agreement in partitives, as in "none of the rice arrives" but "*none
; of the rice arrive"
; DPF 1-Mar-02 - Removed TAM.TENSE no_tense since this blocked predicative 
; of-PP as in "this picture is of Sandy".  Also replaced
; [MOD..MIN never_unify_rel] with never_unify_event_rel since it blocked the 
; no-copula "a chance of rain".
; DPF 17-Apr-03 - Identified prep's ALTMIN with its complement's MIN, to
; preserve visibility of the embedded NP's MIN for NP's like
; 'both of the days' where this can still serve as an adverbial modifier,
; while 'both of the chairs' cannot.
; DPF 2-Sept-04 - Restricted MOD..INDEX to ref-ind, to block "a bit of rain"
; as a no_copula construction (contra 1-Mar-02 view - now treat those as
; NP fragments).

; DPF 31-May-02 - Constrain to only modify nominals.
; <type val="p_np_i-nsp-ngap_le">
; <description>Prep, np, no gap, no specifier   
; <ex>B won nothing but the gold
; <nex>
; <todo>
; </type>
p_np_i-nsp-ngap_le := prep_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD basic_noun ] >,
                       VAL [ SPR < unexpressed >,
                             COMPS < [ OPT -,
                                       NONLOC.SLASH 0-dlist ] > ] ] ].

p_temp_lexent :=  basic_prep_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT [ HEAD.MINORS.MIN temp_loc_rel,
                       VAL.COMPS < synsem & 
                                 [ LOCAL [ CAT [ HEAD nominal &
                                                      [ CASE non_nom,
                                                        POSS - ],
                                                 VAL [ SUBJ *olist*,
                                                       SPR *olist*,
                                                       COMPS < > ],
                                                 MC na ],
                                           CONJ cnil ],
                                   OPT - ] > ] ] ].

; <type val="p_np_i-tmp_le">
; <description>Prep, np, temporal               
; <ex>The game on Monday is here
; <nex>
; <todo>
; </type>
p_np_i-tmp_le := p_temp_lexent.

; <type val="p_np_i-tmp-vm_le">
; <description>Prep, np, temporal, vp mod       
; <ex>B had won by Friday.
; <nex>
; <todo>
; </type>
p_np_i-tmp-vm_le := p_temp_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_p ] >,
                       VAL.SPR < [ LOCAL.CAT.HEAD adv ] > ] ].

; This looks tempting, but prevents e.g. "We camped two kilometers before the
; bridge."
#|
; 'before'
p_temp_spr_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ --SIND.SORT time ] >,
                           COMPS < [ OPT - ] > ] ].
|#

; Used e.g. for "from", as in "from under the table"
; DPF 6-Apr-01 - Also used for "worth" as in "ten dollars worth of food"
; DPF 01-sept-04 - Removed PRD + since it prevents "Kim put it back in the box"
; DPF 29-sept-05 - Added COMPS..PRD + to block depictives as complements:
; "*Kim arrived from happy."
; DPF 21-may-06 - Changed MOD n_or_v to MOD n_or_v_or_a

p_ppcomp_lexent := basic_prep_word &
  [ SYNSEM one_arg_prep_synsem &
	 [ LOCAL [ CAT [ HEAD [ PRD +,
                                TAM.TENSE tense,
                                MOD < [ LOCAL.CAT 
                                         [ HEAD subst,
                                           VAL.SPR < synsem_min > ] ] > ],
                         VAL.COMPS < synsem &
				   [ --MIN #min,
                                     LOCAL [ CAT [ HEAD prep &
                                                        [ PRD + ],
						   VAL [ SPR *olist*,
							 COMPS < > ] ],
					     CONJ cnil ] ] > ],
                   CONT [ HOOK.XARG non_expl,
                          RELS <! prep_relation !>,
                          HCONS <! !> ] ],
           NONLOC.SLASH 0-dlist,
           LKEYS.--COMPKEY #min ] ].

p_pp_i-coprd_lexent := p_ppcomp_lexent &
  [ SYNSEM one_arg_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD.PRD +,
              VAL.COMPS < [ OPT -,
                            --MIN loc_abstr_rel,
                            LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #ind ] ],
                            NONLOC.REL 0-dlist,
                            --SIND event ] > ],
        CONT.HOOK [ LTOP #ltop,
                    INDEX #ind ] ] ] ].

;; DPF 2012-04-02 - Restrict complement to nonlex_synsem to avoid analysis for
;; |in on|
; <type val="p_pp_i-coprd_le">
; <description>Prep, pp, no lex-pp complements, not modifying PPs
; <ex>B wins except on clay.
; <nex>
; <todo>
; </type>
p_pp_i-coprd_le := p_pp_i-coprd_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD n_or_v_or_a ] >,
		       VAL.COMPS < nonlex_synsem > ] ].

; <type val="p_pp_i-coprd-lx_le">
; <description>Prep, pp, can also take lex-pps and modify PPs
; <ex>B directed from within.
; <nex>
; <todo>
; </type>
p_pp_i-coprd-lx_le := p_pp_i-coprd_lexent.

; 'from now on', maybe 'from two to four'
p_ditrans_lexent := noncs-m &
  [ SYNSEM ditrans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL [ CONJ cnil ],
                                            OPT - ], 
                                 synsem & [ LOCAL.CAT.MC na,
                                            NONLOC.QUE.LIST *paramlist*,
                                            OPT -,
                                            PUNCT.LPUNCT no_punct ] >,
                   CONT.HOOK.LTOP #ltop ],
           LKEYS [ KEYREL.LBL #ltop,
                   --COMPKEY #cmin,
                   --+COMPKEY #cmin,
                   --OCOMPKEY #ocmin,
                   --+OCOMPKEY #ocmin ] ] ].

; <type val="p_np-ptcl_i_le">
; <description>Prep, np, prtcl, only 'from'     
; <ex>B won from Monday on.
; <nex>
; <todo>
; </type>
p_np-ptcl_i_le := p_ditrans_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT nomp_cat_acc_min,
                                             CONT.HOOK [ LTOP #ltop,
							 INDEX index ] ] ],
                                   [ LOCAL [ CAT.VAL.COMPS < synsem >,
                                             CONT.HOOK.LTOP #ltop ],
                                     NONLOC non-local_none,
                                     LEX + ] >,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! relation !>,
                          HCONS <! !> ] ] ].
                                                 
;; DPF 2012-08-01 - Changed to make the second PP complement supply its own 
;; semantics, rather than being a semantically empty PP.
;;
p_ditrans_from_to_lexent := p_ditrans_lexent &
  [ SYNSEM 
    [ LOCAL [ CAT.VAL.COMPS < [ --SIND #arg2,
                                LOCAL.CAT.HEAD.MINORS 
                                       [ MIN nonpro_rel,
                                         ALTMIN quant_rel ] ],
                              [ LOCAL [ CAT.VAL.COMPS < >,
                                        CONT.HOOK [ LTOP #ltop,
						    INDEX non_expl,
						    XARG #xarg ] ] ] >,
	      CONT.HOOK [ LTOP #ltop,
			  XARG #xarg ] ],
      LKEYS.KEYREL.ARG2 #arg2 ] ].

; <type val="p_np-pp_i-frm-to_le">
; <description>Prep, np, pp, only 'from'        
; <ex>B won from April to July.
; <nex>
; <todo>
; </type>
p_np-pp_i-frm-to_le := p_ditrans_from_to_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ CAT nomp_cat_acc_min,
                                               CONT.HOOK [ LTOP #ltop,
							   INDEX index ] ],
                   CONT [ HOOK.LTOP #ltop,
			  RELS <! relation !>,
                          HCONS <! !> ] ] ].

;; DPF 2012-12-21 - Added more general --MIN gen_nom_nbar_rel instead of 
;; non_temp_nbar_rel.
;;
; <type val="p_nb-pp_i-frm-to_le">
; <description>Prep, nbar, pp, only 'from'      
; <ex>B ran from room to room.
; <nex>
; <todo>
; </type>
;;
p_nb-pp_i-frm-to_le := p_ditrans_from_to_lexent &
  [ SYNSEM [ LOCAL
             [ CAT.VAL.COMPS
                      < abstr_lex_synsem &
                        [ OPT -,
                          --MIN gen_nom_nbar_rel,
                          LOCAL [ CAT [ HEAD noun,
                                        VAL [ SPR < synsem &
                                                    [ LOCAL.CAT.HEAD det,
                                                      NONLOC [ SLASH 0-dlist,
                                                               QUE 0-dlist ]]>,
                                              COMPS < > ] ],
                                  CONT.HOOK [ LTOP #nhand,
                                              INDEX #arg ] ],
                          NONLOC.SLASH 0-dlist ],
                        [ --MIN _to_p_nbar_rel ] >,
               CONT [ RELS <! relation,
			  #altkeyrel &
                          [ PRED udef_q_rel,
                            ARG0 #arg,
                            RSTR #rhand ] !>,
                      HCONS <! qeq & [ HARG #rhand,
                                       LARG #nhand ] !> ] ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; DPF 13-Mar-02 - Changed PRD - to PRD +: "the response was as expected"
; DPF 2-Jul-02 - Added MOD..HEAD verb to prevent spurious analysis for e.g.
; "Abrams sees Browne as being a competent manager."
; DPF 8-Jun-03 - Split this "as" into two lexical entries, one with an
; independent rel, taking verbal (PRD +) complements and able to serve as a 
; modifier phrase or copular complement, and one with a selected_rel
; taking adj-or-prep complements, but MOD < >. and nonprd.
;; DPF 2012-06-15 - Corrected semantic composition so the ARG2 is a handle,
;; not the VP's event.

; <type val="p_vp_i_le">
; <description>Prep, vp(prd), only 'as'         
; <ex>The price was as expected.
; <nex>
; <todo>
; </type>
p_vp_i_le := basic_prep_word &
  [ SYNSEM basic_one_arg_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ PRD +,
                     MOD < [ LOCAL.CAT.HEAD verb ] > ],
              VAL [ COMPS < synsem &
                            [ LOCAL [ CAT prd_cat & [ HEAD verb ],
                                      CONJ cnil,
                                      CONT.HOOK [ LTOP #cltop,
						  XARG #xarg ] ],
                              NONLOC [ SLASH 0-dlist,
                                       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT - ] >,
                    SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                [ MIN much_deg_rel,
                                                  ALTMIN abstr_meas_nom_rel ],
                                          VAL [ SPR *olist*,
						SPEC < synsem >,
						COMPS *olist* ] ],
				    CONT.HOOK [ LTOP #ltop,
                                                XARG #ind ] ] ] > ] ],
        CONT [ HOOK [ LTOP #ltop,
		      INDEX #ind,
		      XARG #xarg ],
               RELS <! prep_relation & [ LBL #ltop,
					 ARG0 #ind,
					 ARG2 #arg2 ] !>,
               HCONS <! qeq & [ HARG #arg2, LARG #cltop ] !> ] ] ] ].

; <type val="p_vp_i-inf_le">
; <description>Prep, vp(inf), only 'as'         
; <ex>The price was not so high as to scare us
; <nex>
; <todo>
; </type>
p_vp_i-inf_le := basic_prep_word &
  [ SYNSEM basic_trans_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ PRD +,
                     MOD < anti_synsem > ],
              VAL [ COMPS < synsem &
                            [ LOCAL [ CAT vp_inf_cat,
                                      CONJ cnil,
                                      CONT.HOOK #hook & [ LTOP #ltop,
							  INDEX #ind ] ],
                              NONLOC [ SLASH 0-dlist,
                                       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT - ] >,
                    SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                [ MIN much_deg_rel,
                                                  ALTMIN abstr_meas_nom_rel ],
                                          VAL.SPR *olist* ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #ind ] ] ] > ] ],
        CONT [ HOOK #hook,
               RELS <! prep_relation & [ LBL #ltop,
                                         ARG0 #ind ] !>,
               HCONS <! !> ] ] ] ].

; <type val="p_prd_ptcl_le">
; <description>Prep, prdp, sem empty            
; <ex>B strikes C as clever.
; <nex>
; <todo>
; </type>
p_prd_ptcl_le := basic_prep_word &
  [ SYNSEM basic_prep_nomod_synsem &
           [ LOCAL 
             [ CAT [ HEAD.PRD -,
                     VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                           COMPS < synsem &
                                   [ LOCAL [ CAT prd_cat,
                                             CONJ cnil,
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #ind,
                                                         XARG #xarg ] ],
                                     NONLOC [ SLASH 0-dlist,
                                              QUE 0-dlist,
                                              REL 0-dlist ],
                                     OPT - ] > ] ],
               CONT [ HOOK [ LTOP #ltop,
                             INDEX #ind,
                             XARG #xarg ],
                      RELS <! !>,
                      HCONS <! !> ] ] ] ].


; when: "use of this device when shaving/angry/in Berlin is ..."
; <type val="p_prd_i_le">
; <description>Prep, prdp, n mod, only 'when'   
; <ex>Kids when hungry complain.
; <nex>
; <todo>
; </type>
p_prd_i_le := basic_prep_word &
  [ SYNSEM basic_trans_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ PRD +,
                     MOD < [ LOCAL.CAT.HEAD noun ] > ],
              VAL [ COMPS < synsem &
                            [ LOCAL [ CAT prd_cat,
				      CONT.HOOK [ LTOP #ltop,
						  XARG non_expl-ind ],
                                      CONJ cnil ],
                              NONLOC [ SLASH 0-dlist,
                                       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT - ] >,
                    SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                [ MIN much_deg_rel,
                                                  ALTMIN abstr_meas_nom_rel ],
                                          VAL.SPR *olist* ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #arg0 ] ] ] > ] ],
        CONT [ HOOK [ LTOP #ltop,
                      INDEX #arg0 & non_conj_event ],
               RELS <! prep_relation !>,
               HCONS <! !> ] ] ] ].

; Prepositions that don't modify nominals - e.g, 'until'

; DPF 25-oct-05 - Make [PRD +] to force measure-NP specs to be inflected:
; "ten feet under the ground" not "*ten foot under the ground".  

p_no_nmod_lexent := prep_word &
  [ SYNSEM.LOCAL.CAT [ HEAD [ MOD < [ LOCAL.CAT.HEAD v_or_a_or_p ] >,
                              PRD + ],
                       VAL.COMPS < [ OPT - ] > ] ].

; DPF 1-May-03 - Additionally, block phrasal degree specifiers to avoid
; spurious reading for "Abrams showed an office to Browne".
; DPF 26-sep-07 - Added [CASE obliq] to allow us to block these from the
; it-cleft copula as in "It was to Kim that we ran".
; DPF 2010-08-16 - Added restriction that NP complement is not temporal,
; though this is not principled, to avoid spurious analyses for e.g.
; "We came down early".  FIX someday ??
; DPF 2010-09-17 - Re 2010-08-16: This blocks "continued into the evening".
; so split into two subtypes, one excluding temporals, the other not.

p_np_i-nnm_lexent := p_no_nmod_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE obliq,
		       VAL.SPR < [ LEX + ] > ] ].
;
; 'into'
; <type val="p_np_i-nnm_le">
; <description>Prep, NP, no noun mod            
; <ex>B ran up the hill.
; <nex>
; <todo>
; </type>
p_np_i-nnm_le := p_np_i-nnm_lexent.

; <type val="p_np_i-nnm-mal_le">
; <description>Prep, NP, no noun mod, robust
; <ex>B ran to to the hill.
; <nex>
; <todo>
; </type>
p_np_i-nnm-mal_le := p_np_i-nnm_lexent &
  [ GENRE robust ].

; "down"
; <type val="p_np_i-nnm-nt_le">
; <description>Prep, NP, no noun mod, no temporal complement
; <ex>B ran up the hill.
; <nex>
; <todo>
; </type>
p_np_i-nnm-nt_le := p_no_nmod_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE obliq,
		       VAL [ SPR < [ LEX + ] >,
			     COMPS < [ --MIN non_temp_nom_rel ] > ] ] ].

; Additionally block pronominal NP complements - e.g. 'as'
; <type val="p_np_i-nnm-npro_le">
; <description>Prep, NP, nonpro, no noun mod    
; <ex>B waited until the end.
; <nex>
; <todo>
; </type>
p_np_i-nnm-npro_le := p_no_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN nonpro_rel ] > ].

; For colon lexical entry
; <type val="p_np_i-nnm-ngap_le">
; <description>Prep, NP, nonpro, no gap |:|     
; <ex>C likes cats: red ones.
; <nex>
; <todo>
; </type>
p_np_i-nnm-ngap_le := p_no_nmod_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MOD < synsem >,
				CASE obliq ],
                         VAL.SPR < anti_synsem_min > ],
             NONLOC.SLASH 0-dlist,
             LKEYS.KEYREL prep_notense_relation ] ].

; "Case-marking" prepositions, which cannot be modifiers
; and (let's assume) also cannot be modified, so stipulate [ SUBJ < > ].
;
; DPF 10-Jun-99 - But they can take specifiers: "Kim fell nearly to the bottom"

gen_prep_nomod_synsem := lex_synsem & prep_with_spr_synsem &
			 prep_p_synsem &
  [ LOCAL [ CAT [ HEAD prep & [ MOD < > ],
		  VAL [ SPR < [ OPT +,
                                LOCAL [ CAT [ HEAD adv,
                                              VAL [ SPR *olist*,
						    SPEC < synsem >,
                                                    COMPS < > ] ],
                                        CONT.HOOK [ LTOP #ltop,
                                                    XARG #arg0 ] ] ] >,
                        COMPS < synsem & 
				[ OPT -,
                                  --MIN #cmin ] > ] ] ],
    LKEYS [ KEYREL basic_arg12_relation & [ PRED prep_rel,
                                            LBL #ltop,
                                            ARG0 #arg0 ],
            --COMPKEY #cmin ] ].

basic_prep_nomod_synsem := gen_prep_nomod_synsem & basic_one_arg.

prep_nomod_synsem := basic_prep_nomod_synsem &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL [ SPR < [ --MIN much_deg_rel ] >,
                        COMPS < [ --SIND #ind,
                                  NONLOC [ QUE.LIST *paramlist*,
                                           SLASH 0-dlist ] ] > ] ],
	    CONT [ HOOK [ INDEX #arg0,
                          XARG #pind ],
                   RELS <! prep_relation & #keyrel !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL #keyrel &
                 [ ARG0 #arg0,
                   ARG1 #pind,
                   ARG2 #ind ] ].

; Lexical PPs

basic_pp_word := noncqrs-hm-nab &
  [ SYNSEM lex_pp_synsem &
    [ LOCAL [ CAT.VAL.SPR < [ OPT +,
			      LOCAL.CAT.HEAD n_or_adv &
                                [ MINORS [ MIN much_deg_rel,
                                           ALTMIN abstr_meas_nom_rel ] ] ] >,
	      CONT [ RELS <! arg01_only_relation !>,
                     HCONS <! !> ] ] ] ].

pp_word := basic_pp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD prep & [ PRD +,
				     MOD < [ LOCAL.CAT.HEAD n_or_v_or_a ] > ]]].
		    

; 'astray'
; <type val="pp_-_i_le">
; <description>PP, intersective                 
; <ex>B saw C above.
; <nex>
; <todo>
; </type>
pp_-_i_le := pp_word.

; 'about'
; <type val="pp_-_i-nmb_le">
; <description>PP, non-mobile (no extrctn)      
; <ex>B hung about.
; <nex>
; <todo>
; </type>
pp_-_i-nmb_le := basic_pp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD prep_nonmob &
			    [ MOD < [ LOCAL.CAT.HEAD v_or_a_or_p,
				      MODIFD.RPERIPH - ] > ] ] ].

;; DPF 2012-07-25 - Changed MOD..HEAD to subst from v_or_a_or_p, to admit
;; |test cases:|.  This will add ambiguity, but so be it.
;;
; <type val="pp_-_i-cln_le">
; <description>PP, only for post-head colon
; <ex>B likes cats:
; <nex>
; <todo>
; </type>
pp_-_i-cln_le := basic_word &
  [ INFLECTD +,
    SYNSEM lex_pp_synsem &
	   [ LOCAL [ CAT [ HEAD prep_nonmob &
			        [ MOD < [ LOCAL.CAT.HEAD subst,
					  MODIFD.RPERIPH - ] >,
				  PRD + ],
			   VAL.SPR < anti_synsem_min >,
			   MC na ],
		     CONT [ RELS <! arg01_only_relation !>,
			    HCONS <! !> ],
		     CONJ cnil ],
	     NONLOC non-local_none,
	     PUNCT [ LPUNCT no_punct,
		     RPUNCT clause_or_no_punct ] ] ].

; DPF 25-mar-05 - Added hack [CASE obliq] to prevent particle PPs from
; fronting.
;
; <type val="pp_-_ptcl_le">
; <description>PP, sem empty                    
; <ex>B looked forward to it.
; <nex>
; <todo>
; </type>
pp_-_ptcl_le := noncqrs-hm-nab &
  [ SYNSEM basic_lex_pp_synsem &
           [ LOCAL [ CAT [ HEAD prep &
                                [ MINORS.MIN selected_rel & #min,
                                  MOD < >,
                                  PRD -,
                                  CASE obliq ],
                           VAL.SPR < > ],
                     CONT [ HOOK.XARG #xarg,
                            RELS <! !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL [ PRED #min,
                            ARG1 #xarg ] ] ].

; 'right away'
; <type val="pp_-_i-vm_le">
; <description>PP, vp mod                       
; <ex>B left right away.
; <nex>
; <todo>
; </type>
pp_-_i-vm_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a ] > ].

; 'each'
; <type val="pp_-_i-nm_le">
; <description>PP, noun mod                     
; <ex>We took two books each.
; <nex>
; <todo>
; </type>
pp_-_i-nm_le := pp_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ --MIN basic_nom_rel ] >,
                   CONT.HOOK.INDEX.E.TENSE no_tense ] ].

; 'PDT'
; <type val="pp_-_i-nm-hr_le">
; <description>PP, hour-noun modifier
; <ex>It begins at ten _PDT_.
; <nex>
; <todo>
; </type>
pp_-_i-nm-tm_le := pp_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ --MIN numbered_hour_rel ] >,
		     CONT.HOOK.INDEX.E.TENSE no_tense ],
	     LKEYS.KEYREL.PRED timezone_p_rel ] ].

; below, down, ...
pp_dir_lexent := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ --MIN nom_nbar_rel,
                                    LOCAL.CAT.HEAD noun ] >,
                            MINORS.MIN dir_rel ] ].

; <type val="pp_-_i-dir_le">
; <description>PP, directional                  
; <ex>B flew across.
; <nex>
; <todo>
; </type>
pp_-_i-dir_le := pp_dir_lexent.

; DPF 14-nov-05 - To avoid rampant ambiguity for now, make variant for "in"
; which restricts modification to nouns with SORT place - a hack. FIX.
; Also FIX name, since -nnm elsewhere signifies no-nmod.
; <type val="pp_-_i-dir-nnm_le">
; <description>PP, directional, no noun mod     
; <ex>B flew by.
; <nex>
; <todo>
; </type>
pp_-_i-dir-nnm_le := basic_pp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD prep &
                            [ MOD < [ --MIN nom_nbar_rel,
				      LOCAL [ CAT.HEAD noun,
					      CONT.HOOK.INDEX.SORT place ] ] >,
			      MINORS.MIN dir_rel ] ] ].
; 'after'
; <type val="pp_-_i-nm-tmp_le">
; <description>PP, temporal noun mod            
; <ex>B arrived the day after.
; <nex>
; <todo>
; </type>
pp_-_i-nm-tmp_le := pp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ --MIN basic_nom_rel,
                                    LOCAL.CAT.VAL.SPR 
                                                 < [ LOCAL.CAT.HEAD det ] >,
                                    --SIND ref-ind & [ SORT time ] ] >,
             LKEYS.KEYREL.ARG0.E.TENSE nontense ] ].

; Postpositions
pp_-_i-po_lexent := noncqrs-hm-nab &
  [ SYNSEM norm_lex_pp_synsem &
    [ LOCAL [ CAT [ HEAD prep & [ PRD +,
				  MOD < [ LOCAL.CAT.HEAD n_or_v_or_a ] >  ],
		    VAL.SPR < synsem_min & 
			      [ LOCAL
				[ CAT [ HEAD basic_noun,
					VAL [ SPR *olist*,
					      COMPS < >,
					      SPCMPS < > ] ],
				  CONT.HOOK.INDEX #ind ],
				NONLOC.QUE 0-dlist,
				MODIFD notmod_or_lmod,
				OPT - ] >,
		    POSTHD + ],
	      CONT [ RELS <! relation &
			   [ ARG2 #ind ] !>,
		     HCONS <! !> ] ] ] ].

;; DPF 2012-08-29 - Changed SPR..ALTMIN from indef_or_num_q_rel to 
;; implicit_q_rel to require only measure NPs, avoiding spurious ambiguity
;; for |a year ago|
;; DPF 2013-01-09 - Generalized SPR..MIN to abstr_meas_nom_rel in order to
;; also allow |We arrived a couple of days ago|
;;
; For 'ago', constrain SPR to be only temporal measure NPs.
; <type val="pp_-_i-po-tm_le">
; <description>PP, postposition, temporal       
; <ex>B arrived two days ago.
; <nex>
; <todo>
; </type>
pp_-_i-po-tm_le := pp_-_i-po_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --SIND.SORT time,
				 LOCAL.CAT.HEAD.MINORS
				     [ MIN abstr_meas_nom_rel,
				       ALTMIN implicit_q_rel,
				       NORM quantity_rel ] ] > ].

; For e.g. 'Kim's objections notwithstanding, we won't stay.'
; <type val="pp_-_i-po_le">
; <description>PP, postposition (ARG2 as spec)  
; <ex>Doubts notwithstanding, go
; <nex>
; <todo>
; </type>
pp_-_i-po_le := pp_-_i-po_lexent.

; DPF 10-sept-07 - Restrict MOD to RPERIPH - to avoid attaching after 
; depictives as in "things we are concerned about"
; <type val="pp_-_i-nnm_le">
; <description>PP, no noun mod                  
; <ex>B ran on.
; <nex>
; <todo>
; </type>
pp_-_i-nnm_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a_or_p,
                                  MODIFD.RPERIPH - ] > ].

; DPF 29-Nov-02 - Stipulate HOOK.XARG nothing to prevent these from appearing
; as complements of predicative 'be'.
; DPF 4-Feb-03 - But the HOOK of a modifier is now the HOOK of the hadj phrase,
; and a VP (with or without a PP modifier) has to present its XARG as the 
; index of its SUBJ, so it can't be 'nothing' - must be ref-ind.  And anyway,
; by-PPs can be complements of the copula: "The best route is by car".  So
; instead constrain subtype for e.g. "per" with incompatible value for TENSE.
; DPF 4-Feb-03 - Changed COMPS type from lex_synsem to abstr_lex_synsem to
; admit compound nouns, as in "I paid by credit card".

p_nbar_comp_lexent := basic_prep_word &
  [ SYNSEM [ LOCAL 
             [ CAT [ VAL [ SPR < [ NONLOC.SLASH 0-dlist ] >,
                           COMPS < [ OPT -,
                                     --MIN gen_nom_nbar_rel,
                                     LOCAL 
                                      [ CAT [ HEAD basic_noun &
						   [ MINORS.ALTMIN #sprmin,
						     CASE non_nom ],
                                              VAL [ SPR < synsem &
                                                   [ LOCAL.CAT.HEAD det,
                                                     NONLOC non-local_none,
						    --MIN #sprmin ] >,
                                                    COMPS < > ] ],
                                        AGR.DIV - ],
                                     NONLOC.SLASH 0-dlist ] > ],
                     POSTHD + ] ],
             LKEYS [ KEYREL prep_relation & [ ARG2 #arg ],
                     ALTKEYREL [ PRED udef_q_rel,
                                 ARG0 #arg ] ] ] ].

; DPF 9-jul-04 - But this blocks e.g. "per day", so make this constraint be
; specific to the lex entry for "by".
; DPF 27-aug-04 - Changed COMPS..MODIFD notmod to notmod_or_lmod to allow
; 'by private car' or 'by large Zodiac raft'.

basic_p_nbar_comp_spr_lexent := p_nbar_comp_lexent &
  [ SYNSEM basic_one_arg_prep_synsem &
    [ LOCAL [ CAT 
              [ HEAD.PRD +,
                VAL.COMPS < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN implicit_q_rel,
                                      CONT.HOOK.LTOP #nhand ],
                              --SIND #ind ] > ],
              CONT [ RELS.LIST < #keyrel, #altkeyrel, ... >,
                     HCONS.LIST < qeq & [ HARG #rhand,
                                          LARG #nhand ], ... > ] ],
      LKEYS [ KEYREL #keyrel & [ ARG2 #ind & non_expl ] ,
              ALTKEYREL #altkeyrel & [ RSTR #rhand ] ] ] ].

p_nbar_comp_spr_lexent := basic_p_nbar_comp_spr_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
              VAL [ SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                               [ MIN much_deg_rel,
                                                 ALTMIN abstr_meas_nom_rel ],
                                          VAL [ SPR *olist*,
                                                SPEC < synsem >,
                                                COMPS < > ] ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #arg0 ] ] ] >,
                    COMPS < [ LOCAL.CAT [ HEAD.MINORS.MIN #ckey,
                                          VAL.SPR 
                                            < [ LOCAL.AGR.DIV - ] > ] ] > ] ],
        CONT [ RELS <! relation, relation !>,
               HCONS <! qeq !> ] ],
      LKEYS [ KEYREL [ LBL #ltop,
                       ARG0 #arg0 ],
              --COMPKEY #ckey,
              --+COMPKEY #ckey ] ] ].

; DPF 12-Apr-03 - Added COMP..MIN non_temp_nom_rel to block e.g. means reading
; for "by three o'clock'
; DPF 21-Mar-07 - Since this also blocks "sorted by date", instead constrain
; the SPR of the nbar-complement to be HEAD det, which will still block this
; analysis for "by three o'clock".  If sustainable, then lose the type
; p_nb_i-per_le.  FIX.
; DPF 03-oct-08 - Need some general mechanism to block unwanted frequently
; occurring phrases like "as well".  For now, co-opt NORM attribute, though
; need to FIX.

; <type val="p_nb_i_le">
; <description>Prep, nbar, nontemp noun         
; <ex>B arrived by car.
; <nex>
; <todo>
; </type>
p_nb_i_le := p_nbar_comp_spr_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < abstr_lex_synsem & 
				 [ MODIFD notmod_or_lmod,
				   LOCAL.CAT.HEAD.MINORS.NORM norm_rel ] > ].
; <type val="p_nb_i-per_le">
; <description>Prep, nbar, temp noun ok         
; <ex>One cat per dog is good.
; <nex>
; <todo>
; </type>
p_nb_i-per_le := p_nbar_comp_spr_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD noun_or_nomger,
					      VAL.SPR.FIRST synsem ] ] > ].

; For preps like "as" which can take phrasal nbar complements
; <type val="p_nb_i-phr_le">
; <description>Prep, nbar (phrasal)             
; <ex>C as new kid was teased.
; <nex>
; <todo>
; </type>
p_nb_i-phr_le := p_nbar_comp_spr_lexent & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ MODIFD notmod_or_lmod,
				   LOCAL.CAT.HEAD.MINORS.NORM norm_rel ] > ].

; 'step by step'
; <type val="p_nb_i-oblsp_le">
; <description>Prep, nbar, oblig nbar spec      
; <ex>B approached step by step.
; <nex>
; <todo>
; </type>
p_nb_i-oblsp_le := basic_p_nbar_comp_spr_lexent &
  [ SYNSEM [ LOCAL 
	     [ CAT.VAL [ SPR < [ OPT -,
				 --MIN gen_nom_nbar_rel,
				 LEX +,
				 LOCAL [ AGR.PNG.PN unsp_pernum,
					 CAT [ VAL [ SPCMPS < >,
						     COMPS < > ],
					       POSTHD + ],
					 CONT.HOOK [ LTOP #sltop,
						     INDEX #arg &
							  nonconj_ref-ind ] ],
				 LKEYS.KEYREL.PRED #pred ] >,
			 COMPS < abstr_lex_synsem &
				 [ LEX +,
				   MODIFD notmod_or_lmod,
				   LKEYS.KEYREL.PRED #pred ] > ],
	       CONT [ RELS <! relation, 
			      [ CFROM #cfrom, CTO #cto ],
			      #alt2keyrel &
			      [ PRED udef_q_rel,
				ARG0 #arg,
				RSTR #rstr,
				CFROM #cfrom, CTO #cto ] !>,
		      HCONS <! qeq, qeq & [ HARG #rstr,
					    LARG #sltop ] !> ] ],
	     LKEYS.ALT2KEYREL #alt2keyrel ] ].

; DPF 24-Jun-01 - Added SUBJ <anti_synsem_min> to block 'per' reading: "Abrams
; is a manager"
; DPF 29-Nov-02 - But [E.TENSE no_tense] should be enough
; DPF 5-Sep-03 - Added SPR < anti_synsem_min > to prevent spurious readings 
; like for "three times a day"
; DPF 27-Sep-03 - no_tense won't be enough to block this as copula complement
; since all PPs are no_tense.  Instead use new value 'nontense'.
;; DPF 2012-09-21 - Pushed COMPS < abstr_lex_synsem > down to subtype, since
;; want to allow |She ran for governer of Florida|
;;
p_nbar_comp_nospr_lexent := p_nbar_comp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < anti_synsem_min > ],
             LKEYS.KEYREL.ARG0.E [ TENSE nontense,
                                   ASPECT no_aspect ] ] ].

; Added MOD..ALTMIN no_rel to prevent "a person" from modifying e.g. gerunds.
; 10-Nov-01 - But now gerunds are unmarked for ALTMIN, since they need to be
; able to appear as left members of noun-noun compounds.  
; DPF 3-Jul-02 - Added [MOD..LEX +] to block spurious analyses as for 
; e.g. "every manager who has a bookcase"
; DPF 30-Aug-01 - Added COMPS <[MODIFD notmod]> to block "a ten percent
; probability" with a_per.
; DPF 16-oct-03 - Changed MOD..ALTMIN to impl_or_expl_q_rel to exclude proper 
; nouns, to still block e.g. "Kim a book".
; DPF 19-may-05 - Added MOD..NORM no_rel to prevent modification of
; e.g. locative 'there', while still avoiding modification of gerunds, as
; in 'hiring a consultant'
; DPF 26-mar-06 - But this blocks "ten days a week", so changed NORM to
; norm_rel (still blocks modif of 'there' and gerunds).
; DPF 28-aug-07 - Added COMPS..NORM quantity_or_no_rel to block unusual nouns 
; like in "a little".
; DPF 20-jun-08 - Changed MOD..MIN nonpro_rel to gen_nom_nbar_rel to exclude
; proper names, to avoid e.g. "Browne an office and interviewed programmers"

; 'a (per)'
p_nbar_comp_nmod_lexent := p_nbar_comp_nospr_lexent &
  [ SYNSEM basic_trans_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ MOD < [ LOCAL.CAT [ HEAD basic_noun &
                                         [ MINORS [ MIN gen_nom_nbar_rel,
                                                    ALTMIN impl_or_expl_q_rel ] ] ],
                             NONLOC.QUE 0-dlist,
                             PUNCT.RPUNCT pair_or_no_punct,
			     MODIFD notmod ] >,
                     MINORS.ALTMIN no_rel,
                     PRD - ],
              VAL.COMPS < abstr_lex_synsem &
			  [ LOCAL [ CAT.HEAD.MINORS.NORM quantity_or_no_rel,
                                    AGR.PNG.PN 3s,
                                    CONT.HOOK.LTOP #nhand ],
                            MODIFD notmod_or_rmod ] > ],
        CONT [ HOOK.INDEX non_conj_event,
	       RELS <! #keyrel, #altkeyrel !>,
               HCONS <! qeq & [ HARG #rhand,
                                LARG #nhand ] !> ] ],
      LKEYS [ KEYREL #keyrel,
              ALTKEYREL #altkeyrel & [ RSTR #rhand ] ] ] ].

; <type val="p_nb_i-nm_le">
; <description>Prep, nbar, noun mod, con onset  
; <ex>B read ten pages a day.
; <nex>
; <todo>
; </type>
p_nb_i-nm_le := p_nbar_comp_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET con_or_unk ] > ].

; <type val="p_nb_i-nm-an_le">
; <description>Prep, nbar, noun mod, voc onset  
; <ex>B read ten pages an hour.
; <nex>
; <todo>
; </type>
p_nb_i-nm-an_le := p_nbar_comp_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET voc_or_unk ] > ].

;; DPF 2012-12-18 - Added quant_rel for contentful p_nb `to', and removed it
;; from the ditrans p_nb-pp `from', since the LBL of the bare nbar is not
;; visible to the `from'.
;;
p_nb_i-nmd_lexent := p_nbar_comp_nospr_lexent &
  [ SYNSEM basic_prep_nomod_synsem &
    [ LOCAL.CAT [ HEAD.PRD -,
		  VAL [ SPR < [ --MIN much_deg_rel ] >,
			COMPS < [ LOCAL [ CAT.HEAD.PRD - ] ] > ] ] ] ].

; 'of' in "what kind of book(s)'
; 'the 25th to 28th of May'
;
; <type val="p_nb_i-nmd_le">
; <description>Prep, nbar, no mod               
; <ex>That kind of dog barks.
; <nex>
; <todo>
; </type>
p_nb_i-nmd_le := p_nb_i-nmd_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MINORS.ALTMIN #min ],
			 VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nhand,
							 INDEX #index ],
				       --MIN #min ] > ],
		   CONT [ HOOK.INDEX #index,
			  RELS <! [ PRED udef_q_rel,
				    ARG0 #index,
				    RSTR #rhand,
				    CFROM #cfrom, CTO #cto ] !>,
			  HCONS <! qeq & [ HARG #rhand,
					   LARG #nhand ] !> ] ],
    ORTH [ FROM #cfrom, TO #cto ] ].

; <type val="p_nb_i-nmd-to_le">
; <description>Prep, nbar, no mod, contentful
; <ex>From week _to_ week
; <nex>
; <todo>
; </type>

p_nb_i-nmd-to_le := p_nbar_comp_nospr_lexent &
  [ SYNSEM basic_prep_nomod_synsem &
    [ LOCAL [ CAT [ HEAD.PRD -,
		    VAL [ SPR < [ --MIN much_deg_rel ] >,
			  COMPS.FIRST.LOCAL [ CAT.HEAD.PRD -,
					      CONT.HOOK [ LTOP #nhand,
							  INDEX #objind ] ] ] ],
	      CONT [ HOOK [ LTOP #ltop,
			    INDEX #event,
			    XARG #xarg ],
                     RELS <! #keyrel &
                                 [ LBL #ltop,
                                   PRED prep_mod_rel,
                                   ARG0 #event &
				       [ E.ASPECT no_aspect ],
                                   ARG1 #xarg,
                                   ARG2 #objind ],
			     #altkeyrel !>,
		     HCONS <! qeq & [ HARG #rhand,
                                      LARG #nhand ] !> ] ],
      LKEYS [ KEYREL #keyrel,
              ALTKEYREL #altkeyrel & [ RSTR #rhand ] ] ] ].

; 'planes leave _every_ four hours'
; <type val="p_np_i-msr_le">
; <description>Prep, NP, measure phr            
; <ex>B arrives every four hours
; <nex>
; <todo>
; </type>
p_np_i-msr_le := basic_prep_word &
  [ SYNSEM one_arg_prep_synsem &
    [ LOCAL 
      [ CAT 
        [ HEAD.PRD +,
          VAL 
          [ SPR < [ NONLOC.SLASH 0-dlist ] >,
            COMPS < abstr_lex_synsem &
                    [ OPT -,
                      LOCAL 
                      [ CAT [ HEAD noun &
				   [ MINORS.MIN meas_nom_rel ],
                              VAL [ SPR < synsem &
					  [ --MIN degree_rel,
					    NONLOC [ SLASH 0-dlist,
						     QUE 0-dlist ] ] >,
                                    COMPS < > ] ],
                        CONT.HOOK.INDEX #nind,
                        AGR.PNG.PN 3s ],
                      NONLOC.SLASH 0-dlist ] > ],
          POSTHD + ],
        CONT [ HOOK [ LTOP #plbl,
                      INDEX #pind,
                      XARG #arg1 ],
               RELS <! prep_relation & #keyrel &
                       [ LBL #plbl,
                         PRED loc_nonsp_rel,
                         ARG0 #pind,
                         ARG1 #arg1,
                         ARG2 #iind ],
		       #altkeyrel &
                       [ LBL #ihand,
                         PRED interval_rel,
                         ARG0 #iind,
                         ARG1 #nind ],
		       #alt2keyrel &
                       [ PRED udef_q_rel,
                         ARG0 #iind,
                         RSTR #rhand ] !>,
               HCONS <! qeq & [ HARG #rhand,
                                LARG #ihand ] !> ] ],
      LKEYS [ KEYREL #keyrel,
	      ALTKEYREL #altkeyrel,
	      ALT2KEYREL #alt2keyrel ] ] ].


;; Temporal prepositions:

; "ten minutes to three" - "to" as head
; Use POSTHD to allow "half past three" and "three thirty" but block
;      "?thirty past three" and "*three half"
; DPF (12-Jul-98) The specifier on hour_prep_words has to be [ OPT + ] in 
; order to block prenominal adjectives from attaching, since they distinguish 
; proper from common nouns by the optionality (or absence) of the specifier.  
; This distinction doesn't seem to work well here, but it's the only case, so 
; perhaps the analysis of "ten after three" should be reconsidered.
; DPF (11-Jul-99) But this [OPT +] incorrectly predicts that "To five thirty 
; suits me" is good, and worse, it allows "to five thirty" to act like an NP in
; appositive constructions.  So instead of this hack, constrain adjectives to
; only modify nominals with a DET specifier.
; DPF 23-May-03 - Since we now treat the specifier as the semantic head in the
; spr-head rule, "ten" of "ten to three" will determine the index of the phrase
; But this finally drives us to revise the analysis of this construction, so
; now we have a lexical rule that converts one- and two-digit cardinal number
; adjectives into nouns which take an optional "minute" complement and an
; obligatory prepositional complement (which is itself underspecified for 
; whether it is complement-saturated).  This should give us "ten to two",
; "ten minutes to two", and "ten to" and "ten after".

minute_noun_synsem := lex_synsem &
  [ LOCAL 
    [ CAT 
      [ HEAD noun & [ MOD < >,
                      MINORS.MIN hour_prep_rel ],
        VAL [ SPR < >,
              SUBJ < >,
              COMPS < [ LOCAL [ CAT nomp_cat &
                                    [ HEAD.MINORS [ MIN _minute_n_1_rel,
                                                    ALTMIN implicit_q_rel ] ],
                                CONT.HOOK.INDEX #minst & index,
                                CONJ cnil ],
                        NONLOC.SLASH 0-dlist,
                        OPT +,
                        PUNCT.LPUNCT no_punct ],
                      [ LOCAL [ CAT [ HEAD prep & 
                                        [ PRD -,
                                          MINORS [ MIN minute_prep_sel_rel,
                                                   ALTMIN numbered_hour_rel ]],
                                      VAL.SPR *olist*,
                                      MC na ],
                                CONT.HOOK [ LTOP #nhand,
                                            INDEX #ninst &
                                                 [ SORT time ] ],
                                CONJ cnil ],
                        NONLOC.SLASH 0-dlist,
                        OPT -,
                        PUNCT.LPUNCT no_punct ] > ] ],
      CONT nom-obj &
          [ HOOK [ LTOP #nhand,
                   INDEX ref-ind & #ninst &
                        [ PNG png & [ PN 3s ] ] ],
            HCONS <! !> ] ],
    LKEYS.KEYREL [ LBL #nhand,
                   PRED hour_prep_rel,
                   ARG1 #ninst,
                   ARG2 #minst ] ].

; ten pm to two am
; Tuesday to Friday
; ten mph to twenty mph
; DPF 3-Jul-02 - If MIN is interval_rel, then we predict wrongly that all of
; these constructions can be modifier NPs like "Tuesday".  But the modifying
; capability seems to be whatever the interval endpoints are: "Kim stayed
; Tuesday to Saturday" but "*Kim stayed Abrams to Browne".  So let's try 
; making the MIN be the SPR's MIN instead.
; DPF 28-Apr-03 - The [PRD -] feature prevents this from undergoing the
; temp_np rule, so we don't get "Kim stayed Tuesday to Saturday".  Let's try
; removing this constraint and see what happens.
; DPF 15-jun-04 - Restrict two arguments to [LEX +] to avoid spurious
; ambiguities; so admit "Tuesday - Wednesday" but not "Hire Kim -- his brother"
; with the sense of x_to_y.
; DPF 21-aug-04 - Removed SYNSEM..ALTMIN never_unify_rel, since it prevents
; these from appearing in NP-N compounds, as in "the Berlin - Paris route".
; Don't know what it was trying to exclude.
; DPF 25-sept-04 - Can't use LEX + to avoid 'Hire Kim - his brother'
; (cf. 15-jun-04) since this would also block 'Two - three p.m. is okay'
; since 'two' is [LEX -] in order to sustain contrast of 'we have a two p.m.
; meeting' vs. '*we have a two meeting'.  But happily we already have the
; constraint on MIN of each dtr NP requiring abstr_named_rel, which does the
; job we want, as long as we correct the erroneous type definition for
; reason_rel which wrongly unified norm_nom_rel and abstr_named_rel.  Sigh.
; DPF 7-mar-05 - Removed [PRD -] constraint on SPR and COMPS, since proper NPs
; now have their PRD value identified with their INFL value.  Don't know why
; this constraint was originally imposed.  Now only require that the PRD values
; of the two be identified, to avoid spurious ambiguity.
; Also changed parent type from norm_msg_word to norm_word since it needs
; to be unmarked for INFL in order to appear in compounds 
; (eg. "the Berlin - Paris route").
; DPF 14-nov-05 - Hack: added [AUX +] to prevent these from being modified by
; PPs, avoiding spurious analysis for "from Paris [[to Rome] on Thursday]"
; DPF 06-mar-06 - Propagated LEX from right dtr via HS-LEX, to block 'the 
; Paris to a city in Italy tour'
; DPF 24-may-06 - Further constrained NPs to be not post-modified, to avoid
; further spurious ambiguity.
; DPF 15-sept-07 - Removed identif of INFLECTD and PRD, since want to constrain
; HCOMP rule to require INFL + hd-dtr, to avoid spurious edges for e.g.
; 'hire Kim'.  We'll remind ourselves of why this identity was clever?
; DPF 17-may-09 - Changed SPR..MIN nonpro_rel to nonpro_or_num_rel, to allow
; |items 1 - 3|

basic_n-or-p_x_to_y_lexent := noncqrs-hm &
  [ SYNSEM basic_two_arg &
      [ LOCAL [ CAT [ VAL 
                      [ SPR < synsem &
                              [ LOCAL 
                                [ CAT 
                                  [ HEAD basic_noun &
                                    [ POSS -,
                                      MOD < >,
                                      PRD #prd,
                                      MINORS [ MIN nonpro_or_num_rel ] ],
                                    VAL [ SUBJ *olist*,
                                          COMPS < >,
					  SPEC < [ LOCAL.CAT.VAL.COMPS < > ] >,
					  SPCMPS < > ] ],
				  CONT.HOOK.INDEX non_expl,
				  CONJ cnil ],
                                NONLOC non-local_none &
				      [ SLASH.LIST < > ],
                                --SIND [ SORT #sort ],
                                OPT - ], ... >,
                        SUBJ < >,
                        COMPS < synsem &
                                [ --MIN #cmin,
				  LOCAL [ CAT [ HEAD basic_noun &
                                                [ POSS -,
                                                  MOD < >,
                                                  PRD #prd,
						  MINORS.MIN nonpro_or_num_rel],
						VAL [ SUBJ *olist*,
                                                      COMPS < > ] ],
					  CONT.HOOK.INDEX non_expl,
                                          CONJ cnil ],
				  NONLOC non-local_none &
					[ SLASH.LIST < > ],
                                  LEX #lex,
                                  --SIND [ SORT #sort ],
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ] >,
                        SPCMPS < > ],
                      HS-LEX #lex ] ],
	LKEYS.--COMPKEY #cmin ] ].

n-or-p_x_to_y_lexent := basic_n-or-p_x_to_y_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR.FIRST.MODIFD notmod_or_lmod,
		     CONT [ RELS.LIST < [ LBL #nhand,
					ARG0 #index,
					CFROM #from,
					CTO #to ],
				      [ PRED udef_q_rel,
					ARG0 #index,
					RSTR #rhand,
					CFROM #from,
					CTO #to ], ... >,
			  HCONS.LIST < qeq & [ HARG #rhand,
					       LARG #nhand ], ... > ],
		     AGR.DIV - ],
	     LKEYS.ALTKEYREL.PRED never_unify_rel ] ].

;; DPF 2013-02-12 - Anchored CFROM and CTO to those of the first rel.
;;
n_x_to_y_lexent := basic_n-or-p_x_to_y_lexent &
  [ INFLECTD na_or_+,
    SYNSEM 
      [ LOCAL [ CAT [ HEAD noun &
			   [ POSS -,
			     AUX +,
			     MOD < > ],
		      VAL [ SPR.FIRST [ --SIND #arg1,
					LOCAL.CAT.HEAD.MINORS.ALTMIN 
                                                 abstr_def_or_udef_q_rel ],
			    COMPS.FIRST.--SIND #arg2 ] ],
                CONT nom-obj &
                    [ HOOK.INDEX #index,
		      RELS.LIST < #keyrel & [ LBL #nhand,
					      PRED interval_rel,
					      ARG0 #index,
					      CFROM #from, CTO #to ],
                                  prep_relation &
                                  [ LBL #nhand,
                                    PRED interval_p_start_rel,
                                    ARG0.E [ TENSE no_tense,
                                             ASPECT no_aspect ],
                                    ARG1 #index & ref-ind,
                                    ARG2 #arg1,
				    CFROM #from, CTO #to ],
                                  prep_relation &
                                  [ LBL #nhand,
                                    PRED interval_p_end_rel,
                                    ARG0.E [ TENSE no_tense,
                                             ASPECT no_aspect ],
                                    ARG1 #index,
                                    ARG2 #arg2,
				    CFROM #from, CTO #to ], ... > ] ],
	LKEYS.KEYREL #keyrel ] ].

;; DPF 2010-sept-13 - Removed identity of --MIN on SPR and COMPS, since we
;; want e.g. Paris - Berlin - Rome, where one of the two will be interval_rel,
;; while the other will be named_np_rel.
;; DPF 2012-09-26 - Removed COMPS.MIN and SPR..MIN abstr_named_rel, to allow 
;; meas-NPs, so let's see where this overgenerates.
;
; <type val="n_np_x-to-y-sg_le">
; <description>Diadic n 'to' (XtoY) -sg np cmp  
; <ex>Berlin to Paris was quick.
; <nex>
; <todo>
; </type>
n_np_x-to-y-sg_le := n_x_to_y_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT 
	[ HEAD.MINORS.MIN interval_rel,
	  VAL [ SPR < [ LOCAL 
			[ AGR.PNG.PN 3s,
			  CAT [ HEAD.MINORS [ MIN named_or_meas_rel & #sprmin,
					      ALTMIN impl_or_proper_q_rel ],
				VAL [ SPR *olist* ] ] ] ],
		      unexpressed_reg &
		      [ LOCAL.CAT.HEAD det,
			--MIN abstr_def_or_udef_q_rel,
			OPT - ] >,
		COMPS < [ --MIN named_or_meas_rel,
			  LOCAL [ AGR.PNG.PN 3s,
				  CAT.VAL.SPR *olist* ],
			  MODIFD notmod_or_lmod ] > ] ],
	CONT [ HOOK [ LTOP #nhand,
		      INDEX #index ],
	       RELS <! [ LBL #nhand, ARG0 #index ],
		       relation, relation !>,
               HCONS <!  !> ],
	AGR.DIV + ],
      LKEYS [ --COMPKEY #cmin,
              --+COMPKEY #cmin,
              --+OCOMPKEY #sprmin ] ] ].

; <type val="n_np_x-to-y-pl_le">
; <description>Diadic n 'to' (XtoY) -pl np cmp  
; <ex>Thirty to fifty arrived.
; <nex>
; <todo>
; </type>
n_np_x-to-y-pl_le := n_x_to_y_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD.MINORS.MIN interval_rel,
	      VAL [ SPR < [ --MIN part_nom_rel,
			    LOCAL.CAT.VAL.SPR *olist* ],
			  anti_synsem_min >,
		    COMPS < [ --MIN abstr_named_rel,
			      LOCAL [ CAT.VAL.SPR *olist*,
				      AGR.PNG.PN 3p ],
			      MODIFD notmod_or_lmod ] > ] ],
	CONT [ RELS <! [ LBL #nhand,
			 ARG0 #index,
			 CFROM #from,
			 CTO #to ],
		       relation, relation,
		       [ PRED udef_q_rel,
			 ARG0 #index,
			 RSTR #rhand,
			 CFROM #from,
			 CTO #to ] !>,
               HCONS <! qeq & [ HARG #rhand,
				LARG #nhand ] !> ],
	AGR.DIV - ],
      LKEYS [ --+COMPKEY card_rel,
	      --+OCOMPKEY card_rel ] ] ].

; <type val="n_nb_x-to-y_le">
; <description>Diadic n 'to' (XtoY) - nbar comp and spr
; <ex>The text to speech engine worked.
; <nex>
; <todo>
; </type>
n_nb_x-to-y_le := n_x_to_y_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT 
	[ HEAD.MINORS.MIN interval_rel,
	  VAL [ SPR < [ --MIN norm_nom_rel,
		      	LOCAL noninfl_noun_local &
			      [ CAT.VAL.SPR.FIRST synsem & [ OPT - ],
				CONT.HOOK [ LTOP #spltop,
					    INDEX #spind ] ] ],
		      anti_synsem_min >,
		COMPS < [ --MIN norm_nom_rel,
		      	  LOCAL [ CAT.VAL.SPR.FIRST synsem & [ OPT - ],
				  CONT.HOOK [ LTOP #cltop,
					      INDEX #cind ] ] ] > ] ],
	CONT [ HOOK [ LTOP #lbl,
		      INDEX #index ],
	       RELS <! [ LBL #lbl,
			 ARG0 #index,
			 CFROM #from, CTO #to ],
		       relation, relation,
	               [ PRED udef_q_rel,
			 ARG0 #spind,
			 RSTR #sphand,
			 CFROM #from, CTO #to ],
		       [ PRED udef_q_rel,
			 ARG0 #cind,
			 RSTR #chand,
			 CFROM #from, CTO #to ] !>,
               HCONS <! qeq & [ HARG #sphand,
				LARG #spltop ],
		        qeq & [ HARG #chand,
				LARG #cltop ] !> ],
	AGR.DIV - ] ] ].

;; DPF 2011-11-19 - There is remaining spurious ambiguity here, since we can't
;; demand that the SPR be [INFLECTD +], and since e.g. |October ten| must be 
;; able to be [INFLECTD -] (for |the October ten meeting|), we get two.
;; FIX someday
;; DPF 2013-02-12 - Renamed to n_nb_x-to-y-dom_le since this one is only for
;; dofm specifier and comp.
;;
; <type val="n_nb_x-to-y-dom_le">
; <description>Diad n 'to'  (XtoY) - nbar cmp   
; <ex>We met May 23 to 25.
; <nex>
; <todo>
; </type>
n_nb_x-to-y-dom_le := n_x_to_y_lexent &
  [ SYNSEM
    [ LOCAL 
      [ CAT [ HEAD.MINORS.MIN interval_modable_rel,
              VAL [ SPR < [ --MIN dofm_rel & #sprmin,
			    LOCAL.CAT.VAL.SPR *olist* ],
			  anti_synsem_min >,
		    COMPS < [ --MIN dofm_rel & #sprmin,
                              LOCAL [ CAT.VAL.SPR.FIRST synsem,
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX #cind ] ] ] > ] ],
        CONT [ RELS <! [ LBL #nhand,
			 ARG0 #index,
			 CFROM #cfrom, CTO #cto ],
		       relation, relation,
		       [ PRED udef_q_rel,
			 ARG0 #cind,
			 RSTR #crstr,
			 CFROM #cfrom, CTO #cto ],
		       [ PRED udef_q_rel,
			 ARG0 #index,
			 RSTR #rhand,
			 CFROM #cfrom,
			 CTO #cto ] !>,
               HCONS <! qeq & [ HARG #rhand,
				LARG #nhand ],
		        qeq & [ HARG #crstr,
				LARG #cltop ] !> ],
	AGR.DIV - ],
      LKEYS [ --COMPKEY #cmin,
              --+COMPKEY #cmin,
              --+OCOMPKEY #sprmin ] ] ].

;; For |the $10 a share price|
p_nb_pre-meas_lexent := basic_n-or-p_x_to_y_lexent &
  [ INFLECTD +,
    SYNSEM 
      [ LOCAL [ CAT [ HEAD prep &
			   [ MOD < synsem &
				   [ LOCAL intersective_mod &
					   [ CAT [ HEAD noun,
						   VAL [ SPR.FIRST synsem,
							 COMPS < > ] ],
					     CONT.HOOK [ LTOP #ltop,
							 INDEX #mind ] ] ] >,
			     MINORS.MIN #pred ],
		      VAL [ SPR <
			     [ LOCAL 
			        [ CAT [ HEAD.MINORS [ MIN meas_nom_rel,
						      ALTMIN implicit_q_rel ] ],
				  CONT.HOOK [ INDEX #arg1,
					      XARG #shand ] ],
			       OPT - ],
			      anti_synsem_min >,
			    COMPS < [ LOCAL [ CAT [ HEAD noun,
						    VAL [ SPR.FIRST synsem &
							  [LOCAL.CAT.HEAD det],
							  COMPS < > ] ],
					      CONT.HOOK [ LTOP #chand,
							  INDEX #arg2 ] ],
				      OPT - ] > ],
		      POSTHD - ],
		CONT [ HOOK [ LTOP #ltop ],
		       RELS <! #keyrel & prep_relation &
			       [ LBL #shand,
				 ARG1 #arg1,
				 ARG2 #arg2,
				 CFROm #cfrom, CTO #cto ],
			       prep_notense_relation &
			       [ LBL #ltop,
				 PRED compound_rel,
				 ARG1 #mind,
				 ARG2 #arg1,
				 CFROM #cfrom, CTO #cto ],
			       [ PRED udef_q_rel,
				 ARG0 #arg2,
				 RSTR #crstr,
				 CFROM #cfrom, CTO #cto ]!>,
		       HCONS <! qeq & [ HARG #crstr,
					LARG #chand ] !> ],
		AGR.DIV - ],
	LKEYS.KEYREL #keyrel & [ PRED #pred ] ] ].

p_nb_pre-meas_le := p_nb_pre-meas_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.PHON.ONSET con ].

p_nb_pre-meas-an_le := p_nb_pre-meas_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.PHON.ONSET voc ].

; <type val="p_np_x-to-y-num_le">
; <description>prep 'to' (XtoY) - scores: numbers
; <ex>They lost 3 to 2.
; <nex>
; <todo>
; </type>
p_np_x-to-y-num_le := n-or-p_x_to_y_lexent &
  [ INFLECTD +,
    SYNSEM 
    [ LOCAL 
      [ CAT 
	[ HEAD prep &
	       [ MINORS.MIN #min,
		 MOD < [ LOCAL intersective_mod &
			       [ CAT [ HEAD verb,
				       VAL [ SUBJ.FIRST synsem,
					     COMPS < > ] ],
				 CONT.HOOK [ LTOP #ltop,
					     INDEX #xarg ] ] ] > ],
	  VAL [ SPR < [ --SIND #arg1,
			LOCAL.CAT [ HEAD.MINORS.ALTMIN number_q_rel,
				    VAL.SPR *olist* ] ],
		      anti_synsem_min >,
		COMPS.FIRST [ --SIND #arg2,
			      LOCAL.CAT [ HEAD.MINORS.ALTMIN number_q_rel,
					  VAL.SPR *olist* ] ] ] ],
	CONT [ HOOK [ LTOP #ltop,
		      INDEX #index ],
	       RELS <! [ PRED score_n_rel,
			 ARG0 #nindex,
			 ARG1 #arg1,
			 ARG2 #arg2 ],
		       relation,
		       [ LBL #ltop,
			 PRED #min & with_p_score_rel,
			 ARG0 #index,
			 ARG1 #xarg,
			 ARG2 #nindex ] !>,
               HCONS <! qeq !> ] ] ] ].

; DPF 13-Aug-01 - For 'mid to upper' as in "the mid to upper nineties"
; Meaning intended to be something like "the nineties in the interval whose
; start is the mid somethings and whose end is the upper somethings"
; DPF 01-sept-04 - Removed MINORS.MIN basic_adj_rel from SPR and COMPS, to 
; allow "three to five chairs"
; DPF 23-apr-09 - Generalized HEAD from adj to adj_or_intadj to enable
; intervals in measure phrases: |5-10 ft. tall|
; DPF 2010-09-14 - Identified MIN on SPR and COMPS, to avoid spurious analysis
; of |close to fifty cats|
;; DPF 2012-04-07 - Added MOD < synsem > to prevent adjunct extraction here

; <type val="aj_pp_i-x-to-y_le">
; <description>Adj, only interval 'to'          
; <ex>B has small to big cats.
; <nex>
; <todo>
; </type>
aj_pp_i-x-to-y_le := noncqrs-m-nab &
  [ SYNSEM 
    [ LOCAL 
      [ CAT 
        [ HEAD adj_or_intadj & 
          [ MOD < synsem &
		  [ LOCAL intersective_mod &
                    [ CAT nbar_cat_min,
                      CONT.HOOK [ LTOP #hand,
                                  INDEX #nomarg & ref-ind & [ PNG #png ] ],
                      CONJ cnil ] ] >,
            MINORS.MIN interval_p_end_rel ],
          VAL 
          [ SUBJ < >,
            SPR < synsem &
                  [ OPT -,
                    LOCAL [ CAT [ HEAD adj_or_intadj &
                                       [ TAM [ TENSE no_tense,
                                               ASPECT no_aspect ],
                                         MOD < synsem & 
                                               [ LOCAL intersective_mod ] >,
					 MINORS.MIN #min ],
                                  VAL [ SPR *olist*,
                                        COMPS < >,
                                        SPCMPS < >,
                                        SPEC < [ LOCAL.CAT.VAL.COMPS < > ]>]],
			    CONT.HOOK [ LTOP #fghand,
                                        XARG #fromarg ],
                            CONJ cnil ],
		    LEX +,
                    NONLOC.SLASH 0-dlist ] >,
            COMPS < [ OPT -,
                      LOCAL [ CAT [ HEAD adj_or_intadj &
                                         [ TAM [ TENSE no_tense,
                                                 ASPECT no_aspect ],
                                           MOD < synsem & 
                                                [ LOCAL intersective_mod ] >,
					   MINORS.MIN #min ],
                                    VAL [ SPR *olist*,
                                          COMPS < > ] ],
                              CONT.HOOK [ LTOP #tghand,
                                          XARG #toarg ],
                              CONJ cnil ],
		      LEX +,
                      NONLOC.SLASH 0-dlist,
                      PUNCT.LPUNCT no_punct ] > ] ],
        CONT [ HOOK [ LTOP #hand,
                      INDEX #arg0 & nonconj_indiv,
                      XARG #nomarg ],
               RELS <! #keyrel &
                     prep_relation &
                     [ LBL #ihand,
                       PRED interval_p_end_rel,
                       ARG0 #arg0,
                       ARG1 #intarg & [ DIV + ],
                       ARG2 #toarg,
		       CFROM #from,
		       CTO #to ],
                     prep_relation &
                     [ LBL #ihand,
                       PRED interval_p_start_rel,
                       ARG0.E [ TENSE no_tense,
                                ASPECT no_aspect ],
                       ARG1 #intarg,
                       ARG2 #fromarg,
		       CFROM #from,
		       CTO #to ],
                     [ LBL #fghand,
                       PRED elliptical_n_rel,
                       ARG0 #fromarg,
		       CFROM #from,
		       CTO #to ],
                     [ PRED udef_q_rel,
                       ARG0 #fromarg,
                       RSTR #fgrhand,
		       CFROM #from,
		       CTO #to ],
                     [ LBL #tghand,
                       PRED elliptical_n_rel,
                       ARG0 #toarg,
		       CFROM #from,
		       CTO #to ],
                     [ PRED udef_q_rel,
                       ARG0 #toarg,
                       RSTR #tgrhand,
		       CFROM #from,
		       CTO #to ],
                     [ LBL #ihand,
                       PRED interval_rel,
                       ARG0 #intarg,
		       CFROM #from,
		       CTO #to ],
                     [ PRED udef_q_rel,
                       ARG0 #intarg,
                       RSTR #irhand,
		       CFROM #from,
		       CTO #to ],
                     prep_relation &
                     [ LBL #hand,
                       PRED loc_nonsp_rel,
                       ARG0.E [ TENSE no_tense,
                                ASPECT no_aspect ],
                       ARG1 #nomarg,
                       ARG2 #intarg,
		       CFROM #from,
		       CTO #to ] !>,
               HCONS <! qeq & [ HARG #irhand,
                                LARG #ihand ],
                      qeq & [ HARG #fgrhand,
                              LARG #fghand ],
                      qeq & [ HARG #tgrhand,
                              LARG #tghand ] !> ],
        AGR [ PNG #png,
              DIV - ] ],
      LKEYS.KEYREL #keyrel,
      MODIFD.LPERIPH na ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADVERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Adverbs modify VPs and APs either pre-head or post-head (or both).
; Sentence-initial adverbials are treated as extractions of post-VP modifiers,
; unless the adverbial is a pre-head modifier. Otherwise, it would be hard to
; block post-S attachment along with post-VP attachment, which would give 
; spurious ambiguity.
; DPF 19-Oct-02 - Removed nonprd_synsem parent, since trying to make
; head_adj rule constrain adj to be PRD +.

basic_adverb_synsem := basic_one_arg & basic_lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_adv &
		       [ MOD < [ LOCAL local_basic &
				       [ CONJ cnil ],
                                 MODIFD.LPERIPH #lperiph,
                                 OPT - ] >,
                         MINORS.MIN basic_adv_rel ],
                  VAL [ SUBJ < >,
                        SPR #spr & [ FIRST.LOCAL.CAT.VAL.SPCMPS #spc ],
			COMPS < >,
			SPCMPS #spc ] ],
	    CONT.RELS.LIST < #keyrel, ... >,
            ARG-S #spr ],
    MODIFD.LPERIPH #lperiph,
    LKEYS.KEYREL #keyrel & adv_relation,
    --SIND non_expl ].

basic_scopal_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL scopal_mod &
				     [ CAT [ HEAD adverbee,
					     MC #mc ],
				       CONT.HOOK [ LTOP #mhand,
						   INDEX #index,
						   XARG #xarg ] ] ] >,
		  MC #mc ],
	    CONT [ HOOK [ INDEX #index,
			  XARG #xarg ],
                   RELS <! relation !>,
                   HCONS <! qeq &
                          [ HARG #hand,
                            LARG #mhand ] !> ] ],
    LKEYS.KEYREL.ARG1 #hand & handle ].


; DPF 17-Dec-01 - Made MOD..E-INDEX reentrant with E-INDEX, and the INDEX 
; values the same: 
; 'Chairs currently available arrived"
; DPF 04-may-05 - We consider restricting intersective adverbs to not modify
; auxiliary VPs, to avoid generating e.g. "Abrams carefully is leaving."
; But this also blocks e.g. "Abrams will often be early" - if anything, the
; generalization is that these adverbs don't want to attach to finite aux VPs,
; but that constraint is hard to express, and it's probably even more tricky
; to get the real constraint right - cf. ellipsis: "Kim often will." Or even
; "Kim sometimes might say this".  So remove AUX - from MOD.

basic_int_adverb_synsem := basic_adverb_synsem & isect_synsem &
  [ LOCAL.CAT [ HEAD.MOD < [ LOCAL [ CAT.MC #mc & na,
				     CONT.HOOK.INDEX #index ] ] >,
		MC #mc ],
    LKEYS.KEYREL.ARG1 #index & event ].

basic_spec_adverb_synsem := basic_adverb_synsem &
  [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.MC #mc ] >,
		MC #mc,
		VAL.SPR < synsem & 
			  [ LOCAL [ CAT [ VAL [ SUBJ < >,
						SPR *olist* ],
					  MC na ],
				    CONT.HOOK [ LTOP #hand,
						XARG #arg0 ] ] ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #arg0 ] ].

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
spec_adverb_synsem := basic_spec_adverb_synsem &
  [ LOCAL.CAT.VAL.SPR < [ --MIN more_or_very_deg_rel,
                          LOCAL.CAT.HEAD adv ] > ].

intersect_spec_adverb_synsem := basic_int_adverb_synsem & 
                                basic_spec_adverb_synsem.
		  
scopal_spec_adverb_synsem := basic_scopal_adverb_synsem & spec_adverb_synsem.

; VP, PP, AP
scopal_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD adv & 
                   [ MOD < [ LOCAL.CAT [ VAL.COMPS < >,
                                         MC na_or_- ] ] > ] ].

basic_intersect_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ VAL [ SUBJ *synlist*,
					     COMPS < > ],
				       MC na_or_- ] ] > ].

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
intersect_adverb_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD reg_adv & [ MOD < [ LOCAL.CAT adverbee_cat ] > ],
                  VAL.SPR < [ --MIN more_or_very_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
            CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; Adverbs like "once" as in "just once" ("*very once")
intersect_adverb_just_only_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD reg_adv & [ MOD < [ LOCAL.CAT adverbee_cat ] > ],
                  VAL.SPR < [ --MIN just_only_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
            CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; 'now' but not 'then' - appears after auxiliary as in "You are now ready"
; DPF 10-apr-05 - Changed SPR..MIN from no_rel to very_deg_rel in order
; to get "Kim is very often unhappy" and "Kim very often refuses to leave"
; Will have to find some other way to block "*Kim is very now unhappy",

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
intersect_adverb_auxv_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD lexadv & [ MOD < [ LOCAL [ CAT adverbee_cat &
                                                      [ HEAD v_or_g ],
                                                  CONT.HOOK.LTOP #ltop ],
                                          MODIFD.LPERIPH na_or_- ] > ],
                  VAL.SPR < [ --MIN more_or_very_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
            CONT.HOOK.LTOP #ltop ] ].

#|
;; DPF 2012-02-27 - Interestingly, it seems that we need to allow adverbs
;; that modify other adverbs.  At least, this seems to be the right analysis
;; for `already' as in |twice already, kim has lost|.  To be cautious, let's
;; start by constraining the modifiee to LEX +.
;; But in fact, the head-adj rule for intersective modifiers would have to be
;; generalized to allow adverb modifiees, and this will take substantial
;; testing to avoid overgeneration.  So put off for now, but 
;; FIX someday
;;
intersect_adverb_advmod_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD lexadv & [ MOD < [ LOCAL [ CAT.HEAD adv,
                                                  CONT.HOOK.LTOP #ltop ],
					  LEX + ] > ],
                  VAL.SPR < [ --MIN just_only_deg_rel,
			      LOCAL.CAT.HEAD adv ] > ],
            CONT [ HOOK.LTOP #ltop,
		   RELS <! relation !>,
                   HCONS <! !> ] ] ].

; <type val="av_-_i-avmod_le">
; <description>Intersective, adverb modifiee
; <ex>Twice already, B won.
; <nex>
; <todo>
; </type>
av_-_i-avmod_le := basic_adverb_word &
  [ SYNSEM intersect_adverb_advmod_synsem ].
|#


; VP only
; Block adj modifiee to avoid spurious parse for "almost empty"
; DPF 09-Aug-99 - Relaxed MOD..HEAD value to be v_or_g_or_a because okay for 
; adjectives as pre-head modifiers ("an apparently difficult problem"), though
; not post-head.
; DPF 25-Oct-01 - Removed MOD..MOD < synsem > constraint since it blocked
; 'I should never have arrived'
; DPF 30-aug-04 - Changed MOD..SUBJ from <synsem_min> to *synlist* in order
; to return to letting adverbs modify adjectives, while still distinguishing
; VPs from clauses.
; DPF 04-sept - But this prevents modification of inverted sentences as in
; 'why hasn't kim arrived yet'.  So use MOD..MSG no_msg instead.

scopal_vp_adverb_synsem := scopal_adverb_synsem &
  [ LOCAL.CAT.HEAD [ MOD < [ LOCAL [ CAT [ HEAD v_or_g_or_a,
                                           VAL.SPR.FIRST synsem_min ] ] ] >,
                     MINORS.MIN adv_rel ],
    LKEYS.KEYREL adv_relation ].

; Adverbs like "also" that either (pre) modify VPs or appear as complements of
; aux Vs.
; DPF 24-May-00 - Restrict MOD value to be no_aspect, to avoid spurious
; ambiguity for "kim is probably leaving"
; DPF 14-Oct-00 - But this prevents the desired parse for "Kim is not currently
; sleeping" since "not" should modify a pres-participle VP, not the gerund.  So
; as long as the gerund rule is a lexical rule, we're stuck with the ambiguity.
; DPF 13-Mar-02 - Added [MOD..PRD +] to ensure that when these adverbs modify
; deverbal adjectives, they not appear attributively, as in *the not yet 
; finished book
; DPF 18-Mar-02 - But this [PRD +] prevents these adverbs from pre-modifying
; ordinary finite VPs.  So let's instead accept "the not yet finished book" as
; okay.
; DPF 30-aug-04 - Changed MOD..SUBJ from <synsem_min> to *synlist* in order
; to return to letting adverbs modify adjectives, while still distinguishing
; VPs from clauses.

scopal_vp_aux_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD lexadv &
                   [ MOD < [ LOCAL.CAT [ HEAD v_or_g_or_a,
                                         VAL [ SUBJ *synlist*,
                                               COMPS < > ],
                                         MC na ] ] >,
                     MINORS.MIN adv_rel ] ].

scopal_negadv_adverb_synsem := scopal_adverb_synsem &
  [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT [ HEAD negadv,
                                         VAL.SUBJ < > ] ] >,
                     MINORS.MIN adv_rel ],
    LKEYS.KEYREL adv_relation ].

; rather: 'would you rather leave' 'I would rather not'
scopal_adv_would_v_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT [ HEAD adv & [ MOD < [ --MIN _would_v_modal_rel,
                                     LOCAL.CAT [ HEAD verb,
                                                 VAL.COMPS *cons* ],
                                     MODIFD.RPERIPH na_or_- ] >,
                             MINORS.MIN adv_rel ],
                POSTHD + ] ].

; DPF 21-Mar-02 - Added MOD..MSG no_msg, which seemingly should have
; been here all along - needed to block e.g. spurious parse for "kindly leave"
intersect_vp_adverb_synsem := intersect_adverb_synsem &
  [ LOCAL.CAT.HEAD.MINORS.MIN basic_adv_rel,
    LKEYS.KEYREL adv_relation ].

; S (for pre-S scopal adverbs only)
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.

scopal_s_adverb_synsem := spec_adverb_synsem &
  [ LOCAL [ CAT.HEAD adv &
                     [ MOD < [ LOCAL scopal_mod &
                                     [ CAT [ HEAD verb,
                                             VAL [ SUBJ *olist*,
                                                   COMPS < > ] ],
                                       CONT [ HOOK [ LTOP #arghand,
                                                     INDEX #index ] ] ] ] > ],
            CONT [ HOOK [ LTOP #khand,
                          INDEX #index & [ SF #iforce ] ],
		   RELS <! relation !>,
		   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #arghand ] !> ] ],
    PUNCT.RPUNCT.PSF #iforce,
    LKEYS.KEYREL [ LBL #khand,
                   ARG1 handle & #mhand ] ].

; S or VP (for pre-head intersective adverbs only) 
; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
intersect_s_or_vp_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL [ CAT [ HEAD adv &
                       [ MOD < [ LOCAL.CAT adverbee_cat &
                                           [ VAL.COMPS < > ] ] > ],
                  VAL.SPR < [ --MIN more_or_very_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; For adverbs like "maybe" which take no degree specifier
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.
; DPF 03-dec-05 - Generalized MOD..HEAD to 'verbal' to allow e.g.
; "they believed therefore that Kim was right"
basic_scopal_s_adverb_nospec_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT [ VAL.SPR < anti_synsem_min >,
		  HEAD adv &
                          [ MOD < [ LOCAL scopal_mod &
                                          [ CAT [ HEAD basic_verb_or_frag,
                                                  VAL [ SUBJ *olist*,
                                                        COMPS < > ],
                                                  MC bool ],
                                            CONT.HOOK [ LTOP #arghand,
                                                        INDEX #index ] ] ] >,
                            MINORS.MIN adv_rel ] ],
	    CONT [ HOOK [ LTOP #khand,
                          INDEX #index & [ SF #iforce ] ],
		   RELS <! relation !>,
		   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #arghand ] !> ] ],
    PUNCT.RPUNCT.PSF #iforce,
    LKEYS.KEYREL [ LBL #khand,
                   ARG1 handle & #mhand ] ].

scopal_s_adverb_nospec_synsem := basic_scopal_s_adverb_nospec_synsem &
  [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.MC #mc ] >,
		MC #mc ] ].

basic_adverb_word := noncrs-m-nab &
   [ SYNSEM basic_lex_synsem &
	    [ LOCAL.CONT.HOOK.LTOP #ltop,
              LKEYS.KEYREL.LBL #ltop ] ].


adverb_word := basic_adverb_word &
  [ SYNSEM scopal_vp_adverb_synsem ].

; <type val="av_-_s-negmod_le">
; <description>Scop, modify 'not': 'probably'   
; <ex>B is probably not C.
; <nex>
; <todo>
; </type>
av_-_s-negmod_le := basic_adverb_word &
  [ SYNSEM scopal_negadv_adverb_synsem ].

; <type val="av_-_s-rather_le">
; <description>Scop, just 'rather'              
; <ex>B would rather not win.
; <nex>
; <todo>
; </type>
av_-_s-rather_le := basic_adverb_word &
  [ SYNSEM scopal_adv_would_v_synsem ].

; DPF (27-Apr-99) Assume for now that S-initial adverbs can only modify [INV -]
; S's, in order to block "*Never does kim sleep?"
; DPF 28-Oct-01 - But this blocked e.g. "Meanwhile when does kim sleep"

norm_adv_word := noncrs-nab &
   [ SYNSEM basic_lex_synsem ].

adv_s_pre_lexent := norm_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT [ POSTHD -,
			 HEAD.MOD < [ LOCAL.CAT.MC bool ] > ] ] ].

; <type val="av_-_s-cp-pr_le">
; <description>Scop, S, pre-hd                  
; <ex>Obviously B won.
; <nex>
; <todo>
; </type>
av_-_s-cp-pr_le := adv_s_pre_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN adv_rel ].

; <type val="av_-_s-cp-pr-inv_le">
; <description>Scop, S, pre-hd                  
; <ex>Obviously B won.
; <nex>
; <todo>
; </type>
av_-_s-cp-pr-inv_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT [ POSTHD -,
			 HEAD [ MINORS.MIN adv_rel,
				PRD -,
				MOD < [ LOCAL.CAT [ HEAD.INV +,
						    MC na ] ] > ] ] ] ].

; For "(3)" or "3)" meaning 'thirdly'
; <type val="av_-_s-cp-gen_le">
; <description>Scop, S, generic                 
; <ex>Generic-adv, B won.
; <nex>
; <todo>
; </type>
av_-_s-cp-gen_le := adv_s_pre_lexent & basic_generic_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN adv_rel,
	     LKEYS.KEYREL.PRED "nth_rel" ] ].

; 'evidently' - only pre-modifies declaratives, not questions or commands
; <type val="av_-_s-cpp_le">
; <description>Scop, S-prop, pre-hd             
; <ex>Evidently B won.
; <nex>
; <todo>
; </type>
av_-_s-cpp_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT 
              [ HEAD [ MOD < [ LOCAL [ CAT.MC +,
                                       CONT.HOOK.INDEX.SF basic-prop ] ] >,
                       MINORS.MIN adv_rel ] ] ] ].
    
; DPF 10-Apr-02 - Removed MOD..VFORM imp_vform since this blocked e.g 
; "I would like to know when my order is going to arrive , please"
; <type val="av_-_s-cp-nsp-po_le">
; <description>Scop, S, no spec, post-hd        
; <ex>B won for sure.
; <nex>
; <todo>
; </type>
av_-_s-cp-nsp-po_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT [ POSTHD +,
			 HEAD.MOD < [ LEX -,
				      LOCAL.CAT.MC bool ] > ] ] ].

; <type val="av_-_s-cp-mc-po_le">
; <description>Scop, S main cls (mc), post-hd   
; <ex>B won, and ...
; <nex>
; <todo>
; </type>
av_-_s-cp-mc-po_le := norm_adv_word &
  [ GENRE spoken,
    SYNSEM basic_scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.MC +,
				      NONLOC.SLASH 0-dlist ] >,
			 POSTHD + ] ] ].

; <type val="av_-_s-cp-nsp-pr_le">
; <description>Scop, S, no spec, pre-hd         
; <ex>Hence B won.
; <nex>
; <todo>
; </type>
av_-_s-cp-nsp-pr_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHD - ] ].
    
; <type val="av_-_s-cp-mc-pr_le">
; <description>Scop, S main cls (mc), pre-hd    
; <ex>No, B won.
; <nex>
; <todo>
; </type>
av_-_s-cp-mc-pr_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT [ HEAD.MOD < [ NONLOC.SLASH 0-dlist ] >,
                         MC +,
                         POSTHD - ] ] ].
    
; <type val="av_-_s-cp_le">
; <description>Scop, S                          
; <ex>Actually B won.
; <nex>
; <todo>
; </type>
av_-_s-cp_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT [ HEAD.INV -,
						  MC bool ] ] >,
                              MINORS.MIN adv_rel ] ] ].

av_-_s-vp_lexent := adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                    MODIFD [ LPERIPH na_or_-,
                                             RPERIPH na_or_- ] ] >,
                            MINORS.MIN adv_rel ] ].

; <type val="av_-_s-vp_le">
; <description>Scopal, VP                       
; <ex>B possibly won.
; <nex>
; <todo>
; </type>
av_-_s-vp_le := av_-_s-vp_lexent.
; <type val="av_-_s-vp-only_le">
; <description>Scop, VP (no AdjP)               
; <ex>B won too.
; <nex>
; <todo>
; </type>
av_-_s-vp-only_le := av_-_s-vp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g ] > ].

; <type val="av_-_s-vp-x_le">
; <description>Scop, VP w/aux head
; <ex>B is obviously C.
; <nex>
; <todo>
; </type>
av_-_s-vp-x_le := basic_adverb_word &
  [ SYNSEM scopal_vp_aux_adverb_synsem &
           [ LOCAL.CAT [ POSTHD -,
                         HEAD.MOD < [ MODIFD.LPERIPH na_or_- ] > ] ] ].
    
; <type val="av_-_s-vp-only-x_le">
; <description>Scop, VP w/aux head, does not modify adjectives
; <ex>B is really C.
; <nex>
; <todo>
; </type>
av_-_s-vp-only-x_le := basic_adverb_word &
  [ SYNSEM scopal_vp_aux_adverb_synsem &
           [ LOCAL.CAT [ POSTHD -,
                         HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g,
				      MODIFD.LPERIPH na_or_- ] > ] ] ].
    
; DPF 7-Jun-00 - To avoid apparently spurious ambiguity of attachment of
; VP-final scopal adverbs in e.g. "I have won too", require these adverbs to
; attach only to finite or imperative VP, forcing high attachment.

; <type val="av_-_s-vp-po_le">
; <description>Scop, VP, post-hd                
; <ex>B won too.
; <nex>
; <todo>
; </type>
av_-_s-vp-po_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g & 
                                                   [ VFORM fin_or_imp ],
                                    MODIFD.RPERIPH na_or_- ] >,
                       POSTHD + ] ].

; <type val="av_-_s-vp-pr_le">
; <description>Scop, VP, pre-hd                 
; <ex>B thereby won.
; <nex>
; <todo>
; </type>
av_-_s-vp-pr_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT [ POSTHD -,
                       HEAD [ MINORS.MIN adv_rel,
                              MOD < [ MODIFD.LPERIPH na_or_- ] > ] ] ].

; <type val="av_-_i-ap-pp_le">
; <description>Int, AP or PP                    
; <ex>Anyone currently ahead won
; <nex>
; <todo>
; </type>
av_-_i-ap-pp_le := basic_adverb_word &
  [ SYNSEM intersect_adverb_synsem & 
    [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD a_or_p &
                                     [ MOD < [ LOCAL intersective_mod ] > ]] >,
                       MINORS.MIN adv_rel ] ] ].
    
; <type val="av_-_i-ap_le">
; <description>Intersective, AdjP               
; <ex>B was sub-optimal
; <nex>
; <todo>
; </type>
av_-_i-ap_le := basic_adverb_word &
  [ SYNSEM intersect_adverb_synsem & 
    [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD adj &
                                     [ MOD < [ LOCAL intersective_mod ] > ]] >,
                       MINORS.MIN adv_rel ] ] ].
    
int_vp_adverb_word := basic_adverb_word &
  [ SYNSEM intersect_vp_adverb_synsem ].
    
int_vp_adv_just_only_word := basic_adverb_word &
  [ SYNSEM intersect_adverb_just_only_synsem ].
    
int_vp_aux_adverb_word := basic_adverb_word &
  [ SYNSEM intersect_adverb_auxv_synsem &
           [ LOCAL.CAT.HEAD.MINORS.MIN adv_rel ] ].
    
av_-_i-vp_lexent := int_vp_adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD adv & 
                          [ MINORS.MIN adv_rel,
                            MOD < [ LOCAL.CAT.HEAD v_or_g_or_a_or_int,
                                    MODIFD [ LPERIPH na_or_-,
                                             RPERIPH na_or_- ] ] > ] ].

; <type val="av_-_i-vp_le">
; <description>Intersective, VP                 
; <ex>B quickly won.
; <nex>
; <todo>
; </type>
av_-_i-vp_le := av_-_i-vp_lexent.

; 'much' - want to avoid "*older much"
; <type val="av_-_i-vp-only_le">
; <description>Intersective, VP (no AdjP)       
; <ex>B didn't sleep much.
; <nex>
; <todo>
; </type>
av_-_i-vp-only_le := av_-_i-vp_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
		       POSTHD + ] ].

; 'much' - want to avoid "*older much"
; <type val="av_-_i-vp-only_le">
; <description>Intersective, VP (no AdjP)       
; <ex>B didn't sleep much.
; <nex>
; <todo>
; </type>
av_-_i-vp-only-pr_le := av_-_i-vp_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
		       POSTHD - ] ].

; 'enough' - want to avoid "*very enough"
; <type val="av_-_i-vp-nspr_le">
; <description>Intersective, VP-mod, no specifier
; <ex>B didn't sleep enough
; <nex>
; <todo>
; </type>
av_-_i-vp-nspr_le := av_-_i-vp_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
		       VAL.SPR < unexpressed_min >,
		       POSTHD + ] ].

; DPF 06-sept-07 - Add type to allow restrictions on which adverbs can take
; part in the v_mod rule which allows modifiers before NP complements.
;; DPF 2012-09-21 - Generalize MOD..HEAD from v_or_a to v_or_a_or_p to allow
;; |for now, at least, we arise|

; <type val="av_-_i-vp-nvm_le">
; <description>Intersective, VP (no v_adv_np)   
; <ex>B at least likes cats.
; <nex>
; <todo>
; </type>
av_-_i-vp-nvm_le := av_-_i-vp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD.FIRST.LOCAL.CAT.HEAD v_or_a_or_p,
			    MINORS.NORM norm_rel ] ].

; <type val="av_-_i-vp-j_le">
; <description>Intersective, VP not modif       
; <ex>B sometimes wins.
; <nex>
; <todo>
; </type>
av_-_i-vp-j_le := int_vp_adv_just_only_word &
  [ SYNSEM.LOCAL.CAT.HEAD adv & 
                          [ MINORS.MIN adv_rel,
                            MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                    MODIFD [ LPERIPH na_or_-,
                                             RPERIPH na_or_- ] ] > ] ].

; <type val="av_-_i-vp-x_le">
; <description>Int, VP w/aux head               
; <ex>B can indeed win.
; <nex>
; <todo>
; </type>
av_-_i-vp-x_le := int_vp_aux_adverb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
                           POSTHD - ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

; <type val="av_-_i-vp-x-only_le">
; <description>Int, VP w/aux head, only         
; <ex>B should if possible win.
; <nex>
; <todo>
; </type>
av_-_i-vp-x-only_le := int_vp_aux_adverb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < anti_synsem &
                                      [ LOCAL [ CAT.HEAD verb,
                                                CONT.HOOK.LTOP #ltop ] ] > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

; 'long' as in "we have long admired abrams"
; <type val="av_-_i-vp-x-nmd_le">
; <description>Int, only complement of aux      
; <ex>B can in any case win.
; <nex>
; <todo>
; </type>
av_-_i-vp-x-nmd_le := int_vp_aux_adverb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < anti_synsem >,
                           POSTHD - ],
                     CONT [ RELS <! #keyrel !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

; 'now'
; <type val="av_-_i-vp-x-now_le">
; <description>Int, just 'now'                  
; <ex>B can now win.
; <nex>
; <todo>
; </type>
av_-_i-vp-x-now_le := noncrs-hm &
  [ INFLECTD +,
    SYNSEM intersect_adverb_auxv_synsem &
           [ LOCAL [ CAT [ HEAD [ TAM #tam,
				  MOD < [ LOCAL.CAT.HEAD.MINORS.ALTMIN
                                                  non_ellipt_rel ] > ],
			   POSTHD - ],
                     CONT [ RELS <! [ PRED temp_loc_x_rel,
                                      ARG2 #inst,
				      CFROM #from,
				      CTO #to ],
                                   [ LBL #nhand, 
                                     PRED time_n_rel,
                                     ARG0 #inst,
				     CFROM #from,
				     CTO #to ],
                                   [ PRED def_implicit_q_rel,
                                     ARG0 #inst,
                                     RSTR #rhand,
				     CFROM #from,
				     CTO #to ],
                                   [ LBL #nhand,
                                     PRED _now_a_1_rel,
                                     ARG1 #inst,
				     CFROM #from,
				     CTO #to ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #nhand ] !> ] ],
             LKEYS.KEYREL.ARG1 [ E #tam,
                                 SORT time ] ] ].

; DPF 25-aug-07 - Added MODIFD hasmod to prevent these from appearing in
; the robust v_mod construction preceding complements, to avoid spurious
; ambiguity for e.g. "Abrams has more consultants."

; <type val="av_-_i-vp-po_le">
; <description>Int, VP post-hd                  
; <ex>B ran fast.
; <nex>
; <todo>
; </type>
av_-_i-vp-po_le := int_vp_adverb_word & 
  [ SYNSEM [ LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                      MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                              MODIFD.RPERIPH na_or_- ] > ],
                         POSTHD + ],
             MODIFD hasmod ] ].

; DPF 13-nov-05 - Generalized MOD..HEAD from v_or_g to v_or_g_or_a in order
; to get modification of deverbal attrib adjs.
; DPF 24-may-07 - And generalized again in order to get modification of
; PPs as in "professors now at Stanford ..."
;
; <type val="av_-_i-vp-pr_le">
; <description>Int, VP pre-hd                   
; <ex>B nearly won.
; <nex>
; <todo>
; </type>
av_-_i-vp-pr_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                    MOD < [ LOCAL.CAT.HEAD v_or_g_or_a_or_p,
                                            MODIFD.LPERIPH na_or_- ] > ],
                       POSTHD - ] ].

; <type val="av_-_i-vpo-pr_le">
; <description>Int, VP pre-hd, VP only
; <ex>B so wanted to win.
; <nex> B arrived so in the car.
; <todo>
; </type>
av_-_i-vpo-pr_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                    MOD < [ LOCAL.CAT.HEAD v_or_g,
                                            MODIFD.LPERIPH na_or_- ] > ],
                       POSTHD - ] ].

; <type val="av_-_i-vp-po-nmb_le">
; <description>Int, VP post-hd, not extracted, not between V and comp
; <ex>B can't win either.
; <nex>
; <todo>
; </type>
av_-_i-vp-po-nmb_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob & 
                            [ MINORS [ MIN adv_rel,
				       NORM norm_rel ],
                              MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                      MODIFD.RPERIPH na_or_- ] > ],
                       POSTHD + ] ].

; DPF 05-nov-08 - For lexical verbal prefixes like "re-"
;
; <type val="av_-_i-v-lx-pr_le">
; <description>Intersective, lexical V, pre-hd  
; <ex>B out-ran the others.
; <nex>
; <todo>
; </type>
av_-_i-v-lx-pr_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                    MOD < [ LOCAL.CAT.HEAD verb,
				            LEX + ] > ],
                       POSTHD - ] ].

; ERB (31-10-96) See notes near n_wh_pro_le.
; where, when, how
; DPF 31-may-06 - SPR constraint propagated from supertype - maybe unneeded.
; DPF 30-sept-06 - Changed MOD..HEAD from v_or_g_or_a to v_or_n_or_g_or_a
; in order to enable e.g "the reason why is obvious." as well as
; "why are there stars?"
; DPF 23-may-07 - Changed MOD..HEAD to just 'subst' since also want modif. of
; PPs as in "They knew why Kim was in Paris."
; DPF 18-feb-08 - Added PRD - to exclude spurious reading for "how is Kim?".
;; DPF 2010-10-08 - Re 31-may-06: Lack of constraint allowed "evening why"
;; as spec-hd.  But we only want a few degree adverbs as in "just why" or
;; "exactly how", so add further constraints.

; <type val="pp_-_i-wh_le">
; <description>PP, WH                           
; <ex>B knew why C won.
; <nex>
; <todo>
; </type>
pp_-_i-wh_le := noncrs-hm-nab &
  [ SYNSEM prep_spr_mod_synsem &
      [ LOCAL [ CAT [ HEAD p_or_adv &
                           [ PRD -,
			     MOD < [ LOCAL.CAT.HEAD subst ] >,
                             MINORS.ALTMIN nom_rel ],
		      VAL [ COMPS < >,
                            SPR < [ LOCAL [ CAT.HEAD adv,
					    CONT.HOOK.LTOP #ltop ],
				    --MIN more_or_very_deg_rel ] >,
			    SPEC < > ],
		      POSTHD +,
                      MC na ],
		CONT [ HOOK.LTOP #ltop,
		       RELS <! #keyrel & 
			       [ ARG2 #objind,
				 CFROM #cfrom, CTO #cto ],
			       [ PRED which_q_rel,
				 ARG0 #objind,
				 RSTR #rhand,
				 CFROM #cfrom, CTO #cto ],
			       nom_relation & #altkeyrel &
                               [ LBL #nhand,
				 ARG0 #objind ] !>,
		       HCONS <! qeq &
			       [ HARG #rhand,
				 LARG #nhand ] !> ],
                CONJ cnil ],
        LKEYS [ KEYREL #keyrel,
                ALTKEYREL #altkeyrel ],
        NONLOC.QUE 1-dlist &
              [ LIST < param > ],
        PUNCT no_punctuation_min ] ].
 
pp_-_i-rel_lexent := nonc-hm-nab &
  [ SYNSEM basic_lex_pp_synsem &
      [ LOCAL [ CAT [ HEAD prep &
                           [ PRD +,
                             MINORS.MIN #min,
			     MOD < [ LOCAL [ CAT vp_cat &
						 [ HEAD verb ],
					     CONJ cnil ],
                                     --SIND #event & event ] > ],
		      VAL.SPR < synsem & 
                                [ --MIN degree_rel,
                                  LOCAL [ CAT [ HEAD n_or_adv,
                                                VAL [ SPR *olist*,
                                                      COMPS < > ] ],
                                          CONT.HOOK [ LTOP #khand,
                                                      XARG #event ] ],
                                  NONLOC.QUE 0-dlist,
                                  OPT + ] >,
		      POSTHD +,
                      MC na,
                      HC-LEX - ],
                CONT [ HOOK [ LTOP #khand,
                              INDEX #event ],
		       RELS <! #keyrel & [ ARG1 #event,
                                           ARG2 #objind ] !>,
		       HCONS <! !> ],
                CONJ cnil ],
        LKEYS.KEYREL #keyrel & [ LBL #khand,
                                 PRED #min ],
        NONLOC [ REL 1-dlist & [ LIST < [ INDEX #objind ] > ],
                 SLASH 0-dlist,
                 QUE 0-dlist ],
        PUNCT no_punctuation_min ] ].

; <type val="pp_-_i-rel_le">
; <description>PP, relative                     
; <ex>B knew times when C won.
; <nex>
; <todo>
; </type>
pp_-_i-rel_le := pp_-_i-rel_lexent.

; <type val="pp_-_i-rel-that_le">
; <description>PP, relative, only `that'
; <ex>The time that C arose was memorable.
; <nex>
; <todo>
; </type>
pp_-_i-rel-that_le := pp_-_i-rel_lexent &
  [ SYNSEM.NONLOC.REL.LIST < [ INDEX.SORT location ] > ].

; 'on vacation', 'in bed'

; DPF 26-aug-07 - Don't know why this is here, but it's not good, since it
; licenses unification of abstr_lex_synsem and phr_synsem. So commented out.
;
; prep_p_mod_phr_synsem := prep_p_mod_synsem & phr_synsem.

prep_nomod_phr_synsem := phr_synsem &
  [ LOCAL [ CAT [ HEAD prep & [ TAM #tam,
                                MOD < > ],
                  VAL [ SUBJ < >,
                        COMPS #comps ] ],
            CONT.RELS.LIST < relation & [ PRED norm_rel,
                                          ARG0.E #tam ], ... >,
            ARG-S #comps ] ].

; FIX - should not be asking for COMPS..COMPS..LTOP :)
; <type val="p_ap_i_le">
; <description>Prep, adj, only 'as'             
; <ex>B did as early as possible
; <nex>
; <todo>
; </type>
p_ap_i_le := basic_prep_word &
  [ INFLECTD +,
    SYNSEM basic_prep_nomod_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ MINORS.MIN _as_p_comp_rel,
                     PRD - ],
              VAL [ SPR < unexpressed >,
                    COMPS < [ LOCAL 
                              [ CAT [ HEAD adj,
                                      VAL.COMPS
                                           < unexpressed &
                                             [ LOCAL.CAT.HEAD prep ],
                                             unexpressed &
                                             [ LOCAL.CONT.HOOK.LTOP #mhand] >],
                                CONT.HOOK [ LTOP #ltop,
                                            INDEX #index,
                                            XARG it-ind ],
                                CONJ cnil ],
                              LEX +,
                              NONLOC non-local_none ] > ],
              HC-LEX - ],
        CONT [ HOOK [ LTOP #ltop,
                      INDEX #index ],
               RELS <! basic_arg12_relation & #keyrel &
                     [ PRED prep_rel],
		     #altkeyrel &
                     arg1_relation &
                     [ LBL #mhand,
                       ARG0.SF prop,
                       PRED ellipsis_rel ] !>,
               HCONS <! !> ],
        CONJ cnil ],
      NONLOC [ SLASH 0-dlist,
               REL 0-dlist,
               QUE 0-dlist ],
      LKEYS [ KEYREL #keyrel &
                     [ LBL #ltop,
                       ARG0.E [ TENSE nontense,
                                ASPECT no_aspect ] ],
	      ALTKEYREL #altkeyrel,
              --+ARGIND it-ind ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DETERMINERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Determiners must have the MIN relation be the quantifier, since nouns
; select their determiner in part based on the type of the quantifier rel.
; The basic determiner synsem has a non-null value for its specifier; this is 
; to account for cases like "nearly all books, only his book, exactly which
; book, almost every book".  
;
; Quantifiers need to accommodate expressions like
; 'almost every book'.  One might expect to have the degree_rel of 'almost'
; take the handle of 'every' as its ARG1 value, but this may interfere with 
; the treatment of scope which needs to identify the set of quantifier handles.
; So we do this by adding separate lexical entries for these det-specs.
; DPF 8-Jun-03 - Removed COMPS < > from basic_det_synsem, since want to allow
; possibility of non-empty comps (e.g. for "a/an" as in "an hour and a half"
; analogous to "as tall as kim"
; DPF 17-jun-07 - Restored COMPS < >, since this "a/an" is now an adjective

basic_det_synsem := nomod_synsem &
  [ LOCAL [ CAT [ HEAD det & [ MINORS.MIN #pred ],
		  VAL [ SPR < [ NONLOC [ QUE 0-dlist,
                                         REL 0-dlist ],
				PUNCT.RPUNCT pair_or_no_punct ] >, 
			SPEC < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #pred,
                                         CONT.HOOK [ LTOP #nhand,
                                                     INDEX #index,
						     XARG #xarg ] ] ] >,
                        COMPS < > ] ],
	    CONT nom-obj &
		[ HOOK [ INDEX #index,
			 XARG #xarg ],
		  RELS.LIST < quant_or_wh_relation & #keyrel &
                              [ ARG0 #index,
                                RSTR #rhand ], ... >,
                  HCONS.LIST < qeq &
				[ HARG #rhand,
				  LARG #nhand ], ... > ],
	    ARG-S < > ],
    LKEYS.KEYREL #keyrel ].

basic_nonpart_det_synsem := basic_det_synsem.

norm_det_synsem := basic_det_synsem & 
  [ LOCAL.CAT [ HEAD.MINORS.MIN #min,
                VAL [ SPR < [ LOCAL [ CAT.HEAD adv,
				      CONT.HOOK.LTOP #lbl ],
			      --MIN degree_rel ] >,
		      SPCMPS < > ] ],
    LKEYS.KEYREL [ LBL #lbl,
                   PRED #min ] ].

nonpart_det_synsem := norm_det_synsem.

det_synsem := nonpart_det_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

basic_part_det_synsem := norm_det_synsem.

part_det_synsem := basic_part_det_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

part_det_synsem_nonwh := part_det_synsem & 
  [ NONLOC.QUE 0-dlist ].

; DPF 21-Nov-01 - Removed BV..DIV -* and AGR.DIV -: last Christmas
next_last_det_synsem := nonpart_det_synsem &
  [ LOCAL [ CAT [ HEAD [ POSS -,
                         MINORS.MIN def_implicit_q_rel ],
                  VAL [ SPEC < [ LOCAL [ CAT [ HEAD.MINORS 
                                                    [ MIN temp_abstr_rel,
                                                      ALTMIN norm_rel ],
                                               VAL.COMPS < > ],
                                         CONT.HOOK.LTOP #nhand ],
                                 MODIFD notmod ] >,
                        COMPS < > ] ],
	    CONT [ RELS <! [ PRED def_implicit_q_rel,
                             ARG0 #ind & [ PNG png & [ PN 3s ] ] ],
			    relation & #altkeyrel &
			    [ LBL #nhand,
			      ARG1 #ind ] !>,
		   HCONS <! qeq !> ],
            AGR.PNG.PN 3s ],
    NONLOC.QUE 0-dlist,
    MODIFD hasmod,
    LKEYS.ALTKEYREL #altkeyrel ].

basic_det_word := word.
;; DPF 2012-06-23 - Moved [POSS -] up from det_word to here, in order to
;; block spurious |of all| with poss-gen `of', as in |cats of all arose|.
;;
abstr_det_word := basic_det_word & que_word &
  [ SYNSEM.LOCAL.CAT.HEAD.POSS - ].
 
det_word := abstr_det_word &
  [ SYNSEM det_synsem ].

; DPF 15-Apr-03 - ALTMIN allows most determiners to appear with day-part nouns
; like 'morning' as VP modifiers, as in 'i arrive every morning' but not
; 'I arrive the morning'
; DPF 06-dec-03 - Moved constraint PN 3s down but leave DIV - so we can allow
; coordination in "every dog and cat" where the nbar is PN 3p, but not
; constrained for DIV.  Still blocking "*every dogs"

det_word_sing := det_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                     AGR.DIV - ],
             NONLOC.QUE 0-dlist ] ].

basic_det_word_nonque := det_word &
  [ SYNSEM.NONLOC.QUE 0-dlist ].
det_word_nonque := basic_det_word_nonque &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ RELS <! relation !>,
                          HCONS <! qeq !> ] ] ].

det_pl_lexent := det_word_nonque &
  [ SYNSEM [ LOCAL [ AGR.PNG.PN 3p,
                     CAT.HEAD.MINORS.ALTMIN dofw_or_poss_q_rel ],
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ],
             MODIFD hasmod ] ].

; <type val="d_-_pl_le">
; <description>Det, plural                      
; <ex>These dogs barked.
; <nex>
; <todo>
; </type>
d_-_pl_le := det_pl_lexent.

; 'another two chairs' but '*another chairs'
; <type val="d_-_pl-modn_le">
; <description>Det, plural, noun obl mod - FIX  
; <ex>Another six dogs barked.
; <nex>
; <todo>
; </type>
d_-_pl-modn_le := det_pl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ MODIFD lmod ] > ].

; <type val="d_-_sgm_le">
; <description>Det, sing, deictic               
; <ex>This dog barked.
; <nex>
; <todo>
; </type>
d_-_sgm_le := det_word_nonque &
  [ SYNSEM [ LOCAL.AGR.PNG.PN 3s,
	     MODIFD hasmod ] ].

; 'zero effect'
; <type val="d_-_m_le">
; <description>Det, mass noun                   
; <ex>B had zero effect.
; <nex>
; <todo>
; </type>
d_-_m_le := det_word_nonque &
  [ SYNSEM [ LOCAL.AGR.PNG.PN 3s,
             LKEYS.KEYREL.ARG0.DIV + ] ].

; <type val="d_-_next_le">
; <description>Det, only 'next'                 
; <ex>B arrives next week.
; <nex>
; <todo>
; </type>
d_-_next_le := abstr_det_word &
  [ SYNSEM next_last_det_synsem ].

; <type val="d_-_last_le">
; <description>Det, only 'last'                 
; <ex>B arrived last week.
; <nex>
; <todo>
; </type>
d_-_last_le := abstr_det_word &
  [ SYNSEM next_last_det_synsem ].

; "yesterday morning, tomorrow afternoon"
; <type val="d_-_proxday_le">
; <description>Det, proximal day                
; <ex>B arrives tomorrow morning
; <nex>
; <todo>
; </type>
d_-_proxday_le := abstr_det_word &
  [ SYNSEM next_last_det_synsem & 
	   [ LOCAL.CAT.VAL.SPEC < [ --MIN day_part_rel ] > ] ].

; "all month", "all day" - FIX - not yet blocking "*all October, *all Tuesday"
; <type val="d_-_all-tm_le">
; <description>Det, with time noun, only 'all'  
; <ex>B slept all afternoon.
; <nex>
; <todo>
; </type>
d_-_all-tm_le := abstr_det_word &
  [ SYNSEM next_last_det_synsem ].

; DPF 20-Feb-01 - Use SPEC..ALTMIN to block det-N analysis of 
; "both kim and sandy"
; DPF 11-Mar-02 - Use ALTMIN to block phrasal partitive-NP rule

basic_pdet_word_nonque := abstr_det_word &
  [ SYNSEM part_det_synsem_nonwh &
      [ LOCAL [ CAT.HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                CONT [ RELS.LIST < quant_or_wh_relation, ... >,
                       HCONS <! qeq !> ] ],
        NONLOC.QUE 0-dlist,
        MODIFD hasmod ] ].

pdet_word_nonque := basic_pdet_word_nonque &
  [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].

; 'any'
; <type val="d_-_prt_le">
; <description>Det, partitive okay              
; <ex>Either dog will bark.
; <nex>
; <todo>
; </type>
d_-_prt_le := pdet_word_nonque &
  [ SYNSEM.LOCAL.CAT.NEGPOL + ].

; DPF 19-Oct-02 - Would like to make DIV +* not + to allow coordination of 
; unlike NPs ("my book and some other stuff"), but then we can't block
; spurious "some programmer" whose DIV value ends up +_and_-.  An example
; of problems with this overspecification approach to coordination.

; some
; <type val="d_-_prt-div_le">
; <description>Det, partv, divisible            
; <ex>Some rice arrived.
; <nex>
; <todo>
; </type>
d_-_prt-div_le := pdet_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ VAL.SPR < [ --MIN just_only_deg_rel ] >,
			 NEGPOL - ],
             LKEYS.KEYREL.ARG0.DIV + ] ].

; For "another one/two (of the chairs)"
; Still don't have analysis for "another two chairs" (cf. "*another chairs")
; <type val="d_-_prt-anthr_le">
; <description>Det, partv, only 'another'       
; <ex>Another dog arrived.
; <nex>
; <todo>
; </type>
d_-_prt-anthr_le := pdet_word_nonque &
  [ SYNSEM 
    [ LOCAL.CAT.VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                      SPEC < [ --MIN part_nom_rel ] > ],
      LKEYS.KEYREL.ARG0.DIV + ] ].

; DPF 06-dec-03 - Removed constraint PN 3s but leave DIV - so we can allow
; coordination in "another time and date" where the nbar is PN 3p, but not
; constrained for DIV.  Still blocking "*another chairs"
; <type val="d_-_prt-sg_le">
; <description>Det, partv, singular             
; <ex>Each dog barked.
; <nex>
; <todo>
; </type>
d_-_prt-sg_le := pdet_word_nonque &
  [ SYNSEM [ LOCAL.AGR.DIV -,
             LKEYS.KEYREL.ARG0.DIV - ] ].

; <type val="d_-_prt-sgm-nag_le">
; <description>Det, partv, sing-mass, no agrmt  
; <ex>Little rice arrived.
; <nex>
; <todo>
; </type>
d_-_prt-sgm-nag_le := pdet_word_nonque &
  [ SYNSEM [ LOCAL.AGR [ PNG.PN 3s,
                         DIV + ],
             LKEYS.KEYREL [ PRED explicit_quant_noagr_q_rel,
                            ARG0 [ PNG png & [ PN 3s ],
                                   DIV + ] ] ] ].

det_part_pl-or-m_lexent := basic_pdet_word_nonque &
  [ SYNSEM [ LOCAL.CONT [ RELS.LIST < [ ARG0 #arg0 ],
                                      #altkeyrel &
                                      [ LBL #lbl,
                                        ARG0 event & [ E [ TENSE no_tense,
                                                         ASPECT no_aspect ] ],
                                        ARG1 #arg0 ], ... >,
			  HCONS <! [ LARG #lbl ] !> ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

; <type val="d_-_prt-pl_le">
; <description>Det, partv, plural               
; <ex>Several dogs barked.
; <nex>
; <todo>
; </type>
d_-_prt-pl_le := det_part_pl-or-m_lexent &
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3p,
		   CONT.RELS <! [ PRED udef_q_rel,
				  ARG0.PNG png & [ PN 3p ] ],
			        relation !> ] ].

; <type val="d_-_prt-more_le">
; <description>Det, partitive, only 'more'      
; <ex>More dogs arrived.
; <nex>
; <todo>
; </type>
d_-_prt-more_le := det_part_pl-or-m_lexent &
  [ SYNSEM [ LOCAL [ AGR.DIV +,
		     CONT.RELS <! [ ARG0.DIV + ],
			        [ PRED much-many_a_rel, LBL #lbl, ARG0 #e ],
			        #alt2keyrel &
			        [ PRED comp_rel,
				  LBL #lbl,
				  ARG0 event & [ E [ TENSE no_tense,
						     ASPECT no_aspect ] ],
				  ARG1 #e ] !> ],
	     LKEYS.ALT2KEYREL #alt2keyrel ] ].

; <type val="d_-_prt-pl-both_le">
; <description>Det, partv, plural, only 'both'  
; <ex>Both dogs barked.
; <nex>
; <todo>
; </type>
d_-_prt-pl-both_le := basic_pdet_word_nonque &
  [ SYNSEM [ LOCAL [ AGR.PNG.PN 3p,
                     CONT [ HOOK.INDEX #index,
                            RELS <! relation, [ LBL #lbl,
                                                PRED card_rel,
                                                ARG0 event & 
                                                    [ E [ TENSE no_tense,
                                                          ASPECT no_aspect ] ],
                                                ARG1 #index,
                                                CARG "2",
						CFROM #from, CTO #to ] !>,
                            HCONS <! qeq & [ LARG #lbl ] !> ] ],
             LKEYS.KEYREL [ ARG0.PNG png & [ PN 3p ],
			    CFROM #from, CTO #to ] ] ].

; This assumes (falsely) that all plurals are divisible (cf "oats", "clothes")
; It also incorrectly blocks coordinations like "Kim and all children" since 
; the alternative (DIV +) would fail to block "all book".
; DPF 28-oct-03 - Added LEX + to block e.g. "a person all of us" as hd-spec.
; DPF 01-may-04 - Changed SPR..MIN from very_deg_rel to just_only_deg_rel

det_part_pl_mass_lexent := pdet_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ --MIN just_only_deg_rel,
                                     LEX + ] >,
                     AGR.DIV + ],
             LKEYS.KEYREL.ARG0.DIV +,
             MODIFD hasmod ] ].

; <type val="d_-_prt-plm_le">
; <description>Det, partv, plural-mass          
; <ex>B has enough rice.
; <nex>
; <todo>
; </type>
d_-_prt-plm_le := det_part_pl_mass_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_quant_agr_q_rel ].

; <type val="d_-_prt-plm-unsp_le">
; <description>Det, partv, pl-mass, unsp agr    
; <ex>B never has such rice.
; <nex>
; <todo>
; </type>
d_-_prt-plm-unsp_le := det_part_pl_mass_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_q_rel ].

; <type val="d_-_prt-plm-nag_le">
; <description>Det, partv, pl-mass, no agr      
; <ex>B has less rice.
; <nex>
; <todo>
; </type>
d_-_prt-plm-nag_le := det_part_pl_mass_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_quant_noagr_q_rel ].

; <type val="d_-_prt-unsp_le">
; <description>Det, partv, only 'which'         
; <ex>B saw which rice grew.
; <nex>
; <todo>
; </type>
d_-_prt-unsp_le := abstr_det_word &
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD.POSS -,
		     CONT [ RELS <! quant_or_wh_relation !>,
			    HCONS <! qeq !> ] ],
	     NONLOC.QUE 1-dlist &
		           [ LIST < param > ],
             LKEYS.KEYREL.PRED which_q_rel ] ].

; DPF 10-May-00 - We add subtypes of determiners to distinguish "We met every 
; week" from "*We met the week".  The distinction makes use of the feature 
; MODIFD, where the head-specifier rule's mother's MODIFD value is 
; determined by the specifier daughter, so each specifier has to say whether it
; passes on the MODIFD value from its head, or supplies its own.  Thus "the"
; assigns its own value,"every" supplies its own 'hasmod' 
; value, and "a" supplies the opposite value "notmod", to block "*Kim arrived 
; a big week".

; 'no'
; <type val="d_-_no_le">
; <description>Det, only 'no'                   
; <ex>No book arrived.
; <nex>
; <todo>
; </type>
d_-_no_le := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                         VAL.SPEC < [ MODIFD #modif ] >,
			 NEGPOL + ],
             LKEYS.KEYREL.PRED no_q_rel,
             MODIFD #modif ] ].


; 'some'
; <type val="d_-_ndiv_le">
; <description>Det, only individ 'some'         
; <ex>Some book arrived.
; <nex>
; <todo>
; </type>
d_-_ndiv_le := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                         VAL.SPEC < [ MODIFD #modif ] > ],
             LKEYS.KEYREL [ PRED some_q_rel,
                            ARG0.DIV - ],
             MODIFD #modif ] ].

; 'the'
; DPF 2-May-03 - Divide this type into two subtypes, one [MODIFD notmod]
; and one [MODIFD lmod] to support the treatment of VP-modifying NPs with
; the following pattern of grammaticality:
;   Kim arrived the first week
;  *Kim arrived the week
;   Kim arrived the week Sandy left
;   Kim arrived the week of the party
;  *Kim arrived week of the party
;
; DPF 27-May-03 - See discussion in syntax.tdl's npadv_mod_rule for why we
; considered and then abandoned two separate entries for "the".
; DPF 03-dec-03 - Replaced ALTMIN no_rel with dofw_or_poss_q_rel in
; order to get "on the weekend".  But then get two parses for "the night",
; so go back to no_rel.
; DPF 19-sept-07 - Since 'no_rel' blocked "the day we arrived", changed this
; ALTMIN to _the_q_rel, which is compatible with extracted-napdv construction.

d_-_the_lexent := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN _the_q_rel,
                         VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                               SPEC < [ MODIFD #mod ] > ],
			 NEGPOL - ],
             LKEYS.ALTKEYREL.PRED no_rel,
             MODIFD #mod ] ].

; <type val="d_-_the_le">
; <description>Det, only 'the'                  
; <ex>The book arrived.
; <nex>
; <todo>
; </type>
d_-_the_le := d_-_the_lexent.

; For "the the"
; <type val="d_-_the-mal_le">
; <description>Det, only 'the the' (robust)     
; <ex>*The the book arrived.
; <nex>
; <todo>
; </type>
d_-_the-mal_le := d_-_the_lexent &
  [ GENRE robust ].

; For "X amount of money"
; <type val="d_-_x_le">
; <description>Det, only 'X'
; <ex>We received X amount of money.
; <nex>
; <todo>
; </type>
d_-_x_le := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN _x_q_rel,
                         VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                               SPEC < [ MODIFD #mod ] > ],
			 NEGPOL - ],
             LKEYS.ALTKEYREL.PRED no_rel,
             MODIFD #mod ] ].

; 'half the time'
det_word_modable := det_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                           VAL.COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             MODIFD hasmod ] ].

; <type val="d_-_wh_le">
; <description>Det, nnly 'what'                 
; <ex>B knew what book he had.
; <nex>
; <todo>
; </type>
d_-_wh_le := det_word_modable &
  [ SYNSEM [ LKEYS.KEYREL.PRED which_q_rel,
	     NONLOC.QUE 1-dlist &
			   [ LIST < param > ] ] ].

; 'a/an'
; DPF 15-Nov-01 - Removed [SPR <anti_synsem_min>] since this blocke "more than 
; a week ago"
; DPF 12-nov-05 - Removed 3s constraint from ARG0, since want to allow 
; "A number who sing also dance." where the semantic index is plural,
; but the syntactic agreement is still singular.
; DPF 30-sept-06 - Changed MODIFD notmod to instead identify value with that
; of SPEC.MODIFD, in order to get e.g. "We arrived a week after you."

; det_word_sing &
basic_det_sg_nomod_lexent := abstr_det_word &
  [ SYNSEM basic_det_synsem &
	   [ LOCAL 
             [ CAT [ VAL [ SPEC < [ MODIFD #modif ] >,
			   COMPS < > ],
		     NEGPOL - ],
               AGR [ PNG.PN 3s,
		     DIV - ],
               CONT [ RELS <! relation !>,
                      HCONS <! qeq !> ] ], 
	     NONLOC.QUE 0-dlist,
             MODIFD #modif ] ].

det_sg_nomod_lexent := det_word_sing & basic_det_sg_nomod_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.MINORS.MIN 
							    just_only_deg_rel,
	     LKEYS.KEYREL.PRED some_q_rel ] ].

det_sg_compadj_lexent := basic_det_sg_nomod_lexent &
  [ SYNSEM basic_nonpart_det_synsem &
	   [ LOCAL.CAT [ HEAD [ MINORS.MIN #pred,
				POSS - ],
			 VAL [ SPR 
			     < [ LOCAL [ CAT [ HEAD [ MINORS.MIN adj_rel,
						      MOD < [ --SIND #nind ] >,
						      PRD - ],
					       VAL [ SPR < anti_synsem &
						    [ --MIN this_that_deg_rel]>,
						     COMPS #comps ] ],
					 CONT.HOOK.LTOP #ltop ],
				 OPT -,
				 LEX -,
				 NONLOC non-local_none ] >,
			       SPEC < [ LOCAL.CONT.HOOK [ LTOP #ltop,
							  INDEX #nind ] ] >,
			       SPCMPS #comps ] ],
	     LKEYS.KEYREL.PRED #pred & _a_q_rel ] ].

; <type val="d_-_sg-nmd_le">
; <description>Det, sing, not modif, con onset  
; <ex>A book arrived.
; <nex>
; <todo>
; </type>
d_-_sg-nmd_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_unk ] > ].

; <type val="d_-_sg-nmd-an_le">
; <description>Det, sing, not modif, voc onset  
; <ex>An apple arrived.
; <nex>
; <todo>
; </type>
d_-_sg-nmd-an_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc_or_unk ] > ].

; <type val="d_-_sg-caj_le">
; <description>Det, sing, oblig compadj spr
; <ex>Too big a cat arrived.
; <nex>
; <todo>
; </type>
d_-_sg-caj_le := det_sg_compadj_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_unk ] > ].

; <type val="d_-_sg-caj-an_le">
; <description>Det, sing, oblig compadj spr
; <ex>Too big an apple arrived.
; <nex>
; <todo>
; </type>
d_-_sg-caj-an_le := det_sg_compadj_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc_or_unk ] > ].

; "a apple"
; <type val="d_-_sg-a-mal_le">
; <description>Det, only 'a' (robust number)    
; <ex>*A cats arrived.
; <nex>
; <todo>
; </type>
d_-_sg-a-mal_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc ] >,
    GENRE robust ].

; "an dog"
; <type val="d_-_sg-an-mal_le">
; <description>Det, only 'an' (robust number)   
; <ex>*An apples fell.
; <nex>
; <todo>
; </type>
d_-_sg-an-mal_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con ] >,
    GENRE robust ].

; "a a cat" "an an apple"
; <type val="d_-_sg-a-a-mal_le">
; <description>Det, only 'a(n) a(n)' (robust)   
; <ex>*A a book arrived.
; <nex>
; <todo>
; </type>
d_-_sg-a-a-mal_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_voc ] >,
    GENRE robust ].

; 'every'
; <type val="d_-_sg-every_le">
; <description>Det, sing, only 'every'          
; <ex>Every dog barked.
; <nex>
; <todo>
; </type>
; DPF 22-may-09 - Changed SPR..MIN from just_only_very_deg_rel to
; just_only_deg_rel - why was it allowing 'very'?
d_-_sg-every_le := det_word_sing &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                               COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             MODIFD hasmod,
             LKEYS [ KEYREL [ LBL #lbl,
			      PRED every_q_rel ],
                     ALTKEYREL.LBL #lbl ] ] ].

; We make the non-quantifier relation generically pron_rel, and have each
; individual pronoun simply constrain the ARG0 index of that pron_rel.
;   This type is used for both WH "whose" and relative "whose", so it leaves 
; both  QUE  and  REL  values unspecified, but supplies all other defaults.
; DPF 24-aug-06 - Added ALTMIN no_rel to block possessive determiners from
; combining with e.g.day-of-month nouns as in  "*My five is booked."

poss_word := noncs-m-nab & basic_det_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ POSS +,
				  MINORS.ALTMIN no_rel ],
			   VAL.COMPS < > ],
		     CONT nom-obj &
			[ HOOK.INDEX #index,
			  RELS.LIST < relation,
                                      prep_relation & #altkeyrel &
                                      [ PRED poss_rel,
                                        ARG0.E [ TENSE no_tense,
                                                ASPECT no_aspect ],
                                        ARG1 #index ], ... > ] ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; ERB (31-10-96) See notes near n_wh_pro_le.

; <type val="d_-_wh-poss_le">
; <description>Det, only 'whose'                
; <ex>B knew whose dog barked.
; <nex>
; <todo>
; </type>
d_-_wh-poss_le := poss_word &
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN def_implicit_q_rel,
                           VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #nhand ] > ],
		     CONT [ RELS <! #keyrel & [ PRED def_implicit_q_rel,
						CFROM #from, CTO #to ],
                                    [ LBL #nhand,
                                      ARG2 #ind ],
				    [ LBL #phand,
                                      PRED person_rel,
                                      ARG0 #ind & full_non_expl,
				      CFROM #from, CTO #to ],
                                    [ ARG0 #ind,
                                      PRED which_q_rel,
                                      RSTR #rhand2,
				      CFROM #from, CTO #to ] !>,
			    HCONS <! qeq, 
                                     qeq &
                                     [ HARG #rhand2,
                                       LARG #phand ] !> ] ],
             LKEYS [ KEYREL #keyrel ],
	     NONLOC [ REL 0-dlist,
                      QUE 1-dlist &
			   [ LIST < param > ] ] ] ].

; DPF 17-dec-03 - Added HS-LEX + to avoid sentence "*about my arrives"

nonwh_poss_word := poss_word &
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN def_explicit_q_rel,
                           VAL.SPR < [ --MIN just_only_deg_rel ] >,
                           HS-LEX + ],
                     CONT [ HCONS.LIST < qeq, ... > ] ],
             NONLOC.QUE 0-dlist,
             LKEYS.KEYREL.PRED def_explicit_q_rel ] ].

;; DPF 2012-12-14 - Removed XARG #ind, since this conflicts with other
;; assumptions about compound names, where the XARG is of type `handle'.
;; We'll see if we can rediscover why this XARG constraint was here...
;;
basic_det_poss_lexent := nonwh_poss_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #hand ] >,
                     CONT [ RELS <! relation & [ CFROM #from, CTO #to ],
                                  [ LBL #hand,
                                    ARG2 #ind ],
				  #alt2keyrel &
                                  [ PRED pronoun_q_rel,
                                    RSTR #rhand,
                                    ARG0 #ind ],
				  [ LBL #prohand,
                                    ARG0 #ind &
                                        [ SORT entity ],
				    CFROM #from, CTO #to ] !>,
                            HCONS <! qeq, qeq & [ HARG #rhand,
                                                  LARG #prohand ] !> ] ],
             NONLOC.REL 0-dlist,
	     LKEYS.ALT2KEYREL #alt2keyrel ] ].

det_poss_lexent := basic_det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			      [ PRED pron_rel,
				ARG0.PT std ] !> ].

d_-_poss-her_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
                             [ ARG0 [ PNG png & [ PN 3s,
                                                  GEN fem ],
                                      PT std ] ] !> ].
; <type val="d_-_poss-her_le">
; <description>Det, only 'her'                  
; <ex>Her dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-her_le := d_-_poss-her_lexent.

; <type val="d_-_poss-her-mal_le">
; <description>Det, only 'her', robust
; <ex>Her her dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-her-mal_le := d_-_poss-her_lexent &
  [ GENRE robust ].

d_-_poss-his_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3s,
						    GEN masc ],
					PT std ] ] !> ].
; <type val="d_-_poss-his_le">
; <description>Det, only 'his'                  
; <ex>His dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-his_le := d_-_poss-his_lexent.

; <type val="d_-_poss-his-mal_le">
; <description>Det, only 'his'                  
; <ex>His his dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-his-mal_le := d_-_poss-his_lexent &
  [ GENRE robust ].

; DPF 26-sept-04 - Temporary solution until we add determiner coordination,
; at least.
; <type val="d_-_poss-his-her_le">
; <description>Det, only 'his/her'              
; <ex>His/her dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-his-her_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
                             [ ARG0 [ PNG png & [ PN 3s,
                                                  GEN andro ],
                                      PT std ] ] !> ].

d_-_poss-its_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3s,
						    GEN neut ],
					PT std ] ] !> ].
; <type val="d_-_poss-its_le">
; <description>Det, only 'its'                  
; <ex>Its tail wagged.
; <nex>
; <todo>
; </type>
d_-_poss-its_le := d_-_poss-its_lexent.

; <type val="d_-_poss-its-mal_le">
; <description>Det, only 'its', robust
; <ex>Its its tail wagged.
; <ex>It's tail wagged.
; <nex>
; <todo>
; </type>
d_-_poss-its-mal_le := d_-_poss-its_lexent &
  [ GENRE robust ].

d_-_poss-my_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1s ],
					PT std ] ] !> ].

; <type val="d_-_poss-my_le">
; <description>Det, only 'my'                   
; <ex>My dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-my_le := d_-_poss-my_lexent.

; <type val="d_-_poss-my-mal_le">
; <description>Det, only 'my', robust
; <ex>My my dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-my-mal_le := d_-_poss-my_lexent &
  [ GENRE robust ].

d_-_poss-our_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1p ],
					PT std ] ] !> ].

; <type val="d_-_poss-our_le">
; <description>Det, only 'our'                  
; <ex>Our dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-our_le := d_-_poss-our_lexent.

; <type val="d_-_poss-our-mal_le">
; <description>Det, only 'our', robust
; <ex>Our our dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-our-mal_le := d_-_poss-our_lexent &
  [ GENRE robust ].

d_-_poss-their_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3p ],
					PT std ] ] !> ].

; <type val="d_-_poss-their_le">
; <description>Det, only 'their'                
; <ex>Their dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-their_le := d_-_poss-their_lexent.

; <type val="d_-_poss-their-mal_le">
; <description>Det, only 'their', robust
; <ex>Their their dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-their-mal_le := d_-_poss-their_lexent &
  [ GENRE robust ].

d_-_poss-your_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 2 ],
					PT std ] ] !> ].
; <type val="d_-_poss-your_le">
; <description>Det, only 'your'                 
; <ex>Your dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-your_le := d_-_poss-your_lexent.

; <type val="d_-_poss-your-mal_le">
; <description>Det, only 'your', robust
; <ex>Your your dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-your-mal_le := d_-_poss-your_lexent &
  [ GENRE robust ].

; <type val="d_-_poss-anoth_le">
; <description>Det, only 'their'                
; <ex>Their dog barked.
; <nex>
; <todo>
; </type>
d_-_poss-anoth_le := basic_det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ PRED recip_pro_rel,
				 ARG0 [ PNG png & [ PN 3p ] ] ] !> ].

; <type val="d_-_poss-rel_le">
; <description>Det, only relative 'whose'       
; <ex>Men whose dogs bark laugh.
; <nex>
; <todo>
; </type>
d_-_poss-rel_le := nonwh_poss_word &
  [ SYNSEM [ LOCAL.CONT [ RELS <! relation,
				#altkeyrel &
                                [ LBL #hand,
                                  ARG2 #ind ] !>,
                          HCONS <! qeq !> ],
	     NONLOC.REL 1-dlist &
			   [ LIST < [ LTOP #hand,
				      INDEX #ind ] > ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].


; 'of mine'
det_nospec_synsem := nomod_synsem.
det_poss_nospec_lexent := basic_det_word & noncrs-m-nab &
  [ SYNSEM det_nospec_synsem &
           [ LOCAL [ CAT [ HEAD det & [ POSS +,
                                        MINORS [ MIN implicit_q_rel,
                                               ALTMIN poss_rel ] ],
                           VAL [ SPR < anti_synsem_min >,
                                 SPEC < anti_synsem_min >,
                                 COMPS < > ] ],
                     CONT [ HOOK.INDEX ref-ind & #ind,
                            RELS <! [ PRED pronoun_q_rel,
                                      RSTR #rhand,
                                      ARG0 #ind,
				      CFROM #cfrom, CTO #cto ],
				  #altkeyrel &
                                  [ LBL #prohand,
				    PRED pron_rel,
                                    ARG0 #ind &
					[ PT std,
					  SORT entity ],
				    CFROM #cfrom, CTO #cto ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !> ] ],
             NONLOC non-local_none,
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; <type val="d_-_poss-mine_le">
; <description>Det, only 'mine'                 
; <ex>Mine barked.
; <nex>
; <todo>
; </type>
d_-_poss-mine_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 1s ] !> ].

; <type val="d_-_poss-ours_le">
; <description>Det, only 'ours'                 
; <ex>Ours barked.
; <nex>
; <todo>
; </type>
d_-_poss-ours_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 1p ] !> ].

; <type val="d_-_poss-yours_le">
; <description>Det, only 'yours'                
; <ex>Yours barked.
; <nex>
; <todo>
; </type>
d_-_poss-yours_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 2 ] !> ].

; <type val="d_-_poss-his-ns_le">
; <description>Det, only 'his'                  
; <ex>His barked.
; <nex>
; <todo>
; </type>
d_-_poss-his-ns_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG [ PN 3s,
                                                     GEN masc ] ] !> ].

; <type val="d_-_poss-hers_le">
; <description>Det, only 'hers'                 
; <ex>Hers barked.
; <nex>
; <todo>
; </type>
d_-_poss-hers_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG [ PN 3s,
                                                     GEN fem ] ] !> ].

; <type val="d_-_poss-theirs_le">
; <description>Det, only 'theirs                
; <ex>Theirs barked.
; <nex>
; <todo>
; </type>
d_-_poss-theirs_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 3p ] !> ].

; 'preposition' "a/an" for predicative NPs, as in "It is a (real/rare) 
; pleasure to visit Oslo" and "Oslo is a pleasure to visit"

pred_a_prep_lexent := nonconj &
  [ SYNSEM synsem &
    [ LOCAL [ CAT [ HEAD prep &
                         [ PRD +,
                           MOD < anti_synsem &
                                 [ LOCAL intersective_mod ] >,
                           TAM #tam & [ TENSE tense ],
                           MINORS [ MIN pred_a_rel,
				    NORM norm_rel ] ],
                    VAL [ SPR < >, 
                          SUBJ < >,
                          COMPS < [ --MIN prednom_rel,
                                    LOCAL [ CAT 
                                             [ HEAD noun &
                                                    [ POSS - ],
                                               VAL [ SUBJ < >,
                                                     COMPS < > ],
                                               MC na ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #index,
                                                        XARG #xarg ] ],
                                    NONLOC non-local_none &
                                          [ SLASH.LIST < > ],
                                    OPT - ] > ],
                    MC na ],
              CONT [ HOOK [ LTOP #ltop,
                            INDEX #event & event & [ E #tam ],
                            XARG #xarg ],
                     RELS <! #keyrel & quant_or_wh_relation, 
			     #altkeyrel &
                             arg1_relation & 
                             [ LBL #ltop,
                               PRED prednom_state_rel,
                               ARG0 #event,
                               ARG1 #index ] !>,
                     HCONS <! qeq &
                             [ HARG #rhand,
                               LARG #nhand ] !> ],
              ARG-S < > ],
      LKEYS [ KEYREL #keyrel & [ PRED some_q_rel,
				 ARG0 #index,
				 RSTR #rhand ],
	      ALTKEYREL #altkeyrel ],
      NONLOC [ SLASH 0-dlist,
               QUE 0-dlist,
               REL 0-dlist ] ],
    INFLECTD + ].

; <type val="p_np_i-prd-a_le">
; <description>Prep, NP, prednom, con onset     
; <ex>It is a pleasure to win. 
; <nex>
; <todo>
; </type>
p_np_i-prd-a_le := pred_a_prep_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET con_or_unk ] > ].

; <type val="p_np_i-prd-an_le">
; <description>Prep, NP, prednom, voc onset     
; <ex>It is an honor to be here.
; <nex>
; <todo>
; </type>
p_np_i-prd-an_le := pred_a_prep_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET voc_or_unk ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Free relatives
;
; One crucial property of free relatives is that they have a non-empty QUE
; value whose single list element is an index (rather than the param which
; is employed for ordinary question WH-words).
; The other is that they encode the constraints for their S/XP sister in the
; free-relative construction, in their SLASH attribute.
;; DPF 2012-11-12 - Changed SPR from synsem to unexpressed, to avoid spurious
;; ambiguity as in |just what ...| - force high attachment.
;;
free_rel_pro_word := noncr-hm-nab & basic_pronoun_word &
  [ SYNSEM synsem &
	   [ LOCAL [ CAT [ HEAD partn & [ MOD < > ],
			   VAL [ SPR < unexpressed &
				       [ --MIN just_only_deg_rel,
					 LOCAL [ CAT.HEAD adv,
						 CONT.HOOK.LTOP #lbl ],
					 NONLOC [ QUE 0-dlist,
						  REL 0-dlist ] ],
				       anti_synsem_min & [ OPT - ] >,
				 SUBJ < >,
				 COMPS < >,
				 SPEC < > ] ],
		     AGR #ind,
		     CONT [ HOOK [ INDEX non_expl-ind & #ind & [ PNG.PN 3 ],
                                   XARG #nhand ],
			    RELS.LIST < [ LBL #lbl,
                                          PRED basic_free_relative_q_rel,
                                          ARG0 #ind,
                                          RSTR #rhand,
					  CFROM #from, CTO #to ], 
					[ LBL #nhand,
                                          ARG0 #ind,
					  CFROM #from, CTO #to ], ... >,
			    HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !> ],
		     ARG-S < > ],
	     NONLOC [ REL 0-dlist,
                      QUE 1-dlist & <! #ind !>,
                      SLASH 1-dlist &
                          <! [ CAT.VAL.COMPS < >,
                               CONJ cnil ] !> ],
	     LKEYS.KEYREL [ CFROM #from, CTO #to ] ] ].

; whatever, whoever
; DPF 20-Aug-01 - Added SLASH..PRD - to block "what my offers are" with 
; predicative copula.

n_freerel_pro_lexent := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ PRD -,
                                MINORS #minors &
				       [ MIN reg_nom_rel & #pred,
					 ALTMIN free_relative_ever_q_rel ] ],
		     CONT [ HOOK.INDEX #ind & [ PNG.PN 3,
                                                SORT entity ],
                            RELS <! relation & #altkeyrel, #keyrel !> ] ],
             LKEYS [ KEYREL #keyrel & [ PRED #pred ],
                     ALTKEYREL #altkeyrel ],
	     NONLOC.SLASH 1-dlist &
                   <! [ CAT.HEAD noun & [ MOD < >,
                                          PRD -,
					  MINORS #minors ],
                        CONT.HOOK.INDEX #ind,
                        AGR non_expl-ind ] !> ] ].

; DPF 25-aug-07 - Need to leave underspecified for PN: "We bought what we
; thought were the right amounts"
; <type val="n_-_pr-fr_le">
; <description>Free relative pro                
; <ex>B did what C wanted.
; <nex>
; <todo>
; </type>
n_-_pr-fr_le := n_freerel_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_q_rel ].
                                          
; <type val="n_-_pr-fr-ever_le">
; <description>Free relative pro whatever          
; <ex>B did whatever C wanted.
; <nex>
; <todo>
; </type>
n_-_pr-fr-ever_le := n_freerel_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel ].

; <type val="n_-_pr-fr-ever-sg_le">
; <description>Free relative pro whoever, 3sg only
; <ex>B did whatever C wanted.
; <nex>
; <todo>
; </type>
n_-_pr-fr-ever-sg_le := n_freerel_pro_lexent &
  [ SYNSEM [ LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel,
             NONLOC.SLASH <! [ AGR.PNG.PN 3s ] !> ] ].

; when, where
; DPF 15-Apr-02 - Added SLASH..VAL.SUBJ..INDEX #arg to accommodate predicative
; 'be' as in "Find where Kim is"
; DPF 19-Oct-02 - Removed PRD - since need to allow head_adj_phr to have 
; adjunct be PRD +.
; DPF 06-sept-07 - Added INDEX.SORT location to prevent these from appearing
; as non-heads in appositives.
; DPF 07-apr-08 - But this blocks coord with other free rels, as in
; "we admired what he said and where he'd been."  So instead try constraining
; ALTMIN to non_freerel_rel, replacing nonpro_rel.
;;
n_freerel_pro_adv_lexent := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN #min,
				       ALTMIN #altmin & free_relative_q_rel,
				       NORM prep_mod_rel ],
		     CONT [ HOOK.INDEX.PNG.PN 3s,
			    RELS <! relation, 
                                   #keyrel & [ ARG0 #ind ],
                                   #alt2key &
                                   [ LBL #lochand,
                                     PRED prep_mod_rel,
                                     ARG0 [ E [ TENSE no_tense,
                                                 ASPECT no_aspect ] ],
                                     ARG1 #arg,
                                     ARG2 #ind ] !> ] ],
             LKEYS [ KEYREL #keyrel & [ PRED #min ],
                     ALTKEYREL #keyrel,
                     ALT2KEYREL #alt2key & [ PRED #slmin ] ],
	     NONLOC.SLASH 1-dlist &
                   <! [ CAT.HEAD prep & 
                                 [ MOD *nogaplist* &
				       < synsem & [ --SIND #arg ] >,
				   MINORS [ MIN #slmin,
					    ALTMIN #altmin ] ],
                        CONT.HOOK [ LTOP #lochand,
                                    XARG #arg ] ] !> ] ].


; <type val="n_-_pr-fr-wh_le">
; <description>Free relative 'wh'               
; <ex>B won when C won.
; <nex>
; <todo>
; </type>
n_-_pr-fr-wh_le := n_freerel_pro_adv_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_q_rel ].

; <type val="n_-_pr-fr-whever_le">
; <description>Free relative 'wh-ever'          
; <ex>B won whenever C won.
; <nex>
; <todo>
; </type>
n_-_pr-fr-whever_le := n_freerel_pro_adv_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel ].

; DPF 10-jul-04 - Replacing SLASH..HEAD n_or_p with noun since we don't want
; an extracted adjunct reading for e.g. "kim chases whichever cats bark".
; To still get "kim stays at whichever place he lands", maybe we have to
; make two separate entries for "whichever" - one a simple determiner
; which would in principle allow either NP or PP (maybe appropriately
; constrained ...), and the other the partitive which only allows NP slash.
; FIX ...

free_rel_det_word_gen := noncr-hm-nab &
  [ SYNSEM norm_det_synsem & 
	   [ LOCAL [ CAT [ HEAD.POSS -,
			   VAL [ SPEC < [ LOCAL.CONT.HOOK.LTOP #althand ] >,
                                 COMPS < > ] ],
                     CONT [ RELS <! [ PRED basic_free_relative_q_rel,
                                      ARG0 #arg0 ] !>,
			    HCONS <! qeq !> ] ],
             LKEYS.ALTKEYREL.LBL #althand,
	     NONLOC [ QUE 1-dlist &
			     [ LIST < index  > ],
			 SLASH 1-dlist &
			     <! [ CAT.HEAD noun & [ MOD < > ],
                                  CONT.HOOK.INDEX #arg0 ] !> ] ] ].

; whatever, what
; DPF 25-Nov-03 - Removed [SLASH..CASE acc] since also want "whichever books
; arrived".

; <type val="d_-_freerel_le">
; <description>Det, free relative               
; <ex>Whichever dog barks wins.
; <nex>
; <todo>
; </type>
d_-_freerel_le := free_rel_det_word_gen &
  [ SYNSEM det_synsem & 
           [ LOCAL [ CAT [ HEAD [ POSS -,
                                  MINORS.ALTMIN no_rel ],
                           VAL.COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             LKEYS.ALTKEYREL.PRED no_rel ] ].

; whichever
; <type val="n_-_pr-fr-part_le">
; <description>Free rel partitive 'whichever'   
; <ex>B won whichever cat C won.
; <nex>
; <todo>
; </type>
n_-_pr-fr-part_le := free_rel_det_word_gen &
  [ SYNSEM part_det_synsem ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 'which' for VP-modifying relative clauses
;; e.g. "Kim snored, which bothered Sandy."

vp_rel_word := basic_prep_word &
  [ SYNSEM one_arg_norel_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD prep_nonmob &
		   [ MOD < [ LOCAL scopal_mod &
				   [ CAT [ HEAD verb,
					   VAL [ SUBJ *oblcons*,
						 COMPS < > ] ],
				     CONJ cnil,
				     CONT.HOOK.LTOP #modltop ] ] > ],
	      POSTHD +,
	      VAL [ SPR < >,
		    COMPS < synsem &
			    [ LOCAL [ CAT [ HEAD verb &
					      [ VFORM fin,
						TAM.MOOD indicative,
						MINORS.ALTMIN non_ellipt_rel ],
					    VAL [ SUBJ *anti_list*,
						  COMPS < > ],
					    MC - ],
				      CONJ cnil,
				      CONT.HOOK [ LTOP #cltop,
						  INDEX #cevent,
						  --SLTOP #modltop ] ],
			      NONLOC [ SLASH 1-dlist &
				        <! [ CAT 
					     [ HEAD comp &
						    [ VFORM fin,
						      TAM.MOOD indicative ],
					       VAL [ SUBJ < >,
						     COMPS < > ] ],
					     CONT.HOOK.INDEX.SF prop ] !>,
				       QUE 0-dlist,
				       REL 0-dlist ],
			      OPT - ] >,
		    SPEC < > ] ],
	CONT [ HOOK [ LTOP #cltop,
		      INDEX #cevent ],
	       RELS <! !>,
	       HCONS <! !> ],
	AGR.PNG.PN 3s ],
      NONLOC non-local_none ] ].

p_cp_sl-rel_le := vp_rel_word.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Possessives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Possessive "'s" takes an NP[-Poss] specifier and projects either an
;; NP[+Poss] phrase (for "the book of Kim's") or a DetP[+Poss] phrase (for
;; "Kim's book").  Either way, the content of the possessive phrase will be a
;; definite possessive quantifier.  The NP[+Poss] things also work pretty well
;; for things like "Kim's is under the desk" if we allow governed NPs to be
;; +Poss.  The tricky thing will be figuring out exactly where `bare
;; possessives' can show up.  Also, we need to add the restriction that the SPR
;; must be non-pronominal.  We cannot simply make the synsem of the SPR be
;; the type nonpronominal, since that NP might be either lexical or phrasal,
;; distinguished by the synsem types lex_synsem and phr_synsem.  So we use
;; the semantic MIN relation to identify nonpronominals.

;; Another question is what do we do with the scope
;; of quantifiers in the possessor?  This entry assumes that they always have
;; narrow scope.  That should be an empirical question, as the saying goes.
; DPF 10-oct-04 - Added SPR..CASE non_obliq constraint to exclude reflexive 
; pronouns as in "*ourselves's chairs arrived", while still allowing
; reciprocals, as in "we hired each other's consultants."
; DPF 18-Nov-04 - Added SPR..PRD + to require that proper NPs be INFLECTD +,
; possible since the hdn_bnp-pn_c rule identifies PRD and INFLECTD.  This is
; needed since proper-NPs need to be [INFLECTD -] for NP-N-cmpnd rule which
; is also used for measure-NP compounds like "ten foot wall" (cf "*ten feet
; wall"); and further, the sp-hd_hc_c rule must leave the non-hd-dtr unspecified
; for INFLECTD since this rule is used to build "ten foot high (wall)", as
; well as the possessive phrase "kim 's".  Since the value of SPR is a list
; of synsems (with no access to the INFLECTD value), we smuggle in the
; needed constraint by coercing the otherwise unused feature PRD on proper
; NPs (note in defense that this same identity of PRD and INFLECTD is used
; legitimately in measure-NPs).
;; DPF 13-03-13 - Removed SPR..--BARE - so we can detect errors such as e.g.
;; |we admire cat's fur|.  Check for consequences.

basic_n_poss_clitic_lexent := nonc-m-nab &
  [ ALTS.SQPNCT -,
    SYNSEM lex_synsem &
     [ LOCAL [ ARG-S < #spr >,
	       CAT [ HEAD det &
			  [ POSS +,
                            MOD < >,
                            MINORS.ALTMIN poss_rel ],
                     VAL [ SUBJ < >,
                           SPR < #spr & synsem &
                                 [ --MIN nonpro_rel,
                                   LOCAL [ CAT nomp_cat_min &
                                               [ HEAD [ PRD +,
							--BARE -,
							CASE non_obliq ],
                                                 VAL [ SUBJ < >,
						       SPCMPS < > ] ],
                                           CONT.HOOK [ LTOP #plbl,
						       INDEX index ],
                                           CONJ cnil ],
                                   NONLOC [ SLASH #slash,
                                            REL #rel,
                                            QUE #que ],
                                   --SIND #pindex & individual_min,
                                   OPT - ] >,
                           COMPS < >,
			   SPCMPS < > ] ],
               CONT.HOOK [ INDEX #index,
			   XARG #pindex ] ],
       LKEYS.ALTKEYREL prep_relation &
             [ PRED poss_rel,
	       LBL #plbl,
               ARG0.E [ TENSE no_tense,
                        ASPECT no_aspect ],
               ARG1 #index & full_ref-ind,
               ARG2 #pindex ],
       NONLOC [ SLASH #slash,
                REL #rel,
                QUE #que ] ] ].

n_poss_clitic_lexent := basic_n_poss_clitic_lexent &
  [ SYNSEM lex_synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN def_explicit_q_rel & #min,
                     VAL.SPEC < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #min,
					  CONT.HOOK [ LTOP #phand,
						      INDEX #index ] ] ] > ],
	       CONT [ HOOK.INDEX #index,
                      RELS <! #keyrel & [ PRED def_explicit_q_rel,
                                       ARG0 #index,
                                       RSTR #rhand ],
                              #altkeyrel !>,
		      HCONS <! qeq & [ HARG #rhand,
                                       LARG #phand ] !> ] ],
       LKEYS [ KEYREL #keyrel,
               ALTKEYREL #altkeyrel & [ LBL #phand,
					ARG1 #index ] ] ] ].

; <type val="n_-_cl-poss_le">
; <description>Possessive NP clitic "'s"        
; <ex>B's cat won.
; <nex>
; <todo>
; </type>
n_-_cl-poss_le := n_poss_clitic_lexent.
; <type val="n_-_cl-poss-pl_le">
; <description>Possessive NP clitic plural "'"  
; <ex>The cats' owner won.
; <nex>
; <todo>
; </type>
n_-_cl-poss-pl_le := n_poss_clitic_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --SIND.PNG.PN 3p ] > ].

; For "That dog of Kim's barks."
; DPF 11-jan-10 - Tempted to block plural NPs followed by 's, as in "*dogs's"
; but we want to still allow "people's", so would have to be able to
; distinguish between productive morphological plural and not.  FIX ...
;
; <type val="n_-_cl-poss-nq_le">
; <description>Possessive NP clitic no-quantif  
; <ex>That cat of Browne's won.
; <nex>
; <todo>
; </type>
n_-_cl-poss-nq_le := basic_n_poss_clitic_lexent &
  [ SYNSEM lex_synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN implicit_q_rel,
                     VAL [ SPR < [ LOCAL.CONT.HOOK #hook ] >,
                           SPEC < anti_synsem > ] ],
	       CONT [ HOOK #hook,
                      RELS <! !>,
		      HCONS <! !> ] ],
       LKEYS.KEYREL.PRED no_rel ] ].

; Should eventually constrain this based on a PHON.FINAL feature to allow
; "Abrams' chairs" but block "Browne' chairs".  Overgenerate for now.
; <type val="n_-_cl-poss-pr_le">
; <description>Possessive NP clitic - of Jones' 
; <ex>Abrams' cat won.
; <nex>
; <todo>
; </type>
n_-_cl-poss-pr_le := n_poss_clitic_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --MIN named_rel,
                                 --SIND.PNG.PN 3s ] > ].

;; The possessive "of" takes an NP[+Poss] complement (e.g., "Kim's", "mine")
;; and modifies an N'[-Poss].  Unfortunately, the way the hierarchy of
;; preposition types is built, there wasn't any type this could inherit from.
;; We could probably rearrange things so this inherits some preposition
;; properties, but right now I'm too lazy.  Also, somehow we'll have to make
;; sure that this doesn't modify a pronoun.  The semantic manipulation here is
;; tricky - keep your eyes on the definite quantifier.  This def_implicit_q_rel
;; provided by the apostrophe-s (for its other life as a determiner), is 
;; dropped by the possessive-of, analogous to nouns, verbs, and adjectives 
;; dropping the semantics of the prepositions that can mark their complements.
;; This dropping of the relation is effected by having the possessive-of 
;; neglect to grab the handle of the def_implicit_q_rel for its complement, 
;; but grab instead the handle (and instance variable) of the NP complement 
;; of the apostrophe-s.  Then the general semantic pruning mechanism will 
;; ignore the def_implicit_q_rel, since its handle will not be a value in any 
;; other relation.

one_arg_isect := one_arg & isect_synsem.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBORDINATING CONJUNCTIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; These are not restricted to modifying only main VPs, since e.g. "if" needs
; to take scope over modals as in "I'd be pleased if we made an appointment."
; This lack of constraint means there will be structural ambiguity for 
; if-clauses, but not spurious - get different scopes of "if" and modals.
; But we restrict them to modifying only finite VPs or imperatives.

; DPF (10-Jan-99) Changed these to modify S rather than VP, since they don't
; appear to survive extraction from embedded clauses, nor do they appear inside
; an extraposed subject relative clause.

; DPF (10-Jan-98) For some reason, can't make the HEAD value prep* - fails to
; unify with strict_type in "Kim sleeps if Sandy sleeps".  Solve later.

; DPF 02-Oct-00 Changed subconj_inf_synsem to modify S rather than VP, in 
; order to make semantics consistent with other subord rels.

; DPF 26-Apr-03 Our analysis prevented subordinating phrases from modifying
; embedded clauses, but clearly we need these for examples like "I wonder
; whether Sandy arrived before Kim left".  So relax MOD..CAT to s_cat_unspec
; and make the subord's MSG be that of its modifiee, to block e.g.
; "*I wonder Kim arrived before Sandy left".  And further relax MOD..CAT to
; allow modification of infinitival VPs as in "Kim didn't want to leave before
; Sandy arrived", which means also dropping [ MOD..E.TENSE real_tense].
; DPF 17-Jul-03 - Removed PRD - since it blocks "Kim arrives two weeks after
; Sandy leaves", given our analysis of measure-NPs.  Not clear what it was for.
; DPF 22-Nov-03 - Removed MOD..SLASH 0-dlist since want to also get "the chair
; (that) I'll buy if you like it is expensive" and "who did you say Kim would
; hire if we were supportive".
; DPF 25-Nov-03 - Added MOD..LPERIPH na_or_- to avoid spurious disc_adv reading
; for "hiring kim and firing sandy happened"
; DPF 7-Jun-04 - This constraint prevented desired analysis for "if kim 
; arrives then sandy arises", so instead only use it in subjconj_vp rule.
; DPF 18-jul-04 - Removed constraint of MOD..MSG message to allow these to
; modify VPs as well as S's, to get e.g. "I found a book to read before 
; Abrams arrives"
; DPF 26-mar-05 - Restricting MOD.HEAD to verbal blocked modification of
; verbal gerunds, such as "safe practices for using a phone while driving",
; so changed to HEAD v_or_g.  Also removed MOD..LEX - since this prevented
; "for singing while driving"
; DPF 14-aug-05 - Re 17-Jul-03: PRD - prevents "not happy" from being
; built spuriously as "not" modifying the subconj-prdp "happy".
; DPF 13-nov-05 - Added MOD..SPR *cons* to exclude complementizer-phrases,
; to avoid spurious ambiguity for e.g. "Kim tried to leave while we slept."
; DPF 04-may-06 - Removed MOD..SUBJ *cons* since this prevents attaching
; subord clauses in relative clauses, as in "The guy that leaves if we
; stay is famous."
; DPF 13-may-06 - FIX - strictly speaking, we should have two versions of
; the filler-head-non-wh rule, one root and one non-root, analogous to the
; two subject-head rules, since the root one incorporates the mood
; of the punctuation mark, while the non-root one would pass it up.
; Right now, we don't parse 'Arise, whereas in Paris we arrive.' since the
; subord-clause prematurely declares the mood to be prop, when
; it should stay underspecified in this clause, and then become comm
; at the root.
; DPF 24-apr-08 - Add MOD..MOD anti_synsem_min to block modification of
; relative clauses (spurious analyses)
;; DPF 2011-08-10 - Added (hack) AUX + to prevent subordinate phrases from
;; being modified by PPs, to avoid spurious ambiguity of "kim arose [to 
;; arrive] [in Paris]".

basic_subconj_synsem := canonical_lex_or_phrase_synsem &
  [ LOCAL [ CAT [ HEAD prep &
		       [ MOD < synsem &
                               [ LOCAL scopal_mod &
				       [ CAT [ HEAD v_or_g &
						    [ MOD < anti_synsem_min >],
					       VAL.COMPS < >,
					       MC #mc ],
					 CONT.HOOK.LTOP #modltop,
                                         CONJ cnil ] ] >,
			 AUX +,
                         MINORS.MIN subord_rel ],
		  VAL.SUBJ < >,
                  MC #mc ],
            CONT [ HOOK.INDEX event,
		   RELS.LIST < subord_relation &
                                [ ARG0 [ E [ TENSE no_tense,
                                             ASPECT no_aspect ] ],
                                  ARG1 #main ], ... >,
                   HCONS.LIST < qeq & [ HARG #main,
                                        LARG #modltop ], ... > ] ] ].

basic_subconj_lex_synsem := basic_subconj_synsem &
  [ LOCAL [ CAT.VAL.SPR < [ LOCAL [ CAT [ HEAD n_or_adv,
                                          VAL.SPR *olist* ],
                                    CONT.HOOK [ LTOP #sltop,
                                                XARG #arg0 ] ],
                            NONLOC.QUE 0-dlist,
                            OPT + ] >,
            CONT [ HOOK.LTOP #sltop,
                   RELS.LIST < [ LBL #sltop,
                                 ARG0 #arg0 ], ... > ] ] ].

subconj_lex_synsem := basic_subconj_lex_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ --SIND #ind ] >,
	    CONT.HOOK.INDEX #ind ] ].

;; DPF 2012-09-21 - Corrected COMPS..LPUNCT from no_punct to pair_or_no_punct
;; so we can get |Kim arose because "she won".|
basic_onearg_subconj_synsem := basic_subconj_lex_synsem & basic_one_arg &
                               lex_synsem &
  [ LOCAL [ ARG-S #comps,
            CAT.VAL.COMPS #comps & < synsem &
                                     [ --MIN #cmin,
                                       NONLOC [ REL 0-dlist,
                                                QUE 0-dlist ],
                                       OPT -,
                                       PUNCT.LPUNCT pair_or_no_punct ] >,
            CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS [ KEYREL #keyrel,
            --COMPKEY #cmin ] ].

;; DPF 2012-03-14 - We wrongly had identified COMPS..PSF with INDEX..SF, but
;; this fails obviously for an example like |if Kim asks `who won?' we quit|
;; So identify it instead with the SF of the KEYREL.ARG0.
reg_onearg_subconj_synsem := basic_onearg_subconj_synsem & 
			      subconj_lex_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT.PSF #iforce,
			    NONLOC.SLASH 0-dlist ] >,
    LKEYS.KEYREL.ARG0.SF #iforce ].

norm_onearg_subconj_synsem := reg_onearg_subconj_synsem &
  [ LOCAL.CAT [ HEAD.PRD -,
		VAL.SPR < [ --MIN just_only_deg_rel ] > ] ].

basic_subconj_cp_synsem := basic_onearg_subconj_synsem & cp_addin_tam_pn &
  [ LOCAL [ CAT [ VAL [ COMPS < #keycomp &
			      [ LOCAL.CONT.HOOK [ LTOP #cltop,
						  INDEX event ],
				NONLOC.SLASH 0-dlist ] >,
			KCMP #keycomp ],
                  HC-LEX - ],
            CONT [ RELS <! relation &
                           [ ARG2 #subord ] !>,
                   HCONS <! qeq, qeq & [ HARG #subord,
                                         LARG #cltop ] !> ] ] ].

subconj_cp_synsem := basic_subconj_cp_synsem & reg_onearg_subconj_synsem.

subconj_synsem := subconj_cp_synsem & 
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT s_cat_unspec & 
					[ MC -,
					  HEAD verb & [ VFORM fin ] ],
				    CONT.HOOK.INDEX.SF prop-or-comm ],
			    --SIND.E.TENSE real_tense ] > ].
                         
subconj_ind_synsem := subconj_synsem &
  [ LOCAL.CAT [ HEAD.PRD -,
		VAL [ SPR < [ --MIN just_only_deg_rel ] >,
		      COMPS < [ LOCAL.CAT s_cat_fin &
                                    [ HEAD.TAM.MOOD ind_or_modal_subj ]] > ]]].

#|
subconj_sbjnct_synsem := subconj_synsem &
  [ LOCAL.CAT [ HEAD.PRD -,
		VAL [ SPR < [ --MIN just_only_deg_rel ] >,
		      COMPS < [ LOCAL.CAT s_cat_fin &
                                    [ HEAD.TAM.MOOD basic_subjunctive ]] > ]]].
|#

; 'Kim arrived, as did Abrams.'
subconj_cp_inv_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
					        [ INV +,
						  AUX +,
						  TAM indic_tam,
						  MINORS.ALTMIN ellipsis_rel,
						  MOD *anti_list* ],
					      VAL [ SUBJ < anti_synsem_min >,
                                                  COMPS < > ] ],
					CONT.HOOK [ LTOP #cltop,
						    INDEX event & 
							 [ SF prop ] ] ],
				NONLOC [ SLASH 0-dlist & [ LIST < > ],
					 QUE 0-dlist,
					 REL 0-dlist ] ] >,
                  HC-LEX - ],
	    CONT [ RELS <! relation &
                           [ ARG2 #mtop ] !>,
                   HCONS <! qeq, qeq & [ HARG #mtop,
                                         LARG #cltop ] !> ] ] ].

; 'We'll stay as time permits'
; Restrict to nonaux subord clause, to avoid spurious ambig for id-copula
;; DPF 2012-09-28 - Restrict further to not-left-modified clause, to avoid
;; spurious analyses of "as though ..." constructions, as in
;; |as though the author was growing less interested|
;;
subconj_cp_gap_synsem := subconj_lex_synsem & lex_synsem & cp_addin_tam_pn &
  [ LOCAL [ CAT [ HEAD.PRD -,
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
		        COMPS #comps &
                          < #keycomp &
			    [ --MIN #cmin,
                              LOCAL [ CAT [ HEAD verb &
                                                 [ INV -,
                                                   AUX - ],
                                            VAL [ SUBJ < anti_synsem_min >,
                                                  COMPS < > ],
                                            MC - ],
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX event & 
						       [ SF prop ] ] ],
			      MODIFD notmod_or_rmod,
                              NONLOC [ SLASH 1-dlist &
                                             <! arg-local &
					      [ CAT [ HEAD n_or_adv,
						      VAL.SPR *olist* ],
						CONT.HOOK.INDEX.SORT
						    basic-entity-or-event ] !>,
				       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT -,
                              PUNCT [ LPUNCT no_punct,
                                      RPUNCT.PSF #iforce ] ] >,
			KCMP #keycomp ],
                  HC-LEX - ],
	    CONT [ RELS <! relation & #keyrel &
                           [ ARG2 #mtop ] !>,
                   HCONS <! qeq, qeq & [ HARG #mtop,
                                         LARG #cltop ] !> ],
            ARG-S #comps ],
    NONLOC non-local_none,
    LKEYS [ KEYREL #keyrel & [ ARG0.SF #iforce ],
            --COMPKEY #cmin ] ].

subconj_cp_cp-gap_synsem := subconj_lex_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CONT.HOOK.INDEX #mevent ] >,
			 PRD - ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
		        COMPS #comps &
                          < #keycomp &
			    [ --MIN #cmin,
                              LOCAL [ CAT [ HEAD verb &
                                                 [ AUX +,
						   MINORS.ALTMIN passive_rel,
						   TAM indic_tam,
						   VFORM fin ],
					    VAL [ SUBJ 
						  < synsem &
						    [ LOCAL.CAT.HEAD noun,
						      NONLOC.SLASH 0-dlist ] >,
						  COMPS < > ],
                                            MC na_or_- ],
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX event & 
						       [ SF prop ],
						  --SLTOP #sltop  ] ],
                              NONLOC [ SLASH 1-dlist &
                                         <! [ CAT [ HEAD comp & [ VFORM fin ],
						    VAL [ SPR *olist*,
							  COMPS *olist* ]]] !>,
				       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT -,
                              PUNCT [ LPUNCT no_punct,
                                      RPUNCT.PSF #iforce ] ] >,
			KCMP #keycomp ],
                  HC-LEX - ],
	    CONT [ RELS <! relation & #keyrel &
                           [ ARG2 #mtop ],
			   #altkeyrel &
			   relation & [ LBL #sltop,
					PRED v_event_rel,
					ARG0 #proarg0 & event ],
			   #alt2keyrel &
			   relation & [ LBL #sltop,
					PRED id_rel,
					ARG1 #mevent,
					ARG2 #proarg0 ] !>,
                   HCONS <! qeq, qeq & [ HARG #mtop,
                                         LARG #cltop ] !> ],
            ARG-S #comps ],
    NONLOC non-local_none,
    LKEYS [ KEYREL #keyrel & [ ARG0.SF #iforce ],
            ALTKEYREL #altkeyrel,
            ALT2KEYREL #alt2keyrel,
            --COMPKEY #cmin ] ].


; DPF 28-jul-06 - Dropped the zero-pronoun semantics for the subordinate
; infinitival clause - no motivation for it.  But still constrain the XARG
; of the infinitival to be non_expl, and SORT entity to reduce ambiguity
; for e.g. 'Kim tried to be winning.'
; DPF 21-apr-08 - Removed MOD..CAT s_cat_fin_or_imp to allow modif of
; VPs, as in "He arose to wave and sat down again"
; DPF 16-jul-2010 - Added identity of MOD..SUBJ..INDEX and COMPS..XARG so we
; bind the XARG of the complement VP just in case we are modifying a VP, 
; effectively identifying it with the XARG of the VP being modified, but avoid
; always unifying with the MOD's XARG since this is sometimes incorrect when
; the MOD value is a full sentence.  Here are three classes of counterexamples
; to the claim that the index of the syntactic subject of ARG1 is always 
; identified with the index of the implicit subject of the "(in order) to" 
; verb phrase:
; 1. Expletive subjects (where the syntactic subject of the main clause has 
; no semantics of its own)
;   In order to have a winner, there has to be a loser.
;   In order to win the race, it seems that John took a shortcut.
; 2. Bridging verbs
;   In order to get a seat, I think you'll need to arrive early.
;   In order to get a seat, I'm sure he must have arrived early.
; 3. Direct conflicts (the most problematic counterexamples)
;   In order to have a winner, somebody else has to lose.
;   In order to make himself popular, we advised John to kiss more babies.
; So we take advantage of the fact that when the "in order to" phrase 
; follows what it modifies, we typically get two analyses, one attaching to
; VP (where we effectively impose the XARG identity), and one attaching to
; S, where we don't.  This solution is sort of a hack, since it takes advantage
; of our representation of (most) S's as having SUBJ < anti_synsem >, where
; that SUBJ's INDEX is (of course) unbound.  The cleaner alternative would be
; to split this lexical entry for "to" (and "in order to") into two, one for
; VP modification and one for S.  But let's try managing with just one entry.
; DPF 2011-04-17 - Removed identify of COMPS..PSF and INDEX.SF, since this
; blocked |this is why we arise to arrive|.  Don't recall why this was here.

subconj_bse_or_inf_synsem := basic_onearg_subconj_synsem & subconj_lex_synsem &
  [ LOCAL [ CAT [ HEAD 
		  [ MOD 
		     < [ MODIFD.LPERIPH -,
			 LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #xarg]>,
		    PRD + ],
                  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS < [ LOCAL 
                                [ CAT vp_cat &
                                      [ VAL [ SPR *olist* ] ],
                                  CONT.HOOK [ LTOP #vpltop,
                                              INDEX event &
                                                [ E.TENSE no_tense ],
                                              XARG non_expl-ind & #xarg ]]] > ],
                  HC-LEX - ],
            CONT [ HOOK.XARG #xarg,
		   RELS <! subord_relation & [ ARG2 #subord ] !>,
                   HCONS <! qeq, 
                            qeq & [ HARG #subord,
                                    LARG #vpltop ] !> ] ] ].

subconj_bse_synsem := subconj_bse_or_inf_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT vp_bse_cat &
				      [ HEAD.MINORS.ALTMIN non_ellipt_rel,
					VAL.SUBJ < unexpressed_reg > ] ] > ].

subconj_inf_synsem := subconj_bse_or_inf_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT vp_inf_cat ] > ].

; DPF 2/6/02 - Changed COMPS..SPR synsem to synsem_min in order to support 
; e.g. 'I slipped while dancing'
; DPF 5/20/02 - Cannot require that COMPS..SUBJ..INDEX be re-entrant with
; the MOD..AGR, since get sentences like "There are age restrictions when
; renting a car" where the AGR is there_expl, but the INDEX is ref-ind.  
; So the subject of the predicative phrase must be discourse-bound.
; DPF 30-May-02 - TO DO - constrain complement to be non-temporal, to allow
; "when there" but block "when Tuesday".
; DPF 3-May-03 - Made [COMPS..MOD..HEAD noun] to avoid some of the  spurious 
; ambiguity for e.g. "Kim knows when to arrive".
; DPF 22-apr-04 - Removed SPR < synsem_min > from complement, since this
; prevents "when really necessary", and it's not clear what it was supposed
; to be blocking.
; DPF 20-aug-04 - Removed [MOD..MSG message] even though this was helping
; with seemingly spurious ambiguity, because it blocked attachment to
; subordinate clauses, as in "if you slip while dancing, you fall".

subconj_prd_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.VFORM non_inf ] >,
                  VAL.COMPS < [ LOCAL [ CAT prd_or_adv_cat,
                                        CONT.HOOK [ LTOP #prdltop,
                                                    XARG non_expl-ind ] ]] > ],
            CONT [ RELS <! subord_relation & [ ARG2 #cltop ] !>,
                   HCONS <! qeq, qeq & [ HARG #cltop,
                                         LARG #prdltop ] !> ] ] ].

subconj_prd_pre_synsem := subconj_prd_synsem &
  [ LOCAL.CAT.POSTHD - ].

subconj_prd_post_synsem := subconj_prd_synsem &
  [ LOCAL [ CAT.POSTHD +,
            CONT.HOOK.INDEX.SF #iforce ],
    PUNCT.RPUNCT.PSF #iforce ].

; For "so" of "I can be there, so yes/no/okay"
subconj_disc_adv_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT s_cat_fin_or_imp,
                               MODIFD.LPERIPH - ] >,
                  VAL.COMPS < [ LOCAL [ CAT [ HEAD root-marker,
                                              POSTHD - ],
                                        CONT.HOOK [ LTOP #cltop,
                                                    INDEX.SF prop ] ],
                                LEX + ] >,
                  HC-LEX -,
                  POSTHD + ],
            CONT [ HOOK.INDEX.SF #iforce,
                   RELS <! subord_relation & [ ARG2 #subord ] !>,
                   HCONS <! qeq, qeq & [ HARG #subord,
                                         LARG #cltop ] !> ] ],
    PUNCT.RPUNCT.PSF #iforce ].

; DPF 14-May-02 - Cost of having this complementizer-like analysis is that
; we don't get conjoined if-clauses like "If you leave and he stays, I win"
; So why do we have this analysis?  Can't remember ...
; DPF 01-Jun-07 - Removed identity of MOOD on main and subord clauses, due to
; "If it were true, you can be sure we would know" where the irrealis is in
; the complement clause - too hard to pass through, so let's overgenerate.
;; DPF 2013-02-13 - Constrain to non-local empty on both complements.
;
; 'For Kim to win, Abrams must lose'
;; DPF 2014-06-04 - Changed COMPS.REST.FIRST..COMPS from *olist* to < > to avoid
;; spurious ambig of e.g. |with Kim angry, ...|
;;
subconj_twoarg_synsem := subconj_lex_synsem & basic_two_arg &
  [ LOCAL [ ARG-S #comps,
            CAT [ HEAD [ TAM.MOOD #mood,
			 PRD -,
                         MOD < [ LOCAL [ CAT s_cat_fin_or_imp &
                                           [ HEAD.TAM.MOOD #mood ] ],
                                 NONLOC.SLASH 0-dlist,
                                 MODIFD.LPERIPH - ] > ],
                  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
		        COMPS #comps &
                              < synsem &
                                [ LOCAL [ CAT np_cat_acc_min,
                                          CONJ cnil ],
                                  NONLOC non-local_none,
                                  --SIND #ind,
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ],
                                synsem &
                                [ LOCAL
                                  [ CAT [ HEAD.TAM.MOOD #mood,
                                          VAL.COMPS < > ],
                                    CONT.HOOK [ LTOP #chand,
                                                INDEX.SF prop,
                                                XARG #ind ] ],
                                  NONLOC non-local_none,
                                  OPT -,
                                  PUNCT [ LPUNCT no_punct,
                                          RPUNCT.PSF #iforce ] ] > ],
		  HC-LEX - ],
            CONT [ RELS <! subord_relation & #keyrel &
                           [ ARG2 #sub,
                             ARG0 [ E [ TENSE no_tense,
                                        ASPECT no_aspect ] ] ] !>,
                   HCONS <! qeq, qeq & [ HARG #sub,
                                         LARG #chand ] !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG0.SF #iforce ] ].

subconj_for_synsem := subconj_twoarg_synsem &
  [ LOCAL.CAT.VAL.COMPS 
		  < [ LOCAL.AGR #agr ],
		    [ LOCAL.CAT [ HEAD comp & [ VFORM inf ],
				  VAL.SUBJ < synsem &
					     [ LOCAL.AGR #agr,
					       NONLOC.SLASH 0-dlist ] > ]] > ].
                                                
; For predicatives, like "with Kim angry, no one smiled"
;; DPF 2014-06-04 - Constrain COMPS.REST.FIRST..MOD..HEAD to basic_noun, to
;; block (in-order-)to-VP as in |with Kim to arrive soon, ...|
;;
subconj_with_synsem := subconj_twoarg_synsem &
  [ LOCAL.CAT.VAL.COMPS 
		  < synsem, 
		    [ LOCAL.CAT [ HEAD v_or_a_or_p &
				       [ PRD +,
					 MOD < [ LOCAL.CAT.HEAD basic_noun ] >],
				  VAL.SUBJ *olist* ] ] > ].

; Since we don't (yet) have a treatment of predicative NPs, add separate
; type for "With Kim the president, no one worried."
; But block robust bare singular for second NP
subconj_with_np_np_synsem := subconj_lex_synsem & basic_two_arg &
  [ LOCAL [ ARG-S #comps,
	    CAT [ HEAD [ TAM.MOOD #mood,
			 PRD -,
                         MOD < [ LOCAL [ CAT s_cat_fin_or_imp &
                                           [ HEAD.TAM.MOOD #mood ] ],
                                 NONLOC.SLASH 0-dlist,
                                 MODIFD.LPERIPH - ] > ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS #comps &
                              < synsem &
                                [ LOCAL [ CAT np_cat_acc_min,
                                          CONJ cnil ],
                                  NONLOC.SLASH 0-dlist,
                                  --SIND #ind1,
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ],
                                synsem &
                                [ LOCAL
                                  [ CAT np_cat_nonnom &
					[ HEAD.--BARE - ],
				    CONJ cnil ],
                                  NONLOC.SLASH 0-dlist,
                                  --SIND #ind2,
                                  OPT -,
				  --MIN nom_nbar_rel,
                                  PUNCT [ LPUNCT no_punct,
                                          RPUNCT.PSF #iforce ] ] > ],
                  HC-LEX - ],
            CONT [ RELS <! subord_relation & #keyrel &
                           [ ARG2 #sub,
                             ARG0 [ E [ TENSE no_tense,
                                        ASPECT no_aspect ] ],
			     CFROM #cfrom, CTO #cto ],
			   [ PRED cop_id_rel,
			     LBL #chand,
			     ARG1 #ind1,
			     ARG2 #ind2,
			     CFROM #cfrom, CTO #cto ]!>,
                   HCONS <! qeq, qeq & [ HARG #sub,
                                         LARG #chand ] !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG0.SF #iforce ] ].



; For sentence-initial discourse-level PPs like in "as for Chiang, who hired
; her?"
subconj_np_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT s_cat_fin_or_imp,
				       CONT.HOOK.INDEX.SF basic-prop ],
			       NONLOC.SLASH 0-dlist,
			       MODIFD.LPERIPH - ] >,
		  VAL.COMPS < [ LOCAL [ CAT nomp_cat_nonnom_min &
					    [ HEAD basic_noun ],
                                        CONT.HOOK.INDEX #ind &
					                non_expl-ind ] ] >,
                  POSTHD - ],
            CONT [ RELS <! subord_relation & [ ARG2 #subord ],
			   #altkeyrel &
                           unknown_relation &
                           [ LBL #cltop,
                             ARG #ind ] !>,
                   HCONS <! qeq, qeq & [ HARG #subord,
                                         LARG #cltop ] !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

subconj_word := noncqrs-h-nab &
  [ SYNSEM subconj_lex_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT -,
				     NONLOC.SLASH 0-dlist,
				     PUNCT.RPUNCT.PSF #iforce ] >,
	     LKEYS.KEYREL.ARG0.SF #iforce ] ].
    
;; For subordinating preps like 'after' which don't allow topicalized S compl:
;; "*Kim left, after on Tuesday Kim had already arrived."
;; Also take meas-NP specifiers as in "two weeks after ..."
;; DPF 21-mar-10 - Can't make compl be POSTHD -, since ordinary sb-hd phrases
;; are POSTHD +, just like topicalized clauses.  So require complement to be
;; CASE obliq, which prevents topicalized clauses.
;;
; <type val="p_cp_s-notop_le">
; <description>Prep, S, no prep stranding       
; <ex>After B lost, C won.
; <nex>
; <todo>
; </type>
p_cp_s-notop_le := subconj_word &
  [ SYNSEM subconj_synsem & 
           [ LOCAL.CAT.VAL [ SPR < [ --MIN just_only_notvery_deg_rel ] >,
			     COMPS < [ LOCAL.CAT.HEAD.CASE obliq ] > ] ] ].

; For subordinating preps like 'since' which allow topicalized S compl, as in
; 'Kim left, since on Tuesday Browne had already arrived'
; <type val="p_cp_s_le">
; <description>Prep, S, subord                  
; <ex>B won since C lost.
; <nex>
; <todo>
; </type>
p_cp_s_le := subconj_word &
  [ SYNSEM subconj_ind_synsem ].

; "for"
; <type val="p_cp_s-post_le">
; <description>Prep, S, no fronting             
; <ex>C lost, for B won.
; <nex>
; <todo>
; </type>
p_cp_s-post_le := subconj_word &
  [ SYNSEM subconj_ind_synsem &
           [ LOCAL.CAT.POSTHD + ] ].

; For ones like "as if" which can take subjunctive CP complement
; <type val="p_cp_s-unsp_le">
; <description>Prep, S, unsp for subord         
; <ex>C won, as if B were here.
; <nex>
; <todo>
; </type>
p_cp_s-unsp_le := subconj_word &
  [ SYNSEM subconj_synsem &
	   [ LOCAL.CAT [ HEAD.PRD -,
			 VAL.SPR < [ --MIN just_only_deg_rel ] > ] ] ].

; 'Kim left, as did Abrams'
; <type val="p_cp_inv-s_le">
; <description>Prep, S, subord, inverted        
; <ex>B won, as did C.
; <nex>
; <todo>
; </type>
p_cp_inv-s_le := subconj_word &
  [ SYNSEM subconj_cp_inv_synsem ].

; 'Kim will stay as time permits'
; <type val="p_cp_gap-s_le">
; <description>Prep, S, object NP gap           
; <ex>C sings, as time permits.
; <nex>
; <todo>
; </type>
p_cp_gap-s_le := noncqrs-h-nab &
  [ SYNSEM subconj_cp_gap_synsem ].

; 'as has been shown'
; <type val="p_cp_cp-gap_le">
; <description>Prep, S, subj gap                
; <ex>C wins, as has been seen.
; <nex>
; <todo>
; </type>
p_cp_cp-gap_le := noncqrs-h-nab &
  [ SYNSEM subconj_cp_cp-gap_synsem ].

; Post-head subordinating prep colon, which also allows
; imperatives: "Berlin: See brochure"

; <type val="p_cp_s-cln_le">
; <description>Prep, S, only colon              
; <ex>C wins: B loses.
; <nex>
; <todo>
; </type>
p_cp_s-cln_le := noncqrs-h-nab &
  [ SYNSEM basic_subconj_cp_synsem & basic_onearg_subconj_synsem &
	   subconj_lex_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ *anti_list* ] >,
			   VAL [ SPR *anti_list*,
				 COMPS < [ OPT -,
					 LOCAL.CAT s_cat_unspec &
					     [ HEAD [ VFORM fin_or_inf_or_imp,
						      TAM indic_tam ],
					       VAL.SPR *olist*,
					       MC + ],
					 NONLOC.SLASH 0-dlist,
					 PUNCT.RPUNCT.PSF #sf ] > ],
			   POSTHD + ],
		     CONT.HOOK.INDEX.SF #sf ] ] ].

; DPF 14-Oct-02 - Collapse above two, just specifying real_tense.

; <type val="p_cp_s-for_le">
; <description>Prep, S, only 'for'              
; <ex>C wins, for B loses.
; <nex>
; <todo>
; </type>
p_cp_s-for_le := noncqrs-nab &
  [ SYNSEM subconj_for_synsem ].

; <type val="p_cp_s-ncop_le">
; <description>Prep, S, nocop frag              
; <ex>With B losing, C can win.
; <nex>
; <todo>
; </type>
p_cp_s-ncop_le := noncqrs-nab &
  [ SYNSEM subconj_with_synsem ].

; <type val="p_np-np_s-ncop_le">
; <description>Prep, double-np subord nocop
; <ex>With B the leader, C can win.
; <nex>
; <todo>
; </type>
p_np-np_s-ncop_le := noncqrs-nab &
  [ SYNSEM subconj_with_np_np_synsem ].

; <type val="p_vp_bse_le">
; <description>Prep, vp(bse)                    
; <ex>B won to avenge C.
; <nex>
; <todo>
; </type>
p_vp_bse_le := nonconj & non_affix_bearing &
  [ SYNSEM subconj_bse_synsem ].

; <type val="p_vp_inf_le">
; <description>Prep, VP, inf                    
; <ex>B raced in order to win.
; <nex>
; <todo>
; </type>
p_vp_inf_le := nonconj & non_affix_bearing &
  [ SYNSEM subconj_inf_synsem ].

; <type val="p_prd_s_le">
; <description>Prep, pred-phr, scopal           
; <ex>B sulked while unhappy.
; <nex>
; <todo>
; </type>
p_prd_s_le := noncqrs-nab &
  [ SYNSEM subconj_prd_synsem ].

; <type val="p_prd_s-v-p_le">
; <description>Prep, pred-phr, non-adjective    
; <ex>B won while in Paris.
; <nex>
; <todo>
; </type>
p_prd_s-v-p_le := noncqrs-nab &
  [ SYNSEM subconj_prd_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD v_or_p &
                                         [ TAM.ASPECT.PROGR - ] ] > ] ].

; <type val="p_np_s_le">
; <description>Prep, NP, subord                 
; <ex>Of these dogs, none won. 
; <nex>
; <todo>
; </type>
p_np_s_le := noncqrs-nab &
  [ SYNSEM subconj_np_synsem ].

; <type val="p_adv_s_le">
; <description>Prep, disc-adv, subord           
; <ex>B won, so yes.
; <nex>
; <todo>
; </type>
p_adv_s_le := noncqrs-nab &
  [ SYNSEM subconj_disc_adv_synsem ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Coordinating conjunctions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; HACK: For efficiency, restrict conjunctions to only coordinate phrases which 
; are saturated for COMPS.  This falsely excludes "Kim bought and sold a car".
; DPF (25-Apr-98) Removed COMPS..HEAD subst constraint, to allow 
; "your and my offices"
; DPF 8-Jun-99 - Removed hack on saturated COMPS - was blocking e.g. "between
; eleven and one p.m."
; DPF 15-May-03 - Discovered that the change to use LKEYS meant all subtypes
; of word were undesirably being coerced to be [LEX +] since type inference
; determined from the LKEYS attribute in 'word' that the synsem type should be
; abstract_lex_synsem which also introduces [LEX +].  This meant among other
; things that conj_word was always [LEX +*] rather than unspecified, and hence
; we could not parse e.g. "Kim is hiring Abrams and firing Browne" though we
; could still parse "Kim hired Abrams and fired Browne".  Now corrected, maybe.
; DPF 29-may-07 - Made conj_word be [LEX na] so we can prevent these from
; being right dtrs in coord phrases by themselves.  Were using nonlex_synsem
; constraint on those right dtrs, but this was inconsistent with "Kim etc,"
; where "etc," has lex_punct_synsem.
; DPF 10-sept-07 - Finally realized that conjunctions were interacting badly
; with chart dependencies, since these words identify their HEAD value with
; that of their complement, which means that they are lexically underspecified
; and hence unifiable with any requirement on MINORS.MIN.  In principle,
; should constrain the chart dependency mechanism to ignore CONJ + entries.
; For now, exclude coordination of selected PPs to gain better efficiency.

basic_conj_word := word &
  [ INFLECTD +,
    SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD #head & [ MINORS.MIN independent_rel ],
		     VAL [ SUBJ #subj,
                           SPEC #spec,
			   COMPS < synsem &
				   [ LOCAL [ CAT [ HEAD #head,
						   VAL [ SUBJ #subj,
                                                         SPEC #spec,
                                                         COMPS #comps,
							 SPCMPS #spcmps],
                                                   HC-LEX #hclex ],
                                             CONT.HOOK.XARG #xarg,
                                             CONJ cnil ],
				     OPT -,
                                     PUNCT.LPUNCT pair_or_no_punct ] 
				   . #comps >,
			   SPCMPS #spcmps ],
                     HC-LEX #hclex ],
               CONT.HOOK.XARG #xarg ],
       LEX na,
       PUNCT no_punctuation_min ] ].

conj_word := basic_conj_word &
  [ SYNSEM.LOCAL.CAT [ MC #mc,
		       VAL [ SPR #spr,
			     COMPS < [ LOCAL.CAT [ MC #mc,
						   VAL.SPR #spr ] ] > ] ] ].

; A coordinating conjunction needs to "prime" the CONJ.LBLS and
; CONJ.INDICES lists, so that the right side of a binary coordination looks
; like an iterated coordination.

norm_conj_word := conj_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR.DIV #div ], ... >,
                     AGR.DIV #div ],
             LKEYS.KEYREL basic_conj_relation &
		          [ ARG0 conj-ind ] ] ].

basic_conj_complex_lexent := conj_word &
  [ SYNSEM [ LOCAL [ CONJ.CREL #keyrel,
                     CONT [ HOOK [ LTOP #chand,
                                   INDEX #cind ],
                            RELS <! #keyrel &
                                  [ LBL #chand,
                                    ARG0 #cind ] !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

conj_complex_lexent := basic_conj_complex_lexent & norm_conj_word.

; DPF 14-apr-05 - We should distinguish conjoined mass nouns, which can produce
; a still singular phrase ('this hardiness and zest for life') from count nouns
; which are always(?) plural when conjoined, whether singular or plural.  But
; we don't have a natural class of count (whether sg or pl) vs mass, so can't
; easily split this entry into two.
; DPF 01-sept-06 - Re 14-apr-05: Now that we have multiple n-bar coord rules,
; we can locate the AGR..PN 3p in the specific construction that coordinates
; DIV - nouns.  So removed AGR..PN 3p from c_xp_and_le, cp_xp_and-both_le.
; DPF 20-sept-06 - But this would mean we parse "Abrams and Browne arrives", 
; so we use the new attribute CONJ.CPNG to distinguish 'and' from 'or', and
; have only the NP-coord rule (not the nbar-coord rule) include this
; constraint on the mother.

c_xp_and_lexent := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD both_or_cnil,
                                     CPNG.PN 3p ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

; <type val="c_xp_and_le">
; <description>Conj, only 'and'                 
; <ex>B and C arrived.
; <nex>
; <todo>
; </type>
c_xp_and_le := c_xp_and_lexent.

; <type val="c_xp_and-mal_le">
; <description>Conj, only 'and', robust
; <ex>B and and C arrived.
; <nex>
; <todo>
; </type>
c_xp_and-mal_le := c_xp_and_lexent &
  [ GENRE robust ].

; '(first) Kim and then Sandy'
; <type val="c_xp_and-then_le">
; <description>Conj, only 'and then'            
; <ex>B saw C and then D.
; <nex>
; <todo>
; </type>
c_xp_and-then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD subst ], ... >,
                   CONJ lex-conj & [ CHEAD first_or_cnil ],
		   CONT.RELS <! [ PRED _and+then_c_rel ] !> ] ].

; <type val="c_xp_and-also_le">
; <description>Conj, only 'and also'            
; <ex>B saw C and also D.
; <nex>
; <todo>
; </type>
c_xp_and-also_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+also_c_rel ] !> ] ].

; <type val="c_xp_and-yet_le">
; <description>Conj, only 'and yet'             
; <ex>B ran fast and yet lost.
; <nex>
; <todo>
; </type>
c_xp_and-yet_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+yet_c_rel ] !> ] ].

; <type val="c_xp_and-thus_le">
; <description>Conj, only 'and thus'            
; <ex>B ran slow and thus lost.
; <nex>
; <todo>
; </type>
c_xp_and-thus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+thus_c_rel ] !> ] ].

; <type val="c_xp_and-not_le">
; <description>Conj, only 'and not'             
; <ex>B and not C fell.
; <nex>
; <todo>
; </type>
c_xp_and-not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+not_c_rel ] !> ] ].

; DPF 31-oct-05 - Make [CONJ phr-conj] to avoid spurious ambiguity for
; "Then we should go."
; 'first Kim, then Sandy'
; <type val="c_xp_then_le">
; <description>Conj, only 'then'                
; <ex>B tripped then fell.
; <nex>
; <todo>
; </type>
c_xp_then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL.COMPS < > ] ] >,
		   CONJ phr-conj & [ CHEAD first_or_cnil ],
		   CONT.RELS <! [ PRED _then_c_rel ] !> ] ].


; <type val="c_xp_and-so_le">
; <description>Conj, only 'and so'              
; <ex>B tripped asn so fell.
; <nex>
; <todo>
; </type>
c_xp_and-so_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+so_c_rel ] !> ] ].


; <type val="c_xp_and-finally_le">
; <description>Conj, only 'and finally'         
; <ex>B raced and finally won.
; <nex>
; <todo>
; </type>
c_xp_and-finally_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+finally_c_rel ] !> ] ].

; <type val="c_xp_or-else_le">
; <description>Conj, only 'or else'             
; <ex>B won or else tied.
; <nex>
; <todo>
; </type>
c_xp_or-else_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _or+else_c_rel ] !> ] ].

; <type val="c_xp_else_le">
; <description>Conj, only 'else'             
; <ex>B must win, else A loses.
; <nex>
; <todo>
; </type>
c_xp_else_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SUBJ *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _else_c_rel ] !> ] ].

; <type val="c_xp_except-that_le">
; <description>Conj, only 'except that'         
; <ex>B'd win except that C did.
; <nex>
; <todo>
; </type>
c_xp_except-that_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _except+that_c_rel ] !> ] ].

; <type val="c_xp_except_le">
; <description>Conj, only 'except'              
; <ex>B would win except C did.
; <nex>
; <todo>
; </type>
c_xp_except_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD n_or_p,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _except_c_rel ] !> ] ].

; <type val="c_xp_aswellas_le">
; <description>Conj, only 'as well as'          
; <ex>B saw C as well as D.
; <nex>
; <todo>
; </type>
c_xp_aswellas_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD n_or_p_or_a,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD both_or_cnil ],
		   CONT.RELS <! [ PRED _as+well+as_c_rel ] !> ] ].

c_xp_but_lexent := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD non_noun_or_adv ] >,
                   CONJ lex-conj & [ CHEAD not_or_cnil ],
		   CONT.RELS <! [ PRED _but_c_rel ] !> ] ].

; <type val="c_xp_but_le">
; <description>Conj, only 'but'                 
; <ex>B ran fast but lost.
; <nex>
; <todo>
; </type>
c_xp_but_le := c_xp_but_lexent.

; <type val="c_xp_but-mal_le">
; <description>Conj, only 'but', robust
; <ex>B ran fast but but lost.
; <nex>
; <todo>
; </type>
c_xp_but-mal_le := c_xp_but_lexent &
  [ GENRE robust ].

; <type val="c_xp_but-np_le">
; <description>Conj, only 'but' with NPs        
; <ex>B hired consultants but no engineers.
; <nex>
; <todo>
; </type>
c_xp_but-np_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD basic_noun ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _but_c_rel ] !> ] ].

; <type val="c_xp_but-np-not_le">
; <description>Conj, only 'but' with NPs, paired with `not'
; <ex>B hired not C but D.
; <nex>
; <todo>
; </type>
c_xp_but-np-not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD basic_noun ] >,
                   CONJ lex-conj & [ CHEAD not-conj ],
		   CONT.RELS <! [ PRED _but_c_not_rel ] !> ] ].

; <type val="c_xp_nor_le">
; <description>Conj, only 'nor'                 
; <ex>B can't sing nor dance.
; <nex>
; <todo>
; </type>
c_xp_nor_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD neither_or_cnil ],
		   CONT.RELS <! [ PRED _nor_c_rel ] !> ] ].

c_xp_or_lexent := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD either_or_cnil ],
		   CONT.RELS <! [ PRED _or_c_rel ] !> ] ].  

; <type val="c_xp_or_le">
; <description>Conj, only 'or'                  
; <ex>B saw C or D.
; <nex>
; <todo>
; </type>
c_xp_or_le := c_xp_or_lexent.

; <type val="c_xp_or-mal_le">
; <description>Conj, only 'or', robust
; <ex>B saw C or or D.
; <nex>
; <todo>
; </type>
c_xp_or-mal_le := c_xp_or_lexent &
  [ GENRE robust ].

; <type val="c_xp_plus_le">
; <description>Conj, only 'plus'                
; <ex>B saw C plus D.
; <nex>
; <todo>
; </type>
c_xp_plus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _plus_c_rel ] !> ] ].

; <type val="c_xp_plus-minus_le">
; <description>Conj, only '+/-'                 
; <ex>B saw them +/- C.
; <nex>
; <todo>
; </type>
c_xp_plus-minus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _plus-minus_c_rel ] !> ] ].

; DPF 31-oct-05 - Make [CONJ phr-conj] to avoid spurious ambiguity for
; "So we should leave."
; DPF 10-oct-10 - But this makes external interface too mysterious for
; generation, so live with ambiguity.
; DPF 13-aug-09 - Treating 'so' as a conjunction wrongly excludes S-initial
; order: "So Kim could win, we ran more slowly".  Change (back) to subord.
; <type val="c_xp_so_le">
; <description>Conj, only 'so'                  
; <ex>B runs fast so should win.
; <nex>
; <todo>
; </type>
c_xp_so_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --SIND event ] >,
		   CONJ.CHEAD cnil,
		   CONT.RELS <! [ PRED _so_c_rel ] !> ] ].

; <type val="c_xp_vs_le">
; <description>Conj, only 'vs'                  
; <ex>B prefers C vs. D.
; <nex>
; <todo>
; </type>
c_xp_vs_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _versus_c_rel ] !> ] ].

; <type val="c_xp_minus_le">
; <description>Conj, only 'minus'               
; <ex>B saw everyone minus C.
; <nex>
; <todo>
; </type>
c_xp_minus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CAT.VAL.COMPS < [ LOCAL.CAT.HEAD noun ] >,
		   CONT.RELS <! [ PRED _minus_c_rel ] !>,
                   AGR.PNG png & [ PN 3s ] ] ].

; <type val="c_xp_but-not_le">
; <description>Conj, only 'but not'             
; <ex>B saw C but not D.
; <nex>
; <todo>
; </type>
c_xp_but-not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _but+not_c_rel ] !> ] ].

; <type val="c_xp_if-not_le">
; <description>Conj, only 'if not'              
; <ex>B saw C if not D.
; <nex>
; <todo>
; </type>
c_xp_if-not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _if+not_c_rel ] !> ] ].

; <type val="c_xp_but-then_le">
; <description>Conj, only 'but then'            
; <ex>B ran fast but then lost.
; <nex>
; <todo>
; </type>
c_xp_but-then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD n_or_p_or_a,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _but+then_c_rel ] !> ] ].

; <type val="c_xp_but-also_le">
; <description>Conj, only 'but also'            
; <ex>B saw C but also D.
; <nex>
; <todo>
; </type>
c_xp_but-also_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD notonly_or_cnil ],
		   CONT.RELS <! [ PRED _but+also_c_rel ] !> ] ].

; <type val="c_xp_much-less_le">
; <description>Conj, only 'much less'           
; <ex>B can't run much less win.
; <nex>
; <todo>
; </type>
c_xp_much-less_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _much+less_c_rel ] !> ] ].

; <type val="c_xp_let-alone_le">
; <description>Conj, only 'let alone'           
; <ex>B can't run let alone win.
; <nex>
; <todo>
; </type>
c_xp_let-alone_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _let+alone_c_rel ] !> ] ].

; <type val="c_xp_nottomentn_le">
; <description>Conj, only 'not to mention'      
; <ex>B saw C not to mention D.
; <nex>
; <todo>
; </type>
c_xp_nottomentn_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _not+to+mention_c_rel ] !> ] ].

; <type val="c_xp_nottosay_le">
; <description>Conj, only 'not to say'      
; <ex>B saw C not to say D.
; <nex>
; <todo>
; </type>
c_xp_nottosay_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _not+to+say_c_rel ] !> ] ].

; <type val="c_xp_amp_le">
; <description>Conj, only ampersand             
; <ex>B saw C &amp; D.
; <nex>
; <todo>
; </type>
c_xp_amp_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD both_or_cnil ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

; DPF 18-Mar-03 - How to block finite VP right conjunct?  Note that not only
; VPs can be conjoined.  Note also that blocking VP right conjunct will also
; correctly block sentence conjunction.
;   This data means either having two lexical entries, or pushing VFORM up to
; type 'head' so non-verbal conjuncts are still permitted here even with
; constraint on VFORM nonfin.  Also suggests that lexical conjunctions and 
; not the coord rules determine which properties of 'head' are unified on the
; two conjuncts, if we want to treat these as regular conjunctions.
;   'Kim will buy a truck rather than rent a car'
;   'Kim will buy a truck rather than renting a car'
;   '*Kim bought a truck rather than rented a car'
;   'Kim wanted to buy a truck rather than to rent a car'
;   '*Kim bought a truck rather than Sandy rented a car'
;   'Kim arrived on Tuesday rather than on Wednesday'

; <type val="c_xp_rather_le">
; <description>Conj, only 'rather than'         
; <ex>B saw C rather than D.
; <nex>
; <todo>
; </type>
c_xp_rather_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _rather+than_c_rel ] !> ] ].  

; DPF 18-Mar-03 - Need to block not only finite VP right conjunct, but also 
; base form (and maybe infinitival?)
;   '*Kim will buy a truck instead of rent a car'
;   'Kim will buy a truck instead of renting a car'
;   '*Kim bought a truck instead of rented a car'
;   '?Kim wanted to buy a truck instead of to rent a car'
;   'Kim arrived on Tuesday instead of on Wednesday'

; <type val="c_xp_instead_le">
; <description>Conj, only 'instead of'          
; <ex>B saw C instead of D.
; <nex>
; <todo>
; </type>
c_xp_instead_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _instead+of_c_rel ] !> ] ].  

; <type val="c_xp_and-or_le">
; <description>Conj, only 'and/or'              
; <ex>B saw C and/or D.
; <nex>
; <todo>
; </type>
c_xp_and-or_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

; For e.g. slash in A/B - limit to lexical conjuncts
; <type val="c_xp_and-or-lx_le">
; <description>Conj, only slash, lex conjncts   
; <ex>B saw C/D.
; <nex>
; <todo>
; </type>
c_xp_and-or-lx_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil,
				     CLEX + ],
		   CONT.RELS <! [ PRED _and_c_rel ] !>,
		   CAT.VAL.COMPS.FIRST.LEX + ] ].

; <type val="c_xp_not_le">
; <description>Conj, only 'not'                 
; <ex>B saw C not D.
; <nex>
; <todo>
; </type>
c_xp_not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST [ --SIND ref-ind,
					 LOCAL.AGR.PNG.PN #pn ],
		   CONJ lex-conj & [ CHEAD cnil,
				     CPNG.PN #pn ],
		   CONT.RELS <! [ PRED _not_c_rel ] !> ] ].

; DPF 18-aug-07 - Also for non-finite VPs, PPs, APs, etc., as in
; "We want to win the game, not lose it!"
; <type val="c_xp_not-ev_le">
; <description>Conj, only 'not', event cnjcts   
; <ex>B wants to win, not lose.
; <nex>
; <todo>
; </type>
c_xp_not-ev_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ *synlist*,
                             COMPS.FIRST.--SIND event & [ E.TENSE untensed ] ],
		   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _not_c_rel ] !> ] ].

; <type val="c_xp_yet_le">
; <description>Conj, only 'yet'                 
; <ex>B ran fast yet lost.
; <nex>
; <todo>
; </type>
c_xp_yet_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.--SIND event,
		   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _yet_c_rel ] !> ] ].

; <type val="c_xp_even_le">
; <description>Conj, only 'even'                
; <ex>B saw everyone even C.
; <nex>
; <todo>
; </type>
c_xp_even_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD n_or_p_or_a,
                                                   VAL.SPR *olist* ],
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _even_c_rel ] !> ] ].

; Different since it sets DIV to +, to get e.g.
; 'chair after chair arrived.'
; <type val="c_xp_after_le">
; <description>Conj, only 'after'               
; <ex>Dog after dog barked.
; <nex>
; <todo>
; </type>
c_xp_after_le := basic_conj_complex_lexent &
  [ SYNSEM [ LOCAL [ AGR [ PNG.PN #pn,
                           DIV + ],
                     CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD noun,
                                                     VAL.SPR < synsem > ],
                                               AGR.PNG.PN #pn ] ] >,
                     CONJ lex-conj & [ CHEAD cnil ],
                     CONT.RELS <! [ PRED _after_c_rel ] !> ],
             LKEYS.KEYREL conj_relation ] ].

; <type val="c_xp_albeit_le">
; <description>Conj, only 'albeit'              
; <ex>B saw a cat, albeit C.
; <nex>
; <todo>
; </type>
c_xp_albeit_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adj ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _albeit_c_rel ] !> ] ].


; <type val="c_xp_tog-with_le">
; <description>Conj, only 'together with' with NPs        
; <ex>B, C, together with D arrived.
; <nex>
; <todo>
; </type>
c_xp_tog-with_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD noun,
						 VAL.SPR *olist* ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _together-with_c_rel ] !> ] ].


; <type val="c_xp_though_le">
; <description>Conj, only 'though', excluding NPs and Ss
; <ex>The happy though confused cat jumped.
; <nex>
; <todo>
; </type>
c_xp_though_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD non_noun_or_adv,
						 VAL [ SUBJ *synlist*,
						       SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _though_c_rel ] !> ] ].

; <nex>
; <todo>
; </type>
; <type val="c_xp_rather-mrk_le">
; <description>Conj, only discontinuous 'rather' of |rather V than V|
; <ex>B would rather sing than dance
; <nex>
; <todo>
; </type>
c_xp_rather-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ rather ].

; <type val="c_xp_than_le">
; <description>Conj, only 'than' of discontinuous |rather V than V|
; <ex>B would rather sing than dance.
; <nex>
; <todo>
; </type>
c_xp_than_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL.SUBJ < synsem_min > ] ] >,
		   CONJ lex-conj & [ CHEAD rather ],
		   CONT.RELS <! [ PRED _rather+than_c_rel ] !> ] ].

; DPF 31-jul-06 - Constrain to *olist* SPR to avoid '*the both dog and cat"

basic_conj_atomic_lexent := basic_conj_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ CAT.VAL.SPR *olist*,
                                               CONT.HOOK #hook,
                                               CONJ cnil ],
		   CONJ atomic-conj,
		   CONT [ HOOK #hook,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

conj_atomic_lexent := basic_conj_atomic_lexent & norm_conj_word.

; <type val="c_xp_both-mrk_le">
; <description>Conj, 'both' paired with 'and'   
; <ex>B saw both C and D.
; <nex>
; <todo>
; </type>
c_xp_both-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ both ].

; <type val="c_xp_btwn-mrk_le">
; <description>Conj, 'between' paired with 'and', numbers only
; <ex>B saw between 10 and 20 cats.
; <nex>
; <todo>
; </type>
c_xp_btwn-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL [ CONJ between,
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD intadj ] ].

; <type val="c_xp_btwn-mz-mrk_le">
; <description>Conj, 'between' paired with 'and', measure NPs only
; <ex>B has between ten dollars and twenty dollars.
; <nex>
; <todo>
; </type>
c_xp_btwn-mz-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL [ CONJ between,
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD noun &
						     [ MINORS.MIN 
						         abstr_meas_nom_rel ],
						   VAL.SPR *olist* ] ] ].

; <type val="c_xp_and-btwn_le">
; <description>Conj, only 'and'                 
; <ex>B and C arrived.
; <nex>
; <todo>
; </type>
c_xp_and-btwn_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD between,
                                     CPNG.PN 3p ],
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD intadj,
		   CONT.RELS <! [ PRED _and_c_btwn_rel ] !> ] ].

; <type val="c_xp_and-btwn-mz_le">
; <description>Conj, only 'and'                 
; <ex>B and C arrived.
; <nex>
; <todo>
; </type>
c_xp_and-btwn-mz_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD between,
                                     CPNG.PN 3p ],
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD noun &
					             [ MINORS.MIN 
						          abstr_meas_nom_rel ],
						   VAL.SPR *olist* ],
		   CONT.RELS <! [ PRED _and_c_btwn_rel ] !> ] ].

; <type val="c_xp_from-mrk_le">
; <description>Conj, 'from' paired with 'to', numbers only
; <ex>B saw from 10 to 20 cats.
; <nex>
; <todo>
; </type>
c_xp_from-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL [ CONJ from-conj,
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD intadj ] ].

; <type val="c_xp_from-mz-mrk_le">
; <description>Conj, 'from' paired with 'to', measure NPs only
; <ex>B has from ten dollars to twenty dollars.
; <nex>
; <todo>
; </type>
c_xp_from-mz-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL [ CONJ from-conj,
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD noun &
						     [ MINORS.MIN 
						         abstr_meas_nom_rel ],
						   VAL.SPR *olist* ] ] ].

; <type val="c_xp_to-from_le">
; <description>Conj, only 'to' with `from'
; <ex>From 10 to 20 cats arrived.
; <nex>
; <todo>
; </type>
c_xp_to-from_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD from-conj,
                                     CPNG.PN 3p ],
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD intadj,
		   CONT.RELS <! [ PRED _to_c_from_rel ] !> ] ].

; <type val="c_xp_to-from-mz_le">
; <description>Conj, only 'to' with `from'
; <ex>From ten miles to twenty miles passed.
; <nex>
; <todo>
; </type>
c_xp_to-from-mz_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD from-conj,
                                     CPNG.PN 3p ],
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD noun &
					             [ MINORS.MIN 
						          abstr_meas_nom_rel ],
						   VAL.SPR *olist* ],
		   CONT.RELS <! [ PRED _to_c_from_rel ] !> ] ].

; <type val="c_xp_either-mrk_le">
; <description>Conj, 'either' paired with 'or'  
; <ex>B saw either C or D.
; <nex>
; <todo>
; </type>
c_xp_either-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ either ].
                   
; <type val="c_xp_neither-mrk_le">
; <description>Conj, 'neither' prd with 'nor'   
; <ex>B saw neither C nor D.
; <nex>
; <todo>
; </type>
c_xp_neither-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ neither ].

; <type val="c_xp_notonly-mrk_le">
; <description>Conj, 'not only':'but also'      
; <ex>Not only C but also D won.
; <nex>
; <todo>
; </type>
c_xp_notonly-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ notonly ].

; <type val="c_xp_notonly-inv_le">
; <description>Conj, inverted 'not only'
; <ex>Not only did C win but D also won.
; <nex>
; <todo>
; </type>
c_xp_notonly-inv_le := basic_conj_atomic_lexent &
  [ SYNSEM [ LOCAL [ CONJ notonly,
		     CAT [ VAL [ SPR < >,
				 COMPS < [ LOCAL.CAT [ HEAD verb & [ INV + ],
						       MC na,
						       VAL.SUBJ *olist* ] ] >],
			   MC bool ] ],
             LKEYS.KEYREL basic_conj_relation &
		          [ ARG0 conj-ind ] ] ].

; <type val="c_xp_not-mrk_le">
; <description>Conj, 'not' prd with 'but'       
; <ex>Not C but D won.
; <nex>
; <todo>
; </type>
c_xp_not-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ not-conj ].

; 'First Kim, then Sandy'
; <type val="c_xp_first-mrk_le">
; <description>Conj, 'first' prd w/ 'and then'  
; <ex>B saw first C and then D.
; <nex>
; <todo>
; </type>
c_xp_first-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ first ].

;; DPF 2012-09-19 - Note that we can't just treat this as apposition, since
;; (1) the two NPs are temporally disjoint, so apposition semantics isn't
;; quite right, and (2) we still want to disallow appos structure for two
;; named entities, to avoid massive ambiguity.
;;
; <type val="c_xp_formerly_le">
; <description>Conj, only 'formerly'               
; <ex>Kim Smith, formerly Mary Browne, arrived.
; <nex>
; <todo>
; </type>
c_xp_formerly_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CAT.VAL.COMPS < [ LOCAL.CAT.HEAD noun ] >,
		   CONT.RELS <! [ PRED _formerly_c_rel ] !> ] ].

; two hundred and fifty
; <type val="c_xp_and-num_le">
; <description>Conj, in complex number exprs    
; <ex>Two hundred and ten won.
; <nex>
; <todo>
; </type>
c_xp_and-num_le := conj_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN integer_rel,
                           VAL.COMPS.FIRST [ LOCAL [ CAT.HEAD intadj2- &
                                                     [ MINORS.ALTMIN #altmin ],
                                                     CONT.HOOK.LTOP #hand,
                                                     CONJ cnil,
                                                     AGR.DIV #div ],
                                             MODIFD.LPERIPH na ] ],
                     CONJ num-conj,
                     CONT [ HOOK.LTOP #hand,
                            RELS <! !>,
                            HCONS <! !> ],
                     AGR.DIV #div ],
             LKEYS [ KEYREL integer_relation,
                     ALTKEYREL.PRED #altmin ] ] ].

; 'five and a half'
; <type val="c_xp_and-fract_le">
; <description>Conj, in fractions               
; <ex>Two and a half teams won.
; <nex>
; <todo>
; </type>
c_xp_and-fract_le := conj_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN fraction_rel,
                           VAL.COMPS.FIRST [ LOCAL [ CAT.HEAD fractadj &
                                                     [ MINORS.ALTMIN #altmin ],
                                                     CONT.HOOK [ LTOP #hand,
                                                                 XARG #ind ],
                                                     CONJ cnil,
                                                     AGR.DIV #div ],
                                             MODIFD.LPERIPH na ] ],
                     CONJ num-conj,
                     CONT [ HOOK [ LTOP #hand,
                                   INDEX #ind ],
                            RELS <! !>,
                            HCONS <! !> ],
                     AGR.DIV #div ],
             LKEYS [ KEYREL.PRED fraction_rel,
                     ALTKEYREL.PRED #altmin ],
             NONLOC [ SLASH 0-dlist,
                      REL 0-dlist,
                      QUE 0-dlist ] ] ].

;; DPF 2012-12-21 - Added NONLOC non-local_none to prevent spurious nonempty 
;; SLASH.  Sigh.
;; DPF 2012-12-24 - Also added SPR < > to avoid conjoined S's feeding the
;; sp-hd rule.
;;
et_conj_lexent := basic_word &
  [ INFLECTD +,
    ORTH [ CLASS #class, FROM #from, TO #to, FORM #form ],
    TOKENS tokens &
           [ +LIST #tl & < [ +CLASS #class, +FROM #from, +FORM #form ], ... >,
             +LAST.+TO #to ],
    SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_rel,
                     VAL [ SPR < >,
			   COMPS < > ] ],
               CONJ phr-conj & [ CREL #keyrel ],
	       AGR.PNG png & [ PN 3p ],
               CONT [ HOOK [ LTOP #chand,
                             INDEX #cind ],
                      RELS <! relation & #keyrel &
                             [ LBL #chand,
                               ARG0 #cind ] !>,
                      HCONS <! !> ] ],
       NONLOC non-local_none,
       LKEYS.KEYREL #keyrel & 
	     [ CFROM #from,
	       CTO #to ],
       PUNCT [ LPUNCT comma_or_clause_or_no_punct,
               RPUNCT no_punct ],
       PHON.ONSET.--TL #tl ] ].

etc_conj_lexent := et_conj_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _etc_c_rel ] !> ].

; <type val="c_-_etc_le">
; <description>Conj, only 'etc.'                
; <ex>B saw C, D, etc.
; <nex>
; <todo>
; </type>
c_-_etc_le := etc_conj_lexent &
  [ SYNSEM.PUNCT.PNCTPR ppair ].

; For "did Kim arrive etc.?" where the PUNCT.PAIRED value must be unconstrained
; even though there's a qmark which would ordinarily stamp PAIRED no_ppair.
; <type val="c_-_etc-qmark_le">
; <description>Conj, only 'etc?'                
; <ex>Did B see C, D, etc?
; <nex>
; <todo>
; </type>
c_-_etc-qmark_le := etc_conj_lexent &
  [ SYNSEM.PUNCT.PNCTPR no_ppair ].

; <type val="c_-_so-on_le">
; <description>Conj, only 'and so on'           
; <ex>B hired C and so on.
; <nex>
; <todo>
; </type>
c_-_so-on_le := et_conj_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _so+on_c_rel ] !> ].

; <type val="c_-_vice-versa_le">
; <description>Conj, only 'and vice versa'      
; <ex>B hired C and vice versa.
; <nex>
; <todo>
; </type>
c_-_vice-versa_le := et_conj_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _vice+versa_c_rel ] !> ].

; Similarly for "Kim hired everyone except:" where the colon affix would
; stamp PAIRED no_ppair, but we want it in PNCTPR since this odd "except"
; is acting like a head-marker phrase.

; <type val="c_-_except_le">
; <description>Conj, only 'except'              
; <ex>B couldn't win except ...
; <nex>
; <todo>
; </type>
c_-_except_le := et_conj_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD n_or_p,
                     CONT.RELS <! [ PRED _except_c_rel ] !> ],
             PUNCT.PNCTPR ppair ] ].

; <type val="c_-_except-coln_le">
; <description>Conj, only 'except:'             
; <ex>B brought nothing except:
; <nex>
; <todo>
; </type>
c_-_except-coln_le := et_conj_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD n_or_p,
                           VAL.SPR *anti_list* ],
                     CONT.RELS <! [ PRED _except_c_rel ] !> ],
             PUNCT.PNCTPR no_ppair ] ].

; <type val="c_-_etal_le">
; <description>Conj, only 'et al'               
; <ex>B hired C et al.
; <nex>
; <todo>
; </type>
c_-_etal_le := et_conj_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD supnoun,
                         VAL.SPR < > ],
                   CONT.RELS <! [ PRED _et+al_c_rel ] !> ] ].

; <type val="c_-_name-few_le">
; <description>Conj, only 'to name a few'       
; <ex>B saw C,D, to name a few.
; <nex>
; <todo>
; </type>
c_-_name-few_le := et_conj_lexent &
  [ SYNSEM [ LOCAL.CONT.RELS <! [ PRED _to+name+a+few_c_rel ] !>,
             PUNCT.PNCTPR ppair ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NEG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; not

; "not" requires its VP complement to be [VFORM non_fin], which is a supersort
; for all non-finite vforms except imp_vform, which is a subsort of bse; the
; other subsort of bse, bse_only, is a subsort of non_fin.  Most verbs with
; base morphology are [VFORM bse], and hence (the VPS they project) can be
; modified by "not", and they can also head imperative clauses, which require
; the head to be [VFORM imp_vform].  Only if modified by "not" will a base
; VP be unable to project an imperative clause; in contrast, "never sleep" is 
; fine as an imperative, since "never" does not further restrict its VP 
; complement leaving it [VFORM bse], which is consistent with the imperative 
; rule.  This fine distinction is due to Rob M.
; DPF 2-Feb-01 - Changed MOD..HEAD from verbal to v_or_g, to allow e.g.
; "I tried not hiring kim"

adv_neg_lexent := basic_adverb_word &
  [ SYNSEM lex_synsem & 
	 [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL scopal_mod &
					    [ CAT [ VAL.COMPS < >,
                                                    MC na ],
                                              CONT [ HOOK [ LTOP #mhand,
                                                            INDEX non_expl &
                                                                  #vevent,
                                                            XARG #xarg ] ],
                                              CONJ cnil ] ] >,
                                MINORS.MIN neg_rel ],
                         VAL [ SUBJ < >,
			       COMPS < >,
			       SPR < > ],
                         MC na,
			 POSTHD - ],
		   CONT [ HOOK [ INDEX #vevent,
                                 XARG #xarg ],
			  RELS <! #keyrel &
                                  [ ARG0.E [ TENSE no_tense,
                                             ASPECT no_aspect ],
                                    ARG1 handle & #hand ] !>,
			  HCONS <! qeq &
				  [ HARG #hand,
				    LARG #mhand ] !> ] ],
           NONLOC.QUE 0-dlist,
           LKEYS.KEYREL #keyrel ] ].

; <type val="av_-_s-not_le">
; <description>Scop, VP, just 'not'             
; <ex>B did not win.
; <nex>
; <todo>
; </type>
av_-_s-not_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD negadv &
                       [ MOD < [ LOCAL.CAT [ HEAD verb_or_frag &
						  [ VFORM non_fin ],
                                             VAL.SUBJ < synsem_min > ],
				 --SIND.SF prop-or-ques ] > ],
		       NEGPOL + ] ].

; DPF 05-apr-05 - MOD..HEAD v_or_a_or_p allows modnp subtype, which is not
; a subtype of a_or_p for independent reasons.  No spurious ambiguity here, 
; since the SUBJ < > constraint rules out all PRD + verbal projections.

; <type val="av_-_s-not-prdp_le">
; <description>Scop, 'not', modify PrdP         
; <ex>Anyone not happy loses.
; <nex>
; <todo>
; </type>
av_-_s-not-prdp_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD adv_nonmob &
                          [ MOD < [ LOCAL.CAT [ HEAD v_or_a_or_p &
                                                     [ PRD + ],
                                                VAL.SUBJ < > ] ] > ] ].

; for "non-" as in "non-intrusive"
; <type val="av_-_s-not-ap_le">
; <description>Scop, 'not', modify AdjP         
; <ex>The non-intrusive cat won.
; <nex>
; <todo>
; </type>
av_-_s-not-ap_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD adv_nonmob &
                          [ MOD < [ LOCAL.CAT [ HEAD adj,
                                                VAL.SUBJ < > ] ] > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; COMPLEMENTIZERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Complementizers except for 'to' are marked [SUBJ < >] which prevents them
; from having PP modifiers.

; ERB (07-10-96) 'whether' clauses are made with the regular hd-cmp_u_c rule, so
; the polar_q_rel must come from 'whether' itself.  This means that whether
; can't identify its MIN with its --COMPKEY.  Also, I made complementizer_word
; inherit from msg_word (see comments near that type).  This has the effect of
; making non_affix_bearing be inherited by this type, instead of the lower
; types.

; ERB (14-12-97) to_c_prop needs to be MC + for infinitival relatives
; (see notes near to and non_wh_rel_cl) so this type can't say MC -.
; There is no convenient supertype to all of the MC - ones, so I'm
; just going to put it in on each for now.

; ERB (14-12-97) Complementizer_word can't be nonmod_local because 
; to_c_nonprop is going to have a non-empty mod value.  Again, For
; now I'm scattering this constraint among the lower types as appropriate.

; ERB (13-01-98) In fact, complementizer_word can't even be MC bool,
; because to_c_nonprop has to be MC na in order to head hcomps that
; serve as modifiers, as in "a teacher to talk to Sandy".

;;; DPF 01-Mar-00 - Reconsider, now that support_rel has been eliminated.
; DPF (27-Sept-98) Made MIN be v_event_rel, since "to" needs to pass up the
; KEY.LBL of its complement, in order to get the desired semantics for e.g.
; "Kim is going to lose" where the copula's support_rel identified its LBL
; with that of its complement's KEY.
; 
; DPF (13-Jan-99) Generalized to make MIN be v_event_rel for all 
; complementizers, needed in particular to avoid treating complementizers as 
; particles, which are selected by MIN value.
; DPF 25-oct-03 - Change SPR from *olist* to < > to block PP modification.

complementizer_word := noncr-h-nab &
  [ SYNSEM.LOCAL [ CAT [ HEAD.INV -,
                         VAL.SPR < > ],
		   AGR.PNG.PN 3s,
		   CONT.HOOK.INDEX non_expl ] ].

; These are the subject-to-object raising complementizers.  We're giving a
; funny three-constituent analysis to CPs: "that [Kim] [walks]" and "for [Kim]
; [to walk]".  One (beneficial) side effect of this is that finite and
; non-finite CPs get a uniform analysis, and we also can do real subject
; extraction without running afoul of the dreaded that-trace filter
; (Perlmutter 1971).  

; We also need another "that", one that combines with an adverbial and an
; S/Adv.  This accounts for why you get preposed modifiers with that clauses
; and not with for/to clauses, and why you don't get the that-t effect when
; you have an adverb in there.  But, that second "that" is going to have to
; bind off a SLASH value, sort of like the tough-movement cases, and that will
; have to wait for lexicalized SLASH passing.

; ERB (14-12-97) See notes at complementizer_word.

; DPF 2-Apr-01 - Added PP modifier argument to COMPS, to allow for sentence-
; initial modification, as in "I knew that on Tuesday I would be early", and in
; particular for "how come when I arrive he leaves" (given that we treat this
; "how come" as a main-clause-compatible complementizer).
; DPF 26-apr-08 - Generalized COMPS.FIRST..HEAD prep_or_modnp to p_or_adv
; to allow e.g. "Kim thinks that often we arise"
; DPF 27-may-09 - Changed PUNCT no_punct to dq_or_no_punct to admit
; |admit that kim "will arrive"|

#|
basic_two_place_compl_word := complementizer_word & 
  [ SYNSEM 
    [ LOCAL 
      [ ARG-S #comps,
        CAT [ HEAD [ VFORM #vform,
                     TAM #tam & [ TENSE #tense,
                                  ASPECT #aspect,
                                  MOOD #mood ],
		     MOD < anti_synsem_min > ],
              VAL [ COMPS #comps,
		    KCMP canonical_synsem &
			 [ --MIN #cmin,
                           LOCAL [ CAT [ HEAD verbal &
                                              [ VFORM #vform,
                                                TAM #tam ],
                                         VAL [ COMPS < > ],
					 MC - ],
                                   CONT.HOOK #hook ],
                           OPT -,
                           PUNCT.LPUNCT dq_or_no_punct ] ] ],
	CONT [ HOOK #hook &
		    [ INDEX.E [ TENSE #tense,
				ASPECT #aspect,
				MOOD #mood ] ] ] ],
      LKEYS.--COMPKEY #cmin ] ].
|#

basic_two_place_compl_word := complementizer_word & 
  [ SYNSEM 
    [ LOCAL 
      [ ARG-S #comps,
        CAT [ HEAD [ VFORM #vform,
		     MOD < anti_synsem_min > ],
              VAL [ COMPS #comps,
		    KCMP canonical_synsem &
			 [ --MIN #cmin,
                           LOCAL [ CAT [ HEAD verbal &
                                              [ VFORM #vform ],
                                         VAL [ COMPS < > ],
					 MC na_or_- ],
                                   CONT.HOOK #hook ],
                           OPT -,
                           PUNCT.LPUNCT dq_or_no_punct ] ] ],
	CONT.HOOK #hook ],
      LKEYS.--COMPKEY #cmin ] ].

; Instead of doing raising here by identifying whole synsems, only identify
; semantic indices, as with regular raising for verbs above.  This lets us get
; "I prefer that he be here early" treating the second (VP) complement of 
; "that" as a simple base-form VP, rather than some new morphological form.

basic_sor_compl_word := basic_two_place_compl_word &
  [ SYNSEM basic_one_arg & 
    [ LOCAL.CAT.VAL [ COMPS < #kcmp &
			      [ LOCAL.CAT.VAL.SUBJ < anti_synsem_min > ] >,
		      KCMP #kcmp ] ] ].

norm_compl_word := basic_sor_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD comp,
		       VAL [ SUBJ < anti_synsem_min >,
			     COMPS < [ LOCAL.CAT [ HEAD verb &
						      [ TAM.TENSE real_tense ],
						   MC - ] ] > ] ] ].

sor_compl_word := norm_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.MOOD #mood,
		       VAL.COMPS < [ LOCAL [ CAT.HEAD [ --ADDIN [ ADDPN #pn,
								  ADDTAM #tam ],
							TAM #tam &
							    [ MOOD #mood ] ],
					     AGR.PNG.PN #pn ] ] > ] ].

; <type val="cm_np-vp_that_le">
; <description>Cmplzr, only 'that' (int mod)    
; <ex>B knew that we won.
; <nex>
; <todo>
; </type>
cm_np-vp_that_le := sor_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  TAM.MOOD indicative,
				  CASE nom,
				  AUX -,
				  MINORS.MIN verb_aspect_rel ],
			   VAL.COMPS.FIRST.LOCAL.CAT.HEAD.TAM indic_tam,
			   MC - ],
		     CONT [ HOOK.INDEX.SF prop,
			    RELS <! !>,
			    HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

;; "I prefer that he be here early"
; <type val="cm_np-vp_th-sv_le">
; <description>Cmplzr, subjnct 'that' (int mod) 
; <ex>B insists that C be here.
; <nex>
; <todo>
; </type>
cm_np-vp_th-sv_le := norm_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM bse,
				  AUX -,
				  MINORS.MIN verb_aspect_rel ],
			   VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM bse ] >,
			   MC - ],
		     CONT [ HOOK.INDEX.E.MOOD subjunctive,
			    RELS <! !>,
			    HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

;; DPF 2012-07-22 - Changed MIN to from verb_aspect_rel to v_event_rel to
;; prevent `for' from letting `be_do' verbs into the chart via the --COMPKEY
;; mechanism.
;;
; <type val="cm_np-vp_for_le">
; <description>Cmplzr, only 'for'               
; <ex>B hopes for C to win.
; <nex>
; <todo>
; </type>
cm_np-vp_for_le := basic_two_place_compl_word &
  [ SYNSEM basic_two_arg & 
	   [ LOCAL [ CAT [ HEAD comp &
				[ VFORM inf,
				  AUX -,
				  MINORS.MIN v_event_rel,
				  TAM #tam ],
			   VAL [ SUBJ < anti_synsem_min >,
				 COMPS 
				  < canonical_synsem &
				    [ LOCAL [ CAT nomp_cat_acc_min,
					      CONT.HOOK.LTOP #vltop,
					      AGR #agr,
					      CONJ cnil ],
				      --SIND #ind & index,
				      OPT -,
				      NONLOC #nloc & [ SLASH 0-dlist,
						       REL 0-dlist ],
				      PUNCT [ RPUNCT 
					       comma_or_rbc_or_pair_or_no_punct,
					      PNCTPR ppair ] ],
				    canonical_synsem & #kcmp &
 				    [ LOCAL 
			              [ CAT [ HEAD comp & [ VFORM inf,
							    TAM #tam ],
					      VAL.SUBJ < synsem &
							 [ LOCAL [ CAT 
								   nomp_cat_min,
								   AGR #agr ],
							   NONLOC #nloc ] > ],
					CONT.HOOK [ LTOP #vltop,
						    XARG #ind ] ] ] >,
				 KCMP #kcmp ],
			   MC - ],
		     CONT [ HOOK.INDEX.SF prop,
			    RELS <! !>,
			    HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

; <type val="cm_np-vp_like_le">
; <description>Cmplzr, 'like'
; <ex>He looks like he'll win.
; <nex>
; <todo>
; </type>
cm_np-vp_like_le := sor_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  AUX -,
				  MINORS.MIN verb_aspect_rel ],
                         VAL.COMPS < [ LOCAL 
                                       [ CAT [ HEAD.TAM indic_tam,
					       MC - ],
                                         CONT.HOOK.INDEX.SF like-iforce ] ] >,
                         MC - ],
                   CONT [ RELS <! !>,
                          HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

; ERB (14-12-97) Why is the SUBJ here specified as acc?? I'm taking it
; out because that follows now from pro_ss.

; ERB (08-01-98) Presumably that had to do with "for him/*he to sleep..."
; but that's the other to: to_c_nonprop.

; ERB (14-12-97) In order to implement infinitival relatives (I found
; a teacher to talk to Sandy, I found a teacher to talk to), I am
; making to_c_prop MC +.  The reasons for this is that the relevant
; cx (non_wh_rel_cl) needs to be able to take subjh_decl and hcomps
; headed by to_c_prop as its head-dtr, but not an extrasubj phrase.

; ERB (13-01-98) to_compl_word says SUBJ < unexpressed >, but I don't
; how that can be, unless the analysis of raising has changed drastically.
; (With it that way, raising is broken).  So I am getting rid of it.

; ERB (19-01-98) SUBJ < unexpressed > was in there because something
; had to take care of giving that subject a SLASH value.  The solution
; we've opted for is this: the subject of to_c_prop is always PRO, and
; the subject of to_c_nonprop is always raised (that is, all
; infinitival tos except those in raising constructions are to_c_prop).
; So there is no constraint on to_compl_word, but to_c_prop says
; SUBJ < pro_ss > and to_c_nonprop says SUBJ canonical_synsem.

; ERB (19-01-98) This to has to have a mod value so that it can
; head the infinitival relatives.  Something needs to be said about
; the features mentioned in nomod_local, probably, but I'm not sure
; what yet.  It also needs to be MC na so it can feed extrasubj.

; ERB (03-02-98) MIN should be no_rel.  It used to be identified with
; --COMPKEY, but that causes at least one problem: to was able to be the
; SPR of the, since the constrains its choice of SPR by a semantic
; constraint on the KEY.
; DPF (13-Jan-99) This problem should be solved by the above decision to
; make all complementizers have the MIN be of type v_event_rel.
; DPF 17-Sep-01 - Removed INDEX.E.TENSE no_tense, since it prevents e.g. 
; "I am going to arrive".
; DPF 14-Nov-01 - Returned to identifying MIN with --COMPKEY, in order to get
; intended constraint on --COMPKEY.E.ASPECT for e.g. "I have yet to arrive"
; DPF 4-apr-04 - Removed identification of AGR and COMPS.FIRST..AGR, since
; we need to have complementizers stipulate AGR.PNG.PN 3s to get the agreement
; right for sentential subjects (?), but we also say that 'and' is inherently
; AGR.PNG.PN 3p (to get NP coordination right (?)), and the result of both
; of these (dubious?) assertions is that we were not parsing "to arrive and
; arise" with the to-prop guy.  Probably room for improvement, but for now
; let's see what happens removing this AGR identity.
; DPF 17-sept-07 - Restrict VP complement to SUBJ..HEAD noun to avoid spurious
; analyses with locative inversion verbs as in "to run".
; DPF 3-apr-10 - Removed [POSTHD -] - don't know why it was here, but it
; blocks coord as in "Kim tried to eat and to sleep".
; DPF 04-jun-10 - Changed SUBJ..HEAD from no_head to basic_noun, since now want
; to unify SUBJ..HEAD values in control constructions, given locative invers,
; and also now need to build inf-S in "for Kim to arrive".

to_compl_word := complementizer_word &
  [ SYNSEM basic_one_arg &
     [ LOCAL [ CAT [ HEAD comp &
			  [ AUX +,
                            MINORS #mins & [ MIN verb_aspect_rel ],
			    MOD < anti_synsem &
                                      [ LOCAL intersective_mod &
                                              [ CAT nbar_cat_min ] ] > ],
                     VAL [ SUBJ < synsem & #subj &
				           [ OPT -,
					     LOCAL.CAT.HEAD basic_noun ] >,
                           COMPS #comps & 
                              < canonical_synsem &
				[ LOCAL 
                                  [ CAT vp_cat &
                                        [ HEAD.MINORS #mins,
                                          VAL.SUBJ 
                                           < #subj &
					     [ LOCAL.CAT.HEAD noun,
                                               NONLOC
                                                     [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ],
				    CONT.HOOK 
                                         [ LTOP #chand,
                                           INDEX #ind & [ E.TENSE no_tense,
							  SF prop-or-ques ],
					   XARG #xarg,
					   --SLTOP #sltop ] ],
				  --MIN #cmin,
				  --SIND #ind,
				  OPT - ] > ],
		     MC na_or_- ],
	       CONT [ HOOK [ LTOP #chand,
			     INDEX #ind,
                             XARG #xarg,
			     --SLTOP #sltop ],
		      RELS <! !>,
		      HCONS <! !> ],
	       ARG-S #comps ],
       MODIFD notmod,
       LKEYS [ KEYREL.PRED no_rel,
	       --COMPKEY #cmin ] ] ].

cm_vp_to_lexent := to_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].

; <type val="cm_vp_to_le">
; <description>Cmplzr, 'to'                     
; <ex>B tried to win.
; <nex>
; <todo>
; </type>
cm_vp_to_le := cm_vp_to_lexent.

; <type val="cm_vp_to-mal_le">
; <description>Cmplzr, 'to', robust
; <ex>B tried to to win.
; <nex>
; <todo>
; </type>
cm_vp_to-mal_le := cm_vp_to_lexent &
  [ GENRE robust ].

; try and win
; <type val="cm_vp_and_le">
; <description>Cmplzr, 'and'                    
; <ex>B will try and win.
; <nex>
; <todo>
; </type>
cm_vp_and_le := to_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_and,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].
; help but notice
; <type val="cm_vp_but_le">
; <description>Cmplzr, 'but'                    
; <ex>B can't help but win.
; <nex>
; <todo>
; </type>
cm_vp_but_le := to_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_but,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].

; prevent him from leaving (cf "*prevent him from danger")
; <type val="cm_vp_from_le">
; <description>Cmplzr, 'from'                   
; <ex>B prevents C from winning.
; <nex>
; <todo>
; </type>
cm_vp_from_le := to_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_from,
                       VAL.COMPS < [ LOCAL.CAT vp_prp_cat ] > ] ].

; ERB (14-12-97) This one will have a non-empty MOD value in order to
; build things like "Kim found a friend to talk to Sandy" where the
; subject of talk has to be bound to friend (unlike in "Kim found a
; friend to talk to" where we're convinced it is discourse bound.)
;
; The semantics are probably not right -- as a place holder in the
; modcont I put a appropriate_rel.  The idea is that "I found a person
; to talk to Sandy" means something like "I found a person who is willing/
; appropriate/suitable to talk to Sandy."  But I don't see how to make
; (something like) the appropriate_rel take the comlement of the to
; as an argument.  There is also the question of whether there should be
; any message associated with this.  One would think not, given that we've
; decided the relevant to is the nonprop one...
;   For now, we're not including this rel.

; ERB (13-01-98) to_compl_nonprop_word must be MC na if it is
; to head hcomps that serve as modifiers as in "a teacher to talk to Sandy".
;
; ERB (19-01-98) All infinitival relatives are now headed by
; to_c_prop.  To_c_nonprop only appears in raising constructions.
; Accordingly, it has no MOD value, and its subject is constrained
; to be canonical_synsem.  I'm not sure the latter constraint is
; actually doing any work for us, but I believe it to be true.
; It can also now inherit from nomod_local.  The MC value might
; could be changed, as well.

; ERB (2003-08-11) Try changing SUBJ < canonical_synsem > to
; SUBJ < unexpressed >.  There are several places in the grammar
; where the SLASH value of the SUBJ here is being constrained.
; Since it is, in fact, always unxpressed, it would seem safe.
; Testing to see whether coverage is lost or gained because something
; was relying on this constraint.

;;; DPF (21-Oct-98) Added types for elided "to", since we can't use the lexical
;; rule of auxiliary verbs, since we need to block the NP "the book to", which
;; would be built by that lexical rule, then by the application of subject
;; extraction, and then the infinitival relative rule.
;; DPF 2012-02-06 - Changed MC from na to na_or_- so we get 
;; |She was too tired to.|

; <type val="cm_-_to_le">
; <description>Cmplzr, 'to' elided              
; <ex>B tried to.
; <nex>
; <todo>
; </type>
cm_-_to_le := noncqr-h-nab &
  [ SYNSEM basic_one_arg &
	   [ LOCAL nomod_local &
		   [ CAT [ HEAD comp &
				[ VFORM inf,
				  INV -,
				  AUX +,
				  PRD -,
                                  MINORS [ MIN ellipsis_rel,
                                           ALTMIN ellipsis_rel ] ],
                           VAL [ SUBJ < synsem >,
				 SPR *olist*,
				 COMPS < > ],
			   MC na_or_- ],
		     CONT [ HOOK [ LTOP #chand,
				   INDEX #event,
                                   XARG #index ],
			    RELS <! #keyrel & arg1_relation &
				    [ LBL #chand,
				      PRED ellipsis_ref_rel,
				      ARG0 #event & [ SF prop ],
				      ARG1 #index ] !>,
			    HCONS <! !> ],
                     ARG-S < [ ] > ],
	     NONLOC.SLASH 0-dlist,
             LKEYS.KEYREL #keyrel ] ].


; ERB (08-10-96) Whether was previously a que_word so that things selecting
; for questions could select by QUE values.  This is clearly a hack, and
; further, one that is no longer necessary now that we have semantic selection.
; I have split the old type whether_compl_word into two types: finite and
; nonfinite.  I have also gotten rid of the feature CMP.  
; As for the semantics, whether contributes a polar_q_rel (see notes near
; polar_q_rel in fundamentals.tdl).  Now, according to Rob, things that
; take complements with message-type semantics usually take the handle of
; those complements as the argument in their KEYs.  However, also according
; to Rob, if we did that here, it would imply that "whether Kim left every
; party" has more readings than "Kim left every party", which doesn't seem
; to be true.  Accordingly, whether will identify its handle with the
; handle of its complement, and take the complement's INDEX as the value
; of the ARG1 in the polar_q_rel.  Now, if whether further identified its
; INDEX with that one, things would be getting pretty twisty, so whether
; will have its own INDEX of type event.

; ERB (24-10-96) MSG now functions like KEYREL as a pointer to
; a certain rel on the RELS.  Both wh and yn questions will have an
; int_m_rel on their RELS.  This is actually sewn into the RELS
; by the constructions.  Whether just carries it in its MSG value
; so that it unifies with the right constructions.  In this way, we
; even kind of get Rob's intuition -- whether doesn't, in a sense,
; have a message, because that message isn't on its RELS.
; Anyway, all of this makes the polar_q_rel irrelevant, so I am removing
; it.  The hcomp_yn_nr construction will make sure the MARG value
; of the int_m_rel takes the LBL of whether's complement.   I don't
; know what to do about whether's LBL and ARG0 now, so I am 
; leaving them unspecified.

; ERB (14-12-97) See notes at complementizer_word.

whether_compl_word := complementizer_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < anti_synsem_min >,
		     CONT.HOOK.INDEX.SF ques ],
             NONLOC.SLASH 0-dlist ] ].

comp_whether_if_fin_lexent := whether_compl_word & basic_sor_compl_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD comp &
                                [ VFORM fin,
                                  MINORS.MIN verb_aspect_rel,
				  TAM #tam ],
                           VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                      [ TAM #tam,
						       --ADDIN [ ADDTAM #tam,
								 ADDPN #pn ] ],
						       MC - ],
						 AGR.PNG.PN #pn ] ] >,
                           MC - ],
                     CONT [ RELS <! !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL.PRED verb_aspect_rel ] ].

; <type val="cm_np-vp_wh_le">
; <description>Cmplzr, 'whether'
; <ex>B wondered whether C won.
; <nex>
; <todo>
; </type>
cm_np-vp_wh_le := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD comp & [ TAM.MOOD indicative ],
                       VAL [ SUBJ < >,
			     COMPS < [ LOCAL.CAT.HEAD.TAM indic_tam ] > ] ] ].

; DPF 10-sept-07 - Add NORM no_rel to prevent these from undergoing the np_cp
; rule, to avoid spurious analysis for e.g. "if Kim arrives, Abrams is."
; And similarly for the subjunctive variant.

; <type val="cm_np-vp_if-ic_le">
; <description>Cmplzr, 'if'
; <ex>B wondered if C won.
; <nex>
; <todo>
; </type>
cm_np-vp_if-ic_le := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD [ CASE acc,
                              MINORS.NORM no_rel ],
                       VAL [ SUBJ < >,
			     COMPS < [ LOCAL 
                                      [ CAT.HEAD.TAM indic_tam,
                                        CONT.HOOK.INDEX.SF prop-or-ques ]]>]]].

; <type val="cm_np-vp_if-sv_le">
; <description>Cmplzr, 'if' subjctv
; <ex>B'd know if C were here.
; <nex>
; <todo>
; </type>
cm_np-vp_if-sv_le := sor_compl_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD comp &
                                [ CASE acc,
                                  VFORM fin,
                                  MINORS [ MIN verb_aspect_rel,
                                           NORM no_rel ] ],
                           VAL [ SUBJ < anti_synsem_min >,
				 COMPS < [ LOCAL.CAT.HEAD.TAM.MOOD 
                                                       basic_subjunctive ] > ],
			   MC - ],
                     CONT [ RELS <! !>,
                            HCONS <! !> ] ],
             NONLOC.SLASH 0-dlist,
	     LKEYS.KEYREL.PRED no_rel ] ].             

; DPF 13-Mar-02 - Blocked first (optional PP) complement from being picked up
; to avoid misparse for e.g. "I need an explanation of how to return the 
; order to you"
; DPF 12-Apr-03 - But the entry for "how" leads to spurious ambiguity for e.g.
; "I know how kim arrived", and doesn't help with other WH-S's as objects of
; prepositions: "I need an explanation of who we hired".  Seems better to 
; return to our analysis treating WH-S's as NPs, and look again at the
; resulting spurious ambiguities there.  So we'll use this type only for
; "how come".

; 'how come they left'
; <type val="cm_np-vp_how_le">
; <description>Cmplzr, 'how come'               
; <ex>B wondered how come C won.
; <nex>
; <todo>
; </type>
cm_np-vp_how_le := sor_compl_word & whether_compl_word & 
  [ SYNSEM [ LOCAL 
             [ CAT [ HEAD comp &
                          [ VFORM fin,
                            TAM.MOOD indicative,
			    MINORS.MIN verb_aspect_rel ],
                     VAL.COMPS < [ LOCAL [ CAT [ HEAD.TAM.MOOD 
							   ind_or_modal_subj ],
					   CONT.HOOK [ LTOP #cltop,
                                                       INDEX #cind &
                                                       [ SF prop-or-ques ]]]]>,
                     MC + ],
               CONT [ HOOK.INDEX #cind & [ SF prop-or-ques ],
                      RELS <! #keyrel & 
                            [ LBL #cltop,
                              ARG0.E [ TENSE no_tense,
                                       ASPECT no_aspect ],
                              ARG1 #cind,
                              ARG2 #objind,
			      CFROM #from,
			      CTO #to ],
                            [ PRED which_q_rel,
                              ARG0 #objind,
                              RSTR #rhand,
			      CFROM #from,
			      CTO #to ],
                            #altkeyrel &
                            [ LBL #nhand,
                              ARG0 #objind ] !>,
                      HCONS <! qeq &
                             [ HARG #rhand,
                               LARG #nhand ] !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ] ] ].


; ERB (08-10-96) In the older version, I had whether_compl_word_inf 
; selecting for something that was just vp_inf_cat.  I never
; tested for this, but this probably allowed Sandy knew whether whether
; to leave, etc.  One way to get around this is for whether to
; select for something that is MSG no_msg.  In order to do 
; this, I need to build to CPs that are no_rel, but we want this
; anyway (even though I talked Dan out of it at one point).
; DPF 09-Jan-00 - Made "whether" be MC -, not MC na, since e.g. "know"
; wants [MC -] CP complements.

; <type val="cm_vp_wh_le">
; <description>Cmplzr, 'whether' with VP        
; <ex>B wondered whether to run.
; <nex>
; <todo>
; </type>
cm_vp_wh_le := whether_compl_word &
  [ SYNSEM basic_one_arg &
	   [ LOCAL [ CAT [ HEAD comp &
                                [ VFORM inf,
                                  MINORS.MIN verb_aspect_rel ],
			   VAL [ SUBJ < >,
				 COMPS #comps &
                                      < [ LOCAL [ CAT [ HEAD comp &
							  [ VFORM inf ],
							VAL [ SUBJ *cons*,
							      COMPS < >,
							      SPR *olist* ],
							MC na ],
                                                  CONT [ HOOK.LTOP #chand ] ],
                                          --SIND #ind,
                                          OPT - ] > ],
			   MC - ],
		     CONT [ HOOK [ LTOP #chand,
                                   INDEX #ind ],
			    RELS <! !>,
			    HCONS <! !> ],
                     ARG-S #comps ],
	     LKEYS.KEYREL.PRED no_rel ] ].

;; DPF 2012-03-13 - Make these AUX + to avoid modification by PPs, as in
;; |Kim knows when to work|
s_compl_phrase_lexent := noncqr-h-nab &
  [ SYNSEM [ LOCAL nomod_local &
		 [ CAT [ HEAD verb & 
			      [ INV -,
				AUX +,
				VFORM fin ],
			 VAL [ COMPS < > ],
			 POSTHD bool ],
		   CONT [ HOOK [ INDEX #event ],
			  RELS.LIST < arg1_relation &
                                      [ PRED ellipsis_rel,
                                        ARG0 #event,
					CFROM #cfrom, CTO #cto ], ... > ],
                   ARG-S < > ],
	     NONLOC.SLASH 0-dlist,
             LEX + ],
    ORTH [ FROM #cfrom, TO #cto ] ].

; 'so'
; <type val="x_-_so-cp_le">
; <description>Pro-form CP, only 'so'           
; <ex>B thought so.
; <nex>
; <todo>
; </type>
x_-_so-cp_le := s_compl_phrase_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN v_event_rel,
			   VAL [ SUBJ *olist* & < anti_synsem_min >,
				 SPR *anti_list* ] ],
                     CONT [ HOOK [ LTOP #khand,                              
				   INDEX.SF prop ],
                            RELS <! relation & #keyrel & [ LBL #khand ] !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ PRED v_event_rel ] ] ].

; 'not'
; <type val="x_-_not-cp_le">
; <description>Pro-form CP, only 'not'           
; <ex>B hoped not.
; <nex>
; <todo>
; </type>
x_-_not-cp_le := s_compl_phrase_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN v_event_rel,
			   VAL [ SUBJ *olist* & < anti_synsem_min >,
				 SPR *anti_list* ] ],
                     CONT [ HOOK [ LTOP #nlbl,
				   INDEX.SF prop ],
                            RELS <! relation & #keyrel &
				    [ LBL #chand,
				      PRED v_event_rel,
				      CFROM #cfrom, CTO #cto ],
				    [ LBL #nlbl,
				      PRED neg_rel,
				      ARG1 #arg,
				      CFROM #cfrom, CTO #cto ] !>,
                            HCONS <! qeq &
				    [ HARG #arg,
				      LARG #chand ] !> ] ],
             LKEYS.KEYREL #keyrel ] ].

; <type val="x_-_wh-cp_le">
; <description>Pro-form CP, wh-adv forms            
; <ex>B wondered why/how/when.
; <nex>
; <todo>
; </type>
x_-_wh-cp_le := s_compl_phrase_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN prep_mod_rel,
					 NORM norm_rel ],
			   VAL [ SUBJ < >,
				 SPR < synsem &
				     [ LOCAL [ CAT [ HEAD.MINORS.MIN #min & 
							just_only_deg_rel,
						     VAL.SPR  *olist* ],
					       CONT.HOOK.LTOP #hand ],
				       NONLOC [ QUE 0-dlist,
						REL 0-dlist ],
				       --MIN #min ] > ] ],
		     CONT [ HOOK [ LTOP #hand,
				   INDEX.SF ques ],
                            RELS <! relation & 
                                 [ LBL #hand,
                                   ARG0 #event,
				   CFROM #from,
				   CTO #to  ],
                                 #keyrel &
                                 [ LBL #hand,
                                   PRED prep_mod_rel,
                                   ARG0.E [ TENSE no_tense,
                                            ASPECT no_aspect ],
                                   ARG1 #event,
                                   ARG2 #objind,
				   CFROM #from,
				   CTO #to  ],
                                 [ PRED which_q_rel,
                                   ARG0 #objind,
                                   RSTR #rhand,
				   CFROM #from,
				   CTO #to  ],
                                 #altkeyrel & [ LBL #nhand,
						ARG0 #objind ] !>,
                          HCONS <! qeq &
                                   [ HARG #rhand,
                                     LARG #nhand ] !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ] ] ].

; 'what, who'
; <type val="x_-_who-cp_le">
; <description>Pro-form CP, wh-pro forms
; <ex>B wondered who.
; <nex>
; <todo>
; </type>
x_-_who-cp_le := s_compl_phrase_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN verb_aspect_rel,
			   VAL [ SUBJ < >,
				 SPR < unexpressed & 
				       [ --MIN deg_rel ] > ] ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX.SF ques ],
                            RELS <! relation & 
                                 [ LBL #ltop,
				   CFROM #from, CTO #to  ],
                                 [ PRED which_q_rel,
                                   ARG0 #objind,
                                   RSTR #rhand,
				   CFROM #from,
				   CTO #to  ],
                                 #altkeyrel & [ LBL #nhand,
						ARG0 #objind ] !>,
                          HCONS <! qeq &
                                   [ HARG #rhand,
                                     LARG #nhand ] !> ] ],
             LKEYS [ ALTKEYREL #altkeyrel ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Imperative words "don't" and "let's"

; ERB (05-10-97) In order to conflate hcomp_root and hcomp_nc into just one
; hd-cmp_u_c, root_marker_words have to identify their value for mc with that of
; their complement.  (Hcomp_root identified MC for mother and non-head
; daughter.)

root_marker_word := noncqr-h-nab &
  [ SYNSEM synsem &
	 [ LOCAL [ CAT [ HEAD verb & [ AUX -,
                                       INV - ],
			 VAL.COMPS < synsem &
                                     [ LOCAL [ CAT.VAL.COMPS < >,
                                               CTXT #ctxt ],
                                       NONLOC [ SLASH #slash,
                                                QUE 0-dlist,
                                                REL 0-dlist ] ] > ],
                   CTXT #ctxt ],
	   NONLOC.SLASH #slash ] ].

; DPF 14-jul-06 - moved SUBJ < anti_synsem_min > down to 'lets' subtype, so 
;'dont' subtype can say SUBJ < >, which (nearly) enables it to be modified 
; by VP adverbs, as in "Still don't move!".  But we await the departure of
; messages, since adj_head_intersective rule requires head to be MSG no_msg.
; Leave for now.
; DPF 31-jul-06 - But this blocks e.g. 'Kim arrived but don't move!"  So
; will have to find some other solution for VP modifiers
; DPF 30-sept-06 - Changed MIN no_rel to nonaux_v_rel in order to admit
; "arise; don't move!"

lex_imperative := root_marker_word &
  [ SYNSEM [ LOCAL 
             [ CAT [ HEAD [ MOD < anti_synsem_min >,
                            TAM.MOOD #mood,
                            PRD -,
                            VFORM imp_vform,
                            MINORS.MIN nonaux_v_rel ],
                     VAL 
		    [ SPR < >,
                      SUBJ < anti_synsem & [ LOCAL.CAT.HEAD.CASE acc,
                                             --SIND #inst & ref-ind ] >,
		      COMPS < [ LOCAL 
                                 [ CAT [ HEAD verb & 
                                              [ VFORM bse_only,
                                                TAM.MOOD #mood ],
                                         VAL.SUBJ 
                                             < synsem &
                                               [ NONLOC [ SLASH 0-dlist,
                                                          QUE 0-dlist,
                                                          REL 0-dlist ] ] >,
                                         MC na ],
                                   CONT.HOOK [ INDEX #ind,
                                               XARG #inst ] ],
                                PUNCT.LPUNCT no_punct ] > ],
                     MC bool ],
               AGR #inst,
               CONT [ HOOK [ LTOP #khand,
                             INDEX #ind & [ E.TENSE present,
                                            SF comm ] ],
                      RELS.LIST < [ PRED pronoun_q_rel,
                                    RSTR #rhand,
                                    ARG0 #inst,
				    CFROM #from, CTO #to ],
				  #altkeyrel &
                                  [ LBL #prohand,
                                    PRED pron_rel,
                                    ARG0 #inst &
                                        [ PT zero,
                                          SORT entity ] ], ... >,
                      HCONS.LIST < qeq &
                                   [ HARG #rhand,
                                     LARG #prohand ], ... > ] ],
             LKEYS [ KEYREL [ LBL #khand,
			      PRED no_rel,
			      CFROM #from, CTO #to ],
		     ALTKEYREL #altkeyrel ] ] ].
		    
; <type val="v_vp_lets-imp_le">
; <description>Cmps VP(bse), hd_imp_c              
; <ex>Let's sing.
; <nex>
; <todo>
; </type>
v_vp_lets-imp_le := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
		   AGR.PNG png & [ PN 1p ],
		   CONT [ HOOK.LTOP #chand,
                          HCONS <! qeq !>,
			  RELS <! relation, relation !> ] ] ].

; <type val="v_vp_dont-imp_le">
; <description>Cmps VP(bse), hd_imp_c, neg         
; <ex>Don't sing.
; <nex>
; <todo>
; </type>
v_vp_dont-imp_le := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CONT [ HOOK.LTOP #chand ],
                                             CAT.HEAD.MINORS.ALTMIN 
                                                            non_conj_rel ],
				     OPT - ] >,
                   AGR.PNG png & [ PN 2 ],
		   CONT [ HOOK.LTOP #neghand,
                          RELS <! relation,
				  relation &
				 [ CFROM #cfrom, CTO #cto ],
                                 [ LBL #neghand,
                                   PRED neg_rel,
				   ARG1 #arg,
				   CFROM #cfrom, CTO #cto ] !>,
			  HCONS <! qeq,
                                   qeq &
				    [ HARG #arg,
				      LARG #chand ] !> ] ] ].

; 09-09-97  Added ARG0 and BODY attributes temporarily for VM2, since the
; whq external relation for how_about is like a quantifier, needing four args.
; Had to change the relation introduced by "how about" to '_which_q_rel'
; rather than '_how_about_rel' because of some property of vitADT.  Similar
; change made to the 'frag-msg' instance in syntax.tdl.
; 06-Oct-98 DPF - Changed MC value from na to +, to allow "okay, how about kim"
; DPF 25-sept-04 - Changed SUBJ, SPR, and MOD from < > to < anti_synsem_min > 
; so these can conjoin with ordinary clauses.
; DPF 18-aug-08 - But SPR for clauses is now empty, so change here.
; DPF 25-jun-09 - Added LEX - to prevent these from appearing as e.g. head
; in n-nh_vorj-cpd_c, and added PRD - to prevent them in pred coord like
; "why Kim and happy"

basic_how_about_word := word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < anti_synsem_min >,
                                  MINORS.MIN how+about_r_rel,
                                  VFORM fin,
                                  AUX -,
                                  INV -,
				  PRD -,
                                  TAM.TENSE real_tense ],
                           VAL [ SUBJ < anti_synsem_min >,
                                 SPR < > ],
                           MC +,
                           HC-LEX - ],
                     CONT [ HOOK.LTOP #rhand,
                            RELS.LIST < event_relation &
                                        [ PRED generic_verb_rel,
                                          LBL #arghand,
					  CFROM #from,
					  CTO #to  ],
                                        relation & #keyrel &
                                        [ LBL #rhand,
                                          ARG0.SF prop-or-ques,
                                          ARG1 #arg,
					  CFROM #from,
					  CTO #to  ], ... >,
                            HCONS <! qeq &
                                     [ HARG #arg,
                                       LARG #arghand ] !> ],
                     CONJ cnil ],
             NONLOC non-local_none,
	     LEX -,
             LKEYS.KEYREL norm_adj_relation & #keyrel,
             PUNCT no_punctuation_min ] ].

how_about_word := basic_how_about_word & root_marker_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM.MOOD indicative,
                         VAL.COMPS < [ --MIN independent_rel,
                                       LOCAL [ CAT.VAL [ SPR *olist*,
                                                         COMPS < > ],
                                               CTXT #ctxt ],
                                       PUNCT.RPUNCT.PSF #pred ] > ],
                   CONT.HOOK.INDEX.SF #pred,
                   CTXT #ctxt ] ].

; DPF 12-Apr-03 - Constrained COMPS..VAL.COMPS to be < > to avoid spurious
; ambiguity due to application of hdn_optcmp_c rule (e.g. "how about sometime").
;; DPF 2011-05-29 - Constrained COMPS..VAL.SUBJ to be empty, to exclude NPs
;; derived from sentences, as in "why is the sky blue? Malia asked."
;;
comp_how_about_n_or_p_lexent := how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD n_or_p,
                                                   VAL [ SUBJ < >,
							 COMPS < > ] ],
                                             CONT.HOOK.LTOP #ltop ],
                                     --SIND #ind ] >,
                   CONT [ HOOK.INDEX #event & event,
                          RELS.LIST < relation, 
                                      [ LBL #ltop,
                                        ARG0 #event,
                                        ARG2 #ind ], ... > ] ] ].

; how about
; <type val="x_xp_howabt-n-p_le">
; <description>WH-about, NP or PP comp          
; <ex>How about rice?
; <nex>
; <todo>
; </type>
x_xp_howabt-n-p_le := comp_how_about_n_or_p_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --SIND #ind,
                                     OPT - ] >,
                   CONT.RELS <! relation, [ ARG2 #ind ] !> ] ].

; how long before the end?  how long before kim arrives?
; <type val="x_pp_howabt_le">
; <description>WH-about, only 'how long'        
; <ex>How long before C arrives?
; <nex>
; <todo>
; </type>
x_pp_howabt_le := comp_how_about_n_or_p_lexent &
  [ SYNSEM.LOCAL 
     [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD prep &
                                  [ MOD < [ LOCAL scopal_mod &
                                                  [ CONT.HOOK.LTOP #mtop ] ]>],
                                 CONT.HOOK.LTOP #ltop ],
                         OPT - ] >,
       CONT.RELS <! relation, 
                  [ ARG2 #ltop,
		    CFROM #cfrom, CTO #cto ],
                  event_relation &
                  [ PRED generic_verb_rel,
                    LBL #mtop,
		    CFROM #cfrom, CTO #cto ] !> ] ].

; <type val="x_cp_howabt_le">
; <description>WH-about, CP comp                
; <ex>How about we leave now?
; <nex>
; <todo>
; </type>
x_cp_howabt_le := how_about_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM.MOOD #mood,
                         VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                          [ TAM.MOOD #mood ],
                                                     MC + ],
                                               CONT.HOOK.LTOP #ltop ],
                                       OPT - ] > ],
                   CONT [ HOOK.INDEX #event,
                          RELS <! relation & [ ARG1 #ltop ],
                                 [ ARG0 #event ] !> ] ] ].

; DPF 25-Nov-01 - Removed INDEX..TENSE no_tense since root_strict requires
; real_tense.
comp_how_about_or_why_vp_lexent := how_about_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM.MOOD #mood,
                         VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                          [ TAM.MOOD #mood ],
                                                     VAL.SUBJ < synsem > ],
                                             CONT.HOOK [ LTOP #cltop,
                                                         INDEX.SF prop ] ],
                                     OPT - ] > ],
                   CONT [ HOOK.INDEX #ind & event,
                          RELS <! relation & [ ARG1 #cltop ], 
                                 [ ARG0 #ind ] !> ] ] ].

; DPF 17-Apr-01 - Changed COMPS.FIRST..SUBJ from canonical_synsem to synsem
; since the former blocked "Why be late"

; <type val="x_vp_howabt_le">
; <description>WH-about, VP comp                
; <ex>How about leaving now?
; <nex>
; <todo>
; </type>
x_vp_howabt_le := comp_how_about_or_why_vp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM prp ] > ].

; <type val="x_vp_why_le">
; <description>WH-about, only 'why', VP comp    
; <ex>Why leave now?
; <nex>
; <todo>
; </type>
x_vp_why_le := comp_how_about_or_why_vp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM bse_only ] > ].

; <type val="x_-_why_le">
; <description>WH-about, no comps               
; <ex>Why?
; <nex>
; <todo>
; </type>
x_-_why_le := basic_how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ HOOK.INDEX #ind & event,
                          RELS <! relation, 
                                [ ARG0 #ind ] !> ] ] ].

; Discourse-related sentential adverbs
;   (e.g. 'then, but')
; DPF 06-Oct-98 - Added MC + to MOD, to block "Kim says but sandy left"
; DPF 15-Oct-98 - Changed HEAD from adv to root-marker, to get "yes, okay"
; DPF 22-Oct-98 - Added MC + to the SYNSEM itself to block the relative clause
;   in "a programmer but he hired".
; DPF 09-Jun-99 - Added SLASH 0-dlist to MOD, to block e.g. "when yes Kim left"
; DPF 03-Oct-99 - Added SUBJ *olist* to MOD specific. - why wasn't it here 
; before?
; DPF 17-Apr-00 - Removed CONJ cnil to enable e.g. "yes and Kim left"
; DPF 22-Nov-01 - We have to make sure that disc_adv_words propagate the MC 
; feature of their modifiee, to block e.g. yes-no parse for "I would like to 
; arrive"
;; DPF 2012-08-09 - Added SPR *olist* to prevent spurious attachment of 
;; `like' adverbs to both N-bar and NP, as in |Kim though though arose.|

basic_disc_adv_synsem := synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT [ MC #mc,
                                             VAL.SPR *olist* ] ] > ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < >,
			SPCMPS < > ],
                  MC #mc ],
	    CONJ cnil ],
    NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ] ].

disc_adv_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD root-marker &
		       [ PRD -,
			 MOD < [ LOCAL scopal_mod &
                                   [ CAT [ HEAD disc_adverbee &
                                              [ TAM.TENSE real_tense ],
                                           VAL [ SUBJ *olist*,
                                                 SPR *olist*,
                                                 COMPS < >,
                                                 SPEC < > ] ] ],
                                 NONLOC.SLASH 0-dlist ] > ] ] ] ].

disc_adv_phr_synsem := basic_disc_adv_synsem & phr_synsem &
  [ LOCAL.CAT.HEAD adv &
                   [ MOD < [ LOCAL.CAT.VAL [ SPR *olist*,
                                             COMPS < > ],
                             NONLOC.SLASH 0-dlist ] > ] ].

;; DPF 24-Oct-98 Removed [MC +] from disc_adv_word, since this runs afoul of
;; the carefully balanced constraint on head-modifier structures which requires
;; [MC na], to allow relative clauses as modifiers while preventing ordinary
;; finite clauses from being modifiers.

disc_adv_word := non-qr-h-nab &
  [ SYNSEM disc_adv_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN abstr_excl_rel,
		     CONJ cnil,
                     CONT [ HOOK [ LTOP #chand & handle,
                                   INDEX #cind ],
			    RELS.LIST < #keyrel,
                                        [ LBL #chand,
                                          PRED discourse_rel,
                                          ARG0 #cind ], ... >,
                            HCONS <! !> ] ],
	     PUNCT [ LPUNCT no_punct,
		     RPUNCT comma_or_clause_or_no_punct ],
             LKEYS.KEYREL #keyrel & [ PRED abstr_excl_rel ] ] ].

adv_disc_preh_lexent := disc_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ POSTHD -,
			   HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #mltop,
					--SIND #mindex ] > ],
		     CONT.RELS <! [ LBL #khand,
                                  ARG0 #kind ],
			      #altkeyrel &
                              [ L-HNDL #khand,
                                L-INDEX #kind,
                                R-HNDL #mltop,
                                R-INDEX #mindex ] !> ],
	     PUNCT [ RPUNCT no_punct,
		     PNCTPR ppair ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; <type val="av_-_dc-pr_le">
; <description>Disc adv, pre-hd                 
; <ex>Folks, B won.
; <nex>
; <todo>
; </type>
av_-_dc-pr_le := adv_disc_preh_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED excl_rel ].

; <type val="av_-_dc-grt-pr_le">
; <description>Disc, greeting, pre-hd           
; <ex>Hello, B is here.
; <nex>
; <todo>
; </type>
av_-_dc-grt-pr_le := adv_disc_preh_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED greet_rel,
             MODIFD.LPERIPH + ] ].

; DPF 18-aug-07 - Constrain the modifiee to be comma-marked, to avoid
; spurious ambiguity for e.g. "The goal brought more cheers."
;; DPF 29-sept-11 - Move this down to more specific subtype, so we can still
;; admit |I'm taking off bye-bye|

adv_disc_posth_lexent := disc_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ POSTHD +,
			   HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #mltop,
					--SIND #mindex ] > ],
		     CONT.RELS <! [ LBL #khand,
                                  ARG0 #kind ],
				#altkeyrel &
                                [ R-HNDL #khand,
                                  R-INDEX #kind,
                                  L-HNDL #mltop,
                                  L-INDEX #mindex ] !> ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; <type val="av_-_dc-po_le">
; <description>Disc, post-hd                    
; <ex>B won, folks.
; <nex>
; <todo>
; </type>
av_-_dc-po_le := adv_disc_posth_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED excl_rel,
	     PUNCT [ RPUNCT no_punct,
		     PNCTPR ppair ] ] ].

; <type val="av_-_dc-po-cma_le">
; <description>Disc, post-hd, head must be comma-marked.                    
; <ex>B won, cheers!
; <nex>
; <todo>
; </type>
av_-_dc-po-cma_le := adv_disc_posth_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED excl_rel,
	     LOCAL.CAT.HEAD.MOD < [ PUNCT.RPUNCT comma_or_no_punct ] >,
	     PUNCT.RPUNCT comma_or_clause ] ].

; <type val="av_-_dc-grt-po_le">
; <description>Disc, greeting, post-hd          
; <ex>We're leaving, bye.
; <nex>
; <todo>
; </type>
av_-_dc-grt-po_le := adv_disc_posth_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED greet_rel ].

; This is like really necessary
disc_adv_like_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD root-marker &
                     [ PRD -,
                       MOD < [ LOCAL scopal_mod &
                                     [ CAT.HEAD subst,
                                       CONT.HOOK #hook ] ] >,
                       MINORS.MIN abstr_excl_rel ],
            CONT [ HOOK #hook,
                   RELS <! !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL.PRED abstr_excl_rel ].

adv_disc_like_lexent := noncqr-h-nab &
  [ SYNSEM disc_adv_like_synsem &
           [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL [ LBL #ltop,
                            PRED excl_rel ] ] ].

;; DPF 2012-10-23 - Generlized LPERIPH from na to na_or_+ in order to also
;; get |Kim, that is, the hero, arrived|

; <type val="av_-_dc-like-pr_le">
; <description>Disc, 'like'-type, pre-hd        
; <ex>B found like the best cat.
; <nex>
; <todo>
; </type>
av_-_dc-like-pr_le := adv_disc_like_lexent &
 [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.COMPS < >,
				     NONLOC.SLASH 0-dlist ] >,
			POSTHD - ],
	    MODIFD.LPERIPH na_or_+ ] ].

; <type val="av_-_dc-like-unk_le">
; <description>Disc adv, generic, matches "UH" PTB tag
; <ex>B found like the best cat.
; <nex>
; <todo>
; <native> av_-_dc-like-pr_le
; </type>
av_-_dc-like-unk_le := adv_disc_like_lexent &
 [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.COMPS < >,
				     NONLOC.SLASH 0-dlist ] >,
			POSTHD - ],
	    MODIFD.LPERIPH na_or_+,
	    PHON.ONSET unk_onset ] ].

; <type val="av_-_dc-like-vp_le">
; <description>Disc, 'like'-type, pre-hd, not main clause mod.
; <ex>B found like the best cat.
; <nex>
; <todo>
; </type>
av_-_dc-like-phr_le := adv_disc_like_lexent &
 [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ VAL.COMPS < >,
						 MC na_or_- ],
				     NONLOC.SLASH 0-dlist ] >,
			POSTHD - ],
	    MODIFD.LPERIPH na ] ].

av_-_dc-spch-pr_le := noncqr-h-nab &
 [ SYNSEM synsem &
	  [ LOCAL [ CAT [ HEAD no_head &
			       [ MOD < [ LOCAL scopal_mod &
					       [ CAT [ HEAD verb_or_frag,
						       VAL [ SUBJ *olist*,
							     SPR *olist*,
							     COMPS < >,
							     SPEC < > ],
						       MC #mc ],
						 CONT.HOOK #hook ],
					 NONLOC.SLASH 0-dlist ] >,
				 MINORS.MIN no_rel ],
			  VAL [ SUBJ < >,
				SPR < >,
				COMPS < > ],
			  MC #mc ],
		    CONJ cnil,
		    CONT [ HOOK #hook,
			   RELS <! !>,
			   HCONS <! !> ] ],
	    LEX -,
	    MODIFD.LPERIPH na_or_+,
	    NONLOC [ SLASH 0-dlist,
		     REL 0-dlist,
		     QUE 0-dlist ] ] ].

; 'i think'
; <type val="av_-_dc-like-po_le">
; <description>Disc, 'like'-type, post-hd       
; <ex>B sent C, I think, to D.
; <nex>
; <todo>
; </type>
av_-_dc-like-po_le := adv_disc_like_lexent &
 [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
		      POSTHD + ] ].

; 'though'
; <type val="av_-_dc-like-po_le">
; <description>Disc, 'like'-type, post-hd, must comma-marked target
; <ex>The cat, though, chased dogs.
; <nex> We act as though Kim chased deals.
; <todo>
; </type>
av_-_dc-like-po-pnct_le := adv_disc_like_lexent &
 [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_punct ] >,
		      POSTHD + ] ].

; 'ten minutes or so'
; <type val="av_-_dc-meas-po_le">
; <description>Disc, just 'or so'               
; <ex>B fell ten feet or so.
; <nex>
; <todo>
; </type>
av_-_dc-meas-po_le := adv_disc_like_lexent &
 [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ --MIN abstr_meas_nom_rel,
                                   PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
                      POSTHD + ] ].

; Speech filler tokens like *delete*
;
speech_filler_synsem := basic_lex_synsem &
  [ LOCAL [ CAT [ HEAD spfill &
                       [ MINORS [ MIN never_unify_rel,
				  ALTMIN never_unify_rel ] ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < > ] ],
	    CONJ cnil,
            CONT [ RELS <! !>,
                   HCONS <! !> ] ],
    NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ],
    LKEYS.KEYREL.PRED no_rel ].

av_-_spfill_le := noncqr-h-nab &
  [ SYNSEM speech_filler_synsem ].

; Tell me please if my account is closed
; <type val="av_-_dc-pls_le">
; <description>Disc, just 'please'              
; <ex>Please leave.
; <nex>
; <todo>
; </type>
av_-_dc-pls_le := noncqr-h-nab &
  [ SYNSEM basic_disc_adv_synsem &
	   [ LOCAL [ CAT [ HEAD adv &
                                [ MOD < [ LOCAL intersective_mod &
                                                [ CAT [ HEAD subst,
                                                        VAL [ SPR *olist*,
                                                              COMPS < > ] ],
                                                  CONT.HOOK #hook ],
					  MODIFD notmod_or_rmod,
                                          NONLOC.SLASH 0-dlist ] >,
                                  MINORS.MIN abstr_excl_rel ] ],
                     CONT [ HOOK #hook &
                                 [ LTOP #ltop,
                                   INDEX #ind ],
                            RELS <! #rel !>,
                            HCONS <! !> ] ],
             LEX +,
             LKEYS.KEYREL #rel & [ PRED polite_rel,
                                   LBL #ltop,
                                   ARG1 #ind ] ] ].

; <type val="x_-_wh-the-hell_le">
; <description>Emph, comp of WH-words           
; <ex>Who the hell told you?
; <nex>
; <todo>
; </type>
x_-_wh-the-hell_le := noncqr-h-nab &
  [ SYNSEM [ LOCAL [ CAT [ HEAD wh_adv &
                                [ MOD < >,
                                  MINORS.MIN wh_the_hell_rel ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ] ],
		     CONT [ RELS <! !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL.PRED wh_the_hell_rel,
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Temporal nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Extend to COMPS of temporal nouns the hack blocking extraction of subjects of
; inverted auxiliaries, which exploits CASE value.
; Block N-N compound of "a two meeting" by stipulating that hour_words are
; PRD +, incompatible with requirement of compound rule.  In contrast, e.g.,
; day_of_week words are unmarked for PRD.
;
; Made CONT.HOOK.LTOP be the handle of the numbered_hour_rel rather than that 
; of the implicit def_implicit_q_rel, since hour_words can be modified, as in 
; "two o'clock on the sixteenth".  Since the PP unifies its LTOP handle with 
; the ; LTOP handle of the phrase it modifies, that handle can't be the handle
; of the quantifier, so must be that of the numbered_hour_rel.

; DPF (18-Oct-98) - Removed PRD + from hour_word, so it can combine with its
; minute or am-pm complements and still be a prenominal adjective, as in
; "a ten thirty am meeting"

; DPF (22-Dec-98) - SYNSEM is typed phr_synsem in order to block 
; "a two meeting" while admitting "a two o'clock meeting" - this works because
; "two o'clock" combines with "meeting" using the noun-noun compound rule, 
; which requires the left member to have SYNSEM of type lex_synsem.

; DPF 13-May-01 - Added [RPERIPH +] to prevent hour words from being modified
; (especially by relative clauses), and therefore added optional prd-pp 
; complement to still get e.g. "three in the morning"
; DPF 9-Oct-02 - Can't have these be phr_synsem, since that prevents them from
; undergoing the (necessary) hdn_optcmp_c rule (which is constrained to lex_synsem
; dtrs in order to prevent spurious ambiguity from n-n-cmpnds).  So instead
; make it LEX - without commitment to the synsem type.
; DPF 27-Oct-02 - Changed HC-LEX from + to +* so we can get coordination of
; "two and two thirty".
; DPF 30-Apr-03 - Considered adding ALTMIN no_rel to prevent these from 
; appearing as left member of np-n compounds after getting a specifier, as in
; "*the at least two chairs", but this fails because the entry for 'from'
; as in "from ten to two" requires the first comp to have non-empty ALTMIN.
; So look for a more general reason to block the above.
; DPF 05-dec-03 - Added SPEC < anti_synsem_min > to prevent these from being 
; specifiers of the sp-hd_n_c rule; preferring instead the sp-hd_hc_c rule for "nine 
; to ten pm'.  Can't say SPEC < > since particle preps want NP complement
; which is SPEC < anti_synsem_min >.

basic_abstr_hour_word := noncqrs-m & basic_noun_word &
  [ INFLECTD +,
    SYNSEM basic_lex_synsem &
    [ LOCAL nomod_local &
            [ CAT [ HEAD noun & [ POSS -,
                                  MINORS [ MIN numbered_hour_rel,
                                           ALTMIN implicit_q_rel ] ],
                    VAL [ SUBJ < >,
                          SPR < [ --MIN just_only_deg_rel,
                                  LOCAL
                                  [ CAT [ HEAD adv,
                                          VAL [ SPR  *olist*,
                                                COMPS < >,
                                                SPEC < [ LOCAL.CAT.VAL.COMPS 
                                                                  < > ] > ] ],
                                    CONT.HOOK [ LTOP #nhand,
                                                XARG #index ] ],
                                  OPT + ] >,
                          SPEC < anti_synsem_min >,
                          COMPS < [ LOCAL [ CAT [ HEAD intadj2 &
                                                  [ MOD < [ --MIN minute_rel,
                                                            LOCAL.CONT.HOOK 
                                                            [ LTOP #nhand ]]>],
                                                  VAL [ COMPS < >,
                                                        SPEC *synlist* ] ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #min ] ],
                                    NONLOC.SLASH 0-dlist,
                                    OPT +,
                                    PUNCT.LPUNCT no_punct ],
                                  synsem &
                                  [ --MIN am_pm_rel,
                                    LOCAL [ CAT.HEAD no_head,
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #ampm ] ],
                                    NONLOC.SLASH 0-dlist,
                                    OPT +,
                                    PUNCT.LPUNCT no_punct ],
                                  synsem & 
                                  [ --MIN temp_loc_rel,
                                    LOCAL 
                                    [ CAT prd_cat &
                                      [ HEAD prep &
                                        [ MOD < [ --MIN #pred ] > ] ],
                                      CONT.HOOK [ LTOP #nhand,
						  XARG #index ],
                                      CONJ cnil ],
                                    NONLOC.SLASH 0-dlist ] > ],
                    HC-LEX +,
                    HS-LEX - ],
              CONT nom-obj &
                       [ HOOK.INDEX #index & [ PNG.PN 3s,
                                               SORT time ],
                         RELS.LIST < #keyrel & basic_arg12_relation &
                                     [ LBL #nhand,
                                       PRED #pred & basic_numbered_hour_rel,
                                       ARG0 #index,
                                       ARG1 #min,
                                       ARG2 #ampm ],
				     #altkeyrel &
				     [ PRED def_implicit_q_rel,
                                       ARG0 #index,
                                       RSTR #rhand ], ... >,
			 HCONS <! qeq &
                                  [ HARG #rhand,
                                    LARG #nhand ] !> ],
		   AGR #index,
		   ARG-S < > ],
      LKEYS [ KEYREL #keyrel,
	      ALTKEYREL #altkeyrel ],
      MODIFD notmod & [ RPERIPH + ] ] ].

abstr_hour_word := basic_abstr_hour_word &
  [ SYNSEM.LKEYS.KEYREL.PRED numbered_hour_rel ].

; <type val="n_-_pn-hour_le">
; <description>Named hour of day                
; <ex>B won at noon.
; <nex>
; <todo>
; </type>
n_-_pn-hour_le := basic_abstr_hour_word &
  [ SYNSEM [ LOCAL.CONT.RELS <! relation, relation !>,
	     LKEYS.KEYREL.PRED numbered_hour_rel,
             LEX - ] ].

; sixish
; <type val="n_-_pn-hour-apx_le">
; <description>Approximate named hour           
; <ex>B won at eightish.
; <nex>
; <todo>
; </type>
n_-_pn-hour-apx_le := abstr_hour_word &
  [ SYNSEM.LOCAL.CONT.RELS <! relation &
			         [ LBL #hand,
				   ARG0 #arg0,
				   CFROM #cfrom, CTO #cto ],
			         relation, 
			         [ LBL #hand,
                                   PRED approx_grad_rel,
				   ARG1 #arg0,
				   CFROM #cfrom, CTO #cto ] !> ].

; <type val="n_np_pn-hour-gen_le">
; <description>Named hour, generic              
; <ex>B won at generic-hour.
; <nex>
; <todo>
; <native> n_-_pn-hour_le
; </type>
n_np_pn-hour-gen_le := basic_abstr_hour_word & generic_ne_lex_entry &
  [ SYNSEM [ LOCAL.CONT.RELS <! relation, relation !>,
	     LKEYS.KEYREL.PRED numbered_hour_rel ] ].

abstr_minute_word := np_word_no_aff &
  [ SYNSEM [ LOCAL [ CAT.HEAD intadj2 &
                              [ MINORS.MIN minute_rel,
                                PRD + ],
                     CONT [ HOOK [ LTOP #hand,
				   INDEX non_expl-ind & #inst &
					[ PNG png & [ PN 3s ] ] ],
			    HCONS <! !> ] ],
	     LKEYS.KEYREL [ LBL #hand,
                            PRED minute_rel,
                            ARG0 #inst ],
	     MODIFD notmod ] ].

; <type val="aj_-_i-mnt-pr_le">
; <description>Adj, named minutes, pre-hd       
; <ex>It is half past three.
; <nex>
; <todo>
; </type>
aj_-_i-mnt-pr_le := abstr_minute_word &
  [ SYNSEM.LOCAL [ CAT.POSTHD -,
                   CONT.RELS <! relation !> ] ].


; <type val="aj_-_i-mnt-po_le">
; <description>Adj, named minutes, post-hd      
; <ex>It is three o'clock.
; <nex>
; <todo>
; </type>
aj_-_i-mnt-po_le := abstr_minute_word &
  [ SYNSEM.LOCAL [ CAT.POSTHD +,
                   CONT.RELS <! relation !> ] ].

; <type val="aj_-_i-mnt-app_le">
; <description>Adj, approx minutes, post-hd     
; <ex>It is three thirtyish.
; <nex>
; <todo>
; </type>
aj_-_i-mnt-app_le := abstr_minute_word &
  [ SYNSEM [ LOCAL [ CAT.POSTHD +,
                     CONT [ HOOK.LTOP #hand,
                            RELS <! relation, 
				  #altkeyrel &
                                  [ LBL #hand,
                                    PRED approx_grad_rel,
                                    ARG1 #arg0 ] !> ] ],
             LKEYS [ KEYREL.ARG0 #arg0,
		     ALTKEYREL #altkeyrel ] ] ].

; am/pm, AD/BC
xp_suffix_lexent := np_word_no_aff &
  [ SYNSEM [ LOCAL [ CAT.HEAD no_head,
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #arg0 ],
                            RELS <! [ LBL #ltop,
                                      ARG0 #arg0 ] !>,
			    HCONS <! !> ] ],
             LKEYS.KEYREL const_arg0_relation ] ].

xp_suffix_quant_lexent := np_word_no_aff &
  [ SYNSEM [ LOCAL [ CAT.HEAD no_head,
		     CONT [ HOOK [ LTOP #cpdtop,
				   INDEX #arg0 & ref-ind & [ PNG.PN 3s, IND + ],
				   XARG #xarg ],
			    RELS <! [ LBL #nhand,
				      ARG0 #arg0,
				      CFROM #cfrom, CTO #cto],
				  #altkeyrel &
				    [ PRED udef_q_rel,
				      ARG0 #arg0,
				      RSTR #rhand ],
				    prep_notense_relation &
				    [ LBL #cpdtop,
				      PRED compound_rel,
				      ARG1 #xarg,
				      ARG2 #arg0,
				      CFROM #cfrom, CTO #cto ] !>,
			    HCONS <! qeq & [ HARG #rhand,
					     LARG #nhand ] !> ] ],
	     LKEYS [ KEYREL const_arg0_relation,
		     ALTKEYREL #altkeyrel ] ] ].

; <type val="x_-_am-pm_le">
; <description>Time expr, only 'am/pm'          
; <ex>B arrived at ten pm.
; <nex>
; <todo>
; </type>
x_-_am-pm_le := xp_suffix_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN am_pm_rel ].

; <type val="x_-_bc-ad_le">
; <description>Time expr, only 'bc/ad'          
; <ex>It was built in 500 A.D.
; <nex>
; <todo>
; </type>
x_-_bc-ad_le := xp_suffix_quant_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN bc_ad_rel ].

; DPF 01-dec-05 - Constrain these to only appear as complements of preps,
; to avoid spurious ambiguity with the ordinary noun of same spelling in
; each case.
; DPF 20-mar-06 - Also exclude these from modification by relative clauses,
; to avoid e.g. "*dinner that I had yesterday was late."

; <type val="n_-_pn-mealtm_le">
; <description>Mealtime noun                    
; <ex>We met at breakfast.
; <nex>
; <todo>
; </type>
n_-_pn-mealtm_le := noncqrs-hm-nab & basic_noun_word &
  [ SYNSEM noun_synsem &
	 [ LOCAL [ CAT [ HEAD [ POSS -,
                                MINORS [ MIN gen_hour_rel,
                                         ALTMIN #altmin,
                                         NORM mealtime_rel ],
				MOD < >,
                                CASE obliq ],
			 VAL [ SUBJ < >,
			       SPR < [ --MIN just_only_deg_rel,
                                       LOCAL [ CAT [ HEAD adv,
                                                     VAL [ SPR  *olist*,
							   COMPS < > ] ],
                                               CONT.HOOK [ LTOP #nhand,
                                                           XARG #index ] ],
                                       OPT + ] >,
			       COMPS < > ] ],
		   CONT nom-obj &
		       [ HOOK [ INDEX #index & [ SORT time ] ],
			 RELS <! #keyrel &
                               [ LBL #nhand,
                                 ARG0 #index ],
			       #altkeyrel &
                               [ PRED def_implicit_q_rel & #altmin,
                                 ARG0 #index,
                                 RSTR #rhand ] !>,
			 HCONS <! qeq &
			   [ HARG #rhand,
			     LARG #nhand ] !> ],
		   ARG-S < > ],
           LKEYS [ KEYREL #keyrel,
		   ALTKEYREL #altkeyrel ],
           MODIFD notmod ] ].

; DPF 16-Apr-03 - Finally added type for odd entries "October the" as in
; 'October the fifth'.  Duplicates much of what is in date_det_lr type, but
; not easy to see how to abstract (cf. HCONS for example).

det_month_synsem := norm_det_synsem &
  [ LOCAL [ CAT [ HEAD [ POSS -,
                         MINORS [ MIN def_explicit_q_rel,
                                  ALTMIN mofy_rel ] ],
                  VAL [ COMPS < >,
                        SPEC < [ --MIN dofm_rel,
                                 --SIND #ind ] > ] ],
            CONT [ RELS <! #keyrel &
			   [ CFROM #from,
			     CTO #to ],
                           #altkeyrel,
			   #alt2keyrel &
                           prep_relation &
                           [ LBL #nltop,
                             PRED of_p_rel,
                             ARG1 #ind,
                             ARG2 #spind ],
                           [ PRED def_implicit_q_rel,
                             ARG0 #spind,
                             RSTR #mhand,
			     CFROM #from,
			     CTO #to ] !>,
                   HCONS <! qeq & [ LARG #nltop ],
                            qeq &
                            [ HARG #mhand,
                              LARG #mltop ] !> ] ],
    LKEYS [ KEYREL #keyrel,
            ALTKEYREL #altkeyrel & [ LBL #mltop,
                                  PRED mofy_rel,
                                  ARG0 #spind ],
	    ALT2KEYREL #alt2keyrel ],
    NONLOC [ SLASH 0-dlist,
             QUE 0-dlist,
             REL 0-dlist ],
    MODIFD hasmod ].

; <type val="d_-_month_le">
; <description>Det, month plus 'the'            
; <ex>October the tenth arrived.
; <nex>
; <todo>
; </type>
d_-_month_le := abstr_det_word &
  [ SYNSEM det_month_synsem ].

common_noun_nomod_comp_synsem := basic_count_noun_synsem & 
                                 nonpro_nomod_synsem & two_arg.

; DPF 22-May-01 Added LPERIPH + constraint to block these from beings heads of
; n-n compounds.
; DPF 24-mar-06 For now, require SPR to be unexpressed, to avoid generating
; '*Kim arrived in the 1997.'  So we lose e.g. 'I imagine that your 1997
; was more enjoyable.'  In general, want to avoid 'the' as spr of unadorned
; proper names.  FIX ...
; DPF 28-jun-07 - Added REL 0-dlist.
; DPF 2010-09-17 - Removed the recently added ALTMIN meas_nom_rel, since it
; blocks "the 2010 yearbook".  Not sure what it was intended to do...
;;
n_-_pn-yoc_lexent := basic_word &
  [ SYNSEM temp_noun_comp_two_arg_synsem &
   [ LOCAL [ CAT [ HEAD [ MOD < >,
                          MINORS [ MIN yofc_rel,
				   ALTMIN proper_q_rel,
                                   NORM norm_rel ] ],
                   VAL [ SPR.FIRST unexpressed &
				   [ --MIN quant_or_wh_rel,
				     LOCAL.CAT.HEAD det,
				     NONLOC.QUE #que ],
                         COMPS < [ --MIN bc_ad_rel,
                                   LOCAL [ CAT.HEAD no_head,
                                           CONJ cnil,
                                           CONT.HOOK [ LTOP #nhand,
						       XARG #ind ] ],
                                   NONLOC.SLASH 0-dlist,
                                   OPT + ] > ],
		   HC-LEX -,
		   MC na ],
             AGR [ DIV -,
                   PNG.PN 3s ],
             CONJ cnil,
             CONT [ HOOK [ LTOP #nhand,
                           INDEX #ind & [ PNG png & [ PN 3s ] ] ],
                    RELS <! relation !>,
                    HCONS <! !> ] ],
     NONLOC [ QUE #que,
              SLASH 0-dlist,
              REL 0-dlist ],
     PUNCT [ LPUNCT no_punct,
	     RPUNCT no_punct ],
     LKEYS [ KEYREL [ PRED yofc_rel,
                      LBL #nhand ],
             ALTKEYREL.PRED quant_or_wh_rel ],
     MODIFD notmod & [ LPERIPH + ] ] ].

; <type val="n_-_pn-yoc-gen_le">
; <description>Named year of century - generic  
; <ex>B won in generic-year.
; <nex>
; <todo>
; <native> 
; </type>
n_-_pn-yoc-gen_le := n_-_pn-yoc_lexent &
  [ INFLECTD -,
    TOKENS.+LIST < [ +TNT null_tnt,
		     +CARG #carg ] >,
    SYNSEM [ PHON.ONSET unk_onset,
	     LKEYS.KEYREL const_arg0_relation & [ CARG #carg ] ] ].

; 'the first', 'October first', 'the first of October'
; Need to find way to block '*October first of October'
; DPF 20-Nov-99 - Added PRD + to block membership in N-N-compounds
; DPF 23-Oct-03 - Instead of PRD +, (which is now not consistent with making
; all non-measure NPs [PRD -]), use ALTMIN no_rel to block ordinals as 
; heads of n-n-compounds.
; DPF 25-aug-04 - Try adding LPERIPH - to prevent these from appearing as
; heads of n-n-compounds.  Can't be LPERIPH + since 'May 23 to 25' uses 'to'
; which requires complement to be LPERIPH na_or_- (for reasons no longer 
; clear).
; DPF 24-sept-04 - But LPERIPH - prevents application of np_adv_c rule, as in
; 'we arrived the tenth', and anyway that LPERIPH constraint for 'to' is no
; longer used, so we make these LPERIPH +.
; DPF 26-jun-10 - Removed NORM never_unify_rel since we want |June 24 event|

generic_dom_synsem := basic_noun_synsem & lex_synsem &
  [ LOCAL 
    [ CAT 
      [ HEAD.MINORS [ MIN dofm_rel,
		      ALTMIN #spmin ],
	VAL [ SPR.FIRST #spr & synsem &
		    [ --MIN #spmin & quant_rel,
		      LOCAL.CAT [ HEAD det,
				  VAL [ SUBJ < >,
					SPR *olist*,
					SPEC < [ LOCAL.CONT.HOOK.LTOP #hand]>]],
		      LEX + ],
	      COMPS #comps,
	      SPEC < anti_synsem_min > ] ],
      AGR #agr,
      CONT [ HOOK.INDEX #agr,
	     RELS.LIST < generic_named_nom_relation &
			 [ LBL #hand,
			   PRED dofm_rel,
			   ARG0.PNG png & [ PN 3s,
					    GEN neut ] ], ... > ],
      ARG-S < #spr . #comps > ] ].

;;; DPF 2014-04-26

basic_dom_synsem := generic_dom_synsem & count_noun_synsem &
  [ LOCAL [ CAT [ HEAD partn,
		  VAL.SPR < expressed_synsem &
			    [ --MIN quant_or_wh_rel,
			      LOCAL.AGR.PNG.PN 3s,
			      OPT - ],
			    [ OPT + ] > ],
            CONT.HOOK.INDEX.DIV - ],
    MODIFD hasmod & [ LPERIPH + ] ].


;; DPF 2014-04-26

basic_dom_ord_synsem := basic_dom_synsem &
  [ LOCAL.CAT [ HEAD.MINORS [ MIN dofm_ord_rel,
			      ALTMIN basic_def_explicit_q_rel ],
                VAL.SPR < synsem &
			  [ --MIN def_q_rel,
			    LOCAL.CAT.HEAD.POSS - ],
			  anti_synsem_min > ] ].

dom_ord_synsem := basic_dom_ord_synsem & nonpro_nomod_synsem & one_arg &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN temp_abstr_rel, 
                  VAL [ SUBJ < >,
                        COMPS < >,
                        SPR.FIRST [ OPT - ],
                        SPEC < anti_synsem_min > ] ],
            CONT [ HOOK.INDEX.SORT time,
                   RELS <! relation !> ] ] ].

; DPF 31-May-02 - Changed SPR..MIN from implicit_q_rel to def_q_rel, 
; to make sure these dom's don't undergo the robust bare_pl_sg rule.
basic_dom_card_synsem := basic_dom_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN dofm_card_rel,
		VAL.SPR.FIRST.LOCAL.CAT.HEAD.MINORS [ MIN def_q_rel,
						      ALTMIN mofy_rel ] ],
    LKEYS.ALTKEYREL relation ].

dom_card_synsem := basic_dom_card_synsem & nonpro_nomod_synsem & one_arg &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN temp_abstr_rel,
                  VAL [ SUBJ < >,
                        COMPS < >,
                        SPR < [ OPT - ], anti_synsem_min >,
                        SPEC < anti_synsem_min > ] ],
            CONT [ HOOK.INDEX.SORT time,
                   RELS <! relation !> ] ] ].

;; 12 october (2003)
dom_euro_synsem := generic_dom_synsem & abstr_noun_npcomp_synsem &
                   basic_mass_or_count_synsem &
  [ LOCAL [ CAT [ HEAD noun,
		  VAL [ SPR.FIRST unexpressed &
				  [ --MIN udef_q_rel ],
			COMPS < #keycomp &
				[ --MIN mofy_rel,
				  LOCAL [ CONT.HOOK.LTOP #ltop,
					  CONJ cnil ],
				  OPT -,
				  PUNCT.LPUNCT hyphen_sgl_or_no_punct ] >,
			KCMP #keycomp ] ],
            CONT.HOOK [ LTOP #ltop,
			INDEX [ PNG png & [ PN 3s ],
				DIV +,
				IND - ] ] ],
    LKEYS.KEYREL.LBL #ltop,
    MODIFD notmod ].

abstr_n_day_of_month_lexent := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM generic_dom_synsem &
           [ LOCAL.AGR.PNG.PN 3s ] ].

; <type val="n_-_pn-dom-ord_le">
; <description>Named day of month - ordinal     
; <ex>B won on the tenth.
; <nex>
; <todo>
; </type>
n_-_pn-dom-ord_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_ord_synsem ].

; <type val="n_-_pn-dom-card_le">
; <description>Named day of month - cardinal    
; <ex>B won on June 10.
; <nex>
; <todo>
; </type>
n_-_pn-dom-card_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_card_synsem ].

; <type val="n_-_pn-dom-euro_le">
; <description>Nmd day of month - europe - pre  
; <ex>B won on 10 June.
; <nex>
; <todo>
; </type>
n_-_pn-dom-euro_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_euro_synsem ].

; <type val="n_-_pn-dom-gen_le">
; <description>Named day of month - generic     
; <ex>B won on generic-dom.
; <nex>
; <todo>
; <native> n_-_pn-dom-card_le
; </type>
n_-_pn-dom-gen_le := abstr_n_day_of_month_lexent & generic_ne_lex_entry &
  [ SYNSEM dom_card_synsem ].

; <type val="n_-_pn-dom-o-gen_le">
; <description>Named day of month, ordinal - generic     
; <ex>B won on the generic-dom.
; <nex>
; <todo>
; <native> n_-_pn-dom-ord_le
; </type>
n_-_pn-dom-o-gen_le := abstr_n_day_of_month_lexent & generic_ne_lex_entry &
  [ SYNSEM dom_ord_synsem ].

; 'Tuesday (the first (of October))', 'Tuesday (October first)'
; 'Tuesday of that week'
; DPF 31-Jul-99 - Made SYNSEM be nonpro_nomod_onearg_synsem instead of 
; nomod_basic_onearg_synsem since they can appear in noun-noun compounds,
; and also in appositive constructions.

; <type val="n_-_pn-dom-e-gen_le">
; <description>Nmd day of month - europe - generic
; <ex>B won on 10 June.
; <nex>
; <todo>
; <native> n_-_pn-dom-euro_le
; </type>
n_-_pn-dom-e-gen_le := abstr_n_day_of_month_lexent & generic_ne_lex_entry &
  [ SYNSEM dom_euro_synsem ].

; 'morning' of 'each morning', 'Tuesday morning'
; DPF 19-Oct-02 - Broke this up into two entries, one with empty COMPS
; that excludes "the" to block "I arrived the morning"; and the other with
; PP-of to allow "I arrived the morning of the fifth."
; DPF 23-Apr-03 - Moved MODIFD from basic_n_day_part_lexent to the nocomp
; subtype, to continue to block "*I arrived the morning" (where the temp_np
; rule requires the dtr to be [MODIFD hasmod], and where the determiner "the"
; passes up the MODIFD value of its SPEC) while allowing "I arrived the
; morning of the third" where this pp-comp 'morning' is unmarked for MODIFD.
; DPF 26-Apr-03 - Note that this awkward machinery for three entries (at least)
; for day-part words like "morning" will have to be generalized, since the same
; constraints hold for a few non-temporal nouns like "way" as in 
; 'Kim sang the way you did'  and 'Kim sings that way' but '*Kim sang the way'.
; Also "time" as in "I fell the time he was here" but "*I fell the time".

;basic_n_day_part_lexent := que_word & basic_noun_word &

basic_n_day_part_lexent := noncqrs-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM lex_synsem &
           [ LOCAL [ CAT [ HEAD noun &
                                [ MINORS.MIN day_part_rel ],
                          VAL.SPR < synsem &
                                     [ --MIN quant_or_wh_rel,
                                       LOCAL
					  [ CAT [ HEAD det,
                                                  VAL [ SUBJ < >,
							COMPS < > ] ] ],
                                       --SIND #ind,
                                       OPT - ] > ],
                     AGR #ind,
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #ind ],
			    RELS <! #keyrel & [ LBL #ltop ] !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel &
                   [ LBL #ltop,
                     ARG0 #ind ] ] ].

onearg_count_n_synsem := nonpro_nomod_onearg_synsem & count_noun_synsem.
twoarg_count_n_synsem := noun_two_arg_nomod_synsem & count_noun_synsem.

; <type val="n_-_c-dpt_le">
; <description>Icn, part of day                 
; <ex>B won on Friday afternoon.
; <nex>
; <todo>
; </type>
n_-_c-dpt_le := basic_n_day_part_lexent &
  [ SYNSEM onearg_count_n_synsem &
	   [ LOCAL [ ARG-S < #spr >,
                     CAT.VAL [ SPR < #spr &
                                    [ LOCAL.CAT.HEAD.MINORS.ALTMIN 
                                                    dofw_or_poss_q_rel ] >,
                               COMPS < > ] ],
	     MODIFD notmod ] ].

n_day_part_ppcomp_lexent := basic_n_day_part_lexent &
  [ SYNSEM twoarg_count_n_synsem &
    [ LOCAL [ ARG-S < #spr . #comps >,
              CAT.VAL [ SPR < #spr >,
                        COMPS #comps &
                            < [ LOCAL [ CAT [ HEAD.MINORS.MIN _of_p_sel_rel,
					      VAL.COMPS < > ],
                                        CONT.HOOK [ LTOP #nhand,
                                                    INDEX #ind ] ],
                                NONLOC.SLASH 0-dlist,
                                OPT - ] > ],
              AGR [ DIV - ] ],
      LKEYS.KEYREL [ LBL #nhand,
		     ARG1 #ind ] ] ].

; <type val="n_pp_c-dpt-sg-of_le">
; <description>Cn, part-of day, sg, PP-of comp  
; <ex>B won the night of the 2nd
; <nex>
; <todo>
; </type>
n_pp_c-dpt-sg-of_le := n_day_part_ppcomp_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s,
                                         GEN neut ] ].

; <type val="n_pp_c-dpt-pl-of_le">
; <description>Cn, part-of day, pl, PP-of comp  
; <ex>Nights of May 10 and 11 do
; <nex>
; <todo>
; </type>
n_pp_c-dpt-pl-of_le := n_day_part_ppcomp_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ].

; 'Advent', 'summer', 'Christmas'
; DPF 20-jan-08 - Removed NORM norm_rel since this blocked e.g. "summer day"
; DPF 27-jan-08 - Remoevd LPERIPH na since this blocked "Paris summer day"
                           
n_-_m-ssn_lexent := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
           [ LOCAL [ CAT.VAL.SPR < unexpressed_reg >,
                     CONT [ HOOK.INDEX.PNG png & [ PN 3s ],
                            RELS <! nom_relation !> ] ],
             MODIFD notmod ] ].

; 'winter, summer' - "in winter", "*at winter"
; <type val="n_-_m-ssn_le">
; <description>Mass, season name                
; <ex>B won in winter.
; <nex>
; <todo>
; </type>
n_-_m-ssn_le := n_-_m-ssn_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN season_rel,
             LKEYS.KEYREL.PRED season_rel ] ].

; 'Advent, Christmas' - "at Christmas"
; <type val="n_-_m-hldy_le">
; <description>Mass, holiday name               
; <ex>B won at Christmas.
; <nex>
; <todo>
; </type>
n_-_m-hldy_le := n_-_m-ssn_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN holiday_rel,
	     LKEYS.KEYREL.PRED holiday_rel ] ].

; DPF 21-dec-05 - Removed MODIFD.LPERIPH na, since it prevented e.g.
; NP-N-N compound 'Avdalen summer farm'
; DPF 29-jun-07 - But now getting 'summer farm' via making 'summer' a
; bare meas-NP, so add NORM norm_rel to prevent spurious N-N-cmpnd.
; <type val="n_-_m-ssn-spr_le">
; <description>Mass, season w/ oblig specifier  
; <ex>B won in the winter.
; <nex>
; <todo>
; </type>
n_-_m-ssn-spr_le := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem &
           [ LOCAL [ CAT [ HEAD.MINORS [ MIN season_rel,
                                         ALTMIN quant_or_wh_rel,
                                         NORM norm_rel ],
                           VAL.SPR < expressed_synsem > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! !> ] ],
             MODIFD notmod,
             LKEYS.KEYREL.PRED season_rel ] ].

; <type val="n_np_m-ssn_le">
; <description>Mass, season, NP comp (yoc)      
; <ex>B won in winter 1993.
; <nex>
; <todo>
; </type>
n_np_m-ssn_le := noun_noninfl_word &
  [ SYNSEM mass_noun_npcomp_synsem &
           [ LOCAL [ CAT [ HEAD.MINORS [ MIN season_rel,
                                         ALTMIN quant_or_wh_rel ],
                           VAL.COMPS < [ --MIN yofc_rel ] > ],
                     CONT.HOOK.INDEX.PNG png & [ PN 3s ] ],
             MODIFD notmod,
             LKEYS.KEYREL.PRED season_rel ] ].

; "the morning" etc.
; DPF 14-Oct-02 - Added ALTMIN relation to prevent these entries from 
; appearing as complements of "per", to avoid spurious ambiguity for e.g.
; "per night"
; DPF 15-Apr-03 - Removed strange constraint SPR..CONT.RELS <! relation !>,
; which blocked (among other things) "my mornings".  Instead, made
; SPR..MIN be def_explicit_q_rel to allow only "the" and possessive pronouns.
;; DPF 2011-12-14 - Removed LPERIPH na_or_-, since this blocked |we arrived 
;; the night before|.

n_def_day_part_lexent := noncqrs-hm-nab & basic_noun_word &
  [ SYNSEM nomod_onearg_synsem &
	   [ LOCAL [ ARG-S < #spr >,
		     CAT [ HEAD noun & [ MINORS [ MIN def_day_part_rel,
                                                  ALTMIN norm_rel ] ],
			   VAL 
			    [ SPR < synsem & #spr &
				  [ --MIN basic_def_explicit_q_rel,
                                    LOCAL.CAT [ HEAD det,
                                                VAL [ SUBJ < >,
                                                      COMPS < > ] ],
                                   --SIND #inst,
                                    OPT - ] >,
			      COMPS < >,
			      SPCMPS < > ],
                           POSTHD + ],
		     AGR #inst,
                     CONT [ HOOK [ LTOP #nhand,
                                   INDEX #inst & ref-ind ],
			    RELS <! #keyrel !> ] ],
             LKEYS [ KEYREL #keyrel &
                            [ LBL #nhand,
                              ARG0 #inst & [ SORT time ] ],
                     ALTKEYREL relation ],
             MODIFD notmod ] ].

; <type val="n_-_c-dpt-df-sg_le">
; <description>Day part, sg, def                
; <ex>B enjoyed the evening.
; <nex>
; <todo>
; </type>
n_-_c-dpt-df-sg_le := n_def_day_part_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN neut ],
                               DIV - ] ].

; <type val="n_-_c-dpt-df-pl_le">
; <description>Day part, pl, def                
; <ex>B spent the nights.
; <nex>
; <todo>
; </type>
n_-_c-dpt-df-pl_le := n_def_day_part_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Degree specifiers for adjectives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 'very, really, much, a lot, almost';
; Treated as measure phrases, selected as specifiers by adjectives.

;; DPF 27-Aug-01 - Removed INDEX ref-ind constraint, which was blocking
;; e.g. "kim is just behind the door"
;; DPF 8-Sep-01 - Added MODIFD.LPERIPH na to make sure that "about two weeks"
;; has this value, to block its appearing as head in n_n_compounds.
;; DPF 25-Sep-01 - Block specification of conjoined phrase for now, since we
;; don't know what to do with the semantics anyway.
;; DPF 10-Apr-03 - Made HEAD simply adv rather than old adv_or_partn, since
;; no need to treat these phrases as noun-like - solves several problems,
;; including avoiding these appearing as complements of prepositions.
;; Can probably get rid of LPERIPH specification now - check later.
;; DPF 26-sept-04 - Moved [XARG individual_min] down to lex_degree_spec
;; subtype, in order to allow measure-NPs (with phr_degree_spec_synsem) to
;; appear in appositive constructions like "three meters (10')".  (Can't
;; remember what this constraint is meant to exclude, but it's probably useful)
;; DPF 8-oct-05 - Yes, that constraint helps to block the spurious use of
;; the nonhead-compos variant of the head-specifier rule to pick up 
;; degree-specifiers, as in "at least part of ..." (since the nonhead-compos
;; variant requires its XARG to be a handle).

basic_degree_spec_synsem := canonical_synsem &
  [ LOCAL nomod_local &
          [ CAT.VAL [ SUBJ < >,
		      SPR.FIRST [ --MIN degree_rel,
				  LOCAL [ CAT [ HEAD n_or_adv,
						VAL [ SPR *olist*,
						      SPEC < synsem > ] ],
					  CONT.HOOK [ LTOP #khand,
						      XARG #spind ] ],
				  NONLOC.QUE 0-dlist ] ],
            CONT.RELS.LIST.FIRST [ LBL #khand,
                                   ARG0 #spind ] ] ].

; DPF 11-Feb-02 - Can't have this be POSTHD - (and why did we want it?), 
; since the spec-head rule takes the value of POSTHD from the head's spr
; value, which blocked "kim arrives really soon".
; DPF 25-May-03 - Need POSTHD of specifier to be that of its SPEC, to make
; sure that "maybe in Berlin" is still POSTHD +.
;; DPF 2011-09-23 - Added identity of SPEC..HS-LEX and SPEC..LEX, to preserve
;; LEX property of adjective (phrases), as in |probably easy to hire|, in order
;; to block |*the probably easy to hire consultant|.  But note that this 
;; requires treating the degree-spec "how" differently, since we use this
;; mechanism to distinguish "how many cats" from "*the how tall cats".  So
;; push down to subtypes, and exclude "how", as well as "so", "too", etc.

basic_lex_degree_spec_synsem := basic_degree_spec_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD adv,
                  VAL [ SPEC < [ LOCAL.CAT.POSTHD #ph ] >,
			SPR < synsem_min > ],
                  POSTHD #ph ],
            CONT [ HOOK [ INDEX #index,
                          XARG individual_min ],
                   RELS.LIST.FIRST #keyrel & [ ARG0 #index ] ] ],
    LKEYS.KEYREL #keyrel ].

lex_degree_spec_synsem := basic_lex_degree_spec_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN degree_rel,
		  VAL [ COMPS < >,
			SPEC < [ MODIFD #modif,
				 LOCAL.CAT.HS-LEX #hslex,
				 LEX #hslex ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX.E [ TENSE no_tense,
                                    ASPECT no_aspect ],
                          XARG #xarg ],
                   RELS.LIST.FIRST [ LBL #ltop,
                                     ARG1 #xarg ] ] ],
    MODIFD #modif ].


; For measure_nps as in "two foot tall"
; DPF 4-Nov-02 - Removed [ LOCAL.CONT.HOOK.XARG nothing ], since now identify
; XARGs of modifier and modifiee.  Why was it added before?
;; DPF 2014-04-27 - This type wrongly required its SPEC..COMPS to be the empty 
;; list: need nonempty for |10% more cats than dogs|, so remove constraint.
;;
phr_degree_spec_synsem := basic_degree_spec_synsem & lex_phr_synsem &
  [ LOCAL [ CAT.VAL [ SPR.FIRST.--MIN just_only_very_deg_rel,
  		      COMPS < >,
                      SPCMPS < > ],
            CONT [ HOOK.XARG #xarg,
                   RELS.LIST.FIRST.ARG1 #xarg ] ] ].

; For "as" of "as soon as possible" and "too" in "too good to miss"

basic_comp_degree_spec_synsem := basic_lex_degree_spec_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN comp_rel,
                  VAL.SPEC < [ LOCAL [ CAT [ HEAD comp_spec_able,
                                             VAL.COMPS < > ],
                                       CONT.HOOK.LTOP #ltop ] ] > ],
            CONT [ HOOK [ LTOP #ltop,
                          XARG #xarg ],
                   RELS <! arg12_relation &
                           [ LBL #ltop,
                             ARG0 event & [ E [ TENSE no_tense,
                                                ASPECT no_aspect ] ],
                             ARG1 #xarg ] !>,
                   HCONS <! !> ] ],
    NONLOC.QUE 0-dlist ].

basic_comp_degree_wcomps_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_enough_rel,
                VAL [ SPCMPS < synsem & #comp &
				   [ LOCAL.CONJ cnil,
				     OPT -,
				     PUNCT.LPUNCT no_punct ] >,
		      COMPS < #comp > ] ] ].

;; DPF 2012-03-13 - For some reason, recently added MODIFD notmod, but this
;; blocks |We arrived as soon as Kim left|, so remove.
comp_degree_wcomps_synsem := basic_comp_degree_wcomps_synsem &
  [ LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD n_or_a_or_adv_or_det ] > ].

comp_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL.SPCMPS.FIRST [ LOCAL.CONT.HOOK [ LTOP #ltop,
						     INDEX #ind ],
				   NONLOC non-local_none ] ],
    LKEYS.KEYREL [ LBL #ltop,
                   ARG2 #ind ] ].

as_degree_spec_synsem := comp_degree_spec_synsem &
  [ LOCAL.CAT.VAL.SPCMPS.FIRST [ --MIN _as_p_comp_rel,
				 LOCAL.CAT [ HEAD prep,
					     VAL.COMPS < > ] ],
    LKEYS.KEYREL.PRED comp_equal_rel ].

more_degree_spec_synsem := basic_comp_degree_wcomps_synsem &
  [ LOCAL.CAT.VAL [ SPR < [ --MIN much_deg_rel ] >,
		    SPCMPS.FIRST [ --MIN _than_p_compar_rel,
				 LOCAL [ CAT [ HEAD prep,
					       VAL.COMPS < > ],
					 CONT.HOOK [ LTOP #ltop,
						     INDEX #ind ] ],
				 NONLOC non-local_none ] ],
    LKEYS.KEYREL [ LBL #ltop,
                   ARG2 #ind ] ].
                           
basic_too_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL.SPCMPS.FIRST.LOCAL [ CAT s_or_vp_inf_cat,
					 CONT.HOOK.LTOP #ltop ] ],
    LKEYS.KEYREL [ PRED comp_too_rel,
                   ARG2 #ltop ] ].

too_degree_spec_slash_synsem := basic_too_degree_spec_synsem &
  [ LOCAL.CAT.VAL [ SPCMPS.FIRST.NONLOC.SLASH 1-dlist &
                                    <! [ CAT np_cat_acc_min &
                                             [ HEAD [ MINORS.MIN norm_nom_rel,
                                                      MOD < > ] ],
                                         CONT.HOOK.INDEX #ind ] !>,
		    SPEC < [ LOCAL.CONT.HOOK.XARG #ind ] > ] ].

too_degree_spec_synsem := basic_too_degree_spec_synsem &
  [ LOCAL.CAT.VAL.SPCMPS.FIRST.NONLOC.SLASH 0-dlist ].

; DPF 15-aug-07 - Removed HEAD comp to allow "He was so late we couldn't wait"
so_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL.SPCMPS.FIRST [ LOCAL [ CAT s_cat_fin_v_c,
					   CONT.HOOK [ LTOP #ltop,
						       INDEX.SF prop ] ],
				   NONLOC.SLASH 0-dlist ] ],
    LKEYS.KEYREL [ PRED comp_so_rel,
                   ARG2 #ltop ] ].

; |not so tall as to scare you|
so_degree_spec_as_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL.SPCMPS.FIRST [ LOCAL [ CAT [ HEAD prep &
						      [ MINORS.MIN _as_p_rel ],
						 VAL.COMPS < > ],
					   CONT.HOOK [ LTOP #ltop,
						       INDEX.SF prop ] ],
				   NONLOC.SLASH 0-dlist ] ],
    LKEYS.KEYREL [ PRED comp_so_rel,
                   ARG2 #ltop ] ].

; DPF 28-Apr-03 - Until we move to always discharging optional complements,
; we have to split 'as' into two lexical entries, one with an as-comp and one
; without, in order to be able to coordinate "as early and as late" where
; the top_coord_nom rule requires COMPS to be empty (since this 'as' pushes
; its complement to 'as early').

comp_degree_spec_nc_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL.CAT.VAL [ SPCMPS #spc,
		    SPR.FIRST.LOCAL.CAT.VAL.SPCMPS #spc,
		    COMPS < > ] ].

comp_degree_spec_enough_synsem := comp_degree_spec_nc_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN enough_deg_rel,
		VAL [ SPCMPS < >,
		      SPR  < anti_synsem_min > ] ],
    LKEYS.KEYREL.PRED comp_enough_rel ].

#|
;; Add lexical entry for |enough| + comp, eventually -- FIX
;;
comp_degree_spec_enough_wcomps_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN enough_deg_rel,
		VAL [ SPCMPS.FIRST [ LOCAL [ CAT s_or_vp_inf_cat,
					     CONT [ HOOK.LTOP #ltop ] ],
				     OPT - ],
		      SPR  < anti_synsem_min > ] ],
    LKEYS.KEYREL [ PRED comp_enough_rel,
                   ARG2 #ltop ] ].
|#

basic_degree_spec_word := que_word &
  [ SYNSEM basic_lex_degree_spec_synsem &
           [ LOCAL.CONT.RELS.LIST < #keyrel, ... >,
             LKEYS.KEYREL #keyrel ] ].

degree_spec_word := basic_degree_spec_word &
  [ SYNSEM lex_degree_spec_synsem &
           [ LOCAL.CONT [ RELS <! degree_relation !>,
                          HCONS <! !> ],
             NONLOC.QUE 0-dlist ] ].

basic_adv_degree_spec_lexent := degree_spec_word.

adv_degree_spec_lexent := basic_adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.ALTMIN non_event_rel,
                       VAL [ SPR < [ LOCAL.CAT.VAL.SPCMPS #spc ] >,
			     SPEC.FIRST.LOCAL.CAT.HS-LEX #hslex,
                             SPCMPS #spc ],
		       HS-LEX #hslex ] ].

; DPF 18-feb-08 - Changed MIN deg_rel to MIN much_or_very_deg_rel to avoid
; spurious spr-hd analysis for e.g. "under Berlin".
; <type val="av_-_dg_le">
; <description>Degree spec (deg)                
; <ex>B is incredibly rich.
; <nex>
; <todo>
; </type>
av_-_dg_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_or_very_deg_rel,
                       VAL.SPEC < [ LEX + ] > ] ].

; <type val="av_-_dg-v_le">
; <description>Deg, very-type                   
; <ex>B is very rich.
; <nex>
; <todo>
; </type>
av_-_dg-v_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN very_deg_rel,
                       VAL.SPEC < [ LEX #lex ] >,
                       HS-LEX #lex ] ].

; <type val="av_-_dg-m_le">
; <description>Deg, much-type                   
; <ex>B is much richer.
; <nex>
; <todo>
; </type>
av_-_dg-m_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN much_deg_rel ].

; This type allows unification with very_deg_rel, while the next does not.
; <type val="av_-_dg-jov_le">
; <description>Deg, just-only-very              
; <ex>B won just the first race.
; <nex>
; <todo>
; </type>
; DPF 22-may-09 - Changed MIN just_only_degree_rel to just_only_very_deg_rel
; to block e.g. "around Kim" as spr-hd.
av_-_dg-jov_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN just_only_very_deg_rel ].

; DPF 22-may-09 - Added this type for deg specs which can appear both with
; proper names and with 'very' and 'much' -taking heads
; <type val="av_-_dg-jomv_le">
; <description>Deg, just-only-very-much
; <ex>B was notably red(der).
; <nex>
; <todo>
; </type>
av_-_dg-jomv_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN just_only_degree_rel ].

; <type val="av_-_dg-jo_le">
; <description>Deg, just-only                   
; <ex>B won only the first race.
; <nex>
; <todo>
; </type>
av_-_dg-jo_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN just_only_deg_rel ].

; <type val="av_-_dg-jo-num_le">
; <description>Deg, just-only, for numbers                   
; <ex>B won over fifty races.
; <nex>
; <todo>
; </type>
av_-_dg-jo-num_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT 
		 [ HEAD.MINORS.MIN just_only_degree_rel,
		   VAL.SPEC < [ LOCAL.CAT.HEAD n_or_a_or_adv_or_det &
			        [ MINORS.MIN meas_or_numq_rel ] ] > ] ].

#|
av_-_dg-jo-num_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT 
		 [ HEAD.MINORS.MIN just_only_degree_rel,
		   VAL.SPEC < [ LOCAL.CAT.HEAD det_or_adv &
			        [ MINORS.ALTMIN dofw_or_poss_or_meas_rel]] > ]].
|#

; 'this much' 'this tall'
; DPF 18-mar-06 - To block "*my this tall chairs", allow SPEC to unify HS-LEX
; value '-', so "this tall" will be LEX -, and hence cannot modify 
; prenominally.  While 'tall' does this unification, 'many' does not, so we
; can still get "this many chairs'
;; DPF 16-jul-2010 - Re: 18-mar-06: With revised analysis of degree specs, 
;; instead make the SPEC value PRD + to allow |the chair is this tall| but
;; block |*the this tall chair appeared|.
; <type val="av_-_dg-tt_le">
; <description>Deg, this-that                   
; <ex>B isn't that rich.
; <nex>
; <todo>
; </type>
av_-_dg-tt_le := que_word &
  [ SYNSEM comp_degree_spec_nc_synsem & 
           [ LOCAL.CAT [ HEAD.MINORS.MIN this_that_deg_rel,
	                 VAL.SPEC < [ LOCAL.CAT.HEAD n_or_a_or_adv_or_det,
				      MODIFD notmod_or_lmod ] >,
                         HS-LEX - ],
	     MODIFD notmod ] ].

; This type requires unification with much_deg_rel, so cannot be used with
; e.g. determiner 'the', as in "straight (into ...)" or "up to (ten ...)"
; <type val="av_-_dg-jom_le">
; <description>Deg, just-only-much              
; <ex>B ran straight into C.
; <nex>
; <todo>
; </type>
av_-_dg-jom_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN just_only_much_deg_rel ].


av_-_dg-sup_lexent := basic_degree_spec_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN this_that_deg_rel,
			   VAL [ SPR < [ --MIN very_deg_rel ] >,
				 SPEC < [ LOCAL.CAT.HEAD a_or_adv ] >,
				 COMPS < >,
				 SPCMPS < > ],
			   HS-LEX + ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX.E [ TENSE no_tense,
					     ASPECT no_aspect ],
				   XARG #xarg ],
			    RELS <! degree_relation &
				    [ LBL #ltop,
				      ARG1 #xarg ] !>,
			    HCONS <! !> ] ],
	     NONLOC.QUE 0-dlist ] ].

av_pp_dg-sup_lexent := basic_degree_spec_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN this_that_deg_rel,
			   VAL [ SPR < [ --MIN very_deg_rel ] >,
				 SPEC < [ LOCAL.CAT.HEAD a_or_adv ] >,
				 COMPS < >,
				 SPCMPS < [ --MIN #cmin & _of_p_sel_rel,
					    LOCAL [ CAT [ HEAD prep & 
                                                        [ PRD -,
                                                          TAM.TENSE nontense ],
                                                        VAL.COMPS < > ],
						  CONT.HOOK.INDEX 
						      non_expl ],
                                          NONLOC non-local_none,
					  OPT - ] > ],
			   HS-LEX + ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX.E [ TENSE no_tense,
					     ASPECT no_aspect ],
				   XARG #xarg ],
			    RELS <! degree_relation &
				    [ LBL #ltop,
				      ARG1 #xarg ] !>,
			    HCONS <! !> ] ],
	     NONLOC.QUE 0-dlist,
             LKEYS.--COMPKEY #cmin ] ].

; Set [HS-LEX +] which adj_synsem identifies with the spr's SPEC..HS-LEX,
; which is what the head-spec rule uses to set LEX on phrase, so we block
; '*the lake most beautiful' but allow 'the most beautiful lake'
; <type val="av_-_dg-sup_le">
; <description>Deg, superl                      
; <ex>The most famous dog won.
; <nex>
; <todo>
; </type>
av_-_dg-sup_le := av_-_dg-sup_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN superl_rel ].

; <type val="av_-_dg-sup-lst_le">
; <description>Deg, superl                      
; <ex>The least happy dog won.
; <nex>
; <todo>
; </type>
av_-_dg-sup-lst_le := av_-_dg-sup_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN comp_or_superl_rel ].


; <type val="av_pp_dg-sup_le">
; <description>Deg, superl, PP-complement
; <ex>The most famous dog of all won.
; <nex>
; <todo>
; </type>
av_pp_dg-sup_le := av_pp_dg-sup_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN comp_or_superl_rel ].

; <type val="av_pp_dg-sup-lst_le">
; <description>Deg, superl, PP-complement
; <ex>The most famous dog of all won.
; <nex>
; <todo>
; </type>
av_pp_dg-sup-lst_le := av_pp_dg-sup_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN comp_or_superl_rel ].

; <type val="av_-_dg-sup-av_le">
; <description>Deg, superl, for adverbs only                     
; <ex>Who sang the most beautifully?
; <nex>
; <todo>
; </type>
av_-_dg-sup-av_le := av_-_dg-sup_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD adv ] > ].

; <type val="av_pp_dg-sup_le">
; <description>Deg, superl, PP-complement, for adverbs only
; <ex>Who sang the most beautifully of all?
; <nex>
; <todo>
; </type>
av_pp_dg-sup-av_le := av_pp_dg-sup_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD adv ] > ].

; Only for degree specs of determiners: 'not all, not many, not every'
; <type val="av_-_dg-det_le">
; <description>Deg, modify det                  
; <ex>Not every runner won.
; <nex>
; <todo>
; </type>
av_-_dg-det_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN just_only_degree_rel,
                       VAL.SPEC < [ LOCAL.CAT.HEAD det_or_partn ] > ] ].

; Degree specs of directional preps: "all over New York"
;; DPF 2012-02-01 - Generalize slightly to locatives: |all at the same time|
;
; <type val="av_-_dg-ppdir_le">
; <description>Deg, modify dir PP               
; <ex>B sank well into the sand.
; <nex>
; <todo>
; </type>
av_-_dg-ppdir_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL.SPEC < [ --MIN dir_or_state_rel ] > ] ].

; 'due' only for directions
; <type val="av_-_dg-dir_le">
; <description>Deg, 'due north'                 
; <ex>B ran due north.
; <nex>
; <todo>
; </type>
av_-_dg-dir_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL.SPEC < [ --MIN place_n_rel ] > ] ].

; 'roughly', 'wide(-spread)', 'jam(-packed)'
; <type val="av_-_dg-ap_le">
; <description>Deg, modify AP                   
; <ex>The race is wide open.
; <nex>
; <todo>
; </type>
av_-_dg-ap_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN very_this_that_rel,
                       VAL [ SPEC < [ LOCAL.CAT.HEAD adj ] >,
			     SPR.FIRST.LOCAL.CAT.VAL.SPCMPS #spc,
                             SPCMPS #spc ] ] ].

; 'any'
; <type val="av_-_dg-any_le">
; <description>Deg, just 'any'                  
; <ex>B isn't any richer.
; <nex>
; <todo>
; </type>
av_-_dg-any_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL [ SPEC < [ LEX + ] >,
			     SPR.FIRST.LOCAL.CAT.VAL.SPCMPS #spc,
                             SPCMPS #spc ] ] ].

; "how tall"
; DPF 21-Jul-03 - Will want opt comp of-PP or indef-NP to get "how good (of) a
; player is he"
; DPF 07-mar-06 - Made semantics analogous to that of "To what degree is Kim
; tall?", thereby relating the degree index to Kim's index.
; DPF 30-sept-06 - Removed ALTMIN no_rel, since positive adj's now have
; ALTMIN norm_rel so 'most beautiful' can be treated as superlative in
; partitives like "the most beautiful arrived."

adv_wh_degree_spec_lexent := basic_degree_spec_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN degree_rel,
                           VAL [ SPEC < [ LOCAL 
                                          [ CAT.VAL.COMPS *obllist*,
                                            CONT.HOOK.LTOP #sphand ],
                                          NONLOC.SLASH 0-dlist ] >,
				 COMPS < >,
				 SPR.FIRST.LOCAL.CAT.VAL.SPCMPS #spc,
				 SPCMPS #spc ],
			   HS-LEX - ],
                     CONT [ HOOK.XARG #spind,
			    RELS <! [ LBL #hand,
                                      PRED abstr_deg_rel,
                                      ARG0 #arg0 ],
				  #altkeyrel &
                                  [ PRED which_q_rel,
                                    ARG0 #arg0,
                                    RSTR #harg ],
				  #alt2keyrel &
                                  [ PRED measure_rel,
                                    LBL #sphand,
                                    ARG0.E.TENSE no_tense,
                                    ARG1 #spind,
                                    ARG2 #arg0 ] !>,
                            HCONS <! qeq & [ HARG #harg,
                                             LARG #hand ] !> ] ],
	     NONLOC.QUE 1-dlist & [ LIST < param > ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

; How tall
; <type val="av_-_dg-v-wh_le">
; <description>Deg, WH very-type                
; <ex>B saw how rich C is.
; <nex>
; <todo>
; </type>
av_-_dg-v-wh_le := adv_wh_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN very_deg_rel ].

; How much taller
; <type val="av_-_dg-m-wh_le">
; <description>Deg, WH much-type                
; <ex>B saw how much richer C is
; <nex>
; <todo>
; </type>
av_-_dg-m-wh_le := adv_wh_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN much_deg_rel ].

; <type val="av_pp_dg-as_le">
; <description>Deg, just 'as', PP-as comp       
; <ex>B is as rich as C.
; <nex>
; <todo>
; </type>
av_pp_dg-as_le := que_word &
  [ SYNSEM as_degree_spec_synsem ].

; <type val="av_vp_dg-too_le">
; <description>Deg, just 'too', inf VP-CP comp  
; <ex>B is too poor to win.
; <nex>
; <todo>
; </type>
av_vp_dg-too_le := que_word &
  [ SYNSEM too_degree_spec_synsem ].

; <type val="av_vpslnp_dg-too_le">
; <description>Deg, 'too' with VP/NP comp       
; <ex>B is too big to hide.
; <nex>
; <todo>
; </type>
av_vpslnp_dg-too_le := que_word &
  [ SYNSEM too_degree_spec_slash_synsem ].

; <type val="av_cp_dg-so_le">
; <description>Deg, just 'so', CP comp          
; <ex>B is so fast that he won.
; <nex>
; <todo>
; </type>
av_cp_dg-so_le := que_word &
  [ SYNSEM so_degree_spec_synsem ].

; <type val="av_cp_dg-so_le">
; <description>Deg, just 'so', as-VP comp          
; <ex>B is not so rich as to scare you.
; <nex>
; <todo>
; </type>
av_cp_dg-so-as_le := que_word &
  [ SYNSEM so_degree_spec_as_synsem ].

; <type val="av_pp_dg-more_le">
; <description>Deg, just 'more', PP comp   
; <ex>B is less rich than C.
; <nex>
; <todo>
; </type>
av_pp_dg-more_le := que_word &
  [ SYNSEM more_degree_spec_synsem &
	   [ LOCAL.CAT.HEAD.MINORS.ALTMIN comp_more_rel ] ].

; <type val="av_pp_dg-less_le">
; <description>Deg, just 'less', PP comp   
; <ex>B is less rich than C.
; <nex>
; <todo>
; </type>
av_pp_dg-less_le := que_word &
  [ SYNSEM more_degree_spec_synsem ].

; DPF 13-Nov-03 - Constrained SPEC value to be PRD + to prevent "The as tall
; player ..." or "the too beautiful chair ..."
; DPF 16-mar-06 - But this is in conflict with our revised treatment of
; 'many' as an adjective, as in "too many chairs".  So instead constrain
; the SPEC's HS-LEX to be -.
; DPF 31-dec-08 - Require SPEC to be not right-modified, to avoid spurious 
; analysis of "as [tall as Kim]", but allow "as completely crazy as Kim".
;; DPF 2012-09-20 - Removed MODIFD notmod, since this blocked 
;; |Kim arose too soon|, since the npadv rule requires its dtr to be hasmod,
;; and sp-hd-hc rule takes MODIFD value from specifier.


; <type val="av_-_dg-cmp-so_le">
; <description>Deg, 'so/as/too' no comp         
; <ex>B is so fast.
; <nex>
; <todo>
; </type>
av_-_dg-cmp-so_le := que_word &
  [ SYNSEM comp_degree_spec_nc_synsem & 
           [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
	                 VAL.SPEC < [ LOCAL.CAT.HEAD n_or_a_or_adv_or_det,
				      MODIFD notmod_or_lmod ] >,
                         HS-LEX - ] ] ].

; DPF 12-jul-06 - Changed MIN much_or_very_deg_rel to more_deg_rel
; to block "more many" but still allow "very many"
;
av_-_dg-cmp-more_lexent := que_word &
  [ SYNSEM comp_degree_spec_nc_synsem &
           [ LOCAL.CAT.HEAD.MINORS.MIN more_deg_rel ] ].

; <type val="av_-_dg-cmp-more_le">
; <description>Deg, 'more' no comp         
; <ex>B is less rich.
; <nex>
; <todo>
; </type>
av_-_dg-cmp-more_le := av_-_dg-cmp-more_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN comp_more_rel ].

; <type val="av_-_dg-cmp-less_le">
; <description>Deg, 'less' no comp         
; <ex>B is less rich.
; <nex>
; <todo>
; </type>
av_-_dg-cmp-less_le := av_-_dg-cmp-more_lexent.

; <type val="av_-_dg-enough_le">
; <description>Deg, just 'enough'               
; <ex>B is rich enough.
; <nex>
; <todo>
; </type>
av_-_dg-enough_le := que_word &
  [ SYNSEM comp_degree_spec_enough_synsem ].

#|
; <type val="av_-_dg-enough_le">
; <description>Deg, just 'enough'               
; <ex>B is rich enough.
; <nex>
; <todo>
; </type>
av_vp_dg-enough_le := que_word &
  [ SYNSEM comp_degree_spec_enough_wcomps_synsem ].
|#

; <type val="av_-_dg-many_le">
; <description>Deg, just 'many more'
; <ex>'many more (cats) arrived'
; <nex>
; <todo>
; </type>
av_-_dg-many_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL.SPEC < [ LEX +,
				    LOCAL.CAT [ HEAD compar_adj &
						[MOD < [LOCAL.AGR.PNG.PN 3p]>],
						VAL.COMPS < > ] ] > ] ].

; For measure-np ersatz
; NORM norm_rel prevents these from also appearing in noun_n_cmpnds, 
; leaving only the np-hdn_cpd_c we want for "200m climb"
; DPF 7-mar-05 - Removed MODIFD notmod since this prevented "200m away" from
; undergoing the np_adv_c rule, and its motivation remained obscure.
; DPF 29-mar-05 - Changed MIN to deg_rel so we get "half an hour before Kim
; arrives"
;; DPF 2012-03-03 - Removed identif. of INFLECTD and PRD, since we want to
;; allow |Stocks fell _meas_ne_| which needs to be INFL + but PRD - in order
;; to meet demands of the npadv_meas rule that makes the meas_np adverbial.
;;
; <type val="n_-_meas-gen_le">
; <description>Measure noun - generic           
; <ex>C is generic-meas tall.
; <nex>
; <todo>
; <native>
; </type>
n_-_meas-gen_le := noncqrs-hm & generic_lex_entry &
  [ TOKENS.+LIST < [ +CARG #carg ] >,
    SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MINORS [ MIN meas_nom_rel,
                                                  ALTMIN udef_q_rel,
                                                  NORM quantity_rel ],
                                         MOD < > ],
                           VAL [ SPR < unexpressed, anti_synsem_min >,
                                 SPEC < >,
                                 COMPS < > ] ],
                     AGR.PNG.PN 3s,
                     CONT [ HOOK [ LTOP #nhand,
                                   INDEX #nindex ],
                            RELS <! #keyrel & named_nom_relation &
                                    [ PRED meas_np_rel,
				      LBL #nhand,
                                      ARG0 #nindex,
				      CARG #carg ] !>,
                            HCONS <! !> ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             LKEYS [ KEYREL #keyrel ] ] ].

; <type val="n_-_meas-n-gen_le">
; <description>Measure noun - generic           
; <ex>C is 42 generic-meas-noun tall.
; <nex>
; <todo>
; <native> n_-_c-meas_le
; </type>
n_-_meas-n-gen_le := basic_noun_word & generic_lex_entry &
  [ INFLECTD bool,
    SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS [ MIN meas_nom_rel,
					 NORM quantity_rel ],
			   VAL.SPR < [ --MIN quant_or_wh_rel ] > ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !>,
			    HCONS <! !> ],
		     CONJ cnil ],
	     MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation & 
		   [ LBL #ltop,
		     PRED string ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Numbers
;;
;; DPF 14-Apr-01 - Numerals combine with their complements and specifiers as
;; laid out in Smith 2000, but since the specifier-head rule makes the TOP
;; handle of the phrase be that of the spr dtr, we can't have numerals simply
;; identify their LTOP value with their KEY.LBL value or something similar.
;; Hence, numerals combine using the LBL of the attribute ALTMIN, which
;; points to the MIN for simple numerals like "two", but to the plus_rel or
;; the times_rel for more interesting numerals like "hundred".  
;;   The LTOP handle is identified with the SPEC's handle, so when a numeral is
;; built using the specifier-head rule, the resulting LTOP handle will be the 
;; same as the LTOP handle of the head-dtr.  This is useful because of two other
;; regularities:
;;   (1) the MOD's handle is identified with the ALTKEY's handle; and
;;   (2) the intersective modifier-head rule identifies the MOD's handle with
;;       the modifier's LTOP handle.
;; This ensures that the LTOP handle of a numeral modifier will be identified
;; with the ALTKEY's handle, as desired.

; For numerals
anycard_norm_num_synsem := canonical_synsem & basic_zero_arg &
  [ LOCAL [ CAT [ HEAD intadj,
                  VAL.SUBJ < >,
		  POSTHD - ],
	    CONT [ HOOK.XARG non_expl,
                   RELS.LIST < integer_relation, ... > ],
	    CONJ cnil ] ].

; DPF 6-Jun-01 - Added MODIFD.LPERIPH - to avoid unwanted reading for 
; "two hundred three chairs".
; But this blocks "two competent programmers", so make [LPERIPH na].
; DPF 28-Apr-03 - This PERIPH feature is overloaded since it does not
; distinguish directionality - the two uses clash for examples like "the
; first chair that I bought arrived" where for ordering of thatless and
; full relatives we want "chair that I bought" to be (right) [PERIPH +] but 
; to avoid double ordinals we want it to be (left) [PERIPH -].  So change to
; two features LPERIPH and RPERIPH.
; DPF 16-oct-03 - Since now making adj+N be [LPERIPH +], change this type so
; it asks for a MOD..LPERIPH bool but projects LPERIPH na so we can still
; block unwanted parse for "two hundred three chairs" but allow "two hundred
; big chairs".
; Pushed this down to cards, not ords, so we can get "the first seven chairs...
; DPF 06-jun-06 - Moved constraint MOD..SPR expressed_synsem down to cards,
; since this wrongly rejected "many second homes", "some third floors".  
; 24-aug-06 - Re: 16-oct-03: Making "three chairs" be LPERIPH na sadly means
; they can appear within N-N compounds, as in "*mountain first hotel".  Happily
; we aren't actually claiming that adj-N be [LPERIPH +] now, so we can go
; back to requiring that these numerical adjectives modify something which
; is LPERIPH - (could probably also be na, but leave out for now), but they
; themselves are LPERIPH +, still preventing recursion.
; DPF 27-jun-10 - Prevent integers from directly modifying measure nouns,
; to avoid spurious ambiguity for "ten inch nails"
; DPF 2010-09-17 - Moved the recently added MOD..NORM norm_or_no_rel down to 
; cardinals, since it blocked e.g. |the first kilometer|

basic_norm_num_synsem := anycard_norm_num_synsem &
  [ LOCAL 
     [ CAT 
        [ HEAD.MOD 
           < [ LOCAL intersective_mod &
               [ CAT basic_nbar_cat &
		     [ HEAD noun_or_nomger_or_nadj &
			    [ MINORS.MIN nonpro_rel ],
		       VAL.SPR < synsem & [ --MIN quant_or_deg_rel ], ... > ],
		 CONT.HOOK.INDEX #xarg,
                 CONJ cnil ] ] >,
          HC-LEX + ],
       CONT [ HOOK [ INDEX #index,
                     XARG #xarg ],
              RELS.LIST.FIRST [ ARG0 #index,
                                ARG1 #xarg ] ] ],
    MODIFD notmod_or_rmod & [ LPERIPH na_or_+ ] ].

norm_num_synsem := basic_norm_num_synsem & zero_arg &
  [ LOCAL.CONT.RELS.LIST.FIRST #keyrel,
    LKEYS.KEYREL #keyrel ].

; DPF 9-jul-04 - Is this used?
phr_norm_num_synsem := basic_norm_num_synsem & phr_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ MODIFD.LPERIPH bool ] >,
            CONT [ HOOK.INDEX event & 
                              [ E [ TENSE no_tense,
                                    ASPECT no_aspect ] ],
                   HCONS <! !> ] ] ].

; DPF 05-apr-05 - Moved PRD - to norm_card_word since it blocks "Kim was third"

norm_num_word := noncqrs-m-nab &
  [ SYNSEM norm_num_synsem ].

;; some norm_card-words must remain unspecified for CARDINAL
;; DPF 10-Apr-02 - Moved MOD..DIV +* from norm_num_word to norm_card_word
;; since ordinals don't require this: "the eleventh child"
; DPF 27-nov-04 - In fact, DIV value must come from the same source as
; the value for CARDINAL: "twenty ninth" isn't DIV + but "twenty nine" is
; DPF 17-jun-07 - Enabled cardinals to be specifiers of 'more' as in
; 'ten more cats arrived'.

norm_card_word := norm_num_word &
  [ SYNSEM 
    [ LOCAL.CAT [ HEAD [ MOD < [ MODIFD.LPERIPH -,
                                 LOCAL.CAT [ HEAD.MINORS.NORM norm_or_no_rel,
					     VAL.SPR < expressed_synsem &
                                                  [ --MIN explicit_q_rel]>]]>,
			 PRD -,
                         MINORS.MIN card_rel ],
		  VAL [ SPEC < [ LOCAL.CAT.VAl.COMPS #comps ] >,
                        SPCMPS #comps ] ],
      LKEYS.KEYREL.PRED basic_card_rel ] ].

;; those cardinals that take no complements may be safely specified as 
;; +CARDINAL, and as plural (since they're normal)
;; DPF 17-may-09 - Moved PNG.PN constraint to AGR, to enable coordination of
;; "one or two cats"

card_only_word := norm_card_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ CARDINAL +,
			    MOD < [ LOCAL.AGR.PNG.PN 3p ] > ] ].

; should be POSTHD -
; These are adjectives only

; DPF 25-apr-04 - Added SPEC < anti_synsem_min > to prevent ordinals from
; undergoing the partitive_num rule, which is designed to handle not only
; cardinal numbers but also superlatives as in "the best arrived", and
; measure phrases ("ten feet of rope"), while excluding ordinary NPs.
; --FIX-- This won't scale up to complex ordinals like "twenty-second"
; which are different from "twenty-two" only in the CARDINAL feature, so
; CARDINAL would have to be introduced higher up than on the type intadj.
; DPF 26-aug-04 - Added variant of partitive rule for cardinals and ordinals,
; (which produces a sign that like common nouns requires a determiner),
; still using SPEC < anti_synsem_min > to distinguish the two.

ord_word := norm_num_word & 
  [ SYNSEM [ LOCAL.CAT [ HEAD [ CARDINAL -,
                                MINORS.MIN ord_rel ],
                         VAL [ COMPS < >,
                               SPEC < [ LOCAL.CAT [ HEAD basic_adj &
                                                         [ MINORS.ALTMIN 
                                                               superl_rel ],
                                                    VAL.COMPS #comps ] ] >,
                               SPCMPS #comps ] ],
             LKEYS.KEYREL.PRED basic_ord_rel ] ].

;;  Specifiers and modifiers will agree with heads on the value
;; of the head feature CARDINAL -- this allows propagation
;; of such a feature from complements, where (on the current account)
;; the CARDINAL feature gets a value from the lexicon.

;; distribution of CARDINAL:
;;   ordinal lex_entries are CARDINAL -
;;   complement_free lex_entries are CARDINAL +
;;   all lex_entries for "one" are CARDINAL +
;;   other lex_entries are unspecified for CARDINAL
;; Since (the HEAD feature of) the determiner "one" is outside this 
;; hierarchy, it can't appear as a specifier or complement.


;; The sorts below refer only to lexical entries, so there's presumably no
;; harm in making conventions about the order of the RELs on their RELSs
;; No particular order is assumed for any phrase containing these entries.

;; It will be hard to do optional complements here and get the RELSs to
;; come out right.  Another problem with optional complementation is that
;; entries with complements must be -ORD, while their complement-taking
;; counterparts must be underspecified for ORD 
;;   (cf. "twenty" vs. "twenty one" vs. "twenty first")

;; DPF 19-aug-08 - Removed KCMP lex_synsem since the head-complement rule now
;; stamps nonlex_synsem on mother, and this was blocking "hundred fifty". 
;; Instead, use feature LEX +, and see if this is still okay.

complement_free_number := norm_num_word &
			  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

complemented_number := norm_num_word &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD [ CARDINAL #card,
                           MOD < [ LOCAL.AGR.DIV #div ] > ],
		    VAL.KCMP [ OPT -,
			       LOCAL [ CAT [ HEAD intadj & 
						[ CARDINAL #card,
                                                  MOD < [ LOCAL.AGR.DIV 
                                                                   #div ] > ],
					     VAL [ SPR *olist*,
						   COMPS < > ] ],
				       CONT.HOOK.XARG #arg & [ PNG #num ] ],
			       NONLOC.SLASH 0-dlist,
			       PUNCT.LPUNCT no_punct ] ],
	      CONT [ HOOK.XARG.PNG #num,
		     RELS.LIST < relation, 
				 #altkeyrel & [ PRED plus_rel ], ... > ] ],
      LEX +,
      LKEYS [ KEYREL.ARG1 #arg,
	      ALTKEYREL #altkeyrel ] ] ].
		   

; Non-identity stipulated for handle of SPR and handle of CONT in order to
; prevent the regular head-spec rule (non-head-compositional) from applying.
; Need head-compositional since the handle of the phrase "two hundred" must
; be the handle of the times_rel from the head "hundred" (which contains as
; arguments the other two handles).

specified_number := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < synsem &
                               [ OPT -,
                                 LOCAL [ CAT [ HEAD intadj & 
                                                    [ CARDINAL + ],
                                               VAL [ COMPS < >,
                                                     SPR *olist*,
                                                     SPCMPS < > ] ] ] ] > ].
				 
; DPF 01-Feb-03 - Removed the degree specifier, since we don't want to parse
; "*the exactly five chairs arrived".  We'll ignore "the nearly fifty people".
; DPF 10-dec-03 - Made SPR be < anti_synsem_min > so we can still use the 
; normal adjective-coordination rule.  
; DPF 21-sept-04 - But we also want "exactly five people arrived".  Seems to
; support the idea of ambiguous 'five': (1) an adjective which takes no 
; specifier and which always co-occurs with a determiner; and (2) a 
; determiner which can have a degree specifier.  Already have this ambiguity
; for 'one' (necessarily, to get "one chair arrived"), but degree sprs give
; reason to do it consistently for cardinals.  Note that only the cardinals
; would have the determiner entry; ordinals are only adjectives, and don't
; occur with degree specifiers.  So added num_det syntactic rule, and removed
; the idiosyncratic lexical type (and entries) for determiner "one".
; DPF 22-sept-04 - Removed SPEC < anti_synsem_min > which was preventing
; "(exactly) two of the chairs arrived"

unspecified_num := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < anti_synsem_min > ].

; DPF 17-jun-07 - Removed SPEC..COMPS < > since this blocks e.g 'ten more
; cats than dogs', and can't remember why it was here.

unspecified_num_without_complements := complement_free_number & 
                                       unspecified_num &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN const_rel,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! const_relation & [ LBL #ltop ] !> ] ] ].

approx_unspecified_num_without_complements := complement_free_number & 
                                              unspecified_num &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
                           VAL.SPEC < anti_synsem_min > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! const_relation & [ LBL #ltop ],
				    #altkeyrel &
                                    [ PRED approx_grad_rel,
                                      ARG1 #arg0 ]  !> ] ],
             LKEYS [ KEYREL.ARG0 #arg0,
		     ALTKEYREL #altkeyrel ] ] ].

unspecified_num_with_complements := complemented_number & unspecified_num &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
                         VAL.KCMP [ --MIN integer_rel,
                                    LOCAL.CONT.HOOK [ LTOP #chandle,
				                      XARG #arg ]  ] ],
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! const_relation &
                                  [ LBL #khandle ],
                                  [ LBL #ltop,
                                    ARG1 #arg,
                                    ARG2 handle & #khandle,
                                    ARG3 handle & #chandle] !> ] ] ].

specified_num_without_complements := complement_free_number & 
                                     specified_number &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
			   VAL [ SPR < [ LOCAL.CONT.HOOK [ LTOP #shandle,
                                                         XARG #arg ] ] >,
				 SPEC < [ LOCAL.CAT.VAL.COMPS < > ] > ] ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! const_relation & 
                                  [ LBL #khandle ],
				  #altkeyrel &
                                  [ LBL #ltop,
                                    PRED times_rel,
                                    ARG1 #arg,
                                    ARG2 handle & #shandle,
                                    ARG3 handle & #khandle ] !> ] ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

specified_num_with_complements := complemented_number & specified_number & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
			   VAL [ SPR < [ LOCAL.CONT.HOOK [ LTOP #shandle,
                                                         XARG #arg ] ] >,
				 SPEC < [ LOCAL.CAT.VAL.COMPS < > ] >,
				 KCMP #kcmp,
				 COMPS < #kcmp &
                                       [ LOCAL.CONT.HOOK [ LTOP #chandle,
                                                           XARG #arg ] ] > ] ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! [ LBL #khandle ],
                                [ LBL #ltop,
                                  ARG1 #arg,
                                  ARG2 handle & #thandle,
                                  ARG3 handle & #chandle ],
				#alt2keyrel &
                                [ LBL #thandle,
                                  PRED times_rel,
                                  ARG1 #arg,
                                  ARG2 handle & #shandle,
                                  ARG3 handle & #khandle ] !> ] ],
	     LKEYS.ALT2KEYREL #alt2keyrel ] ].

basic_adj_bare_unspecified_card_lexent := card_only_word & 
                                          unspecified_num_without_complements &
  [ SYNSEM.LKEYS.KEYREL.PRED card_rel ].

adj_bare_unspecified_card_lexent := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM.MODIFD.LPERIPH na ].

adj_bare_unspecified_card_wcomps_lexent := card_only_word & 
                                           unspecified_num_with_complements &
  [ SYNSEM [ LOCAL.CAT.VAL [ KCMP #kcmp,
			     COMPS < #kcmp &
                                   [ LOCAL [ CAT.HEAD fractadj,
                                             CONJ num-conj ] ] > ],
	     LKEYS.KEYREL.PRED card_rel ] ].

; DPF 12-aug-07 - Add variants to enable named numbers in compounds, as in
; "the 280 freeway", while still blocking spurious parse for "the five cats"

; <type val="aj_-_i-crd-one_le">
; <description>Adj, card, 1 digit, no cmp       
; <ex>Eight cats ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-one_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj1,
	     PHON.DIGIT - ] ].
; <type val="aj_-_i-crd-two_le">
; <description>Adj, card, 2 digit, no cmp       
; <ex>Thirty cats ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-two_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj2,
	     PHON.DIGIT - ] ].
; <type val="aj_-_i-crd-thr_le">
; <description>Adj, card, 3 digit, no cmp       
; <ex>1000 cats ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-thr_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj3,
	     PHON.DIGIT - ] ].

; <type val="aj_-_i-dig-one_le">
; <description>Adj, digit, 1 digit, no cmp      
; <ex>6 is even.
; <nex>
; <todo>
; </type>
aj_-_i-dig-one_le := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj1,
             MODIFD.LPERIPH + ] ].
; <type val="aj_-_i-dig-two_le">
; <description>Adj, digit, 2 digit, no cmp      
; <ex>16 is even.
; <nex>
; <todo>
; </type>
aj_-_i-dig-two_le := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj2,
             MODIFD.LPERIPH + ] ].
; <type val="aj_-_i-dig-thr_le">
; <description>Adj, digit, 3+ digit, no cmp     
; <ex>1000 is even. 
; <nex>
; <todo>
; </type>
aj_-_i-dig-thr_le := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj3,
             MODIFD.LPERIPH + ] ].

; <type val="aj_np_i-crd-one_le">
; <description>Adj, card, 1 dig, comp           
; <ex>Two and a half teams ran.
; <nex>
; <todo>
; </type>
aj_np_i-crd-one_le := adj_bare_unspecified_card_wcomps_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].

adj_bare_specified_card_lexent := card_only_word & 
                                  specified_num_without_complements &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC *anti_list*,
             MODIFD.LPERIPH na,
	     LKEYS.KEYREL.PRED card_rel ] ].

; <type val="aj_-_i-crd-hnd_le">
; <description>Adj, card, only 'hundred'        
; <ex>Two hundred cats ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-hnd_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].
; <type val="aj_-_i-crd-dzn_le">
; <description>Adj, card, only 'dozen'          
; <ex>Two dozen cats ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-dzn_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj2,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].

; <type val="aj_-_i-crd-thd_le">
; <description>Adj, card, only 'thousand'       
; <ex>Two thousand cats ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-thd_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
; <type val="aj_-_i-crd-mln_le">
; <description>Adj, card, only 'million'        
; <ex>Two million cats ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-mln_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
; <type val="aj_-_i-crd-bln_le">
; <description>Adj, card, only 'billion'        
; <ex>Two billion cats ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-bln_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
; <type val="aj_-_i-crd-trln_le">
; <description>Adj, card, only 'trillion'       
; <ex>Two trillion cats ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-trln_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj15,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].

; <type val="aj_-_i-crd-apprx_le">
; <description>Adj, card, approx without num specifier
; <ex>The dozen cats we found ran.
; <nex>
; <todo>
; </type>
aj_-_i-crd-apprx_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj2 & 
			    [ PRD -,
			      MOD < expressed_synsem &
				    [ LOCAL.CAT.VAL.SPR 
					< [ --MIN def_q_rel ] > ] >,
			      MINORS.ALTMIN no_rel ],
		       VAL.SPEC *anti_list*,
		       POSTHD - ] ].

aj_np_i-crd-nsp_lexent := card_only_word & unspecified_num_with_complements &
  [ SYNSEM [ LOCAL.CAT [ HEAD intadj2,
                         VAL [ KCMP #kcmp,
			       COMPS < #kcmp & 
                                     [ LOCAL [ CAT.HEAD intadj &
						    [ MINORS.ALTMIN norm_rel ],
                                               CONJ cnil ] ] > ] ],
	     LKEYS.KEYREL.PRED card_rel ] ].

; <type val="aj_np_i-crd-nsp_le">
; <description>Adj, crd, 2 dg, comp,no sp       
; <ex>Thirty-two cats ran.
; <nex>
; <todo>
; </type>
aj_np_i-crd-nsp_le := aj_np_i-crd-nsp_lexent.


adj_complemented_specified_card_lexent := norm_card_word & 
                                          specified_num_with_complements &
  [ SYNSEM.LKEYS.KEYREL.PRED card_rel ].

; <type val="aj_np_i-crd-hnd_le">
; <description>Adj, card, only 'hundred'        
; <ex>Two hundred ten cats ran.
; <nex>
; <todo>
; </type>
aj_np_i-crd-hnd_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj2-,
                             COMPS.FIRST [ LOCAL.CAT.HEAD intadj2-,
                                           MODIFD.LPERIPH na ] ] ] ].
; <type val="aj_np_i-crd-thd_le">
; <description>Adj, card, only 'thousnd'        
; <ex>Two thousand ten cats ran.
; <nex>
; <todo>
; </type>
aj_np_i-crd-thd_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj3- ] ] ].
; <type val="aj_np_i-crd-mln_le">
; <description>Adj, card, only 'million'        
; <ex>Two million ten cats ran.
; <nex>
; <todo>
; </type>
aj_np_i-crd-mln_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj6- ] ] ].
; <type val="aj_np_i-crd-bln_le">
; <description>Adj, card, only 'billion'        
; <ex>Two billion ten cats ran.
; <nex>
; <todo>
; </type>
aj_np_i-crd-bln_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj9- ] ] ].

; <type val="aj_np_i-crd-trln_le">
; <description>Adj, card, only 'trilln'         
; <ex>Two trillion ten cats ran.
; <nex>
; <todo>
; </type>
aj_np_i-crd-trln_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj15,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj12- ] ] ].

; <type val="aj_-_i-crd-unk_le">
; <description>Adj, card, 2 dig - unknown       
; <ex>B has unknown-card cats.
; <nex>
; <todo>
; <native> aj_-_i-crd-two_le
; </type>
aj_-_i-crd-unk_le := basic_adj_bare_unspecified_card_lexent & basic_unknown_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL [ LBL #ltop,
			    CARG #carg ],
	     MODIFD.LPERIPH na ],
    TOKENS.+LIST < [ +CARG #carg ] > ].

; <type val="aj_-_i-crd-gen_le">
; <description>Adj, card, 2 dig - generic       
; <ex>B has generic-card cats.
; <nex>
; <todo>
; <native> aj_-_i-crd-two_le
; </type>
aj_-_i-crd-gen_le := basic_adj_bare_unspecified_card_lexent & 
		     generic_ne_lex_entry &
  [ SYNSEM [ MODIFD.LPERIPH na,
	     LKEYS.KEYREL.PRED card_rel ] ].

; <type val="aj_np_i-crd-gen_le">
; <description>Adj, crd, 2 dg, np comp,no sp       
; <ex>Thirty-two cats ran.
; <nex>
; <todo>
; <native> aj_np_i-crd-nsp_le
; </type>
aj_np_i-crd-gen_le := aj_np_i-crd-nsp_lexent & 
		     generic_ne_lex_entry &
  [ SYNSEM [ MODIFD.LPERIPH na,
	     LKEYS.KEYREL.PRED card_rel ] ].

; <type val="aj_-_i-two-gen_le">
; <description>Adj, card, 2 dig - generic       
; <ex>B has generic-card cats.
; <nex>
; <todo>
; </type>
aj_-_i-two-gen_le := adj_bare_unspecified_card_lexent & generic_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].

basic_adj_bare_unspecified_ord_lexent := ord_word & 
					 unspecified_num_without_complements.
adj_bare_unspecified_ord_lexent := basic_adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED ord_rel ].

; <type val="aj_-_i-ord-one_le">
; <description>Adj, ord, 1 digit, no comp       
; <ex>The ninth cat won.
; <nex>
; <todo>
; </type>
aj_-_i-ord-one_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].

; <type val="aj_-_i-ord-two_le">
; <description>Adj, ord, 2 digit, no comp       
; <ex>The thirtieth cat won.
; <nex>
; <todo>
; </type>
aj_-_i-ord-two_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].

adj_bare_specified_ord_lexent := ord_word & specified_num_without_complements &
  [ SYNSEM.LKEYS.KEYREL.PRED ord_rel ].

; <type val="aj_-_i-ord-hnd_le">
; <description>Adj, ord, only 'hundredth'       
; <ex>The hundredth cat won.
; <nex>
; <todo>
; </type>
aj_-_i-ord-hnd_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
; <type val="aj_-_i-ord-thd_le">
; <description>Adj, ord, only 'thousandth'      
; <ex>The thousandth cat won.
; <nex>
; <todo>
; </type>
aj_-_i-ord-thd_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
; <type val="aj_-_i-ord-mln_le">
; <description>Adj, ord, only 'millionth'       
; <ex>The millionth cat won.
; <nex>
; <todo>
; </type>
aj_-_i-ord-mln_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj6- ] ].

; <type val="aj_-_i-ord-unk_le">
; <description>Adj, ord, 1 digit, unknown       
; <ex>The unknown-ordth cat won.
; <nex>
; <todo>
; </type>
aj_-_i-ord-unk_le := basic_adj_bare_unspecified_ord_lexent & basic_unknown_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

; <type val="aj_-_i-ord-gen_le">
; <description>Adj, ord, 1 digit, generic       
; <ex>The generic-ordth cat won.
; <nex>
; <todo>
; <native> aj_-_i-ord-two_le
; </type>
aj_-_i-ord-gen_le := adj_bare_unspecified_ord_lexent & generic_ne_lex_entry.

; <type val="aj_-_i-crd-app_le">
; <description>Adj, card, approx, 2 dig         
; <ex>B has thirtyish cats.
; <nex>
; <todo>
; </type>
aj_-_i-crd-app_le := card_only_word & 
                     approx_unspecified_num_without_complements &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj2,
             MODIFD.LPERIPH na,
	     LKEYS.KEYREL.PRED card_rel ] ].

;; the constraints appropriate for all lexical entries for "one"
;; DPF 2-Feb-01 - Removed [ SPEC..OPT - ], since blocked "the one year old boy"
;; and it's not clear what it was for.
;; DPF 17-Nov-01 - Added LPERIPH na like with other numbers.  Don't know why
;; a_one_sing and a_one_plur were marked [LPERIPH -], but need LPERIPH + to 
;; block application of nominal modifier rules to measure_nps including 
;; "an inch"
;; DPF 25-Jun-03 - Tried making this [DIV -] to block "*one tobacco 
;; arrived" but this is the same "one" used in "one dozen chairs arrived".
;; Would want something fancier, where [DIV +] implied plural number,
;; to just exclude mass nouns.
;; DPF 17-may-09 - Moved RELS.ARG1 [ DIV -] to AGR, to enable coord as in
;; "one or two cats arrived"

basic_one_num_synsem := anycard_norm_num_synsem & zero_arg &
  [ LOCAL [ CAT [ HEAD intadj & 
                       [ CARDINAL +,
                         MINORS.MIN card_rel,
			 MOD < [ LOCAL 
				 [ CAT basic_nbar_cat &
				  [ HEAD noun_or_nomger_or_nadj &
					 [ MINORS.MIN nonpro_rel ],
				    VAL.SPR < synsem & 
					     [ --MIN quant_or_deg_rel], ... >],
				   AGR.DIV - ] ] > ],
		  VAL [ SPR < anti_synsem_min >,
                        SPEC < [ LOCAL.CAT.VAL.COMPS #comps ] >,
                        SPCMPS #comps ] ],
            CONT [ HOOK [ INDEX #arg0,
                          XARG #index ],
                   RELS.LIST.FIRST #keyrel &
                             [ PRED card_rel,
                               ARG0 #arg0,
                               ARG1 #index ] ] ],
    LKEYS.KEYREL #keyrel,
    PUNCT [ LPUNCT no_punct,
            RPUNCT no_punct,
            PNCTPR ppair ] ].

one_num_synsem := basic_one_num_synsem &
  [ LKEYS.KEYREL.CARG "1" ].

;; DPF 2012-08-29 - Added missing OPT - on complement, presumably intended.
;;
one_num_fract_synsem := one_num_synsem & 
  [ LOCAL [ CAT [ HEAD.PRD -,
                  VAL.COMPS < canonical_synsem &
			      [ --MIN fraction_rel & #min,
                                LOCAL [ CAT [ HEAD fractadj,
                                              VAL.COMPS < > ],
                                        CONT.HOOK [ LTOP #fhand,
                                                    XARG #ind ] ],
				OPT -,
                                PUNCT.LPUNCT no_punct ] > ],
            CONT [ HOOK.LTOP #hand,
                   RELS <! [ LBL #chand ],
			 #altkeyrel &
                         [ LBL #hand,
                           PRED plus_rel,
                           ARG1 #ind,
                           ARG2 handle & #chand,
                           ARG3 handle & #fhand ] !> ] ],
    MODIFD.LPERIPH +,
    LKEYS [ ALTKEYREL #altkeyrel,
	    --+COMPKEY #min ] ].

one_word := word &
  [ INFLECTD +,
    SYNSEM one_num_synsem & 
           [ MODIFD.LPERIPH + ] ].

; DPF 29-May-02 - Made adj_one_lexent be HEAD intadj1 not intadj, to
; avoid "let's meet at five one" meaning "five oh one"
; DPF 13-May-03 - Managed to get by with just one entry for adj "one", even
; though we need "forty one chairs" to sustain plural number on the semantic
; index for "one", by making the 3s constraint on the AGR of the modified
; noun, so when "one" is directly a modifier, it will only modify 3s nouns.
; (This simplification also required modifying the part-num rule to unify the
; daughter's MOD..AGR value with the dtr's own AGR.
; DPF 31-May-02 - Added PRD stipulation to distinguish "one" from "a/an" for
; e.g. partitive-num and num-noun rules.
; DPF 30-sept-06 - Removed MOD..INDEX.PNG.PN 3s since this prevents making
; "one hundred" since "hundred" modifies plural noun.

; <type val="aj_-_i-one_le">
; <description>Adj, card, only 'one', mod       
; <ex>One cat ran.
; <nex>
; <todo>
; </type>
aj_-_i-one_lexent := one_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD intadj1 &
                            [ PRD -,
                              MOD < [ --MIN nonpro_rel,
                                      LOCAL intersective_mod &
                                            [ CAT nbar_cat_min,
                                              CONT.HOOK [ LTOP #ltop,
                                                          INDEX #index ],
                                              CONJ cnil,
                                              AGR.PNG.PN 3s ],
                                      MODIFD.LPERIPH na_or_- ] > ],
                           VAL.COMPS < > ],
		     CONJ cnil,
                     CONT [ HOOK [ LTOP #ltop,
                                   XARG #index ],
                            RELS <! relation !> ] ],
             LKEYS.KEYREL.LBL #ltop ] ].

aj_-_i-one_le := aj_-_i-one_lexent &
  [ SYNSEM.PHON.DIGIT - ].

aj_-_i-one-d_le := aj_-_i-one_lexent.

; <type val="aj_np_i-frct-one_le">
; <description>First half of fraction w/'one'   
; <ex>Two and one third eggs are
; <nex>
; <todo>
; </type>
aj_np_i-frct-one_le := one_word &
  [ SYNSEM one_num_fract_synsem &
           [ LOCAL [ CAT [ HEAD intadj1 & 
                                [ MOD < [ --MIN nonpro_rel,
                                          LOCAL intersective_mod &
                                                [ CAT nbar_cat_min,
                                                  CONT.HOOK [ LTOP #ltop,
                                                              INDEX #index ],
                                                  CONJ cnil,
                                                  AGR.PNG.PN 3s ],
                                          MODIFD.LPERIPH - ] > ],
                           VAL.COMPS < lex_synsem >,
                           HC-LEX + ],
                     CONT.HOOK [ LTOP #ltop,
                                 XARG #index ] ] ] ].

; 'a/an' of 'the string is an inch long'
; DPF 21-May-03 - Even though these are PRD + to keep them out of partitives
; and num-nouns, we still don't want them showing up as predicative complements
; and so we make them MOD anti_synsem_min, so they are incompatible with 
; prd_cat.
; DPF 5-jul-04 - While these are MOD < anti_synsem_min >, we still want to 
; prevent them from combining with plural nouns in measure-NP constructions 
; which are indifferent to PRD value, namely as complements of PPs - e.g. to 
; block *Kim arrives in a weeks".  So add AGR constraint to MOD value, which 
; the measure-NP rule already enforces.
; DPF 28-aug-04 - Since no longer using PRD to distinguish types of NPs (see
; note by nomp_cat), constrain these to combine with lexically marked 
; measure-nouns to keep an artificial lid on spurious ambiguity.  So
; allowing "an inch is enough" with MNP, but not "an engineer is enough".
; DPF 12-oct-05 - These were PRD + (see 21-May-03), but this meant we were
; parsing "*Kim found it a" analogous to "Kim found it pleasant".  So instead,
; make these [PRD -] and constrain the rules for partitives and num-dets to 
; exclude anti_synsem MOD values. (The num-noun rule is already blocking due 
; to the ALTMIN value.)
; DPF 26-apr-08 - Re 21-may-03: removed MOD < anti_synsem_min ... > because 
; the num-n_mnp_c rule requires MOD < synsem >.  These no longer undergo
; hdn_np-num_c rule because of ALTMIN no_rel.  
; DPF 27-apr-08 Added MODIFD hasmod to prevent these from undergoing 
; partitive_num rule.

adj_one_an_lexent := word &
  [ INFLECTD +,
    SYNSEM one_num_synsem & 
           [ LOCAL.CAT.HEAD intadj1 &
                                [ MOD < [ --MIN abstr_meas_nom_rel,
                                          LOCAL intersective_mod &
						[ CAT.HEAD noun,
						  AGR.PNG.PN 3s ] ] >,
                                  MINORS.ALTMIN no_rel ],
	     MODIFD hasmod ] ].

; DPF 27-apr-08 - Tried adding MODIFD lmod but this also blocks "a hundred", 
; which we want. So instead, constrain num_det rule

adj_one_prd_lexent := adj_one_an_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.PRD -,
			   VAL.COMPS < > ],
		     CONT [ HOOK.LTOP #ltop,
                            RELS <! [ LBL #ltop ] !> ] ],
             MODIFD.LPERIPH na ] ].

; <type val="aj_-_i-one-nmd_le">
; <description>Adj, only 'one' cannot modify    
; <ex>The cat weighs a kilo.
; <nex>
; <todo>
; </type>
aj_-_i-one-nmd_le := adj_one_prd_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PHON.ONSET con_or_unk ] >,
		       VAL.SPEC < [ PHON.ONSET con_or_unk ] > ] ].

; <type val="aj_-_i-an-nmd_le">
; <description>Adj, only card 'an', no modif    
; <ex>The cat weighs an ounce.
; <nex>
; <todo>
; </type>
aj_-_i-an-nmd_le := adj_one_prd_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PHON.ONSET voc_or_unk ] >,
		       VAL.SPEC < [ PHON.ONSET voc_or_unk ] > ] ].

; <type val="aj_-_i-subone-gen_le">
; <description>Adj, generic sub-one fract or decimal, singular agreement
; <ex>The cat weighs 0.3 ounce.
; <nex>
; <todo>
; <native> aj_-_i-one-nmd_le
; </type>
aj_-_i-one-gen_le := adj_one_prd_lexent & basic_unknown_word.

; For 'several thousand' 'a few dozen'
; DPF 3-May-08 - Add MOD..NORM norm_rel to block "a few cat" from being
; left member of n-n-cmpnd.

aj_-_i-num_lexent := word &
  [ SYNSEM basic_one_num_synsem &
           [ LOCAL [ CAT [ HEAD intadj1 &
                                [ PRD -,
                                  MOD < anti_synsem_min & 
                                        [ --MIN abstr_meas_nom_rel,
                                          LOCAL [ CAT.HEAD.MINORS.NORM norm_rel,
						  AGR.PNG.PN 3s ] ] > ],
                           VAL.COMPS < > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! [ LBL #ltop ] !> ] ] ] ].

; <type val="aj_-_i-num_le">
; <description>Adj, only 'several/a few'        
; <ex>Cats weigh several kilos.
; <nex>
; <todo>
; </type>
aj_-_i-num_le := aj_-_i-num_lexent &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN no_rel ].
    
; <type val="aj_-_i-num_le">
; <description>Adj, only 'plus', `minus'        
; <ex>Cats weigh five-plus kilos.
; <nex>
; <todo>
; </type>
aj_-_i-num-plus_le := aj_-_i-num_lexent &
  [ INFLECTD + ].

; <type val="aj_-_i-num-nifl_le">
; <description>Adj, non-inflected, only 'a couple of'        
; <ex>Cows weigh a couple of hundred kilos.
; <nex>
; <todo>
; </type>
aj_-_i-num-nifl_le := aj_-_i-num_lexent &
  [ INFLECTD -,
    SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN no_rel ].

; 'a/an' of 'a meter and a half of snow'
; DPF 10-dec-03 - The 'and a half' synsem cannot be represented as a COMP
; since it can't be discharged until after 'a/an' has combined with the noun
; using the measure-NP rule, unlike say 'twenty' of 'twenty two foot'.  So
; this synsem is treated as a SPEC value, and is propagated by the MNP rule
; onto the COMPS list of the phrase.
; [HC-LEX -] prevents "*an and a half hours" since MNP rule requires left dtr
; to be LEX +, so get "one and a half hours".
; DPF 05-may-05 - Re 10-dec-03: corrected, and now put the complement on COMPS.

adj_one_fract_lexent := adj_one_an_lexent &
  [ SYNSEM one_num_fract_synsem &
           [ LOCAL.CAT [ VAL.COMPS < phr_synsem >,
                         HC-LEX - ],
             MODIFD.LPERIPH + ] ].

; <type val="aj_np_i-frct-a_le">
; <description>Cardinal adj combining with con-N and then fraction
; <ex>A day and a half
; <nex>
; <todo>
; </type>
aj_np_i-frct-a_le := adj_one_fract_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET con_or_unk ] > ].

; <type val="aj_np_i-frct-an_le">
; <description>Cardinal adj combining with voc-N and then fraction
; <ex>An hour and a half
; <nex>
; <todo>
; </type>
aj_np_i-frct-an_le := adj_one_fract_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET voc_or_unk ] > ].

;; DPF 2012-08-29 - This type is wrongly conceived: this lexical entry is
;; the prenominal modifier which also selects for the conj-marked fraction
;; NP following the noun.  Curretnly we treat the |a third| in |two and a third|
;; as non-decomposed, so more work will be needed to get the variant with
;; |two and another third|.  FIX later.
#|
; <type val="aj_np_i-frct-ath_le">
; <description>Fraction with 'another'          
; <ex>Two and another third are.
; <nex>
; <todo>
; </type>
aj_np_i-frct-ath_le := adj_one_fract_lexent.
|#

; 'a half'
fraction_num_synsem := anycard_norm_num_synsem & abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD fractadj & 
                       [ CARDINAL +,
                         MINORS.MIN fraction_rel ],
                  VAL [ SPR < >,
                        COMPS < >,
                        SPEC < [ LOCAL.CAT.VAl.COMPS #comps ] >,
			SPCMPS #comps & < > ] ],
            CONT [ HOOK [ LTOP #lbl,
                          XARG #index ],
                   RELS <! #keyrel &
                         [ PRED fraction_rel,
                           LBL #lbl,
                           ARG1 #index ] !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL #keyrel,
    MODIFD.LPERIPH na ].

fraction_word := word &
  [ INFLECTD +,
    SYNSEM fraction_num_synsem &
           [ PUNCT no_punctuation_min ] ].

; <type val="aj_-_i-frct_le">
; <description>Adj, fraction                    
; <ex>Two and a half arrived.
; <nex>
; <todo>
; </type>
aj_-_i-frct_le := fraction_word.

; <type val="aj_-_i-frct-gen_le">
; <description>Adj, fraction - generic          
; <ex>Two and generic-f arrived.
; <nex>
; <todo>
; <native> aj_-_i-frct_le
; </type>
aj_-_i-frct-gen_le := fraction_word & generic_ne_lex_entry.

; Types for unknown and generic words
basic_generic_lex_entry := word &
  [ SYNSEM.PHON.ONSET unk_onset ].

; For form-derived generics like an email address
generic_lex_entry := basic_generic_lex_entry &
  [ TOKENS.+LIST < [ +TNT null_tnt ] > ].

generic_ne_lex_entry := generic_lex_entry &
  [ SYNSEM.LKEYS.KEYREL.CARG #carg,
    TOKENS.+LIST < [ +CARG #carg ] > ].

; For POS-tag-derived generics like unknown proper names
basic_unknown_word := basic_generic_lex_entry & nonconj & mcna.

norm_unknown_word := basic_unknown_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL [ LBL #ltop,
			    PRED #pred ] ],
    TOKENS.+LIST.FIRST.+PRED #pred ].

unknown_word := norm_unknown_word &
  [ INFLECTD + ].

generic_v_np*_trans_lex_entry := unknown_word & basic_main_verb &
  [ SYNSEM np_trans_verb &
	   [ LOCAL [ CAT [ VAL.COMPS < [ OPT + ] > ],
		     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel & [ PRED string ] ] ].

; <type val="v_np*_unk_le">
; <description>
; <ex>
; <nex>
; <todo>
; <native> v_np*_le
; </type>
v_np*_unk_le := basic_main_verb & norm_unknown_word &
  [ INFLECTD -,
    SYNSEM np_trans_verb &
	   [ LOCAL [ CAT [ VAL.COMPS < [ OPT + ] > ],
		     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel & [ PRED  "generic_v_rel" ] ] ].

; <type val="v_np*_bse-unk_le">
; <description>Cmps NP(opt), generic unk, bse   
; <ex>B can unk-verb.
; <nex>
; <todo>
; <native> v_n3s-bse_ilr & [ SYNSEM.LOCAL bse_verb ] v_np*_le
; </type>
v_np*_bse-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL bse_verb ].

; <type val="v_np*_pr-3s-unk_le">
; <description>Cmps NP(opt), generic unk, 3sing 
; <ex>B unk-verbs.
; <nex>
; <todo>
; <native> v_3s-fin_olr v_np*_le
; </type>
v_np*_pr-3s-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL third_sg_fin_verb ].

; <type val="v_np*_pr-n3s-unk_le">
; <description>Cmps NP(opt), generic unk, non3s 
; <ex>We unk-verb.
; <nex>
; <todo>
; <native>v_n3s-bse_ilr & [ SYNSEM.LOCAL non_third_sg_fin_verb ] v_np*_le
; </type>
v_np*_pr-n3s-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL non_third_sg_fin_verb ].

; <type val="v_np*_pa-unk_le">
; <description>Cmps NP(opt), generic unk, past  
; <ex>We unk-verbed.
; <nex>
; <todo>
; <native> v_pst_olr v_np*_le
; </type>
v_np*_pa-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL past_or_subj_verb ].

; <type val="v_np*_psp-unk_le">
; <description>Cmps NP(opt), generic unk, psp   
; <ex>We have unk-verbed.
; <nex>
; <todo>
; <native> v_psp_olr v_np*_le
; </type>
v_np*_psp-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL psp_verb ].

; <type val="v_np*_prp-unk_le">
; <description>Cmps NP(opt), generic unk, prp   
; <ex>We are unk-verbing.
; <nex>
; <todo>
; <native> v_prp_olr v_np*_le
; </type>
v_np*_prp-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL prp_verb ].

; <type val="v_-_pas-unk_le">
; <description>No cmps, psv - unknown           
; <ex>B was generic-verbed.
; <nex>
; <todo>
; <native> v_-_psv_le
; </type>
v_-_pas-unk_le := unknown_word & basic_main_verb_sans_key & 
  [ SYNSEM passive_unerg_synsem &
           [ LOCAL [ CAT [ HEAD [ MINORS.MIN nonaux_event_rel ],
			   MC na ],
		     CONT.HOOK.LTOP #ltop ],
	     LKEYS.KEYREL [ LBL #ltop,
			    PRED string ] ] ].

; DPF 15-may-08 - Don't identify AGR with HOOK.INDEX, since we want uninflctd
; mass-or-count to be modifiable by plural adjectives, as in "six glump house"
;

generic_n_intr_lex_entry := basic_unknown_word &
  [ SYNSEM unsp_common_noun_synsem &
	   [ LOCAL [ CAT [ HEAD noun & [ MINORS.MIN norm_nom_rel ],
                           VAL.SPR < [ --MIN quant_or_wh_rel ] > ],
                     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel & [ PRED string ] ,
	     MODIFD notmod ] ].

; <type val="n_-_c-sg-unk_le">
; <description>Icn for unknown sing.nouns       
; <ex>B bought an unk-noun.
; <nex>
; <todo>
; </type>
n_-_c-sg-unk_le := generic_n_intr_lex_entry & unknown_word &
  [ SYNSEM noun_nocomp_synsem & [ LOCAL sing_noun ] ].

; <type val="n_-_c-sg-gen_le">
; <description>Icn for generic sing.nouns       
; <ex>B bought a generic-noun.
; <nex>
; <todo>
; </type>
n_-_c-sg-gen_le := generic_n_intr_lex_entry & generic_lex_entry &
  [ SYNSEM noun_nocomp_synsem & [ LOCAL sing_noun ] ].

; <type val="n_-_m-unk_le">
; <description>Mass, unknown                    
; <ex>B won noununk.
; <nex>
; <todo>
; </type>
n_-_m-unk_le := generic_n_intr_lex_entry & unknown_word &
  [ SYNSEM mass_noun_synsem & [ LOCAL mass_noun ] ].

; DPF 12-may-08 - Let's try restricting this to singular, letting the
; tagger predict plural nouns separately

n_-_mc-unk_lexent := generic_n_intr_lex_entry &
  [ INFLECTD -,
    SYNSEM basic_mass_or_count_nocomp_synsem & 
           [ LOCAL noun_local &
		   [ CAT [ HEAD.--BARE -,
			   VAL.SPR < [ LOCAL.AGR.PNG.PN 3s ] > ],
                     CONT.HOOK.LTOP #ltop,
		     AGR.PNG.PN 3s ],
             LKEYS.KEYREL.LBL #ltop,
	     PHON.ONSET unk_onset ] ].

; <type val="n_-_mc-unk_le">
; <description>Mass-count, unknown              
; <ex>B won the noununk.
; <nex>
; <todo>
; <native> n_-_mc_le
; </type>
n_-_mc-unk_le := n_-_mc-unk_lexent & norm_unknown_word.

; <type val="n_-_c-pl-unk_le">
; <description>Icn, unknown plur                
; <ex>B won noununks.
; <nex>
; <todo>
; <native> n_pl_olr n_-_mc_le
; </type>
n_-_c-pl-unk_le := generic_n_intr_lex_entry & unknown_word &
  [ SYNSEM mass_or_count_nocomp_synsem & 
           [ LOCAL plur_noun ] ].

; <type val="n_-_c-pl-gen_le">
; <description>Icn, generic plur used for |'70s|, |1800s|
; <ex>Kim arrived in the 1800s.
; <nex>
; <todo>
; <native> n_pl_olr n_-_mc_le
; </type>
n_-_c-pl-gen_le := generic_ne_lex_entry &
  [ INFLECTD +,
    SYNSEM mass_or_count_nocomp_synsem & 
	   [ LOCAL plur_noun &
		   [ CAT [ HEAD noun & [ MINORS.MIN norm_nom_rel ],
                           VAL.SPR < [ --MIN quant_or_wh_rel ] > ],
                     CONT [ HOOK [ LTOP #lbl,
				   INDEX #arg0 ],
			    RELS <! #keyrel !> ] ],
             LKEYS.KEYREL #keyrel & named_nom_relation &
		                    [ PRED year_range_rel,
				      LBL #lbl,
				      ARG0 #arg0 ],
	     PUNCT no_punctuation_min,
             MODIFD notmod ] ].

; Inflected noun, unmarked for number or div, used for 'ersatz' nouns like
; OSCARCOMPOUND
n_-_mc-ifl_le := nonc-hm & basic_noun_word &
  [ INFLECTD +,
    SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT [ RELS <! relation !>,
                            HCONS <! !> ] ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; DPF 12-sept-07 - Restrict these to attributives, since the predicatives
; give rise to too much ambiguity (esp. with depictives and robust-np-sg).
; DPF 11-may-08 - But we need these in predicative position as well, so
; block from depictives via MINORS.NORM
; DPF 24-mar-09 - Don't know why SPR was anti_synsem, but this blocked any
; degree specifiers, including 'very' and 'most'.
; DPF 24-apr-09 - Re 11-may-08: But this blocks adjectives in n_vora_cmpnds,
; sigh, so instead constrain to POSTHD -, still blocking unknown adj 
; depictives, but allowing n-nh_vorj-cpd_c.
; DPF 30-apr-09 - But then unknown adjs can't be the complement of "be".
; So let's just try letting them be depictives, since it's not easy to block. 
; DPF 07-jun-09 - Can't remember what trick motivated the COMPS <anti_synsem>,
; but it does not play well with aj-hdn_adjn_c, since that complement gets 
; passed up from adj to mother.  Let's drop it and see what we lose ...
;; DPF 2011-10-22 - Added MODIFD notmod to avoid spurious application of
;; partitive_intadj rule.
;
; <type val="aj_-_i-unk_le">
; <description>Adj, unknown positive            
; <ex>The adjunk dog ran.
; <nex>
; <todo>
; <native> aj_-_i_le
; </type>
aj_-_i-unk_le := unknown_word &
  [ SYNSEM adj_onearg_lex_synsem &
           [ LOCAL [ CAT [ HEAD adj & 
			      [ MOD < synsem_min &
				      [ LOCAL 
					[ CAT 
					  [ HEAD basic_nom_or_ttl &
						 [ POSS - ],
					    VAL [ SUBJ < >,
						  SPR.FIRST synsem & 
						    [ --MIN quant_or_deg_rel ],
						  COMPS < > ],
					    MC na ],
					  CONJ cnil ],
					--SIND #ind ] >,
				MINORS.MIN abstr_adj_rel ],
			   VAL [ SPR.FIRST synsem & 
					   [ --MIN more_or_very_deg_rel ],
				 COMPS < > ] ],
		     CONT [ HOOK.XARG #ind,
                            RELS <! #keyrel !> ] ],
             LKEYS.KEYREL #keyrel & [ PRED string,
				      ARG1 #ind ],
	     MODIFD notmod,
	     NONLOC non-local_none ] ].

; <type val="aj_-_i-cmp-unk_le">
; <description>Adj, unknown comparative         
; <ex>The compadjunk dog ran.
; <nex>
; <todo>
; <native> aj_pp_i-cmp_le & [ SYNSEM.LOCAL.CAT.VAL.COMPS < unexpressed > ]
; </type>
aj_-_i-cmp-unk_le := unknown_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind ] >,
                                  MINORS.ALTMIN comp_rel ],
                           VAL [ SPR.FIRST.--MIN much_deg_rel,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
				      PRED string,
                                      ARG1 #ind ],
                                  #altkeyrel &
                                  [ LBL #hand,
                                    ARG1 #ind ] !> ] ],
             LKEYS.ALTKEYREL #altkeyrel & [ PRED comp_rel ] ] ].

;; DPF 2012-09-26 - Constrained HEAD to be superl_adj to avoid spurious ambig
;;
; <type val="aj_-_i-sup-unk_le">
; <description>Adj, unknown superlative         
; <ex>The supadjunk dog ran.
; <nex>
; <todo>
; <native> aj_-_i-sup_le
; </type>
aj_-_i-sup-unk_le := unknown_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD superl_adj &
				[ MOD < [ --SIND #ind ] >,
                                  MINORS.ALTMIN superl_rel ],
                           VAL [ SPR.FIRST.--MIN much_deg_rel,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
				      PRED string,
                                      ARG0 #arg0,
                                      ARG1 #ind ],
                                  #altkeyrel &
                                  [ LBL #hand,
                                    ARG1 #arg0 ] !> ] ],
             LKEYS.ALTKEYREL #altkeyrel & [ PRED superl_rel ] ] ].

; <type val="av_-_i-unk_le">
; <description>Adv, int, unknown                
; <ex>C arrived advunk.
; <nex>
; <todo>
; <native> av_-_i-vp_le
; </type>
av_-_i-unk_le := unknown_word & noncqrs &
  [ SYNSEM intersect_adverb_synsem & 
            [ LOCAL.CAT.HEAD adv &
			     [ MOD < [ LOCAL.CAT.HEAD v_or_g_or_a ] > ],
	      LKEYS.KEYREL.PRED string ] ].

; **FIX**

punct_word := basic_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD punct_hd & [ PRD -, MOD < >, 
                                             MINORS.MIN punct_rel ],
                           VAL [ SUBJ < >, SPR < >, SPEC < >,
                                 COMPS < expressed_synsem &
                                         [ OPT -, 
                                           LOCAL.CAT.HEAD subst_or_func ] > ]],
                     CONT [ RELS <! !>, 
			    HCONS <! !> ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
	     	      REL 0-dlist],
             LKEYS.KEYREL.PRED punct_rel ] ].

punct_right_word := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < abstr_lex_synsem & 
                                   [ NONLOC.QUE #que,
                                     PUNCT.RPUNCT pair_or_no_punct ] >,
             NONLOC.QUE #que,
             PUNCT [ LPUNCT no_punct,
                     RPUNCT punct_mark ] ] ].

; Sentence-ending dash, for informal writing
; <type val="pt_-_s-dash_le">
; <description>Punct, sentence dash             
; <ex>B arrived - C left.
; <nex>
; <todo>
; </type>
pt_-_s-dash_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT s_dash_punct ].

; Sentence-ending threedots
; <type val="pt_-_3dots-rgt_le">
; <description>Punct, three dots S-final        
; <ex>B arrived ...
; <nex>
; <todo>
; </type>
pt_-_3dots-rgt_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT 3dots_punct ].
    
; Sentence-initial threedots
; <type val="pt_-_3dots-lft_le">
; <description>Punct, three dots S-initial      
; <ex>... C left.
; <nex>
; <todo>
; </type>
pt_-_3dots-lft_le := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT 3dots_or_clause,
                                     LOCAL.CONJ cnil ] >,
             PUNCT [ LPUNCT 3dots_punct,
                     RPUNCT 3dots_or_clause_or_no_punct ] ] ].

; <type val="pt_-_dbl-hyphn_le">
; <description>Punct, double hyphen             
; <ex>B arrived -- C left.
; <nex>
; <todo>
; </type>
pt_-_dbl-hyphn_le := punct_right_word &
  [ SYNSEM.PUNCT [ RPUNCT hyphen_dbl,
                   PNCTPR no_ppair ] ].

; <type val="pt_-_hyphn-rgt_le">
; <description>Punct, single hyphen             
; <ex>B - the winner - arrived.
; <nex>
; <todo>
; </type>
pt_-_hyphn-rgt_le := punct_right_word &
  [ SYNSEM.PUNCT [ RPUNCT hyphen_sgl,
                   PNCTPR no_ppair ] ].
                                 
colon_copula_synsem_min := synsem_min.
colon_copula_synsem := norm_two_arg_subst & colon_copula_synsem_min &
  [ LOCAL [ CAT [ HEAD verb &
		       [ VFORM fin,
			 MOD < >,
			 MINORS.MIN be_v_id_rel,
			 PRD -,
			 AUX -,
			 INV -,
			 TAM #tam & [ ASPECT [ PRF -,
					       PROGR - ] ] ],
		  POSTHD -,
		  HC-LEX -,
		  VAL [ SUBJ < canonical_synsem &
			       [ --MIN nom_or_mnp_rel,
				 LOCAL [ CAT nomp_cat_min,
					 CONJ cnil ],
				 --SIND #id1ind & non_expl-ind,
				 OPT - ] >,
			SPR < anti_synsem_min >,
			COMPS < [ --MIN nom_or_mnp_rel,
				  LOCAL [ CAT nomp_cat_min & 
					      [ HEAD.MOD < >,
						VAL.SPEC *cons* ],
					  CONT.HOOK.LTOP #ltop,
					  CONJ cnil ],
				  --SIND #id2ind & non_expl-ind,
				  NONLOC non-local_none,
				  OPT - ] > ] ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #event & [ E #tam ],
			  XARG #id1ind ],
		   RELS <! #keyrel !>,
		   HCONS <! !> ],
	    CONJ cnil,
	    AGR.PNG png & [ PN 3 ] ],
    NONLOC non-local_none,
    PUNCT [ LPUNCT no_punct,
	    RPUNCT colon_punct ],
    MODIFD hasmod,
    LKEYS.KEYREL #keyrel & arg12_relation &
	  [ PRED _colon_v_id_rel,
	    LBL #ltop,
	    ARG0 #event,
	    ARG1 #id1ind,
	    ARG2 #id2ind ] ].

; For colon copula with NP subject, as in "Owners: Abrams and Browne"
; <type val="v_np_colon_le">
; <description>Cmps NP(obl), only colon         
; <ex>Owners: C and D
; <nex>
; <todo>
; </type>
v_np_colon_le := mcna &
  [ INFLECTD +,
    ALTS.ADVADD -,
    SYNSEM colon_copula_synsem ].

colon_copula_nb_synsem_min := synsem_min.
colon_copula_nb_synsem :=  basic_two_arg & colon_copula_nb_synsem_min &
  [ LOCAL [ CAT [ HEAD verb &
		       [ VFORM fin,
			 MOD < >,
			 MINORS.MIN be_v_id_rel,
			 PRD -,
			 AUX -,
			 INV -,
			 TAM #tam & [ TENSE real_tense,
				      ASPECT [ PRF -,
					       PROGR - ] ] ],
		  POSTHD -,
		  VAL [ SUBJ < >,
			SPR < synsem_min & 
			      [ --MIN norm_nom_rel,
				LOCAL [ CAT nbar_cat &
					    [ VAL.SPCMPS < > ],
					CONT.HOOK [ LTOP #nltop,
						    INDEX #nind ],
					AGR [ PNG.PN 3p,
					      DIV - ],
					CONJ cnil ],
				--SIND #id1ind & non_expl-ind,
				NONLOC non-local_none,
				OPT - ] >,
			COMPS < [ --MIN nom_or_mnp_rel,
				  LOCAL [ CAT nomp_cat_min & 
					      [ HEAD.MOD < >,
						VAL.SPEC *cons* ],
					  CONT.HOOK.LTOP #ltop,
					  CONJ cnil ],
				  --SIND #id2ind & non_expl-ind,
				  NONLOC [ SLASH 0-dlist,
					   REL 0-dlist ],
				  OPT - ] > ],
		  MC + ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #event & [ E #tam ],
			  XARG #id1ind ],
		   RELS <! #keyrel, 
			 #altkeyrel &
			 [ PRED udef_q_rel,
			   ARG0 #nind,
			   RSTR #rstr ] !>,
		   HCONS <! qeq & [ HARG #rstr, LARG #nltop ] !> ],
	    CONJ cnil,
	    AGR.PNG png & [ PN 3 ] ],
    NONLOC non-local_none,
    PUNCT [ LPUNCT no_punct,
	    RPUNCT colon_punct ],
    MODIFD notmod,
    LKEYS [ KEYREL #keyrel &
		   [ PRED _colon_v_id_rel,
		     LBL #ltop,
		     ARG0 #event,
		     ARG1 #id1ind,
		     ARG2 #id2ind ],
	    ALTKEYREL #altkeyrel ] ].

; For colon copula with nbar subject, as in "Owner: Abrams"
; Only for uninflected nouns, since cannot force inflection on singular nbars.
; <type val="v_np_colon-nb_le">
; <description>Cmps NP(obl), nbar-sbj - colon   
; <ex>Owner: C and D
; <nex>
; <todo>
; </type>
v_np_colon-nb_le := hc-to-phr &
  [ INFLECTD +,
    SYNSEM colon_copula_nb_synsem ].

colon_copula_nb_nb_synsem_min := synsem_min.
colon_copula_nb_nb_synsem := basic_two_arg & colon_copula_nb_nb_synsem_min &
  [ LOCAL [ CAT [ HEAD verb &
		       [ VFORM fin,
			 MOD < >,
			 MINORS.MIN be_v_id_rel,
			 PRD -,
			 AUX -,
			 INV -,
			 TAM #tam & [ TENSE real_tense,
				      ASPECT [ PRF -,
					       PROGR - ] ] ],
		  POSTHD -,
		  VAL [ SUBJ < >,
			SPR < synsem_min & 
			      [ --MIN norm_nom_rel,
				LOCAL [ CAT nbar_cat &
					    [ VAL.SPCMPS < > ],
					CONT.HOOK [ LTOP #nltop,
						    INDEX #nind ],
					AGR [ PNG.PN 3p,
					      DIV - ],
					CONJ cnil ],
				--SIND #id1ind & non_expl-ind,
				NONLOC non-local_none,
				OPT - ] >,
			COMPS < [ --MIN reg_nom_rel,
				  LOCAL [ CAT nbar_cat & 
					      [ HEAD.MOD < >,
						VAL.SPCMPS < > ],
					  CONT.HOOK [ LTOP #ctop,
						      INDEX #cind ],
					  CONJ cnil ],
				  --SIND #id2ind & non_expl-ind,
				  NONLOC [ SLASH 0-dlist,
					   REL 0-dlist ],
				  OPT - ] > ],
		  MC + ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #event & [ E #tam ],
			  XARG #id1ind ],
		   RELS <! #keyrel & [ CFROM #cfrom, CTO #cto ],
			 [ PRED udef_q_rel,
			   ARG0 #nind,
			   RSTR #rstr,
			   CFROM #cfrom, CTO #cto ],
			 #altkeyrel &
			 [ PRED udef_q_rel,
			   ARG0 #cind,
			   RSTR #crstr ] !>,
		   HCONS <! qeq & [ HARG #rstr, LARG #nltop ],
			  qeq & [ HARG #crstr, LARG #ctop ]!> ],
	    CONJ cnil,
	    AGR.PNG png & [ PN 3 ] ],
    NONLOC non-local_none,
    PUNCT [ LPUNCT no_punct,
	    RPUNCT colon_punct ],
    MODIFD notmod,
    LKEYS [ KEYREL #keyrel &
		   [ PRED _colon_v_id_rel,
		     LBL #ltop,
		     ARG0 #event,
		     ARG1 #id1ind,
		     ARG2 #id2ind ],
	    ALTKEYREL #altkeyrel ] ].

; For 'owner: young consultant'
; <type val="v_nb_colon-nb_le">
; <description>Cmps Nbar(obl), nbar-sbj - colon 
; <ex>Owner: young manager
; <nex>
; <todo>
; </type>
v_nb_colon-nb_le := hc-to-phr &
  [ INFLECTD +,
    SYNSEM colon_copula_nb_nb_synsem ].

;; For idioms with a simple transitive verb, such as |kick the bucket|
;;
v_np_idm_lexent := main_verb_mliszt & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < [ OPT - ] > ] ],
    IDIOM + ].

never_unify_lex := word &
  [ SYNSEM.LOCAL.CAT [ HEAD fw & [ MINORS.MIN never_unify_rel,
				   MOD < > ],
		       VAL [ SPR < >,
			     SUBJ < >,
			     COMPS < > ] ],
    ORTH < "_never_unify_" > ].

never_unify_le := never_unify_lex &
  [ INFLECTD -,
    ARGS < never_unify_lex &
	   [ INFLECTD + ] > ].

