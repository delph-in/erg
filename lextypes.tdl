;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  lextypes.tdl
;;;
;;;  Lexical types (i.e., word classes)
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;  Last revised: Dan Flickinger, 24-Feb-97

;:message "Lexical types".

:begin :type.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

affix_bearing := word &
  [ SYNSEM.LOCAL [ CAT #cat,
		   CONT [ HANDEL #hand,
			  INDEX #index,
			  --STEMLISZT *diff-list* &
				 [ LIST #1,
				   LAST #2 ],
			  LISZT *diff-list* &
				 [ LIST #1,
				   LAST #3 ],
			  KEY #key,
			  MODCONT #modcont ],
		   CTXT #ctxt ],
    ARGS < [ AFFIX affix & [ CAT #cat,
			     CONT [ HANDEL #hand,
				    INDEX #index,
				    LISZT *diff-list* &
					   [ LIST #2,
					     LAST #3 ],
				    KEY #key,
				    MODCONT #modcont ],
			     CTXT #ctxt ] ] > ].

non_affix_bearing := word &
  [ SYNSEM.LOCAL.CONT [ --STEMLISZT #liszt,
			LISZT #liszt ],
    ARGS < [ AFFIX no-affix ] , ... > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LEXICAL DEFAULTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nonslash := word &
  [ SYNSEM.NON-LOCAL.SLASH *e-dlist* ].  

; Lexical types that may have subtypes or instances with nonempty QUE values.
; Quantifiers introduce a nonempty value for their H-STORE attribute, but
; all nonque words assign the empty list for H-STORE.

nonque := word &
  [ SYNSEM.NON-LOCAL.QUE *e-dlist* ].  

nonrel := word &
  [ SYNSEM.NON-LOCAL.REL *e-dlist* ].  

nonconj := word &
  [ SYNSEM.LOCAL.CONJ cnil ].

rootna := word &
  [ SYNSEM.LOCAL.CAT.ROOT na ].

nonmsg := word &
  [ SYNSEM.LOCAL.CONT.MESSAGE no_rel ].

nonhstore := word & 
  [ SYNSEM.LOCAL.CONT.H-STORE <! !> ].

nonhcons := word &
  [ SYNSEM.LOCAL.CONT [ H-CONS <! !>,
			MODCONT.H-CONS <! !> ] ].

; norm_word's have all the defaults
norm_word := nonque & nonconj & nonslash & nonrel & nonmsg & nonhstore &
	     nonhcons & rootna.

norm_no_affix_word := norm_word & non_affix_bearing.

; ERB (13-11-96) Default type for potential modifiers:
; Two types because they're not all non_affix_bearing.
; The reason for this is tags...  see notes there.

norm_mod_word := nonque & nonconj & nonslash & nonrel & nonhstore & 
		 nonhcons & rootna &
   [ SYNSEM.LOCAL [ CAT.MOD.CONT.MESSAGE #mes,
		    CONT.MESSAGE #mes ] ].

norm_mod_no_affix_word := norm_mod_word & non_affix_bearing.

; ERB (04-10-96) I have added nonmsg to the following types, as
; appropriate.

; que_word's have all the defaults EXCEPT nonque and nonhstore.
que_word := nonconj & non_affix_bearing &
	    rootna &
	    nonslash &
	    nonrel &
	    nonmsg &
	    nonhcons. 

; rel_word's have all the defaults EXCEPT nonrel.
rel_word := nonque & non_affix_bearing &
	    rootna &
            nonslash &
	    nonconj &
	    nonmsg &
	    nonhcons. 

; conj_word's have all the defaults EXCEPT nonconj and nonmsg.
conj_word := nonque & non_affix_bearing & nonhstore &
	     nonslash &
	     nonrel &
 	     nonhcons. 

; ERB (04-10-96) msg_word's have all the defaults EXCEPT non_msg & rootna.
msg_word := nonque & non_affix_bearing & nonhstore &
	    nonslash &
	    nonrel &
	    nonconj &
	    nonhcons.

; hcons_word's have all the defaults EXCEPT nonhcons and non_affix_bearing.
hcons_word := nonque &
	    rootna &
	    nonslash &
	    nonrel &
	    nonconj &
	    nonmsg &
	    nonhstore.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; REMARKS
;;
;; MODCONT stores semantic properties of lexical entries which can serve as
;;   either modifiers or arguments, where the semantic contribution of the 
;;   item differs in the two roles.  For example, a preposition like "up" can
;;   appear as a particle selected for a verb as in "look up the answer", where
;;   the preposition does not provide an _up_rel; but "up" can also head a
;;   modifying PP-phrase, as in "ran up the street", where it does introduce an
;;   _up_rel.  So "up" stores its KEY relation in its CONT.MODCONT.LISZT rather
;;   than directly in CONT.LISZT, and leaves it to the grammar to incorporate
;;   the MODCONT in a head-modifier phrase.  Of course, some predicates like 
;;   the copula "be" take a predicative phrase as argument, and must lexically
;;   include the MODCONT of their predicative complement.  Likewise for verbs
;;   like "put" which take a PP complement, but want the preposition's lexical
;;   semantics, in contrast to "agree" as in "We agreed on fish", where the
;;   semantics of the preposition is ignored.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBCATEGORIZATIONS -- synsems for verbs, adjectives, prepositions, nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Type for verbs, adjectives, prepositions -- not nouns

subst_synsem := lex_synsem &
  [ LOCAL [ CAT.VALENCE [ SUBJ #subj & synsem & [ LOCAL local ],
			  COMPS #comps & *list*,
			  SPR *list* ],
	    CONT mrs,
	    ARG-S < #subj . #comps > ] ].

;; Type for synsems of words that take handle-args as complement or modifiee.
;; Use junk slot --H-CONS since adverbs put these constraints in their
;; MODCONT.H-CONS rather than directly in CONT.H-CONS, since they can be
;; used as particles (as in "get together") where no scope is involved.

basic_scopedarg_synsem := lex_synsem &
  [ LOCAL [ CAT.--SCOPEDARG [ LOCAL local & 
				    [ CONT [ HANDEL #arghand,
					     H-STORE.LIST #hslist ] ],
			      --ARG #arg ],
	    CONT [ HANDEL #hand,
		   --H-CONS.LIST < is-one-of &
				 [ SC-ARG #arg,
				   CANDS < #arghand . #hslist > ],
				 outscopes & 
				 [ SC-ARG #hand,
				   OUTSCPD #arghand ], ... > ] ] ].

scopedarg_synsem := basic_scopedarg_synsem &
  [ LOCAL.CONT [ --H-CONS #hcons,
		 H-CONS #hcons & <! scp_pr, scp_pr !> ] ].

scopedarg_neg_aux_synsem := basic_scopedarg_synsem &
  [ LOCAL [ CAT [ --SCOPEDARG.LOCAL.CONT.H-STORE.LIST #hslist,
		  --SCOPEDARG2 [ LOCAL local &
				       [ CONT.H-STORE.LIST #hslist ],
				 --ARG #arg ] ],
	    CONT [ HANDEL #hand,
		   KEY.HANDEL #arghand,
		   --H-CONS #hcons,
		   H-CONS #hcons &
			  <! scp_pr, scp_pr,
			     is-one-of &
			     [ SC-ARG #arg,
			       CANDS < #arghand . #hslist > ],
			     outscopes & 
			     [ SC-ARG #hand,
			       OUTSCPD #arghand ] !> ] ] ].

; For words that do not serve as modifiers, the CONT and MODCONT values for
; KEY are identified, in order to allow a general statement of
; which HANDEL scopal modifiers identify with their ARG (allowing for
; modification of modifiers like prepositions and temporal nouns whose MODCONT
; is not identical to their CONT.  The identification of MODCONT.HANDEL and
; MODCONT.KEY.KANDEL (which distinguishes intersective from scopal 
; modification) is done by intersective modifiers for their MOD values,
; analogous to what the Head-Modifier rule does for the modifier's semantics.
; INDEX and MODCONT.INDEX are also identified here - they will also have to
; be identified independently for those modifiers whose MODCONT does not
; introduce a new index.

nomod_local := local &
  [ CAT.MOD no-mod,
    CONT [ KEY #key,
	   INDEX #ind,
	   MODCONT [ HANDEL #hand,
		     KEY #key &
			 [ HANDEL #hand ],
		     INDEX #ind,
		     LISZT <! !> ] ] ].

nomod_synsem := lex_synsem &
  [ LOCAL nomod_local ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Linking Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Linking types specify the relationship between valence positions and 
;; semantic roles.

linking_type :< subst_synsem.

atrans_lt := linking_type &
  [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL local &
				   [ CONT.INDEX it-ind ],
	    CONT.KEY no_role_rel ] ].

act_subj_lt := linking_type &
  [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL local &
				   [ CONT.INDEX #subjind & non_expl-ind,
				     THROLE arg1 ],
	    CONT.KEY act_rel & [ ACT #subjind ] ] ].

unacc_lt := linking_type &
  [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL local & [ CONT.INDEX #subjind,
					     THROLE arg1 ],
	    CONT.KEY und_only_rel & [ UND #subjind ] ] ].

act_und_lt := act_subj_lt & 
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					[ CONT.INDEX #objind & non_expl-ind,
                                          THROLE arg3 ] ], ... >,
	    CONT.KEY act_und_rel & [ UND #objind ] ] ].

trans_lt :< act_und_lt.

act_und_h_lt := act_subj_lt & 
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					[ CONT [ KEY verb_aspect_rel,
						 MESSAGE.HANDEL #mhand ],
					  THROLE arg3 ] ], ... >,
	    CONT.KEY act_und_rel & [ UND #mhand ] ] ].

; "suppose" which makes its KEY same as its complement's KEY
; - wouldn't need this if had defaults
alt_act_und_h_lt := linking_type &
  [ LOCAL [ CAT.VALENCE [ SUBJ.LOCAL local &
				     [ CONT.INDEX #subjind & non_expl-ind,
				       THROLE arg1 ],
			  COMPS < [ LOCAL local &
					  [ CONT [ KEY verb_aspect_rel,
						   MESSAGE.HANDEL #mhand ],
					    THROLE arg3 ] ], ... >,
	    CONT.ALTKEY act_und_rel & [ ACT #subjind,
					UND #mhand ] ] ] ].

poss_lt := linking_type &          ; Maybe only for main verb "have"
  [ LOCAL [ CAT.VALENCE [ SUBJ.LOCAL local &
				     [ CONT.INDEX #subjind,
                                       THROLE arg1 ],
			  COMPS < [ LOCAL local &
					  [ CONT.INDEX #objind,
                                            THROLE arg3 ] ], ... > ],
	    CONT.--STEMLISZT <! act_und_rel & 
			      [ ACT #subjind,
				UND #objind ] !> ] ].

expl_obj_lt := act_subj_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					[ CONT.INDEX it-ind ] ], ... >,
	    CONT.KEY act_rel ] ].

expl_obj_cp_lt := expl_obj_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < synsem, [ LOCAL local &
					  [ CONT.MESSAGE.HANDEL #mhand ] ], ... >,
	    CONT.KEY act_und_rel & [ UND #mhand ] ] ].

ditrans_lt := act_und_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < *top*, [ LOCAL local &
					 [ CONT.INDEX #obj2ind & non_expl-ind,
					   THROLE arg2 ] ], ... >,
	    CONT.KEY act_und_thm_rel & [ THM #obj2ind ] ] ].

tritrans_lt := ditrans_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < *top*, *top*, [ LOCAL local &
						  [ CONT.INDEX #obj3ind ] ],
				... >,
	    CONT.KEY act_und_thm_prop_rel & [ PROP #obj3ind ] ] ].

prep_intrans_lt := act_subj_lt &
  [ LOCAL [ CAT.VALENCE.COMPS 
			< [ LOCAL local &
				  [ CONT [ KEY prep_rel & [ ARG #event],
					   MODCONT [ KEY.HANDEL #hand,
						     LISZT [ LIST #list,
							     LAST #last ] ]]]],
			  ... >,
	    CONT [ HANDEL #hand,
		   INDEX #event,
		   KEY #key,
		   --STEMLISZT *diff-list* &
		       [ LIST < #key . #list >,
			 LAST #last ] ] ] ].

empty_prep_intrans_lt := act_subj_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					[ CONT.KEY prep_rel & 
						   [ PREP #objind ],
					  THROLE arg2 ] ], ... >,
	    CONT.KEY act_prep_rel & [ PREPARG #objind ] ] ].

; Argument coercion as in "Kim suggests on Friday"
prep_intrans_event_lt := act_subj_lt &
  [ LOCAL [ CAT.VALENCE.COMPS 
			 < [ LOCAL local &
				   [ CONT [ KEY prep_rel & [ ARG #event ],
					    MODCONT.LISZT [ LIST #list,
							    LAST #last ] ],
				     THROLE arg2 ] ], ... >,
	    CONT [ KEY #key & [ UND #event ],
		   --STEMLISZT *diff-list* &
		       [ LIST < #key . #list >,
			 LAST #last ] ] ] ].

prep_trans_lt := act_und_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < *top*, 
				[ LOCAL local &
				   [ CONT [ KEY prep_rel & [ ARG #event ],
					    MODCONT.LISZT [ LIST #list,
							    LAST #last ] ] ] ],
				... >,
	    CONT [ KEY #key,
		   INDEX #event,
		   --STEMLISZT *diff-list* &
		       [ LIST < #key . #list >,
			 LAST #last ] ] ] ].

empty_prep_trans_lt := act_und_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < *top*, [ LOCAL local &
					 [ CONT.KEY prep_rel &
                                                 [ PREP #objind ],
                                                 THROLE arg2 ] ], ... >, 
	    CONT.KEY act_und_prep_rel & [ PREPARG #objind ] ] ].

empty_prep_particle_intrans_lt := act_subj_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < *top*, [ LOCAL local &
					 [ CONT.KEY prep_rel & 
                                                 [ PREP #objind ],
                                                 THROLE arg2 ] ], ... >,
	    CONT.KEY act_prep_rel & [ PREPARG #objind ] ] ].

empty_prep_particle_trans_lt := act_und_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < synsem, synsem, [ LOCAL local &
						  [ CONT.KEY prep_rel &
							[ PREP #objind ],
							  THROLE arg2 ] ], ... >, 
	    CONT.KEY act_und_prep_rel & [ PREPARG #objind ] ] ].


cp_trans_lt := act_und_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < *top*, 
				[ LOCAL local &
				   [ CONT [ KEY event_rel,
					    MESSAGE.HANDEL #mhand ] ] ], ...>,
	    CONT.KEY act_und_thm_rel & [ THM #mhand ] ] ].

; "explain to Kim that ..."
pp_cp_lt := empty_prep_intrans_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < *top*,
				[ LOCAL local &
				   [ CONT [ KEY event_rel,
					    MESSAGE.HANDEL #mhand ] ] ],... >,
	    CONT [ KEY act_und_prep_rel & [ UND #mhand ] ] ] ].

double_pp_lt := act_subj_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					[ CONT.KEY prep_rel &
						   [ ARG #event ] ] ], 
				[ LOCAL local &
					[ CONT.KEY prep_rel &
						   [ ARG #event ] ] ], ... >,
	    CONT.INDEX #event ] ].

s_equi_lt := linking_type &
  [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL local &
				   [ CONT.INDEX #index & non_expl-ind,
                                     THROLE arg1 ],
	    CONT.KEY fig_gnd_rel & [ GND #index ] ] ].

; Add predicative complement's KEY relation to --STEMLISZT, since its KEY
; will be in MODCONT.LISZT rather than in LISZT.

equi_prd_lt := linking_type & 
  [ LOCAL [ CAT.VALENCE.--KEYCOMP.LOCAL.CONT.MODCONT.LISZT [ LIST #list,
							     LAST #last ],
	    CONT [ --STEMLISZT *diff-list* &
			       [ LIST < relation & [ HANDEL #hand ]
					. < support_rel & #altkey & 
					    [ HANDEL #hand,
					      EVENT #event &
						     [ VIT.TENSE tense ] ]
					    . #list > >,
				 LAST #last ],
		   KEY.FIG #event,
		   ALTKEY #altkey ] ] ].
#|
equi_prd_lt := linking_type & 
  [ LOCAL [ CAT.VALENCE.--KEYCOMP.LOCAL.CONT.MODCONT.LISZT [ LIST #list,
							     LAST #last ],
	    CONT [ --STEMLISZT *diff-list* &
			       [ LIST < relation . #list >,
				 LAST #last ] ] ] ].
|#

subj_equi_lt := s_equi_lt &
  [ LOCAL.CAT.VALENCE 
		[ SUBJ.LOCAL.CONT.INDEX #index,
		  COMPS < [ LOCAL local &
				  [ CAT.VALENCE.SUBJ.LOCAL local &
							[ CONT.INDEX #index ],
                                    THROLE arg3] ] > ] ].

; 'try to leave'
subj_equi_inf_lt := subj_equi_lt &
  [ LOCAL [ CAT.VALENCE.--KEYCOMP.LOCAL local &
					[ CONT.MESSAGE.HANDEL #hand ],
	    CONT.KEY.FIG #hand ] ].

; 'stay calm'
subj_equi_prd_lt := equi_prd_lt & s_equi_lt &
  [ LOCAL [ CAT.VALENCE 
		[ SUBJ.LOCAL.CONT [ INDEX #index,
				    KEY.HANDEL #chand ],
		  --KEYCOMP #comp,
		  COMPS < #comp & 
			  [ LOCAL local &
				  [ CAT.VALENCE.SUBJ.LOCAL local &
							 [ CONT.INDEX #index ],
				    CONT.HANDEL #chand,
                                    THROLE arg3] ] > ],
	    CONT.ALTKEY.ARG #chand ] ].

; 'persuade Kim to leave'
obj_equi_lt := act_subj_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					[ CONT.INDEX #index & non_expl-ind,
					  THROLE arg2 ] ],
				[ LOCAL local &
				   [ CAT.VALENCE.SUBJ.LOCAL.CONT.INDEX #index,
				     THROLE arg3 ] ] >,
	    CONT.KEY act_fig_gnd_rel & [ GND #index ] ] ].

; 'persuade Kim to leave'
obj_equi_inf_lt := obj_equi_lt &
  [ LOCAL [ CAT.VALENCE.--KEYCOMP.LOCAL local &
					[ CONT.MESSAGE.HANDEL #hand ],
	    CONT.KEY.FIG #hand ] ].

pp_inf_lt := act_subj_lt &
 [ LOCAL [ CAT.VALENCE [ COMPS < [ LOCAL local &
					 [ CONT.KEY.PREP #und,
                                           THROLE arg2 ] ],
				 [ LOCAL local &
					 [ CONT.HANDEL #hand,
                                           THROLE arg3 ] ] > ],
	   CONT.KEY act_und_thm_rel & [ UND #und,
					THM #hand ] ] ].

; 'consider Kim wise'

obj_equi_prd_lt := equi_prd_lt & obj_equi_lt &
  [ LOCAL [ CAT.VALENCE
		  [ --KEYCOMP #comp,
		    COMPS < [ LOCAL local &
				    [ CONT [ INDEX #index,
					     KEY basic_nom_rel ],
				      THROLE arg2 ] ],
			    #comp &
			    [ LOCAL local &
				    [ CAT.VALENCE.SUBJ.LOCAL local &
							[ CONT.INDEX #index ],
				      CONT.HANDEL #chand,
				      THROLE arg3 ] ] > ],
	    CONT.ALTKEY.ARG #chand ] ].

; 'promise Kim to leave'
anom_equi_lt := s_equi_lt &
  [ LOCAL [ CAT.VALENCE 
		[ SUBJ.LOCAL.CONT.INDEX #subjind,
		  COMPS < [ LOCAL local &
				  [ CONT.INDEX #objind & non_expl-ind,
				    THROLE arg2 ] ],
			  [ LOCAL local &
				  [ CAT.VALENCE.SUBJ.LOCAL local &
						       [ CONT.INDEX #subjind ],
				    CONT.MESSAGE.HANDEL #hand,
                                    THROLE arg3 ] ] > ],
	    CONT.KEY fig_gnd_und_rel &
		     [ FIG #hand,
		       UND #objind ] ] ].

; 'turn out unreliable' (also resultatives like 'turned up drunk')
anom_equi_prd_lt := equi_prd_lt & s_equi_lt &
  [ LOCAL [ CAT.VALENCE 
		[ SUBJ.LOCAL.CONT [ INDEX #index,
				    KEY.HANDEL #chand ],
		  --KEYCOMP #comp,
		  COMPS < *top*,
			  #comp &
			  [ LOCAL local &
				  [ CAT.VALENCE.SUBJ.LOCAL local &
							[ CONT.INDEX #index ],
				    CONT.HANDEL #chand,
                                    THROLE arg3 ] ] > ],
	    CONT.ALTKEY.ARG #chand ] ].

; 'turn out to be red'
anom_equi_particle_lt := s_equi_lt &
  [ LOCAL [ CAT.VALENCE 
		[ SUBJ.LOCAL.CONT.INDEX #index,
		  COMPS < *top*,
			  [ LOCAL local &
				  [ CAT.VALENCE.SUBJ.LOCAL local &
							 [ CONT.INDEX #index ],
				    CONT.MESSAGE.HANDEL #hand,
                                    THROLE arg3 ] ] > ],
	    CONT.KEY.FIG #hand ] ].

ssr_lt := linking_type & scopedarg_synsem &
  [ LOCAL [ CAT.--SCOPEDARG.--ARG #arg,
	    CONT.KEY support_rel & [ VARG #arg ] ] ].

basic_ssr_expr_lt := ssr_lt &
  [ LOCAL [ CAT [ VALENCE.--KEYCOMP #comp,
		  --SCOPEDARG #comp ] ] ].

ssr_expr_lt := basic_ssr_expr_lt &
  [ LOCAL [ CAT.VALENCE [ --KEYCOMP #comp,
			  COMPS < [ LOCAL.CONT.KEY.PREP #expr ], #comp, ... >],
	    CONT.KEY.EXPR #expr ] ].

; 09-09-97  The VM semdb entries for these verbs lack an arg2 for the pp-to,
; so this definition is temporarily replaced by the one following, which
; treats the to-phrase as a modifier semantically.
#|
ssr_prdp_expr_lt := basic_ssr_expr_lt &
  [ LOCAL [ CAT.VALENCE [ --KEYCOMP #comp,
			  COMPS < #comp & 
				  [ LOCAL.CONT.MODCONT.LISZT [ LIST #list,
							       LAST #last ] ],
				  [ LOCAL.CONT.KEY _to_rel &
						   [ PREP #expr ] ],
				  ... > ],
	    CONT [ KEY #key & [ EXPR #expr,
				ARG2 #expr ],
		   --STEMLISZT *diff-list* & [ LIST < #key . #list >,
					       LAST #last ] ] ] ].
|#

ssr_prdp_expr_lt := basic_ssr_expr_lt &
  [ LOCAL [ CAT.VALENCE [ --KEYCOMP #comp,
			  COMPS < #comp & 
				  [ LOCAL.CONT.MODCONT.LISZT [ LIST #list,
							       LAST #middle ]],
				  [ LOCAL.CONT [ KEY _to_rel &
						     [ HANDEL #hand,
						       ARG #ind ],
						 MODCONT.LISZT [LIST #middle,
								LAST #last]]], ... > ],
	    CONT [ HANDEL #hand,
		   INDEX #ind,
		   KEY #key,
		   --STEMLISZT *diff-list* & [ LIST < #key . #list >,
					       LAST #last ] ] ] ].

sor_lt := linking_type & scopedarg_synsem &
  [ LOCAL [ CAT [ VALENCE [ SUBJ [ LOCAL local &
					 [ CONT.INDEX #index,
					   THROLE arg1 ] ], 
			    COMPS < synsem & [ LOCAL local &
						     [ THROLE arg2 ] ], 
				    #comp & [ THROLE arg3 ] > ],
		  --SCOPEDARG #comp & [ --ARG #arg ] ],
	    CONT.KEY fig_gnd_rel & [ FIG #arg,
				     GND #index ] ] ].

expl_it_subj_lt := linking_type & scopedarg_synsem &
  [ LOCAL [ CAT [ VALENCE [ SUBJ.LOCAL local & [ CONT.INDEX it-ind ],
			    COMPS < [ LOCAL local &
				      [ CONT.KEY.PREP #expr ] ], #comp, ... >,
			    --KEYCOMP #comp & 
				      [ LOCAL local &
					     [ CONT.MESSAGE.HANDEL #hand ] ] ],
		  --SCOPEDARG #comp ],
	    CONT.KEY support_rel &
		     [ ARG #hand,
		       EXPR #expr ] ] ].

expl_prep_trans_lt := linking_type &
 [ LOCAL [ CAT.VALENCE [ SUBJ.LOCAL local &
				    [ CONT.INDEX it-ind ],
			 COMPS < [ LOCAL local &
					 [ CONT.INDEX #und,
					   THROLE arg3 ] ],
				 [ LOCAL local &
					 [ CONT [ KEY prep_rel & 
						      [ HANDEL #hand,
							ARG #index,
							PREP #act ] ],
                                           THROLE arg1 ] ], ...> ],
	   CONT [ HANDEL #hand,
		  INDEX #index,
		  KEY act_und_rel & [ ACT #act,
				      UND #und ] ] ] ].

expl_pp_inf_lt := act_subj_lt &
 [ LOCAL [ CAT.VALENCE [ COMPS < [ LOCAL local &
					 [ CONT.INDEX it-ind ] ],
				 [ LOCAL local &
					 [ CONT.KEY.PREP #und,
                                           THROLE arg2 ] ],
				 [ LOCAL local &
					 [ CONT.HANDEL #hand,
                                           THROLE arg3 ] ] > ],
	   CONT.KEY act_und_thm_rel & [ UND #und,
					THM #hand ] ] ].

; 'leave it to Kim to find the answer'
expl_pp_inf_oeq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VALENCE.COMPS < *top*,
			     [ LOCAL.CONT.KEY.PREP #und ],
			     [ LOCAL.CONT.KEY act_rel & [ ACT #und ] ] > ].

; 'arrange with Kim to meet her'
pp_inf_seq_lt := pp_inf_lt &
 [ LOCAL.CAT.VALENCE [ SUBJ.LOCAL local &
				  [ CONT.INDEX #act ],
		       COMPS < *top*,
			       [ LOCAL.CONT.KEY act_rel & [ ACT #act ] ] > ] ].

; 'arrange it with Kim to meet her'
expl_pp_inf_seq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VALENCE [ SUBJ.LOCAL local &
				  [ CONT.INDEX #act ],
		       COMPS < *top*,
			       *top*,
			       [ LOCAL.CONT.KEY act_rel & [ ACT #act ] ] > ] ].

; suffice
atrans_inf_lt := linking_type &
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					[ CONT.HANDEL #hand ] ] >,
	    CONT.KEY fig_gnd_rel & [ FIG #hand ] ] ].

particle_NP_lt := act_subj_lt & 
  [ LOCAL [ CAT.VALENCE.COMPS < *top*, [ LOCAL local &
					 [ CONT.INDEX #index,
					   THROLE arg3 ] ] >,
	    CONT.KEY act_und_rel & [ UND #index ] ] ].

NP_particle_lt := act_subj_lt & 
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					[ CONT.INDEX #index,
                                          THROLE arg3 ] ], ... >,
	    CONT.KEY act_und_rel & [ UND #index ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Valence Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Valence types specify the number and type of subcategorized complements.
  
valence_type :< subst_synsem.

unsat_subst := valence_type &
  [ LOCAL.CAT.VALENCE.SUBJ @nomp( ) ].

intrans_subst := unsat_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < > ].

unsat_two_arg_subst := unsat_subst &
  [ LOCAL [ CAT.VALENCE.COMPS < synsem & [ LOCAL local &
						 [ CONT.KEY #ckey ] ], ... >,
	    CONT.COMPKEY #ckey ] ].

two_arg_subst := unsat_two_arg_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < *top* > ].

; For verbs that passivize.
trans_subst := unsat_subst &
  [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc), ... > ].
  
np_trans_subst := trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < [ LOCAL local &
				      [ CAT.HEAD noun ] ] > ].
  
; For verbs with NP complement but that don't passivize.
non_trans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc), ... > ].
  
np_non_trans_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < [ LOCAL local &
				      [ CAT.HEAD noun ] ] > ].

cp_intrans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < #comp & @cp($vform=fin) > ] ].
  
fin_cp_intrans_subst := cp_intrans_subst &
  [ LOCAL.CAT.VALENCE.--KEYCOMP.LOCAL local &
				      [ CAT.HEAD.VFORM fin ] ].
  
prd_intrans_subst := unsat_two_arg_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < @prd() > ].

prep_intrans_subst := two_arg_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < @pp() > ].

unsat_three_arg_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VALENCE.COMPS < synsem, 
				synsem & [ LOCAL local &
						 [ CONT.KEY #ckey ] ], ... >,
	    CONT.OCOMPKEY #ckey ] ].

three_arg_trans_subst := unsat_three_arg_subst & trans_subst.

prep_trans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc), @pp() > ].
  
prd_trans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc), @prd() > ].

prd_non_trans_subst := unsat_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc), @prd() > ].

ditrans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc), @np($case=acc) > ].
  
; 'inform Kim that S'
cp_trans_subst := three_arg_trans_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < @np($case=acc),
				#comp & @cp($vform=fin) > ] ]. 
  
pp_cp_subst := unsat_three_arg_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < @pp(),
				#comp & @cp($vform=fin) > ] ].
  
np_comp_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc),
			      [ LOCAL local &
				 [ CAT [ HEAD subst,
					 VALENCE [ SUBJ synsem,
						   COMPS *olist* ] ] ] ] > ].
; 'talk to Kim about Sandy'
double_pp_subst := unsat_three_arg_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < @pp(), @pp() > ].
  
inf_or_prp_intrans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < #comp & @vp($vform=inf_or_prp) > ] ].

inf_intrans_subst := inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VALENCE.COMPS < [ LOCAL local &
				      [ CAT.HEAD.VFORM inf ] ] > ].

for_inf_intrans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VALENCE.COMPS < @cp($vform=inf) > ].

inf_trans_subst := three_arg_trans_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp, 
			COMPS < *top*, #comp & @vp($vform=inf) > ] ].

prp_intrans_subst := inf_or_prp_intrans_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < [ LOCAL local &
				      [ CAT.HEAD.VFORM prp ] ] > ].

bse_trans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < *top*, @vp($vform=bse) > ].

; want (doesn't passivize)
inf_non_trans_subst := unsat_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < *top*, #comp & @vp($vform=inf) > ] ].

pp_inf_subst := unsat_three_arg_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < @pp(),
				#comp & @vp($vform=inf) > ] ].
  

ssr_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VALENCE [ SUBJ.LOCAL local & #subj,
			COMPS < [ LOCAL local &
					[ CAT.VALENCE [ SUBJ synsem & 
							     [ LOCAL #subj ],
							COMPS *olist* ],
					  CONT.MESSAGE no_rel ] ] > ] ].

ssr_inf_subst := ssr_subst & inf_intrans_subst.

ssr_pp_inf_subst :=  unsat_three_arg_subst &
  [ LOCAL.CAT.VALENCE [ SUBJ #subj,
			COMPS < @pp(),
				[ LOCAL local &
					[ CAT [ HEAD verbal & [ VFORM inf ],
						VALENCE [ SUBJ synsem & #subj,
							  COMPS *olist* ] ],
					  CONT.MESSAGE no_rel ] ] > ] ].

ssr_prdp_pp_subst :=  unsat_three_arg_subst &
  [ LOCAL.CAT.VALENCE [ SUBJ #subj,
			COMPS < [ LOCAL local &
					[ CAT [ HEAD.PRD +,
						VALENCE [ SUBJ synsem & #subj,
							  SPR *olist*,
							  COMPS *olist* ],
						ROOT na ] ] ],
				@pp() > ] ].

expl_pp_cp_subst :=  unsat_three_arg_subst &
  [ LOCAL.CAT.VALENCE.COMPS < @pp(), @cp() > ].

sor_inf_subst := inf_trans_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < #subj & [ OPT - ], 
			      [ LOCAL local &
				      [ CAT.VALENCE.SUBJ #subj,
					CONT.MESSAGE no_rel ],
				OPT - ] > ].

sor_bse_subst := bse_trans_subst &
  [ LOCAL.CAT.VALENCE.COMPS < #subj & [ OPT - ], 
			      [ LOCAL local &
				      [ CAT.VALENCE.SUBJ #subj ],
				OPT - ] > ].

sor_inf_non_trans_subst := inf_non_trans_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < #subj & [ OPT - ], 
			      [ LOCAL local &
				      [ CAT.VALENCE.SUBJ #subj,
					CONT.MESSAGE no_rel ],
				OPT - ] > ].

particle_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VALENCE.COMPS 
           < lex_synsem & [ LOCAL local &
				  [ CAT.HEAD particle & [ PRD - ] ] ], ... > ].

particle_NP_subst := particle_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < synsem,
			      @np($case=acc) > ].

generic_NP_particle_subst := unsat_subst & 
  [ LOCAL [ CAT.VALENCE.COMPS < @np($case=acc),
				lex_synsem &
				[ LOCAL local &
					[ CAT [ HEAD particle & [ PRD - ] ],
					  CONT.KEY #ckey ] ], ... >,
	    CONT.COMPKEY #ckey ] ].

NP_particle_subst := generic_NP_particle_subst & trans_subst &
  [ LOCAL.CAT.VALENCE.COMPS < synsem, synsem > ].

particle_plus_subst := particle_subst & unsat_three_arg_subst.

particle_prd_subst := particle_plus_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < synsem, @prd() > ].

; 'turn out to be'
particle_inf_subst := particle_plus_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < *top*, #comp & @vp($vform=inf) > ] ].

particle_pp_subst := particle_plus_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < *top*, @pp() > ].

particle_adv_subst := particle_plus_subst & 
  [ LOCAL.CAT.VALENCE.COMPS < *top*, [ LOCAL.CAT.HEAD adv ] > ].

; 'find out that S'
particle_cp_subst := particle_plus_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < *top*, #comp & @cp($vform=fin) > ] ].

;; 'leave it to Kim to schedule the meeting'
unsat_four_arg_subst := unsat_three_arg_subst &
  [ LOCAL.CAT.VALENCE.COMPS < synsem, 
			      synsem,
			      synsem, ... > ].

; 'leave it to Kim to find the answer'
expl_pp_inf_subst := unsat_four_arg_subst & trans_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < *top*, 
				@pp(),
				#comp & @vp($vform=inf) > ] ].

;; 'put kim through to Sandy'
particle_np_pp_subst := generic_NP_particle_subst & unsat_subst &
  [ LOCAL.CAT.VALENCE.COMPS < synsem, synsem, @pp() > ].

;; 'bet Kim a fortune that Sandy would win'
np_np_cp_subst := unsat_four_arg_subst & trans_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < @np($case=acc),
				@np($case=acc),
				#comp & @cp($vform=fin) > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; VERB SYNSEMS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Verb synsems should inherit from one valence type and one linking type.
;; The type verb_synsem is given a non-empty SPR value so VPs can be modified
;; by PPs, but the synsem is marked [ LOCAL no-mod ] to block unification,
;; to avoid ever picking up an actual specifier.
;;   Added VIT links for the moment, to satisfy VIT requirements for visibility
;; of AGR, TENSE, and MOOD information.

verb_synsem := subst_synsem &
  [ LOCAL [ CAT [ HEAD verb &
		       [ TENSE #vittense,
			 MOOD #vitmood ],
		  AGR #agr,
		  VALENCE [ SUBJ.LOCAL local &
				       [ CAT.AGR #agr ],
			    SPR < synsem & [ LOCAL no-mod ] > ] ],
	    CONT psoa &
		[ INDEX.VIT [ AGR #agr,
				  TENSE #vittense,
				  MOOD #vitmood ],
		  MODCONT.LISZT <! !> ] ] ].

verb_nonhcons := verb_synsem &
  [ LOCAL.CONT.H-CONS <! !> ].

atrans_verb := verb_nonhcons & intrans_subst & atrans_lt.

unerg_verb := verb_nonhcons & intrans_subst & act_subj_lt.
  
unacc_verb := verb_nonhcons & intrans_subst & unacc_lt.
  
; For at least main verb "have" (e.g, "Kim has some rice")
poss_verb := verb_nonhcons & two_arg_subst & poss_lt &
  [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc) > ].
  
np_trans_verb := verb_nonhcons & np_trans_subst & trans_lt.
  
np_non_trans_verb := verb_nonhcons & np_non_trans_subst & trans_lt.

np_non_trans_unacc_verb := verb_nonhcons & np_non_trans_subst & unacc_lt.

;; come to
;;
prep_intrans_verb := verb_nonhcons & prep_intrans_subst & prep_intrans_lt.

;; look for
;;
empty_prep_intrans_verb := verb_nonhcons & prep_intrans_subst & 
			   empty_prep_intrans_lt.

;; suggest on Tuesday
;;
prep_intrans_event_verb := verb_nonhcons & prep_intrans_subst & 
			   prep_intrans_event_lt.

;; put, move
;;
prep_trans_verb := verb_nonhcons & prep_trans_subst & prep_trans_lt.
  
;; remind-of
;;
empty_prep_trans_verb := verb_nonhcons & prep_trans_subst & empty_prep_trans_lt.

;; regard Kim as tall
np_comp_verb := verb_nonhcons & np_comp_subst & obj_equi_lt.

;; strike Kim as tall
np_comp_obj_verb := verb_nonhcons & np_comp_subst & 
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL.CONT.INDEX #index ],
				[ LOCAL.CONT.INDEX #event ] >,
	    CONT.KEY fig_gnd_rel & [ FIG #event,
				     GND #index ] ] ].

to_trans_verb := empty_prep_trans_verb &
  [ LOCAL.CONT.OCOMPKEY _to_rel ].
  
ditrans_verb := verb_nonhcons & ditrans_subst & ditrans_lt.
  
ditrans_only_verb := verb_nonhcons & ditrans_subst & ditrans_lt &
  [ LOCAL.CAT.VALENCE.COMPS < synsem, [ OPT - ] > ].

; 'talk to Kim about Sandy'
double_pp_verb := verb_nonhcons & double_pp_subst & double_pp_lt.

; Raising verbs which take an infinitival complement restrict it to being
; [ MESSAGE no_rel ], which ensures that the VP will be headed by the 
; non-propositional "to" complementizer, which identifies its handle with
; that of its VP complement.

ssr_verb := verb_synsem & ssr_inf_subst & ssr_lt.

ssr_prd_verb := verb_synsem & ssr_subst & ssr_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < @prd() &
				[ LOCAL.CONT.MODCONT.LISZT [ LIST #list, 
							     LAST #last ] ] >,
	    CONT [ KEY #key,
		   --STEMLISZT *diff-list* &
		       [ LIST < #key . #list >,
			 LAST #last ] ] ] ].

ssr_pp_inf_verb := verb_synsem & ssr_pp_inf_subst & ssr_expr_lt.

ssr_prdp_pp_verb := verb_synsem & ssr_prdp_pp_subst & ssr_prdp_expr_lt.

sor_verb := verb_synsem & sor_inf_subst & sor_lt.

sorb_verb := verb_synsem & sor_bse_subst & sor_lt.

sor_non_trans_verb := verb_synsem & sor_inf_non_trans_subst & sor_lt.

subj_equi_prp_verb := verb_nonhcons & prp_intrans_subst & subj_equi_lt.

subj_equi_prd_verb := verb_nonhcons & prd_intrans_subst & subj_equi_prd_lt.

obj_equi_prd_verb := verb_nonhcons & prd_trans_subst & obj_equi_prd_lt.

obj_equi_non_trans_prd_verb := verb_nonhcons & prd_non_trans_subst & 
			       obj_equi_prd_lt.

anom_equi_prd_verb := verb_nonhcons & prd_trans_subst & anom_equi_prd_lt.

; ERB (07-10-96) I am working with the verb 'know' as a prototype for a verb
; that selects by the semantic type (for now expressed as a feature) of its
; sentential complement rather than by the value of CMP or some such hack.  In
; order to do so, I have changed the types around here.  In particular, I am
; adding a new type cp_prop+ques_intrans_verb that takes a sentential
; complement but doesn't care if its a proposition or a question (for verbs
; like 'know').  A further access of variation is the VFORM of the complement
; (fin vs. inf).  Since my analysis of 'know' never makes use of the resolved
; subtypes (e.g., cp_prop_intrans_verb) I am not adding to the resolved
; subtypes, and just making the old ones inherit from the finite side of
; things for now.  The future inf_cp_prop_intrans_verb will probably be the
; type of subject equi verbs. A further future modification would involve the
; addition of cp_command_intrans_verb and cp_command+prop_intrans_verb for
; verbs like 'insist'.

scoping_verb := verb_synsem & scopedarg_synsem.

cp_prop+ques_verb := scoping_verb &
  [ LOCAL [ CAT [ VALENCE [ --KEYCOMP #comp &
				      [ LOCAL local &
					      [ CAT [ HEAD verbal,
						      ROOT - ],
					  CONT [ MESSAGE #msg & prop_ques_rel &
							 [ SOA #arg ] ] ] ] ],
		  --SCOPEDARG #comp & [ --ARG #arg ] ],
	    CONT.--STEMLISZT.LIST < relation, #msg, ... > ] ].

fin_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VALENCE.--KEYCOMP.LOCAL.CAT.HEAD.VFORM fin ].

cp_intrans_verb := fin_cp_prop+ques_verb & cp_intrans_subst & act_und_h_lt.

cp_prop_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VALENCE.COMPS < [ LOCAL.CONT.MESSAGE propositional_rel ] > ].

cp_ques_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VALENCE.COMPS < [ LOCAL.CONT.MESSAGE int_rel ] > ].

cp_prop_raise_key_verb := fin_cp_prop+ques_verb & cp_intrans_subst &
			  alt_act_und_h_lt &
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL.CONT [ KEY #key,
					       MESSAGE propositional_rel ] ] >,
	    CONT [ KEY #key & mod_role_rel,
		   ALTKEY #altkey,
		   --STEMLISZT.LIST < relation, relation, #altkey, ... > ] ] ].

;; tell Kim that/whether S
np_trans_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt.

;; inform Kim that S
fin_np_trans_cp_verb := np_trans_cp_verb &
  [ LOCAL.CAT.VALENCE.--KEYCOMP.LOCAL.CAT.HEAD.VFORM fin ].

;; bet Kim ten cents that S
np_np_cp_verb := fin_cp_prop+ques_verb & np_np_cp_subst & tritrans_lt.

;; explain to Kim that S
pp_cp_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
  [ LOCAL.CAT.VALENCE.COMPS < synsem, [ LOCAL.CONT.MESSAGE propositional_rel ] > ].

;; ask Kim whether S
np_trans_cp_ques_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &

  [ LOCAL.CAT.VALENCE.COMPS < synsem, [ LOCAL.CONT.MESSAGE int_rel ] > ].

subj_equi_verb := cp_prop+ques_verb & inf_intrans_subst & subj_equi_inf_lt.

obj_equi_verb := cp_prop+ques_verb & inf_trans_subst & obj_equi_inf_lt.

oeq_pp_inf_verb := verb_synsem & pp_inf_subst & obj_equi_inf_lt.

pp_inf_seq_verb := cp_prop+ques_verb & pp_inf_subst & pp_inf_seq_lt.

anom_equi_verb := cp_prop+ques_verb & inf_non_trans_subst & anom_equi_lt.

particle_inf_verb := cp_prop+ques_verb & particle_inf_subst & 
		     anom_equi_particle_lt.

particle_cp_verb := fin_cp_prop+ques_verb & particle_cp_subst & 
		    anom_equi_particle_lt.

expl_it_subj_verb := cp_prop+ques_verb & expl_pp_cp_subst & expl_it_subj_lt.

expl_pp_inf_oeq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_oeq_lt.

expl_pp_inf_seq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_seq_lt.

atrans_inf_verb := cp_prop+ques_verb & inf_intrans_subst & atrans_inf_lt.

for_to_verb := verb_synsem & for_inf_intrans_subst & trans_lt.

expl_prep_trans_verb := verb_nonhcons & non_trans_subst & 
			expl_prep_trans_lt & unsat_three_arg_subst &
  [ LOCAL.CAT.VALENCE.COMPS < *top*, @pp() > ].

particle_verb := verb_nonhcons & particle_subst & act_subj_lt &
  [ LOCAL.CAT.VALENCE.COMPS < *top* > ].

particle_NP_verb := verb_nonhcons & particle_NP_subst & particle_NP_lt.

NP_particle_verb := verb_nonhcons & NP_particle_subst & NP_particle_lt.

particle_prd_verb := verb_nonhcons & particle_prd_subst & anom_equi_prd_lt.

particle_pp_verb := verb_nonhcons & particle_pp_subst & 
		    empty_prep_particle_intrans_lt.

particle_adv_verb := verb_nonhcons & particle_adv_subst & act_subj_lt.

particle_np_pp_verb := verb_nonhcons & particle_np_pp_subst & empty_prep_particle_trans_lt.

; prefer it if ...
expl_obj_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & expl_obj_cp_lt.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The semantics of a main verb consists of the "main" handel for the sentence
; and a list of relations.  A pointer to the main or head relation in the list
; is kept in the KEY attribute.

main_verb_sans_key := hcons_word & affix_bearing &
  [ SYNSEM.LOCAL [ CAT.HEAD verb & [ AUX -,
				     INV - ],
		   CONT [ HANDEL #hand,
			  INDEX #event,
			  --STEMLISZT.LIST < event_rel &
				       [ EVENT #event,
					 HANDEL #hand ], ... > ] ] ].
main_verb := main_verb_sans_key &
  [ SYNSEM.LOCAL.CONT [ --STEMLISZT.LIST < #key, ... >,
			  KEY #key ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; AUXILIARY VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Auxiliary verbs are subject-to-subject raising verbs which also raise the 
; content of the VP complement, possibly tacking an additional relation on the
; end.  They also raise the context of the VP complement, for now at least to
; propagate tense information.
; AUX verbs are further classified by the type of VP complement they 
; select for.  Also, AUX verbs optionally take a neg (post-head) specifier.

aux_verb := verb_synsem & ssr_subst &
  [ LOCAL.CAT.VALENCE [ --KEYCOMP #comp,
			COMPS < #comp, ... > ] ].

aux_verb_word := hcons_word &
  [ SYNSEM aux_verb & 
	  [ LOCAL.CAT.HEAD.AUX + ] ].

bse_aux_verb_word := aux_verb_word & 
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT.VALENCE.COMPS < @vp($vform=bse) &
				       [ LOCAL local &
					       [ CAT.HEAD.PRD - ],
					 OPT - ] > ] ].
;; ought
inf_aux_verb_word := aux_verb_word & 
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT.VALENCE.COMPS < @vp($vform=inf) & 
				       [ LOCAL.CAT.HEAD.PRD -,
					 OPT - ] > ] ].

psp_aux_verb_word := aux_verb_word & 
  [ SYNSEM.LOCAL.CAT.VALENCE.COMPS < @vp($vform=psp) &
				     [ OPT - ] > ].

; Only for the copula
prd_aux_verb_word := aux_verb_word &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS 
				< [ LOCAL local &
					  [ CAT [ HEAD [ PRD + ],
						  VALENCE [ SUBJ synsem,
							    COMPS *olist*,
							    SPR *olist* ],
						  ROOT na ],
					    CONT.HANDEL #arghand ],
				    OPT - ] >,
		   CONT.KEY.ARG #arghand ] ].

raise_cont := *avm* &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					  [ CONT [ HANDEL #hand,
						   INDEX #index,
						   MODCONT #mcont ] ] ], ... >,
		   CONT [ HANDEL #hand,
			  INDEX #index,
			  MODCONT #mcont,
			  --STEMLISZT <! !> ] ] ].

add_cont := *avm* &
  [ SYNSEM.LOCAL.CONT [ --STEMLISZT.LIST < relation & #key, ... >,
			KEY #key ] ].

scoping_aux_verb := aux_verb & scoping_verb.
scoping_neg_aux_verb := aux_verb & scopedarg_neg_aux_synsem.

; Real modal verbs are auxiliary verbs which select a base form complement.
; They only exist in finite forms.

generic_modal_verb_word := aux_verb_word & 
  [ SYNSEM [ LOCAL [ CAT [ VALENCE.--KEYCOMP #comp,
			   --SCOPEDARG #comp & 
				       [ --ARG #arg ] ],
		     CONT [ INDEX #event,
			    --STEMLISZT.LIST < [ EVENT #event,
						 ARG #arg ], ... > ] ] ] ].

fin_modal_verb_word := generic_modal_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
				VFORM fin ],
			 VALENCE.SUBJ @nomp($case=nom) ],
		   CONT.INDEX [ TIME #e,
				REFERENCE #e ] ] ].

pres_modal_verb_word := fin_modal_verb_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD.TENSE present,
		   CONT [ INDEX [ REFERENCE #r,
				  SPCH #s ],
			  --STEMLISZT <! relation, 
				     temp_over_rel &
				     [ HANDEL #hand,
				       EVENT1 #r,
				       WHEN #s ] !>,
			  KEY.HANDEL #hand ],
		   CTXT.C-INDS.SPEECH #s ] ].

; Assume for now that all modals have simple present tense semantics,
; ignoring the habitual past readings possible for "would" and "could" -
; these will have to be separate lexical entries.

modal_verb_word := pres_modal_verb_word & bse_aux_verb_word.
pos_modal_verb_word := modal_verb_word &
  [ SYNSEM scoping_aux_verb &
	   [ LOCAL.CONT [ HANDEL #hand,
			  KEY.HANDEL #hand ] ] ].

ought_verb_word := pres_modal_verb_word & inf_aux_verb_word.
pos_ought_verb_word := ought_verb_word &
  [ SYNSEM scoping_aux_verb &
	   [ LOCAL.CONT [ HANDEL #hand,
			  KEY.HANDEL #hand ] ] ].
past_ought_verb_word := fin_modal_verb_word & inf_aux_verb_word &
  [ SYNSEM scoping_aux_verb &
	   [ LOCAL [ CAT.HEAD.TENSE past,
		     CONT [ HANDEL #hand,
			    INDEX [ REFERENCE #r,
				    SPCH #s ],
			    --STEMLISZT <! relation, 
					 temp_prec_rel &
					 [ HANDEL #hand,
					   EVENT1 #r,
					   LATER #s ] !>,
			    KEY.HANDEL #hand ],
		     CTXT.C-INDS.SPEECH #s ] ] ].

quasimodal_word := generic_modal_verb_word & inf_aux_verb_word.

sai_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD verb & [ INV +,
				AUX + ],
		  VALENCE [ SUBJ none,
			    COMPS #comps & *list*] ],
	    CONT mrs,
	    ARG-S #comps ] ].




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modifier synsems
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

modifier_synsem := lex_synsem &
  [ LOCAL.CONT [ HANDEL #hand,
		 KEY.HANDEL #hand ] ].

; 5/2/96 (DPF) Was subtype of prd_synsem, but this blocked "how about Tuesday"
; so made it subtype of modifier_synsem.

temp_mod_synsem := modifier_synsem &
  [ LOCAL [ CAT [ HEAD noun &
		       [ POSS - ],
		  VALENCE.SUBJ none,
		  MOD local &
		       [ CAT [ HEAD verb,
			       VALENCE [ SPR < synsem >,
					 COMPS *olist* ],
			       ROOT na ],
			 CONT [ HANDEL #mhand,
				INDEX #event,
				MESSAGE #msg ] ],
		  POSTHEAD + ],
	    CONT [ HANDEL #hand,
		   INDEX #index & ref-ind,
		   --STEMLISZT.LIST < #key &
				      [ INST #index ], ... >,
		   KEY #key & [ HANDEL #hand ],
		   MODCONT [ HANDEL #mhand,
			     INDEX #event,
			     LISZT <! #mkey !>,
			     KEY #mkey & temp_loc_rel &
				         [ PREP #index,
					   ARG #event ],
			     MESSAGE #msg ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NOUNS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;       TYPE                 ISA                what's it for?
;       nominal_synsem       lex_synsem         all nouns
;       xpro_synsem          nominal_synsem     pro v. non-pro dimension
;       xref_synsem          nominal_synsem     ref v. non-ref dimension
;       pronominal_synsem    xpro_synsem        all pronouns
;       nonpronominal_synsem xpro_synsem        all non-pronominal nouns
;       ref_synsem           xref_synsem        personal pro's & nouns
;       non_ref_synsem       xref_synsem        it, there, wh-pronouns
;       ref_pro_synsem       pronominal_synsem  personal pronouns
;                            & ref_synsem
;       non_ref_pro_synsem   pronominal_synsem  it, there, wh-pronouns
;                            & non_ref_synsem
;       noun_synsem          non_pronominal_synsem all non-pro nouns
;                            & ref_synsem 

; The "default" statement that most nouns identify their AGR and INDEX
; will live on noun_synsem and non_ref_pro_synsem, and then be restated for
; personal pronouns other than my special 'they'.  (All this because I can't
; be bothered now to set up a special default type...) 

basic_nom_synsem := lex_synsem & 
  [ LOCAL [ CAT.HEAD noun,
	    CONT nom-obj,
	    ARG-S < > ] ].

nominal_synsem := basic_nom_synsem &
  [ LOCAL.CAT.HEAD.POSS - ].

xpro_synsem :< nominal_synsem.
xref_synsem :< nominal_synsem.

pronominal_synsem := xpro_synsem &
  [ LOCAL [ CAT.VALENCE.SUBJ none,
	    CONT.MODCONT.LISZT <! !> ] ].

nonpronominal_synsem :< xpro_synsem.

ref_synsem := xref_synsem &
  [ LOCAL [ CONT [ INDEX #inst & ref-ind,
		   --STEMLISZT.LIST < basic_nom_rel & #key & 
				    [ INST #inst ], ... >,
		   KEY #key ] ] ].

non_ref_synsem := xref_synsem & nomod_synsem &
  [ LOCAL [ CAT.VALENCE [ SPR < >,
			  COMPS < > ],
	    ARG-S < > ] ].

ref_pro_synsem := pronominal_synsem & ref_synsem.
non_ref_pro_synsem := pronominal_synsem & non_ref_synsem &
  [ LOCAL [ CAT.AGR #agr,
	    CONT.INDEX #agr ] ].

noun_synsem := nonpronominal_synsem & ref_synsem &
  [ LOCAL [ CAT.AGR #agr,
	    CONT.INDEX #agr ] ].

;;
;; Common nouns
;;


; The specifier more generally will need to include the H-STORE of its N-bar
; in the list of candidates for its restrictor, in addition to the handle of
; the N-bar itself, but we leave this for later.

#|
;; This good definition is commented out for now, since the Verbmobil VIT
;; definition temporarily (and incorrectly) hardwires the handle of the noun 
;; to the RESTR value for the quantifier.

common_noun_synsem := noun_synsem &
  [ LOCAL [ CAT [ HEAD cnoun,
		  VALENCE [ SPR < synsem &
				  [ LOCAL local &
					  [ CAT [ HEAD det,
						  VALENCE [ SUBJ none,
							    COMPS *olist* ] ],
					    CONT.KEY [ HANDEL #dethand,
						       BV #index,
						       RESTR #arg ] ],
				    OPT - ] >,
			    SUBJ none ] ],
	    CONT [ HANDEL #hand,
		   INDEX #index,
		   KEY.HANDEL #hand,
		   --SP-H-CONS <! is-one-of &
				 [ SC-ARG #arg,
				   CANDS < #hand > ],
				 outscopes & 
				 [ SC-ARG #dethand,
				   OUTSCPD #hand ] !> ] ] ].
|#

common_noun_synsem := noun_synsem &
  [ LOCAL [ CAT [ HEAD cnoun,
		  VALENCE [ SPR < synsem &
				  [ LOCAL local &
					  [ CAT [ HEAD det,
						  VALENCE [ SUBJ none,
							    COMPS *olist* ] ],
					    CONT.KEY [ BV #index,
						       RESTR #hand ] ],
				    OPT - ] >,
			    SUBJ none ] ],
	    CONT [ HANDEL #hand,
		   INDEX #index,
		   KEY.HANDEL #hand,
		   --SP-H-CONS <! !> ] ] ].

common_noun_nocomp_synsem := common_noun_synsem &
  [ LOCAL [ CAT.VALENCE.COMPS < >,
	    CONT [ --SP-H-CONS #hcons,
		   H-CONS #hcons ] ] ].

noun_nocomp_synsem := common_noun_nocomp_synsem & nomod_synsem.

noun_nocomp_mod_synsem := common_noun_nocomp_synsem & temp_mod_synsem &
  [ LOCAL.CONT.--STEMLISZT <! relation !> ].

common_noun_ppcomp_synsem := common_noun_synsem &
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					[ CAT [ HEAD prep & [ PRD - ],
						VALENCE.COMPS *olist* ],
					  CONT.KEY #ckey & 
					      [ PREP #index ] ] ] >,
	    CONT [ KEY.NPREP #index,
		   COMPKEY #ckey,
		   --SP-H-CONS #hcons,
		   H-CONS #hcons ] ] ].

noun_ppcomp_synsem := common_noun_ppcomp_synsem & nomod_synsem &
  [ LOCAL.CONT.KEY diadic_nom_rel ].

temp_noun_ppcomp_synsem := common_noun_ppcomp_synsem & temp_mod_synsem &
  [ LOCAL [ CAT.VALENCE [ COMPS.FIRST [ LOCAL.CONT.KEY _of_rel,
					OPT + ],
			  SPR < [ LOCAL.CONT [ HANDEL #hand,
					       MODCONT.HANDEL #hand ] ] > ],
	    CONT [ KEY temp_rel,
		   --STEMLISZT <! relation !> ] ] ].

;; a way to meet
;; 09-09-97  This definition is temporarily replaced by the one following,
;; due to an error in the VM semdb.
#|
common_noun_vpcomp_synsem := common_noun_synsem & basic_scopedarg_synsem &
			     nomod_synsem &
  [ LOCAL [ CAT [ VALENCE.COMPS 
                     < #comp & @vp($vform=inf) & 
		       [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL.CONT.INDEX #inst,
				 CONT.MESSAGE hypo_rel ],
			 OPT -,
			 --ARG #arg ] >,
		  --SCOPEDARG #comp ],
	    CONT [ KEY.NOMARG #arg,
		   TOP-H #toph,
		   --STEMLISZT <! relation, pron_rel &
				            [ HANDEL #toph,
					      INST #inst &
						   [ PRONTYPE zero_pron ] ] !>,
		   H-CONS *diff-list* &
			  [ LIST #list,
			    LAST #last ],
		   --H-CONS <! scp_pr, scp_pr !> &
		            [ LIST #list,
			      LAST #middle ],
		   --SP-H-CONS [ LIST #middle,
				 LAST #last ] ] ] ].
|#
common_noun_vpcomp_synsem := common_noun_synsem &
			     nomod_synsem &
  [ LOCAL [ CAT [ VALENCE.COMPS 
                     < @vp($vform=inf) & 
		       [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL.CONT.INDEX #inst,
				 CONT [ HANDEL #hand,
					MESSAGE hypo_rel ] ],
			 OPT - ] > ],
	    CONT [ HANDEL #hand,
		   TOP-H #toph,
		   --STEMLISZT <! relation, pron_rel &
				            [ HANDEL #toph,
					      INST #inst &
						   [ PRONTYPE zero_pron ] ] !>,
		   H-CONS <! !> ] ] ].


mass_noun_synsem := noun_nocomp_synsem &
  [ LOCAL.CONT [ INDEX [ PNG 3sg,
			 DIVISIBLE + ],
		 --STEMLISZT <! relation !> ] ].

; One of the relations in --STEMLISZT is the support relation nominalize_rel 
; which is a subtype of nom_rel, but also introduces the NOMARG attribute 
; for the handle of the verbal relation.  The other rel is the verbal relation.

deverbal_noun_synsem := common_noun_synsem & nomod_synsem &
  [ LOCAL.CONT [ --STEMLISZT <! nominalize_rel & [ NMZARG #hand ],
			        relation & #altkey & [ HANDEL #hand ] !>,
		 ALTKEY #altkey ] ].

deverbal_intr_noun_synsem := deverbal_noun_synsem & noun_nocomp_synsem.

deverbal_trans_noun_synsem := deverbal_noun_synsem & noun_ppcomp_synsem &
  [ LOCAL.CAT.VALENCE.COMPS.FIRST.OPT + ].

deverbal_mass_noun_synsem := deverbal_noun_synsem &
  [ LOCAL [ CAT.VALENCE.COMPS < >,
	    CONT.INDEX [ PNG 3sg,
			 DIVISIBLE + ] ] ].

deverbal_mass_noun_ppcomp_synsem := deverbal_noun_synsem & 
				    noun_ppcomp_synsem &
  [ LOCAL.CONT.INDEX [ PNG 3sg,
		       DIVISIBLE + ] ].

;; Make adj_noun's be of type pronominal_synsem, to block their appearance
;; as left member of noun-noun compounds.

adj_noun_synsem := ref_pro_synsem & nomod_synsem &
  [ LOCAL [ CAT [ VALENCE.SPR < synsem & [ LOCAL local ],
				synsem &
				[ LOCAL local &
					[ CAT [ HEAD det,
						VALENCE [ SUBJ none,
							  SPR *olist*,
							  COMPS *olist* ] ],
					  CONT.KEY def_rel &
					           [ BV #index,
						     RESTR #hand ] ],
				  OPT - ] >,
		  AGR #index ],
	    CONT [ HANDEL #hand,
		   INDEX #index,
		   KEY nominalize_rel & [ HANDEL #hand,
					  INDEX #index ] ] ] ].

adj_noun_personal_synsem := adj_noun_synsem &
  [ LOCAL.CONT.INDEX.PNG 3pl].

adj_noun_abstract_synsem := adj_noun_synsem &
  [ LOCAL [ CAT.VALENCE.SPR < synsem, synsem & [ LOCAL.CAT.HEAD.POSS - ] >,
	    CONT.INDEX.PNG 3sg ] ].

partitive_noun_synsem := noun_synsem &
  [ LOCAL [ CAT [ VALENCE [ SUBJ none,
			    SPR  < [ LOCAL local &
					   [ CAT.VALENCE [ SPR  *olist*,
							   COMPS *olist* ],
					     CONT [ KEY degree_rel,
						    ALTKEY [ HANDEL #hand,
							     ARG #index ] ] ],
				     OPT + ] >, 
			    COMPS < [ LOCAL local &
					    [ CAT [ HEAD prep & [ PRD -],
						    VALENCE.COMPS *olist* ],
					      CONT.KEY #ckey & _of_rel &
						  [ HANDEL #chand, 
						    PREP #cind ] ],
				      OPT + ] > ],
		  MOD no-mod ],
	    CONT [ HANDEL #hand,
		   INDEX #index,
		   KEY #key,
		   ALTKEY #altkey,
		   LISZT <! part_of_rel & #key & [ HANDEL #phand,
						   INST #index,
						   SET  #chand,
						   NPREP #cind ],
			    quant_or_wh_rel & #altkey & [ HANDEL #hand,
							  BV #index,
							  RESTR #phand ] !>,
		   MODCONT.LISZT <! !>,
		   COMPKEY #ckey ] ] ].

basic_intr_noun_word := hcons_word & affix_bearing &
  [ SYNSEM common_noun_nocomp_synsem &
	   [ LOCAL.CONT.--STEMLISZT <! relation !> ] ].

intr_noun_word := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT.VALENCE.SPR < [ LOCAL.CONT.KEY quant_or_wh_rel ] >,
		     CONT.KEY reg_nom_rel ] ] ].

intr_temp_noun_word := basic_intr_noun_word & 
  [ SYNSEM noun_nocomp_mod_synsem &
	   [ LOCAL [ CAT.VALENCE.SPR < [ LOCAL.CONT.KEY quant_or_wh_rel ] >,
		     CONT.KEY temp_rel ] ] ].

irreg_intr_noun_word := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT.VALENCE.SPR < [ LOCAL.CONT.KEY quant_or_wh_rel ] >,
		     CONT.KEY basic_nom_rel ] ] ].

intr_temp_noun_nomod_word := basic_intr_noun_word & 
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.VALENCE.SPR < [ LOCAL.CONT.KEY quant_or_wh_rel ] >,
		     CONT.KEY temp_rel ] ] ].

temp_noun_ppcomp_word := hcons_word & affix_bearing &
  [ SYNSEM temp_noun_ppcomp_synsem &
	   [ LOCAL.CONT.--STEMLISZT <! relation !> ] ].

temp_noun_ppcomp_nomod_word := hcons_word & affix_bearing &
  [ SYNSEM common_noun_ppcomp_synsem & nomod_synsem &
	   [ LOCAL.CONT.--STEMLISZT <! temp_rel !> ] ].

noun_ppcomp_word := hcons_word & affix_bearing &
  [ SYNSEM noun_ppcomp_synsem &
	   [ LOCAL [ CAT.VALENCE.COMPS.FIRST.OPT +,
		     CONT.--STEMLISZT <! relation !> ] ] ].

noun_ppof_word := noun_ppcomp_word &
  [ SYNSEM.LOCAL.CONT.COMPKEY _of_rel ].

noun_ppin_word := noun_ppcomp_word &
  [ SYNSEM.LOCAL.CONT.COMPKEY _in_rel ].

noun_vpcomp_word := hcons_word & affix_bearing &
  [ SYNSEM common_noun_vpcomp_synsem ].

deverbal_noun_intr_word := hcons_word & affix_bearing &
  [ SYNSEM deverbal_intr_noun_synsem ].

deverbal_noun_trans_word := hcons_word & affix_bearing &
  [ SYNSEM deverbal_trans_noun_synsem ].

mass_noun_word := hcons_word & non_affix_bearing &
  [ SYNSEM mass_noun_synsem ].

deverbal_mass_noun_word := hcons_word & non_affix_bearing &
  [ SYNSEM deverbal_mass_noun_synsem ].

deverbal_mass_noun_ppcomp_word := hcons_word & non_affix_bearing &
  [ SYNSEM deverbal_mass_noun_ppcomp_synsem ].

plur_noun_word := hcons_word & non_affix_bearing &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL.CONT [ INDEX.PNG 3pl,
			  --STEMLISZT <! relation !> ] ] ].

part_noun_word := que_word &
  [ SYNSEM partitive_noun_synsem ].

;;
;; Lexical NPs
;;
;;   (proper names, pronouns, names of weekdays, ...)

np_word := norm_no_affix_word & 
  [ SYNSEM ref_synsem &
	 [ LOCAL.CAT [ HEAD pnoun,
		       VALENCE [ SPR < >,
				 SUBJ none,
				 COMPS < > ] ] ] ].


; Proper names should formally introduce an additional relation in the liszt 
; for the implied definite quantifier.  The following can be viewed as an 
; abbreviation, to be expanded unambiguously in post-processing of the
; semantics (which is also where e.g. underspecified quantifier scopes get
; fully specified).

np_sing_word := np_word &
  [ SYNSEM noun_synsem & nomod_synsem &
	   [ LOCAL.CONT [ HANDEL #hand,
			  INDEX.PNG 3sg,
			  --STEMLISZT <! basic_nom_rel &
				       [ HANDEL #hand ] !> ] ] ].

proper_name_sg := np_sing_word & 
  [ SYNSEM.LOCAL.CONT [ HANDEL #hand, 
			TOP-H #hand,
			KEY named_rel ] ].

; Lexical NP plurals - maybe only in British English? ("IBM are hiring again.")
;
np_pl_word := np_word &
  [ SYNSEM noun_synsem & nomod_synsem &
	   [ LOCAL.CONT.INDEX.PNG 3pl ] ].

personal_pro := np_word &
  [ SYNSEM ref_pro_synsem & nomod_synsem &
	   [ LOCAL.CONT [ HANDEL #hand,
			  TOP-H #hand,
			  --STEMLISZT <! pron_rel !>,
			  KEY.HANDEL #hand ] ] ].

reflexive_pro := personal_pro &
  [ SYNSEM.LOCAL [ CAT [ HEAD.CASE acc,
			 AGR #agr ],
		   CONT [ INDEX #agr,
			  KEY refl_pro_rel ] ] ].

reciprocal_pro := personal_pro &
  [ SYNSEM.LOCAL [ CAT [ HEAD.CASE acc,
			 AGR #agr ],
		   CONT [ INDEX #agr,
			  KEY recip_pro_rel ] ] ].

; 'yours'
poss_pro_np := que_word & nonque &
  [ SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD pnoun & [ POSS + ],
			   AGR #index,
			   VALENCE [ SUBJ none,
				     SPR < >,
				     COMPS < > ] ],
		     CONT [ HANDEL #hand,
			    INDEX #index,
			    --STEMLISZT <! pron_rel & 
					   [ HANDEL #phand,
					     INST #eind &
						    [ PRONTYPE std_pron ] ],
					   def_rel & #key & 
					   [ HANDEL #hand,
					     BV #index,
					     RESTR #phand ],
					   poss_rel & #ckey & 
					   [ HANDEL #hand,
					     POSSR #eind,
					     POSSD #index ] !>,
			    KEY #key,
			    ALTKEY #ckey,
			    H-STORE <! #hand !> ] ] ] ].

; Expletive pronouns "there" and "it"
expletive_it_word := norm_no_affix_word &
  [ SYNSEM non_ref_pro_synsem &
	 [ LOCAL.CONT [ INDEX it-ind,
			--STEMLISZT <! !>,
			KEY no_rel ] ] ].

expletive_there_word := norm_no_affix_word &
  [ SYNSEM non_ref_pro_synsem &
	 [ LOCAL.CONT [ INDEX there-ind,
			 --STEMLISZT <! !>,
			 KEY no_rel ] ] ].

; ERB (31-10-96) A hack:  I want the wh_interrogs to be able to
; get their hands on the which_rel so they can put it on the PARAMS
; list, but QSTORE isn't working yet.  So I am making the QUE value
; of wh_pro_word, wh_adverb_word, and wh_poss_word be the handle of
; the which_rel, so that this gets passed up in such a way that I can see it.

; DPF (14-01-97) To maintain monotonicity, we don't put the handle of the
; WH-operator in H-STORE, but only in QUE, where wh_interrog phrases know
; to look in order to add the handle to their PARAMS list.

; DPF (4-Sept-97) For the moment, add the handle to H-STORE, to get the current
; VM dialogues working, until we can convince our colleagues of the better
; analysis

; who, what
wh_pro_word := que_word & 
  [ SYNSEM ref_pro_synsem & nomod_synsem &
	 [ LOCAL [ CAT [ AGR #index,
			 VALENCE [ SPR < >,
				   COMPS < > ] ],
		   CONT [ HANDEL #hand,
			  INDEX #index & [ PNG 3sg ],
			  --STEMLISZT <! [ HANDEL #rhand ],
				         which_rel & [ HANDEL #hand,
						       BV #index,
						       RESTR #rhand ] !>,
			  H-STORE <! #hand !> ] ],
	   NON-LOCAL.QUE <! #hand !> ] ].

rel_pro_word := rel_word & nonhstore &
  [ SYNSEM ref_pro_synsem & nomod_synsem &
	 [ LOCAL [ CAT [ VALENCE [ SPR < >,
				 COMPS < > ],
			 AGR #index ],
		   CONT [ HANDEL #hand,
			  --STEMLISZT <! [ HANDEL #hand,
					   INST #index ] !> ] ],
	   NON-LOCAL.REL <! #index !> ] ].

generic_pro_word := que_word &
  [ SYNSEM noun_synsem & nomod_synsem &
	   [ LOCAL [ CAT [ HEAD cnoun,
	                   VALENCE [ SPR < >,
				     SUBJ none,
				     COMPS < > ] ],
		     CONT [ HANDEL #dethand,
			    --STEMLISZT <! reg_nom_rel, #altkey & quant_rel !>,
			    KEY [ HANDEL #hand,
				  INST #inst & [ PNG 3sg ] ],
			    ALTKEY #altkey & 
				   [ HANDEL #dethand,
				     BV #inst,
				     RESTR #hand ],
			    H-STORE <! #dethand !> ] ],
	     NON-LOCAL.QUE *e-dlist* ] ].

deictic_pro_word := que_word & nonque &
  [ SYNSEM ref_pro_synsem & nomod_synsem &
	   [ LOCAL [ CAT [ HEAD pnoun,
			   VALENCE [ SPR < >,
				     SUBJ none,
				     COMPS < > ] ],
		     CONT [ HANDEL #dhand,
			    --STEMLISZT <! reg_nom_rel, 
				         demonstrative_rel & #altkey &
				         [ HANDEL #dhand,
					   BV #ind,
					   RESTR #hand ] !>,
			    H-STORE <! #dhand !>,
			    KEY [ HANDEL #hand,
				  INST #ind ],
			    ALTKEY #altkey ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADJECTIVES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (See prep_synsem definition for discussion of ARG attribute.)

; Predicative adjectives introduce an EVENT attribute in a separate support 
; relation, as do predicative PPs (and perhaps also pred. nominals, someday).

; Assume that if adjectives have a specifier, it will be either a measure-NP,
; as in "two feet tall', 'a week later"; or a degree_adverb like "very".

basic_adj_synsem := subst_synsem &
  [ LOCAL [ CAT [ HEAD adj,
		  VALENCE [ SUBJ synsem & #subj & 
				 [ LOCAL local &
					 [ CAT [ HEAD nominal,
						 VALENCE [ SPR *olist*,
							   COMPS *olist* ] ],
					   THROLE arg1 ] ],
			    SPR < synsem &
				  [ LOCAL local &
					  [ CAT [ VALENCE [ SPR *olist*,
							    COMPS *olist* ],
						  ROOT na ],
					    CONT [ KEY degree_rel &
						       [ HANDEL #ahand,
							 DARG #darg ] ] ],
				    OPT + ] > ],
		  MOD [ CAT [ HEAD cnoun &
				   [ POSS - ],
			      VALENCE [ SPR < synsem >,
					COMPS *olist* ],
			      MOD no-mod ],
			CONT [ HANDEL #nhand,
			       INDEX #ind & individual,
			       MODCONT [ HANDEL #mchand,
					 KEY.HANDEL #mchand ] ] ] ],
	    CONT [ INDEX #ind,
		   --STEMLISZT.LIST < adj_rel & #key &
					  [ HANDEL #ahand,
					    NARG #ind,
					    DIM #darg ], ... >,
		   KEY #key,
		   MODCONT [ HANDEL #nhand,
			     INDEX #ind,
			     KEY #key,
			     LISZT  <! !> ] ],
	    ARG-S < #subj, ... > ] ].

adj_synsem := basic_adj_synsem &
  [ LOCAL.CONT [ HANDEL #hand,
		 KEY.HANDEL #hand ] ].

nonprd_synsem := modifier_synsem &
  [ LOCAL.CAT.HEAD.PRD - ].

prd_synsem := modifier_synsem &
  [ LOCAL.CAT.HEAD.PRD + ].

intrans_adj_synsem := adj_synsem &
  [ LOCAL.CAT [ VALENCE.COMPS < >,
		POSTHEAD - ] ].

attr_adj_synsem := intrans_adj_synsem & nonprd_synsem.

pred_adj_synsem := adj_synsem & prd_synsem.

intrans_pred_adj_synsem := intrans_adj_synsem & prd_synsem.

;;; We should have a trans_adj_attr_synsem too, for 'easy' and the likes ...

trans_adj_pred_synsem := pred_adj_synsem  &
  [ LOCAL.CAT.VALENCE.COMPS < [ LOCAL local &
				      [ CAT [ HEAD prep & [ PRD - ],
					      VALENCE.COMPS *olist* ] ] ] > ].

; e.g. 'able' - Can't use equi_intrans_lt since it specifies a fig_gnd_rel, 
; which is incompatible with adj_rel.  Also, the subj index of adjectives is 
; bound to the NARG role, not the GND role of equi verbs; the NARG role is used
; to give a uniform treatment of semantics of noun modification for adjectives.

reg_adj_equi_synsem := pred_adj_synsem & inf_intrans_subst &
  [ LOCAL [ CAT.VALENCE 
	     [ SUBJ.LOCAL.CONT.INDEX #subjind,
	       COMPS < [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL local &
						       [ CONT.INDEX #subjind ],
				 CONT.HANDEL #hand ],
			 OPT + ], ...> ],
	    CONT.KEY adj_varg_rel &
		     [ NARG #subjind,
		       VARG #hand ] ] ].

reg_adj_atrans_synsem := pred_adj_synsem & inf_intrans_subst &
  [ LOCAL [ CAT.VALENCE [ SUBJ.LOCAL.CONT.INDEX it-ind,
			  COMPS < [ LOCAL.CONT.HANDEL #hand,
				    OPT - ], ...> ],
	    CONT [ --STEMLISZT <! relation !>,
		   KEY adj_varg_rel &
		       [ VARG #hand ] ] ] ].

scoping_adj_synsem := pred_adj_synsem & scopedarg_synsem &
  [ LOCAL [ CAT [ VALENCE.--KEYCOMP #comp,
		  --SCOPEDARG #comp & [ --ARG #arg ] ],
	    CONT [ --STEMLISZT <! relation !>,
		   KEY adj_varg_rel &
			       [ VARG #arg ] ] ] ].

reg_adj_cp_synsem := scoping_adj_synsem & cp_intrans_subst.

reg_adj_atrans_cp_synsem := reg_adj_cp_synsem &
  [ LOCAL [ CAT.VALENCE [ SUBJ.LOCAL.CONT.INDEX it-ind ] ] ].

adj_word := norm_word &
 [ SYNSEM adj_synsem &
	  [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL.CONT.INDEX #ind,
		    CONT [ KEY.NARG #ind,
			   --STEMLISZT <! adj_rel !> ] ] ] ].

reg_adj_word := adj_word & affix_bearing.

; Make these [POSTHEAD -] to prevent them from being postnominal modifiers
reg_intrans_adj := reg_adj_word & nonhcons &
  [ SYNSEM adj_synsem & modifier_synsem &
	   [ LOCAL.CAT [ VALENCE.COMPS < >,
			 POSTHEAD - ] ] ].

attr_intrans_adj := reg_adj_word &
  [ SYNSEM attr_adj_synsem ].

pred_intrans_adj := reg_intrans_adj &
  [ SYSNEM pred_adj_synsem ].

intrans_adj_oddsem := norm_no_affix_word &
  [ SYNSEM intrans_adj_synsem ].

;; doctor's appointment
compound_adj_word := intrans_adj_oddsem &
  [ SYNSEM attr_adj_synsem &
	 [ LOCAL 
	   [ CAT.MOD.CONT [ HANDEL #hand,
			    INDEX #nind ],
	     CONT [ HANDEL #hand,
		    --STEMLISZT <! relation & [ INST #aind ],
				     unspec_rel & [ HANDEL #hand,
						    HINST #nind,
						    NHINST #aind ] !> ] ] ] ].

;; {OPT +] is on reg_trans_adj and not on trans_adj_synsem because the 
;; comparison_lr uses trans_adj_synsem and requires OPT -. Same for semantics.

reg_trans_adj := reg_adj_word &
  [ SYNSEM trans_adj_pred_synsem  &
	   [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL.CONT.KEY.NARG #index ,
					   OPT +] >, 
		     CONT.--STEMLISZT <! [ PREPARG #index ] !> ] ] ].

; These 'irregular' types are for multi-word adjectives, which cannot
; be affix-bearing under the current regime.  They should be eliminated
; once we do better with multi-words.

irreg_adj_word := adj_word & non_affix_bearing.

irreg_attr_adj := irreg_adj_word &
  [ SYNSEM attr_adj_synsem &
	  [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL.CONT [ HANDEL #hand,
						  INDEX #ind & non_expl-ind ],
		    CONT.KEY [ HANDEL #hand,
			       NARG #ind ] ] ] ].

irreg_pred_intrans_adj := irreg_adj_word &
  [ SYNSEM intrans_pred_adj_synsem &
	  [ LOCAL [ CAT [ HEAD.PRD +,
			  VALENCE.SUBJ.LOCAL.CONT [ HANDEL #hand,
						    INDEX #ind & non_expl-ind ] ],
		    CONT.KEY [ HANDEL #hand,
			       NARG #ind ] ] ] ].

irreg_trans_adj := irreg_adj_word &
  [ SYNSEM trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL.CONT.KEY.NARG #index,
					   OPT + ] >,
		     CONT.--STEMLISZT <! [ PREPARG #index ] !> ] ] ].

reg_adj_equi_word := norm_word & affix_bearing &
  [ SYNSEM reg_adj_equi_synsem &
	   [ LOCAL.CONT.--STEMLISZT <! adj_rel !> ] ].

reg_adj_atrans_word := norm_word & affix_bearing &
  [ SYNSEM reg_adj_atrans_synsem ].

reg_adj_atrans_cp_word := hcons_word & affix_bearing &
  [ SYNSEM reg_adj_atrans_cp_synsem ].



ord_rel := adj_rel &
  [ ORD integer ].

ordinal_adj_word := reg_intrans_adj &
  [ SYNSEM.LOCAL.CONT.KEY ord_rel ].

; How is Sandy?  How does Tuesday look?
; To avoid second-order quantification, we use an abstr_rel which vaguely
; relates the argument of the adj_rel to the restrictor of the WH operator.

#|
wh_adjective_word := que_word & 
  [ SYNSEM basic_adj_synsem & 
      [ LOCAL [ CAT [ POSTHEAD +,
		      VALENCE [ SUBJ.LOCAL.CONT.INDEX #ind,
				COMPS < > ] ],
		CONT [ HANDEL #hand,
		       INDEX #ind,
		       --STEMLISZT <! adj_rel & [ HANDEL #hand,
						  NARG #ind ],
				      which_rel & [ HANDEL #whhand,
						    BV #propind,
						    RESTR #restr ],
				      relation & [ HANDEL #restr,
						   INST #propind,
						   ARG #ind ] !>,
		       MODCONT.HANDEL #hand,
		       H-STORE <! #whhand !> ] ],
	    NON-LOCAL.QUE <! #whhand !> ] ].

wh_adjective_word := que_word & 
  [ SYNSEM basic_adj_synsem & 
      [ LOCAL [ CAT [ POSTHEAD +,
		      VALENCE [ SUBJ.LOCAL.CONT.INDEX #ind,
				COMPS < > ] ],
		CONT [ HANDEL #hand,
		       INDEX #ind,
		       --STEMLISZT <! adj_rel & [ HANDEL #restr,
						  NARG #ind ],
				      which_rel & [ HANDEL #whhand,
						    BV #propind,
						    RESTR #restr ],
				      abstr_rel & [ HANDEL #hand,
						    INST #propind,
						    ARG #ind ] !>,
		       MODCONT.HANDEL #hand,
		       H-STORE <! #whhand !> ] ],
	    NON-LOCAL.QUE <! #whhand !> ] ].
|#


wh_adjective_word := que_word & 
  [ SYNSEM basic_adj_synsem & 
      [ LOCAL [ CAT [ POSTHEAD +,
		      VALENCE [ SUBJ.LOCAL.CONT.INDEX #ind,
				COMPS < > ] ],
		CONT [ HANDEL #hand,
		       INDEX #propind,
		       --STEMLISZT <! adj_rel & [ HANDEL #restr,
						  NARG #propind ],
				      which_rel & [ HANDEL #whhand,
						    BV #propind,
						    RESTR #restr ],
				      abstr_rel & [ HANDEL #hand,
						    INST #ind,
						    ARG3 #propind ] !>,
		       MODCONT.HANDEL #hand,
		       H-STORE <! #whhand !> ] ],
	    NON-LOCAL.QUE <! #whhand !> ] ].


; two-hour meeting, two-foot tall
measure_adj_attr_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD adj &
		       [ PRD - ],
		  VALENCE [ SUBJ none,
			    SPR < synsem &
				  [ LOCAL local &
					  [ CAT [ VALENCE [ SPR *olist*,
							    COMPS *olist* ],
						  ROOT na ],
					    CONT.KEY const_rel & 
						     [ HANDEL #numhand ] ],
				    OPT - ] >,
			    COMPS < > ],
		  MOD [ CAT [ HEAD cnoun &
				   [ POSS - ],
			      VALENCE [ SPR < synsem >,
					COMPS *olist* ] ],
			CONT [ HANDEL #hand,
			       INDEX #ind ] ] ],
	    CONT mrs &
		 [ HANDEL #hand,
		   --STEMLISZT <! meas_adj_rel & #key &
				  [ HANDEL #hand,
				    NARG #ind,
				    MEAS #numhand ] !>,
		   KEY #key,
		   MODCONT [ HANDEL #hand,
			     INDEX #ind,
			     KEY #key,
			     LISZT  <! !> ] ],
	    ARG-S < > ] ].

meas_adj_word := norm_no_affix_word &
 [ SYNSEM measure_adj_attr_synsem ].


;; Verbal synsem for present and passive participles, which can modify N-bars

;; Titles like 'mister', 'professor' which modify proper names

title_rel :< basic_nom_rel.

title_synsem := modifier_synsem & 
  [ LOCAL [ CAT [ HEAD adj,
		  VALENCE [ SUBJ none,
			    SPR < >,
			    COMPS < > ],
		  POSTHEAD -,
		  MOD [ CAT [ HEAD noun &
				   [ POSS - ],
			      VALENCE [ SPR *olist*,
					COMPS *olist* ] ],
			CONT [ HANDEL #hand,
			       INDEX #ind,
			       KEY named_rel ] ] ],
	    CONT [ HANDEL #hand,
		   INDEX #ind,
		   --STEMLISZT <! title_rel & #key & [ INST #ind ] !>,
		   KEY #key,
		   MODCONT [ INDEX #ind,
			     KEY #key,
			     LISZT <! !> ] ] ] ].
title_word := norm_no_affix_word &
  [ SYNSEM title_synsem ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PREPOSITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Most prepositions can be modifiers.  If they act as a modifier, we'll assume
; they have no subject (leaving for some distinct analysis Carl's "A unicorn
; at the helm, the ship sailed into the horse latitudes."  This lets us use a
; single attribute, ARG, for the index of the phrase modified, or for the
; index of the subject of the PP, in a predicative construction.

; Prepositions also have a distinguished role PREP which has as value the
; index of the object of the preposition.  We could introduce distinct role
; names for each preposition (e.g. "ON" for on_rel, "IN" for in-rel) but this
; would complicate the definition of the prep_synsem type, since it needs to
; know the role name to which it assigns the object's index.

; An EVENT attribute is needed for PPs (and other substs used predicatively)
; occurring as complements of the copula as in "the meeting is on Tuesday",
; but on this analysis not postnominally.  This EVENT role is introduced in a
; separate support_rel, supplied by the copula.

; Prepositions, like adjectives and participial verbs, can have either
; predicative or nonpredicative synsems, so each ordinary preposition
; (actually the PP headed by the P) can unify with either a pred. or non-pred.
; constraint, which resolves the underspecification.  One assumption here is 
; that there are no contexts which are underspecified for the PRD feature 
; for PPs.

; N.B. The LISZT value of basic_prep_synsem cannot be a singleton list, since
; adverbs like "when" inherit this synsem, and add additional rels lexically.

basic_prep_synsem := lex_synsem & 
  [ LOCAL [ CAT.HEAD prep,
	    CONT [ --STEMLISZT <! !>,
		   MODCONT.LISZT.LIST < prep_rel, ... > ] ] ].

prep_synsem_unspec_subj := basic_prep_synsem &
  [ LOCAL [ CAT [ VALENCE.COMPS < synsem & 
				  [ LOCAL local &
					  [ CONT [ HANDEL #hand,
						   INDEX #objind,
						   KEY #ckey ] ] ], ... >,
		  POSTHEAD + ],
	    CONT [ HANDEL #hand,
		   INDEX  #objind,
		   MODCONT [ KEY #key,
			     LISZT.LIST < #key, ... > ],
		   KEY #key & [ PREP #objind ],
		   COMPKEY #ckey ] ] ].

; For lexical prepositions taking at least one complement
prep_synsem := prep_synsem_unspec_subj & unsat_two_arg_subst.

; For predicative Ps and PPs like "when", which have an NP subject:

prep_p_synsem := basic_prep_synsem & subst_synsem &
  [ LOCAL [ CAT.VALENCE.SUBJ.LOCAL [ CAT [ HEAD noun &
						[ POSS - ],
					   VALENCE [ SUBJ none,
						     COMPS *olist* ] ],
				     CONT.INDEX #subjind,
                                     THROLE arg1 ],
	    CONT.KEY [ ARG #subjind ] ] ].

; Ps and PPs that can be modifiers.
; These are also assumed to allow modification by another PP.
; Block PP modification of infinitival "to" - spurious ambiguity.

#|
mod_n_or_vp_synsem := synsem &
  [ LOCAL [ CAT [ VALENCE.SPR < synsem & [ LOCAL local &
					   [ CAT [ HEAD adv,
						   VALENCE [ SPR *olist*,
							     COMPS *olist* ] ],
					       CONT.KEY degree_rel &
						   [ DARG #ind ] ],
					   OPT + ] >,
		  MOD local & [ CAT [ HEAD subst,
				      VALENCE [ SPR < synsem >,
						COMPS *olist* ],
				      ROOT na ],
				CONT [ HANDEL #hand,	
				       INDEX #ind,
				       MODCONT.HANDEL #hand,
				       MESSAGE #msg ] ] ],
	    CONT [ KEY.ARG #ind,
		   MODCONT [ HANDEL #hand,
			     INDEX #ind,
			     MESSAGE #msg ] ] ] ].
|#

mod_n_or_vp_synsem := synsem &
  [ LOCAL [ CAT [ VALENCE.SPR < synsem & [ LOCAL local &
					   [ CAT [ HEAD adv,
						   VALENCE [ SPR *olist*,
							     COMPS *olist* ] ],
					       CONT.KEY degree_rel &
						   [ DARG #ind ] ],
					   OPT + ] >,
		  MOD local & [ CAT [ HEAD subst,
				      VALENCE [ SPR < synsem >,
						COMPS *olist* ],
				      ROOT na ],
				CONT [ HANDEL #hand,	
				       INDEX #ind,
				       MODCONT.HANDEL #hand,
				       MESSAGE #msg ] ] ],
	    CONT [ KEY.ARG #ind,
		   MODCONT [ HANDEL #hand,
			     INDEX #ind,
			     MESSAGE #msg ] ] ] ].

prep_p_mod_synsem := prep_p_synsem & mod_n_or_vp_synsem.

prep_prd_synsem := prep_synsem & prep_p_mod_synsem & prd_synsem.

prep_nonprd_synsem := prep_synsem & prep_p_mod_synsem & nonprd_synsem.

prep_prd_or_nonprd_synsem := prep_synsem & prep_p_mod_synsem & lex_synsem.

; Strict transitive prepositions which can be either predicative or non-pred:

trans_prep_synsem := prep_prd_or_nonprd_synsem &
  [ LOCAL [ CAT.VALENCE.COMPS < [ LOCAL.CONT [ HANDEL #hand,
					       INDEX #index ],
				  OPT - ] >,
	    CONT [ HANDEL #hand,
		   INDEX #index,
		   MODCONT.LISZT <! prep_rel !> ] ] ].

ditrans_prep_synsem := prep_prd_or_nonprd_synsem & unsat_three_arg_subst &
  [ LOCAL [ CAT.VALENCE.COMPS < *top*, 
				[ LOCAL.CONT.MODCONT.LISZT [ LIST #list,
							     LAST #last ] ] >,
	    CONT.MODCONT.LISZT *diff-list* &
			      [ LIST < prep_rel . #list >,
				LAST #last ] ] ].

lex_pp_synsem := prep_p_mod_synsem &
  [ LOCAL [ CAT.VALENCE.COMPS < >,
	    CONT [ MODCONT.LISZT <! #key !>,
		   KEY #key ] ] ].

lex_pp_nomod_synsem := prep_p_synsem &
  [ LOCAL [ CAT [ HEAD,PRD +,
		  VALENCE [ SPR < >,
			    COMPS < > ],
		  MOD no-mod ],
	    CONT [ MODCONT.LISZT <! #key !>,
		   KEY #key ] ] ].

; Ordinary prepositions:

prep_word := norm_no_affix_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc,$cont=[INDEX non_expl-ind]) > ]].

reg_prep_word := prep_word &
  [ SYNSEM.LOCAL.CAT.VALENCE.COMPS < [ LOCAL local &
					     [ CONT.KEY reg_nom_rel ] ] > ].

; 'from now on', maybe 'from two to four'
ditrans_prep_word := norm_no_affix_word &
  [ SYNSEM ditrans_prep_synsem &
	 [ LOCAL.CAT.VALENCE.COMPS < @np($case=acc) & [ OPT - ], 
				     synsem & [ LOCAL local &
						      [ CAT [ HEAD.PRD -,
							      ROOT na ] ],
						OPT - ] > ] ].

prep_cp_word := norm_no_affix_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT.VALENCE.COMPS < @cp($vform=fin) &
				[ LOCAL [ CAT.HEAD.INV -,
					  CONT.MESSAGE propositional_rel ] ] >
				   ] ].

; Prepositions that don't modify nominals - e.g, 'until'
prep_no_n_mod_word := prep_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.PRD -,
		       MOD.CAT.VALENCE.SUBJ synsem ] ].


; "Case-marking" prepositions, which cannot be modifiers
; and (let's assume) also cannot be modified, so stipulate [ SUBJ none ].

prep_nomod_word := norm_no_affix_word &
  [ SYNSEM prep_synsem_unspec_subj &
	 [ LOCAL [ CAT [ HEAD.PRD -,
			 VALENCE [ SUBJ none,
				   SPR < >,
				   COMPS < @np($case=acc) &
					   [ OPT - ] > ],
			 MOD no-mod ],
		   CONT.MODCONT.LISZT <! relation !> ] ] ].

; nominal "of"
prep_nomod_empty_word := prep_nomod_word &
  [ SYNSEM.LOCAL.CONT [ INDEX #ind,
			KEY.PREP #ind ] ].

; Lexical PPs

pp_word := norm_no_affix_word &
  [ SYNSEM lex_pp_synsem ].

pp_nomod_word := norm_no_affix_word &
  [ SYNSEM lex_pp_nomod_synsem ].

; Prepositions with lexically idiosyncratic complements:

prep_idiom_word := norm_no_affix_word &
  [ SYNSEM trans_prep_synsem ].

prep_idiom_pp_word := prep_idiom_word &
  [ SYNSEM.LOCAL.CAT.VALENCE.COMPS < @pp() > ].

prep_idiom_nomod_word := norm_no_affix_word &
  [ SYNSEM prep_synsem_unspec_subj &
	 [ LOCAL.CAT [ HEAD.PRD -,
		       VALENCE [ SPR < >,
				 COMPS < [ OPT - ] > ],
		       MOD no-mod ] ] ].

;; Temporal prepositions:

; Special type for "at" taking hours
;    'at five oclock'
;    'at fifteen to six'

at_prep_word := norm_no_affix_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT.VALENCE.COMPS
		 < @np($case=acc) & 
		   [ LOCAL.CONT.KEY hour_rel ], ...> ] ].

; Prepositions like "before" that take a prep_noun like "now, then".
;   'before now', 'since then'

before_prep_word := norm_no_affix_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT.VALENCE.COMPS 
		 < synsem & 
		   [ LOCAL local &
			   [ CAT [ HEAD prep_noun,
				   VALENCE [ SUBJ synsem,
					     COMPS *olist* ] ],
			     CONT.KEY temp_loc_rel ] ], ... > ] ].

; "ten minutes to three" - "to" as head
; Use POSTHEAD to allow "half past three" and "three thirty" but block
;      "?thirty past three" and "*three half"

hour_prep_word := norm_no_affix_word &
  [ SYNSEM nomod_synsem &
	 [ LOCAL [ CAT [ HEAD pnoun &
			      [ POSS - ],
			 VALENCE [ SPR < synsem & @np($case=acc) &
					 [ LOCAL [ CAT.POSTHEAD -,
						   CONT [ INDEX #minute,
							  KEY minute_rel ] ],
					   OPT - ] >,
				   SUBJ none,
				   COMPS < synsem & @np($case=acc) & 
					   [ LOCAL.CONT 
						     [ INDEX #hour,
						       KEY numbered_hour_rel &
							   #ckey ],
					     OPT - ] > ] ],
		   CONT nom-obj &
		       [ HANDEL #hand,
			 INDEX #ind & [ PNG 3sg ],
			 LISZT <! #key !>,
			 KEY #key & hour_prep_rel &
				    [ HANDEL #hand,
				      INST #ind,
				      MINUTE-IND #minute,
				      HOUR-IND #hour ],
			 COMPKEY #ckey ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADVERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Adverbs modify VPs, either pre-head or post-head (or both).
; Sentence-initial adverbials are treated as extractions of post-VP modifiers,
; unless the adverbial is a pre-head modifiier. Otherwise, it would be hard to
; block post-S attachment along with post-VP attachment, which would give 
; spurious ambiguity.

basic_adverb_synsem := basic_scopedarg_synsem &
  [ LOCAL [ CAT [ HEAD adv &
		       [ PRD - ],
		  VALENCE [ SUBJ none,
			    COMPS < > ],
		  MOD local & #mod &
		       [ CAT.HEAD adverbee,
			 CONT [ MODCONT.INDEX #vevent,
				MESSAGE #msg ] ],
		  --SCOPEDARG [ LOCAL #mod,
				--ARG #arg ] ],
	    CONT [ HANDEL #hand,
		   INDEX #vevent,
		   --STEMLISZT <! !>,
		   KEY #key & adv_rel &
			      [ HANDEL #hand,
				ARG #arg ],
		   H-CONS <! !>,
		   --H-CONS #hcons,
		   MODCONT [ INDEX #vevent,
			     KEY #key,
			     LISZT <! #key !>,
			     H-CONS #hcons & <! scp_pr, scp_pr !>,
			     MESSAGE #msg ] ] ] ].

;; Adverbs can probably themselves take adverbs as specifiers, but we prevent
;; these for now, pending more data about constraints, since we don't want
;; e.g. "together again" as a SpecH phrase.

spec_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT.VALENCE.SPR < synsem & 
			      [ LOCAL local &
				      [ CAT [ HEAD no_head,
					      VALENCE [ SUBJ none,
							SPR *olist*,
							COMPS *olist* ],
					      ROOT na ],
					CONT [ KEY.DARG #hand,
					       MODCONT.INDEX #vevent ] ],
				OPT + ] >,
	    CONT [ HANDEL #hand,
		   INDEX #vevent ] ] ].

; VP, PP, AP
adverb_synsem := spec_adverb_synsem &
  [ LOCAL.CAT.MOD.CAT [ VALENCE [ SUBJ synsem,
				  COMPS *olist* ],
	                ROOT na ] ].
; VP only
vp_adverb_synsem := spec_adverb_synsem &
  [ LOCAL.CAT.MOD.CAT [ HEAD v_or_g,
			VALENCE [ SUBJ synsem,
				  COMPS *olist* ],
	                ROOT na ] ].

; S or VP (for pre-head adverbs only)
s_or_vp_adverb_synsem := spec_adverb_synsem &
  [ LOCAL.CAT.MOD.CAT.VALENCE.COMPS *olist* ].

; For adverbs like "maybe" which take no degree specifier
s_or_vp_adverb_nospec_synsem := basic_adverb_synsem &
  [ LOCAL.CAT [ VALENCE.SPR < >,
		MOD.CAT.VALENCE.COMPS *olist* ] ].

adverb_word := hcons_word & non_affix_bearing & 
  [ SYNSEM adverb_synsem ].
    
adv_pre_word := hcons_word & non_affix_bearing & 
  [ SYNSEM s_or_vp_adverb_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].
    
adv_pre_word_nospec := hcons_word & non_affix_bearing & 
  [ SYNSEM s_or_vp_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].
    
adv_post_word := adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

vp_adverb_word := hcons_word & non_affix_bearing &
  [ SYNSEM vp_adverb_synsem ].
    
vp_adv_post_word := vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

; ERB (31-10-96) See notes near wh_pro_word.
; where, when, how
wh_adverb_word := que_word & 
  [ SYNSEM prep_p_mod_synsem & 
      [ LOCAL [ CAT [ POSTHEAD +,
		      VALENCE.COMPS < > ],
		CONT [ HANDEL #hand,
		       KEY #key,
		       MODCONT [ HANDEL #hand,
				 LISZT <! [ PREP #objind ] & #key, 
		    			  which_rel & [ HANDEL #hand,
							BV #objind,
							RESTR #restr ],
					  nom_rel & [ HANDEL #restr,
						      INST #objind ] !> ],
		       H-STORE <! #hand !> ] ],
	    NON-LOCAL.QUE <! #hand !> ] ].

rel_adverb_word := rel_word & 
  [ SYNSEM prep_p_mod_synsem & 
      [ LOCAL [ CAT [ POSTHEAD +,
		      VALENCE.COMPS < > ],
		CONT [ HANDEL #hand,
		       KEY #key,
		       MODCONT [ HANDEL #hand,
				 LISZT <! [ PREP #objind ] & #key, 
					  def_rel & [ HANDEL #hand,
						      BV #objind,
						      RESTR #restr ],
				  	  nom_rel & [ HANDEL #restr,
						      INST #objind ] !> ],
		       H-STORE <! #hand !> ] ],
	    NON-LOCAL.REL <! #objind !> ] ].


; 'here, there'
np_adverb_word := norm_no_affix_word &
  [ SYNSEM prep_p_mod_synsem & 
      [ LOCAL [ CAT [ HEAD prep_noun,
		      VALENCE.COMPS < >,
		      POSTHEAD + ],
		CONT [ HANDEL #hand,
		       KEY #key,
		       MODCONT [ HANDEL #hand,
				 LISZT <! loc_rel & #key & 
					  [ HANDEL #hand ] !> ] ] ] ] ].

; "on vacation"
pp_idiom_word := norm_no_affix_word &
  [ SYNSEM prep_p_mod_synsem &
      [ LOCAL [ CAT.VALENCE.COMPS < >,
		CONT [ HANDEL #hand,
		       MODCONT.LISZT.LIST < prep_rel & #key & 
					      [ HANDEL #hand ], ... > ,
		       KEY #key ] ] ] ].

comparison_spec_word := norm_no_affix_word &
  [ SYNSEM nomod_synsem &
	  [ LOCAL [ CAT [ HEAD adv,
			  VALENCE [ SUBJ none,
				    COMPS < >,
				    SPR < > ] ],
		    CONT [ HANDEL #hand,
			   INDEX #inst,
			   --STEMLISZT <! #key &
				        [ HANDEL #hand,
					  INST #inst
					  ] !>,
			   KEY #key ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DETERMINERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Determiners must have the KEY relation be the quantifier, since nouns
;; select their determiner in part based on the type of the quantifier rel.
;; The basic determiner synsem has a non-null value for its specifier; this is 
;; to account for cases like "nearly all books, only his book, exactly which
;; book, almost every book".  
;;
;; Quantifiers need to accommodate expressions like
;; 'almost every book'.  One might expect to have the degree_rel of 'almost'
;; take the handle of 'every' as its ARG value, but this may interfere with the
;; treatment of scope via H-STORE, since a quantifier always adds its handle
;; to H-STORE, and this handle interacts with other scope constraints.  So
;; we would have to put the handle of 'almost' in H-STORE as well, but only
;; in case 'almost' is a specifier for determiners, not for e.g.'almost ready'.
;; So we do this by adding separate lexical entries for these det-specs.

basic_det_synsem := lex_synsem & nomod_synsem &
  [ LOCAL [ CAT [ HEAD det,
		  VALENCE [ SUBJ none,
			    SPR < [ LOCAL local &
					  [ CONT [ KEY degree_rel &
						       [ HANDEL #hand,
							 DARG #darg ],
						   INDEX #index ] ],
				    OPT + ] >, 
			    COMPS < > ] ],
	    CONT nom-obj &
		[ HANDEL #hand,
		  INDEX #index,
		  KEY #key & [ HANDEL #hand,
			       BV #index,
			       DIM #darg],
		  --STEMLISZT.LIST < quant_or_wh_rel & #key, ... > ],
	    ARG-S < > ] ].

det_synsem := basic_det_synsem &
  [ LOCAL.CONT [ HANDEL #hand,
		 --STEMLISZT <! quant_or_wh_rel !>,
		 H-STORE <! #hand !> ] ].

part_det_synsem :< basic_det_synsem.

part_det_synsem_nonwh := part_det_synsem & 
  [ LOCAL.CONT [ HANDEL #hand,
		 H-STORE <! #hand !> ] ].

non_part_basic_det_synsem :< basic_det_synsem.
non_part_det_synsem := non_part_basic_det_synsem & det_synsem.

det_word := que_word &
  [ SYNSEM det_synsem & [ LOCAL.CAT.HEAD.POSS - ] ].

det_word_non_part := que_word &
  [ SYNSEM non_part_det_synsem & 
	   [ LOCAL.CAT.HEAD.POSS - ] ].

det_word_sing := det_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV [ PNG 3sg,
			       DIVISIBLE - ] ].

det_word_mass := det_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV [ PNG 3sg,
			       DIVISIBLE + ] ].

det_word_plur := det_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.PNG 3pl ].

det_word_sg_mass := det_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.PNG 3sg ].

pdet_word := que_word &
  [ SYNSEM part_det_synsem_nonwh &
	   [ LOCAL.CONT.--STEMLISZT <! quant_or_wh_rel !> ] ].

pdet_word_sing := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV [ PNG 3sg,
			       DIVISIBLE - ] ].

pdet_word_mass := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV [ PNG 3sg,
			       DIVISIBLE + ] ].

pdet_word_plur := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.PNG 3pl ].

pdet_word_sg_mass := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.PNG 3sg ].

; This assumes (falsely) that all plurals are divisible (cf "oats", "clothes")
pdet_word_pl_mass := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.DIVISIBLE + ].

pdet_word_wh := que_word &
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD.POSS -,
		     CONT [ HANDEL #hand,
			    --STEMLISZT <! quant_or_wh_rel !>,
			    H-STORE <! #hand !> ] ] ] ].

pdet_word_one := que_word &
  [ SYNSEM part_det_synsem_nonwh &
	   [ LOCAL.CONT.--STEMLISZT <! some_rel &
				       [ BV #ind & 
					    [ PNG 3sg,
					      DIVISIBLE - ],
					 RESTR #hand ],
				       const_rel &
				       [ HANDEL #hand,
					 XARG #ind,
					 CONST_VALUE 1 ] !> ] ].


;; We make the non-quantifier relation generically pron_rel, and have each
;; individual pronoun simply constrain the INST index of that pron_rel.
;;   This type is used for both WH "whose" and relative "whose", so it leaves 
;; both  QUE  and  REL  values unspecified, but supplies all other defaults.
;;   For now, make the poss_rel's handle be same as the RESTR, but as soon as
;; we go back to an underspec. treatment of the restrictor, we'll have to make
;; this identity more carefully.

poss_word := nonconj & non_affix_bearing & nonslash & nonmsg & 
	     nonhcons & rootna &
  [ SYNSEM basic_det_synsem &
	   [ LOCAL [ CAT.HEAD.POSS +,
		     CONT nom-obj &
			  [ TOP-H #toph,
			    INDEX #index,
			    --STEMLISZT <! quant_or_wh_rel & #key,
				         pron_rel & #altkey & 
					 [ HANDEL #toph,
					   INST #eind &
					        [ PRONTYPE std_pron ] ],
					 poss_rel & [ HANDEL #hand,
						      POSSR #eind,
						      POSSD #index ] !>,
			    KEY #key & [ RESTR #hand ],
			    ALTKEY #altkey ] ] ] ].

; ERB (31-10-96) See notes near wh_pro_word.

wh_poss_word := poss_word & nonrel &
  [ SYNSEM [ LOCAL.CONT [ KEY which_rel & [ HANDEL #hand ],
			  H-STORE <! #hand !> ],
	     NON-LOCAL.QUE <! #hand !> ] ].

nonwh_poss_word := poss_word & nonque &
  [ SYNSEM non_part_basic_det_synsem &
	   [ LOCAL.CONT [ HANDEL #hand,
			  KEY def_rel,
			  H-STORE <! #hand !> ] ] ].

rel_poss_word := nonwh_poss_word &
  [ SYNSEM [ LOCAL.CONT.ALTKEY.INST #index,
	     NON-LOCAL.REL <! #index !> ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Possessives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Possessive "'s" takes an NP[-Poss] specifier and projects either an
;; NP[+Poss] phrase (for "the book of Kim's") or a DetP[+Poss] phrase (for
;; "Kim's book").  Either way, the content of the possessive phrase will be a
;; definite possessive quantifier.  The NP[+Poss] things also work pretty well
;; for things like "Kim's is under the desk" if we allow governed NPs to be
;; +Poss.  The tricky thing will be figuring out exactly where `bare
;; possessives' can show up.  Also, we need to add the restriction that the SPR
;; must be non-pronominal.  Another question is what do we do with the scope
;; of quantifiers in the possessor?  This entry assumes that they always have
;; narrow scope.  That should be an empirical question, as the saying goes.

poss_clitic := que_word & nonque &
  [ SYNSEM nomod_synsem & 
     [ LOCAL [ CAT [ HEAD poss-able &
			  [ POSS + ],
		     VALENCE [ SUBJ none,
			       SPR < synsem &
				     [ LOCAL local &
					  [ CAT [ HEAD noun & [ POSS - ],
						  VALENCE [ SUBJ none,
							    SPR *olist*,
							    COMPS *olist* ] ],
					       CONT [ HANDEL #rhand,
						      INDEX #pindex ] ],
				       OPT - ] >,
			       COMPS < > ] ],
	       CONT [ HANDEL #hand,
		      INDEX #index,
		      LISZT <! #key & def_rel & [ HANDEL #hand,
						  BV #index,
						  RESTR #rhand ],  
			     #ckey & poss_rel & [ HANDEL #rhand,
						  POSSR #pindex,
						  POSSD #index ] !>,
		      COMPKEY #ckey,
		      KEY #key,
		      H-STORE <! #hand !> ] ] ] ].

;; The possessive "of" takes an NP[+Poss] complement (e.g., "Kim's", "mine")
;; and modifies an N'[-Poss].  Unfortunately, the way the hierarchy of
;; preposition types is built, there wasn't any type this could inherit from.
;; We could probably rearrange things so this inherits some preposition
;; properties, but right now I'm too lazy.  Also, somehow we'll have to make
;; sure that this doesn't modify a pronoun.  The semantic manipulation here is
;; tricky - keep your eyes on the definite quantifier.  This def_rel provided 
;; by the apostrophe-s (for its other life as a determiner), is dropped by the
;; possessive-of, analogous to nouns, verbs, and adjectives dropping the
;; semantics of the prepositions that can mark their complements.  This
;; dropping of the relation is effected by having the possessive-of neglect to
;; grab the handle of the def_rel for its complement, but grab instead the
;; handle (and instance variable) of the NP complement of the apostrophe-s.
;; Then the general semantic pruning mechanism will ignore the def_rel, since
;; its handle will not be a value in any other relation.

poss_of := norm_no_affix_word &
  [ SYNSEM synsem &
     [ LOCAL 
       [ CAT [ HEAD prep & 
		    [ PRD - ],
	       VALENCE [ SUBJ none,
			 SPR < >,
			 COMPS < @np() & 
				 [ LOCAL [ CAT.HEAD.POSS +,
					   CONT.ALTKEY [ HANDEL #hand,
							 POSSD #index ] ],
				   OPT - ] > ],
	       MOD local & 
		    [ CAT [ HEAD noun &
				 [ POSS - ],
			    VALENCE [ COMPS *olist*,
				      SPR < synsem > ],
			    ROOT na ],
		      CONT [ HANDEL #hand,
			     INDEX #index,
			     MESSAGE #msg ] ],
	       POSTHEAD + ],
	 CONT [ HANDEL #hand,
		INDEX #index,
		LISZT <! !>,
		KEY no_rel,
		MODCONT [ HANDEL #hand,
			  INDEX #index,
			  LISZT <! !>,
			  MESSAGE #msg ] ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBORDINATING CONJUNCTIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; These are not restricted to modifying only main VPs, since e.g. "if" needs
; to take scope over modals as in "I'd be pleased if we made an appointment."
; This lack of constraint means there will be structural ambiguity for 
; if-clauses, but not spurious - get different scopes of "if" and modals.
; But we restrict them to modifying only finite VPs or imperatives.

subconj_synsem := nonprd_synsem & 
  [ LOCAL [ CAT [ HEAD prep,
		  VALENCE [ SUBJ none,
			    COMPS < synsem &
				    [ LOCAL local &
					    [ CAT [ HEAD verb &
							 [ INV -,
							   VFORM fin ],
						    VALENCE [ SUBJ none,
							      COMPS *olist*,
							      SPR *olist* ],
						    ROOT -,
						    MOD no-mod ],
					      CONT [ HANDEL #vhand,
						     KEY #ckey, 
						   MESSAGE propositional_rel]],
				      NON-LOCAL [ SLASH *e-dlist*,
						  QUE *e-dlist* ],
				      OPT - ] >,
			    SPR < > ],
		  MOD local &
		       [ CAT [ HEAD verb & [ VFORM fin ],
			       VALENCE [ SUBJ synsem,
					 COMPS *olist* ],
			       ROOT na ],
			 CONT [ HANDEL #modhand,
				MESSAGE #msg ] ],
		  POSTHEAD + ],
	    CONT [ --STEMLISZT <! subord_rel & #key &
			    [ MAIN #modhand,
			      SUBORD #vhand ] !>,
		   INDEX #ind,
		   KEY #key,
		   COMPKEY #ckey,
		   MODCONT [ INDEX #ind,
			     KEY #key,
			     LISZT <! !>,
			     MESSAGE #msg ] ] ] ].

subconj_word := norm_word & non_affix_bearing &
  [ SYNSEM subconj_synsem ].
    
subconj_if_word :< subconj_word.

;  [ SYNSEM.LOCAL.CAT [ MOD.CAT.HEAD.MOOD #mood,
;                       VALENCE.COMPS.FIRST.LOCAL.CAT.HEAD.MOOD #mood ] ].

; "in order to"
subconj_inf_synsem := prd_synsem & 
  [ LOCAL [ CAT [ HEAD prep,
		  VALENCE [ SUBJ none,
			    COMPS < synsem &
				    [ LOCAL local &
					    [ CAT [ HEAD verb &
							 [ VFORM bse ],
						    VALENCE [ SUBJ synsem,
							      COMPS *olist*,
							      SPR *olist* ],
						    ROOT na,
						    MOD no-mod ],
					      CONT [ HANDEL #vhand,
						     KEY #ckey, 
						   MESSAGE no_rel]],
				      NON-LOCAL [ SLASH *e-dlist*,
						  QUE *e-dlist* ],
				      OPT - ] >,
			    SPR < > ],
		  MOD local &
		       [ CAT [ HEAD verb,
			       VALENCE [ SUBJ synsem,
					 COMPS *olist* ],
			       ROOT na ],
			 CONT [ HANDEL #modhand,
				MESSAGE #msg ] ],
		  POSTHEAD + ],
	    CONT [ --STEMLISZT <! subord_rel & #key &
			    [ MAIN #modhand,
			      SUBORD #vhand ] !>,
		   INDEX #ind,
		   KEY #key,
		   COMPKEY #ckey,
		   MODCONT [ INDEX #ind,
			     KEY #key,
			     LISZT <! !>,
			     MESSAGE #msg ] ] ] ].

subconj_inf_word := norm_word & non_affix_bearing &
  [ SYNSEM subconj_inf_synsem ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Coordinating conjunctions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

marker_word := conj_word & 
  [ SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD #head & subst,
		     ROOT #root,
		     VALENCE [ SUBJ #subj, 
			       SPR #spr,
			       COMPS < synsem &
				     [ LOCAL local &
					     [ CAT [ HEAD #head,
						     ROOT #root,
						     VALENCE [ SUBJ #subj,
							       SPR #spr,
							       COMPS #comps ],
						     MOD #mod ],
					       CONT [ HANDEL #hand,
						      MESSAGE #mes,
						      INDEX #index,
						      MODCONT #mcont ] ],
				       OPT - ]
				       . #comps > ],
		     MOD #mod ],
	       CONT [ HANDEL #hand,
		      MESSAGE #mes,
		      INDEX #index,
		      --STEMLISZT <! !>,
		      MODCONT #mcont ] ] ] ].

; A coordinating conjunction needs to "prime" the CONJ.HANDELS and
; CONJ.INDICES lists, so that the right side of a binary coordination looks
; like an iterated coordination.

coord_word_complex := marker_word &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS.FIRST.LOCAL.CONT [ HANDEL #hand,
							INDEX #ind ],
		   CONJ complex-conj & [ HANDELS <! #hand !>,
					 INDICES <! #ind !> ] ] ].
coord_word_atomic := marker_word &
  [ SYNSEM.LOCAL.CONJ atomic-conj ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NEG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; not

; "not" requires its VP complement to be [VFORM non_fin], which is a supersort
; for all non-finite vforms except imp_vform, which is a subsort of bse; the
; other subsort of bse, bse_only, is a subsort of non_fin.  Most verbs with
; base morphology are [VFORM bse], and hence (the VPS they project) can be
; modified by "not", and they can also head imperative clauses, which require
; the head to be [VFORM imp_vform].  Only if modified by "not" will a base
; VP be unable to project an imperative clause; in contrast, "never sleep" is 
; fine as an imperative, since "never" does not further restrict its VP 
; complement leaving it [VFORM bse], which is consistent with the imperative 
; rule.  This fine distinction is due to Rob M.

neg_word := hcons_word & non_affix_bearing &
  [ SYNSEM basic_scopedarg_synsem &
	 [ LOCAL [ CAT [ HEAD neg,
			 VALENCE [ SUBJ none,
				   COMPS < >,
				   SPR < > ],
			 MOD local & #mod &
			      [ CAT [ HEAD verbal &
					   [ VFORM non_fin ],
				      VALENCE [ SUBJ synsem,
						COMPS *olist* ] ],
				CONT [ INDEX #vevent,
				       MESSAGE #msg,
				       KEY.HANDEL #ckhand ] ],
			 POSTHEAD -,
			 --SCOPEDARG [ LOCAL #mod,
				       --ARG #arg ] ],
		   CONT [ HANDEL #hand,
			  INDEX #vevent,
			  --STEMLISZT <! neg_rel & #key &
				 [ HANDEL #hand,
				   ARG #arg ] !>,
			  --H-CONS #hcons & <! scp_pr, scp_pr, 
					     outscopes &
					     [ SC-ARG #hand,
					       OUTSCPD #ckhand ] !>,
			  H-CONS #hcons,
			  KEY #key,
			  MODCONT [ HANDEL #hand,
				    INDEX #vevent,
				    KEY #key,
				    LISZT <! !>,
				    MESSAGE #msg ] ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; COMPLEMENTIZERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Complementizers except for 'to' are marked [SUBJ none] which prevents them
; from having PP modifiers.  The POSS feature here is inappropriate, but since
; TDL is not strictly typed, unification would succeed with [ POSS + ] for a
; CP without the specification [ POSS - ] on CPs given below.

; ERB (07-10-96) 'whether' clauses are made with the regular hcomp rule, so
; the polar_q_rel must come from 'whether' itself.  This means that whether
; can't identify its KEY with its COMPKEY.  Also, I made complementizer_word
; inherit from msg_word (see comments near that type).  This has the effect of
; making non_affix_bearing be inherited by this type, instead of the lower
; types.

; Complementizers are [ROOT -] since they project clauses simply by application
; of the head-comp rule, which only passes up the ROOT value from head to
; mother.

complementizer_word := msg_word & 
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD comp &
			      [ POSS -,
				INV - ],
			 VALENCE.SPR < >,
			 ROOT - ],
		   CONT.--STEMLISZT <! !> ] ].

plain_compl_word := complementizer_word &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					       [ CONT [ HANDEL #hand,
							INDEX #ind,
							KEY #ckey ] ],
					 OPT - ], ... >,
		   CONT [ HANDEL #hand,
			  INDEX #ind,
			  COMPKEY #ckey ] ] ].

; These are the subject-to-object raising complementizers.  We're giving a
; funny three-constituent analysis to CPs: "that [Kim] [walks]" and "for [Kim]
; [to walk]".  One (beneficial) side effect of this is that finite and
; non-finite CPs get a uniform analysis, and we also can do real subject
; extraction without running afoul of the dreaded that-trace filter
; (Perlmutter 1971).  

; We also need another "that", one that combines with an adverbial and an
; S/Adv.  This accounts for why you get preposed modifiers with that clauses
; and not with for/to clauses, and why you don't get the that-t effect when
; you have an adverb in there.  But, that second "that" is going to have to
; bind off a SLASH value, sort of like the tough-movement cases, and that will
; have to wait for lexicalized SLASH passing.

two_place_compl_word := complementizer_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MOOD #mood,
				VFORM #vform ],
			 VALENCE [ SUBJ none,
				   COMPS < synsem,
					   [ LOCAL local &
					       [ CAT [ HEAD verb &
							    [ MOOD #mood,
							      VFORM #vform ],
						       VALENCE.COMPS *olist*,
						       ROOT na ],
						 CONT [ HANDEL #hand,
							KEY #ckey ] ],
					     OPT - ] > ] ],
		   CONT [ HANDEL #hand,
			  KEY #ckey,
			  COMPKEY #ckey ] ] ].

sor_compl_word := two_place_compl_word &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS < #subj & @nomp() &
				       [ OPT - ],
				     [ LOCAL [ CAT.VALENCE.SUBJ #subj & synsem,
					       CONT.MESSAGE.SOA #soa ] ] >,
		   CONT.MESSAGE.SOA #soa ] ].

that_compl_word := sor_compl_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD.VFORM fin,
		   CONT.MESSAGE prpstn_rel ] ].

for_compl_word := sor_compl_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD.VFORM inf,
		   CONT.MESSAGE hypo_rel ] ].

to_compl_word := plain_compl_word &
  [ SYNSEM ssr_subst &
	   [ LOCAL [ CAT [ HEAD [ VFORM inf,
				  PRD - ],
			   VALENCE.COMPS < @vp($vform=bse) > ],
		     CONT [ KEY #ckey,
			    COMPKEY #ckey ] ] ] ].

to_compl_prop_word := to_compl_word & 
  [ SYNSEM.LOCAL [ CAT.VALENCE.SUBJ.LOCAL local &
					  [ CAT.HEAD.CASE acc ],
		   CONT.MESSAGE hypo_rel ] ].

to_compl_nonprop_word := to_compl_word & 
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS < [ LOCAL local &
					       [ CONT.HANDEL #hand ] ] >,
		   CONT [ HANDEL #hand,
			  MESSAGE no_rel ] ] ].

; ERB (08-10-96) Whether was previously a que_word so that things selecting
; for questions could select by QUE values.  This is clearly a hack, and
; further, one that is no longer necessary now that we have semantic selection.
; I have split the old type whether_compl_word into two types: finite and
; nonfinite.  I have also gotten rid of the feature CMP.  
; As for the semantics, whether contributes a polar_q_rel (see notes near
; polar_q_rel in fundamentals.tdl).  Now, according to Rob, things that
; take complements with message-type semantics usually take the handle of
; those complements as the argument in their KEYs.  However, also according
; to Rob, if we did that here, it would imply that "whether Kim left every
; party" has more readings than "Kim left every party", which doesn't seem
; to be true.  Accordingly, whether will identify its handle with the
; handle of its complement, and take the complement's INDEX as the value
; of the ARG in the polar_q_rel.  Now, if whether further identified its
; INDEX with that one, things would be getting pretty twisty, so whether
; will have its own INDEX of type event.

; ERB (24-10-96) MESSAGE now functions like KEY as a pointer to
; a certain rel on the LISZT.  Both wh and yn questions will have an
; int_rel on their LISZT.  This is actually sewn into the LISZT
; by the constructions.  Whether just carries it in its MESSAGE value
; so that it unifies with the right constructions.  In this way, we
; even kind of get Rob's intuition -- whether doesn't, in a sense,
; have a message, because that message isn't on its LISZT.
; Anyway, all of this makes the polar_q_rel irrelevant, so I am removing
; it.  The hcomp_yn_nr construction will make sure the SOA value
; of the int_rel takes the HANDEL of whether's complement.   I don't
; know what to do about whether's HANDEL, KEY, and EVENT now, so I am 
; leaving them unspecified.

whether_compl_word := complementizer_word &
  [ SYNSEM.LOCAL.CONT.MESSAGE int_rel & [ PARAMS <! !> ] ].

whether_compl_word_fin := whether_compl_word & sor_compl_word &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin ].

; ERB (08-10-96) In the older version, I had whether_compl_word_inf 
; selecting for something that was just @vp($vform=inf).  I never
; tested for this, but this probably allowed Sandy knew whether whether
; to leave, etc.  One way to get around this is for whether to
; select for something that is MESSAGE no_rel.  In order to do 
; this, I need to build to CPs that are no_rel, but we want this
; anyway (even though I talked Dan out of it at one point).

whether_compl_word_inf := whether_compl_word & plain_compl_word &
  [ SYNSEM ssr_subst &
	   [ LOCAL.CAT [ HEAD.VFORM inf,
			 VALENCE.COMPS 
			     < [ LOCAL.CAT [ HEAD comp &
						  [ VFORM inf ],
					     VALENCE [ COMPS *olist*,
						       SPR *olist* ] ] ] >
				    ] ] ].
	    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Imperative words "don't" and "let's"

root_marker_word := msg_word & rootna &
  [ SYNSEM synsem &
	 [ LOCAL [ CAT [ HEAD root-marker & [ MOOD #mood ],
			 VALENCE [ SPR < >,
				   COMPS < synsem &
					   [ LOCAL local &
					      [ CAT [ HEAD.MOOD #mood,
						      VALENCE.COMPS *olist* ],
						CTXT #ctxt ],
					     NON-LOCAL [ SLASH *e-dlist*,
							 QUE *e-dlist*,
							 REL *e-dlist* ] ] > ],
			 MOD no-mod ],
		   CTXT #ctxt ] ] ].

lex_imperative := root_marker_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ AUX -,
				VFORM bse ],
			 AGR #inst,
			 VALENCE [ SUBJ synsem & [ LOCAL local &
						       [ CONT.INDEX #inst ] ],
				 COMPS < [ LOCAL [ CAT [ HEAD verbal &
							      [ VFORM bse ],
							 VALENCE.SUBJ synsem,
							 MOD no-mod,
							 ROOT na ],
						   CONT [ HANDEL #chand,
							  INDEX #ind,
							  MODCONT #cont ] ],
					   OPT - ] > ] ],
		   CONT [ HANDEL #chand,
			  TOP-H #hand,
			  INDEX #ind,
			  KEY #msg,
			  LISZT <! pron_rel & [ HANDEL #hand,
						INST #inst &
						     [ PRONTYPE std_pron ]] !>,
			  MODCONT #cont,
			  MESSAGE #msg ] ] ].


;; 09-09-97  Added BV and SCOPE attributes temporarily for VM2, since the
;; whq external relation for how_about is like a quantifier, needing four args.
;; Worse, made the MESSAGE value be simply 'relation' rather than 'message',
;; since had to change the relation introduced by "how about" to '_which_rel'
;; rather than '_how_about_rel' because of some property of vitADT.  Similar
;; change made to the 'frag-msg' instance in syntax.tdl.

how_about_word := root_marker_word &
  [ SYNSEM.LOCAL [ CAT.VALENCE.COMPS < [ LOCAL [ ROOT na,
						 CAT [ HEAD subst,
						       VALENCE.COMPS *olist* ],
						 CONT [ MODCONT
						        [ INDEX #ind,
							  LISZT #mliszt ],
							MESSAGE no_rel ] ],
					 OPT - ] >,
		   CONT [ HANDEL #hand,
			  LISZT <! !>,
			  KEY #msg,
			  MODCONT [ INDEX #ind,
				    LISZT #mliszt ],
			  MESSAGE relation & #msg &
				  [ HANDEL #hand,
				    BV #ind,
				    SCOPE handle ] ] ] ].

; Discourse-related sentential adverbs
;   (e.g. 'then, but')

disc_adv_word := root_marker_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.PRD #prd,
			 VALENCE.COMPS 
				 < [ LOCAL [ CAT.HEAD.PRD #prd,
					     CONT [ HANDEL #chand,
						    INDEX #ind,
						    MODCONT #mcont,
						    MESSAGE #msg ] ],
				     OPT + ] > ],
		   CONT [ HANDEL #chand,
			  TOP-H #hand,
			  INDEX #ind,
			  LISZT <! relation !>,
			  --STEMLISZT.LIST < excl_rel & #key &
					   [ HANDEL #hand ], ... >,
			  KEY #key,
			  MODCONT #mcont,
			  MESSAGE #msg ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Temporal nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

hour_word := que_word & nonque &
  [ SYNSEM noun_synsem & nomod_synsem &
	 [ LOCAL [ CAT [ HEAD pnoun &
			      [ POSS - ],
			 VALENCE [ SUBJ none,
				   SPR < [ LOCAL local &
					   [ CAT [ HEAD adv,
						   VALENCE [SPR  *olist*,
							    COMPS *olist* ] ],
					     CONT.KEY degree_rel &
						      [ DARG #hand ] ],
				     OPT + ] >,
				   COMPS < [ LOCAL local &
					     [ CAT [ VALENCE [ SUBJ none,
							       COMPS *olist*,
							       SPR *olist* ],
						     POSTHEAD +,
						     ROOT na ],
					       CONT [ HANDEL #hand,
						      KEY minute_rel &
						        [ INST #minute ] ] ],
					     OPT + ],
					   [ LOCAL local &
					     [ CAT [ VALENCE [ SUBJ none,
							       COMPS *olist*,
							       SPR *olist* ],
						     POSTHEAD +,
						     ROOT na ],
					       CONT.KEY am_pm_rel &
						        [ HANDEL #hand,
							  INST #ampm ] ],
					     OPT + ] > ] ],
		   CONT nom-obj &
		       [ HANDEL #hand,
			 INDEX #index,
			 --STEMLISZT <! numbered_hour_rel & #key &
				        [ HANDEL #nhand,
					  INST #index,
					  MIN #minute,
					  AM-PM #ampm],
				      def_rel &
				        [ HANDEL #hand,
					  BV #index,
					  RESTR #nhand ] !>,
			 KEY #key,
			 H-STORE <! #hand !> ],
		   ARG-S < > ] ] ].

minute_word := np_sing_word &
  [ SYNSEM.LOCAL.CONT.KEY minute_rel ].

am_pm_word := np_sing_word &
  [ SYNSEM.LOCAL [ CAT.POSTHEAD +,
		   CONT.KEY am_pm_rel ] ].

; June, June 1996, June of 1996
month_year_synsem := noun_synsem & nomod_synsem &
  [ LOCAL [ CAT [ HEAD pnoun,
	          VALENCE [ SPR < >,
			    COMPS < synsem & 
				    [ LOCAL local &
					    [ CAT [ VALENCE [ SPR *olist*,
							      COMPS *olist* ],
						    ROOT na ],
					      CONT.INDEX #year,
					      CONJ cnil ] ] > ] ],
	    CONT [ HANDEL #hand,
		   TOP-H #hand,
		   INDEX.PNG 3sg_n,
		   --STEMLISZT <! mofy_rel &
				[ HANDEL #hand,
				  YEAR-IND #year ] !> ] ] ].

month_of_year_synsem := month_year_synsem &
  [ LOCAL.CAT.VALENCE.COMPS < synsem & 
			      [ LOCAL [ CAT [ HEAD prep & [ PRD - ],
					      VALENCE.SUBJ *top* ],
					CONT [ KEY _of_rel,
					       COMPKEY yofc_rel ] ],
				OPT + ] > ].

month_no_of_year_synsem := month_year_synsem &
  [ LOCAL.CAT.VALENCE.COMPS < synsem &
			      [ LOCAL [ CAT [ HEAD nominal & [CASE acc],
					      VALENCE.SUBJ none ],
					CONT.KEY yofc_rel ],
				OPT - ] > ].

month_word := norm_no_affix_word &
  [ SYNSEM month_of_year_synsem ].

month_year_word := norm_no_affix_word &
  [ SYNSEM month_no_of_year_synsem ].

year_word := np_sing_word &
  [ SYNSEM.LOCAL.CONT.KEY yofc_rel ].

; 'the first', 'October first', 'the first of October'
; Need to find way to block '*October first of October'
dom_synsem := noun_ppcomp_synsem &
  [ LOCAL [ CAT.VALENCE [ SPR < [ LOCAL.CONT [ KEY quant_or_wh_rel,
					       ALTKEY mofy_rel &
						   [ INST #inst ] ] ] >,
			  COMPS < [ LOCAL.CONT [ KEY _of_rel,
						 COMPKEY mofy_rel ],
				      OPT + ] > ],
	    CONT.--STEMLISZT <! dofm_rel &
			        [ HANDEL #hand,
				  INST #ninst & [ PNG 3sg_n ],
				  NPREP #inst ],
			        integer_rel &
			        [ HANDEL #hand,
				  XARG #ninst ] !> ] ].

day_of_month_word := hcons_word & non_affix_bearing &
  [ SYNSEM dom_synsem ].

; 'Tuesday (the first (of October))', 'Tuesday (October first)'

day_of_week_word := norm_no_affix_word &
  [ SYNSEM temp_mod_synsem &
	   [ LOCAL [ CAT [ AGR #ind,
			   VALENCE [ SPR < >,
				     COMPS < [ LOCAL local &
					      [ CAT [ VALENCE [ SUBJ none,
							       COMPS *olist*,
							       SPR *olist* ],
						     ROOT na ],
					       CONT [ INDEX #ind,
						      KEY dofm_rel ] ],
					     OPT + ] > ] ],
		     CONT [ HANDEL #hand,
			    TOP-H #hand,
			    INDEX #ind,
			    KEY dofw_rel & [ INST.PNG 3sg_n ],
			    --STEMLISZT <! relation !> ] ] ] ].

; 'morning' of 'each morning', 'Tuesday morning'
; 09-09-97  Temporarily replaced this def. with the one following, since the
; VM semdb wrongly made this a unary predicate.
#|
day_part_word := norm_no_affix_word &
  [ SYNSEM temp_mod_synsem &
	   [ LOCAL [ CAT [ AGR #ind,
			   VALENCE 
			    [ SPR < synsem &
				  [ LOCAL local &
					  [ CAT [ HEAD det,
						  VALENCE [ SUBJ none,
							    COMPS *olist* ] ],
					    CONT [ KEY quant_or_wh_rel &
						       [ BV #pinst,
							 RESTR #hand ],
						   ALTKEY dofw_rel &
						       [ INST #dinst ] ] ],
				    OPT - ] >,
			      COMPS < [ LOCAL [ CAT.VALENCE.COMPS < >,
						CONT [ INDEX #dinst,
						       KEY _of_rel,
						       COMPKEY dofm_rel ]]]>]],
		     CONT [ HANDEL #hand,
			    INDEX #ind,
			    KEY day_part_rel &
				[ INST #pinst,
				  OF-DAY #dinst ] ] ] ] ].
|#
day_part_word := norm_no_affix_word &
  [ SYNSEM temp_mod_synsem &
	   [ LOCAL [ CAT [ AGR #ind,
			   VALENCE 
			    [ SPR < synsem &
				  [ LOCAL local &
					  [ CAT [ HEAD det,
						  VALENCE [ SUBJ none,
							    COMPS *olist* ] ],
					    CONT [ KEY quant_or_wh_rel &
						       [ BV #pinst,
							 RESTR #hand ],
						   ALTKEY dofw_rel &
						       [ INST #dinst ] ] ],
				    OPT - ] >,
			      COMPS < [ LOCAL [ CAT.VALENCE.COMPS < >,
						CONT [ HANDEL #hand,
						       INDEX #dinst,
						       KEY _of_rel &
							     [ ARG #pinst ],
						       COMPKEY dofm_rel,
						       MODCONT.LISZT 
							 [ LIST #list,
							   LAST #last ]]]]>]],
		     CONT [ HANDEL #hand,
			    INDEX #ind,
			    KEY #key & day_part_rel &
				[ INST #pinst ],
			    --STEMLISZT *diff-list* &
				   [ LIST < #key . #list >,
				     LAST #last ] ] ] ] ].

holiday_word := np_sing_word &
  [ SYNSEM.LOCAL.CONT.KEY holiday_rel ].

; 'Advent', 'summer'
season_word := np_sing_word &
  [ SYNSEM.LOCAL.CONT.KEY season_rel ].

; "the morning" etc.
#|
def_day_part_word := norm_no_affix_word &
  [ SYNSEM xref_synsem & nonpronominal_synsem &
	   [ LOCAL [ CAT [ HEAD pnoun,
			   MOD no-mod, 
			   VALENCE [ SPR < >,
				     SUBJ none,
				     COMPS < > ],
			   AGR #ind ],
		     CONT [ HANDEL #hand,
			    INDEX #ind & ref-ind,
			    KEY #key,
			    ALTKEY #altkey,
			    MODCONT.LISZT <! !>,
			    --STEMLISZT <! def_day_part_rel & #key &
				         [ HANDEL #nhand,
					   INST #inst & [ PNG 3sg ] ],
				         def_rel & #altkey &
				         [ HANDEL #hand,
					   BV #inst,
					   RESTR #nhand ] !>,
			    H-STORE <! #hand !> ] ] ] ].
|#

def_day_part_word := norm_no_affix_word &
  [ SYNSEM temp_mod_synsem &
	   [ LOCAL [ CAT [ AGR #inst,
			   VALENCE 
			    [ SPR < synsem &
				  [ LOCAL local &
					  [ CAT [ HEAD det,
						  VALENCE [ SUBJ none,
							    COMPS *olist* ] ],
					    CONT [ KEY def_rel &
						       [ BV #inst,
							 RESTR #hand ] ] ],
				    OPT - ] >,
			      COMPS < > ] ],
		     CONT [ HANDEL #hand,
			    INDEX #inst,
			    KEY def_day_part_rel &
				[ INST #inst ] ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Hour-noun modifiers:  "about" "exactly"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

hour_mod_word := norm_no_affix_word &
  [ SYNSEM synsem &
      [ LOCAL [ CAT [ HEAD adj,
		      VALENCE [ SUBJ none,
				COMPS < >,
				SPR < > ],
		      MOD local &
			   [ CAT [ HEAD noun & [ POSS - ],
				   VALENCE.COMPS *olist*,
				   ROOT na ],
			     CONT [ HANDEL #hand,
				    INDEX #nind,
				    KEY hour_rel,
				    MESSAGE #msg ] ],
		      POSTHEAD - ],
		CONT [ HANDEL #hand,
		       INDEX #nind,
		       --STEMLISZT <! arg_rel & #key &
				  [ HANDEL #hand,
				    ARG    #nind ] !>,
		       KEY #key,
		       MODCONT [ HANDEL #hand,
				 INDEX #nind,
				 KEY #key,
				 LISZT <! !>,
				 MESSAGE #msg ] ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Degree specifiers for adjectives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 'very, really, much, a lot, almost'
; Treated as measure phrases, selected as specifiers by adjectives.
; These words do not specify empty HSTORE, since they can get assigned a
; nonempty value when they serve as specifiers of determiners.  All other
; heads taking these as specifiers must specify an empty HSTORE, given our
; treatment of this attribute as a difference list.


basic_degree_spec_word := que_word &
  [ SYNSEM nomod_synsem &
	  [ LOCAL [ CAT [ HEAD adv,
			  VALENCE [ SUBJ none,
				    COMPS < >,
				    SPR < [ LOCAL local &
					   [ CAT [ HEAD adv,
						   VALENCE [ SPR *olist*,
							     COMPS *olist* ] ],
					     CONT [ KEY degree_rel &
						      [ HANDEL #hand,
							DARG #darg] ] ],
					    NON-LOCAL.QUE *e-dlist*,
					    OPT + ] > ] ],
		    CONT [ HANDEL #hand,
			   INDEX #ind,
			   --STEMLISZT.LIST < degree_rel & #key &
					      [ DARG individual,
						DIM #darg ], ... >,
			   KEY #key,
			   MODCONT [ HANDEL #hand,
				     INDEX #ind ] ] ] ] ].

degree_spec_word := basic_degree_spec_word & nonque & nonhstore &
  [ SYNSEM.LOCAL.CONT [ HANDEL #hand,
			--STEMLISZT <! [ HANDEL #hand ] !> ] ].

; "how tall"
wh_deg_spec_word := basic_degree_spec_word & 
  [ SYNSEM [ LOCAL.CONT [ HANDEL #hand,
			  --STEMLISZT <! [ HANDEL #dhand,
					   DEGINST #dinst ],
				         relation,
				         which_rel & [ HANDEL #hand,
						       BV #dinst,
						       RESTR #dhand ] !> ],
	     NON-LOCAL.QUE <! #hand !> ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Numbers

; For numerals
num_synsem := synsem &
	      [ LOCAL [ CAT.HEAD.ORDINAL #ord,
			CONT [ HANDEL #hand,
			       KEY integer_rel & #key &
				      [ HANDEL #hand,
					ORD #ord ],
			       --STEMLISZT.LIST < #key, ... >  ] ] ].

int_adj_synsem := lex_synsem & 
  [ LOCAL [CAT [HEAD intadj,
		MOD local & [ CAT [ HEAD noun & [POSS -],
				    VALENCE [ SPR < synsem >,
					      COMPS *olist* ] ],
			      CONT [HANDEL #hand,
				    INDEX #index,        
				    KEY nom_rel] ] ],
	   CONT [HANDEL #hand,
		 INDEX #index,
		 MODCONT [ HANDEL #hand,
			   INDEX #index,
			   LISZT <! !>,
			   H-CONS <! !> ],
		 KEY integer_rel & [HANDEL #hand,
			            XARG #index] ] ] ].

norm_num_synsem := num_synsem & int_adj_synsem.

norm_num_word := norm_no_affix_word &
  [ SYNSEM norm_num_synsem ].

;; some norm_card-words must remain unspecified for ORDINAL
norm_card_word :< norm_num_word.

;; those cardinals that take no complements may be safely specified as 
;; -ORDINAL, and as plural (since they're normal)

card_only_word:= norm_card_word &
  [ SYNSEM [LOCAL [CAT.HEAD.ORDINAL -,
		   CONT.INDEX.PNG 3pl ] ] ].

; should be POSTHEAD -
; These are adjectives only

ord_word := norm_num_word & lex_entry &
  [ SYNSEM.LOCAL.CAT [HEAD.ORDINAL +,
		      VALENCE.COMPS < > ] ].


;;  Specifiers and modifiers will agree with heads on the value
;; of the head feature ORDINAL -- this allows propagation
;; of such a feature from complements, where (on the current account)
;; the ORDINAL feature gets a value from the lexicon.

;; distribution of ORDINAL:
;;   ordinal lex_entries are ORDINAL +
;;   complement_free lex_entries are ORDINAL -
;;   all lex_entries for "one" are ORDINAL - 
;;   other lex_entries are unspecified for ORDINAL
;; Since (the HEAD feature of) the determiner "one" is outside this 
;; hierarchy, it can't appear as a specifier or complement.


;; The sorts below refer only to lexical entries, so there's presumably no
;; harm in making conventions about the order of the RELs on their LISZTs
;; No particular order is assumed for any phrase containing these entries.

;; It will be hard to do optional complements here and get the LISZTs to
;; come out right.  Another problem with optional complementation is that
;; entries with complements must be -ORD, while their complement-taking
;; counterparts must be underspecified for ORD 
;;   (cf. "twenty" vs. "twenty one" vs. "twenty first")


complement_free_number := norm_num_word &
			  [ SYNSEM.LOCAL.CAT [VALENCE.COMPS < >] ].

complemented_number := norm_num_word &
  [ SYNSEM 
    [LOCAL [CAT [HEAD.ORDINAL #ord,
		 VALENCE.COMPS < [OPT -,
				  LOCAL [CAT [VALENCE [SPR < >,
						       COMPS < >],
					      HEAD intadj & 
						      [ORDINAL #ord] ],
					 CONT.INDEX.PNG #num] ] > ],
	    CONT [ INDEX.PNG #num,
		   KEY.XARG #arg,
		   --STEMLISZT.LIST < plus_rel, const_rel & [ XARG #arg ], ... >
		   ] ] ] ].
		   

; Non-identity stipulated for handle of SPR and handle of CONT in order to
; prevent the regular head-spec rule (non-head-compositional) from applying.
; Need head-compositional since the handle of the phrase "two hundred" must
; be the handle of the times_rel from the head "hundred" (which contains as
; arguments the other two handles).

specified_number := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VALENCE.SPR < synsem &
				   [ OPT -,
				     LOCAL [ CAT [HEAD intadj & [ORDINAL -],
						  VALENCE [ COMPS < >,
							    SPR < > ] ] ] ] >].
				 
unspecified_num_without_complements := complement_free_number &
  [ SYNSEM.LOCAL [CAT.VALENCE [ SPR < > ],
		  CONT.--STEMLISZT <! const_rel !> ] ].

unspecified_num_with_complements := complemented_number &
  [ SYNSEM.LOCAL 
     [CAT [VALENCE [ SPR < >,
		     COMPS < [LOCAL [ CONT.KEY integer_rel & 
					       [ HANDEL #chandle ] ] ] > ] ],
      CONT.--STEMLISZT <! [ TERM1  #khandle,
			    TERM2  #chandle],
			  [ HANDEL #khandle] !> ] ].

specified_num_without_complements := complement_free_number &
				     specified_number & 
  [ SYNSEM.LOCAL 
	[ CAT.VALENCE.SPR < [ LOCAL.CONT.HANDEL #shandle ] >,
	 CONT.--STEMLISZT <! times_rel & [ FACTOR1  #shandle,
					   FACTOR2  #khandle],
			     const_rel & [ HANDEL #khandle] !> ] ].

specified_num_with_complements := complemented_number &
				  specified_number & 
  [ SYNSEM.LOCAL 
    [ CAT 
       [ VALENCE [ SPR < [ LOCAL.CONT.HANDEL #shandle ] >,
		   COMPS < [ LOCAL.CONT.HANDEL #chandle ] > ] ],
      CONT.--STEMLISZT <! [ TERM1  #thandle,
			    TERM2  #chandle],
			  [ HANDEL #khandle],
			  times_rel & [ HANDEL #thandle,
				      FACTOR1 #shandle,
				      FACTOR2 #khandle] !> ] ].

;; the constraints appropriate for all lexical entries for "one"

one_word := norm_no_affix_word & 
   [ SYNSEM num_synsem &
	    [ LOCAL [ CAT [ HEAD intsort & [ORDINAL -],
			    VALENCE [ SPR < >,
				      COMPS < >] ],
		      CONT [ --STEMLISZT <! const_rel & 
					  [CONST_VALUE 1 ] !>,
			     MODCONT.LISZT <! !> ] ] ] ].

