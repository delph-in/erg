;;; -*- Mode: tdl; coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2006
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see erg/licence.txt for conditions
;;;
;;;  lextypes.tdl
;;;
;;;  Lexical types (i.e., word classes)
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$

;:message "Lexical types".

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LEXICAL DEFAULTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nonconj := word_or_lexrule &
  [ SYNSEM [ LOCAL.CONJ cnil,
             PUNCT no_punctuation_min ] ].

nonque := word_or_lexrule &
  [ SYNSEM.NONLOC.QUE 0-dlist ].  

nonrel := word_or_lexrule &
  [ SYNSEM.NONLOC.REL 0-dlist ].  

nonslash := word_or_lexrule &
  [ SYNSEM.NONLOC.SLASH 0-dlist ].

; Most words combine with their complements (if any) to produce a phrase,
; but a few, like "twenty" as in "twenty-two" and "five" as in "five o'clock",
; produce a sign which is still a word -- one with [ SYNSEM lex_synsem ].

hc-to-phr := word_or_lexrule &
  [ SYNSEM.LOCAL.CAT.HC-LEX - ].

mcna := word_or_lexrule &
  [ SYNSEM.LOCAL.CAT.MC na ].

non_affix_bearing := word_or_lexrule &
  [ INFLECTD + ].

;; Relevant combinations of these seven lexical defaults

nons-m := nonslash & mcna.
noncs-m := nons-m & nonconj.
nonc-h := nonconj & hc-to-phr.
nonc-m-nab := nonconj & mcna & non_affix_bearing.
noncs-m-nab := nonc-m-nab & nonslash.
noncs-hm := noncs-m & hc-to-phr.
noncs-hm-nab := noncs-hm & noncs-m-nab.
noncrs-hm := noncs-hm & nonrel.
noncqrs-hm := noncrs-hm & nonque.
noncqrs-hm-nab := noncqrs-hm & noncs-m-nab.
nonrs := nonrel & nonslash.
noncrs := nonrs & nonconj.
noncqrs := noncrs & nonque.
noncrs-nab := noncrs & non_affix_bearing.
noncqrs-nab := noncqrs & non_affix_bearing.
noncrs-m := noncs-m & noncrs.
noncqrs-m := noncrs-m & nonque.
noncrs-m-nab := noncrs-m & noncs-m-nab.
noncqrs-m-nab := noncrs-m-nab & nonque.
nonc-hm := nonconj & hc-to-phr & mcna.
noncqs := nonconj & nonque & nonslash.
noncqs-hm := noncs-hm & noncqs.
noncqs-m-nab := noncqs & noncs-m-nab.
noncqs-hm-nab := noncqs-hm & noncs-m-nab.
nonc-h-nab := nonconj & hc-to-phr & non_affix_bearing.
noncr-h-nab := nonc-h-nab & nonrel.
noncqr-h-nab := noncr-h-nab & nonque.
nonc-hm-nab := nonc-h-nab & mcna.
noncqrs-h-nab := noncqrs & nonc-h-nab.
noncr-hm-nab := noncr-h-nab & mcna.
noncrs-hm-nab := noncrs-hm & noncs-m-nab.
nonrs-nab := nonrs & non_affix_bearing.

; que_word's have all the defaults EXCEPT nonque
que_word := noncrs-hm-nab & word.

norm_nonconj_word := nonc-hm-nab & word.

;;;;;
;; Non-local amalgmation types

basic_zero_arg := synsem &
  [ LOCAL.ARG-S < >,
    NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ] ].

zero_arg := basic_zero_arg & lex_synsem &
  [ LOCAL.CONT.HCONS <! !> ].

basic_one_arg := canonical_synsem &
  [ LOCAL.ARG-S < [ NONLOC [ SLASH #slash,
                             REL #rel,
                             QUE #que ] ] >,
    NONLOC [ SLASH #slash,
             REL #rel,
             QUE #que ] ].

one_arg := basic_one_arg &
  [ LOCAL.CONT.HCONS <! !> ].

unspec_two_arg := basic_lex_synsem &
  [ LOCAL.ARG-S < [ NONLOC [ SLASH [ LIST #smiddle,
                                     LAST #slast ],
                             REL [ LIST #rmiddle,
                                   LAST #rlast ],
                             QUE [ LIST #qmiddle,
                                   LAST #qlast ] ] ],
		  [ NONLOC [ SLASH [ LIST #sfirst,
                                     LAST #smiddle ],
                             REL [ LIST #rfirst,
                                   LAST #rmiddle ],
                             QUE [ LIST #qfirst,
                                   LAST #qmiddle ] ] ] >,
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ],
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

basic_two_arg := unspec_two_arg & lex_synsem.

two_arg := basic_two_arg &
  [ LOCAL.CONT.HCONS <! !> ].

; 'Kim is worth admiring.'
worth_two_arg := lex_synsem &
  [ LOCAL.ARG-S < [ NONLOC [ SLASH #slash,
                             REL [ LIST #rmiddle,
                                   LAST #rlast ],
                             QUE [ LIST #qmiddle,
                                   LAST #qlast ] ] ],
                  [ NONLOC [ REL [ LIST #rfirst,
                                   LAST #rmiddle ],
                             QUE [ LIST #qfirst,
                                   LAST #qmiddle ] ] ] >,
    NONLOC [ SLASH #slash,
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

generic_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ REL [ LIST #rmiddle2,
                                     LAST #rlast ],
                               QUE [ LIST #qmiddle2,
                                     LAST #qlast ] ] ],
                    [ NONLOC [ REL [ LIST #rfirst,
                                     LAST #rmiddle1 ],
                               QUE [ LIST #qfirst,
                                     LAST #qmiddle1 ] ] ],
                    [ NONLOC [ REL [ LIST #rmiddle1,
                                     LAST #rmiddle2 ],
                               QUE [ LIST #qmiddle1,
                                     LAST #qmiddle2 ] ] ] > ],
    NONLOC [ REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

basic_three_arg := generic_three_arg &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle2,
                                   LAST #slast ] ],
                  [ NONLOC.SLASH [ LIST #sfirst,
                                   LAST #smiddle1 ] ],
                  [ NONLOC.SLASH [ LIST #smiddle1,
                                   LAST #smiddle2 ] ] >,
    NONLOC.SLASH [ LIST #sfirst,
                   LAST #slast ] ].

three_arg := basic_three_arg &
  [ LOCAL.CONT.HCONS <! !> ].

; Don't amalgamate SLASH of last complement
tough_three_arg := generic_three_arg &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle1,
                                   LAST #slast ] ],
                  [ NONLOC.SLASH [ LIST #sfirst,
                                   LAST #smiddle1 ] ],
                  synsem >,
    NONLOC.SLASH [ LIST #sfirst,
                   LAST #slast ] ].

; Don't amalgamate REL of last complement (it-cleft, 'have X to finish')
norel_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle2,
                                       LAST #slast ],
                               REL [ LIST #rmiddle,
                                     LAST #rlast ],
                               QUE [ LIST #qmiddle2,
                                     LAST #qlast ] ] ],
                    [ NONLOC [ SLASH [ LIST #sfirst,
                                       LAST #smiddle1 ],
                               REL [ LIST #rfirst,
                                     LAST #rmiddle ],
                               QUE [ LIST #qfirst,
                                     LAST #qmiddle1 ] ] ],
                    [ NONLOC [ SLASH [ LIST #smiddle1,
                                       LAST #smiddle2 ],
                               QUE [ LIST #qmiddle1,
                                     LAST #qmiddle2 ] ] ] > ],
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ],
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

four_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle3,
                                       LAST #slast ],
                               REL [ LIST #rmiddle3,
                                     LAST #rlast ],
                               QUE [ LIST #qmiddle3,
                                     LAST #qlast ] ] ],
		    [ NONLOC [ SLASH [ LIST #sfirst,
                                       LAST #smiddle1 ],
                               REL [ LIST #rfirst,
                                     LAST #rmiddle1 ],
                               QUE [ LIST #qfirst,
                                     LAST #qmiddle1 ] ] ],
		    [ NONLOC [ SLASH [ LIST #smiddle1,
                                       LAST #smiddle2 ],
                               REL [ LIST #rmiddle1,
                                     LAST #rmiddle2 ],
                               QUE [ LIST #qmiddle1,
                                     LAST #qmiddle2 ] ] ],
		    [ NONLOC [ SLASH [ LIST #smiddle2,
                                       LAST #smiddle3 ],
                               REL [ LIST #rmiddle2,
                                     LAST #rmiddle3 ],
                               QUE [ LIST #qmiddle2,
                                     LAST #qmiddle3 ] ] ] > ],
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ],
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBCATEGORIZATIONS -- synsems for verbs, adjectives, prepositions, nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nomod_local := local &
  [ CAT.HEAD.MOD < > ].

nomod_synsem := lex_synsem &
  [ LOCAL.CAT [ HEAD.MOD < >,
		VAL.SUBJ < > ] ].

scopal_mod :< mod_local.
intersective_mod :< mod_local.

scopal_mod_local := scopal_mod & local.
int_mod_local := intersective_mod & local.

; DPF 27-May-99 - Changed [MC na] in NOMP_CAT to [MC na_or_-] to allow 
; acc-verbal-gerunds to be NP complements, even though they are built via the 
; head_subj rule.
; DPF 18-Nov-99 - Removed PRD + since this prevented e.g. "ten past five" where
; "ten" is [PRD -], and "past" requires a nomp_cat specifier.
; DPF 07-Jan-01 - We would like to capture the generalization that nominal
; phrases which have been assigned case (nominative or accusative) must also
; be [ MSG no_msg ] to block, e.g., spurious analyses for verbal gerunds
; which have been built via the subj-head rule.  But for now have to stipulate
; this for each occurrence in subcats.
; DPF 21-Mar-01 - Made COMPS for nomp_cat be < > rather than *olist* to avoid
; spurious ambiguity for partitives, as in "some arrived", since they have to
; undergo the n_optcomp pumping rule in order to be able to take a specifier
; as in "almost all arrived".
; DPF 20-Dec-01 - Added SPEC < > in nomp_cat to exclude measure-NPs.
; DPF 8-Feb-02 - But this prevents NPs from ever being specifiers (given the
; constraint on SPR..SPEC in the h-spec rule.  So remove this constraint, and
; try to remember the examples that were supposed to be excluded.
; DPF 20-May-02 - Why MOOD on nomp_cat?
; DPF 27-Oct-02 - Would like to say about all nomp's that they are 
; [DIV strict_sort], as we've already been doing (asymmetrically) for
; verbs' subjects for a while now, to avoid spurious ambiguity for e.g.
; "Fridays are inconvenient",  thus extending this to other uses of NPs.
; But AGR.DIV is not in CAT, so we can't, and we have to replicate this
; constraint everywhere, as we've already had to do for [CONJ cnil].  Maybe
; a better approach could be found, maybe with defaults?
; DPF 4-Nov-02 - Added MOD < > since we can no longer distinguish modnp guys
; (output of npadv_mod rule) by their having a non-empty SUBJ.
; DPF 7-jul-04 - Removed [ TAM.MOOD ind_or_mod_subj ] from nomp_cat, since
; it's not clear what it was supposed to do.
; DPF 27-aug-04 - Removed [PRD -] constraint, since we want "as much rice
; as possible" which is [PRD +].
; DPF 04-mar-06 - Re 4-Nov-02, removed MOD < > since some NPs (e.g. yofc) have
; non-empty MOD, and npadv's have INDEX event rather than index.

nomp_cat_min :< cat_min.

nomp_cat := nomp_cat_min & cat &
  [ HEAD nominal &
	 [ POSS -,
           MOD < > ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS < > ],
    MC na_or_- ].

; DPF (8-Jan-99) Added accusative and nominative subtypes of nomp_cat, since 
; nominative ones are not 'mobile' - see fundamentals.tdl, and still want to
; keep _min types to reduce size of feature structures, even with CASE
; restriction.

nomp_cat_nom_min :< nomp_cat_min.
nomp_cat_acc_min :< nomp_cat_min.
nomp_cat_nonnom_min :< nomp_cat_min.

nomp_cat_nom := nomp_cat_nom_min & nomp_cat &
  [ HEAD.CASE nom ].

nomp_cat_acc := nomp_cat_acc_min & nomp_cat &
  [ HEAD.CASE acc ].

nomp_cat_nonnom := nomp_cat_nonnom_min & nomp_cat &
  [ HEAD.CASE non_nom ].

np_cat_min :< nomp_cat_min.
np_cat_nom_min := nomp_cat_nom_min & np_cat_min.
np_cat_acc_min := nomp_cat_acc_min & np_cat_min.

np_cat_nom := nomp_cat_nom & np_cat_nom_min &
  [ HEAD supnoun ].

np_cat_acc := nomp_cat_acc & np_cat_acc_min &
  [ HEAD supnoun ].

;; DPF (30-Apr-98) In saturated phrase subcats, SUBJ must be < >, not *olist*,
;; since we need to have SUBJ < > unify with the filler in filler_head phrases,
;; and the filler is constrained to be SUBJ *prolist* which has a distinct 
;; synsem type (pro_ss) which is constrained to be [OPT -].
;; DPF 27-May-99 - Having eliminated the need for *prolist* to be OPT -, we
;; can now make saturated phrases require SUBJ to be *olist* rather than < >, 
;; which means verbal gerunds can have an optional SUBJ but still themselves 
;; be subjects or complements.
;; DPF (28-Jul-98) Added MOD < > to exclude non-finite relative clauses, which
;; are otherwise not distinguishable from nomp's.  Maybe also needed to 
;; exclude the second (modifier) entries for temporal NPs like "Tuesday".
;; DPF 09-Jun-99 - Removed MOD < > (see above), since relative clauses are now
;; all marked with non-empty REL, and because this constraint was falsely 
;; blocking "one to three pm" as an NP complement, because it has a 
;; non-empty MOD.

s_cat_unspec := cat &
  [ HEAD verbal,
    VAL [ SUBJ *olist*,
	  COMPS < > ] ].

s_cat_v_c := s_cat_unspec &
  [ HEAD.INV -,
    VAL.SPR *olist*,
    MC - ].

s_cat_fin_or_inf_unspec := s_cat_unspec &
  [ HEAD.VFORM fin_or_inf ].

s_cat_fin_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD [ VFORM fin,
           TAM indic_tam ] ].

s_cat_inf_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD.VFORM inf ].

s_cat_fin_or_inf_v_c := s_cat_v_c & s_cat_fin_or_inf_unspec.

s_cat_fin_v_c := s_cat_v_c & s_cat_fin_unspec.

s_cat_inf_v_c := s_cat_v_c & s_cat_inf_unspec.

; Removed HEAD comp, to allow "I demand he be here"
s_cat_bse := s_cat_v_c &
  [ HEAD [ VFORM bse,
	   TAM.TENSE real_tense ] ].

s_cat := s_cat_unspec &
  [ HEAD verb & [ TAM.TENSE real_tense ] ].

s_cat_fin := s_cat & s_cat_fin_unspec &
  [ HEAD.INV - ].

; DPF 17-Jul-03 - Removed MC + since blocked e.g. "I assume you stayed to chat"
s_cat_fin_or_imp := s_cat &
  [ HEAD.VFORM fin_or_imp,
    MC bool ].

n_or_v_cat_min := cat_min.
n_or_v_cat := n_or_v_cat_min & cat &
  [ HEAD nominal_or_verbal,
    VAL.COMPS < > ].

vp_cat := n_or_v_cat &
  [ HEAD verbal &
	 [ INV -,
           MOD *anti_list* ],
    VAL.SUBJ < synsem_min & [ NONLOC [ SLASH 0-dlist,
                                       REL 0-dlist,
                                       QUE 0-dlist ] ] >,
    MC na ].

vp_inf_cat := vp_cat &
  [ HEAD [ VFORM inf,
	   PRD - ] ].

vp_bse_unspec_cat := vp_cat &
  [ HEAD verb &
	 [ VFORM bse_only,
	   PRD - ] ].

vp_prp_cat := vp_cat &
  [ HEAD.VFORM prp ].

; DPF 19-Oct-02 - Changed MOOD from indicative to indicative* to
; allow coord of "I will stay so you should leave"
vp_bse_cat := vp_bse_unspec_cat &
  [ HEAD.TAM [ MOOD indicative,
               TENSE no_tense ] ].

s_or_vp_inf_cat := cat &
  [ HEAD verbal &
         [ VFORM inf,
           MOD *anti_list* ],
    VAL [ SUBJ *prolist*,
          COMPS < > ] ].

; DPF 10-Jun-99 - Removed MOD < > (cf note in templates.tdl)
; DPF 11-Jul-99 - Added restriction that SPR be [HEAD det] to prevent 
; adjectives from modifying partitives and odd nouns like hour_prep words.
; DPF 28-Aug-99 - Removed SPR: OPT - to allow relative clauses to modify
; generic-pro's like "anything" and still have the result look like an NP.
; DPF 10-May-01 - Removed [SPR..HEAD det] to allow modifiers of generic_pro
; entries as in "everyone important to me"
; DPF 2-Nov-01 - Added SPR < synsem > to exclude "happy here" with n_adv "here"
; DPF 03-may-04 - Consider adding SPEC < anti_synsem_min > to nbar_cat, so 
; these aren't tempted to unify with measure_nps.

nbar_cat_min := n_or_v_cat_min.

basic_nbar_cat := n_or_v_cat &
  [ HEAD noun_or_nomger &
	 [ POSS - ],
    VAL [ SUBJ < >,
          SPR < synsem_min, ... >,
          COMPS < > ],
    MC na ].

nbar_cat := nbar_cat_min & basic_nbar_cat &
  [ VAL.SPR < synsem & [ --MIN quant_or_deg_rel ], ... > ].

adverbee_cat := cat &
  [ HEAD adverbee ].

; DPF 4-Nov-02 - Added MOD < synsem_min > to block NPs, now that we don't have
; presence of SUBJ synsem on all predicative phrases.
; DPF 24-Jun-03 - Removed MOD, since verbs now MOD empty.  Instead, use
; HEAD v_or_a_or_p to exclude NPs.
; DPF 12-oct-05 - Can't constrain MOD to synsem, to exclude e.g. adj "a":
; "*find it a", since verbs have non-empty MOD constrained to anti_synsem.
; So instead constrain semantics of this "a".

basic_prd_cat := cat &
  [ HEAD v_or_a_or_p & 
         [ PRD +,
           MOD < [ LOCAL intersective_mod ] >,
           TAM.TENSE tense ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS < > ],
    MC na ].

; DPF 18-oct-03 - Restricted prd_cat to phrases which can modify nouns, in 
; order to avoid spurious ambiguity for e.g. prepositions that are lexically
; split between noun-modifying and verb-modifying, as "make the check to Kim".
; DPF 01-sept-06 - Added SPR *cons* to block infinitival relatives as
; ordinary prd_cats, to block spurious analysis for e.g. "Kim turned out to
; be tall", while still allowing such relatives to appear as complements of
; the copula 'be' as in "Kim is to be elected."
; DPF 27-sept-06 - Re 01-sept-06: But this prevents "Kim got very tall", so
; instead require AUX -, which still blocks infinitival relatives.

prd_cat := basic_prd_cat &
  [ HEAD [ MOD < [ LOCAL.CAT.HEAD basic_noun ] >,
           AUX -,
           TAM.TENSE untensed ] ].

basic_pp_cat := cat &
  [ HEAD prep_or_modnp,
    VAL [ SPR *olist*,
          COMPS < > ],
    MC na ].

; Only for complements of verbs, to avoid spurious ambiguity (e.g with 'into')
pp_cat := basic_pp_cat &
  [ HEAD [ MOD < [ LOCAL.CAT.HEAD verb ] >,
           PRD + ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Linking Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Linking types specify the relationship between valence positions and 
;; semantic roles.

linking_type :< lex_synsem.

atrans_lt := linking_type &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN no_role_rel,
                  VAL.SUBJ < [ --SIND it-ind & #subjind ] > ],
            CONT.HOOK.XARG #subjind ],
    LKEYS.--+ARGIND it-ind ].

arg1_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ --MIN nom_or_mnp_rel,
                             --SIND #subjind & basic_non_expl,
			     LOCAL.CONT.HOOK.LTOP #ltop ] >,
            CONT.HOOK [ LTOP #ltop,
			XARG #subjind ] ],
    LKEYS.KEYREL arg1_relation & [ ARG1 #subjind ] ].

; DPF 12-Mar-03 - As per agreement with AAC, changed treatment of unaccusatives
; so they introduce an ARG1, not an ARG2 - they are to be related to their
; causative alternation (if any) via lexical rule which introduces an 
; additional cause_rel.
; unacc_lt := arg1_subj_lt.

basic_arg12_lt := arg1_subj_lt & 
  [ LOCAL.CAT.VAL.COMPS 
            < [ --SIND #objind & basic_non_expl ], ... >,
    LKEYS.KEYREL arg12_relation & [ ARG2 #objind ] ].

arg12_lt := basic_arg12_lt &
  [ LOCAL.CAT.VAL.COMPS 
            < [ LOCAL.CONT.HOOK.LTOP #lbl ], ... >,
    LKEYS.KEYREL.LBL #lbl ].

trans_lt := arg12_lt &
  [ LKEYS.KEYREL.ARG2 basic_non_expl ].

arg12h_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], ... >,
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL arg12_relation & [ ARG2 handle & #mhand ] ].

; Maybe only for main verb "have" and for possessive "got"

poss_lt := linking_type &         
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						 INDEX #subjind & 
						    non_expl-ind ] ] >,
		      COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #objind & 
						    non_expl-ind ] ], ... > ],
            CONT [ HOOK [ INDEX #arg0,
                          XARG #subjind ],
                   RELS <! arg12_relation & 
                         [ LBL #lbl,
			   ARG0 #arg0,
                           ARG1 #subjind,
                           ARG2 #objind ] !> ] ] ].

expl_obj_lt := arg1_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND it-ind ], ... >,
    LKEYS.--+ARGIND it-ind ].

; 'prefer it if ...'
; 'make it clear that ...'
expl_obj_cp_lt := expl_obj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    [ LOCAL.CONT.HOOK.LTOP #vhand ],
			    ... >,
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL arg12_relation & [ ARG2 handle & #mhand ] ].

expl_obj_prdp_lt := expl_obj_lt & basic_control_expr_lt &
  [ LOCAL.CAT.VAL [ COMPS < [ --SIND #objind ], 
                            #keycomp &
                            [ LOCAL.CONT.HOOK.XARG #objind ],
                            ... >,
                    KCMP #keycomp ],
    LKEYS.KEYREL arg12_relation ].

particle_cp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], ... >,
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL arg12_relation & [ ARG2 handle & #mhand ] ].

particle_pp_cp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ --MIN selected_rel,
			      --SIND #cind ],
                            [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], ... >,
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL arg12_relation & [ ARG2 #cind,
				    ARG3 handle & #mhand ] ].

particle_oeq_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < synsem,
                              [ --SIND #index & non_expl-ind ],
			      #comp &
			      [ LOCAL [ CAT.VAL.SUBJ 
					 < pro_ss &
                                           [ NONLOC.SLASH 0-dlist ] >,
                                        CONT [ HOOK [ LTOP #chand,
                                                      XARG #index ] ] ] ] >,
                      KCMP #comp ],
	    CONT.HCONS <! qeq & [ HARG #mhand, LARG #chand ] !> ],
    LKEYS.KEYREL arg123_relation & [ ARG2 #index,
                                     ARG3 handle & #mhand ] ].

; DPF 19-Oct-02 - Removed SORT entity from second COMPS, since want to
; allow "that gives me an hour"
ditrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
                  < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #obj2ind & non_expl-ind &
					     [ SORT entity ] ] ],
		    [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #objind & 
					     non_expl-ind ] ], ... > ],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG2 #objind,
                                     ARG3 #obj2ind ] ].

tritrans_lt := ditrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, *top*, 
			    [ --MIN v_event_rel,
                              LOCAL.CONT.HOOK.LTOP #chand ],
				... >,
	    CONT.HCONS <! qeq & [ HARG #mhand,
				  LARG #chand ] !> ],
    LKEYS.KEYREL arg1234_relation & [ ARG4 handle & #mhand ] ].

basic_prep_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			< [ --MIN prep_rel,
                            LOCAL [ CAT.HEAD.TAM #tam & [ TENSE no_tense,
                                                          ASPECT no_aspect ],
                                    CONT [ HOOK [ INDEX [ E #tam,
                                                          --TPC #tpc ],
                                                  XARG #index ] ] ] ],
			  ... >,
            CONT [ HOOK.INDEX #index & [ --TPC #tpc ],
		   RELS.LIST < #keyrel, ... > ] ],
    LKEYS.KEYREL #keyrel ].

prep_intrans_lt := basic_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
            CONT [ HOOK.LTOP #ltop,
                   RELS <! relation !> ] ] ].

prep_intrans_nosubj_lt := basic_prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
    LKEYS.KEYREL.LBL #ltop ].

;; DPF 14-Sept-00 - This type does not conform to our assumption that only 
;; handles, indices, and external arguments of COMPS synsems can be referred 
;; to in semantic construction.  But we believe we have a better analysis on 
;; the way which collapses these collocation constructions into a more general
;; account of multi-word expressions, so we allow the hack for now.
;; DPF 24-jun-08 - Re 14-Sept-00: Now fixed.

basic_empty_prep_intrans_lt := arg1_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
                            LOCAL [ CAT.HEAD.PRD -,
				    CONT.HOOK.LTOP #lbl ] ], ... >,
    LKEYS.KEYREL.LBL #lbl ].
		   
empty_prep_intrans_lt := basic_empty_prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #objind & 
                                                  non_expl-ind ], ... >,
    LKEYS.KEYREL arg12_relation & [ ARG2 #objind ] ].

; Argument coercion as in "Kim suggests on Friday"
prep_intrans_event_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			 < [ --MIN prep_rel,
                             LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                    ASPECT no_aspect ],
                                     CONT.HOOK [ LTOP #ltop,
                                                 INDEX #event ] ] ], ... >,
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel & arg12_relation & [ ARG2 #event ] ].

prep_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND #objind ], 
                            [ --MIN prep_rel,
			      LOCAL [ CAT.HEAD [ MOD < synsem_min >,
                                               TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ] ],
				      CONT.HOOK [ LTOP #cltop,
						  INDEX.SF prop,
						  XARG #objind ] ] ], ... >,
            CONT [ RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #hand,
                                    LARG #cltop ] !> ] ],
    LKEYS.KEYREL #keyrel & arg123_relation & [ ARG3 handle & #hand ] ].

empty_prep_trans_lt := arg12_lt &
  [ LOCAL.CAT.VAL.COMPS < *top*, [ --MIN selected_rel,
				   LOCAL.CONT.HOOK [ LTOP #lbl,
						     INDEX #objind & 
						       non_expl-ind ] ], ... >,
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG3 #objind ] ].
		   
basic_prep_particle_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
	    CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL arg12_relation ].
		   
prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ --MIN independent_rel ] > ].

empty_prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ --MIN selected_rel,
                            --SIND #arg2 & non_expl-ind ] >,
    LKEYS.KEYREL.ARG2 #arg2 ].

cp_trans_lt := basic_arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
			    [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], 
			    ...>,
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL arg123_relation & [ ARG3 handle & #mhand ] ].

; "explain to Kim that ..."
pp_cp_lt := basic_empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND #index ],
			    [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ],
			    ... >,
            CONT.HCONS <! qeq & [ HARG #chand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL arg123_relation & [ ARG2 handle & #chand,
                                     ARG3 #index ] ].

double_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN prep_rel,
                              LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #event ] ] ], 
                            [ --MIN prep_rel,
                              LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #event ] ] ], ... >,
            CONT.HOOK [ LTOP #ltop,
                        INDEX #event ] ] ].

double_pp_empty_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN prep_rel,
                              LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                      CONT.HOOK.LTOP #ltop ] ], 
                            [ --MIN selected_rel,
			      LOCAL.CONT.HOOK [ LTOP #ltop,
						INDEX #objind & 
						     non_expl-ind ] ], ... >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL.ARG2 #objind ].

arg12_double_pp_lt := arg12_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ --MIN selected_rel,
                            --SIND #ind1 & non_expl-ind ], 
                          [ --MIN selected_rel,
			    LOCAL.CONT.HOOK [ LTOP #lbl,
					      INDEX #ind2 & 
						   non_expl-ind ] ], ... >,
    LKEYS.KEYREL [ LBL #lbl,
		   ARG2 #ind1,
                   ARG3 #ind2 ] ].

; DPF 24-jun-08 - FIX: should make this a subtype of arg1_subj_lt ...
s_equi_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK 
					[ LTOP #lbl,
					  INDEX #index & non_expl-ind ] ] >,
	    CONT.HOOK.XARG #index ],
    LKEYS.KEYREL arg12_relation & [ LBL #lbl,
				    ARG1 #index ] ].

equi_prd_lt := linking_type & 
  [ LOCAL [ CAT.VAL.KCMP [ --MIN independent_rel,
                           --SIND #event ],
	    CONT.RELS <! relation !> ],
    LKEYS.KEYREL.ARG2 #event ].

; ERB (14-12-97) Subj_equi verbs now require that their complement have
; a pro_ss subject.  This might be redundant if some other supertype of
; all equi verbs requires prpstn_m_rel on the complement.

; ERB (21-01-98) This pro_ss needs to be constrained to be unslashed.

subj_equi_lt := s_equi_lt &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #xarg ] >,
                    KCMP.LOCAL.CONT.HOOK.XARG #xarg ] ].

; 'try to leave'
subj_equi_inf_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL [ CAT.VAL.SUBJ < pro_ss >,
                                 CONT [ HOOK [ LTOP #vhand,
                                               INDEX.SF basic-prop] ] ],
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL.ARG2 handle & #mhand ].

subj_equi_prp_or_bse_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #hand,
                                           INDEX [ E.TENSE no_tense,
                                                   SF prop ] ],
            CONT [ RELS <! relation !>,
                   HCONS <! qeq &
			   [ HARG #chand,
			     LARG #hand ] !> ] ],
    LKEYS.KEYREL.ARG2 handle & #chand ].

; 'need not'
subj_equi_bse_n3sg_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #hand,
                                           INDEX [ E.TENSE no_tense,
                                                   SF prop ] ],
            CONT [ HOOK.LTOP #ltop,
                   RELS <! #keyrel & [ LBL #vtop ],
                           #altkeyrel &
                           [ LBL #ltop,
                             ARG1 #arg ] !>,
                   HCONS <! qeq &
			   [ HARG #chand,
			     LARG #hand ],
                            qeq &
			   [ HARG #arg,
			     LARG #vtop ] !> ] ],
    LKEYS [ KEYREL #keyrel & [ ARG2 handle & #chand ],
            ALTKEYREL #altkeyrel ] ].

obj_equi_prp_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL [ KCMP.LOCAL.CONT.HOOK [ LTOP #hand,
                                             INDEX [ E.TENSE no_tense,
                                                     SF prop ] ],
                      COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #lbl,
						    INDEX #ind ] ],
            CONT [ RELS <! relation !>,
                   HCONS <! qeq &
			   [ HARG #chand,
			     LARG #hand ] !> ] ],
    LKEYS.KEYREL [ LBL #lbl,
		   ARG2 #ind,
                   ARG3 handle & #chand ] ].

; ERB (14-12-97) comp's subj is a pro_ss.  This is probably redundant since
; the to_c_prop will say that its subject is a pro_ss.

; ERB (21-01-98) The pro_ss needs to be constrained to be unslashed.

; 'persuade Kim to leave'
obj_equi_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK 
					   [ LTOP #lbl,
					     INDEX #index & non_expl-ind ] ],
			      #comp &
			      [ LOCAL.CONT.HOOK.XARG #index ] >,
                      KCMP #comp ] ],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG2 #index ] ].

; 'persuade Kim to leave'
obj_equi_inf_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL [ CAT.VAL.SUBJ < pro_ss &
                                                [ NONLOC.SLASH 0-dlist ] >,
                                 CONT.HOOK.LTOP #vhand ],
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL.ARG3 handle & #mhand ].

; 'help Kim leave'
obj_equi_bse_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL [ CAT.VAL.SUBJ < unexpressed_reg >,
                                 CONT.HOOK [ LTOP #vhand,
                                             INDEX.SF prop ] ],
            CONT [ RELS <! relation !>,
                   HCONS <! qeq & [ HARG #mhand,
                                    LARG #vhand ] !> ] ],
    LKEYS.KEYREL.ARG3 handle & #mhand ].

basic_prd_comp_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind ] >,
		      KCMP.LOCAL.CONT [ HOOK.LTOP #chand ] ],
            CONT [ HOOK.XARG #subjind,
                   RELS <! #keyrel !>,
		   HCONS <! qeq & [ LARG #chand ] !> ] ],
    LKEYS [ KEYREL #keyrel ] ].

prd_comp_lt := basic_prd_comp_lt &
  [ LOCAL.CAT.VAL.KCMP [ --MIN independent_rel,
                         --SIND.E.TENSE untensed ] ].

obj_equi_sel_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK 
					 [ LTOP #lbl,
					   INDEX #cindex & non_expl-ind ] ], 
                            [ LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #c2index & 
                                                    non_expl-ind ] ] >,
            CONT.HCONS <! !> ],
    LKEYS.KEYREL arg12_relation & [ LBL #lbl,
				    ARG2 #cindex,
                                    ARG3 #c2index ] ].

pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					       INDEX #arg2 ] ],
			   [ LOCAL.CONT.HOOK.LTOP #chand ] >,
	   CONT.HCONS <! qeq & [ HARG #arg3, LARG #chand ] !> ],
   LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				    ARG2 #arg2,
                                    ARG3 handle & #arg3 ] ].

; 'consider Kim wise'

obj_equi_prd_lt := prd_comp_lt & obj_equi_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN basic_nom_or_mnp_rel,
			      LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #index ] ],
                            [ LOCAL.CONT.HOOK.XARG #index ] >,
            CONT.HCONS <! [ HARG #arghand ] !> ],
    LKEYS.KEYREL [ LBL #lbl,
		   ARG3 handle & #arghand ] ].

; 'promise Kim to leave'
anom_equi_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind ] >,
                      COMPS < [ LOCAL.CONT.HOOK 
					   [ LTOP #lbl,
					     INDEX #objind & non_expl-ind ] ],
			      [ LOCAL [ CAT.VAL.SUBJ < pro_ss &
						 [ NONLOC.SLASH 0-dlist ] >,
                                        CONT.HOOK [ LTOP #vhand,
                                                    XARG #subjind ] ] ] > ],
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL arg123_relation &
          [ LBL #lbl,
	    ARG3 handle & #mhand,
            ARG2 #objind ] ].

; 'turn out unreliable' (also resultatives like 'turned up drunk')
anom_equi_prd_lt := equi_prd_lt & s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ LOCAL.CONT.HOOK.INDEX #index ] >,
                  KCMP #comp,
		  COMPS < *top*,
			  #comp &
			  [ LOCAL.CONT.HOOK [ LTOP #vhand,
                                              XARG #index ] ] > ],
            CONT.HCONS <! qeq & [ HARG #mhand,
                                  LARG #vhand ] !> ],
    LKEYS.KEYREL.ARG3 #mhand ].

; 'turn out to be red'
anom_equi_particle_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ --SIND #index ] >,
		  COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ],
                          [ LOCAL [ CAT.VAL.SUBJ < pro_ss &
						   [ NONLOC.SLASH 0-dlist]>,
				    CONT.HOOK [ LTOP #vhand,
                                                XARG #index ] ] ] > ],
            CONT [ HOOK.LTOP #ltop,
                   HCONS <! qeq & [ HARG #mhand,
                                    LARG #vhand ] !> ] ],
    LKEYS.KEYREL.ARG2 handle & #mhand ].

basic_control_expr_lt := linking_type &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #chand,
                                           INDEX.SF prop ],
	    CONT [ RELS <! relation !>,
                   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & [ ARG2 handle & #mhand ] ].

ssr_expr_lt := linking_type &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #ppind ] ],
                            [ LOCAL.CONT.HOOK.LTOP #cltop ] >,
            CONT [ RELS <! relation !>,
                   HCONS <! qeq & [ HARG #arg, LARG #cltop ] !> ] ],
    LKEYS.KEYREL [ LBL #lbl,
		   ARG1 #ppind & non_expl,
                   ARG2 #arg ] ].

basic_seq_prdp_expr_lt := basic_control_expr_lt &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						 INDEX #subjind ],
			       --SIND #subjind ] >,
                      KCMP #comp,
                      COMPS < #comp,
                              [ --MIN #ocmin & selected_rel,
                                --SIND #arg ],
                              ... > ],
            CONT.HOOK.XARG #subjind ],
    LKEYS [ KEYREL [ LBL #lbl,
		     ARG1 #arg & non_expl-ind ],
            --OCOMPKEY #ocmin ] ].

seq_prdp_expr_lt := basic_seq_prdp_expr_lt &
  [ LKEYS.--OCOMPKEY _to_p_sel_rel ].

sor_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK 
					  [ LTOP #lbl,
					    INDEX #index & non_expl-ind ],
			       --SIND #index ] >,
                      COMPS < synsem,
                              [ LOCAL.CONT.HOOK.LTOP #chand ] > ],
            CONT [ HOOK.XARG #index,
                   RELS <! relation !>,
                   HCONS <! qeq & [ HARG #arg,
				    LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & [ LBL #lbl,
				    ARG1 #index,
                                    ARG2 handle & #arg ] ].
sor_prop_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK 
					  [ LTOP #lbl,
					    INDEX #index & non_expl-ind ],
			       --SIND #index ] >,
                      COMPS < synsem,
                              [ LOCAL.CONT.HOOK [ LTOP #chand,
                                                  INDEX.SF prop ] ] > ],
            CONT [ HOOK.XARG #index,
                   RELS <! relation !>,
                   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & [ LBL #lbl,
				    ARG1 #index,
                                    ARG2 handle & #mhand ] ].

expl_it_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                 INDEX it-ind & #subjind ] ] >,
                      KCMP.LOCAL.CONT.HOOK.LTOP #chand ],
            CONT [ HOOK.XARG #subjind,
                   HCONS <! qeq & [ HARG #mhand, LARG #chand ] !> ] ],
    LKEYS.KEYREL arg1_relation &
          [ LBL #hand,
            ARG1 handle & #mhand ] ].

expl_it_subj_np_cp_lt := expl_it_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					      INDEX #arg2 ] ], ... >,
    LKEYS.KEYREL arg12_relation &
                        [ LBL #lbl,
			  ARG2 #arg2 ] ].

; take, cost
expl_it_subj_np_np_cp_or_vp_lt := expl_it_subj_np_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CONT.HOOK [ LTOP #lbl,
					      INDEX #ind ] ],
                          ... >,
    LKEYS.KEYREL arg123_relation &
                        [ LBL #lbl,
			  ARG3 #ind ] ].

; cost: "It will cost (me) ten dollars for you to come along"
expl_it_subj_np_np_cp_lt := expl_it_subj_np_np_cp_or_vp_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT.VAL.SUBJ < > ].

; cost, take: "it took me ten minutes to leave"
expl_it_subj_np_np_vp_lt := expl_it_subj_np_np_cp_or_vp_lt &
  [ LOCAL.CAT.VAL [ COMPS < [ --SIND #ind ], ... >,
                    KCMP.LOCAL [ CAT.VAL.SUBJ < pro_ss >,
                                      CONT.HOOK.XARG #ind ] ] ].

expl_it_subj_pp_cp_lt := expl_it_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					      INDEX #arg ] ], ... >,
    LKEYS.KEYREL arg12_relation &
                        [ LBL #lbl,
			  ARG2 #arg ] ].

expl_it_subj_prtcl_cp_lt := expl_it_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem >,
    LKEYS.KEYREL arg1_relation ].

; 'It follows that ..."
expl_it_subj_cp_lt := expl_it_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem >,
    LKEYS.KEYREL arg1_relation ].

expl_pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL [ COMPS < [ --SIND it-ind ],
                             [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                 INDEX #arg ] ],
			       [ LOCAL.CONT.HOOK.LTOP #chand ] > ],
	   CONT [ HOOK.LTOP #ltop,
		  HCONS <! qeq & [ HARG #mhand, LARG #chand ] !> ] ],
   LKEYS [ KEYREL arg123_relation & [ ARG2 #arg,
                                      ARG3 handle & #mhand ],
           --+ARGIND it-ind ] ].

; 'leave it to Kim to find the answer'

expl_pp_inf_oeq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL.COMPS < *top*,
			 [ LOCAL.CONT.HOOK.INDEX #arg ],
			 [ LOCAL.CONT.HOOK.XARG #arg ] > ].

; 'arrange with Kim to meet her'

pp_inf_seq_lt := pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #arg1 ] >,
		   COMPS < *top*,
			  [ LOCAL.CONT.HOOK.XARG #arg1 ] > ] ].

; 'arrange it with Kim to meet her'

expl_pp_inf_seq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #arg1 ] >,
		   COMPS < *top*,
			   *top*,
			   [ LOCAL.CONT.HOOK.XARG #arg1 ] > ]].

; suffice
atrans_inf_lt := linking_type &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
	    CONT.HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ],
    LKEYS.KEYREL arg12_relation & [ ARG2 handle & #arg ] ].

particle_NP_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN selected_rel ],
                            [ LOCAL.CONT.HOOK 
				    [ LTOP #lbl,
				      INDEX #index & non_expl-ind ] ], ... > ],
    LKEYS.KEYREL arg12_relation & [ LBL #lbl,
				    ARG2 #index ] ].

NP_particle_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK
                                         [ LTOP #ltop,
					   INDEX #index & non_expl-ind ] ], 
			    synsem, ... >,
	    CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL arg12_relation & [ LBL #ltop,
                                    ARG2 #index ] ].

np_particle_pp_lt := np_particle_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            synsem,
                            synsem &
                            [ --MIN selected_rel,
			      LOCAL.CONT.HOOK 
				    [ LTOP #lbl,
				      INDEX #objind & non_expl-ind ] ], ... >],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG3 #objind ] ].

np_particle_np_lt := np_particle_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          synsem,
                          synsem &
                          [ LOCAL.CONT.HOOK 
				    [ LTOP #lbl,
				      INDEX #objind & non_expl-ind ] ], ... >,
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG3 #objind ] ].
		   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Val Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Valence types specify the number and type of subcategorized complements.
  
valence_type :< canonical_synsem.

unsat_subst := valence_type &
  [ LOCAL.CAT.VAL.SUBJ < synsem_min & [ LOCAL [ CAT nomp_cat_min,
                                                CONJ cnil ],
                                        --SIND basic_non_event ] > ].
intrans_subst := one_arg & unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < > ].

unsat_two_arg_subst := unsat_subst & abstr_lex_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ --MIN #cmin,
                                     PUNCT.LPUNCT pair_or_no_punct ], ... >,
    LEX +,
    LKEYS.--COMPKEY #cmin ].

two_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

norm_two_arg_subst := two_arg_subst & basic_two_arg.

; For verbs that passivize.
; 21-Apr-00 Changed np_cat_acc_min to nomp_cat_acc_min for e.g. "kim liked 
; hiring abrams"
; DPF 29-May-01 - Removed COMPS..MSG no_msg, since this blocked
; acc-gerunds as in "I resent you giving him that" -- later reconsidered?
; DPF 26-May-03 - We don't have one obvious place to state the constraint that
; VPs are REL empty (no pied piping within VP - Ross 67?), so let's at least
; catch a good bunch of cases with this type.
trans_subst := unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     NONLOC.REL 0-dlist,
                                     --SIND basic_non_event ], ... > ].
  
np_trans_subst := trans_subst & norm_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem >,
	    CONT.HCONS <! !> ] ].
  
; For verbs with nominal complement but that don't passivize.
non_trans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL.CONJ cnil,
                                     NONLOC.REL 0-dlist ], ... > ].
  
np_non_trans_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & 
                          [ LOCAL.CAT nomp_cat_acc_min,
                            --SIND index ] > ].

; became president
nbar_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem & 
                          [ --MIN norm_nom_rel,
                            LOCAL.CAT nbar_cat_min ] > ].

cp_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp &
                         [ LOCAL.CAT.HEAD.TAM.TENSE real_tense ],
                    COMPS < #comp & synsem &
			    [ LOCAL [ CAT s_cat_v_c,
				      CONJ cnil ],
                              NONLOC.REL 0-dlist,
                              OPT - ] > ] ].

; For input to nom-gerund lexical rule
basic_prep_intrans_subst := two_arg_subst.

prep_intrans_subst := basic_prep_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT basic_pp_cat,
				    CONJ cnil ],
                            NONLOC.REL 0-dlist ] > ].

unsat_three_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem & [ --MIN #ocmin ], ... >,
    LKEYS.--OCOMPKEY #ocmin ].

basic_three_arg_subst := unsat_three_arg_subst & basic_three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ NONLOC.REL 0-dlist ] > ].

three_arg_subst := unsat_three_arg_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ NONLOC.REL 0-dlist ] > ].

three_arg_trans_subst := three_arg_subst & trans_subst.

basic_three_arg_trans_subst := basic_three_arg_subst & trans_subst.
three_arg_nontrans_subst := three_arg_subst & non_trans_subst.
basic_three_arg_nontrans_subst := basic_three_arg_subst & non_trans_subst.

three_arg_raising_subst := basic_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event ], ... > ].

; DPF 17-sept-07 - Restricted PP compl to be non-nmod, to disambiguate e.g.
; "to" as in "bring X to Y"

basic_prep_trans_subst := basic_three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event ], 
                          synsem &
                          [ LOCAL [ CAT [ HEAD prep_or_modnp,
                                          VAL [ SPR *olist*,
                                                COMPS < > ],
                                          MC na ],
                                    CONJ cnil ] ] > ].
  
prep_trans_subst := basic_prep_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem &
                          [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD 
                                                         v_or_a_or_p ] > ] > ].

prep_non_trans_subst := three_arg_nontrans_subst & 
  [ LOCAL.CAT.VAL.COMPS < lex_synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                                 CONJ cnil ],
                                         --SIND index,
                                         LEX + ],
			  synsem &
			  [ LOCAL [ CAT basic_pp_cat,
				    CONJ cnil ] ] > ].
  
; DPF 15-Apr-02 - Maybe none of these obj_equi_prd verbs should passivize, 
; since the control of the predicative phrase is already the syntactic subject
; when the PrdP is just a VP modifier rather than a complement.  We'll try 
; making all of them prd_non_trans.

basic_prd_subst := basic_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event,
                                     OPT - ], 
			  synsem & 
			  [ LOCAL [ CAT prd_cat &
                                        [ HEAD.MOD 
                                          < [ --MIN norm_rel ] > ],
                                    CONJ cnil ],
                            OPT - ] > ].

prd_trans_subst := basic_prd_subst & trans_subst.
; DPF 14-mar-05 - Constraining NP to be definite, to block annoying spurious
; parses for e.g. "I have a meeting on Tuesday".
; DPF 20-mar-05 - But this also blocks "I have a lot of mornings free" and
; "I'll get a room ready".  So it seems we have to pay this price with
; ambiguity. Sigh.
prd_non_trans_subst := basic_prd_subst & non_trans_subst.

; Removed nonpro_rel from second NP, since we want to get "sell me this" and
; maybe even "sell me them" even if not "*sell Abrams it"
; DPF 2-Jun-02 - Put this back, since deictics no longer pron_rel.  We do give
; up "sell me them", but we really don't want "sell the customers it".
; DPF 21-may-04 - Changed nonpro_rel to nonpro_or_num_rel, consistent with
; recent treatment of number nouns.
; DPF 24-feb-05 - And then further generalized to nonpro_or_refl_or_num_rel,
; so we still get ditrans reading for "Abrams gave Browne himself"

basic_ditrans_subst := basic_three_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & 
                          [ LOCAL.CONJ cnil,
                            --SIND basic_non_event,
                            NONLOC.REL 0-dlist ], 
			  synsem & 
                          [ LOCAL.CONJ cnil,
                            --MIN nonpro_or_refl_or_num_rel,
                            --SIND basic_non_event ] > ].
  
ditrans_subst := basic_ditrans_subst & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT nomp_cat_acc_min ],
                            [ LOCAL.CAT nomp_cat_acc_min ] >,
            CONT.HCONS <! !> ] ].
  
; 'elected him president'
ditrans_np_nbar_subst := basic_ditrans_subst & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ --MIN norm_nom_rel,
                              LOCAL [ CAT nbar_cat_min,
                                      CONT.HOOK [ LTOP #nhand,
                                                  INDEX #arg ] ],
                              NONLOC.SLASH 0-dlist ] >,
            CONT [ RELS <! relation, 
                           [ PRED udef_q_rel,
                             ARG0 #arg,
                             RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ] ].
                                           
  
; 'see picture, page 2'
ditrans_nbar_np_subst := basic_ditrans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN norm_nom_rel,
                              LOCAL [ CAT nbar_cat_min,
                                      CONT.HOOK [ LTOP #nhand,
                                                  INDEX #arg ] ],
                              NONLOC.SLASH 0-dlist ],
                            [ LOCAL.CAT nomp_cat_acc_min ] >,
            CONT [ RELS <! relation, 
                           [ PRED udef_q_rel,
                             ARG0 #arg,
                             RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ] ].

  
; 'inform Kim that S'
cp_trans_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONJ cnil ],
                                       --SIND basic_non_event ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_v_c,
				      CONJ cnil ],
                              OPT - ] > ] ]. 
  
pp_cp_subst := basic_three_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem &
			    [ LOCAL [ CAT basic_pp_cat,
				      CONJ cnil ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_or_inf_unspec &
                                          [ MC - ],
				      CONJ cnil ],
                              OPT - ] > ] ].
  
np_comp_subst := basic_three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event,
                                     OPT - ],
			  [ LOCAL.CAT [ HEAD prep,
                                        VAL.COMPS < > ],
                            OPT - ] > ].
; 'talk to Kim about Sandy'
double_pp_subst := three_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT pp_cat,
                                    CONJ cnil ] ], 
			  synsem &
			  [ LOCAL [ CAT [ HEAD prep_or_modnp,
                                          VAL [ SPR *olist*,
                                                COMPS < > ],
                                          MC na ],
				    CONJ cnil ] ] > ].
  
np_trans_double_pp_subst := four_arg & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                          synsem &
                          [ --MIN #ocmin & selected_rel,
                            LOCAL [ CAT basic_pp_cat,
                                    CONJ cnil ],
                            NONLOC.REL 0-dlist ], 
                          synsem &
                          [ --MIN selected_rel,
                            LOCAL [ CAT basic_pp_cat,
                                    CONJ cnil ],
                            NONLOC.REL 0-dlist ] >,
	    CONT.HCONS <! !> ],
    LKEYS.--OCOMPKEY #ocmin ].
  
basic_inf_or_prp_intrans_subst := valence_type &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_or_prp ],
                                      CONJ cnil ],
                              --SIND.E.TENSE no_tense,
                              OPT - ] > ] ].

inf_or_prp_intrans_subst := basic_inf_or_prp_intrans_subst & 
                            unsat_two_arg_subst.

basic_inf_intrans_subst := basic_inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM inf ] > ].

inf_intrans_subst := basic_inf_intrans_subst & unsat_two_arg_subst.

inf_intrans_from_subst := basic_inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM inf_from ] > ].

inf_intrans_particle_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
                      COMPS < synsem &
                              [ --MIN selected_rel,
                                LOCAL.CONT.HOOK.LTOP #hand,
                                NONLOC.REL 0-dlist ],
                              #comp & synsem &
                              [ LOCAL [ CAT vp_cat & [ HEAD.VFORM inf ],
                                        CONT.HOOK.LTOP #hand,
                                        CONJ cnil ] ] > ] ] ].

; for "I will try and find it" - analysis following Pullum and Gazdar

inf_intrans_and_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_and ],
                                      CONJ cnil ] ] > ] ].

; for "couldn't help but notice"
inf_intrans_but_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_but ],
                                      CONJ cnil ] ] > ] ].


for_inf_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & 
			  [ LOCAL [ CAT s_cat_v_c &
					[ HEAD comp &
                                               [ VFORM inf ] ],
                                    CONJ cnil ],
                            OPT - ] > ].

inf_trans_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < [ OPT - ], 
                            #comp & synsem &
                            [ LOCAL [ CAT vp_inf_cat,
                                      CONJ cnil ],
                              OPT - ] > ] ].

inf_trans_from_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < [ OPT - ], 
                            #comp & synsem &
                            [ LOCAL [ CAT vp_cat &
                                          [ HEAD.VFORM inf_from ],
                                      CONJ cnil ],
                              OPT - ] > ] ].

inf_trans_raising_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

prp_intrans_subst := inf_or_prp_intrans_subst & basic_two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM prp ] > ].

bse_intrans_subst := unsat_two_arg_subst & basic_two_arg &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM bse ],
                                      CONJ cnil ],
                              --SIND.E.TENSE no_tense,
                              OPT - ] > ] ].

; 'make, let, watch' don't passivize.  Some of these have an apparently
; corresponding passive, but with an ordinary 'to-VP' complement, not vform bse
bse_nontrans_raising_subst := three_arg_raising_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem &
			  [ LOCAL [ CAT vp_bse_cat,
				    CONJ cnil ],
                            OPT - ] > ].

; want (doesn't passivize)
basic_inf_non_trans_subst := unsat_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL.CAT nomp_cat_acc_min,
                                       --SIND index ],
                            #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

inf_non_trans_subst := basic_inf_non_trans_subst & basic_three_arg_subst.

prp_non_trans_subst := basic_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL.CAT nomp_cat_acc_min,
                                       --SIND index,
                                       OPT - ],
			    #comp & synsem &
			    [ LOCAL [ CAT vp_prp_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

basic_pp_vp_subst := valence_type &
  [ LOCAL.CAT.VAL [ KCMP #comp,
                    COMPS < synsem &
                            [ --MIN selected_rel,
                              LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ],
                              NONLOC.REL 0-dlist,
                              PUNCT.LPUNCT no_punct ],
                            #comp & synsem &
                            [ LOCAL [ CAT vp_cat & [ HEAD.VFORM inf_or_prp ],
                                      CONJ cnil ],
                              PUNCT.LPUNCT no_punct,
                              OPT - ] > ] ].

basic_pp_inf_subst := basic_pp_vp_subst &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT vp_inf_cat ].

pp_inf_subst := basic_pp_inf_subst & unsat_three_arg_subst.

; We treat raising as the identification of the CONT attribute of the SUBJ and
; the COMPS.SUBJ, rather than the whole synsem, in part to enable the 
; underspecification of the base/non3sg lex-entry for verbs, where otherwise
; CASE information would clash in examples like "Kim believes Sandy to be 
; ready."  In fact, we only identify the INDEX of the two subjects - see 
; comments by sor_inf_subst.
; 
; DPF 17-Nov-99 - The LTOP handle of the SUBJ must be identified with the
; KEY.LBL of the ssr_subst predicate, since contracted negation auxiliary
; verbs have the LTOP be the neg_rel's handle, but the subject as in 
; "I can't leave" should have its LBL identified with that of the
; can_rel, not the neg_rel.

subj_control_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #sind & basic_non_event ] >,
                    COMPS < [ LOCAL [ CAT.VAL.COMPS < >,
                                      CONT.HOOK.XARG #sind ],
                              OPT - ], ... > ] ].

ssr_subst := subj_control_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #xarg ] >,
            CONT.HOOK.XARG #xarg ] ].

ssr_two_arg_subst := ssr_subst & basic_two_arg.

ssr_inf_subst := ssr_subst & inf_intrans_subst.

ssr_pp_inf_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
	   [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                        INDEX #subj ] ] >,
	     COMPS < synsem &
		     [ --MIN _to_p_sel_rel,
                       LOCAL [ CAT basic_pp_cat & 
                                   [ HEAD.MOD < > ],
                               CONJ cnil ] ] ,
		     [ LOCAL [ CAT [ HEAD verbal & [ VFORM inf ],
                                     VAL [ SUBJ < [ NONLOC [ SLASH 0-dlist,
                                                             REL 0-dlist,
                                                             QUE 0-dlist ] ] >,
                                           COMPS < > ] ],
                               CONT.HOOK.XARG #subj ],
                       OPT - ] > ],
            CONT.HOOK.LTOP #ltop ] ].

seq_prdp_pp_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
              [ COMPS < [ LOCAL 
			  [ CAT [ HEAD [ PRD +,
                                         TAM.TENSE no_tense,
                                         MOD < [ LOCAL intersective_mod ] > ],
                                  VAL [ SUBJ *olist*,
                                        SPR *olist*,
					COMPS < > ],
				  MC na ],
                            CONT.HOOK.XARG #xarg ],
                          OPT - ],
                        synsem &
			[ LOCAL [ CAT basic_pp_cat &
                                      [ HEAD.MOD < > ],
				  CONJ cnil ] ] > ],
	    CONT.HOOK.XARG #xarg ] ].

expl_pp_cp_subst :=  basic_three_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ] ], 
                            synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c,
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

expl_np_cp_subst :=  basic_three_arg_subst & trans_subst &
  [ LOCAL.CAT.VAL [ COMPS < [ OPT - ], 
                            synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].

expl_np_cp_fin_subst := expl_np_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ LOCAL.CAT s_cat_fin_v_c ] > ].

four_arg_subst := unsat_three_arg_subst & four_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem & [ --MIN #ocmin,
                                     NONLOC.REL 0-dlist ],
                          synsem, ... >,
    LKEYS.--OCOMPKEY #ocmin ].

; 'cost/take' - restrict first NP to non-measure-NP, and the second to MNP.
; But this is too strong for second argument, since "a couple of days" is not
; analyzed as a MNP.
expl_np_np_cp_subst :=  four_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT nomp_cat_acc_min &
                                          [ VAL.SPEC < anti_synsem_min > ],
				      CONJ cnil ],
                              --SIND basic_non_event ], 
			    synsem &
			    [ LOCAL [ CAT [ HEAD nominal &
                                                 [ POSS -,
                                                   MOD < > ],
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ],
                                            MC na_or_- ],
				      CONJ cnil ] ], 
			    synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].
                                                 
expl_np_np_cp_inf_subst := expl_np_np_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem,
                          [ LOCAL.CAT.HEAD.VFORM inf ] > ].

expl_prtcl_cp_subst :=  basic_three_arg_subst & particle_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem, 
                            synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c,
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

expl_cp_subst :=  norm_two_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c & [ HEAD comp ],
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

expl_vp_subst :=  norm_two_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem & #keycomp &
                            [ LOCAL [ CAT vp_inf_cat,
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

; Raising synsems have to identify the LOCAL value of the raised synsem with
; that of the VP's subject's synsem, rather than identifying the synsems
; themselves, due to our lexical threading of SLASH: if the raised complement
; is extracted, it will be of type gap, and therefore have a non-empty SLASH,
; but we don't want the lower VP complement's subject to also then have a
; non-empty SLASH.  But cf. note above for subj-subj raising, where maybe we
; even want to restrict the identity to CONT only.
;   Indeed, this seems necessary, since CASE blocks unification for
; 'Kim made him sleep' where our (dual-purpose) 'sleep' requires its subject
; to be [CASE nom] (in order to block the sentence "them sleep"), but when its
; subject is raised to object as with "make", there's a conflict with the
; [CASE acc] on the object of "make".  So here again, we make the raising
; identity hold only for CONT.
; DPF (30-Apr-99) In fact, we now have to further restrict the identity to
; only the INDEX, since if we identify all of CONT, we get the handles of the
; higher NP and the VP's subject being identified, but since we also want to 
; lexically identify a predicate's handle with that of its arguments (subject
; to classes of lexical exceptions like for entries with CP complements), we 
; get an unwanted identity of the handles of the higher and lower verbs through
; the identity of the two NPs.  So if we can't sustain this minimal 
; identification for equi and raising, we'll have to give up on identifying 
; the handles of lexical entries and their arguments.  Possible trouble spots 
; are locative inversions like "On the corner seemed to be an abandoned house".

sor_inf_subst := inf_trans_raising_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL.AGR #agr,
                            --SIND #subj,
                            OPT - ], 
			  [ LOCAL [ CAT.VAL.SUBJ 
					     < [ LOCAL.AGR #agr,
                                                 NONLOC [ SLASH 0-dlist,
                                                          REL 0-dlist,
                                                          QUE 0-dlist ] ] >,
                                    CONT.HOOK [ XARG #subj,
                                                INDEX.E.TENSE no_tense ] ],
				OPT - ] > ].

sor_bse_subst := bse_nontrans_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj,
			    OPT - ], 
                          canonical_synsem &
			  [ LOCAL [ CAT.VAL.SUBJ 
					  < [ NONLOC [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] >,
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

sor_inf_non_trans_subst := inf_non_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj,
			    OPT - ],
			  [ LOCAL [ CAT.VAL.SUBJ 
					     < [ NONLOC [ SLASH 0-dlist,
                                                          REL 0-dlist,
                                                          QUE 0-dlist ] ]>,
                                    CONT [ HOOK.XARG #subj ] ] ] > ].


sor_prd_subst := three_arg_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj ], 
			  [ LOCAL [ CAT basic_prd_cat &
                                        [ HEAD.TAM.TENSE untensed ],
				    CONJ cnil,
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

sor_prd_trans_subst := sor_prd_subst & trans_subst.
sor_prd_nontrans_subst := sor_prd_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CAT prd_cat ] > ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; DPF 20-jun-07 - Instead, make first comp be abstr_lex_synsem, rather than
; the hack we tried for awhile of requiring the RELS list to be <! !> - this
; sort of worked, but we don't want to depend on unification failure for
; features that we will sometimes restrict for efficiency, and it was ugly.

particle_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < abstr_lex_synsem &
                          [ --MIN selected_rel,
                            LOCAL.CAT.HEAD.PRD -,
                            NONLOC [ SLASH 0-dlist,
                                     REL 0-dlist,
                                     QUE 0-dlist ],
                            OPT - ], ... > ].


;; DPF (29-Jan-99) Modified particle_NP_subst to exclude pronominal NP objects,
;; to block *Kim looked up it"
; DPF 2-Sept-04 - Changed COMPS.REST.FIRST..CAT from nomp_cat_acc_min to
; nomp_cat_nonnom_min to allow np_cp's like "We wrote down who won".

particle_NP_subst := particle_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
			  synsem & 
                          [ LOCAL [ CAT nomp_cat_nonnom_min,
                                    CONJ cnil ],
                            --MIN nonpro_or_refl_or_num_rel,
                            --SIND basic_non_event,
                            NONLOC.REL 0-dlist,
                            OPT - ], ... > ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; Instead, identify single-word particles by constraint on RELS - a hack.

generic_NP_particle_subst := trans_subst & abstr_lex_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ],
                            synsem &
                          [ --MIN #cmin & selected_rel,
                            LOCAL [ CAT.HEAD.PRD -,
                                    CONT.RELS <! !> ],
                            NONLOC [ SLASH 0-dlist,
                                     REL 0-dlist,
                                     QUE 0-dlist ],
                            OPT - ], ... > ],
    LEX +,
    LKEYS.--COMPKEY #cmin ].

NP_particle_subst := generic_NP_particle_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

NP_particle_pp_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
                          synsem,
                          synsem &
                          [ --MIN #ocmin,
                            LOCAL [ CAT basic_pp_cat,
                                    CONJ cnil ],
                            NONLOC.REL 0-dlist,
                            OPT - ] >,
	    CONT.HCONS <! !> ],
    LKEYS.--OCOMPKEY #ocmin ].

NP_particle_np_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
                          synsem,
                          synsem &
                          [ LOCAL [ CAT nomp_cat_acc_min,
                                    CONJ cnil ],
                            --SIND basic_non_event,
                            NONLOC.REL 0-dlist,
                            OPT - ] >,
	    CONT.HCONS <! !> ] ].

particle_plus_subst := particle_subst & basic_three_arg_subst.

particle_prd_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem & 
			  [ LOCAL [ CAT prd_cat,
				    CONJ cnil ],
                            NONLOC.REL 0-dlist,
                            OPT - ] > ].

; 'turn out to be'
particle_inf_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

; 'keep on driving'
particle_prp_subst := particle_subst & basic_three_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_prp_cat,
				      CONJ cnil ] ] > ] ].

particle_pp_subst := particle_plus_subst &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
                            synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ],
                              NONLOC.REL 0-dlist ] >,
            CONT.HCONS <! !> ] ].

; 'find out that S'
particle_cp_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
                              OPT - ] > ] ].

; 'point out to Kim that S'
particle_pp_cp_subst := particle_subst & four_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ],
                              NONLOC.REL 0-dlist ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
                              OPT - ] > ] ].

particle_oeq_subst := particle_NP_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem, synsem,
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

; 'leave it to Kim to find the answer'
expl_pp_inf_subst := four_arg_subst & trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < [ OPT - ], 
			    synsem &
			    [ LOCAL [ CAT basic_pp_cat,
				      CONJ cnil ],
                              NONLOC.REL 0-dlist,
                              OPT - ] ,
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

;; 'bet Kim a fortune that Sandy would win'
;; DPF (19-Oct-98) Added hack to block extraction from the CP complement, since
;; don't know how to avoid topicalized imperative parse for "Abrams bet Browne
;; Chiang slept with subject of "slept" topicalized.

np_np_cp_subst := four_arg_subst & trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONJ cnil ],
                                       --SIND basic_non_event ],
			    synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONJ cnil ],
                                       --SIND basic_non_event,
                                       NONLOC.REL 0-dlist ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
			      NONLOC.SLASH 0-dlist ] > ] ].

; E.g., "I'm not doing too badly"
; DPF 30-aug-04 - Changed COMPS..HEAD p_or_adv to just adv, since we were
; overgenerating "Kim did in Paris", and it's not clear why we wanted prep.

adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
			    [ LOCAL 
			      [ CAT [ HEAD adv &
                                       [ MOD < [ LOCAL intersective_mod ] > ],
                                      VAL [ SPR *olist*,
                                            COMPS < > ] ],
                                CONT.HOOK [ LTOP #hand,
                                            INDEX #event ] ],
                              NONLOC.REL 0-dlist,
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERB SYNSEMS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Verb synsems should inherit from one valence type and one linking type.
; The type verb_synsem is given a non-empty SPR value so VPs can be modified
; by PPs, but (hack) the synsem is of type anti_synsem_min to block unification, 
; to avoid ever picking up an actual specifier.
;   Added VIT links for the moment, to satisfy VIT requirements for visibility
; of TENSE and MOOD information.  (Actually, moved VITTENSE specification to
; the various inflectional affixes in lexrules.tdl, to accommodate the collapse
; of the base and fin-non3sg verb forms.
; DPF (8-Jul-98) Added QUE 0-dlist, REL 0-dlist to block pied piping in verb
; phrases (taking advantage of lexical amalgamation of these features, together
; with our treatment of subject-WH as extraction (where only local features are
; propagated in SLASH).
; DPF 8-dec-03 - Removed QUE 0-dlist, since we may now be ready for in-situ
; WH-questions.

basic_verb_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD verb & [ MOD < anti_synsem_min >,
                                MINORS.MIN v_event_rel ],
                  VAL [ SUBJ < synsem_min & #subj >,
			SPR < anti_synsem_min >,
			COMPS #comps ] ],
	    ARG-S < #subj . #comps > ],
    LKEYS.KEYREL event_relation,
    NONLOC.REL 0-dlist,
    MODIFD notmod ].

norm_verb_synsem := basic_verb_synsem &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.AGR.PNG #png ] >,
            AGR.PNG #png ] ].

verb_synsem := norm_verb_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD.TAM #tam,
            CONT.HOOK.INDEX.E #tam ] ].

atrans_verb := verb_synsem & intrans_subst & atrans_lt &
  [ LOCAL.CAT.HEAD.MINORS.MIN weather_v_rel ].

onearg_verb := verb_synsem & intrans_subst & arg1_subj_lt.
unerg_verb := onearg_verb.
twoarg_verb_synsem := verb_synsem & two_arg.
passive_or_unacc_synsem :< unsat_subst.
unacc_verb := onearg_verb & passive_or_unacc_synsem.
  
; For at least main verb "have" (e.g, "Kim has some rice")
poss_verb := twoarg_verb_synsem & two_arg_subst & poss_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
			        	       CONJ cnil ],
                                       --SIND index,
                                       NONLOC.REL 0-dlist ] >,
            CONT.RELS.LIST.FIRST #keyrel ],
    LKEYS.KEYREL #keyrel ].
  
np_trans_verb := verb_synsem & np_trans_subst & trans_lt.
  
np_non_trans_verb := twoarg_verb_synsem & np_non_trans_subst & trans_lt.

np_trans_refl_verb := twoarg_verb_synsem & np_non_trans_subst & trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #arg2 ] >,
	    CONT [ HOOK.XARG #arg1 ,
		   RELS <! [ LBL #lbl ], [ LBL #lbl,
					   PRED id_rel,
					   ARG1 #arg1 & [ PNG #png ],
					   ARG2 #arg2 & [ PNG #png ] ] !> ] ]].

nbar_verb := verb_synsem & basic_two_arg & nbar_subst & trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nhand,
                                                INDEX #arg ] ] >,
            CONT [ RELS <! relation, 
                           [ PRED udef_q_rel,
                             ARG0 #arg,
                             RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ] ].


basic_prep_intrans_verb := verb_synsem & prep_intrans_subst & basic_two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT basic_pp_cat ] > ].

;; come to
prep_intrans_verb := basic_prep_intrans_verb & prep_intrans_lt & two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT pp_cat ] > ].

;; fall into
prep_intrans_unacc_verb := basic_prep_intrans_verb & prep_intrans_lt
                           & two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN dir_or_unsp_loc_rel,
                            LOCAL.CAT [ HEAD prep_or_modnp &
                                             [ MOD < [ LOCAL.CAT.HEAD noun ]>],
                                        VAL [ SPR *olist*,
                                              COMPS < > ],
                                        MC na ] ] > ].

;; thanks (hack)
prep_intrans_nosubj_verb := basic_prep_intrans_verb & prep_intrans_nosubj_lt.

;; look for
;;
empty_prep_intrans_verb := twoarg_verb_synsem & prep_intrans_subst &
			   empty_prep_intrans_lt.

;; run for mayor
empty_prep_nospr_verb := verb_synsem & prep_intrans_subst & basic_two_arg & 
                         empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nhand,
                                                INDEX #nind ] ] >,
            CONT [ RELS <! relation, [ PRED udef_q_rel,
                                       ARG0 #nind,
                                       RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ] ].

;; suggest on Tuesday
;;
prep_intrans_event_verb := twoarg_verb_synsem & prep_intrans_subst &
			   prep_intrans_event_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT pp_cat ] > ].

;; verbs of motion
prep_intrans_dir_verb := twoarg_verb_synsem & basic_prep_intrans_subst &
                         prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN dir_or_unsp_loc_rel,
                            LOCAL.CAT [ HEAD prep_or_modnp &
                                             [ MOD < synsem &
                                                     [ LOCAL.CAT.HEAD noun ]>],
                                        VAL [ SPR *olist*,
                                              COMPS < > ],
                                        MC na ] ] > ].

;; put, move
;;
; DPF 17-sept-07 - Restricted PP compl to be non-nmod, to disambiguate e.g.
; "to" as in "bring X to Y"
;
basic_prep_trans_verb := verb_synsem & prep_trans_subst & prep_trans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD 
                                                         v_or_a_or_p ] > ] > ].
prep_trans_verb := basic_prep_trans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ OPT - ] > ].
  
;; change one's mind about X (where 'about' is only noun-modifier)
prep_trans_verb_nmod := basic_prep_trans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ LOCAL.CAT.HEAD.PRD +,
                                       OPT - ] > ].

;; remind-of
;;
empty_prep_trans_verb := verb_synsem & basic_prep_trans_subst & 
                         empty_prep_trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, [ LOCAL.CAT basic_pp_cat ] >,
            CONT.HCONS <! !> ] ].

;; interest him in X
;;
empty_prep_non_trans_verb := verb_synsem & prep_non_trans_subst & 
			     empty_prep_trans_lt.

;; get-hold-of
;;
;empty_prep_nbar_verb := verb_synsem & prep_nbar_subst & 
;			     empty_prep_nbar_lt.


;; regard Kim as tall
np_as_verb := verb_synsem & np_comp_subst & obj_equi_sel_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ --MIN _as_p_sel_rel & #min,
                            LOCAL.CAT.VAL.SUBJ *olist* ] >,
    LKEYS [ --OCOMPKEY #min,
            --+OCOMPKEY #min ] ].

;; strike Kim as tall
np_as_seq_verb := verb_synsem & np_comp_subst & basic_prd_comp_lt &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #index ] ],
                              #comp & 
                              [ --MIN _as_p_sel_rel & #min,
                                LOCAL.CONT.HOOK.XARG #sind ] >,
                      KCMP #comp ],
            CONT [ HOOK.XARG #sind,
                   HCONS <! [ HARG #arg2 ] !> ] ],
    LKEYS [ KEYREL arg12_relation & [ LBL #lbl,
				      ARG1 #index,
                                      ARG2 #arg2 ],
            --OCOMPKEY #min,
            --+OCOMPKEY #min ] ].

; DPF 4-Jun-01 - Changed dative-to to be contentful "to", in order to sustain
; 'underspecified' semantics for "kim sent it to Sandy/Paris".  Verbs like 
; "hand" are now of type empty_to_trans_verb.
; DPF 3-May-03 - But since then we've altered our views again, and are now
; treating "send" as taking an empty to-PP, so we do the same for derived
; to-datives as well.
  
empty_to_trans_verb := empty_prep_trans_verb &
  [ LKEYS.--OCOMPKEY _to_p_sel_rel ].

ditrans_verb := verb_synsem & ditrans_subst & ditrans_lt.
  
ditrans_only_verb := verb_synsem & ditrans_subst & ditrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

; 'elect him president'
ditrans_np_nbar_verb := verb_synsem & ditrans_np_nbar_subst & ditrans_lt.

; 'see picture, page 2.'
ditrans_nbar_np_verb := verb_synsem & ditrans_nbar_np_subst & ditrans_lt.

; 'talk to Kim about Sandy'
; DPF 26-aug-04 - Counter-intuitively, constrain second complement to be
; noun-modifying PP, to avoid spurious ambiguity (at present) for e.g.
; 'they range from low prices to high prices'
double_pp_verb := verb_synsem & double_pp_subst & double_pp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD
                                   < [ LOCAL.CAT.HEAD verb ] > ],
                          [ LOCAL.CAT.HEAD.MOD
                                   < [ LOCAL.CAT.HEAD noun ] > ] > ].

; Unwanted type if freer order of obliques- 'pay with a check for it"
double_pp_empty_pp_verb := verb_synsem & double_pp_subst & 
                           double_pp_empty_pp_lt.

; 'change the meeting from Tuesday to Wednesday'
; 'pay the money to Browne for the ticket'
np_trans_double_pp_verb := verb_synsem & np_trans_double_pp_subst & 
                           arg12_double_pp_lt.

; Raising verbs which take an infinitival complement restrict it to being
; [ MSG no_msg ], which ensures that the VP will be headed by the 
; non-propositional "to" complementizer, which identifies its handle with
; that of its VP complement.

ssr_verb := verb_synsem & ssr_inf_subst & basic_two_arg &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT.HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !> ],
    LKEYS.KEYREL arg1_relation & [ ARG1 handle & #arghand ] ].

ssr_noimp_verb := ssr_verb &
  [ LOCAL.CAT.HEAD.VFORM fin_or_non_fin ].

; 'It started raining'
ssr_prp_verb := verb_synsem & ssr_subst & prp_intrans_subst &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT.HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !> ],
    LKEYS.KEYREL arg1_relation & [ ARG1 handle & #arghand ] ].

ssr_pp_inf_verb := verb_synsem & ssr_pp_inf_subst & ssr_expr_lt.

seq_prdp_pp_verb := verb_synsem & seq_prdp_pp_subst & seq_prdp_expr_lt.

seq_prdp_pp_about_verb := verb_synsem & seq_prdp_pp_subst & 
                          basic_seq_prdp_expr_lt &
  [ LKEYS.--OCOMPKEY _about_p_sel_rel ].

sor_verb := verb_synsem & sor_inf_subst & sor_lt.

sorb_verb := verb_synsem & sor_bse_subst & sor_prop_lt.

sor_non_trans_verb := verb_synsem & sor_inf_non_trans_subst & sor_lt.

sor_pp_inf_verb := verb_synsem & pp_inf_subst & basic_three_arg_subst
                   & sor_lt.

sor_prd_verb := verb_synsem & sor_prd_trans_subst & sor_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CAT prd_cat & [ HEAD adj ] ] > ].

sor_prd_nontrans_verb := verb_synsem & sor_prd_nontrans_subst & sor_lt.

subj_equi_prp_verb := verb_synsem & prp_intrans_subst & 
                      subj_equi_prp_or_bse_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT [ HEAD verb,
                                        VAL.SUBJ < pro_ss > ] ].

subj_equi_bse_verb := verb_synsem & bse_intrans_subst &
                      subj_equi_prp_or_bse_lt.

; 'You need not stay'
subj_equi_bse_n3sg_verb := verb_synsem & bse_intrans_subst &
                           subj_equi_bse_n3sg_lt.

ssr_two_arg_verb := ssr_two_arg_subst & aux_verb.

; "K became quiet"
subj_prd_verb := verb_synsem & subj_control_subst &
                 basic_prd_comp_lt &
  [ LOCAL [ CAT.VAL [ COMPS < synsem & #comp &
                              [ LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                       ASPECT.PROGR - ],
                                        CONJ cnil ] ], ... >,
                      KCMP #comp ],
            CONT.HCONS <! [ HARG #arghand ] !> ],
    LKEYS [ KEYREL.ARG2 handle & #arghand ] ].

subj_equi_prd_verb := subj_prd_verb & prd_comp_lt & basic_two_arg & 
                      subj_equi_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT basic_prd_cat ] > ].

subj_equi_prd_nogap_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem > ].

subj_equi_prd_adj_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem &
                          [ OPT -,
                            LOCAL.CAT.HEAD adj ] > ].

subj_equi_prd_prep_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                            LOCAL.CAT.HEAD prep ] > ].

; "K got hired"
; DPF 3-Jul-03 - Need to block "*Kim got hiring" - seems to be same need to
; distinguish passive from pres-participle - group passive with A and P.
subj_equi_prd_v_a_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                            LOCAL.CAT.HEAD v_or_a ] > ].

; 'shows as empty'
subj_equi_empty_prep_verb := subj_prd_verb & s_equi_lt & basic_two_arg &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #index ] >,
                    COMPS < [ OPT -,
                              --MIN selected_rel,
                              LOCAL [ CAT [ HEAD prep,
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ] ],
                                      CONT.HOOK.INDEX #index ] ] > ] ].

; DPF 15-Apr-02 - Changed these to prd_non_trans_subst, since get spurious 
; ambiguity with alternate analysis of PrdP as adjunct, with right semantics in
; passive case.  
; DPF 13-Oct-03 - But that adjunct analysis gives the wrong semantics for
; "Kim was made angry" where we what result proposition, not state of Kim
; while she was made. So changing back to 

obj_equi_prd_verb := verb_synsem & prd_trans_subst & obj_equi_prd_lt.

obj_equi_prd_adj_verb := obj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CAT.HEAD adj ] > ].

obj_equi_non_trans_prd_verb := verb_synsem & prd_non_trans_subst & 
			       obj_equi_prd_lt.

; 'I have X to get rid of'
; VFORM fin_or_non_fin prevents imperative "*Have Kim to get rid of." which
; led to spurious ambiguity.
obj_equi_vpslash_prd_verb := verb_synsem & basic_inf_non_trans_subst & 
                             tough_three_arg & arg1_subj_lt &
  [ LOCAL [ CAT [ HEAD.VFORM fin_or_non_fin,
                  VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #ind & non_expl-ind ],
				OPT - ],
                              [ LOCAL.CONT [ HOOK [ LTOP #vltop,
                                                    XARG #xarg ] ],
                                NONLOC.SLASH <! unexpr_local &
                                              [ CAT np_cat_acc_min &
                                                    [ HEAD.MOD < > ],
                                                CONT.HOOK.INDEX #ind ] !> ] >],
            CONT [ HOOK.XARG #xarg,
                   HCONS <! qeq & [ HARG #mltop,
                                    LARG #vltop ] !> ] ],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG2 #ind,
                                     ARG3 #mltop ] ].


; ERB (07-10-96) I am working with the verb 'know' as a prototype for a verb
; that selects by the semantic type (for now expressed as a feature) of its
; sentential complement rather than by the value of CMP or some such hack.  In
; order to do so, I have changed the types around here.  In particular, I am
; adding a new type cp_prop+ques_intrans_verb that takes a sentential
; complement but doesn't care if its a proposition or a question (for verbs
; like 'know').  A further axis of variation is the VFORM of the complement
; (fin vs. inf).  Since my analysis of 'know' never makes use of the resolved
; subtypes (e.g., cp_prop_intrans_verb) I am not adding to the resolved
; subtypes, and just making the old ones inherit from the finite side of
; things for now.  The future inf_cp_prop_intrans_verb will probably be the
; type of subject equi verbs. A further future modification would involve the
; addition of cp_command_intrans_verb and cp_command+prop_intrans_verb for
; verbs like 'insist'.
;
; DPF (19-Jun-98) This type cannot itself simply add the complement CP's 
; (underspecified) message to its RELS, since the generation algorithm requires
; that no relation on RELS will ever get more specialized during parsing.  So 
; we make MSG be list-valued (the empty list for all but complementizers
; and clauses), and have the Head-Complement rule append the values of MSG
; from both of its daughters, since the msg comes from the head if it's a
; complementizer, and from the non-head if the head is a verb.

basic_cp_prop+ques_verb := basic_verb_synsem &
  [ LOCAL [ CAT.VAL.KCMP [ LOCAL.CAT.HEAD verbal & [ INV - ],
                           OPT - ],
            CONT.RELS.LIST < relation, ... > ] ].

norm_cp_prop+ques_verb := basic_cp_prop+ques_verb & verb_synsem.

cp_prop+ques_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.--SIND [ E.MOOD ind_or_modal_subj,
                                SF prop-or-ques ] ].

fin_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_fin_unspec ].

fin_or_inf_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_fin_or_inf_v_c ].

cp_like_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT s_cat_fin_v_c,
                         --SIND.SF like-iforce ] ].

bse_cp_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP canonical_synsem & [ LOCAL.CAT s_cat_bse ] ].

;; DPF 4/21/98 - Moved [ COMPS.FIRST.LOCAL.CAT.MC - ] from cp_ques_intrans_verb
;; to cp_intrans_verb, to block spurious parse for e.g. "Kim knows who left"

cp_intrans_verb := fin_cp_prop+ques_verb & cp_intrans_subst & basic_two_arg &
		   arg12h_lt & cp_comp_verb.

cp_like_intrans_verb := cp_like_verb & cp_intrans_subst & basic_two_arg &
                        arg12h_lt &
  [ LOCAL.CAT.VAL.COMPS 
                   < canonical_synsem &
                     [ --SIND.SF like-iforce ] > ].
; Type for inputs to cp_passive lexical rule
cp_passivable_verb := basic_verb_synsem.

; Type for inputs to inverted_quote_lr for "Kim arrived, said Abrams"
cp_comp_verb := basic_verb_synsem.

cp_fin_inf_intrans_verb := fin_or_inf_cp_prop+ques_verb & cp_intrans_subst &
                           basic_two_arg & arg12h_lt & cp_passivable_verb &
                           cp_comp_verb.

; 'wonder'
cp_ques_fin_inf_intrans_verb := cp_fin_inf_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < >,
                            --SIND.SF ques ] > ].

#|
; 'know'
cp_prop_fin_inf_intrans_verb := cp_fin_inf_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND.SF prop ] > ].
|#

cp_intrans_passivable_verb := cp_intrans_verb & cp_passivable_verb.

cp_prop_intrans_verb := cp_intrans_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND.SF basic-prop ] > ].

cp_only_prop_intrans_verb := cp_intrans_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp,
                            --SIND.SF basic-prop ] > ].

cp_ques_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < >,
                            --SIND.SF ques ] > ].

;; suppose
cp_prop_raise_key_verb := basic_cp_prop+ques_verb & cp_intrans_subst & 
                          basic_two_arg & arg12h_lt & cp_passivable_verb &
                          cp_comp_verb &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                  VAL [ KCMP.LOCAL.CAT s_cat_fin_unspec &
                                       [ HEAD.INV - ],
                        COMPS < [ --MIN #min,
                                  LOCAL [ CONT.HOOK.INDEX.SF basic-prop,
                                          AGR #agr ],
                                  OPT - ] > ] ],
            CONT.RELS <! relation !>,
            AGR #agr ] ].

; Make lexical entries inflected (manual entries for each form, sigh) since 
; can't use inflectional rules to do it since they constrain AGR which is 
; here instead identified with complement's AGR.
v_cp_prop_raise_key_lexent := main_verb_sans_key & 
  [ INFLECTD +,
    SYNSEM cp_prop_raise_key_verb ].

;; tell Kim that/whether S
;; inform Kim that S
np_trans_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &
                    cp_comp_verb.

np_trans_cp_fin_or_inf_verb := fin_or_inf_cp_prop+ques_verb & cp_trans_subst & 
                               cp_trans_lt & cp_comp_verb.

;; bet Kim ten cents that S
np_np_cp_verb := fin_cp_prop+ques_verb & np_np_cp_subst & tritrans_lt.

;; explain to Kim that S
pp_cp_verb := cp_prop+ques_verb & pp_cp_subst & pp_cp_lt & cp_passivable_verb &
              cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND non_expl-ind ], 
			  synsem > ].

pp_cp_fin_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
                  cp_passivable_verb & cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND non_expl-ind ],
                          synsem > ].

pp_expl_cp_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
                   cp_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND it-ind ], synsem > ].

;; ask Kim whether S
np_trans_cp_ques_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &
                         cp_comp_verb & cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL [ CAT.VAL.SUBJ < >,
                                            CONT.HOOK.INDEX.SF ques ] ]> ].

;; persuade Kim that S
np_trans_cp_prop_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &
                         cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
			  [ --SIND.SF basic-prop ] > ].

;; ask that Kim be released
cp_bse_intrans_verb := bse_cp_verb & cp_intrans_subst & basic_two_arg &
                       arg12h_lt & cp_passivable_verb.

;; try to
subj_equi_verb := cp_prop+ques_verb & inf_intrans_subst & basic_two_arg & 
                  subj_equi_inf_lt.

; refrain from Ving
subj_equi_from_verb := cp_prop+ques_verb & inf_intrans_from_subst & 
                       basic_two_arg & subj_equi_inf_lt.

;; try and find it
;; Allow "I/you/we/they try and find it" but block "*He tries and find it"
;; but allow "I/you/we/they/he will try and find it" and "Try and find it".
subj_equi_and_verb := cp_prop+ques_verb & inf_intrans_and_subst & 
                      basic_two_arg & subj_equi_inf_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
            CONT.HOOK.INDEX.E.ASPECT no_aspect ],
    LKEYS [ --COMPKEY #cmin,
            --+COMPKEY #cmin ] ].

;; couldn't help but notice
subj_equi_but_verb := cp_prop+ques_verb & inf_intrans_but_subst & 
                      basic_two_arg & subj_equi_inf_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
            CONT.HOOK.INDEX.E.ASPECT no_aspect ],
    LKEYS [ --COMPKEY #cmin,
            --+COMPKEY #cmin ] ].

;; have yet to find it
ssr_particle_verb := verb_synsem & inf_intrans_particle_subst & 
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min & v_event_rel,
                  VAL [ SUBJ < [ --SIND #sind ] >,
                        COMPS < [ OPT - ],
                                [ --MIN #min,
                                  LOCAL [ CAT.HEAD verbal & [ INV - ],
                                          CONT.HOOK [ LTOP #cltop,
                                                      XARG #sind ] ],
                                  OPT - ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
                          XARG #sind ],
                   RELS <! [ LBL #ltop,
                             PRED #pred,
                             ARG1 #argh ] !>,
                   HCONS <! qeq & [ HARG #argh,
                                    LARG #cltop ] !> ] ],
    LKEYS.KEYREL.PRED #pred ].

;; tell, persuade
obj_equi_verb := cp_prop+ques_verb & inf_trans_subst & obj_equi_inf_lt.

;; help
obj_equi_bse_verb := verb_synsem & sor_bse_subst & obj_equi_bse_lt.

;; appeal, intend
oeq_pp_inf_verb := verb_synsem & pp_inf_subst & basic_three_arg & 
                   obj_equi_inf_lt & empty_prep_intrans_lt.

;; gear up the team to ...
particle_oeq_verb := cp_prop+ques_verb & particle_oeq_subst & four_arg &
                     particle_oeq_lt.

;; arrange with kim to meet
pp_inf_seq_verb := cp_prop+ques_verb & pp_inf_subst & basic_three_arg & 
                   pp_inf_seq_lt.

; promise
anom_equi_verb := cp_prop+ques_verb & inf_non_trans_subst & anom_equi_lt.

; use X to do Y
anom_equi_trans_verb := cp_prop+ques_verb & inf_trans_subst & anom_equi_lt &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

; take too long to do X
anom_equi_oblig_verb := anom_equi_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
                          [ --MIN non_ellipt_rel ] > ].

; have trouble sleeping
anom_equi_prp_verb := verb_synsem & prp_non_trans_subst & obj_equi_prp_lt.

; prevent X from Ving
obj_equi_from_verb := cp_prop+ques_verb & inf_trans_from_subst & 
                      obj_equi_inf_lt.

particle_inf_verb := cp_prop+ques_verb & particle_inf_subst & 
		     anom_equi_particle_lt.

particle_prp_verb := verb_synsem & particle_prp_subst & 
		     subj_equi_prp_or_bse_lt.

particle_cp_verb := fin_cp_prop+ques_verb & particle_cp_subst & 
		    particle_cp_lt & cp_passivable_verb.

particle_pp_cp_verb := fin_cp_prop+ques_verb & particle_pp_cp_subst & 
		       particle_pp_cp_lt & cp_passivable_verb.

expl_it_subj_pp_cp_verb := norm_cp_prop+ques_verb & expl_pp_cp_subst & 
		     expl_it_subj_pp_cp_lt.

expl_it_subj_np_cp_verb := norm_cp_prop+ques_verb & expl_np_cp_subst & 
                           expl_it_subj_np_cp_lt.

; 'It costs me ten dollars for you to enter'
expl_it_subj_np_np_cp_inf_verb := norm_cp_prop+ques_verb & 
                          expl_np_np_cp_inf_subst & expl_it_subj_np_np_cp_lt.

expl_it_subj_np_np_vp_inf_verb := norm_cp_prop+ques_verb & 
                          expl_np_np_cp_inf_subst & expl_it_subj_np_np_vp_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
                          [ LOCAL.CAT.VAL.SUBJ
                                    < pro_ss & 
                                      [ NONLOC.SLASH 0-dlist ] > ] > ].

expl_it_subj_prtcl_cp_verb := norm_cp_prop+ques_verb & expl_prtcl_cp_subst & 
                              expl_it_subj_prtcl_cp_lt.

expl_it_subj_cp_verb := norm_cp_prop+ques_verb & expl_cp_subst & 
                        expl_it_subj_cp_lt.

expl_it_subj_vp_verb := norm_cp_prop+ques_verb & expl_vp_subst & 
                        expl_it_subj_cp_lt.

expl_pp_inf_oeq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_oeq_lt.

expl_pp_inf_seq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_seq_lt.

atrans_inf_verb := cp_prop+ques_verb & inf_intrans_subst & basic_two_arg & 
		   atrans_inf_lt.

for_to_verb := verb_synsem & for_inf_intrans_subst & basic_two_arg & arg12h_lt.

particle_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

; 'going on'
particle_3only_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND.PNG.PN 3 ] >,
                    COMPS < *top* > ] ].

generic_particle_NP_verb := verb_synsem & particle_NP_subst & particle_NP_lt.

generic_NP_particle_verb := verb_synsem & generic_NP_particle_subst & 
                            NP_particle_lt.

NP_particle_verb := generic_NP_particle_verb & NP_particle_subst.

; 'credit back the money to the account'
NP_particle_pp_verb := generic_NP_particle_verb & NP_particle_pp_subst &
                       NP_particle_pp_lt.

; 'give him back his dog'
NP_particle_np_verb := generic_NP_particle_verb & NP_particle_np_subst &
                       NP_particle_np_lt.

NP_particle_noalt_verb := NP_particle_verb.

particle_prd_verb := verb_synsem & particle_prd_subst & anom_equi_prd_lt.

particle_pp_verb := verb_synsem & particle_pp_subst & 
		    prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CAT pp_cat ] > ].

particle_empty_pp_verb := verb_synsem & particle_pp_subst & 
                          empty_prep_particle_intrans_lt.

; prefer it if ...
expl_obj_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & expl_obj_cp_lt.

; make it clear that ...
; This type should be redundant with the sor_prd_verb type, but CP-taking
; adjs constrain their MOD..HEAD to be no_head (for some doubtless good
; reason), so they won't unify with the prd_cat constraint on the second
; complement of sor_prd_verbs.  FIX? ...
expl_obj_prd_verb := verb_synsem & sor_prd_trans_subst & expl_obj_prdp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND it-ind,
                            OPT - ], 
                          [ LOCAL.CAT.HEAD adj ] > ].

; 'i am doing fine/badly/well', but also 'how are you doing?'
adv_verb := verb_synsem & adv_subst & arg1_subj_lt & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < *top* >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel ].

; Inverted verbs of saying: "Kim left, said Sandy"
quoting_verb_inv_synsem := basic_two_arg &
  [ LOCAL [ CAT [ HEAD verb & 
                       [ VFORM fin,
                         TAM #tam ],
                  VAL.SUBJ *anti_list* ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #event & [ E #tam ] ],
                   RELS.LIST < #keyrel, ... > ],
            CONJ cnil ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     ARG0 #event ] ].

; DPF 13-May-02 - Made passive_synsem inherit from basic_verb_synsem rather
; than verb_synsem since we don't want it to be subtype of lex_synsem, since
; simple passives can be post-nominal modifiers, as in "the price quoted is
; too high"

basic_passive_synsem := norm_verb_synsem & passive_or_unacc_synsem & 
                        lex_synsem &
  [ LOCAL [ CAT [ HEAD [ AUX -,
                         VFORM pas ],
                  VAL [ SUBJ < synsem_min &
                               [ LOCAL [ CAT nomp_cat_min,
					 CONT.HOOK.INDEX #ind,
                                         CONJ cnil ],
                                 --SIND #ind & basic_non_event ] >] ],
            CONJ cnil ] ].

passive_synsem := basic_passive_synsem &
  [ LOCAL.CAT.VAL.COMPS *obliquecons* &
                        < synsem & 
                          [ --MIN _by_p_cm_rel,
                            LOCAL local &
                                  [ CAT [ HEAD prep,
                                          VAL [ SUBJ < >,
                                                SPR *olist*,
                                                COMPS < > ] ] ],
                            NONLOC.REL 0-dlist,
                            OPT + ], ... > ].

passive_atrans_synsem := passive_synsem & atrans_lt &
  [ LOCAL.CAT.VAL.SUBJ < synsem > ].

basic_passive_unerg_synsem := passive_synsem &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --MIN nom_or_mnp_rel,
                               --SIND #sindex & basic_non_expl ] >,
                      COMPS < [ --SIND #cindex ] > ],
            CONT [ HOOK [ INDEX #index,
                          XARG #sindex ],
                   RELS.LIST < [ ARG0 #index,
                                 ARG1 #cindex,
                                 ARG2 #sindex ], ... > ] ] ].

; born
passive_unerg_synsem := basic_passive_unerg_synsem &
  [ LOCAL.CONT [ HOOK.LTOP #ltop,
                 RELS <! [ LBL #ltop ] !> ] ].

; unevaluated
passive_unerg_neg_synsem := basic_passive_unerg_synsem &
  [ LOCAL [ CAT.MC na,
            CONT [ HOOK [ LTOP #ltop,
                          XARG #xarg ],
                   RELS <! [ LBL #lbl,
                             ARG0 #event ], 
                           [ PRED neg_rel,
                             LBL #ltop,
                             ARG0.E.TENSE no_tense,
                             ARG1 #arg ],
                           [ LBL #lbl,
                             PRED parg_d_rel,
			     ARG0 event & [ E.TENSE no_tense ],
                             ARG1 #event,
                             ARG2 #xarg ] !>,
                   HCONS <! qeq & [ HARG #arg,
                                    LARG #lbl ] !> ] ] ].

ssr_particle_v_lexent := nonc-hm & word &
  [ INFLECTD -,
    SYNSEM ssr_particle_verb &
           [ LOCAL.CAT.HEAD verb & [ AUX -,
                                     INV - ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modifier synsems
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; When changing, remember to also modify verb_participle_affix in lexrules.tdl
isect_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod,
                             NONLOC.REL 0-dlist ] >,
	    CONT.HOOK.LTOP #hand ],
    LKEYS.KEYREL.LBL #hand ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The semantics of a main verb consists of the "main" handel for the sentence
; and a list of relations.  A pointer to the main or head relation in the list
; is kept in the LKEYS.KEYREL attribute.
;
; DPF 26-Jan-01 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.

basic_main_verb_sans_key := nonc-h &
  [ SYNSEM [ LOCAL [ CAT.HEAD verb & [ AUX -,
                                       INV -,
                                       TAM [ TENSE #tense,
                                             ASPECT #aspect,
                                             MOOD ind_or_subj ],
                                       MINORS [ MIN v_event_rel,
                                                ALTMIN role_rel ] ],
                     CONT [ HOOK.INDEX #index & [ E [ TENSE #tense,
                                                      ASPECT #aspect ] ],
                            RELS.LIST < relation & #keyrel, ... > ] ],
             LKEYS.KEYREL #keyrel & [ ARG0 #index ] ] ].

main_verb_sans_key := basic_main_verb_sans_key &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

basic_main_verb := main_verb_sans_key &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN nonaux_event_rel,
                       MC na ] ].

main_verb_newltop := basic_main_verb_sans_key &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN nonaux_event_rel ].

main_verb := basic_main_verb &
  [ INFLECTD -,
    SYNSEM.LOCAL.CONT.RELS <! relation !> ].

main_verb_mliszt := basic_main_verb &
  [ INFLECTD - ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; AUXILIARY VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Auxiliary verbs are subject-to-subject raising verbs which also raise the 
; content of the VP complement, possibly tacking an additional relation on the
; end.  They also raise the context of the VP complement, for now at least to
; propagate tense information.
; AUX verbs are further classified by the type of VP complement they 
; select for.  Also, AUX verbs optionally take a neg (post-head) specifier.

aux_verb := verb_synsem &
  [ LOCAL [ CAT.HEAD.TAM #tam,
	    CONT.HOOK.INDEX.E #tam ] ].
		
aux_verb_ssr_subst := aux_verb & ssr_subst.


aux_verb_ssr := aux_verb_ssr_subst & basic_two_arg &
  [ LOCAL.CAT [ HEAD.MINORS [ MIN #min,
                              ALTMIN #altmin ],
                VAL [ KCMP #comp & [ LOCAL.CAT.HEAD.MINORS.ALTMIN #altmin ],
                      COMPS < #comp, ... > ] ],
    LKEYS.KEYREL.PRED #min ].

aux_verb_word_super := nonc-hm & word &
  [ INFLECTD + ]. 

aux_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
           [ LOCAL.CAT [ HEAD.AUX +,
                         POSTHD + ] ] ].

bse_aux_verb_word := aux_verb_word &
  [ SYNSEM.LOCAL.CAT [ POSTHD +,
                       VAL.COMPS < synsem &
                                   [ LOCAL [ CAT vp_bse_unspec_cat,
                                             CONJ cnil ],
                                     OPT - ] > ] ].
;; ought, going
inf_aux_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL.CAT [ POSTHD +,
                         VAL.COMPS < synsem &
				     [ LOCAL [ CAT vp_inf_cat,
					       CONJ cnil ],
                                       --SIND.SF basic-prop,
				       OPT - ] > ] ],
    ALTS.VPELLIP - ].

;; Only for auxiliary "have" and "should+of"
psp_aux_verb_word := aux_verb_word &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL.CAT.VAL.COMPS < synsem &
                                   [ LOCAL [ CAT vp_cat &
                                                 [ HEAD verb &
                                                        [ VFORM psp ] ],
                                             CONJ cnil ],
                                     OPT - ] > ] ].
; Only for the copula
; DPF 29-Nov-02 - Predicative copula has to identify COMPS..MOD..INDEX with
; COMPS..XARG since predicative PPs cannot lexically identify XARG with their
; KEY.ARG1, because PPs acting as modifiers of VPs have to project the XARG
; of the VP.
; DPF 20-Nov-03 - But now identifying INDEX of PP with its event, not its XARG.
; DPF 30-aug-05 - Note that we can't make the complement be REL 0-dlist since
; we use the relative clause for the purposive "Kim is to stay."
; DPF 01-Dec-06 - To avoid circularity in generator for e.g. "We could have
; been hiring Browne.", we depend on hack which makes "have" be POSTHD -,
; while other auxiliaries are POSTHD +, to block "been having been ..." 
; FIX?

prd_aux_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
     [ LOCAL [ CAT [ HEAD [ AUX +, 
                            MINORS.MIN be_v_prd_rel ],
                     POSTHD +,
                     VAL.COMPS 
                     < [ LOCAL [ CAT basic_prd_cat &
                                     [ HEAD.MINORS [ MIN independent_rel,
                                                     NORM norm_rel ],
                                       VAL.SUBJ *olist*,
                                       POSTHD + ],
                                 CONT.HOOK [ INDEX #index &
                                                   [ E.TENSE tense ],
                                             XARG #ind ] ],
                         --SIND #index,
                         NONLOC.REL 0-dlist,
                         OPT - ] > ],
               CONT.HOOK [ INDEX #index,
                           XARG #ind ],
               ARG-S < [ NONLOC [ SLASH [ LIST #smiddle,
                                          LAST #slast ],
                                  REL #rel,
                                  QUE [ LIST #qmiddle,
                                        LAST #qlast ] ] ],
                       [ NONLOC [ SLASH [ LIST #sfirst,
                                          LAST #smiddle ],
                                  QUE [ LIST #qfirst,
                                        LAST #qmiddle ] ] ] > ],
       NONLOC [ SLASH [ LIST #sfirst,
                           LAST #slast ],
                REL #rel,
                QUE [ LIST #qfirst,
                      LAST #qlast ] ] ] ].

raise_cont := word_or_lexrule &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                       INDEX #index ] ], ... >,
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index ],
			  RELS <! !> ] ] ].

add_cont := word_or_lexrule &
  [ SYNSEM [ LOCAL.CONT.RELS.LIST < relation & #keyrel, ... >,
             LKEYS.KEYREL #keyrel ] ].
		   
; Real modal verbs are auxiliary verbs which select a base form complement.
; They only exist in finite forms.
; DPF 2-Oct-01 - Removed [KCMP..INDEX.E.TENSE no_tense] since this
; prevented low attachment of "when" in "when can Kim arrive"

generic_modal_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #chand,
                                                    INDEX.E.TENSE no_tense ],
                     CONT [ HOOK.INDEX #event,
			    HCONS.LIST < qeq &
					   [ HARG #arghand,
					     LARG #chand ], ... > ] ],
             LKEYS.KEYREL arg1_relation &
                          [ ARG0 #event,
                            ARG1 handle & #arghand ] ] ].

fin_modal_verb_word := generic_modal_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
				VFORM fin ],
			 POSTHD +,
			 VAL.SUBJ < synsem & [ LOCAL 
                                                [ CAT nomp_cat_nom_min,
                                                  CONJ cnil ],
                                               --SIND basic_non_event,
                                               OPT - ] > ],
		   CONT psoa ] ].

ought_verb_word := fin_modal_verb_word & inf_aux_verb_word &
  [ SYNSEM.LOCAL.CAT [ HEAD [ AUX -,
                              TAM [ TENSE present,
                                    ASPECT no_aspect ] ],
                       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.TAM.TENSE no_tense ] ].

; Assume for now that all modals have simple present tense semantics,
; ignoring the habitual past readings possible for "would" and "could" -
; these will have to be separate lexical entries.
; DPF 26-Jun-03 - Changed this to allow underspecification of tense for at
; least 'could'

modal_verb_word := fin_modal_verb_word & bse_aux_verb_word &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ OPT - ] >,
                           COMPS.FIRST [ LOCAL.CAT vp_bse_cat,
                                         --SIND.SF basic-prop ] ] ].

modal_pos_lex_ent := modal_verb_word & add_cont &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ AUX +,
                                TAM indic_tam ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #keyrel & [ PRED modal_rel,
				      LBL #ltop ] ] ].

modal_pos_indic_lexent := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD indicative ].

pos_ought_verb_word := ought_verb_word &
  [ SYNSEM [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! #keyrel !>,
                          HCONS <! qeq !> ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

; 'used (to)' - Exclude modifiers intervening before VP-inf complement.
;
past_ought_verb_word := fin_modal_verb_word & inf_aux_verb_word &
  [ ALTS.ADVADD -,
    SYNSEM [ LOCAL [ CAT [ HEAD [ AUX -,
                                  TAM [ TENSE past,
                                        ASPECT no_aspect ] ],
                           VAL.COMPS < [ MODIFD notmod_or_rmod ] > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

;; DPF 24-Jun-03 ***FIX?:  [ HEAD.MOD < anti_synsem_min >,
basic_quasimodal_verb_word := generic_modal_verb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN _going+to_v_modal_rel,
                                  TAM [ TENSE real_tense,
                                        ASPECT.PROGR + ] ],
                           VAL [ COMPS.FIRST #comp,
                                 KCMP #comp ] ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
				      PRED will_modal_rel ] ] ].

quasimodal_word := basic_quasimodal_verb_word & inf_aux_verb_word &
  [ SYNSEM.LOCAL.CAT.HEAD.AUX + ].

quasimodal_psp_word := inf_aux_verb_word & generic_modal_verb_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ VFORM psp,
                                TAM.TENSE present,
                                AUX -,
                                PRD -],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #keyrel &
                   [ LBL #ltop ] ] ].

quasimodal_bse_word := basic_quasimodal_verb_word & bse_aux_verb_word &
  [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM prp,
                              PRD + ],
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat,
                                     --SIND.SF basic-prop ] > ] ].

; 'didn't he used to sing?'
nonfin_modal_word := generic_modal_verb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ PRD -,
                                  VFORM bse,
                                  AUX -,
                                  TAM [ TENSE past,
                                        ASPECT [ PRF -,
                                                 PROGR - ] ] ],
                           VAL.COMPS < canonical_synsem &
                                       [ LOCAL.CAT vp_inf_cat,
                                         --SIND.SF basic-prop ] >],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

; DPF 09-Jan-00 - Removed SLASH 0-dlist from COMPS.FIRST, since it was blocking
; e.g. "When's he leaving"
; DPF 13-apr-05 - Instead, make COMPS.FIRST be expressed_synsem.  Also seems
; to make ALTS.VPELLIP - unnecessary.

contracted_aux_word := word &
  [ ALTS [ VPELLIP -,
           SQPNCT - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST expressed_synsem,
    GENRE nonformal ].

; copula, 'exists'
; DPF 12-Apr-02 - The second (predicative) complement was being blocked by
; MIN no_rel - avoided unwanted ambiguity, but now prevents e.g. "where is
; there a problem" since we now want to avoid spurious adjunct extraction.
; So removed no_rel, and instead require this second complement to be 
; non_canonical - allows extraction, but not the spuriosity of in-situ PrdPs.
; DPF 01-Feb-03 - Since we're now allowing adjunct extraction for independent
; reasons, let's try abandoning that second complement of the 'there'-copula
; altogether.  Then we avoid the awkward semantic composition problem of
; having to find the LBL of the noun_rel inside the first complement - does
; violence to our semantic algebra.
; DPF 28-oct-03 - Restored the three-arg there-copula since we need it at
; least for extractions like "what is there to do" (& "there is nothing to do")
; where the last complement has a non-empty rel (to avoid spurious ambig).
; Since the optional second complement will be RELS non-empty, can't use the
; default appending of non-local feats, so have to do cumbersome repeat here,
; to avoid propagating that non-empty RELS.  But don't want to say explicitly
; here that it's non-empty, since then constraint on *olist* not satisfied.
; DPF 28-jun-07 - Constrain second complement to be non-extracted, to avoid
; spurious ambiguity for "In Berlin, there are cats"

; there-copula and it-cleft copula

expl_verb_synsem := unsat_three_arg_subst & verb_synsem & norel_three_arg &
  [ LOCAL [ CAT [ VAL [ SUBJ < [ --SIND expl-ind & #subjind ] >,
                        COMPS < synsem &
			    [ LOCAL [ AGR non_expl,
				      CONJ cnil ],
                              --SIND #cind,
                              NONLOC.REL 0-dlist,
                              OPT - ],
			    [ LOCAL local &
				    [ CAT [ HEAD 
                                             [ MOD < synsem &
                                                     [ --SIND #cind ]> ],
                                            VAL [ SPR *olist*,
                                                  SUBJ *olist*,
						  COMPS < > ],
					    MC na ],
                                      CONT.HOOK.XARG #cind ],
                              NONLOC.SLASH 0-dlist ] > ] ],
            CONT.HOOK.XARG #subjind ],
    LKEYS.KEYREL arg1_relation &
          [ ARG1 #cind & non_expl ] ].

; DPF 25-oct-05 - Removed second comp's [PRD -] since PP's need to be + (see 
; note (same date) for p_reg_lexent), while (most) relative clauses are [PRD -]
there_verb_synsem := expl_verb_synsem &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND there-ind & 
                                      [ PNG [ PN #pn,
                                              GEN no_gend_there ] ] ] >,
                    COMPS < [ --MIN nonpro_or_refl_or_num_rel & #min ,
                              LOCAL [ CAT np_cat_acc_min & [ HEAD #head ],
                                      AGR.PNG [ PN #pn,
                                                GEN neut ] ] ],
                            [ LOCAL [ CAT [ HEAD v_or_a_or_p &
                                            [ MOD < [ LOCAL intersective_mod &
                                                         [ CAT.HEAD #head ],
                                                      --MIN #min ] > ],
                                            MC na,
                                            POSTHD + ],
                                      CONT.HOOK [ LTOP #lbl,
                                                  INDEX.E.TENSE no_tense ],
                                      CONJ cnil ],
                              LEX -,
                              OPT + ] > ],
    LKEYS.KEYREL.LBL #lbl ].

; DPF 19-jan-08 - Try removing AUX + so we can parse e.g. "In Paris it
; was Kim who laughed."
itcleft_verb_synsem := expl_verb_synsem & aux_verb &
  [ LOCAL [ CAT [ VAL [ SUBJ < [ --SIND it-ind & [ PNG.GEN no_gend_it ] ] >,
			COMPS < synsem & [ LOCAL [ CAT [ HEAD n_or_p &
                                                            [ POSS -,
                                                              CASE acc,
                                                              PRD + ],
                                                       VAL [ SUBJ *olist*,
                                                             SPR *olist*,
                                                             COMPS < > ],
                                                       MC na_or_- ],
                                                 CONT.HOOK.LTOP #cltop ],
                                         NONLOC non-local_none ],
                              [ LOCAL 
                                [ CAT [ HEAD verb & 
                                        [ VFORM fin,
                                          MOD < [ LOCAL 
                                                  [ CAT.HEAD supnoun ] ] >],
                                        VAL.SUBJ *olist*,
                                        MC na ],
                                  CONT.HOOK.LTOP #cltop ],
                                OPT - ] > ] ] ],
    LKEYS [ KEYREL [ PRED _be_v_itcleft_rel,
                     ARG2 #cltop ],
            --+ARGIND it-ind ] ].

; 'In the corner is a chair'
; 'Especially popular is Rondane'
; POSTHD - is hack to prevent these from undergoing adjunct extraction
; DPF 12-nov-05 - Generalized subj to be v_or_a_or_p (from just a_or_p)
; to get e.g. "Also contributing to their success was ..."
; Also prevent spurious gapping of complements
; DPF 09-may-06 - SUBJ..ALTMIN blocks npadv phrases, to avoid spurious
; ambiguity for e.g. "There is Kim."
; DPF 06-jul-06 - But this also blocks "Here is Kim." and "There stood Kim".
; So instead constrain NORM, but only for the copula.
; DPF 10-sept-07 - Changed COMPS..--MIN from nonpro_rel to reg_or_temp_nom_rel
; to avoid unwanted analyses with gerunds, as in "...in the tree is arising..."

loc_inv_verb_word := noncqrs-hm & word &
  [ SYNSEM twoarg_verb_synsem & 
     [ LOCAL [ CAT [ HEAD [ AUX -, 
                            INV -,
                            MINORS.MIN aux_arg1_rel ],
                     VAL [ SUBJ < canonical_synsem &
                                  [ --MIN independent_rel,
                                    LOCAL
                                    [ CAT basic_prd_cat &
                                          [ HEAD v_or_a_or_p &
                                                 [ MOD < [ --SIND #sind ] > ],
                                            VAL.SUBJ *olist* ],
                                      CONT.HOOK 
                                          [ INDEX event,
                                            XARG #sind & individual_min ] ],
                                    OPT - ] >,
                           COMPS < synsem_min & 
                                   [ LOCAL [ CAT nomp_cat_min,
                                             AGR #agr,
                                             CONJ cnil ],
                                     --MIN reg_or_temp_nom_rel,
                                     --SIND ref-ind,
                                     OPT - ] > ] ],
               AGR #agr,
               CONT.HOOK.LTOP #ltop ],
       NONLOC non-local_none,
       LKEYS.KEYREL.LBL #ltop ] ].

loc_inv_be_word := loc_inv_verb_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				PRD -,
                                TAM.MOOD indicative ],
                         VAL [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                          INDEX #ind &
                                                             [ E.TENSE tense ],
                                                          XARG #xarg ] ] >,
                               COMPS < [ --SIND #xarg ] > ],
                         POSTHD - ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #ind & [ SF prop-or-ques ],
				   XARG #xarg ],
			    RELS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

; 'lie, stand'
; DPF 20-apr-08 - Added identity of SUBJ..INDEX and own XARG, to block
; spurious analysis of "Kim would ride the horse."
loc_inv_mv_word := loc_inv_verb_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK [ LTOP #ltop,
							    INDEX #xarg,
                                                            XARG #index ] ]] >,
                               COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
							   INDEX #cind ] ] > ],

                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #index,
				   XARG #xarg ],
                            RELS <! #keyrel !> ] ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
                                      ARG0 #index,
                                      ARG1 #cind ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NOUNS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;       TYPE                 ISA                what's it for?
;       nominal_synsem       lex_synsem         all nouns
;       xpro_synsem          nominal_synsem     pro v. non-pro dimension
;       xref_synsem          nominal_synsem     ref v. non-ref dimension
;       pronominal_synsem    xpro_synsem        all pronouns
;       nonpronominal_synsem xpro_synsem        all non-pronominal nouns
;       ref_synsem           xref_synsem        personal pro's & nouns
;       non_ref_synsem       xref_synsem        it, there, wh-pronouns
;       ref_pro_synsem       pronominal_synsem  personal pronouns
;                            & ref_synsem
;       non_ref_pro_synsem   pronominal_synsem  it, there, wh-pronouns
;                            & non_ref_synsem
;       noun_synsem          nonpronominal_synsem all non-pro nouns
;                            & ref_synsem 

; The "default" statement that most nouns identify their AGR and INDEX
; will live on noun_synsem and non_ref_pro_synsem, and then be restated for
; personal pronouns other than my special 'they'.  (All this because I can't
; be bothered now to set up a special default type...) 

; DPF 3-May-03 - Why can't we make [MODIFD notmod] true for all nouns, rather
; than stipulating it on (almost) all subtypes?  Who wants to stay unmarked?
; Answer: day-of-month nouns like "tenth", which can combine with the simple
; determiner "the" and still be modifiers: "He arrived the tenth" but "*He
; arrived the week"

nominal_synsem := basic_lex_synsem & 
  [ LOCAL [ CAT [ HEAD.POSS -,
		  VAL.SPCMPS < > ],
	    CONT nom-obj ] ].

xpro_synsem :< nominal_synsem.
xref_synsem :< nominal_synsem.

; DPF 23-Jul-99 - Add missing MOD < >.

pronominal_synsem := xpro_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD partn &
		       [ MOD < > ],
		  VAL.SUBJ < > ] ] ].

nonpronominal_synsem :< xpro_synsem.

; AAC - added following types for verbal_gerund, poss_clitic etc

nonpro_nomod_synsem := nomod_synsem & nonpronominal_synsem.
nomod_onearg_synsem := nomod_synsem & one_arg.
nonpro_nomod_onearg_synsem := nonpro_nomod_synsem & basic_one_arg.

ref_synsem := xref_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN basic_nom_rel,
                  VAL.SPEC < anti_synsem_min > ],
            CONT [ HOOK.INDEX #inst & non_expl-ind,
                   RELS.LIST < nom_relation & #keyrel & 
                               [ ARG0 #inst ], ... > ] ],
    LKEYS.KEYREL #keyrel ].

non_ref_synsem := xref_synsem & nomod_synsem & zero_arg &
  [ LOCAL.CAT.VAL [ SPR < >,
		    COMPS < >,
                    SPEC < anti_synsem_min > ] ].

ref_pro_synsem := pronominal_synsem & ref_synsem & nomod_synsem.

non_ref_pro_synsem := pronominal_synsem & non_ref_synsem &
  [ LOCAL [ AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

basic_noun_synsem := nonpronominal_synsem & ref_synsem &
  [ LOCAL.CAT.HEAD noun_or_ttl ].

noun_synsem := basic_noun_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD noun,
            AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

mass_or_count_synsem := basic_noun_synsem.
count_noun_synsem := mass_or_count_synsem &
  [ LOCAL.CONT.HOOK.INDEX.IND + ]. 

;;
;; Common nouns
;;
;; DPF 16-Nov-00 - Added SPR.NONLOC.SLASH 0-dlist - don't know how we did
;; without this up to now.
;; DPF 14-Jul-01 - Well, we don't actually want SPR..SLASH 0-dlist since it
;; blocks free relative det constructions like "whichever person you hired"
;; where the "whichever" has a non-empty SLASH value.  Don't know what
;; motivated the above addition of 0-dlist, but I'm sure we'll soon see.
; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).
; DPF 8-Jun-03 - Removed SPR..COMPS *olist* since want to allow discontinuous
; analysis for e.g. "a week and a half"
; DPF 8-Jun-03 - Try requiring sprs of nouns to be LEX +, to block "*a and a
; half week" while enabling "a week and a half".  May want to consider making
; the head-spec rule impose this constraint on all specifiers, given similar
; need for allowing "kim is as tall as Sandy" but blocking "*Kim is as as 
; Sandy tall"

basic_unsp_common_noun_synsem := basic_noun_synsem & lex_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
	    CAT [ HEAD.MINORS.ALTMIN #spmin,
                  VAL [ SPR < #spr & synsem &
                              [ --MIN #spmin & quant_rel,
                                LOCAL.CAT [ HEAD det,
                                            VAL [ SUBJ < >,
                                                  SPR *olist* ] ],
                                LEX + ] >,
                        COMPS #comps,
                        SPEC < anti_synsem_min > ] ] ] ].

; Exclude dom nouns, to allow "the January 11 meeting"
unsp_common_noun_synsem := basic_unsp_common_noun_synsem &
  [ LOCAL.CAT [ HS-LEX -,
                VAL.SPR < [ OPT - ] > ] ].
            
basic_common_noun_synsem := unsp_common_noun_synsem & noun_synsem.

basic_count_noun_synsem := basic_common_noun_synsem & count_noun_synsem.
common_noun_synsem := basic_count_noun_synsem.

unsp_count_noun_nocomp_synsem := unsp_common_noun_synsem & count_noun_synsem &
                                 basic_one_arg & nonpro_nomod_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

common_noun_nocomp_synsem := basic_count_noun_synsem & basic_one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

basic_mass_or_count_synsem := unsp_common_noun_synsem & nonpro_nomod_synsem &
                              mass_or_count_synsem.

basic_mass_or_count_nocomp_synsem := basic_mass_or_count_synsem & one_arg &
  [ LOCAL.CONT.RELS <! relation !> ].

mass_or_count_nocomp_synsem := basic_mass_or_count_nocomp_synsem & 
                               basic_common_noun_synsem.

noun_nocomp_synsem := common_noun_nocomp_synsem & nonpro_nomod_onearg_synsem.

noun_nonpro_nomod_synsem := basic_common_noun_synsem & nonpro_nomod_synsem.
noun_two_arg_nomod_synsem := noun_nonpro_nomod_synsem & basic_two_arg.

; DPF 22-Jul-03 - Constraint on COMPS < expressed_synsem, ... > ensures that
; this complement is either realized or discharged via noptcomp, to avoid
; spurious ambiguity.

unsp_noun_ppcomp_synsem := unsp_common_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < expressed_synsem &
                          [ --MIN #cmin,
                            LOCAL [ CAT [ HEAD prep & [ PRD - ],
					  VAL.COMPS < > ],
				    CONT.HOOK.LTOP #lbl ],
                            PUNCT.LPUNCT no_punct ], ... >,
    LKEYS [ KEYREL.LBL #lbl,
	    --COMPKEY #cmin ] ].

basic_noun_ppcomp_synsem := unsp_noun_ppcomp_synsem & basic_common_noun_synsem.

noun_nondeverb_ppcomp_synsem := basic_noun_ppcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #index ] >,
    LKEYS.KEYREL.ARG1 #index ].

unsp_ppcomp_two_arg_synsem := unsp_noun_ppcomp_synsem & basic_two_arg &
                              nonpro_nomod_synsem & count_noun_synsem.

noun_ppcomp_two_arg_synsem := unsp_ppcomp_two_arg_synsem &
                              basic_noun_ppcomp_synsem & common_noun_synsem.

noun_ppcomp_three_arg_synsem := basic_noun_ppcomp_synsem & three_arg &
                                nonpro_nomod_synsem & common_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          expressed_synsem &
                          [ --MIN #ocmin,
                            LOCAL [ CAT [ HEAD prep & [ PRD - ],
                                          VAL.COMPS < > ],
                                    CONT.HOOK.LTOP #hand ],
                            PUNCT.LPUNCT no_punct ] >,
    LKEYS [ KEYREL.LBL #hand,
            --OCOMPKEY #ocmin ] ].

; DPF 25-mar-05 - Added MODIFD notmod to avoid spurious ambig with adjN rules.
; DPF 26-mar-05 - But this conflicts with the constraint in the NP-ADV rule
; which distinguishes "we arrived the week before" from "*we arrived the week"
; since we also want "We arrived Tuesday".  So try just excluding lmod value.

temp_noun_comp_two_arg_synsem := basic_two_arg & count_noun_synsem & 
                                 nonpro_nomod_synsem & 
  [ LOCAL [ CAT [ HEAD noun & [ MINORS.MIN temp_abstr_rel ], 
                  VAL [ SUBJ < >,
                        SPR < [ OPT - ] >,
                        SPEC < anti_synsem_min > ] ],
	    CONT.HOOK.INDEX.SORT time ] ].

temp_noun_ppcomp_two_arg_synsem := temp_noun_comp_two_arg_synsem &
                                   basic_noun_ppcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
			    LOCAL.CONT.HOOK.INDEX #index ] >,
    LKEYS.KEYREL.ARG1 #index,
    MODIFD notmod_or_rmod ].

; For e.g. "hotel" as in "the hotel Marriott" or "the Marriott hotel Hannover"c
basic_noun_nomcomp_synsem := noun_nonpro_nomod_synsem &
  [ LOCAL [ CAT.VAL.KCMP expressed_synsem & 
                         [ LOCAL.CONJ cnil,
                           --SIND #cindex ],
            CONT [ HOOK [ LTOP #hand,
                          INDEX #index ],
		   RELS.LIST < relation, 
                               prep_notense_relation & #altkeyrel &
                               [ LBL #hand,
                                 PRED compound_rel,
                                 ARG1 #index,
                                 ARG2 #cindex ], ... > ] ],
    LKEYS [ KEYREL.LBL #hand,
            ALTKEYREL #altkeyrel ] ].

basic_noun_npcomp_synsem := basic_noun_nomcomp_synsem &
  [ LOCAL [ CAT.VAL.KCMP [ --MIN abstr_named_rel,
                           LOCAL [ CAT nomp_cat_acc_min,
                                   CONT.HOOK [ LTOP #hand,
                                               INDEX index ] ] ],
            CONT [ HOOK.LTOP #hand,
                   RELS <! relation, relation !>,
                   HCONS <! !> ] ] ].

basic_common_noun_npcomp_synsem := basic_noun_npcomp_synsem & basic_two_arg &
                                   count_noun_synsem &
  [ LOCAL.CAT.VAL [ COMPS < #comp & [ PUNCT.LPUNCT no_punct ] >,
                    KCMP #comp ] ].

common_noun_npcomp_synsem := basic_common_noun_npcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
    LKEYS.KEYREL reg_diadic_nom_relation ].

; 'kinda' as in "what kinda chair is that"
common_noun_nbarcomp_synsem := basic_noun_nomcomp_synsem & basic_two_arg &
                               count_noun_synsem &
  [ LOCAL [ CAT.VAL [ SPR < [ NONLOC.SLASH 0-dlist ] >,
                      COMPS < #comp & abstr_lex_synsem &
                              [ LOCAL [ CAT nbar_cat_min & [ HEAD noun ],
                                        CONT.HOOK [ LTOP #nhand,
                                                    INDEX #arg ] ],
                                NONLOC.SLASH 0-dlist,
                                OPT - ] >,
                      KCMP #comp ],
            CONT [ RELS <! relation, relation,
                         [ PRED udef_q_rel,
                           ARG0 #arg,
                           RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ],
    LKEYS.KEYREL reg_diadic_nom_relation ].

; DPF 08-apr-08 - Added NORM norm_rel to prevent these from heading appositive
common_noun_numcomp_synsem := common_noun_nocomp_synsem &
  [ LOCAL.CAT.HEAD [ MINORS [ MIN mnp_symb_rel,
			      NORM norm_rel ],
                     PRD + ] ].

; ERB (14-12-97) It might be cleaner in some sense for pro_ss to have that
; pron_rel as its MIN and then have this construction and others like it
; take the value of that MIN and put it on their RELS.  Also, if we
; ever move to lexical amalgamation of relations, the pron_rel should get
; incorporated automatically. ... So I'm going to try to do it that way.

; ERB (14-12-97) We just decided that there shouldn't be a pron_rel here.
; The feature PRONTYPE is enough to distinguish the instance introduced
; by the pro_ss as one that doesn't have to be bound.

; ERB (21-01-98) The pro_ss should be unslashed.

basic_mass_noun_synsem := basic_common_noun_synsem & nonpro_nomod_synsem &
                          mass_or_count_synsem &
  [ LOCAL [ CONT.HOOK.INDEX [ PNG png & [ PN 3s ],
                              DIV +,
                              IND - ] ] ].

basic_scoping_noun_synsem := noun_nonpro_nomod_synsem &
  [ LOCAL [ CAT.VAL.KCMP [ LOCAL.CONT [ HOOK.LTOP #ltop ],
                           PUNCT.LPUNCT no_punct ],
	    CONT.HCONS.LIST < qeq & [ HARG #arg1, LARG #ltop ], ... > ],
    LKEYS.KEYREL hcomp_nom_relation & [ ARG1 handle & #arg1 ] ].

scoping_noun_synsem := basic_scoping_noun_synsem & noun_two_arg_nomod_synsem.

;; a way to meet

#|
basic_noun_vpcomp_synsem := basic_scoping_noun_synsem & 
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < #comp & phr_synsem &
			      [ LOCAL [ CAT vp_inf_cat &
					 [ VAL.SUBJ 
					    < pro_ss &
					      [ NONLOC.SLASH 0-dlist ] > ],
                                        CONT.HOOK [ XARG #inst,
                                                    INDEX.SF basic-prop ],
                                        CONJ cnil ],
				OPT - ] > ],
	    CONT [ RELS <! relation, 
                          [ PRED pronoun_q_rel,
                            RSTR #rhand,
                            ARG0 #inst ],
                          [ LBL #prohand,
                            PRED pron_rel,
			    ARG0 #inst & [ PRONTYPE zero_pron,
                                           SORT entity ] ] !>,
                   HCONS <! qeq, qeq & [ HARG #rhand,
					 LARG #prohand ] !> ] ] ].
|#
basic_noun_vpcomp_synsem := basic_scoping_noun_synsem & 
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < #comp &
			      [ LOCAL [ CAT vp_inf_cat &
					 [ VAL.SUBJ 
					    < pro_ss &
					      [ NONLOC.SLASH 0-dlist ] > ],
                                        CONT.HOOK.INDEX.SF basic-prop,
                                        CONJ cnil ],
				OPT - ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! qeq !> ] ] ].

basic_common_noun_vpcomp_synsem := basic_noun_vpcomp_synsem &
                                   common_noun_synsem.
common_noun_vpcomp_synsem := basic_common_noun_vpcomp_synsem & 
                             scoping_noun_synsem.
mass_noun_vpcomp_synsem := basic_noun_vpcomp_synsem & scoping_noun_synsem &
                           basic_mass_noun_synsem.
mass_count_noun_vpcomp_synsem := basic_noun_vpcomp_synsem & scoping_noun_synsem
                                 & basic_mass_or_count_synsem.

; pleasure: "it is a pleasure to visit Abrams"

; It is a pleasure to visit abrams.
common_noun_vpcomp_expl_synsem := common_noun_vpcomp_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN prednom_rel,
                  VAL [ SPR < [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
                        COMPS < [ NONLOC.SLASH 0-dlist,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG it-ind ],
    MODIFD notmod,
    LKEYS.--+ARGIND it-ind ].

; It is sheer drudgery to visit abrams.
mass_noun_vpcomp_expl_synsem := basic_noun_vpcomp_synsem &
                                basic_mass_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN prednom_rel,
                  VAL [ SPR < [ --MIN implicit_q_rel ] >,
                        COMPS < [ NONLOC.SLASH 0-dlist,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG it-ind ],
    MODIFD notmod,
    LKEYS.--+ARGIND it-ind ].

; Abrams is a pleasure to visit.
common_noun_vpcomp_slash_synsem := basic_common_noun_vpcomp_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN prednom_rel,
                  VAL [ SPR < [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
                        COMPS < [ NONLOC.SLASH 1-dlist & 
                                         <! [ CAT nomp_cat_min,
                                              CONT.HOOK.INDEX #xarg &
                                                  index ] !>,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG #xarg ],
    NONLOC.SLASH 0-dlist,
    MODIFD notmod ].

basic_common_noun_cpcomp_synsem := scoping_noun_synsem &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < #comp & synsem &
			    [ LOCAL.CONJ cnil,
                              NONLOC.SLASH 0-dlist,
			      OPT - ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! qeq !> ] ] ].

basic_count_noun_cpcomp_synsem := basic_common_noun_cpcomp_synsem & 
                                  count_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LEX - ] > ].

common_noun_cpcomp_synsem := basic_count_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp ] >,
    LKEYS.KEYREL hcomp_nom_relation ].

common_noun_cpcomp_fin_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ].

common_noun_cpcomp_inf_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_inf_v_c ] > ].

common_noun_cpcomp_bse_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_bse ] > ].

mass_count_noun_cpcomp_fin_synsem := basic_common_noun_cpcomp_synsem &
                                     basic_mass_or_count_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c & [ HEAD comp ] ] >,
            CONT.RELS <! relation !> ],
    LKEYS.KEYREL hcomp_nom_relation ].

mass_noun_onearg_synsem := basic_mass_noun_synsem & one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

mass_noun_synsem := mass_noun_onearg_synsem &
  [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
            CONT.RELS <! reg_nom_relation !> ] ].

basic_mass_noun_ppcomp_synsem := basic_mass_noun_synsem & basic_two_arg &
                                 noun_nondeverb_ppcomp_synsem &
  [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ].

mass_noun_ppcomp_synsem := basic_mass_noun_ppcomp_synsem & two_arg &
  [ LOCAL.CONT.RELS <! reg_diadic_nom_relation !> ].

mass_noun_ppcomp_nospr_synsem := basic_mass_noun_ppcomp_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nhand,
                                                INDEX #nind ] ] >,
            CONT [ RELS <! relation, [ PRED udef_q_rel,
                                       ARG0 #nind,
                                       RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ] ].

basic_mass_or_count_ppcomp_synsem := basic_mass_or_count_synsem & two_arg &
                                     noun_nondeverb_ppcomp_synsem & 
  [ LOCAL [ CAT.HEAD.MINORS.MIN diadic_nom_rel,
            CONT.RELS <! relation !> ],
    LKEYS.KEYREL diadic_nom_relation ].

mass_or_count_ppcomp_synsem := basic_mass_or_count_ppcomp_synsem &
  [ LKEYS.KEYREL reg_diadic_nom_relation ].

mass_noun_npcomp_synsem := basic_mass_noun_synsem & basic_noun_npcomp_synsem &
                           basic_two_arg &
  [ LOCAL.CAT.VAL [ COMPS < #comp & [ OPT -,
                                      PUNCT.LPUNCT no_punct ] >,
                    KCMP #comp ],
    LKEYS.KEYREL reg_diadic_nom_relation ].

; PRD feature used as a hack to avoid partitives in noun-noun compounds,
; pending a better analysis.
; DPF 9-Sept-99 - Changed N-N block to be based on non-empty ALTMIN, rather 
; than PRD. The handle of the of-NP should probably be an argument of the 
; part_of relation, as the value of a feature SET.  But for now we simply 
; identify the handles of the part_of and the of_NP.
; DPF 17-Apr-03 - Changed set-up so the MIN of partitives will be the MIN of
; the of-PP's NP if there is a complement and an underspecified nom_rel as
; the default.
; DPF 2-May-03 - Changed SPR..MIN from degree_rel to just_only_very_deg_rel
; to block a lot of overgeneration, but still leaving a little (e.g. 
; "very all chairs arrived").  We'll fix this once we move to relation names
; as values of PRED feature in relation.
; DPF 27-Jul-03 - Removed SPR..MIN, since it needs to preserve the constraints
; from the non-partitive determiner (the input to the lexical rule for which
; this type is the output), as in "too much of the rice was spilled".
; DPF 31-Oct-03 - But need some SPR..MIN constraint since not all partitives
; are constructed via that lexical rule, and they need some kind of 
; restriction.  So added this constraint to n_part_lexent below.
; DPF 13-Nov-03 - Removed SPR..COMPS *olist* since want these to be able to
; take comparative degree specifiers (which have a non-empty COMPS list), 
; like in "kim hired as many as sandy"
; DPF 22-feb-04 - Identified INDEX and AGR, as with noun_synsem -- was there
; a reason this wasn't done earlier?  It's needed to get the right agreement
; for e.g. "we climbed peaks all of which are tall".
; DPF 09-may-04 - Changed SPEC < > to SPEC < anti_synsem_min > so partitives can
; appear as complements of empty-preps, as in "kim relied on all the chairs"

partitive_noun_synsem := nonpronominal_synsem & xref_synsem &
  [ LOCAL [ CAT [ HEAD partn &
                       [ MOD < >,
                         MINORS [ MIN basic_nom_rel,
                                ALTMIN quant_or_wh_rel & #altmin ] ],
                  VAL [ SUBJ < >,
                        SPR < synsem &
                              [ LOCAL 
				[ CAT [ HEAD.MINORS.MIN just_only_deg_rel,
					VAL.SPR  *olist* ],
				  CONT.HOOK.LTOP #althand ],
				NONLOC [ QUE 0-dlist,
					 REL 0-dlist ],
				OPT + ],
			      anti_synsem_min & [ OPT - ] >,
			SPEC < anti_synsem_min >,
                        KCMP [ --MIN #cmin & _of_p_sel_rel,
                               LOCAL.CAT [ HEAD prep & 
                                                [ PRD -,
                                                  TAM.TENSE nontense ],
                                           VAL.COMPS < > ],
                               NONLOC.SLASH 0-dlist,
                               OPT - ] ] ],
            CONT [ HOOK [ LTOP #nhand,
                          INDEX #index & ref-ind ],
		   HCONS.LIST < qeq & [ HARG #phand,
                                        LARG #nhand ], ... > ],
	    AGR #index ],
    LKEYS [ KEYREL nom_relation &
                   [ LBL #nhand,
                     ARG0 #index ],
            ALTKEYREL quant_or_wh_relation &
                        [ PRED #altmin,
                          LBL #althand,
                          ARG0 #index,
                          RSTR #phand ],
            --COMPKEY #cmin ] ].

; DPF 17-Apr-03 - Identify MIN relation with the of-PP's complement's ALTMIN,
; (the MIN of that PP's NP complement) to maintain visibility of that NP's
; relation, for example to block "*Kim arrives one of these chairs" but allow
; "Kim arrives one of these days".
; DPF 17-dec-03 - Changed KEYREL from reg_diadic_nom_relation to just
; diadic_nom_relation to avoid [SORT entity] constraint, so we can get e.g.
; "hiring sandy is (only) some of the challenge".

basic_partitive_noun_ppof_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                  VAL.KCMP [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #min,
                                     CONT.HOOK [ LTOP #lbl,
						 INDEX #arg ] ],
                             NONLOC.REL #rel,
                             PUNCT.LPUNCT no_punct ] ] ],
    NONLOC.REL #rel,
    LKEYS.KEYREL diadic_nom_relation &
          [ PRED part_of_rel,
	    LBL #lbl,
            ARG1 #arg & non_expl-ind ] ].

partitive_noun_ppof_synsem := basic_partitive_noun_ppof_synsem &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
                      COMPS < #comp > ],
            CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS.KEYREL #keyrel ].

partitive_noun_ppof_agr_synsem := partitive_noun_ppof_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.AGR [ PNG.PN #pn,
                                          DIV #div ],
            AGR [ PNG.PN #pn,
                  DIV #div ] ] ].

partitive_noun_ppof_noagr_synsem :< partitive_noun_ppof_synsem.

; all the books, half your salary
; DPF 11-Sept-01 - Added COMPS..ALTMIN norm_non_conj_rel to block e.g.
; 'both Abrams or Browne arrived'
; DPF 1-Oct-01 - Replaced the above with ALTMIN explicit_q_rel to avoid
; spurious parse for "All books".  Maybe no longer need norm_non_conj_rel.
; DPF 25-apr-04 - Deleted the spurious of_p_sel_rel from RELS.

basic_partitive_noun_NP_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                  VAL.COMPS < synsem & 
                            [ LOCAL [ CAT nomp_cat_acc_min &
                                      [ HEAD.MINORS [ MIN #min,
                                                      ALTMIN explicit_q_rel ]],
                                      CONT.HOOK [ LTOP #lbl,
						  INDEX index ],
                                      CONJ cnil ],
                              NONLOC non-local_none,
                              --SIND #arg,
                              OPT -,
                              PUNCT.LPUNCT no_punct ] > ],
            CONT.RELS.LIST < reg_diadic_nom_relation & #keyrel &
                         [ PRED part_of_rel,
			   LBL #lbl,
                           ARG1 #arg & non_expl-ind ],
                         relation, ... > ],
    NONLOC.REL 0-dlist,
    LKEYS.KEYREL #keyrel ].

partitive_noun_NP_synsem := basic_partitive_noun_NP_synsem &
  [ LOCAL.CONT.RELS <! relation, relation !> ].

partitive_noun_NP_agr_synsem := partitive_noun_NP_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR [ PNG.PN #pn,
                                          DIV #div ] ] >,
            AGR [ PNG.PN #pn,
                  DIV #div ] ],
    LKEYS.ALTKEYREL.PRED explicit_quant_agr_q_rel ].

; both
partitive_noun_NP_noagr_synsem := partitive_noun_NP_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3p ] > ].

; not all
partitive_noun_NP_neg_synsem := basic_partitive_noun_NP_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR [ PNG.PN #pn,
                                          DIV #div ] ] >,
            AGR [ PNG.PN #pn,
                  DIV #div ],
	    CONT.RELS <! relation, 
		       [ LBL #lbl ],
		       [ PRED "not_x_deg_rel",
			 LBL #lbl,
			 ARG0 event,
			 ARG1 semarg ] !> ] ].

; DPF 03-Dec-03 - Added LPERIPH na to prevent these from appearing as heads
; of appositive phrases: "both abrams"
; DPF 06-dec-03 - Moved COMPS < > to le-type using this synsem, so the lexrule
; for partitives with no of-PP can still propagate any other comps of that
; det, in particular for free-rels like "whichever".
; DPF 11-dec-03 - Made MIN part_of_rel so these fit with constraint on "than"
; as in "Kim has more (of the chairs) to offer than Kim"
; DPF 26-aug-07 - Added NORM norm_rel to prevent these from appearing in
; appositives, blocking spurious ambiguity for e.g. "all the cats"
;
partitive_noun_nocomp_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT.HEAD.MINORS [ MIN part_of_rel,
                              NORM norm_rel ],
            CONT.HOOK.INDEX.PNG.PN 3 ],
    MODIFD.LPERIPH na,
    NONLOC.REL 0-dlist,
    LKEYS.KEYREL.PRED generic_entity_rel ].

basic_noun_word := word &
  [ SYNSEM.PUNCT no_punctuation_min ] .

basic_noun_noaffix_word := nonc-hm-nab & basic_noun_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

basic_pronoun_word :< basic_noun_word.

noun_noninfl_word := nonc-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

noun_word := nonc-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

basic_intr_noun_word := noun_noninfl_word &
  [ SYNSEM common_noun_nocomp_synsem &
	   [ LOCAL.CONT [ RELS <! relation !>,
                          HCONS <! !> ] ] ].

basic_intr_lex_entry := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	  [ LOCAL.CAT.VAL.SPR < [ --MIN quant_or_wh_rel ] >,
            MODIFD notmod ] ].

n_intr_lex_entry := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_c_le := n_intr_lex_entry.

n_-_c-ed_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN n-ed_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_c-ed-nocnh_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN n-ed_rel,
				     NORM norm_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

; 'handheld'
; DPF 06-sept-07 - Let's try adding the hack --BARE - here to prevent these
; from undergoing the robust bare-singular rule.  May be too sweeping, but
; avoids a lot of unwanted ambiguity, e.g. for 'remove'
;
n_-_c-nocnh_le := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD [ MINORS [ MIN norm_nom_rel,
                                         NORM norm_rel ],
                                --BARE - ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

; e.g. 'next' as in "the next will be ready soon" but "*the chair next"
n_-_c-nochd_le := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod & [ LPERIPH + ],
             LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                       NORM norm_rel ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

; Block some frequently occurring nouns from appearing in title constructions
; ("no title compound")
n_-_c-ntc_le := n_intr_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM no_rel ].

; phone (like number, order)
; No constraint on ARG0.SORT, so can appear in identity copula constructions
; or conjunctions with verbal projections; e.g. "the idea is to win."
;
n_-_c-ns_le := basic_intr_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ].

; For determinerless-PPs: 'within range'
; DPF 25-apr-04 - Added ALTMIN quant_or_wh_rel to prevent these from
; appearing as left members of N-N compounds.
; DPF 17-may-05 - But now using NORM to block compounding


basic_n_bare_lex_entry := noun_noninfl_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN bare_nom_rel,
					 NORM norm_rel ],
                           VAL.SPR < unexpressed > ],
                     AGR.PNG.PN 3s ] ],
    IDIOM + ].

intr_n_bare_lex_entry := basic_n_bare_lex_entry & basic_intr_lex_entry &
  [ SYNSEM.LKEYS.KEYREL reg_nom_relation ].

n_bare_ppcomp_lex_entry := basic_n_bare_lex_entry & noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ --MIN quant_or_wh_rel ] >,
		     CONT [ RELS <! relation !>,
			    HCONS <! !> ] ],
	     MODIFD notmod ] ].

n_bare_lex_entry := intr_n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE obliq ].

; 'in (family/open) court'
n_-_c-br_le := n_bare_lex_entry.

; 'at eye level' ('*at level')
n_-_c-brn_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_nmod_rel,
             MODIFD.LPERIPH na ] ].

; 'on (summer) vacation' ('*on long vacation')
n_-_c-brn*_le := n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN bare_n_nmod_rel ].

; 'at close range' ('*at range')
n_-_c-brj_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_jmod_rel,
             MODIFD.LPERIPH - ] ].

; 'in (sharp) contrast'
; 'at (long) last'
n_-_c-brj*_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_jmod_rel,
             MODIFD.LPERIPH bool ] ].

; 'at (considerable/company) expense' ('*at expense')
n_-_c-brnj_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_nom_rel,
             MODIFD.LPERIPH na_or_- ] ].

; 'on top', 'of course'
n_-_c-brno_le := n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN bare_n_nomod_rel ].

n_pp_c-brno-of_le := n_bare_ppcomp_lex_entry &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN bare_n_nomod_rel,
		       VAL.COMPS < [ --MIN _of_p_sel_rel ] > ] ].

; his own
n_-_c-poss_le := n_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ ALTMIN def_explicit_q_rel,
				       NORM norm_rel ],
                         VAL.SPR < [ LOCAL.CAT.HEAD.POSS + ] > ],
             LKEYS.ALTKEYREL relation ] ].

; Idiom nouns: e.g.
; ahold: 'I got ahold of sandy'
; part: 'I took part in the meeting'

n_-_c-br-idm_le := intr_n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN bare_n_nomod_rel,
                              CASE acc ] ] ].

basic_n_intr_temp_lexent := basic_intr_noun_word & 
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN temp_abstr_rel,
                           VAL.SPR < [ --MIN quant_or_wh_rel ] > ],
                     CONT.HOOK.INDEX.SORT time ] ] ].

n_intr_temp_lexent := basic_n_intr_temp_lexent &
  [ SYNSEM.MODIFD notmod ].

n_-_c-day_le := n_intr_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN unnamed_day_rel ].

;n_-_c-hour_le := n_intr_temp_lexent &
;  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN gen_hour_rel ].

n_-_c-ssn_le := n_intr_temp_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN season_rel,
             LKEYS.KEYREL.PRED season_rel ] ].

; 'grasp, dearth'
n_-_c-sg_le := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                       ALTMIN quant_or_wh_rel,
                                       NORM norm_rel ],
                     CONT.RELS <! reg_nom_relation !> ],
             LKEYS.KEYREL.ARG0.PNG.PN 3s ] ].

; 'the DFKI'

n_intr_named_lexent := nonc-hm &
  [ INFLECTD -,
    SYNSEM noun_nocomp_synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                     VAL.SPR < [ --MIN quant_or_wh_rel ] >],
               CONT [ HOOK.LTOP #ltop,
                      RELS <! relation !>,
                      HCONS <! !> ],
               CONJ cnil ],
       MODIFD notmod,
       LKEYS.KEYREL named_nom_relation &
             [ LBL #ltop,
               PRED named_n_rel ] ] ].

n_-_c-nm_le := n_intr_named_lexent &
  [ SYNSEM.PUNCT no_punctuation_min ].

; 'the Alps'
n_-_c-nm-pl_le := n_intr_named_lexent &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.PNG.PN 3p,
             PUNCT no_punctuation_min ] ].

; For period-final names like "u.s."
n_-_c-nm-pd_le := n_intr_named_lexent &
  [ SYNSEM.PUNCT [ LPUNCT no_punct,
                   RPUNCT clause_or_no_punct ] ].

n_-_c-gen_le := basic_intr_lex_entry & generic_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation &
			  [ PRED generic_nom_rel ] ] ].


; for identifierersatz's, which need CARG attribute
n_-_c-gnrc_le := basic_intr_lex_entry & generic_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL named_nom_relation ] ].

basic_noun_ppcomp_word := noun_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem ].

norm_noun_ppcomp_word := basic_noun_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ --MIN independent_rel,
                                       LOCAL.CONT.HOOK.XARG #index ] >,
                     CONT [ RELS <! relation !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL.ARG1 #index ] ].

; DPF 12-mar-05 - Added MODIFD notmod to prevent spurious rule for prenom
; adjectives
noun_empty_ppcomp_word := basic_noun_ppcomp_word &
  [ SYNSEM [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
                                     --SIND #index ] >,
             LKEYS.KEYREL.ARG1 #index & non_expl ] ].

norm_noun_empty_ppcomp_word := noun_empty_ppcomp_word &
  [ SYNSEM.LOCAL.CONT [ RELS <! relation !>,
                        HCONS <! !> ] ].

noun_ppcomp_word := norm_noun_ppcomp_word &
  [ SYNSEM [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN unspec_diadic_nom_rel ] ].

n_ppcomp_lexent := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

n_pp_c_le := n_ppcomp_lexent &
  [ SYNSEM.LOCAL.CONT [ RELS <! relation !>,
                        HCONS <! !> ] ].

n_pp_c-of-brn_le := n_ppcomp_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ OPT -,
                                       LOCAL.CONT.HOOK [ LTOP #nhand,
                                                         INDEX #nind ] ] >,
                     CONT [ RELS <! relation, [ PRED udef_q_rel,
                                                ARG0 #nind,
                                                RSTR #rhand ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #nhand ] !> ] ],
             MODIFD.LPERIPH -,
             LKEYS.--COMPKEY _of_p_nbar_rel ] ].

; 'thing about X'; 'rest of X': "I am here the rest of the day"
n_ppcomp_oblig_lexent := norm_noun_empty_ppcomp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

n_pp_c-obl_le := n_ppcomp_oblig_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

; 'rest': modable
;
n_pp_c-ns-obl_le := n_ppcomp_oblig_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN modable_nom_rel ].

n_pp_c-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; No title compounds
n_pp_c-ntc-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM no_rel ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

n_pp_c-ns-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_pp_c-nt-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN reg_diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; DPF 10-sept-07 - Type for e.g. 'thing' which we don't want as left member
; of compounds.
n_pp_c-nsnc-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                     NORM norm_rel ],
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_pp_c-of-obl_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         VAL.COMPS < [ OPT - ] > ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; Since partitive rule already applies to measure NPs to produce
; "ten feet of rope", remove the pp-of complement here to avoid spurious
; ambiguity.
; DPF 13-nov-05 - Make NORM quantity_rel so it won't undergo n-n-cmpnd
; rule, but also won't undergo relcl to avoid silly "' huts were"
;
n_-_c-meas_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN meas_nom_rel,
                                     NORM quantity_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

; For unusual measure nouns incl. 'some' of 'fifty some feet' and 'plus' of
; 'fifty plus floors'.
;
n_-_c-meas-nocnh_le := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
       [ LOCAL [ CAT.HEAD.MINORS [ MIN meas_nom_rel,
                                   NORM quantity_rel ],
                 CONT.HOOK.INDEX.DIV + ],
         MODIFD rmod,
         LKEYS.KEYREL reg_nom_relation ] ].

n_pp_c-pl-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN _place_n_1_rel,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

; alternative
n_pp_c-ns_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL diadic_nom_relation ] ].


; 'way': modable and nosort
;
n_pp_c-mod-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN modable_nom_rel,
             LKEYS [ KEYREL diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; For abbrev "no." and similarly for "north, south, east, west"

n_pp_c-nocnh-of_le := norm_noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM norm_rel ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

noun_double_ppcomp_word := noun_word &
  [ SYNSEM noun_ppcomp_three_arg_synsem &
         [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         VAL.COMPS < [ --MIN selected_rel,
                                       --SIND #index1 ],
                                     [ --MIN selected_rel,
                                       --SIND #index2 ] > ],
                   CONT.RELS <! relation !> ],
           LKEYS.KEYREL reg_triadic_nom_relation &
                        [ ARG1 #index1,
                          ARG2 #index2 ] ] ].

n_pp-pp_c_le := noun_double_ppcomp_word.

basic_n_temp_ppcomp_lexent := noun_word &
  [ SYNSEM temp_noun_ppcomp_two_arg_synsem ].

norm_n_temp_ppcomp_lexent := basic_n_temp_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --MIN _of_p_sel_rel ] >,
                   CONT [ RELS <! relation !>,
                          HCONS <! !> ] ] ].

; DPF 22-May-02 - Note that we have to have two entries for the word "time",
; one which must take a determiner, and which can appear in a temp-mod phrase;
; and the other which denotes a temporal chunk and can't appear as temp-mod:
; "He'll stay this time" but "*He stayed time for a meeting" (Cf. "Do you 
; have time for a meeting.")

; DPF 05-dec-03 - Added NORM as hack to prevent these from appearing as 
; left members of n-n-cmpnds like 'afternoon Monday' though maybe actually OK.
; DPF 06-dec-03 - Removed of-PP complement since possessive of-PP now does the
; work, and we avoid spurious ambiguity.
; DPF 22-sept-04 - Changed SPR from expressed_synsem to synsem so these will
; undergo the bare_np rule, which requires the SPR to be 'unexpressed'.

n_temp_lexent := n_intr_temp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < synsem > ].

n_pp_c-day_le := norm_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN unnamed_day_rel,
             MODIFD notmod ] ].

n_pp_c-t-of-nb_le := basic_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL 
              [ CAT.VAL.COMPS < [ OPT -,
                                  --MIN _of_p_nbar_rel,
                                  LOCAL.CONT.HOOK [ LTOP #nhand,
                                                    INDEX #nind ] ]>,
                CONT [ RELS <! relation, [ PRED udef_q_rel,
                                           ARG0 #nind,
                                           RSTR #rhand ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #nhand ] !> ] ],
             MODIFD notmod & [ LPERIPH - ] ] ].

n_-_c-min_le := n_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN _minute_n_1_rel ].

n_-_c-nday_le := n_temp_lexent & 
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN non_day_diadic_modable_rel ].

n_-_c-nday-pl_le := n_temp_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN non_day_diadic_modable_rel,
                   CONT.HOOK.INDEX.PNG.PN 3p ] ].

n_-_c-year_le := n_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN non_day_diadic_modable_rel ].

n_-_c-year-pl_le := n_temp_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN non_day_diadic_modable_rel,
                   CONT.HOOK.INDEX.PNG.PN 3p ] ].

n_-_c-dow_le := basic_n_intr_temp_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN dofw_rel,
                                       ALTMIN quant_or_wh_rel ],
                         VAL.SPR < synsem > ],
             MODIFD notmod_or_rmod,
             LKEYS [ KEYREL.PRED dofw_rel,
                     ALTKEYREL.PRED quant_or_wh_rel ] ] ].

; DPF 13-May-02 - Added LPERIPH + to prevent these from appearing as heads of
; noun-noun compounds.
; DPF 22-May-02 - But this also blocks "rainy April" - try again.
; DPF 22-May-02 - Changed ALTMIN from basic_nom_rel to quant_or_wh_rel to be 
; consistent with constraints on relative clause modifiees.

n_-_c-month_le := n_temp_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN mofy_rel,
                                     ALTMIN proper_q_rel ],
             LKEYS [ KEYREL.PRED mofy_rel,
                     ALTKEYREL.PRED quant_or_wh_rel ],
             MODIFD notmod ] ].

; "way" as in "find a way to do that" -- was used in VM, but analysis changed
; so this type not currently in use.  Its semrel.tdl entry was as follows:
;   _way_rel := hcomp_nom_rel &
;     [ ARG0.SORT entity ].

n_vp_c_le := noun_word &
  [ SYNSEM common_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; 'permission'
n_vp_m_le := noun_word &
  [ SYNSEM mass_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; 'clearance(s)'
n_vp_mc_le := noun_word &
  [ SYNSEM mass_count_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

n_cp_c-fin_le := noun_word &
  [ SYNSEM common_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; 'reason' - The reason Kim left bothered sandy"
n_cpcomp_optthat_lexent := noun_word &
  [ SYNSEM basic_count_noun_cpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ] ].

n_cp_c-optc_le := n_cpcomp_optthat_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ].

; 'way': modable
n_cp_c-mod_le := n_cpcomp_optthat_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN modable_nom_rel ].

; 'request'
n_cp_c-bse_le := noun_word &
  [ SYNSEM common_noun_cpcomp_bse_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; procedure
n_cp_c-inf_le := noun_word &
  [ SYNSEM common_noun_cpcomp_inf_synsem &
	   [ MODIFD notmod ] ].

; notification
n_cp_mc-fin_le := noun_word &
  [ SYNSEM mass_count_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; build head_complement structure which is still words (with 
; [ SYNSEM lex_synsem ].

noun_hclex_word := noncqrs-m & basic_noun_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

n_np_c_le := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM common_noun_npcomp_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         HC-LEX + ],
	     MODIFD notmod ] ].

n_nb_c_le := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM common_noun_nbarcomp_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         HC-LEX + ],
	     MODIFD notmod ] ].

; 'the word "chair"', 'the term "whippletree"'

n_nb_c-qt_le := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM common_noun_nbarcomp_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         VAL.KCMP [ PUNCT [ LPUNCT pair_or_no_punct,
                                            RPUNCT pair_or_no_punct ],
                                    OPT - ],
                         HC-LEX + ],
	     MODIFD notmod,
             LKEYS.ALTKEYREL.PRED term_rel ] ].

; Use special inflectional rule to produce plural inflected form without 's'
n_numcomp_lexent := nonc-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM common_noun_numcomp_synsem &
	   [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! relation !>,
                          HCONS <! !> ],
             LKEYS.KEYREL.LBL #ltop,
             MODIFD notmod ] ].

n_-_c-cur_le := n_numcomp_lexent.
n_-_c-cur-gen_le := n_numcomp_lexent &
  [ SYNSEM.LKEYS.KEYREL named_nom_relation &
                        [ PRED gen_currency_rel ] ].

n_-_m_le := noun_noninfl_word &
  [ SYNSEM mass_noun_synsem &
	   [ MODIFD notmod ] ].

n_-_m-ed_le := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS.MIN n-ed_rel,
                     CONT.RELS <! reg_nom_relation !> ] ] ].

; The inevitable
n_-_m-def_le := noun_noninfl_word &
  [ SYNSEM mass_noun_synsem &
	   [ MODIFD notmod,
	     LOCAL.CAT.VAL.SPR < expressed_synsem &
				 [ --MIN def_q_rel ] > ] ].

; Removed LPERIPH na because it prevents these from heading NP-N cmpnds.
n_-_mc_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_mc-ns_lexent := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL nom_relation ] ].

; Removed LPERIPH na because it prevents these from heading NP-N cmpnds.
n_-_mc-ns_le := n_-_mc-ns_lexent.

; For "_guess_" unknown-noun entry
n_-_mc-ns-g_le := n_-_mc-ns_lexent.

n_-_mc-nocnh_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                     NORM norm_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

; 'time': modable
; LPERIPH is na_or_- so it can be head of N-N-cmpnd rule as in "work times"

n_-_c-time_le := noun_noninfl_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD notmod & [ LPERIPH na_or_- ],
             LOCAL [ CAT.HEAD.MINORS.MIN non_day_time_rel,
                     CONT [ HOOK.INDEX.SORT time,
                            RELS <! relation !>,
                            HCONS <! !> ] ] ] ].

n_-_mc-ed_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN n-ed_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_pp_m_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ MODIFD notmod ] ].

n_pp_m-obl_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

; 'home of X' - avoid spurious ambiguity with 'the home of X'
n_pp_m-brn_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_nospr_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL [ SPR < unexpressed >,
                             COMPS < [ OPT - ] > ] ] ].

n_pp_mc_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
	   [ MODIFD notmod ] ].

n_pp_mc-obl_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

n_pp_mc-of_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_pp_mc-nocnh-of_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM norm_rel ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; For "order" as in "my order, number 12345" where appositive rule requires
; compatibility of sorts.

n_pp_mc-of-ns_le := noun_noninfl_word &
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
           [ LOCAL.CAT.HEAD.MINORS.MIN reg_diadic_nom_rel,
             MODIFD notmod,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_pp_mc-for_le := noun_noninfl_word &
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
	     LKEYS.--COMPKEY _for_p_sel_rel ] ].

n_pp_mc-to_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
	     LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS.--COMPKEY _to_p_sel_rel ] ].

n_pp_mc-in_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
	     LKEYS.--COMPKEY _in_p_sel_rel ] ].

; Don't appear as left or right members of compounds: e.g. 'last'
n_mass_no_cmpnd_lexent := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                       NORM norm_rel ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

n_-_m-nocnh_le := n_mass_no_cmpnd_lexent.

; 'they hunted bear.'  Prevent from compounds, from and subject position,
; but can't easily prevent ambiguity for "bear hunting was popular"), 
; with 'bear' as subject of verbal gerund.  Also prevent specifier,
; to avoid spurious ambiguity for "the bear has four legs." - here, rather
; want underspecification, probably.

n_-_m-kind_le := n_mass_no_cmpnd_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE non_nom,
                       VAL.SPR < unexpressed_reg > ] ].

; 'red', 'blue' - don't appear as left members of compounds, but can
; appear as either mass or count.
; DPF 15-jan-08 - Added hack PRD + to these, and removed [NORM norm_rel],
; since we want "orange-encrusted" but still want to block n-n compound
; for "orange cat".  Maybe FIX?

n_-_mc-ntoj_lexent := noun_noninfl_word &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD noun_adjable &
                              [ MINORS.MIN norm_nom_rel,
				PRD + ],
		     AGR #agr,
                     CONT [ HOOK.INDEX #agr,
                            RELS <! relation !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_mc-col_le := n_-_mc-ntoj_lexent &
  [ SYNSEM basic_mass_or_count_nocomp_synsem ].

n_-_c-dir_le := n_-_mc-ntoj_lexent &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
           [ MODIFD.LPERIPH + ] ].

basic_n_plur_lexent := noun_noninfl_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL.CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                          HCONS <! !> ] ] ].

n_plur_lexent := basic_n_plur_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                               DIV + ] ] >,
                   CONT.RELS <! relation !> ] ].

n_-_c-pl_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; Bi-partite nouns like "scissors" or "sunglasses".  The basic entry is
; unmarked for INDEX.IND, but constrained to be GENRE informal, so we will
; parse "many sunglasses were cracked".  But there is a lexical rule which
; stamps [GENRE prescrip] and [IND -] on these entries, so the generator
; can be constrained to only generate "many pairs of sunglasses" (using
; a semantically empty classifier noun "pair").

n_-_bipart_le := noun_noninfl_word &
  [ SYNSEM basic_mass_or_count_nocomp_synsem &
           [ LOCAL [ CAT.HEAD noun &
                              [ MINORS.MIN norm_nom_rel,
                                PRD - ],
                     CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                            HCONS <! !> ] ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ],
    GENRE informal ].

; 'systems analyst' - 'systems' is uninflected, and the constraint on the
; SPR is a hack to prevent it from undergoing plural inflectional rule.
; Maybe a better constraint would be to make SPR < anti-synsem >, but
; this would require adjusting the hierarchy of noun synsems - FIX.

n_-_c-pl-cpd_le := basic_n_plur_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                           VAL.SPR < [ LOCAL.AGR.PNG.PN 3s ] > ],
                     CONT.RELS <! relation !> ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; e.g. 'goods': "*the good boat" with nominal 'good'
n_-_c-pl-nocnh_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                     NORM norm_rel ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; DPF 28-jun-07 - Constrained SPR to be expressed_synsem, to avoid e.g.
; spurious analysis for "many arrived".  Note that this fails to block
; nbar coordination without a determiner as in "proud and domestic animals"
; since the coord rule cannot propagate the whole unified synsems from the
; two dtrs (because of unwanted resulting circularity in feature structure).
; FIX.
; 'the few', 'the proud'
n_-_c-pl-def_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN norm_nom_rel,
                                       NORM norm_rel ],
                         VAL.SPR < expressed_synsem &
                                   [ --MIN def_q_rel ] > ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_c-pl-idm_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ],
    IDIOM + ].

; "euro's" which the preprocessor turns into "euro 's"
n_plur_mwe_lexent := nonc-hm & basic_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                               DIV + ] ] >,
                     CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                            RELS <! relation !>,
                            HCONS <! !> ] ] ] ].

n_-_c-pl-mwe_le := n_plur_mwe_lexent & nonc-hm-nab &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_c-pl-one_le := basic_n_plur_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN _one_n_1_rel,
                           VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                                   DIV + ] ] > ],
                     CONT.RELS <! [ LBL #lbl,
                                    PRED generic_entity_rel,
                                    ARG0 #arg0 ],
                                [ LBL #lbl,
                                  PRED card_rel,
                                  ARG0 event & [ E [ TENSE no_tense,
                                                     ASPECT no_aspect ] ],
                                  ARG1 #arg0,
                                  CARG "2+" ] !> ],
             MODIFD notmod_or_rmod ] ].

; For plurals like "sixties" which can directly undergo the npadv_mod rule.
; DPF 8-nov-03 - Can't see why we want "sixties" under npadv_mod rule, so
; changed gen_numval_rel to not inherit from modable_rel.

n_-_c-pl-num_lexent := n_plur_mwe_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD [ MINORS.MIN gen_numval_rel,
                              PRD + ],
             LKEYS.KEYREL.PRED gen_numval_rel ] ].

n_-_c-pl-num_le := n_-_c-pl-num_lexent &
  [ INFLECTD - ].

; For ersatz's which are already inflected
n_-_c-pl-num-ifl_le := n_-_c-pl-num_lexent &
  [ INFLECTD + ].

n_plur_ppcomp_lexent := noun_noninfl_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                           VAL [ COMPS < [ --SIND #index ] >,
				 SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                                     DIV + ] ] > ] ],
                     CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                            RELS <! diadic_nom_relation !>,
                            HCONS <! !> ] ],
	     MODIFD notmod,
             LKEYS.KEYREL.ARG1 #index ] ].

n_pp_c-pl_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! reg_diadic_nom_relation !> ].

; 'millions of ...'
n_pp_c-pl-crd_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ OPT -,
				     LOCAL.CONT.HOOK.INDEX.SORT #sort ] >,
                   CONT.RELS <! [ PRED card_of_rel,
				  ARG0.SORT #sort ] !> ] ].
; 'others of you'
n_pp_c-pl-obl_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
		   CONT.RELS <! reg_diadic_nom_relation !> ] ].

; "kind"
n_pp_c-pl-sg_le := basic_noun_noaffix_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                           VAL.COMPS < [ --SIND #index ] > ],
                     AGR.DIV -,
                     CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                            RELS <! reg_diadic_nom_relation !>,
                            HCONS <! !> ] ],
	     MODIFD notmod,
             LKEYS.KEYREL.ARG1 #index ] ].

; 'bunch', 'lot', 'number'
; DPF 30-sept-06 - Replaced MIN norm_nom_rel with nonpro_rel, and
; unify with COMPS..MIN, to admit e.g. "We arose a number of times."  Also
; removed MODIFD notmod.
; DPF 05-oct-06 - But this blocks "group of us', so generalize to nom_rel.

n_group_ppof_lexent := noun_word &
  [ SYNSEM unsp_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD noun &
                                [ MINORS.MIN nom_rel & #min ],
                           VAL.COMPS < [ LOCAL.CAT.HEAD.MINORS.ALTMIN #min,
                                         --SIND #ind,
                                         OPT - ] > ],
                     CONT [ RELS <! reg_diadic_nom_relation !>,
                            HCONS <! !> ] ],
             LKEYS [ KEYREL.ARG1 #ind,
                     --COMPKEY _of_p_sel_rel ] ] ].

; DPF 28-jun-07 - Restrict to nominative case, to avoid spurious ambig with 
; ordinary n_pp_c_of.
; DPF 07-nov-07 - But this blocks e.g. "there are the majority of houses..."
; since the number mismatch with "are" forces the group noun, but "are" wants
; the complement to be [CASE acc].  FIX...
; DPF 19-jan-08 - Removed that CASE nom restriction, since it now blocks
; 'We hired a group of citizens.'

; 'the row of houses are ...'
n_pp_c-gr-of_le := n_group_ppof_lexent &
  [ SYNSEM.LOCAL.AGR.DIV - ].

; a lot of cats
n_pp_c-gr-of-a_le := n_group_ppof_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ --MIN _a_q_rel ] >,
                   CONT.HOOK.INDEX.PNG.PN 3p,
                   AGR [ PNG.PN 3p,
                         DIV - ] ] ].

; 'plenty of'
n_pp_m-gr-of_le := n_group_ppof_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < unexpressed_reg >,
                             COMPS < [ LOCAL.AGR.PNG.PN #pn ] > ],
                   AGR [ PNG.PN #pn,
                         DIV + ] ] ].

; 'piece of', 'pair of'
n_pp_c-gr-of-ns_le := n_group_ppof_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED quantum_n_of_rel ].

;;; DPF 13-feb-08 - Block "number" from undergoing n-adj rule: Add HEAD noun

n_group_nocomp_lexent := noun_word &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
	   [ LOCAL [ CAT.HEAD noun & [ MINORS.MIN norm_nom_rel ],
                     CONT [ RELS <! reg_nom_relation !>,
                            HCONS <! !> ] ] ] ].

n_-_c-gr_le := n_group_nocomp_lexent.

n_-_m-gr_le := n_group_nocomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < unexpressed_reg >,
                   AGR.DIV + ] ].

n_part_lexent := basic_noun_noaffix_word &
  [ SYNSEM partitive_noun_synsem &
	   [ LOCAL [ CAT.VAL.SPR.FIRST [ LOCAL.CAT.HEAD adv,
					 --MIN just_only_deg_rel ],
                     CONT [ RELS.LIST < #keyrel, #altkeyrel, ... >,
                            HCONS <! qeq !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ],
             NONLOC [ SLASH 0-dlist,
                         QUE 0-dlist ] ] ].

n_pp_mc-a-of_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_agr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !>,
             LKEYS.ALTKEYREL.PRED explicit_quant_agr_q_rel ] ].

n_pp_mc-na-of_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_noagr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !> ] ].

n_pp_mc-pl-na-of_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_noagr_synsem &
           [ LOCAL [ CONT.RELS <! relation, relation !>,
                     AGR.PNG.PN 3p ] ] ].

n_np_mc-a_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_agr_synsem ].

n_np_mc-na_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_noagr_synsem ].

n_-_mc-prt_le := n_part_lexent &
  [ SYNSEM partitive_noun_nocomp_synsem &
           [ LOCAL [ CAT.VAL.COMPS < >,
                     CONT.RELS <! #keyrel, relation !> ],
             MODIFD notmod,
             LKEYS.KEYREL #keyrel ] ].

n_np_mc-neg_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_neg_synsem ].

; pleasure
n_vp_c-it_le := noun_word &
  [ SYNSEM common_noun_vpcomp_expl_synsem ].

; drudgery
n_vp_m-it_le := noun_word &
  [ SYNSEM mass_noun_vpcomp_expl_synsem ].

; pleasure to VP/NP
n_vpslnp_c_le := noun_word &
  [ SYNSEM common_noun_vpcomp_slash_synsem ].

;;
;; Lexical NPs
;;
;;   (proper names, pronouns, names of weekdays, ...)

basic_np_synsem := ref_synsem &
  [ LOCAL.CAT [ HEAD basic_noun &
                     [ MINORS.ALTMIN def_q_rel ],
                VAL.SUBJ < > ] ].

basic_np_word := noncrs-hm-nab & basic_noun_word &
  [ SYNSEM basic_np_synsem ].

basic_non_affixed_np := noncqrs-hm-nab & basic_noun_word &
  [ SYNSEM.MODIFD notmod ].

non_affixed_np := basic_non_affixed_np &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

np_word := basic_np_word & basic_non_affixed_np &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < > ].

;np_synsem := noun_synsem & nomod_synsem.
np_synsem := nonpronominal_synsem & ref_synsem & nomod_synsem &
  [ LOCAL [ CAT.HEAD basic_noun,
	    AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

basic_np_sing_synsem := basic_np_synsem &
  [ LOCAL.CONT [ RELS.LIST < nom_relation &
                             [ PRED basic_nom_rel,
                               ARG0 #ind ],
                             [ PRED quant_rel,
                               ARG0 #ind,
                               RSTR #rhand ], ... >,
                 HCONS <! qeq & [ HARG #rhand,
                                  LARG #keyhand ] !> ],
    LKEYS.KEYREL.LBL #keyhand ].

basic_np_sing_word := basic_np_word &
  [ SYNSEM basic_np_sing_synsem ].

np_sing_synsem := basic_np_sing_synsem & np_synsem &
  [ LOCAL [ CAT.VAL [ SPR < >,
                      COMPS < > ],
            CONT.RELS <! relation, [ PRED proper_q_rel ] !> ],
    MODIFD notmod ].

#|
np_sing_word := basic_np_sing_word &
  [ SYNSEM np_sing_synsem &
           [ NONLOC.QUE 0-dlist ] ].
|#

; DPF 10-Apr-02 - Changed ALTMIN from basic_nom_rel to implicit_q_rel so
; proper names can form compounds like in "the Kim Browne story"

; DPF 15-May-02 - Changed proper names so they now inflect, allowing plural
; forms as in "they hired two Chiangs"
; DPF 5-Sep-03 - Changed ALTMIN from implicit_q_rel to proper_q_rel to
; block compound "the Browne hired Chiang".  Later changed.
; DPF 7-may-04 - Removed nonque supertype, since we want to allow e.g.
; "which Elvis did you see"
; DPF 24-aug-04 - Added RPERIPH + to enable blocking of red-rel analysis
; of "Abrams hired" while still allowing "people hired"
; PDF 19-apr-08 - Added INDEX nonconj_ref-ind to block spurious analysis
; of uninflected "sunny Pittsburgh" as proper_np_conj.
;
basic_n_proper_lexent := noncrs-hm & basic_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT [ HEAD.MINORS [ MIN named_np_rel,
                                       ALTMIN quant_or_wh_rel ],
                           VAL [ SPR < [ --MIN quant_or_wh_rel,
                                         NONLOC.QUE #que ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #index & nonconj_ref-ind ],
                            RELS <! relation !>,
                            HCONS <! !> ],
                     AGR #index ],
             NONLOC.QUE #que,
             LKEYS [ KEYREL named_nom_relation &
                            [ PRED named_np_rel,
                              LBL #ltop ],
                     ALTKEYREL.PRED implicit_q_rel ] ] ].
#|
basic_n_proper_lexent := noncrs-hm & basic_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT [ HEAD.MINORS [ MIN named_np_rel,
                                       ALTMIN quant_or_wh_rel ],
                           VAL [ SPR < [ --MIN quant_or_wh_rel,
                                         NONLOC.QUE #que ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #index ],
                            RELS <! relation !>,
                            HCONS <! !> ],
                     AGR #index ],
             NONLOC.QUE #que,
             LKEYS [ KEYREL named_nom_relation &
                            [ PRED named_np_rel,
                              LBL #ltop ],
                     ALTKEYREL.PRED implicit_q_rel ] ] ].
|#
norm_n_proper_lexent := basic_n_proper_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED named_rel,
    INFLECTD - ].

; Distinguish ordinary proper names like "Kim" from city proper names like
; "Paris", which allow a following comma as in "Paris, France".
n_proper_lexent := norm_n_proper_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN named_rel ].

; MIN allows specialization to named_rel ('Kim') or named_city_rel ('Paris')
; to enable correct treatment of commas: '*Kim, Abrams' but 'Paris, France'
n_-_pn-city_le := norm_n_proper_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN named_np_rel ].

; DPF 26-Mar-01 - Added MODIFD.LPERIPH + to prevent (restrictive) post-nom
; modifiers of bare proper names, as in "*Abrams by Browne arrived." though
; this will also block "Abrams from New York just called".  Not clear what
; the contrast is due to.
; DPF 1-Jun-02 - But this was too strong, so relaxed the reduced-rel rule
; but keep this constraint here, since it still serves to prevent proper names
; from appearing as heads of n-n compounds, blocking "interview Sandy"

n_-_pn_le := n_proper_lexent &
  [ SYNSEM.MODIFD.LPERIPH + ].
n_-_pn-fem_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.GEN fem ].
n_-_pn-msc_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.GEN masc ].
; For "i", which we don't want as plural "is"
n_-_pn-sg_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s ].
n_-_pn-pl_le := basic_n_proper_lexent &
  [ INFLECTD +,
    SYNSEM [ LKEYS.KEYREL.PRED named_rel,
	     LOCAL plur_noun & [ CAT.HEAD.MINORS.MIN named_rel ] ] ].
#|
n_-_pn-gen_le := basic_n_proper_lexent & generic_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN named_rel,
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL.PRED named_gen_rel ],
    INFLECTD - ].
|#

n_-_pn-gen_le := basic_unknown_word &
  [ SYNSEM mass_or_count_nocomp_synsem & 
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
			   VAL.SPR < [ --MIN quant_or_wh_rel ] > ],
                     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel & reg_nom_wcarg_relation &
                   [ PRED named_gen_rel ],
             MODIFD notmod ],
    INFLECTD - ].


n_-_pn-pl-gen_le := basic_n_proper_lexent & generic_lex_entry &
  [ SYNSEM [ LOCAL plur_noun & [ CAT.HEAD [ MINORS.MIN named_rel,
					    CASE nom ] ],
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL.PRED named_gen_rel ],
    INFLECTD + ].

n_-_pn-unk_le := basic_n_proper_lexent & basic_unknown_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN named_rel,
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL.PRED named_unk_rel,
	     PHON.ONSET unk_onset ] ].

n_-_pn-caps-unk_le := basic_n_proper_lexent & basic_unknown_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN named_rel,
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL.PRED named_unk_rel,
	     PHON.ONSET unk_onset ] ].

; Plural proper names, but only nominative case, where agreement matters
n_-_pn-pl-unk_le := basic_n_proper_lexent & unknown_word &
  [ SYNSEM [ LOCAL plur_noun & [ CAT.HEAD [ MINORS.MIN named_rel,
					    CASE nom ] ],
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL.PRED named_unk_rel ] ].

; Add NORM to block these in left position of noun-noun compounds
n_-_pn-abb_le := norm_n_proper_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN named_abb_rel,
                                     ALTMIN proper_q_rel ],
             LKEYS.KEYREL.ARG0.PNG.PN 3s ] ].

; Block left quote on name of letter "s" to avoid spurious ambig for "'s"
; while we still tokenize with an added space preceding "s".
n_-_pn-nq_le := n_proper_lexent &
  [ SYNSEM.MODIFD.LPERIPH +,
    ALTS.SQPNCT - ].

; "here, there" as in "get out of here/there" 
; Make SYNSEM pronominal_synsem to block N-N cmpnds like "the there meeting"
; Added PRD + so appositives with left member np_adv won't join in N-N-cmpnds.
; DPF 23-Oct-00 - Since pronominal_synsem no longer constrains left member of
; noun-noun compounds, use alternate hack of making ALTMIN not unify with
; the [ALTMIN no_rel] constraint in the n-n-cmpnd rule.

basic_np_adv_synsem := basic_np_sing_synsem & pronominal_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS [ MIN #min,
				ALTMIN def_explicit_q_rel,
				NORM never_unify_rel ],
		  NEGPOL - ],
            CONT.HOOK.LTOP #ltop ],
    LKEYS [ KEYREL [ LBL #ltop,
                     PRED #min ],
            ALTKEYREL relation,
            ALT2KEYREL relation ] ].

np_adv_synsem := basic_np_adv_synsem &
  [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.VAL [ SPR *olist*,
                                          COMPS < >,
                                          SPEC < synsem_min > ] ],
			anti_synsem_min & [ OPT - ] > ].

basic_np_adv_word := basic_np_sing_word &
  [ SYNSEM basic_np_adv_synsem &
	   [ LOCAL [ CONT [ HOOK.INDEX #ind & [ PNG png & [ PN 3s ] ],
                            RELS.LIST < relation, #altkeyrel, ... > ],
		     AGR #ind ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

basic_np_adv_nonwh_word := basic_np_adv_word &
  [ SYNSEM np_adv_synsem &
           [ LOCAL.CAT.VAL.SPR.FIRST [ LOCAL.CONT.HOOK.LTOP #ltop ],
             NONLOC.QUE 0-dlist,
	     LKEYS.ALTKEYREL.LBL #ltop ] ].

basic_np_adv_lexent := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
		     CONT.RELS <! relation & [ LBL #hand,
					       ARG0 #inst ], 
				[ PRED def_implicit_q_rel ],
				#alt2key & [ LBL #hand,
                                             ARG0 event & 
                                                 [ E [ TENSE untensed,
                                                       ASPECT no_aspect ] ],
                                             ARG1 #inst ] !> ],
	     LKEYS.ALT2KEYREL #alt2key ] ].

; 6-jun-04 - Changed SPR..HEAD from adv to n_or_adv to allow measure NPs
; as specifiers, as in "two weeks early"
np_adv_lexent := basic_np_adv_lexent &
  [ SYNSEM np_adv_synsem &
           [ LOCAL.CAT.VAL.SPR.FIRST [ LOCAL [ CAT.HEAD n_or_adv,
					       CONT.HOOK [ LTOP #ltop,
							   XARG #arg0 ] ],
				       NONLOC.QUE #que ],
	     NONLOC.QUE #que,
	     LKEYS.ALT2KEYREL [ LBL #ltop,
                                ARG0 #arg0 ] ] ].

norm_np_adv_lexent := np_adv_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST [ --MIN just_only_much_deg_rel ] ].

; DPF 9-oct-05 - Try making these [CASE obliq] to block them from ordinary
; direct objects, as in the object-extraction reading of "Here kim plunged t
; into the water"
n_-_ad-pl_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
                              CASE obliq ],
                   CONT.HOOK.INDEX.SORT place ] ].

n_-_ad-pl-nprd_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
                              PRD - ],
                   CONT.HOOK.INDEX.SORT place ] ].

n_-_ad-time_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN time_n_rel,
                   CONT.HOOK.INDEX.SORT time ] ].

; e.g. 'early', which allows "too/so early", unlike 'now', 'then'
n_-_ad-time-ns_le := np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN time_n_rel,
                         VAL.SPR.FIRST [ --MIN very_this_that_rel ] ],
                   CONT.HOOK.INDEX.SORT time ] ].

n_adv_event_lexent := norm_np_adv_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN place_n_rel,
             LKEYS.ALT2KEYREL.ARG0 [ E [ TENSE no_tense,
                                         ASPECT no_aspect ],
                                     SORT place ] ] ].

n_-_ad-loc_le := n_adv_event_lexent.

; 'there'
n_-_ad-acc_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD [ CASE acc,
                              MINORS.MIN place_n_rel ],
                   CONT.HOOK.INDEX.SORT place ] ].

; 'north' etc, which take degree specifiers like "far" or "ten miles",
; and an optional of-PP complement.
n_-_ad-dir_le := basic_np_adv_word &
  [ SYNSEM np_adv_synsem &
           [ LOCAL [ CAT [ HEAD.MINORS.MIN place_n_rel,
                           VAL [ SPR.FIRST [ --MIN much_deg_rel,
					     LOCAL [ CAT.HEAD n_or_adv,
						     CONT.HOOK [ LTOP #ltop,
								 XARG #arg0 ]],
					     NONLOC.QUE #que ],
				 COMPS < expressed_synsem &
                                         [ --MIN _of_p_sel_rel,
                                           LOCAL
                                           [ CAT [ HEAD prep & [ PRD - ],
                                                   VAL.COMPS < > ],
                                             CONT.HOOK [ LTOP #hand,
                                                         INDEX #ppind ] ],
                                           NONLOC [ SLASH #slash,
                                                    REL #rel,
                                                    QUE 0-dlist ],
                                           PUNCT.LPUNCT no_punct ] > ] ],
                     CONT [ HOOK.INDEX.SORT place,
                            RELS <! relation & [ LBL #hand,
                                                 ARG0 #inst ], 
                                  [ PRED def_implicit_q_rel ],
                                  #alt2key & [ LBL #hand,
                                               ARG1 #inst ] !> ] ],
             NONLOC [ SLASH #slash,
                      QUE #que,
                      REL #rel ],
             LKEYS.ALT2KEYREL #alt2key &
                              [ LBL #ltop,
                                ARG0 #arg0,
                                ARG2 #ppind ] ] ].

; 'then' -- to block "then Kim left" as N+RelClause.  Hack, since this
; also blocks "right then".
; [ACTIVATED -] prevents "then" from being topicalized, to avoid filler-head
; reading for "then kim arrived"
n_-_ad-br_le := basic_np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN time_n_rel,
                           VAL.SPR < anti_synsem_min & [ OPT - ] > ],
                     CONT.HOOK.INDEX.SORT time,
                     CTXT.ACTIVATED - ],
             NONLOC.QUE 0-dlist ] ].

; 'long' as in 'Kim stayed for too long', 'Kim stayed too long', and
; 'it took too long to finish'

basic_n_adv_gradable_lexent := np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN time_n_rel,
                           VAL.SPR.FIRST [ --MIN degree_rel,
					   LEX + ] ],
                     CONT.HOOK [ LTOP #lbl,
                                 INDEX.SORT time ] ],
             LKEYS.KEYREL.LBL #lbl ] ].

n_adv_gradable_lexent := basic_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD grad_n ].

n_-_ad-gr_le := n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST [ --MIN very_this_that_rel ] ].

; longer
n_-_ad-gr-cmp_le := n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST [ --MIN much_deg_rel ] ].

; soon
; DPF 07-may-04 - Added HEAD noun_nom as hack to prevent e.g. 'until soon'
n_-_ad-gr-nm_le := basic_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT 
                 [ HEAD.CASE nom,
                   VAL.SPR.FIRST [ --MIN very_this_that_rel ] ] ].
;sooner
n_-_ad-gr-cmp-nm_le := basic_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE nom,
                       VAL.SPR.FIRST [ --MIN much_deg_rel ] ] ].

; 'awhile'
; DPF 4-Apr-01 - Made ALTMIN be def_explicit_q_rel to block these guys as left 
; members of compounds as in "*the there books"
; DPF 11-Mar-02 - Changed SPR from anti_synsem_min to [MIN just_only_very_deg_rel]
; to allow "kim arrived just yesterday".
; DPF 04-Feb-03 - Can't make this [PRD -] because hadj rule now wants [PRD +]
; adjunct, but this means we overgenerate "the event awhile" since there's no
; way to say that "awhile" once turned into a modifier doesn't want to modify
; a nominal phrase.

n_-_ad-time-acc_le := basic_np_adv_nonwh_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ CASE acc,
                                  MINORS.MIN time_n_rel ],
                           VAL [ SPR.FIRST [ --MIN just_only_very_deg_rel,
					     LOCAL [ CAT.HEAD adv,
						     CONT.HOOK.XARG #arg0 ] ],
				 COMPS < > ] ],
                     CONT [ HOOK.INDEX.SORT time,
                            RELS <! relation, relation !> ] ],
             LKEYS [ ALTKEYREL.PRED def_explicit_q_rel,
                     ALT2KEYREL.ARG0 #arg0 ] ] ].

; later (in the day)
n_-_ad-cmp_le := basic_np_adv_word &
  [ SYNSEM np_adv_synsem &
	   [ LOCAL [ CAT.VAL [ SPR.FIRST [ --MIN just_only_very_deg_rel,
					   LOCAL [ CAT.HEAD n_or_adv,
						   CONT.HOOK.XARG #carg0 ] ],
                               COMPS < synsem & 
                                       [ OPT +,
                                         LOCAL [ CAT basic_pp_cat & 
                                                     [ HEAD.PRD + ],
                                                 CONT.HOOK [ LTOP #ltop,
                                                             INDEX #ind ],
                                                 CONJ cnil ],
                                         NONLOC.SLASH 0-dlist ] > ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #ind ],
                            RELS <! [ LBL #hand, 
                                      PRED modable_rel,
                                      ARG0 #inst ],
                                  [ PRED def_explicit_q_rel ],
                                  arg1_relation & #alt2key &
                                  [ LBL #hand,
				    ARG0 #arg0 &
					[ E [ TENSE no_tense,
					      ASPECT no_aspect ] ],
				    ARG1 #inst ],
                                  [ LBL #hand,
                                    PRED comp_rel,
				    ARG0 #carg0 & [ E [ TENSE no_tense,
                                                        ASPECT no_aspect ] ],
                                    ARG1 #arg0 ] !> ] ],
	     NONLOC.QUE 0-dlist,
	     LKEYS.ALT2KEYREL #alt2key ] ].

; DPF 27-Apr-00 - Added [CASE acc] to block spurious parse for "where is kim"
; DPF 19-Oct-02 - But this unfortunately also blocks "when would be a good 
; time to meet", and besides, "where would be a good place to meet" is okay.
; DPF 9-Jun-03 - Still, what's worse? extra parses for "where does kim work?"
; or no parse for "where would please sandy"?  Maybe we treat the latter as
; the result of robust parsing with relaxation of the CASE constraint, and
; exclude it as strictly grammatical (and likewise for "when would be a good
; time?").

n_wh_adv_lexent := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.CASE acc,
                           VAL [ SPR < anti_synsem_min & [ OPT - ] >,
                                 COMPS 
                                   < [ OPT +,
                                       --MIN wh_the_hell_rel,
                                       LOCAL [ CAT.HEAD wh_adv,
                                               CONJ cnil  ],
                                       NONLOC.SLASH 0-dlist ] > ] ],
                     CONT.RELS <! relation, [ PRED which_q_rel ] !> ],
             NONLOC.QUE 1-dlist &
		         [ LIST < param > ] ] ].

n_-_ad-wh-pl_le := n_wh_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN place_n_rel,
                   CONT.HOOK.INDEX.SORT place ] ].

n_-_ad-wh-tm_le := n_wh_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN time_n_rel,
                   CONT.HOOK.INDEX.SORT time ] ].

; For "the town where we come from"
n_rel_np_lexent := basic_noun_word & noncqs-hm-nab &
  [ SYNSEM nomod_synsem &
           [ LOCAL [ CAT [ HEAD noun &
                                [ MINORS.ALTMIN def_q_rel,
                                  CASE obliq ],
                           VAL [ SPR < anti_synsem_min >,
                                 SPEC < >,
                                 COMPS < > ] ],
                     CONT [ HOOK.INDEX #ind,
                            RELS <! !>,
                            HCONS <! !> ],
                     AGR #ind ],
             MODIFD notmod,
             NONLOC.REL 1-dlist & [ LIST < [ INDEX #ind ] > ],
	     LKEYS.KEYREL.PRED no_rel ] ].
    
n_-_pr-rel-pl_le := n_rel_np_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN place_n_rel ].

n_-_pr-rel-tm_le := n_rel_np_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN time_n_rel ].

; Lexical NP plurals - maybe only in British English? ("IBM are hiring again.")
;
np_pl_word := np_word &
  [ SYNSEM np_synsem &
	   [ LOCAL.CAT.VAL.COMPS < >,
             --SIND.PNG png & [ PN 3p ] ] ].

; DPF 25-May-03 - Added MOD..LTOP so "o'clock" and "fifteen" can both be
; combined with hour-words the same way, by getting at the MOD..LTOP value
; of the complement phrase (necessary since intersective adjectives do not
; lexically bind their LTOP to their key's LBL).
np_ersatz_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < anti_synsem_min & 
                               [ LOCAL.CONT.HOOK.LTOP #hand ] >,
                         MINORS.ALTMIN no_rel ],
                  VAL [ SPR < >,
			SUBJ < >,
			COMPS < >,
                        SPEC < > ] ],
	    CONT nom-obj &
		[ HOOK.LTOP #hand,
		  RELS.LIST < #keyrel, ... >,
		  HCONS <! !> ] ],
    MODIFD.LPERIPH -,
    LKEYS.KEYREL #keyrel & [ LBL #hand ] ].

np_word_no_quant := non_affixed_np &
  [ SYNSEM np_ersatz_synsem ].

ref_pro_np_synsem := basic_np_synsem & ref_pro_synsem.

; DPF 19-dec-04 - Added non-empty specifier to allow restrictive relatives 
; with pronouns: "He who saves...", "you who have...", and "that which you
; did will be rewarded".  But want to restrict this to nominative pronouns,
; to avoid spurious structures: "Kim hired [them in Paris]". So push SPR
; constraint down to various subtypes.
; DPF 03-jul-08 - Re 19-dec-04: Pull back up to pers_pro_synsem, since we
; now use this non-empty SPR property to force application of bare_np_q.
; Distinguish "we in Paris" from "*them in Paris" by further constraining
; the --MIN of the SPR.

pers_pro_synsem := ref_pro_np_synsem &
  [ LOCAL.CAT.VAL.SPR < anti_synsem_min & [ OPT - ] > ].

; For 'them all' as in 'we read them all', but not "*they hired me all"
;
pro_wcomps_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL [ COMPS 
                     < [ LOCAL [ CAT [ HEAD partn &
                                            [ MINORS [ MIN nonpro_rel,
						       ALTMIN both_all_q_rel]],
                                       VAL [ SPR < >,
					     COMPS < > ] ],
                                 CONT.HOOK.INDEX #cind ],
                         NONLOC non-local_none,
                         OPT -,
                         LEX +,
                         PUNCT.LPUNCT no_punct ] > ],
            CONT [ HOOK.INDEX #ind,
                   RELS <! [ LBL #lbl ], relation, [ LBL #lbl,
                                                     PRED id_rel,
                                                     ARG0.E.TENSE no_tense,
                                                     ARG1 #ind,
                                                     ARG2 #cind ] !> ] ] ].

; For 'we/us/you humans' but not '*they/them humans' (and not '*he/she humans')
; DPF 12-Oct-06 - Re-use the general referential-identity pred 'appos_rel' 
; rather than the idiosyncratic 'id_rel' used in tag questions.
pro_wcomps_plur_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL [ COMPS 
                       < [ LOCAL [ CAT [ HEAD basic_noun & 
                                          [ MINORS.ALTMIN both_all_udef_q_rel],
                                         VAL [ SPR *olist*,
					       SUBJ < >,
                                               COMPS < >,
                                               SPEC < anti_synsem_min > ] ],
                                   CONT.HOOK.INDEX #cind & nonconj_ref-ind,
                                   AGR.PNG.PN pl ],
                           OPT - ] > ],
            CONT [ HOOK.INDEX #ind,
                   RELS <! [ LBL #lbl ], relation, [ LBL #lbl,
                                                     PRED appos_rel,
                                                     ARG0.E.TENSE no_tense,
                                                     ARG1 #ind,
                                                     ARG2 #cind ] !> ] ] ].


basic_personal_pro := basic_np_word & basic_pronoun_word & 
                      basic_non_affixed_np &
  [ SYNSEM pers_pro_synsem &
	   [ LOCAL.CONT [ HOOK.LTOP #prohand,
                          RELS.LIST < [ LBL #prohand,
                                        PRED pron_rel,
                                        ARG0 #inst ],
                                      #altkeyrel &
                                      [ PRED pronoun_q_rel,
                                        RSTR #rhand,
                                        ARG0 #inst ], ... >,
                          HCONS <! qeq & [ HARG #rhand,
                                           LARG #prohand ] !> ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

personal_pro := basic_personal_pro &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT.RELS <! relation, relation !> ] ].

n_-_pr-na_le := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE nom,
                                MINORS.MIN pron_rel ],
                     AGR.PNG png & [ PN 3p ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                             GEN andro ],
                                 SORT entity,
                                 PRONTYPE std_pron ] ] ].

basic_n_pers_pro_lexent := basic_personal_pro & 
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                   AGR #agr,
		   CONT.HOOK.INDEX #agr &
			        [ PRONTYPE std_pron ] ] ].

n_pers_pro_lexent := basic_n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ HOOK.INDEX.SORT entity,
                          RELS <! relation, relation !> ] ] ].

n_pers_pro_nom_lexent := n_pers_pro_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom ].

n_pers_pro_acc_lexent := n_pers_pro_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE acc,
		       VAL.SPR < [ --MIN no_rel ] > ] ].

n_-_pr-he_le := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN masc ],
                               PRONTYPE std_pron ] ].

n_-_pr-she_le := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN fem ],
                               PRONTYPE std_pron ] ].

n_-_pr-her_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN fem ],
                               PRONTYPE std_pron ] ].

n_-_pr-him_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN masc ],
                               PRONTYPE std_pron ] ].

n_-_pr-i_le := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
                               PRONTYPE std_pron ] ].

n_-_pr-me_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
                               PRONTYPE std_pron ] ].

n_-_pr-you_le := n_pers_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
			       PRONTYPE std_pron,
			       SORT entity ] ].

; DPF 7-Dec-02 - ACTIVATED is here experimentally, and at present only prevents
; "it" from being topicalized as in "*It I like".

n_-_pr-it_le := basic_n_pers_pro_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR < [ --MIN no_rel ] >,
			       COMPS < > ],
                     CONT.RELS <! relation, relation !>,
                     CTXT.ACTIVATED - ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                             GEN neut ],
                                 PRONTYPE std_pron ] ] ].

n_-_pr-we_le := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                               PRONTYPE std_pron,
                               SORT entity ] ].

n_-_pr-us_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                               PRONTYPE std_pron,
                               SORT entity ] ].

n_-_pr-they_le := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                               PRONTYPE std_pron ] ].

n_-_pr-them_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                               PRONTYPE std_pron ] ].

n_-_pr-thou_le := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                               PRONTYPE std_pron,
                               SORT entity ] ].

n_-_pr-thee_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                               PRONTYPE std_pron,
                               SORT entity ] ].
; 'yours truly'
n_-_pr-1sg-na_le := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                     AGR.PNG png & [ PN 3s ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
                                 PRONTYPE std_pron ] ] ].

; DPF 20-Feb-07 - Why isn't "one another" just another reciprocal pronoun?
#|
n_-_pr-one-anoth_le := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s,
                                         GEN andro1 ] ].
|#

n_np_pr-us_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_plur_synsem &
           [ LOCAL [ CAT [ HEAD.CASE acc,
			   VAL.SPR < [ --MIN no_rel ] > ],
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                                 PRONTYPE std_pron ] ] ].
            
n_np_pr-we_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_plur_synsem &
           [ LOCAL [ CAT.HEAD.CASE nom,
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                                 PRONTYPE std_pron ] ] ].


n_np_pr-you_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_plur_synsem &
           [ LOCAL.CONT.HOOK.INDEX.SORT entity,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                                 PRONTYPE std_pron ] ] ].

n_np_pr-it_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.VAL.SPR < [ --MIN no_rel ]  >,
		     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s ],
                                 PRONTYPE std_pron ] ] ].
            
n_np_pr-they_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.HEAD.CASE nom,
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                                 PRONTYPE std_pron ] ] ].
            
n_np_pr-them_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT [ HEAD.CASE acc,
			   VAL.SPR < [ --MIN no_rel ] > ],
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                                 PRONTYPE std_pron ] ] ].
            
n_refl_pro_lexent := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE acc,
				MINORS.MIN refl_pron_rel ],
		     AGR #agr,
                     CONT.HOOK.INDEX #agr ],
             LKEYS.KEYREL [ PRED pron_rel,
                            ARG0 [ PRONTYPE refl,
                                   SORT entity ] ] ] ].

n_-_pr-herself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN fem ] ].
n_-_pr-himself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN masc ] ].
n_-_pr-itself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN neut ] ].
n_-_pr-myself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 1s ] ].
n_-_pr-ourslves_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 1p ] ].
n_-_pr-themslves_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ].
n_-_pr-yourself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 2s ] ].
n_-_pr-yourslves_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 2p ] ].
n_-_pr-oneself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN andro ] ].

; 'see it yourself!'
; DPF 25-aug-07 - Restricted MOD..HEAD to AUX - to avoid spurious ambiguity 
; for e.g. "He was hired himself."

adv_refl_pro_lexent := noncrs-hm & word &
  [ INFLECTD +,
    SYNSEM basic_int_adverb_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT adverbee_cat &
                                                  [ HEAD.AUX -,
                                                    VAL [ SUBJ *synlist*,
                                                          COMPS < > ] ],
                                        MODIFD.RPERIPH na_or_- ] >,
                           VAL.SPR < anti_synsem >,
                           POSTHD + ],
                     CONT [ RELS <! [ PRED _for_p_rel,
                                      ARG2 #inst ],
                                    #altkeyrel &
                                    [ LBL #prohand, 
                                      PRED pron_rel,
                                      ARG0 #inst & [ PRONTYPE refl,
                                                     SORT entity ] ],
                                    [ PRED pronoun_q_rel,
                                      RSTR #rhand,
                                      ARG0 #inst ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !> ] ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

av_-_pr-herself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN fem ] ].
av_-_pr-himself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN masc ] ].
av_-_pr-itself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN neut ] ].
av_-_pr-myself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 1s ] ].
av_-_pr-ourslvs_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 1p ] ].
av_-_pr-thmslvs_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3p ] ].
av_-_pr-yrself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 2s ] ].
av_-_pr-yrslvs_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 2p ] ].
av_-_pr-oneself_le := adv_refl_pro_lexent &
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN andro ] ].

n_-_pr-recip_le := np_word &
  [ SYNSEM ref_pro_np_synsem &
	   [ LOCAL [ CAT [ HEAD [ CASE acc,
                                  MINORS.MIN recip_pro_rel ],
                           VAL.COMPS < > ],
                     AGR #ind,
                     CONT [ HOOK.INDEX #ind,
			    RELS <! [ LBL #prohand,
                                      PRED recip_pro_rel,
                                      ARG0.PRONTYPE recip ],
                                    [ PRED pronoun_q_rel,
                                      ARG0 #ind,
                                      RSTR #rhand ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !> ] ],
             LKEYS.KEYREL.ARG0.PNG png & [ PN pl ] ] ].

; 'yours'
; DPF 15-Apr-00 = Changed MIN to be pron_rel rather than pronoun_q_rel, since
; e.g. prepositions want a non_temp_nom_rel as their argument.

n_poss_pro_lexent := noncrs-hm-nab & basic_pronoun_word &
  [ SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD partn & [ MINORS [ MIN pron_rel,
						   ALTMIN poss_rel ] ],
                           VAL [ COMPS < >,
				 SPR < anti_synsem_min & [ OPT - ] >,
				 SPEC < anti_synsem_min > ] ],
                     AGR #index,
		     CONT [ HOOK.INDEX #index,
			    RELS <! #keyrel & 
				     [ LBL #prohand,
                                       PRED pron_rel,
                                       ARG0 #pind &
                                           [ PRONTYPE std_pron,
                                             SORT entity ] ],
                                     [ PRED pronoun_q_rel,
                                       ARG0 #pind,
				       RSTR #rhand ],
				     [ PRED def_implicit_q_rel,
                                       ARG0 #index,
				       RSTR #phand ],
                                     nom_relation &
                                     [ LBL #nhand,
                                       PRED generic_entity_rel,
                                       ARG0 #index ],
                                     #altkeyrel & prep_relation &
				     [ LBL #nhand,
                                       PRED poss_rel,
                                       ARG0.E [ TENSE no_tense,
                                                ASPECT no_aspect ],
				       ARG1 #index,
				       ARG2 #pind ] !>,
			    HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ],
                                      qeq & [ HARG #phand,
                                              LARG #nhand ] !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ],
             NONLOC.QUE <! !>,
	     MODIFD notmod ] ].

n_-_pr-hers_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
                                                       GEN fem ] ].
n_-_pr-his_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
                                                       GEN masc ] ].
n_-_pr-its_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
                                                       GEN neut ] ].
n_-_pr-mine_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1s ] ].
n_-_pr-ours_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1p ] ].
n_-_pr-theirs_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3p ] ].
n_-_pr-yours_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 2 ] ].

; Expletive pronouns "there" and "it"
; DPF 3-Jul-02 - Changed MIN from no_rel to pron_rel, to allow simpler
; generalization about subjects of tag-phrases.  Still have empty RELS

norm_pronoun_word := noncqrs-m-nab & basic_pronoun_word.

n_-_pr-it-x_le := norm_pronoun_word &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                     CONT [ HOOK.INDEX it-ind,
                            RELS <! !> ] ],
             LKEYS.KEYREL.PRED pron_rel,
	     MODIFD notmod ] ].

n_-_pr-there-x_le := norm_pronoun_word &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                     CONT [ HOOK.INDEX there-ind,
                            RELS <! !> ] ],
             LKEYS.KEYREL.PRED pron_rel,
	     MODIFD notmod ] ].
			  

; ERB (31-10-96) A hack:  I want the wh_interrogs to be able to
; get their hands on the which_q_rel so they can put it on the PARAMS
; list, but QSTORE isn't working yet.  So I am making the QUE value
; of wh_pro_word, wh_adverb_word, and wh_poss_word be the handle of
; the which_q_rel, so that this gets passed up in such a way that I can see it.

; DPF (3-May-99) We can't just put the handle of the which_q_rel in QUE, since
; in coordinate structures like "which book and which record did sandy buy?"
; we want to unify the NONLOCs of "which book" and "which record", but this
; would mean that the handles of the two which_q_rel's would be wrongly 
; identified. 
; So for now I'm just putting in an unbound handle - we'll have to sort out
; with Ivan what the right solution is.
; DPF 16-jan-08 - Tried changing MIN from norm_nom_rel to pron_rel in order
; to block "*Who's cat", but this runs afoul of constraint on ditransitives
; like "show" to avoid "*he showed Browne it."  So find a better solution...
; FIX

; 'who, what'
n_wh_pro_lexent := que_word & basic_pronoun_word &
  [ SYNSEM ref_pro_synsem &
	 [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         VAL [ SPR < anti_synsem_min & [ OPT - ] >,
			       COMPS < [ OPT +,
                                         --MIN wh_the_hell_rel,
                                         LOCAL [ CAT.HEAD wh_adv,
                                                 CONJ cnil ],
                                         PUNCT.LPUNCT no_punct ] > ] ],
                   AGR #index,
                   CONT [ HOOK [ INDEX #index,
                                 XARG #nhand ],
                          RELS <! [ LBL #nhand ],
                                  [ PRED which_q_rel,
                                    ARG0 #index,
                                    RSTR #rhand ] !>,
			  HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !> ] ],
	   NONLOC.QUE 1-dlist &
		         [ LIST < param > ],
	   MODIFD notmod ] ].

n_-_pr-wh_le :< n_wh_pro_lexent.
n_-_pr-who_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN 3s ].

n_-_pr-wh-acc_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
		   CONT.HOOK.INDEX.PNG.PN 3s ] ].

basic_n_rel_pro_lexent := noncqs-hm-nab & basic_pronoun_word & 
  [ SYNSEM pronominal_synsem &
	 [ LOCAL [ CAT [ HEAD [ MOD < >,
                                MINORS [ MIN non_temp_nonpro_rel,
                                         ALTMIN norm_rel ] ],
			 VAL [ SUBJ < >,
			       SPR < anti_synsem_min & [ OPT - ] >,
			       COMPS < > ] ],
                   AGR #index,
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index,
                                 XARG #xarg ],
			  RELS <! !>,
			  HCONS <! !> ] ],
           LKEYS [ KEYREL [ LBL #hand,
                            PRED no_rel ],
                   ALTKEYREL relation ],
           NONLOC.REL 1-dlist &
		         [ LIST < [ LTOP #hand,
				    INDEX #index,
                                    XARG #xarg ] > ] ] ].

n_rel_pro_lexent := basic_n_rel_pro_lexent.

n_-_pr-rel-who_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
                     CONT.HOOK.INDEX.SORT human ] ] ].

n_-_pr-rel-what_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
                     CONT.HOOK.INDEX.SORT nominal-sort ] ] ].

; Not notmod to let us get "the day that I arrived"/"*the day which i arrived"

n_-_pr-rel-acc_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD [ CASE acc,
                                MINORS.MIN norm_nom_rel ],
                     CONT.HOOK.INDEX.SORT human ] ] ].

; Unmarked for MODIFD, so can undergo temp_np rule to get "the day that I
; arrived"  But to get this, also need to make SPR be non-empty, since the
; extracted-adj-temp rule only allows n-bar slashed elements.
; DPF 19-dec-03 - In fact, need two entries for 'that', since we want to
; allow "the place that Kim stood" but not "*the car that Kim stood" (cf
; "the car where Kim stood".  The one entry is the nbar-filler for the gap
; for the npadv.

n_rel_pro_nonwh_lexent := basic_n_rel_pro_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.PRD -,
                     CONT.HOOK.INDEX.SORT nominal-sort ] ] ].

n_-_pr-rel-nwh_le := n_rel_pro_nonwh_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ].

; DPF 2-apr-05 - Removed AGR.DIV - since this blocks "on the days that
; we perform"
n_-_pr-rel-ad_le := n_rel_pro_nonwh_lexent &
  [ SYNSEM [ LOCAL.CAT basic_nbar_cat & 
                       [ HEAD.MINORS [ MIN modable_nom_rel,
                                       NORM modable_rel ],
                         VAL.SPR < unexpressed &
                                   [ --MIN no_rel ] > ],
             MODIFD.LPERIPH + ] ].

; DPF 28-Aug-99 - SPR..MIN no_rel prevents these from undergoing bare_np rule
; DPF 09-Jan-00 - In fact, can now eliminate bogus SPR, since picking up
; post-head adjuncts as complements.
; DPF 06-May-03 - Removed COMPS..HEAD adj* restriction, since we need to have
; these guys pick up post-head PPs as complements so "anytime after three"
; can still be compatible with the npadv_mod rule's requirement that the dtr
; be [HODIFIED lmod], in order to get the desired analysis for "Kim arrived
; sometime after three".
; DPF 03-Dec-03 - But now getting posthead PPs as modifiers, so go back to
; only allowing adjectival complements.
; DPF 03-Dec-06 - Since also get modifier analysis for all phrases, restrict
; this complement to LEX +, to allow "anyone tall" which would not parse 
; with a modifier analysis.

generic_pro_adv_word := que_word & basic_pronoun_word &
  [ SYNSEM np_synsem &
     [ LOCAL 
        [ CAT [ HEAD #head & 
                     [ MINORS.ALTMIN nondef_explicit_q_rel ],
                VAL [ SPR < [ --MIN degree_rel,
                              LOCAL.CONT.HOOK [ LTOP #khand,
                                                XARG #inst ],
                              NONLOC [ QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT + ],
			    anti_synsem_min & [ OPT - ] >,
                      COMPS < [ OPT +,
                                LEX +,
                                LOCAL 
                                 [ CAT prd_cat & 
                                       [ HEAD v_or_a &
                                         [ MOD < [ LOCAL.CAT.HEAD #head ] > ]],
                                   CONJ cnil,
                                   CONT.HOOK [ LTOP #nhand,
                                               XARG #inst ] ],
                                NONLOC non-local_none,
                                PUNCT.LPUNCT no_punct ] > ] ],
          CONT [ HOOK.LTOP #nhand,
                 RELS <! relation,
                         #altkeyrel & [ PRED quant_rel ] !>,
                 HCONS <! qeq &
                        [ HARG #rhand,
                          LARG #nhand ] !> ] ],
       LKEYS [ KEYREL [ LBL #nhand,
                        ARG0 #inst & [ PNG png & [ PN 3s ] ] ],
               ALTKEYREL #altkeyrel & 
                      [ LBL #khand,
                        ARG0 #inst,
                        RSTR #rhand ] ],
       NONLOC.QUE 0-dlist ] ].

n_-_pr-ad_le := generic_pro_adv_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN modable_rel ].

n_generic_pro_lexent := generic_pro_adv_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.SORT entity,
             MODIFD notmod ] ].

n_-_pr_le := n_generic_pro_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ].
                     
; 'one'
; DPF 23-sept-04 - Curious note: If we don't make COMPS < anti_synsem_min >,
; then we get an asymmetry in how PET and the LKB process "one should": PET
; allows "one" to undergo hoptcomp rule in addition to noptcomp rule, even
; though hoptcomp says head is MIN event_rel while 'one' says MIN is not
; (obviously) a subtype of event_rel.  FIX...
n_-_pr-one_le := n_generic_pro_lexent &
  [ SYNSEM.LOCAL 
           [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                   VAL [ SPR.FIRST [ --MIN just_only_deg_rel ],
                         COMPS < anti_synsem_min > ] ],
             CONT.HOOK.INDEX.PNG.GEN andro ] ].

n_deictic_pro_lexent := norm_pronoun_word &
  [ SYNSEM ref_pro_synsem &
    [ LOCAL 
      [ CAT [ HEAD.MINORS [ MIN generic_nom_rel,
                            ALTMIN demonstrative_q_rel ],
              VAL [ SPR < [ --MIN just_only_deg_rel,
                            LOCAL.CONT.HOOK.LTOP #khand,
                            NONLOC [ QUE 0-dlist,
                                     REL 0-dlist ],
                            OPT + ],
			  anti_synsem_min & [ OPT - ] >,
                    COMPS < [ LOCAL.CAT 
                             [ HEAD partn &
                                    [ MINORS.ALTMIN both_all_q_rel ],
                               VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                                     COMPS < unexpressed &
                                             [ LOCAL 
                                               [ CAT nomp_cat_min,
                                                 CONT.HOOK.INDEX index,
                                                 AGR #index ],
                                               --SIND #index ] > ] ],
                              OPT +,
                              LEX +,
                              PUNCT.LPUNCT no_punct ] > ] ],
        CONT [ HOOK [ LTOP #nhand,
                      INDEX #index,
                      XARG #nhand ],
               RELS <! [ LBL #nhand,
                         PRED generic_entity_rel ], 
                     #altkeyrel &
                     [ LBL #khand,
                       PRED demonstrative_q_rel,
                       ARG0 #ind,
                       RSTR #rhand ] !>,
               HCONS <! qeq &
                      [ HARG #rhand,
                        LARG #hand ] !> ],
        AGR #index ],
      LKEYS [ KEYREL [ LBL #hand,
                       ARG0 #ind ],
              ALTKEYREL #altkeyrel ],
      MODIFD notmod ] ].

; 'those of us who ...'
n_pp_pr-dei-3pl_le := noncqrs-m-nab & basic_pronoun_word &
  [ SYNSEM ref_pro_synsem &
    [ LOCAL [ CAT [ HEAD.MINORS [ MIN generic_nom_rel,
                                  ALTMIN demonstrative_q_rel ],
                    VAL [ SPR < [ --MIN just_only_deg_rel,
                                  LOCAL.CONT.HOOK.LTOP #dhand,
                                  NONLOC [ QUE 0-dlist,
                                           REL 0-dlist ],
                                  OPT + ],
				anti_synsem_min & [ OPT - ] >,
                          COMPS < [ --MIN _of_p_sel_rel,
                                    LOCAL [ CAT [ HEAD prep & 
                                                       [ PRD -,
                                                         TAM.TENSE nontense ],
                                                  VAL.COMPS < > ],
                                            CONT.HOOK.INDEX #pind ],
                                    OPT -,
                                    PUNCT.LPUNCT no_punct ] > ] ],
              CONT [ HOOK [ LTOP #hand,
                            INDEX #ind & [ PNG.PN 3p ],
                            XARG #hand ],
                     RELS <! #keyrel & 
                             [ LBL #hand,
                               PRED part_of_rel,
                               ARG0 #ind,
                               ARG1 #pind & non_expl-ind ], 
                             #altkeyrel &
                             [ LBL #dhand,
                               PRED _those_q_dem_rel,
                               ARG0 #ind,
                               RSTR #rhand ] !>,
                     HCONS <! qeq &
                              [ HARG #rhand,
                                LARG #hand ] !> ],
              AGR #ind ],
      LKEYS [ KEYREL #keyrel,
              ALTKEYREL #altkeyrel ],
      MODIFD notmod ] ].

; DPF 16-oct-03 - Added NORM norm_rel to prevent singular deictics from
; being modified, to get contrast of "*that he bought yesterday arrived" vs
; "those he bought yesterday arrived".
; DPF 19-dec-04 - But this also rules out relative clauses with "which", as
; in 'that which you need will be provided'.  Not clear how to exclude the
; thatless-relatives for singular deictics: odd constraint.  For now, remove
; the old constraint, and overgenerate the first example above.
; DFP 25-oct-05 - Since this overgeneration continues to be costly, we 
; distinguish singular from plural deictics in NORM, and constrain the
; fin_non_wh_rel_cl rule to require its MOD to be NORM norm_rel, so we
; block "*This he bought was nice" but admit "Those he bought were nice".

n_-_pr-dei-sg_le := n_deictic_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM deictic_sg_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3s,
                                           GEN neut ] ] ].

n_-_pr-dei-pl_le := n_deictic_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsems for Auxiliary verb lexical rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ERB (05-10-97) Making this specific to question auxes.  See notes near sai
; in syntax.tdl.
; DPF 26-Jan-01 - Changed HEAD.INV + to HEAD.INV +* to allow for coordination
; of inverted and non-inverted sentences.  Prevent yes-no question rule from
; applying to main verbs by making inverted auxiliaries [MC na], so they have
; to undergo the yes-no rule.
; ERB (2003-10-13) Need a supertype to allow mal_sai_synsem: making
; basic_sai_synsem.

basic_sai_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD verb & [ INV +,
                                PRD -,
                                MOD < [ --MIN no_rel,
                                        LOCAL intersective_mod &
                                              [ CAT.VAL.SPR *cons* ] ] >,
                                TAM indic_tam ],
                  VAL.COMPS #comps & < [ NONLOC.SLASH 0-dlist ], ... >,
		  POSTHD +,
		  MC na ],
	    ARG-S #comps ] ].

sai_synsem := basic_sai_synsem &
  [ LOCAL.CAT.HEAD.AUX + ].

; DPF 3-Jul-02 Changed to COMPS..MIN pron_rel from COMPS..ALTMIN no_rel,
; since common nouns are often unmarked for ALTMIN, and it was a hack.
; DPF 19-Oct-02 - Were using hack of SPEC < > to keep poss-pronouns like
; "mine" out of COMPS, but this also blocked "than mine", so instead use
; difference in ALTMIN for "she" and "hers".
; DPF 9-Feb-03 Changed HEAD value from 'verb' to 'tagaux' so bare tag
; questions don't show up as root clauses (we can't just make them MC -,
; since the MC of a head-mod phrase comes from the modifier daughter).
; DPF 20-apr-05 Since we now make lexical NPs by default have an ALTMIN
; of def_q_rel (but don't (yet) for possessive pronouns like 'mine'),
; changed ALTMIN on complement to def_q_rel.

tag_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD tagaux &
		       [ AUX -,
			 INV -,
			 TAM indic_tam &
                             [ TENSE #tense ],
			 MOD < [ --MIN #min,
                                 LOCAL scopal_mod &
				       [ CAT s_cat_fin &
					     [ HEAD.TAM.TENSE #tense,
                                               MC + ],
					 AGR.PNG #png & png,
					 CONT.HOOK.INDEX [ E.TENSE real_tense,
                                                           SF prop ] ],
                                 NONLOC [ SLASH 0-dlist,
                                          REL 0-dlist,
                                          QUE 0-dlist ],
                                 PUNCT.RPUNCT comma_or_no_punct ] >,
                         MINORS.MIN #min ],
		  POSTHD +,
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < [ OPT -,
				  LOCAL [ CAT.HEAD.MINORS 
                                                 [ MIN pron_rel,
                                                   ALTMIN def_q_rel ],
                                          AGR #tagagr ],
                                  --SIND.PNG #png,
                                  PUNCT.RPUNCT clause_or_no_punct & 
                                               [ PSF #sf ] ] > ],
                  MC + ],
            CONT.HOOK.INDEX.SF #sf & prop-or-ques,
            AGR #tagagr ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADJECTIVES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (See prep_synsem definition for discussion of ARG1 attribute.)

; Predicative adjectives used to introduce an ARG0 attribute in a separate 
; support relation, as did predicative PPs, but now each introduces its own
; ARG0 attribute directly in the MIN relation.

; Assume that if adjectives have a specifier, it will be either a measure-NP,
; as in "two feet tall', 'a week later"; or a degree_adverb like "very".

; Since most adjectives are underspecified for being predicative, we have to be
; sure that when they act as modifiers, the unexpressed subject's SLASH value 
; gets terminated (given lexical SLASH amalgamation).  We can't just make the
; adjective's SUBJ be 'unexpressed' since it must unify with the real subject
; in a raising construction.  So we identify the SLASH of the MOD value with
; that of the SUBJ - only one of the two will be realized syntactically.

; Most but not all adjectives can be modifiers, so the most basic adj_synsem
; type does not introduce the MOD feature, to allow for adjectives like
; "impossible" as in "it is impossible to find Kim".

;; DPF 3-Feb-01 - Removed SPR..COMPS *olist* to allow for equatives like
;; "as tall as you" where first "as" combines with "tall" and passes up its
;; as-complement.
;; DPF 5-Apr-01 - Added [LPERIPH na] to interact correctly with adj-head rule 
;; and noun-noun-cmpnd rule, to block "*towel rusty rack" - the adj-head rule 
;; makes its LPERIPH value that of the adjunct dtr, and the n-n-cmpnd rule 
;; blocks all but [LPERIPH -] head-dtr.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so adjs can
;; coordinate with VPs (which are necessarily SPR anti_synsem_min).

;; DPF 25-Sep-01 - Added AGR reentrancy with SUBJ's AGR, like with verbs, to
;; make sure modification works right in no_copula constructions as in "skies
;; light becoming dark.  But for now must also hardwire link between SUBJ's
;; AGR and INDEX, since the bare-np rule necessarily breaks this link to get
;; DIV right.  Sigh - this will break a few tag questions, as in
;; "Someone is happy, aren't they?"
;; DPF 14-Oct-03 - Changed LPERIPH value from na to + since we want "same day"
;; to be LPERIPH +, not na.  Needed in particular for tempnp rule as in
;; 'Kim arrived the same day' since it requires the NP to be modified and
;; LPERIPH +.
;; DPF 22-Nov-03 - But now make LPERIPH bool since we need "annual report"
;; to be compatible with LPERIPH na_or_- in order to get "IBM annual report"
;; DPF 24-aug-06 - Moved LPERIPH bool down to subtypes, since want to make
;; comparative "more" be LPERIPH na, to prevent further modification as in
;; "*happy more cats"

basic_adj_synsem_lex_or_phrase := canonical_synsem &
  [ LOCAL [ AGR #agr,
            CAT [ HEAD [ TAM #tam,
                         MINORS.MIN basic_adj_rel ],
		  VAL.SUBJ < > ],
            CONT.HOOK [ INDEX.E #tam,
			XARG #agr ] ],
    MODIFD notmod ].

; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).
; DPF 8-Jun-03 -Added SPR..LEX + to block "Kim is as as Sandy tall" but allow
; "Kim is as tall as Sandy"
; DPF 11-Sep-03 - But this prevents measure-phrase specifiers, so remove, and
; look for an alternative to block above.  **FIX**
; DPF 21-oct-03 - Fixed, since MNPs are now LEX +.
; DPF 19-aug-04 - But then we block "the structures forty feet tall" (along
; with "*the structures very tall").  So we'll try making the HS-LEX value
; be constrained by the specifier, and adjust the relevant head_spec rule
; accordingly.

basic_adj_abstr_lex_synsem := basic_adj_synsem_lex_or_phrase & 
                              abstr_lex_synsem &
  [ LOCAL.CONT.RELS.LIST.FIRST basic_adj_relation ].

basic_adj_lex_synsem := basic_adj_abstr_lex_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
            CAT [ HEAD adj_or_intadj,
                  VAL [ SPR 
                        < #spr & synsem_min &
                          [ --MIN degree_rel,
                            LOCAL
                            [ CAT [ VAL [ SPR *olist*,
                                          SPEC < [ LOCAL.CAT.HS-LEX #hslex ]>],
                                    MC na ],
                              CONT.HOOK.LTOP #ltop ],
                            NONLOC.SLASH 0-dlist,
                            OPT + ] >,
                        COMPS #comps ],
                  HS-LEX #hslex ],
            CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

basic_adj_synsem := basic_adj_lex_synsem &
  [ MODIFD.LPERIPH bool,
    LOCAL.CAT [ HEAD adj_or_intadj &
                     [ MINORS.ALTMIN #altmin ],
                VAL.SPR < [ LOCAL.CAT.HEAD.MINORS.ALTMIN #altmin ] > ] ].

norm_adj_lex_synsem := basic_adj_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_adj,
                  VAL.SPR < [ LOCAL.CONT.HOOK.XARG #arg0 ] > ],
            CONT.HOOK.INDEX #arg0 ],
    LKEYS.KEYREL.ARG0 #arg0 ].

;; We assume for now, counterfactually, that all modifying adjectives are
;; intersective.

;; ERB (03-02-98) Maybe should add MOD < [ LOCAL.SPR.OPT ] > - to keep 
;; adjectives from modifying partitives.

;; DPF (16-Feb-98) Made XARG be 'ref-ind' rather than non_expl-ind,
;; to ensure that it gets discourse-bound if the adjective is used in a 
;; fragment.

;; DPF (12-Jul-98) Constrain adjectives to only modify nominals with obligatory
;; specifiers (which distinguishes "common" from "proper" nominals).
;; DPF 9-oct-05 - Try constraining the MOD..MIN to nonpro_rel to block
;; modification of number-nouns ("*old one arrives"), analogous to blocking
;; in n-n compounds.
;; DPF 5-oct-06 - But this conflicts now with making 'group' nouns propagate
;; the MIN of their complement's NP.  And the combination of adj+numnoun is
;; not really out: "Unlucky 13 is often avoided".  So let's take the hit in
;; added ambiguity.
;; DPF 31-jul-07 - Removed mysterious [MOD..OPT -], which was surely not right.

adj_synsem_lex_or_phrase := basic_adj_synsem_lex_or_phrase &
  [ LOCAL [ CAT.HEAD.MOD 
             < synsem_min &
               [ LOCAL [ CAT [ HEAD basic_nom_or_ttl &
                                    [ POSS - ],
                               VAL [ SUBJ < >,
                                     SPR.FIRST synsem & 
					  [ --MIN quant_or_deg_rel ],
                                     COMPS < > ],
                               MC na ],
                         CONJ cnil ],
                 --SIND #ind ] >,
            CONT.HOOK.XARG #ind ] ].

norm_adj_synsem := adj_synsem_lex_or_phrase &
  [ LOCAL.CONT.HOOK.XARG basic_non_expl ].

adj_synsem := norm_adj_lex_synsem & norm_adj_synsem & isect_synsem.
adj_onearg_lex_synsem := norm_adj_lex_synsem & isect_synsem & one_arg.
adj_twoarg_lex_synsem := norm_adj_lex_synsem & isect_synsem & two_arg.
basic_adj_onearg_synsem := basic_adj_synsem & one_arg &
  [ LOCAL.CAT [ HEAD adj,
                VAL.COMPS < > ] ].
adj_twoarg_synsem := adj_synsem & two_arg.
; For comparatives and other semantically complex adjectives with new INDEX
adj_unsp_ind_synsem := basic_adj_lex_synsem & lex_synsem & 
                       adj_synsem_lex_or_phrase & isect_synsem.
adj_unsp_ind_onearg_synsem := adj_unsp_ind_synsem & one_arg &
  [ LOCAL.CAT [ HEAD.MINORS.MIN abstr_adj_rel,
                VAL.COMPS < > ] ].
adj_unsp_ind_twoarg_synsem := adj_unsp_ind_synsem & two_arg.

#|
; For measure-nouns used as adjectives, as in "ten foot pole"
adj_synsem_phr := norm_adj_synsem & phr_synsem &
  [ LOCAL.CAT [ HEAD adj &
                     [ PRD -,
                       MOD < [ LOCAL intersective_mod &
                                     [ CAT [ HEAD.MINORS.ALTMIN no_rel,
                                             VAL.SPR < [ --MIN quant_rel ] >]],
                               NONLOC.REL 0-dlist ] > ],
                VAL [ SPR < >,
                      COMPS < > ] ],
    MODIFD.LPERIPH bool ].
|#

adj_synsem_constr := norm_adj_synsem &
  [ LOCAL [ CAT [ HEAD adj &
		       [ MOD < synsem &
			       [ LOCAL intersective_mod &
				       [ AGR #ind ],
				 NONLOC.REL 0-dlist,
				 --SIND #ind ] >,
			 MINORS [ MIN norm_adj_rel,
				  NORM norm_rel ] ],
		  VAL [ SPR < [ --MIN more_or_very_deg_rel,
				LEX + ] >,
			COMPS < >,
			SPEC < > ] ],
	    CONT [ HOOK.LTOP #hand,
		   RELS.LIST.FIRST.LBL #hand ] ],
    NONLOC non-local_none ].

adj_synsem_lex_constr := adj_synsem_constr & norm_adj_lex_synsem.

; 'cat-like'
adj_synsem_n_spr := basic_adj_abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD adj &
		       [ MOD < synsem &
			       [ LOCAL intersective_mod &
				       [ AGR #ind,
					 CAT [ HEAD basic_nom_or_ttl &
						    [ POSS - ],
					       VAL [ SUBJ < >,
						     SPR < synsem & 
						       [ --MIN 
							 quant_or_deg_rel ] >,
						     COMPS < >,
						     SPCMPS < > ],
					       MC na ] ],
				 NONLOC.REL 0-dlist,
				 --SIND #ind ] >,
			 MINORS.MIN norm_adj_rel ],
		  VAL [ SPR < [ LOCAL [ CAT [ HEAD noun,
					      VAL [ SPR < synsem_min >,
						    COMPS < > ] ],
					CONT.HOOK [ LTOP #nhand,
						    INDEX #nind ] ],
				--MIN nonpro_rel,
				LEX + ] >,
			COMPS < >,
			SPEC < > ] ],
	    CONT [ HOOK [ LTOP #hand,
			  XARG #ind ],
		   RELS <! #keyrel &
			   [ LBL #hand,
			     ARG1 #ind,
			     ARG2 #nind ],
			   [ PRED udef_q_rel,
			     ARG0 #nind,
			     RSTR #rhand ] !>,
		   HCONS <! qeq &
                           [ HARG #rhand,
                             LARG #nhand ] !> ] ],
    NONLOC non-local_none,
    LKEYS.KEYREL #keyrel ].

nomod_adj_synsem := norm_adj_lex_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD no_head ] > ].

nonprd_synsem := lex_synsem &
  [ LOCAL.CAT.HEAD.PRD - ].

prd_synsem := lex_synsem &
  [ LOCAL [ CAT.HEAD.PRD + ] ].

intrans_adj_synsem := adj_synsem & one_arg &
  [ LOCAL.CAT [ HEAD.MINORS.MIN abstr_adj_rel,
                VAL.COMPS < > ] ].

basic_attr_adj_synsem := intrans_adj_synsem & nonprd_synsem &
  [ LOCAL.CAT.POSTHD -,
    NONLOC.REL 0-dlist ].

; DPF 27-nov-04 - Block SPR for these, to avoid e.g. "*a very mere child"
attr_adj_synsem := basic_attr_adj_synsem &
  [ LOCAL [ CAT [ HEAD adj & [ MOD < [ --SIND #ind ] > ],
                  VAL.SPR < anti_synsem > ],
            CONT.HOOK.XARG #ind ],
    NONLOC.QUE 0-dlist,
    LKEYS.KEYREL.ARG1 #ind & non_expl-ind ].

pred_adj_synsem := adj_unsp_ind_synsem & prd_synsem &
  [ LOCAL [ CAT [ HEAD adj &
                       [ MINORS.ALTMIN #altmin ],
                  VAL.SPR < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #altmin,
                                      CONT.HOOK.XARG #arg0 ] ] >,
                  POSTHD + ],
            CONT.HOOK.INDEX #arg0 ],
    MODIFD.LPERIPH bool ].

; Not marked for LEX

intrans_pred_adj_synsem := basic_adj_synsem & one_arg & isect_synsem &
                           norm_adj_synsem &
  [ LOCAL [ CAT [ HEAD adj &
                       [ PRD +,
                         MOD < [ --SIND #ind & non_expl-ind ] >,
                         MINORS.MIN adj_rel ],
                  VAL [ SPR < [ LOCAL [ CAT.HEAD n_or_adv &
                                           [ MINORS.ALTMIN abstr_meas_nom_rel ],
                                        CONT.HOOK.XARG #arg0 ] ] >,
                        COMPS < > ] ],
            CONT [ HOOK [ INDEX #arg0,
			  XARG #ind ],
                   RELS <! adj_relation !> ] ],
    LKEYS.KEYREL [ ARG0 #arg0,
                   ARG1 #ind ] ].

;;; We should have a trans_adj_attr_synsem too, for 'easy' and the likes ...

pred_adj_two_arg_synsem := pred_adj_synsem & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < [ PUNCT.LPUNCT no_punct ] >,
            CONT.HOOK.XARG #ind & basic_non_expl ],
    LKEYS.KEYREL.ARG1 #ind ].

basic_trans_adj_pred_synsem := pred_adj_two_arg_synsem &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
			    [ --MIN #cmin & selected_rel,
                              LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil,
				      CONT.HOOK [ INDEX #ind &
                                                        non_expl-ind ] ] ] > ],
    LKEYS [ KEYREL.ARG2 #ind,
            --COMPKEY #cmin ] ].

trans_adj_pred_synsem := basic_trans_adj_pred_synsem & adj_synsem.

; For adjectives like "accessible (by car)" which take a contentful PP compl.
trans_adj_pp_ind_synsem := pred_adj_two_arg_synsem & adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
			    [ --MIN #cmin & independent_rel,
                              LOCAL [ CAT basic_pp_cat & [ HEAD.PRD + ],
                                      CONJ cnil,
				      CONT.HOOK [ LTOP #ltop,
                                                  XARG #ind &
                                                        non_expl-ind ] ] ] >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS [ KEYREL.ARG2 #ind,
            --COMPKEY #cmin ] ].

irreg_trans_adj_pred_synsem := pred_adj_two_arg_synsem & adj_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem &
                          [ --MIN nom_rel & #cmin,
                            LOCAL [ CAT np_cat_acc_min,
                                    CONT.HOOK.INDEX non_expl-ind ] ] >,
    LKEYS.--COMPKEY #cmin ].

; 'worth the price'
aj_np_i_le := reg_adj_word &
  [ SYNSEM irreg_trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ --SIND #index & [ SORT entity ],
				       OPT - ] >,
		     CONT.RELS <! [ ARG2 #index ] !> ] ] ].

; "arr.": "Plane arr. 10:40."
aj_np_i-unsp_le := reg_adj_word &
  [ SYNSEM irreg_trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ --SIND #index,
				       OPT - ] >,
		     CONT.RELS <! [ ARG2 #index ] !> ] ] ].

; 'how much is it worth?'
aj_np_gap_le := reg_adj_word &
  [ SYNSEM adj_synsem &
	   [ LOCAL [ CAT [ HEAD.PRD +,
                           VAL.COMPS < > ],
		     CONT [ RELS <! [ ARG2 #index ] !>,
                            HCONS <! !> ] ],
             NONLOC [ SLASH 1-dlist &
                            <! [ CAT np_cat_acc_min &
                                     [ HEAD.MINORS.MIN reg_nom_rel ],
                                 CONT.HOOK.INDEX #index ] !>,
                      REL 0-dlist,
                      QUE 0-dlist ] ] ].

; e.g. 'able' - Can't use equi_intrans_lt since it specifies an arg12_rel, 
; which is incompatible with adj_rel.  

basic_adj_vpcomp_synsem := pred_adj_synsem & basic_inf_or_prp_intrans_subst &
                           basic_two_arg & norm_adj_lex_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN adj_rel,
                VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < [ NONLOC.SLASH 0-dlist ] >,
                              OPT -,
                              PUNCT.LPUNCT no_punct ] > ] ].

basic_adj_equi_synsem := basic_adj_vpcomp_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #subjind ] >,
            CONT.HOOK.XARG #subjind & non_expl ],
    LKEYS.KEYREL adj_arg12_relation &
                   [ ARG1 #subjind ] ].

reg_adj_equi_synsem := basic_adj_equi_synsem & basic_inf_intrans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT [ HOOK.LTOP #vhand ] ] >,
            CONT [ RELS <! adj_relation !>,
                   HCONS <! qeq & [ HARG #hand,
                                    LARG #vhand ] !> ] ],
    LKEYS.KEYREL.ARG2 handle & #hand ].

adj_vpcomp_prp_synsem := basic_adj_vpcomp_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.VFORM prp,
                                      CONT.HOOK.LTOP #hand ] ] >,
            CONT [ RELS <! relation !>,
                   HCONS <! qeq & [ HARG #chand,
                                    LARG #hand ] !> ] ],
    LKEYS.KEYREL.ARG2 handle & #chand ].

; 'done working'
adj_equi_prp_synsem := adj_vpcomp_prp_synsem & basic_adj_equi_synsem.

; 'it is worth reading that book'
adj_atrans_prp_synsem := adj_vpcomp_prp_synsem &
  [ LOCAL.CONT.HOOK.XARG it-ind,
    LKEYS.--+ARGIND it-ind ].

scoping_adj_synsem := norm_adj_lex_synsem & prd_synsem & isect_synsem &
  [ LOCAL.CAT [ HEAD.MINORS [ MIN adj_rel,
                              ALTMIN norm_rel ],
                VAL.KCMP [ PUNCT.LPUNCT no_punct ] ] ].

basic_adj_atrans_synsem := norm_adj_lex_synsem & prd_synsem & 
                           basic_pp_vp_subst & 
  [ LOCAL 
    [ CAT [ HEAD.MINORS [ MIN adj_rel,
                          ALTMIN norm_rel ],
            VAL [ COMPS < [ --MIN selected_rel & #cmin,
                            LOCAL.CONT.HOOK [ LTOP #ahand,
                                              INDEX #expr ],
                            OPT + ],
                          #comp &
                          [ LOCAL 
                             [ CAT.VAL.SUBJ < [ NONLOC.SLASH 0-dlist ] >,
                               CONT.HOOK.INDEX.E.TENSE no_tense ],
                            PUNCT.LPUNCT no_punct,
                            OPT - ], ...>,
                  KCMP #comp ] ] ],
    LKEYS [ KEYREL it_adj_arg12_relation &
                   [ LBL #ahand,
                     ARG2 #expr ],
            --COMPKEY #cmin ] ].

; DPF 30-aug-04 - Generalize to take either inf or prp VP complements, as in
; 'it is tough climbing that hill' or 'it is tough to climb that hill'
reg_adj_atrans_synsem := basic_adj_atrans_synsem & basic_three_arg &
                         nomod_adj_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
            CONT [ HOOK [ LTOP #ltop,
                          XARG it-ind ],
                   RELS <! relation !>,
                   HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ] ],
    LKEYS [ KEYREL [ LBL #ltop,
                     ARG1 handle & #arg ],
            --+ARGIND it-ind ] ].

; 'Kim is easy to please'

tough_adj_atrans_synsem := basic_adj_atrans_synsem & basic_pp_inf_subst &
                           scoping_adj_synsem & tough_three_arg &
                           norm_adj_synsem &
  [ LOCAL [ CAT.VAL [ COMPS < synsem,
                            [ LOCAL.CONT.HOOK.LTOP #ltop,
                              NONLOC.SLASH <! unexpr_local &
                                            [ CAT np_cat_acc_min &
                                                  [ HEAD.MOD < > ],
                                              CONT.HOOK.INDEX #slind ] !>]>,
                      SPR < [ LOCAL.CONT.HOOK.XARG #arg0 ] > ],
            CONT [ HOOK [ INDEX #arg0,
                          XARG #slind & ref-ind ],
                   RELS <! relation & [ ARG1 #arg ] !>,
                   HCONS <! qeq & [ HARG #arg, LARG #ltop ] !> ] ],
    LKEYS.--COMPKEY _for_p_sel_rel ].

; 'Kim is worth admiring.'
worth_adj_atrans_synsem := basic_inf_or_prp_intrans_subst & isect_synsem &
                           worth_two_arg & norm_adj_synsem &
                           basic_adj_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN adj_rel,
                  VAL [ COMPS < [ LOCAL [ CAT [ HEAD.VFORM prp,
                                                VAL.SUBJ 
                                                < [ NONLOC.SLASH 0-dlist ] > ],
                                          CONT.HOOK [ LTOP #ltop,
                                                      INDEX event &
                                                       [ E.TENSE no_tense,
                                                         SF prop-or-ques ] ] ],
                                  NONLOC.SLASH 
                                        <! unexpr_local &
                                         [ CAT np_cat_acc_min &
                                               [ HEAD.MOD < > ],
                                           CONT.HOOK.INDEX #slind ] !>,
                                  PUNCT.LPUNCT no_punct,
                                  OPT - ] >,
                        SPR < [ LOCAL.CONT.HOOK.XARG #event ] > ] ],
            CONT [ HOOK.XARG #slind & ref-ind,
                   RELS <! relation & #keyrel & [ ARG1 #mlbl,
                                                  ARG0 #event ] !>,
                   HCONS <! qeq & [ HARG #mlbl,
                                    LARG #ltop ] !> ] ],
    LKEYS.KEYREL #keyrel ].

;; DPF (9-Mar-99) It appears that there are no CP-taking adjectives which 
;; select for a 'like-CP' of the kind some verbs take (e.g. 'It sounds like
;; Kim will leave').  So we constrain the KCMP to be prop-or-ques_m_rel.
;; But there are adjectives (like 'doubtful, unclear, unsure') which can take 
;; a whether-CP, so we introduce a subtype of reg_adj_cp_synsem for those that 
;; only take a 'that-CP', and similarly for expletive-it subject-taking 
;; adjectives.

; 'uncertain': '?Kim is uncertain that Sandy left' 
;              'Kim is uncertain whether Sandy left' 
;              'It is uncertain that Sandy left'
;              'It is uncertain whether Sandy left'

basic_adj_cp_synsem := scoping_adj_synsem & basic_two_arg &
  [ LOCAL [ CAT.VAL [ COMPS < synsem & #comp &
                              [ LOCAL
                               [ CAT s_cat_v_c,
                                 CONJ cnil,
                                 CONT.HOOK.INDEX.SF prop-or-ques ] ] >,
                      KCMP #comp ],
	    CONT.RELS <! relation !> ] ].

adj_cp_fin_inf_synsem := basic_adj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_or_inf_v_c ] > ].

; 'unclear' '*Kim is unclear that/whether Sandy left'
;           'It is unclear that Sandy left'
;           'It is unclear whether Sandy left'
; DPF 10-jul-04 - FIX -- Why is the ARG1 constrainted to PNG.PN 3s?  
; Shouldn't that ARG1 be for an optional (experiencer) to-PP (not yet
; provided)?
; DPF 21-dec-05 - Removed CAT.HEAD comp to allow "it's obvious why we did it"

adj_atrans_cp_fin_inf_synsem := adj_cp_fin_inf_synsem & nomod_adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
            CONT [ HOOK.XARG it-ind,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ] ],
    LKEYS [ KEYREL it_adj_arg1_relation & [ ARG1 handle & #arg ],
            --+ARGIND it-ind ] ].

; 'imperative': 'it is imperative that you be here'
adj_atrans_bse_cp_synsem := basic_adj_cp_synsem & nomod_adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT s_cat_bse,
                                      CONT.HOOK.LTOP #chand ] ] >,
            CONT [ HOOK.XARG it-ind,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ] ],
    LKEYS [ KEYREL it_adj_arg1_relation & [ ARG1 handle & #arg ],
            --+ARGIND it-ind ] ].

reg_adj_cp_synsem := adj_cp_fin_inf_synsem & adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
	    CONT.HCONS <! qeq & [ HARG #arg, LARG #chand ] !> ],
    LKEYS.KEYREL [ ARG1 non_expl,
                   ARG2 handle & #arg ] ].

; 'afraid'  'Kim is afraid that Sandy left'
;           '*Kim is afraid whether Sandy left'
;           '*It is afraid that/whether Sandy left'
reg_adj_that_cp_synsem := reg_adj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    CONT.HOOK.INDEX.SF basic-prop ] ] > ].

; 'obvious' '*Kim is obvious that/whether Sandy left'
;           'It is obvious that Sandy left'
;           '*It is obvious whether Sandy left'
;   but cf. 'It is not obvious whether Sandy left' ***Needs fixing***

adj_atrans_that_cp_synsem := adj_atrans_cp_fin_inf_synsem &
  [ LOCAL.CAT.VAL.KCMP.LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    CONT.HOOK.INDEX.SF basic-prop ] ].

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking of "more many"
norm_adj_word := nonc-hm-nab & word &
  [ SYNSEM.LOCAL.CAT 
                 [ HEAD adj & [ MINORS.ALTMIN non_ellipt_rel ],
                   VAL.SPR < synsem &
                            [ --MIN more_or_very_deg_rel,
                              LOCAL.CAT.HS-LEX #hslex ] >,
                   HS-LEX #hslex ] ].

reg_adj_word := norm_adj_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT.HEAD [ MOD < [ --SIND #ind ] >,
                                MINORS.MIN adj_rel ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! adj_relation !> ] ],
             LKEYS.KEYREL.ARG1 #ind & non_event ] ].

reg_intrans_adj := reg_adj_word & 
  [ SYNSEM intrans_adj_synsem ].

aj_-_i_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

; For adjs like 'far' and 'early' which don't get used as depictives: 
; constrain NORM to be norm_rel (hack).
; DPF 27-jan-08 - But this prevents coordination with ordinary adjectives
; like "pleasant but far from ...".  So live with ambiguity of e.g.
; "Kim lived far from the city."

aj_-_i-ndpt_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

aj_-_prt_le := norm_adj_word &
  [ SYNSEM basic_adj_onearg_synsem &
              [ LOCAL [ CAT [ HEAD [ MOD < >,
                                     MINORS.MIN selected_rel & #min ],
                              POSTHD - ],
                        CONT [ HOOK.INDEX #ind,
                               RELS <! relation !> ] ],
                LKEYS.KEYREL [ PRED #min,
                               ARG2 #ind ] ] ].

; own: 'his own books'
aj_-_i-poss_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD 
     [ MINORS.MIN norm_adj_rel,
       PRD -,
       MOD < [ LOCAL.CAT.VAL.SPR 
                    < [ --MIN explicit_q_rel,
                        LOCAL.CAT.HEAD.POSS + ] > ] > ] ].

; Not bare adj-noun : 
;   *we arrived last weeks
;   'many chairs' - avoid spurious ambig with determiner 'many'

adj_intrans_notb_lexent := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD 
     [ MINORS.MIN norm_adj_rel,
       MOD < [ LOCAL.CAT.VAL.SPR < [ --MIN explicit_q_rel ] > ] > ] ].

aj_-_i-spn_le := adj_intrans_notb_lexent.
aj_-_i-spn-att_le := adj_intrans_notb_lexent &
  [ SYNSEM basic_attr_adj_synsem ].

; 'many/much' - allows QUE specifier ('how many')
; DPF 12-jul-06 - Added LPERIPH + to block e.g. "*the tall many chairs"
adj_attr_intrans_que_lexent := nonc-hm-nab & word &
  [ SYNSEM basic_attr_adj_synsem &
    [ LOCAL [ CAT [ HEAD compar_adj &
                         [ MOD < [ --SIND #ind ] >,
                           MINORS.MIN meas_adj_rel ],
                    VAL.SPR < synsem &
                              [ --MIN very_this_that_rel ]>],
              CONT [ HOOK.XARG #ind,
                     RELS <! adj_relation !> ] ],
      MODIFD.LPERIPH +,
      LKEYS.KEYREL [ ARG1 #ind & non_event ] ] ].

; 'many, few'
aj_-_i-many_le := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ AGR.PNG.PN 3p,
                                          CONT.HOOK.INDEX.IND + ] ] > ].

; 'much, little'
aj_-_i-much_le := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR [ PNG.PN 3s,
                                              DIV + ] ] > ].

; 'several, a few': exclude QUE specifier
; DPF 3-May-08 - Add MOD..NORM norm_rel to block "a few cat" from being
; left member of n-n-cmpnd.

aj_-_i-svrl_le := adj_attr_intrans_que_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ LOCAL [ AGR.PNG.PN 3p,
					    CAT.HEAD.MINORS [ ALTMIN udef_q_rel,
							      NORM norm_rel ],
					    CONT.HOOK.INDEX.IND + ] ] >,
	     NONLOC.QUE 0-dlist ] ].

; 'not many' - Can't easily do this compositionally since 'not + Adj' usually
; holds only for predicative adjectives: "kim is occasionally not clever" but
; "*The not clever consultant".  We now treat 'many' as sitting in the
; syntactic position of an attributive adjective, yet it can appear with a
; 'not' modifier.  So we'll treat it for now as a multi-word.
; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"

attr_adj_onearg_synsem := norm_adj_synsem & basic_one_arg & 
                          basic_adj_synsem & nonprd_synsem &
  [ LOCAL.CAT [ HEAD adj & [ MINORS.MIN norm_adj_rel ],
                POSTHD -,
                VAL [ SPR < synsem &
                              [ --MIN more_or_very_deg_rel,
                                LOCAL.CAT.HS-LEX #hslex ] >,
                      COMPS < > ],
                HS-LEX #hslex ],
    NONLOC.REL 0-dlist ].

aj_-_i-mneg_le := norm_adj_word &
  [ SYNSEM attr_adj_onearg_synsem &
           [ LOCAL [ CAT.HEAD.MOD 
                           < [ LOCAL 
                               [ CAT.VAL.SPR < [ LOCAL.CONT.HOOK.LTOP #lbl ] >,
                                 CONT.HOOK [ LTOP #albl,
                                             INDEX #ind ] ] ] >,
                     CONT [ HOOK [ LTOP #albl,
                                   XARG #ind ],
                            RELS <! [LBL #albl,
                                      PRED much-many_a_rel ], 
                                    [ LBL #lbl,
                                      PRED neg_rel,
                                      ARG0.E.TENSE no_tense ] !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL.ARG1 #ind & non_event ] ].

aj_-_i-att_le := reg_adj_word &
  [ SYNSEM basic_attr_adj_synsem ].

aj_-_i-att-nsp_le := nonc-hm-nab & word &
  [ SYNSEM attr_adj_synsem &
           [ LOCAL [ CAT [ HEAD adj,
                           VAL.SPEC < > ],
                     CONT.RELS <! adj_relation !> ] ] ].

aj_-_i-prd_le := norm_adj_word &
  [ SYNSEM intrans_pred_adj_synsem &
	      [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ] ].

; nuts: only complement of copula, or depictive.
aj_-_i-prd-nmd_le := norm_adj_word &
  [ SYNSEM intrans_pred_adj_synsem & 
              [ LOCAL.CAT [ HEAD [ MINORS.MIN norm_adj_rel,
                                   MOD < anti_synsem_min > ],
                            POSTHD + ] ] ].

; 'else': not even as depictive
aj_-_i-prd-ndpt_le := nonc-hm-nab & word &
  [ SYNSEM basic_adj_abstr_lex_synsem &
           [ LOCAL [ CAT [ HEAD adj &
                                [ PRD +,
                                  MINORS [ MIN norm_adj_rel,
					   NORM norm_rel ],
                                  MOD < anti_synsem_min > ],
                           VAL [ SPR < anti_synsem_min >,
                                 COMPS < > ],
                           POSTHD + ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #arg0,
                                   XARG #xarg ],
                            RELS <! #keyrel & adj_relation !> ] ],
             NONLOC non-local_none,
             MODIFD.LPERIPH bool,
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
                                   ARG0 #arg0,
                                   ARG1 #xarg & non_expl-ind ] ] ].

intrans_adj_oddsem := noncqrs-hm-nab & word &
  [ SYNSEM intrans_adj_synsem &
           [ LOCAL [ CAT [ POSTHD -,
                           HEAD.MINORS.MIN norm_adj_rel ],
                     CONT.HOOK [ LTOP #ltop,
                                 XARG #ind ] ],
             LKEYS.KEYREL [ LBL #ltop,
                            ARG1 #ind ] ] ].

; DPF 10-Jun-03 - Added MOD..HEAD no_head to prevent these from appearing as
; modifiers. They have to be MOD nonempty in order to combine with the copula, 
; and in fact MOD < synsem> to combine with base form "be".
aj_-_i-wthr_le := norm_adj_word &
  [ SYNSEM adj_onearg_lex_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < synsem & [ LOCAL.CAT.HEAD no_head ] >,
                                  MINORS.MIN expl_adj_rel ],
                           VAL.COMPS < > ],
                     CONT [ HOOK.XARG it-ind,
                            RELS <! relation !> ] ],
             NONLOC non-local_none,
             LKEYS.--+ARGIND it-ind ] ].

aj_pp_i-time_le := norm_adj_word &
  [ SYNSEM adj_twoarg_lex_synsem &
    [ LOCAL [ CAT [ HEAD [ MOD < synsem & [ LOCAL.CAT.HEAD no_head ] >,
                           MINORS.MIN expl_adj_rel ],
                    VAL.COMPS < [ --MIN selected_rel & #cmin,
                                  LOCAL [ CAT basic_pp_cat,
                                          CONT.HOOK.INDEX #ind &
                                              non_expl-ind,
                                          CONJ cnil ],
                                  NONLOC.SLASH 0-dlist,
                                  OPT - ] > ],
              CONT [ HOOK.XARG it-ind,
                     RELS <! relation & [ ARG1 #ind ] !> ] ],
      NONLOC non-local_none,
      LKEYS [ --COMPKEY #cmin,
              --+ARGIND it-ind ] ] ].

;; doctor's appointment
aj_-_i-cmpd_le := intrans_adj_oddsem &
  [ SYNSEM attr_adj_synsem &
	 [ LOCAL 
	   [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                INDEX #nind & non_expl-ind]] >,
             CONT [ HOOK.LTOP #hand,
		    RELS <! relation & [ ARG1 #aind ],
                            prep_notense_relation &
                            [ LBL #hand,
                              PRED compound_rel,
                              ARG1 #nind,
                              ARG2 #aind ] !> ] ] ] ].

;; {OPT +] is on reg_trans_adj and not on trans_adj_synsem because the 
;; comparison_lr uses trans_adj_synsem and requires OPT -. Same for semantics.

adj_trans_lexent := reg_adj_word &
  [ SYNSEM basic_trans_adj_pred_synsem &
	   [ LOCAL.CONT.RELS <! relation !> ] ].

aj_pp_i_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

aj_pp_i-prd_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD +,
                            MINORS.MIN norm_adj_rel ] ].

aj_pp_i-obl_le := adj_trans_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ] ].

aj_pp_i-ind_le := reg_adj_word &
  [ SYNSEM trans_adj_pp_ind_synsem &
           [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !> ] ] ] ].

adj_reg_equi_lexent := nonc-hm-nab &
  [ SYNSEM reg_adj_equi_synsem & 
           [ LOCAL.CAT [ HEAD adj,
                         VAL.SPR < synsem &
                                   [ --MIN more_or_very_deg_rel,
                                     LOCAL.CAT.HS-LEX #hslex ] >,
                         HS-LEX #hslex ] ] ].

aj_vp_i-seq_le := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

; For e.g. "supposed to"
aj_vp_i-seq-nmd_le := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    MOD < anti_synsem > ] ].

aj_vp_i-seq-prp_le := norm_adj_word &
  [ SYNSEM adj_equi_prp_synsem & [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ] ].

aj_pp-vp_i-it_le := norm_adj_word &
  [ SYNSEM reg_adj_atrans_synsem &
           [ LKEYS.--COMPKEY _for_p_sel_rel ] ].

; incumbent on X
aj_pp-vp_i-on-it_le := norm_adj_word &
  [ SYNSEM reg_adj_atrans_synsem &
           [ LKEYS.--COMPKEY _on_p_sel_rel ] ].

; 'it is worth reading that book.'
aj_vp_i-it-prp_le := norm_adj_word &
  [ SYNSEM adj_atrans_prp_synsem ].

reg_adj_atrans_cp_word := norm_adj_word &
  [ SYNSEM adj_atrans_cp_fin_inf_synsem ].

aj_pp-cp_i-it_le := reg_adj_atrans_cp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

aj_pp-cp_i-it-c_le := reg_adj_atrans_cp_word &
  [ SYNSEM adj_atrans_that_cp_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

aj_pp-vp_i-tgh_le := norm_adj_word &
  [ SYNSEM tough_adj_atrans_synsem ].

aj_vp_i-wrth_le := norm_adj_word &
  [ SYNSEM worth_adj_atrans_synsem ].

reg_adj_cp_word := norm_adj_word &
  [ SYNSEM reg_adj_cp_synsem &
	   [ LOCAL.CONT.HOOK.XARG #ind,
             LKEYS.KEYREL.ARG1 #ind ] ].

aj_cp_i_le := reg_adj_cp_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
		       VAL.COMPS < [ OPT - ] > ] ].

aj_cp_i-fin_le := reg_adj_cp_word &
  [ SYNSEM reg_adj_that_cp_synsem &
           [ LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
			 VAL.COMPS < [ OPT - ] > ] ] ].

aj_cp_i-bse_le := norm_adj_word &
  [ SYNSEM adj_atrans_bse_cp_synsem ].


; How is Sandy?  How does Tuesday look?
; We adopt the following second-order quantification semantics for these:
;    which (p, property(p), look_seem(proposition_to_property(adj(x),p)))
; where we exploit a type-shifting relation to change the proposition "adj(x)"
; into the associated property "the set of entities of which adj(x) is true",
; so the "which" operator can quantify over that property.
; DPF 14-Apr-00 - Changed SUBJ.CAT from nomp_cat_nom_min to nomp_cat_min
; since [CASE nom] conflicts with the CASE hack on pro_ss to prevent the
; latter from undergoing subject xxtraction (see ERB notes for pro_ss).

aj_-_i-wh_le := noncrs-m-nab & word &
  [ SYNSEM lex_synsem &
      [ LOCAL [ ARG-S < >,
		CAT [ POSTHD +,
		      HEAD adj & [ MOD < synsem &
					 [ LOCAL intersective_mod &
                                                 [ CAT nbar_cat_min,
                                                   CONJ cnil ],
                                           --SIND #ind & ref-ind ] >,
                                   MINORS [ MIN adj_abstract_rel,
					    ALTMIN no_rel ] ],
		      VAL [ SPR < >,
			    COMPS < > ] ],
		CONT [ HOOK [ LTOP #ltop,
                              INDEX #arg0,
                              XARG #ind ],
		       RELS <! [ LBL #ahand,
                                 PRED unspec_adj_rel,
				 ARG0 #arg0,
                                 ARG1 #ind ],
			        [ PRED which_q_rel,
                                  ARG0 #pind,
                                  RSTR #hand ],
			        [ LBL #hand,
                                  PRED property_rel,
                                  ARG0 #pind ],
			        prpstn_to_prop_relation & #keyrel &
			        [ LBL #ltop,
				  ARG1 handle & #ahand,
				  ARG2 #pind ] !>,
		       HCONS <! !> ] ],
        LKEYS.KEYREL #keyrel,
	NONLOC.QUE 1-dlist &
	           [ LIST < param > ] ] ].

; "cat-like"
aj_-_i-nspr_le := nonc-hm-nab & word &
  [ SYNSEM adj_synsem_n_spr ].

; DPF 03-Feb-06 - Changed analysis so INDEX is now the ARG0 of the comp_rel
; rather than of the basic predicate, to give a more plausible semantics
; for e.g. 'Dogs are 5 cm. taller than horses.'
; DPF 09-may-06 - But this is unnecessary, and creates an unwanted asymmetry
; with '5 cents more expensive', since in the first case the ARG0 of the
; proposition is the ARG0 of the comp_rel, but in the second it's the ARG0
; of the adjective's relation (since we use the head_compositional head-spr
; variant to build 'more expensive').  So let's go back to making the INDEX
; the ARG0 of the basic adjective relation, and still hook up the comp_rel's 
; argument as desired, but by referring to the adj's SPR value.

compar_superl_adj_word := nonc-hm-nab & word &
  [ SYNSEM abstr_lex_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < [ --SIND #ind & non_expl-ind ] >,
                           VAL.SPR < [ LOCAL.CONT.HOOK.XARG #altarg0 ] > ],
                     CONT [ HOOK [ XARG #ind,
                                   INDEX #arg0 ],
                            RELS.LIST < [ LBL #hand,
                                          ARG0 #arg0 & event,
                                          ARG1 #ind ],
                                        #altkeyrel &
                                        [ LBL #hand,
                                          ARG0 event & #altarg0,
                                          ARG1 #arg0 ], ... > ] ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

basic_compar_adj_word := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_synsem ].

; DPF 03-Feb-06 - Changed analysis so INDEX is now the ARG0 of the comp_rel
; rather than of the basic predicate, to give a more plausible semantics
; for e.g. 'Dogs are 5 cm. taller than horses.'

basic_adj_comp_lexent := basic_compar_adj_word &
  [ SYNSEM adj_unsp_ind_twoarg_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < synsem &
                                     [ --MIN #cmin,
                                       LOCAL [ CAT basic_pp_cat,
                                               CONJ cnil,
                                               CONT.HOOK [ LTOP #ltop,
                                                           INDEX #ind ] ] ] >,
                     CONT.HOOK [ LTOP #ltop,
                                 XARG #xarg ] ],
             LKEYS [ KEYREL.ARG1 #xarg,
                     ALTKEYREL.ARG2 #ind,
                     --COMPKEY #cmin ] ] ].

adj_comp_lexent := basic_adj_comp_lexent &
  [ SYNSEM.LKEYS [ --COMPKEY _than_p_compar_rel,
                   ALTKEYREL.PRED comp_rel ] ].

aj_pp_i-cmp_le := adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN comp_rel ],
                           VAL.SPR < [ --MIN much_deg_rel ] > ],
                     CONT.RELS <! relation, relation !> ],
             MODIFD.LPERIPH bool ] ].

; 'more'
aj_pp_i-more_le := adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD compar_adj &
                              [ MOD < [ LOCAL [ AGR #agr & [ DIV + ],
                                                CAT.HEAD.MINORS.ALTMIN 
                                                        implicit_q_rel ],
					--SIND #ind ] > ],
                           VAL [ SPR < [ --MIN card_or_much_rel,
                                         LOCAL.CAT.VAL.COMPS < > ] >,
				 COMPS < [ LOCAL [ CONT.HOOK.XARG #ind,
						   AGR #agr ] ] >,
                                 SPEC *synlist* ],
                           POSTHD - ],
                     CONT.RELS <! relation, relation !> ],
             MODIFD.LPERIPH na ] ].

; 'one more'
aj_pp_i-onemore_le := adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD intadj1 &
                              [ MOD < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN 
                                                        implicit_q_rel,
                                                CONT.HOOK [ LTOP #lbl,
                                                            INDEX #index & 
                                                              [ PNG.PN 3s ] ],
                                                AGR [ PNG.PN 3s,
                                                      DIV - ] ],
                                        MODIFD.LPERIPH bool ] > ],
                           POSTHD - ],
                     CONT.RELS <! relation & 
                                  [ LBL #lbl,
                                    ARG1 #index ], 
                                  relation,
                                  integer_relation &
                                  [ PRED card_rel,
                                    LBL #lbl,
                                    ARG1 #index,
                                    CARG "1" ] !> ],
             MODIFD.LPERIPH na ] ].

; For 'different from/than', 'similar_to'
; (Takes both 'very' and 'much' specifiers.)
aj_pp_i-cmp-dif_le := basic_adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj,
                           VAL.SPR < [ --MIN much_or_very_deg_rel ] > ],
                     CONT.RELS <! relation, relation !> ],
             MODIFD.LPERIPH bool,
             LKEYS.ALTKEYREL.PRED comp_rel ] ].

; For 'same as' - Note "*Kim is same", "*A same car arrived"
aj_pp_i-cmp-sme_le := basic_adj_comp_lexent &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD superl_adj &
                         [ PRD -,
                           MOD < [ LOCAL.CAT.VAL.SPR 
                                       < [ --MIN def_or_demon_q_rel ] > ] > ],
                    VAL.SPR < [ --MIN much_deg_rel ] > ],
              CONT.RELS <! relation, relation !> ],
      MODIFD.LPERIPH bool,
      LKEYS [ ALTKEYREL.PRED comp_equal_rel,
              --COMPKEY _as_p_comp_rel ] ] ].

aj_pp_i-cmp-wthr_le := nonc-hm-nab & word &
  [ SYNSEM norm_adj_lex_synsem &
        [ LOCAL [ CAT [ HEAD [ MOD < >,
                               MINORS.ALTMIN comp_rel ],
                        VAL [ SPR < [ --MIN much_deg_rel ]>,
                              COMPS < > ] ],
                  CONT [ HOOK [ LTOP #hand,
                                XARG it-ind ],
                         RELS <! [ LBL #hand ],
                               #altkeyrel &
                               [ LBL #hand,
                                 ARG0 event ] !> ] ],
          LKEYS [ ALTKEYREL #altkeyrel & [ PRED comp_rel ],
                  --+ARGIND it-ind ] ] ].

aj_pp_i-cmp-oth_le := basic_compar_adj_word &
  [ SYNSEM trans_adj_pred_synsem &
	   [ LOCAL [ CAT [ HEAD adj,
                           VAL [ COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                             INDEX #index ]]>, 
                                 SPR < [ --MIN much_deg_rel ] > ] ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! relation, relation !> ] ],
             LKEYS [ KEYREL.ARG2 #index,
                     ALTKEYREL.PRED comp_rel ] ] ].

; DPF 14-jul-06 - Added LPERIPH + to block spurious analysis of "next 
; tallest" as adj-head; only want spr-head analysis.  But this isn't quite
; right - make LPERIPH na.
; DPF 06-sept-07 - Require MOD nbar to have an explicit determiner, to 
; block e.g. "biggest dogs barked."
; DPF 15-jan-08 - Re: 14-jul-06 But this blocks "the two tallest trees",
; so remove, and find alternative to block "next tallest".  FIX...

adj_superl_lexent := compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
    [ LOCAL [ CAT.VAL.SPR < [ --MIN ord_or_very_rel ] >,
              CONT.RELS <! relation, relation !> ],
      LKEYS.ALTKEYREL.PRED superl_rel ] ].
                         
aj_-_i-sup_le := adj_superl_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD superl_adj & [ MINORS.ALTMIN superl_rel,
                                         MOD < [ LOCAL.CAT.HEAD.MINORS.ALTMIN
                                                   explicit_q_rel ] > ] ].

; 'most' - Doesn't allow an explicit quantifier, except for "the"
; DPF 24-may-06 - Added MOD..NORM norm_rel to prevent 'most cat' from
; being left member of compound as in 'most cat rugs'. (We can't require that
; what 'most' modifies must be inflected, as we might wish.)
aj_-_i-most_le := adj_superl_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD compar_or_superl_adj &
                          [ MOD < [ LOCAL [ CAT.HEAD.MINORS [ ALTMIN 
                                                            impl_or_the_q_rel,
                                                              NORM norm_rel ],
                                            AGR.DIV + ] ] > ] ].

superl_adj_synsem := basic_adj_abstr_lex_synsem & one_arg &
  [ LOCAL.CONT.RELS <! #keyrel, relation !>,
    MODIFD.LPERIPH bool,
    LKEYS.KEYREL #keyrel ].

adj_atrans_superl_lexent := nonc-hm-nab &
  [ SYNSEM norm_adj_lex_synsem &
       [ LOCAL [ CAT [ HEAD [ MOD < >,
                              MINORS.ALTMIN superl_rel ],
                       VAL [ SPR < [ --MIN ord_or_very_rel ] >,
                             COMPS < > ] ],
                 CONT [ HOOK [ LTOP #hand,
                               XARG it-ind ],
                        RELS <! [ LBL #hand ],
                              #altkeyrel &
                              [ LBL #hand ] !> ] ],
         LKEYS [ ALTKEYREL #altkeyrel & [ PRED superl_rel ],
                 --+ARGIND it-ind ] ] ].

aj_-_i-sup-it_le := adj_atrans_superl_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

; Titles like 'mister', 'professor' which modify proper names
; DPF 5-Apr-01 - Changed MOD..MIN to abstr_named_rel from named_rel, to
; include integers, as in "number ten"
; Removed LPERIPH na - it blocked "order fivedigitersatz" since the num-np
; rule cannot accept numerals modified by adjectives or noun-noun compounds -
; we want to block the NP "Toshiba 2000" but allow the NP "order (number) 2000"
; DPF 12-Nov-03 - Removed MOD.MODIFD notmod_or_rmod since it prevented
; "number 222" where "222" is MODIFD lmod.  We'll see what that constraint
; was trying to block.
; DPF 03-may-04 - Added LPERIPH + to distinguish "number five" from "five",
; so the former can appear in appositives but not the latter.
; DPF 01-sep-05 - Changed MOD..MIN from gen_named_rel to named_np_or_num_rel
; to block "my summer house" as post_title.
; DPF 08-sep-06 - Changed SPR < anti_synsem_min > to synsem with unexpr SPR
; to allow Adj-N titles as in "federal highway 66".

basic_title_synsem := basic_zero_arg & count_noun_synsem &
  [ LOCAL [ CAT [ HEAD ttl &
                  [ MOD < [ LOCAL intersective_mod &
                                  [ CAT nbar_cat_min &
                                    [ HEAD.MINORS [ MIN named_np_or_num_rel & 
                                                        non_temp_nom_rel,
                                                    ALTMIN proper_q_rel ],
                                      VAL.SPR < [ OPT - ] > ],
                                    CONJ cnil,
                                    CONT.HOOK [ INDEX #nind,
                                                XARG #nhand ] ],
                            NONLOC non-local_none,
                            PUNCT.RPUNCT comma_or_rbc_or_clause_or_no_punct ]>,
                    MINORS [ MIN generic_entity_rel,
                             ALTMIN no_rel ] ],
                  VAL [ SUBJ < >,
                        SPR < unexpressed &
                              [ --MIN explicit_q_rel ] >,
                        COMPS < > ] ],
            AGR #ind,
	    CONT [ HOOK [ LTOP #nhand,
			  INDEX #ind,
                          XARG #khand ],
		   RELS.LIST 
			< #keyrel & 
                          [ LBL #khand,
                            ARG0 #ind ],
                          [ PRED udef_q_rel,
                            ARG0 #ind,
                            RSTR #rhand ],
                          [ LBL #nhand,
                            PRED compound_name_rel,
                            ARG1 #nind,
                            ARG2 #ind ], ... >,
                   HCONS.LIST < qeq &
                           [ HARG #rhand,
                             LARG #khand ], ... > ] ],
    MODIFD notmod & [ LPERIPH + ],
    LKEYS.KEYREL #keyrel ].

title_synsem := basic_title_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.AGR.PNG.PN #pn ] >,
            CONT [ HOOK.INDEX.PNG.PN #pn,
		   RELS <! relation, relation, relation !>,
		   HCONS <! qeq !> ] ] ].

;title_pre_synsem := title_synsem & lex_synsem &
;  [ LOCAL.CAT.POSTHD - ].
;
; DPF 31-jul-06 - Changed to be uninflected, in order to allow examples like
; 'chapters two and three'.
;n_-_tt_le := noncqrs-m & word &
;  [ INFLECTD -,
;    SYNSEM title_pre_synsem ].
;
;n_-_tt-rbst_le := noncqrs-m & word &
;  [ INFLECTD -,
;    SYNSEM title_pre_synsem,
;    GENRE robust ].
;
; 'ms.'
;n_-_tt-abb_le := noncqrs-m & word &
;  [ INFLECTD -,
;    SYNSEM title_pre_synsem &
;	   [ LKEYS.KEYREL.PRED title_rel ] ].
; 'number', 'age', 'aged'
;
;n_-_tt-num_le := noncqrs-m & word &
;  [ INFLECTD -,
;    SYNSEM title_pre_synsem &
;     [ LOCAL.CAT.HEAD.MOD < [ --MIN integer_rel ] > ] ].

; DPF 7-mar-05 - Added MOD..MODIFD notmod to remove spurious analysis of e.g.
; '[Abrams in Berlin] river rises.'
n_-_tt-post_le := noncqrs-hm & word &
  [ INFLECTD -,
    SYNSEM title_synsem &
	   [ LOCAL.CAT [ POSTHD +,
                         HEAD [ MOD < [ MODIFD notmod ] >,
				PRD - ] ] ] ].

n_-_tt-post-pl_le := noncqrs-hm & word &
  [ INFLECTD -,
    SYNSEM basic_title_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
                            HEAD.MOD < [ MODIFD notmod ] > ],
                     AGR.PNG.PN 3p,
		     CONT [ RELS <! relation, relation, relation !>,
			    HCONS <! qeq !> ] ] ] ].

; For 'high mountain lodges' until a better solution emerges ...
n_-_tt-post-mwe_le := noncqrs-hm & word &
  [ INFLECTD -,
    SYNSEM basic_title_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
			   HEAD.MOD < [ MODIFD notmod ] > ],
		     CONT [ RELS <! [ LBL #khand,
				      ARG0 #kind ],
				    relation, relation,
				    #altkeyrel & 
				    [ LBL #lhand,
 				      ARG0 #lind ],
				    [ PRED udef_q_rel,
				      ARG0 #lind,
				      RSTR #lrstr ],
				    [ LBL #khand,
				      PRED compound_rel,
				      ARG1 #kind,
				      ARG2 #lind ],
				    #alt2keyrel &
				    [ LBL #khand,
				      ARG0.E [ TENSE untensed, 
					       ASPECT no_aspect ],
				      ARG1 #kind ] !>,
			    HCONS <! qeq, qeq & [ HARG #lrstr,
						  LARG #lhand ] !> ] ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PREPOSITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Most prepositions can be modifiers.  If they act as a modifier, we'll assume
; they have no subject (leaving for some distinct analysis Carl's "A unicorn
; at the helm, the ship sailed into the horse latitudes."  This lets us use a
; single attribute, ARG, for the index of the phrase modified, or for the
; index of the subject of the PP, in a predicative construction.

; Prepositions also have a distinguished role ARG2 which has as value the
; index of the object of the preposition.  We could introduce distinct role
; names for each preposition (e.g. "ON" for on_rel, "IN" for in-rel) but this
; would complicate the definition of the prep_synsem type, since it needs to
; know the role name to which it assigns the object's index.

; An ARG0 attribute is needed for PPs (and other substs used predicatively)
; occurring as complements of the copula as in "the meeting is on Tuesday",
; but on this analysis not postnominally.  This ARG0 role used to be
; introduced in a separate support_rel, supplied by the copula, but is now
; introduced directly in the relation introduced by the predicate (prep or
; adj or verb).

; Prepositions, like adjectives and participial verbs, can have either
; predicative or nonpredicative synsems, so each ordinary preposition
; (actually the PP headed by the P) can unify with either a pred. or non-pred.
; constraint, which resolves the underspecification.  One assumption here is 
; that there are no contexts which are underspecified for the PRD feature 
; for PPs.

; N.B. The RELS value of basic_prep_synsem cannot be a singleton list, since
; adverbs like "when" inherit this synsem, and add additional rels lexically.

; Here we only amalgamate non-local features from the complements, not the
; subject.  This is so we don't get two identical gaps in an example like "Who
; does kim think is under the bed?".  On the other hand, binding theory
; suggests that the subjects of prepositions really are on the ARG-S list.

; DPF (14-Mar-99) Constrained prepositions to not allow pied-piping in
; free relative constructions, where the QUE value is an index rather than
; a handle.

; DPF 18-Nov-04 - FIX - make HEAD be prep rather than n_or_p: no longer any
; visible motive for n_or_p.

basic_prep_synsem := canonical_synsem & 
  [ LOCAL.CAT [ HEAD basic_prep,
                VAL.SUBJ < > ] ].

; DPF 18-Apr-01 - Removed ident. of ALTMIN with COMPS..MIN, since it prevents
; selection in v-np-pp verbs for a PP which is temporal or locative: want to
; block "When did kim put the book", but allow "Where did Kim put the book"
; We'll see where this constraint was being used.
; DPF 28-jun-07 - Made contentful preps PRD + so they take the right kind
; of measure-NP specifiers: "miles under the ice" but not "mile under the ice"

prep_synsem := basic_prep_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD prep & 
                       [ MINORS.MIN #min,
                         TAM #tam ],
                  VAL.COMPS < synsem &
                              [ LOCAL.CAT.NEGPOL #negpol,
				PUNCT.LPUNCT pair_or_no_punct ], ... >,
                  POSTHD +,
		  NEGPOL #negpol ],
	    CONT [ HOOK.INDEX.E #tam,
                   RELS.LIST < #keyrel, ... > ] ],
    LKEYS.KEYREL #keyrel & [ PRED #min ] ].

; For predicative Ps and PPs like "when" which have a (non-expletive) NP subj

prep_p_synsem := basic_prep_synsem &
  [ LOCAL [ CAT.VAL.COMPS #comps,
	    ARG-S #comps ] ].

;; DPF 17-Jul-01 - Restricted SPR to be very_deg_rel, to avoid e.g. "much 
;; for Kim".  
;; DPF 16-Nov-01 - But "very for Kim" is also bad", and note "very much for
;; Kim" is good, but not "very very for Kim".  Seems reminiscent of contrast
;; between "*I want much to stay" and "I want very much to stay".  Don't know
;; how to get this, but in any case fixed SPR.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so PPs can
;; coordinate with VPs (which are necessarily SPR anti_synsem_min).
;; DPF 27-Apr-03 - Note that making SPR be much_deg_rel means that for now we
;; have to have two degree specifier lex-entries for the just_only_deg ones,
;; since we want them to work for positive adjectives, and cannot underspecify
;; much_deg vs. very_deg yet.  Once we move to PRED for relation names, we
;; should be able to get rid of those duplicate deg-spec entries.
;; DPF 18-jul-06 - Removed SPR..MODIFD notmod_or_lmod since this interacted
;; badly with degree-specs identifying their MODIFD value with their SPEC's,
;; blocking examples like "directly down under Berlin".  Believe this was here
;; to block e.g. (((ten meters) (in Paris)) (under Berlin)), but we can now
;; instead block this in rule pumping measure-NPs to degree-specs.

prep_with_spr_synsem := basic_prep_synsem & abstr_lex_synsem &
  [ LOCAL 
    [ CAT [ HEAD.MINORS.MIN #min,
            VAL.SPR < synsem_min & 
                      [ LOCAL
                        [ CAT [ HEAD n_or_adv,
                                VAL [ COMPS *olist*,
                                      SPEC < [ LOCAL.CAT.VAL.COMPS < > ] > ]]],
                        NONLOC.QUE 0-dlist ] > ] ],
    LKEYS.KEYREL.PRED #min ].

; Ps and PPs that can be modifiers.
; Block PP modification of infinitival "to" - spurious ambiguity.
; Constrain MOD < [ --SIND > to be non_expl, for fragments like 
; "perhaps in a week"
; DPF 10-Sept-01 - Removed MOD..MIN relation, since it prevents modification
; of no_copula VPs, as in "rain likely tomorrow"
; DPF 19-Feb-03 - Added link between HOOK.INDEX and KEY.ARG1 - don't know why
; this went missing (example: "Can kim arrive on tuesday after four").
; DPF 11-Nov-03 - Removed reentrancy of LTOP and MOD..LTOP since this is being
; supplied by the head-modifier constructions generally, as required by the
; solution to the "apparently unsolvable problem" Kasper scoping examples.
; One extra benefit of this division of labor is that we now also get the 
; right scoping for "On Tuesday who arrives?" where the PP does not want to 
; share the handle with the filler-head phrase that it modifies.
; DPF 12-Mar-04 - Added MOD..SPEC < anti_synsem_min > to block modification by
; PPs of measure-NPs.  Though this prevents "Five kilometers on snow is
; difficult", so we should reconsider.
; DPF 19-nov-04 - Okay, we reconsidered, and removed this constraint, in order
; to provide an analysis for "five kilometers on artificial snow is difficult".
; The apparently spurious additional ambiguity seems to be manageable.
; DPF 11-mar-05 - Finally decided to take the plunge and allow PPs to modify
; other PPs (along with Nbars, VPs, and APs), so we can get rid of the
; spurious ambiguity for "Kim will arrive on Tuesday":  also constrain
; MOD to AUX -.  Note that this analysis assumes that elided VPs are not
; marked for AUX: 'Kim can on Tuesdays'.

basic_mod_n_or_vp_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ --MIN independent_rel,
                               LOCAL intersective_mod &
                                     [ CAT [ HEAD subst & 
                                                  [ AUX - ],
                                             VAL [ SPR < synsem_min, ... >,
                                                   COMPS < > ],
                                             MC #mc ],
				       CONJ cnil ],
                               --SIND #ind & basic_non_expl ] >,
                  MC #mc,
                  POSTHD + ],
            CONT [ HOOK [ LTOP #hand,
                          INDEX #event,
                          XARG #ind ] ] ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event,
                   ARG1 #ind ] ].

prep_p_mod_synsem := prep_p_synsem & basic_mod_n_or_vp_synsem & 
                     prep_with_spr_synsem.

prep_prd_or_nonprd_synsem := prep_synsem & prep_p_mod_synsem.

; Strict transitive prepositions which can be either predicative or non-pred:

basic_one_arg_prep_synsem := prep_prd_or_nonprd_synsem & basic_one_arg &
  [ LOCAL.CONT.RELS.LIST < prep_relation, ... > ].

one_arg_prep_synsem := basic_one_arg_prep_synsem &
  [ LOCAL.CAT.VAL.SPR < [ LOCAL 
                          [ CAT [ HEAD.MINORS [ MIN much_deg_rel,
                                                ALTMIN abstr_meas_nom_rel],
                                  VAL [ SPR *olist*,
                                        SPEC < synsem >,
                                        COMPS < > ] ],
                            CONT.HOOK [ LTOP #ltop,
                                        XARG #arg0 ] ] ] >,
    LKEYS.KEYREL [ LBL #ltop,
                   ARG0 #arg0 ] ].

basic_trans_prep_synsem := basic_one_arg_prep_synsem &
  [ LOCAL.CAT.VAL [ COMPS < [ --SIND #ind ] >,
                    SPR < [ LOCAL.CAT.VAL [ SPEC < synsem >,
                                            COMPS < > ] ] > ],
    LKEYS.KEYREL.ARG2 #ind & non_expl ].

; DPF 21-Jun-01 - Changed COMPS..INDEX from ref-ind to non_expl-ind so preps
; can be particles.
; DPF 8-Aug-01 - Removed identification of LTOP and COMPS..LTOP - unwanted.

norm_trans_prep_synsem := basic_trans_prep_synsem &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL [ COMPS < [ --SIND non_expl-ind,
                                  --MIN #cmin,
                                  NONLOC.QUE.LIST *paramlist* ] >,
                      SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                             [ MIN just_only_notvery_deg_rel,
                                               ALTMIN abstr_meas_nom_rel ],
                                            VAL.SPR *olist* ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #arg0 ] ] ] > ] ],
            CONT [ RELS <! prep_relation &
                           [ LBL #ltop,
                             ARG0 #arg0 ] !>,
		   HCONS <! !> ] ],
    LKEYS.--COMPKEY #cmin ].

; DPF 27-sept-04 - Added TAM.TENSE tense to enable blocking of coordination
; of ordinary PPs with nbar-complement PPs like "per unit" or "a person"

trans_prep_synsem := norm_trans_prep_synsem &
  [ LOCAL.CAT.HEAD.TAM.TENSE tense ].

ditrans_prep_synsem := prep_prd_or_nonprd_synsem & basic_two_arg &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL [ SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                 [ MIN much_deg_rel,
                                                   ALTMIN abstr_meas_nom_rel ],
                                            VAL [ SPR *olist*,
                                                  SPEC < synsem >,
                                                  COMPS < > ] ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #arg0 ] ] ] >,
                      COMPS < [ --MIN #cmin,
                                NONLOC.QUE.LIST *paramlist*,
				LOCAL.CONT.HOOK.LTOP #ltop,
                                --SIND #objind ], 
                              [ --MIN #ocmin,
                                LOCAL [ CAT.HEAD.TAM [ TENSE nontense,
						       ASPECT no_aspect ],
					CONT.HOOK.LTOP #ltop ] ] > ] ],
	    CONT.RELS.LIST < prep_relation &
                             [ ARG2 #objind & non_expl,
                               LBL #ltop,
                               ARG0 #arg0 ], ... > ],
    LKEYS [ --COMPKEY #cmin,
            --OCOMPKEY #ocmin ] ].

basic_lex_pp_synsem := prep_p_synsem & abstr_lex_synsem &
  [ LOCAL [ ARG-S < >,
	    CAT [ VAL.COMPS < >,
		  NEGPOL - ],
            CONT.HCONS <! !> ],
    LEX - ].

; Try excluding lexical PPs modifing PPs, to avoid spurious ambiguity
; DPF 21-apr-08 - Added ALTMIN no_rel to let us exclude these from v_mod
; rule, to avoid spurious ambiguity for e.g. "We brought up the cat"
;
norm_lex_pp_synsem := basic_lex_pp_synsem & basic_mod_n_or_vp_synsem &
  [ LOCAL [ CAT.HEAD [ MOD < synsem & [ MODIFD notmod_or_rmod,
                                        LOCAL.CAT.HEAD n_or_v_or_a ] >,
                       MINORS [ MIN #min,
				ALTMIN no_rel ],
                       PRD + ],
            CONT.RELS.LIST.FIRST #keyrel & [ PRED #min ] ],
    LKEYS.KEYREL #keyrel & [ ARG0 event,
                             ARG1 individual ] ].

; DPF 26-aug-07 - Restrict NORM to prevent these from appearing in
; v_mod constructions as in "moving on the river"
; DPF 20-apr-08 - Re 26-aug-07: But this also blocks ordinary copula-be+PP
; so remove, and revisit.  FIX??
;
lex_pp_synsem := norm_lex_pp_synsem & prep_with_spr_synsem &
  [ LOCAL.CAT.VAL.SPR < [ --MIN much_deg_rel,
              	          LOCAL [ CAT.VAL [ SPR *olist*,
                                            COMPS < >,
                                            SPEC < synsem > ],
                                  CONT.HOOK [ LTOP #ltop,
                                              XARG #arg0 ] ] ] >,
    LKEYS.KEYREL [ LBL #ltop,
                   ARG0 #arg0 ] ].

; Ordinary prepositions:

; Moved [ OPT - ] specification to subtypes, to allow "the day before" where
; the complement is missing.
; DPF (9-Mar-99) Made basic_prep_word not inherit from nonmsg, since it has
; its MSG identified with that of its modifiee (via the head_modifier rule)
; and that modifiee will sometimes have a non-empty message, as in
; "Is kim happy in Berlin"
; DPF 19-Nov-01 - Removed COMPS..MSG no_msg, since now want to get "this
; depends on whether kim arrives" and "I'm interested in who you met"

basic_prep_word := nonc-h-nab &
  [ INFLECTD +,
    SYNSEM.PUNCT no_punctuation_min ].

norm_prep_word := basic_prep_word &
  [ SYNSEM norm_trans_prep_synsem &
	 [ LOCAL.CAT.VAL.COMPS < synsem & 
                                 [ LOCAL [ CAT nomp_cat_nonnom_min,
                                           CONT.HOOK.INDEX index,
                                           CONJ cnil ] ] > ] ].

; Changed ref-ind constraint to non_expl-ind so prep's can be used as particles
; DPF 20-Oct-02 - Made SORT of ARG1 and first COMP be identified, to avoid
; spurious ambiguity for e.g. "ten to five"
; DPF 27-Oct-02 - But this runs afoul of the facts (1) that preps identify 
; their own index with that of their MOD's index (since they're intersective),
; (which is also their ARG's index) and (2) that predicative ones identify 
; their XARG index with their ARG's index.  And anyway, "ten to five" doesn't
; use the preposition, but rather the n_x_to_y lexical entry.

prep_word := norm_prep_word &
  [ SYNSEM trans_prep_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ --SIND non_expl-ind ] > ] ].

; DPF 02-Apr-02 - For now, block measure-phrase specifiers of ordinary 
; prepositions -- too many spurious parses.
; DPF 17-Jul-03 - But we're losing too many good sentences, such as "Kim
; arrived a week after me" so removed SPR..LEX +.

p_np_i_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

; DPF 24-aug-04 - For prepositions like "as" that exclude verbal gerund 
; complements (to avoid spurious ambiguity)
; DPF 29-sept-05 - Also make PRD - to prevent e.g. "*Kim arrived from as 
; Abrams"
; DPF 12-nov-05 - But this prevents these PPs from ever being modifiers,
; so instead tighten constraints on complements of e.g. 'from' to exclude
; these.
; DPF 11-sep-07 - Added SPR < anti_synsem_min > to avoid spurious reading
; for "(as) well as .."

p_np_i-nger_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < anti_synsem_min >,
                           COMPS < [ OPT -,
                                     LOCAL.CAT.HEAD noun ] > ] ].

basic_p_nmod_lexent := norm_prep_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun_or_nomger ] >,
                       VAL.COMPS < [ OPT -,
                                     --SIND non_expl-ind ] > ] ].

; DPF 25-oct-05 - Collapsed this type with the following - need PRD + on PPs
; in order to force measure-NPs to be inflected: "ten feet under them" not
; "*ten foot under them".  (was only used for 'about')
;p_nmod_prd_le := basic_p_nmod_lexent & 
;  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].

p_nmod_lexent := basic_p_nmod_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.PRD +,
             NONLOC.SLASH 0-dlist ] ].


p_np_i-nm_le := p_nmod_lexent.

; 'than' of "kim had more of them than sandy"
; 13-mar-06 - But we also need this, for now, to get "more to offer than Kim".
; So we'll live with the spurious ambiguity for the simple case.
p_np_i-than_le := p_nmod_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD 
                      < [ --MIN part_nom_rel ] >,
             LKEYS.KEYREL.ARG0.E.TENSE nontense ] ].


; For "to", to avoid so much ambiguity for e.g. "ten to twelve"
; DPF 3-nov-03 - Changed MOD..MIN from non_temp_nom_rel to norm_nom_rel to
; prevent attachment to proper names.
; DPF 21-dec-05 - Changed COMPS..MIN from non_temp_nonpro_rel to 
; non_temp_nom_rel, since we want 'the road to it is open'
; DPF 30-sept-06 - Re: 3-nov-03 - But this blocks eg. "Berlin to the north
; is cooler."  FIX.
; DPF 10-oct-06 - Okay, made named_np_rel be subtype of this MIN, so now
; get attachment to proper names, and will live with added ambiguity.
; DPF 16-oct-06 - Replaced MOD..MIN norm_nom_or_place_rel with old and better
; non_temp_nom_rel to include partitives as modifiees: "two to Paris"

p_np_i-nm-no-tm_le := p_nmod_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ --MIN non_temp_nom_rel,
                                      LOCAL.CAT.HEAD basic_noun ] >,
                         VAL.COMPS < [ --MIN non_temp_nom_rel ] > ],
                   CONT.HOOK.INDEX.E.TENSE no_tense ] ].

; possessive 'of'
; DPF 28-mar-05 - Removed ARG0..TENSE nontense since this prevents e.g.
; 'Pollock is of what nationality?'  Also removed PRD - for same reason.
; DPF 17-apr-05 - Block SPR from being realized, to avoid spurious analyis
; of e.g. 'bits of rope'
; DPF 18-jul-07 - But this also blocks "mainly of Kim's", so let's instead
; restrict the SPR to being a degree adv.
; DPF 24-jul-07 - Still want to avoid having PPs modify these of-PPs, so
; add hack [AUX +] here.  FIX someday.
; DPF 18-jul-07 - While it was tempting to make the COMP be basic_nonpro_rel,
; to contrast "cats of mine" vs. "*cats of me", this also blocks ordinary
; constructions like "the intensity of it" "the presence of us (in the room)".
; So relax constraint to nom_rel, and wait for more insight about how to
; block "the cats of us".
; DPF 15-apr-08 - Re 24-jul-07: Note that this blocks "This paper is of high
; quality today".  But the extra ambiguity is still a pain, so leave hack in
; for now.

p_np_i-nm-poss_le := basic_p_nmod_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD [ MOD < [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD det ] > ] >,
		     AUX + ],
	      VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
		    COMPS < synsem &
			    [ --MIN nom_rel,
			      LOCAL.CAT.VAL.SPEC < anti_synsem_min > ]>]],
	CONT.HOOK.XARG ref-ind ],
      NONLOC.SLASH 0-dlist ] ].

; 'of mine', 'of Kim's'
p_np_i-poss-gen_le := basic_prep_word &
  [ SYNSEM one_arg_prep_synsem &
     [ LOCAL 
        [ CAT [ HEAD [ PRD -,
                       AUX +,
                       TAM.TENSE tense,
                       MOD < [ LOCAL [ CAT [ HEAD noun,
                                             VAL.SPR 
                                                  < [ LOCAL.CAT.HEAD det ] > ],
                                       CONT.HOOK.LTOP #ltop ] ] > ],
                VAL.COMPS < synsem &
                            [ LOCAL [ CAT [ HEAD det &
                                               [ MINORS [ MIN implicit_q_rel,
                                                          ALTMIN poss_rel ] ],
                                            VAL [ SPR *olist*,
                                                  SPEC < anti_synsem_min > ] ],
                                      CONT.HOOK.INDEX #cind,
                                      CONJ cnil ],
                              OPT - ] > ],
          CONT [ HOOK.LTOP #ltop,
                 RELS <! prep_relation &
                       [ LBL #ltop,
                         PRED poss_rel,
                         ARG0 [ E [ TENSE no_tense,
                                    ASPECT no_aspect ],
                                --TPC - ],
                         ARG2 #cind ] !>,
                 HCONS <! !> ] ],
       NONLOC.SLASH 0-dlist ] ].

; e.g. since
p_np_i-ngap_le := prep_word & 
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             NONLOC.SLASH 0-dlist ] ].

; For particles
; DPF 31-may-07 - Removed COMPS..INDEX non_expl since we want to allow
; 'We saw to it that Kim left' where "to it" needs expletive "it".

gen_p_prtcl_lexent := basic_prep_word &
  [ SYNSEM gen_prep_nomod_synsem &
     [ LOCAL [ CAT [ HEAD [ MINORS [ MIN selected_prep_rel,
                                     ALTMIN #min ],
                            TAM [ TENSE untensed,
                                  ASPECT no_aspect ],
                            PRD - ],
                     VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                           COMPS < synsem &
                                   [ --MIN #min,
                                     LOCAL [ CAT [ VAL [ SUBJ *olist*,
                                                         SPR *olist*,
                                                         COMPS < > ],
                                                   MC na_or_- ],
                                             CONJ cnil ],
                                     OPT - ] > ] ],
               CONT [ RELS <! !>,
                      HCONS <! !> ] ] ] ].

basic_p_prtcl_lexent := gen_p_prtcl_lexent &
  [ SYNSEM basic_prep_nomod_synsem ].

; DPF 06-may-04 - Changed COMPS..CASE from acc to non_nom to allow obliq
; complement NPs, including WH-S NPs, as in "that depends on who stays"
; DPF 29-may-07 - FIX semantics for "Kim's belief only in Abrams" where
; the LTOP and XARG of "only" need to get bound to something reasonable.

p_prtcl_lexent := basic_p_prtcl_lexent &
  [ SYNSEM.LOCAL 
           [ CAT.VAL [ SPR < [ LOCAL.CONT.HOOK.LTOP #sprtop ] >,
                       COMPS < synsem &
                             [ LOCAL [ CAT [ HEAD nominal &
                                                  [ POSS -,
                                                    MOD < >,
                                                    CASE non_nom ],
                                             VAL.COMPS < > ],
                                       CONT.HOOK #hook ] ] > ],
             AGR #index,
             CONT.HOOK #hook & [ LTOP #sprtop,
				 INDEX #index ] ] ].

; Disallow measure-NPs for most particle preps (except 'of')
norm_p_prtcl_lexent := p_prtcl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SPEC < anti_synsem_min > ] >].

p_np_ptcl_le := norm_p_prtcl_lexent.

; DPF - This is a place-holder solution for equative and comparative phrases,
; until we work out an adequate semantics for e.g. "taller than Abrams" or
; "as soon as convenient"
; DPF 31-mar-05 COMPS..MOD *anti_list* excludes subord-preps as in spurious
; analysis for "(as soon) as possible"
; DPF 13-nov-05 - But this also prevents lexical PPs like "before" which
; make MOD be synsem.  So let's use NORM norm_non_num_rel instead, 
; DPF 15-jul-07 - Removed COMPS..CASE non_nom, since we want "taller than he"
; in formal written English. 

; For VP,AP,PP complements, where need to bind LTOP
p_noslash_prtcl_lexent := basic_p_prtcl_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT.VAL.COMPS < synsem &
                        [ LOCAL [ CAT [ HEAD 
                                        [ MINORS [ MIN norm_rel,
                                                 NORM norm_non_num_rel ] ],
                                        VAL [ SUBJ *anti_list*,
                                              COMPS < > ] ],
                                  CONT.HOOK.INDEX #index ] ] >,
               CONT.HOOK.INDEX #index ],
             NONLOC.SLASH 0-dlist ] ].

; For VP,AP,PP complements, where need to bind LTOP
; 30-aug-05 - Can't have PRD + on COMPS since this would block
; 'as soon as Kim arrives'
; 14-nov-05 - But to block "than in" we'll try constraining the COMPS..MOD
; to be an *anti_list* which excludes lexical PPs.

p_prd_ptcl-ngap_le := p_noslash_prtcl_lexent &
  [ SYNSEM.LOCAL 
           [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD v_or_a_or_p &
                                                [ MINORS [ MIN independent_rel,
							   ALTMIN role_rel ],
                                                  MOD *anti_list* ],
                                       CONT.HOOK [ LTOP #ltop,
                                                   INDEX.SF prop-or-ques ] ],
                               NONLOC.REL 0-dlist ] >,
             CONT.HOOK.LTOP #ltop ] ].

; For NP complements, where cannot bind LTOP (given that for some lexical NPs
; like 'anyone' or 'that', the LTOP exposes the nominal relation's LBL, in
; order to support intersective post-nom modification, e.g. 'anyone in Paris')
; DPF 23-jun-08 - With improved treatment of lexical NPs, can now bind LTOP
; as we should.

p_np_ptcl-ngap_le := p_noslash_prtcl_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD nominal,
					     CONT.HOOK.LTOP #ltop ] ] >,
		   CONT.HOOK.LTOP #ltop ] ].

p_np_ptcl-of_le := p_prtcl_lexent.

; 'Kim hired more consultants than Abrams did'
p_cp_ptcl-ell_le := basic_p_prtcl_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT.VAL.COMPS < synsem &
                        [ LOCAL [ CAT [ HEAD verb & 
                                             [ MINORS.ALTMIN ellipsis_rel ],
                                        VAL [ SUBJ *anti_list*,
                                              COMPS < > ],
                                        MC - ],
                                  CONT.HOOK.LTOP #ltop ],
                          NONLOC non-local_none ] >,
        CONT.HOOK.INDEX #ltop ],
      NONLOC.SLASH 0-dlist ] ].

p_cp_ptcl-gap_le := gen_p_prtcl_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT.VAL.COMPS < synsem &
                        [ LOCAL [ CAT [ HEAD verb & 
                                             [ MINORS.ALTMIN non_ellipt_rel ],
                                        VAL [ SUBJ *anti_list*,
                                              COMPS < > ],
                                        MC - ],
                                  CONT.HOOK.LTOP #ltop ],
                          NONLOC.SLASH <! [ CAT.HEAD noun,
					    CONT.HOOK.INDEX #ind,
					    AGR #slagr ] !> ] >,
        CONT.HOOK [ INDEX #ltop,
		    XARG #ind ],
	AGR #slagr ],
      NONLOC.SLASH 0-dlist ] ].

; DPF 8-Jan-02 - Added constraint on SPR to exclude measure-NP specifiers, as
; in "*There are a book in the office"
p_reg_lexent := prep_word &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LEX + ] >,
                           COMPS < [ --MIN non_temp_nom_rel,
                                     OPT - ] > ] ].


; DPF 25-oct-05 - Make [PRD +] to force measure-NP specs to be inflected:
; "ten feet under the ground" not "*ten foot under the ground".  
p_np_i-reg_le := p_reg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].

; DPF 02-Apr-02 - blocks e.g. "an office by Sandy" as in "kim was shown an 
; office by Sandy".  Hack, since it also blocks "Kim lives right by the river"
; DPF 31-oct-03 - Changed this constraint from SPR < unexpressed > to 
; restriction excluding measure NPs which are now [HEAD noun].
; DPF 18-mar-05 - Further constrained to locative sense which does not take
; gerundive complements, and introduce separate "by" for "by means of", to
; enable blocking of unwanted coordinations such as "from here and by arriving"
; And further constrained to prevent stranding, though this may be too strong:
; "?Which library is that tree by?"

p_np_i-dgsp_le := p_reg_lexent &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                           COMPS < canonical_synsem &
                                   [ --SIND.SORT entity ] > ] ].

; For "from" of "ten weeks from now" where in AmEng we block "he'll be here
; from now".

p_np_i-oblsp_le := p_temp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < expressed_synsem >,
                             COMPS < [ OPT -,
                                       LEX + ] > ],
             LKEYS.--COMPKEY temp_abstr_rel ] ].

; 'by hiring Abrams'
p_np_i-ger_le := p_reg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a ] >,
                       VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                             COMPS < canonical_synsem &
                                     [ LOCAL.CAT.HEAD supnoun,
                                       --SIND.SORT nom-event ] > ] ] ].

; DPF 24-Oct-01 - Added identity of AGR..PN, DIV and NP comp's AGR..PN, DIV to
; support agreement in partitives, as in "none of the rice arrives" but "*none
; of the rice arrive"
; DPF 1-Mar-02 - Removed TAM.TENSE no_tense since this blocked predicative 
; of-PP as in "this picture is of Sandy".  Also replaced
; [MOD..MIN never_unify_rel] with never_unify_event_rel since it blocked the 
; no-copula "a chance of rain".
; DPF 17-Apr-03 - Identified prep's ALTMIN with its complement's MIN, to
; preserve visibility of the embedded NP's MIN for NP's like
; 'both of the days' where this can still serve as an adverbial modifier,
; while 'both of the chairs' cannot.
; DPF 2-Sept-04 - Restricted MOD..INDEX to ref-ind, to block "a bit of rain"
; as a no_copula construction (contra 1-Mar-02 view - now treat those as
; NP fragments).

; DPF 31-May-02 - Constrain to only modify nominals.
p_np_i-nsp-ngap_le := prep_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD basic_noun ] >,
                       VAL [ SPR < unexpressed >,
                             COMPS < [ OPT -,
                                       NONLOC.SLASH 0-dlist ] > ] ] ].

p_temp_lexent :=  basic_prep_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT [ HEAD.MINORS.MIN temp_loc_rel,
                       VAL.COMPS < synsem & 
                                 [ LOCAL [ CAT [ HEAD nominal &
                                                      [ CASE non_nom,
                                                        POSS - ],
                                                 VAL [ SUBJ *olist*,
                                                       SPR *olist*,
                                                       COMPS < > ],
                                                 MC na ],
                                           CONJ cnil ],
                                   OPT - ] > ] ] ].

p_np_i-tmp_le :< p_temp_lexent.

p_np_i-tmp-vm_le := p_temp_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_p ] >,
                       VAL.SPR < [ LOCAL.CAT.HEAD adv ] > ] ].

; This looks tempting, but prevents e.g. "We camped two kilometers before the
; bridge."
#|
; 'before'
p_temp_spr_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ --SIND.SORT time ] >,
                           COMPS < [ OPT - ] > ] ].
|#

; Used e.g. for "from", as in "from under the table"
; DPF 6-Apr-01 - Also used for "worth" as in "ten dollars worth of food"
; DPF 01-sept-04 - Removed PRD + since it prevents "Kim put it back in the box"
; DPF 29-sept-05 - Added COMPS..PRD + to block depictives as complements:
; "*Kim arrived from happy."
; DPF 21-may-06 - Changed MOD n_or_v to MOD n_or_v_or_a

p_ppcomp_lexent := basic_prep_word &
  [ SYNSEM one_arg_prep_synsem &
	 [ LOCAL [ CAT [ HEAD [ PRD +,
                                TAM.TENSE tense,
                                MOD < [ LOCAL.CAT 
                                         [ HEAD n_or_v_or_a,
                                           VAL.SPR < synsem_min > ] ] > ],
                         VAL.COMPS < synsem &
				   [ --MIN #min,
                                     LOCAL [ CAT [ HEAD prep &
                                                        [ PRD + ],
						   VAL [ SPR *olist*,
							 COMPS < > ] ],
					     CONJ cnil ] ] > ],
                   CONT [ HOOK.XARG non_expl,
                          RELS <! prep_relation !>,
                          HCONS <! !> ] ],
           NONLOC.SLASH 0-dlist,
           LKEYS.--COMPKEY #min ] ].

p_pp_i-coprd_le := p_ppcomp_lexent &
  [ SYNSEM one_arg_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD.PRD +,
              VAL.COMPS < [ OPT -,
                            --MIN loc_abstr_rel,
                            LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #ind ] ],
                            NONLOC.REL 0-dlist,
                            --SIND event ] > ],
        CONT.HOOK [ LTOP #ltop,
                    INDEX #ind ] ] ] ].

; 'from now on', maybe 'from two to four'
p_ditrans_lexent := nons-m &
  [ SYNSEM ditrans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL [ CONJ cnil ],
                                            OPT - ], 
                                 synsem & [ LOCAL.CAT [ HEAD.PRD -,
                                                        MC na ],
                                            NONLOC.QUE.LIST *paramlist*,
                                            OPT -,
                                            PUNCT.LPUNCT no_punct ] >,
                   CONT.HOOK.LTOP #ltop ],
           LKEYS [ KEYREL.LBL #ltop,
                   --COMPKEY #cmin,
                   --+COMPKEY #cmin,
                   --OCOMPKEY #ocmin,
                   --+OCOMPKEY #ocmin ] ] ].

p_np-ptcl_i_le := p_ditrans_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT nomp_cat_acc_min,
                                             CONT.HOOK.INDEX index ] ],
                                   [ LOCAL [ CAT.VAL.COMPS < synsem >,
                                             CONT.HOOK.LTOP #ltop ],
                                     NONLOC non-local_none,
                                     LEX + ] >,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! relation !>,
                          HCONS <! !> ] ] ].
                                                 
p_ditrans_from_to_lexent := p_ditrans_lexent &
  [ SYNSEM 
    [ LOCAL [ CAT.VAL.COMPS < [ --SIND #arg2 & [ SORT #sort ],
                                LOCAL.CAT.HEAD.MINORS 
                                       [ MIN nonpro_rel,
                                         ALTMIN quant_rel ] ],
                              [ --MIN selected_rel,
                                LOCAL [ CAT.VAL.COMPS < >,
                                        CONT.HOOK.INDEX #arg3 &
                                            non_expl-ind & 
                                            [ SORT #sort ] ] ]> ],
      LKEYS.KEYREL [ ARG2 #arg2,
                     ARG3 #arg3 ] ] ].

p_np-pp_i-frm-to_le := p_ditrans_from_to_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ CAT nomp_cat_acc_min,
                                               CONT.HOOK.INDEX index ],
                   CONT [ RELS <! relation !>,
                          HCONS <! !> ] ] ].

p_nb-pp_i-frm-to_le := p_ditrans_from_to_lexent &
  [ SYNSEM.LOCAL
           [ CAT.VAL.COMPS
                      < abstr_lex_synsem &
                        [ OPT -,
                          --MIN non_temp_nbar_rel,
                          LOCAL [ CAT [ HEAD noun,
                                        VAL [ SPR < synsem &
                                                    [ LOCAL.CAT.HEAD det,
                                                      NONLOC [ SLASH 0-dlist,
                                                               QUE 0-dlist ]]>,
                                              COMPS < > ] ],
                                  CONT.HOOK [ LTOP #nhand,
                                              INDEX #arg ] ],
                          NONLOC.SLASH 0-dlist ],
                        [ --MIN _to_p_nbar_rel,
                          LOCAL.CONT.HOOK [ LTOP #n2hand,
                                            INDEX #n2ind,
                                            XARG #event ] ]>,
             CONT [ HOOK.INDEX #event,
                    RELS <! relation,
                          [ PRED udef_q_rel,
                            ARG0 #arg,
                            RSTR #rhand ],
                          [ PRED udef_q_rel,
                            ARG0 #n2ind,
                            RSTR #r2hand ]!>,
                    HCONS <! qeq & [ HARG #rhand,
                                     LARG #nhand ],
                             qeq & [ HARG #r2hand,
                                     LARG #n2hand ] !> ] ] ].

; DPF 13-Mar-02 - Changed PRD - to PRD +: "the response was as expected"
; DPF 2-Jul-02 - Added MOD..HEAD verb to prevent spurious analysis for e.g.
; "Abrams sees Browne as being a competent manager."
; DPF 8-Jun-03 - Split this "as" into two lexical entries, one with an
; independent rel, taking verbal (PRD +) complements and able to serve as a 
; modifier phrase or copular complement, and one with a selected_rel
; taking adj-or-prep complements, but MOD < >. and nonprd.

p_vp_i_le := basic_prep_word &
  [ SYNSEM basic_trans_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ PRD +,
                     MOD < [ LOCAL.CAT.HEAD verb ] > ],
              VAL [ COMPS < synsem &
                            [ LOCAL [ CAT prd_cat & [ HEAD verb ],
                                      CONJ cnil,
                                      CONT.HOOK #hook & [ LTOP #ltop,
                                                          INDEX #ind ] ],
                              NONLOC [ SLASH 0-dlist,
                                       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT - ] >,
                    SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                [ MIN much_deg_rel,
                                                  ALTMIN abstr_meas_nom_rel ],
                                          VAL.SPR *olist* ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #ind ] ] ] > ] ],
        CONT [ HOOK #hook,
               RELS <! prep_relation & [ LBL #ltop,
                                         ARG0 #ind ] !>,
               HCONS <! !> ] ] ] ].

p_prd_ptcl_le := basic_prep_word &
  [ SYNSEM basic_prep_nomod_synsem &
           [ LOCAL 
             [ CAT [ HEAD.PRD -,
                     VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                           COMPS < synsem &
                                   [ LOCAL [ CAT prd_cat,
                                             CONJ cnil,
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #ind,
                                                         XARG #xarg ] ],
                                     NONLOC [ SLASH 0-dlist,
                                              QUE 0-dlist,
                                              REL 0-dlist ],
                                     OPT - ] > ] ],
               CONT [ HOOK [ LTOP #ltop,
                             INDEX #ind,
                             XARG #xarg ],
                      RELS <! !>,
                      HCONS <! !> ] ] ] ].


; when: "use of this device when shaving/angry/in Berlin is ..."
p_prd_i_le := basic_prep_word &
  [ SYNSEM basic_trans_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ PRD +,
                     MOD < [ LOCAL.CAT.HEAD noun ] > ],
              VAL [ COMPS < synsem &
                            [ LOCAL [ CAT prd_cat,
                                      CONJ cnil,
                                      CONT.HOOK.LTOP #ltop ],
                              NONLOC [ SLASH 0-dlist,
                                       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT - ] >,
                    SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                [ MIN much_deg_rel,
                                                  ALTMIN abstr_meas_nom_rel ],
                                          VAL.SPR *olist* ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #arg0 ] ] ] > ] ],
        CONT [ HOOK [ LTOP #ltop,
                      INDEX #arg0 ],
               RELS <! prep_relation !>,
               HCONS <! !> ] ] ] ].

; Prepositions that don't modify nominals - e.g, 'until'

; DPF 25-oct-05 - Make [PRD +] to force measure-NP specs to be inflected:
; "ten feet under the ground" not "*ten foot under the ground".  

p_no_nmod_lexent := prep_word &
  [ SYNSEM.LOCAL.CAT [ HEAD [ MOD < [ LOCAL.CAT.HEAD v_or_a_or_p ] >,
                              PRD + ],
                       VAL.COMPS < [ OPT - ] > ] ].

; DPF 1-May-03 - Additionally, block phrasal degree specifiers to avoid
; spurious reading for "Abrams showed an office to Browne".
; DPF 26-sep-07 - Added [CASE obliq] to allow us to block these from the
; it-cleft copula as in "It was to Kim that we ran".
;
; 'into'
p_np_i-nnm_le := p_no_nmod_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE obliq,
		       VAL.SPR < [ LEX + ] > ] ].

; Additionally block pronominal NP complements - e.g. 'as'
p_np_i-nnm-npro_le := p_no_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN nonpro_rel ] > ].

; For colon lexical entry
p_np_i-nnm-ngap_le := p_no_nmod_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MOD < synsem >,
				CASE obliq ],
                         VAL.SPR < anti_synsem_min > ],
             NONLOC.SLASH 0-dlist,
             LKEYS.KEYREL prep_notense_relation ] ].

; "Case-marking" prepositions, which cannot be modifiers
; and (let's assume) also cannot be modified, so stipulate [ SUBJ < > ].
;
; DPF 10-Jun-99 - But they can take specifiers: "Kim fell nearly to the bottom"

gen_prep_nomod_synsem := lex_synsem & prep_with_spr_synsem &
                           prep_p_synsem &
  [ LOCAL [ CAT [ HEAD prep & [ MOD < > ],
		  VAL [ SPR < [ OPT +,
                                LOCAL [ CAT [ HEAD adv,
                                              VAL [ SPR *olist*,
						    SPEC < synsem >,
                                                    COMPS < > ] ],
                                        CONT.HOOK [ LTOP #ltop,
                                                    XARG #arg0 ] ] ] >,
                        COMPS < synsem & 
				[ OPT -,
                                  --MIN #cmin ] > ] ] ],
    LKEYS [ KEYREL basic_arg12_relation & [ PRED prep_rel,
                                            LBL #ltop,
                                            ARG0 #arg0 ],
            --COMPKEY #cmin ] ].

basic_prep_nomod_synsem := gen_prep_nomod_synsem & basic_one_arg.

prep_nomod_synsem := basic_prep_nomod_synsem &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL [ SPR < [ --MIN much_deg_rel ] >,
                        COMPS < [ --SIND #ind,
                                  NONLOC [ QUE.LIST *paramlist*,
                                           SLASH 0-dlist ] ] > ] ],
	    CONT [ HOOK [ INDEX #arg0,
                          XARG #pind ],
                   RELS <! prep_relation & #keyrel !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL #keyrel &
                 [ ARG0 #arg0,
                   ARG1 #pind,
                   ARG2 #ind ] ].

; Lexical PPs

basic_pp_word := noncqrs-hm-nab & word &
  [ SYNSEM lex_pp_synsem &
    [ LOCAL [ CAT.VAL.SPR < [ OPT +,
                              LOCAL.CAT.HEAD n_or_adv &
                                  [ MINORS [ MIN much_deg_rel,
                                             ALTMIN abstr_meas_nom_rel ] ] ] >,
	      CONT [ RELS <! arg01_only_relation !>,
                     HCONS <! !> ] ] ] ].

pp_word := basic_pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD prep & [ PRD + ] ].

; 'astray'
pp_-_i_le := pp_word.

; 'about'
pp_-_i-nmb_le := basic_pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD prep_nonmob &
                          [ MOD < [ LOCAL.CAT.HEAD v_or_a_or_p,
                                    MODIFD.RPERIPH - ] > ] ].

; DPF 25-mar-05 - Added hack [CASE obliq] to prevent particle PPs from
; fronting.
;
pp_-_ptcl_le := noncqrs-hm-nab & word &
  [ SYNSEM basic_lex_pp_synsem &
           [ LOCAL [ CAT [ HEAD prep &
                                [ MINORS.MIN selected_rel & #min,
                                  MOD < >,
                                  PRD -,
                                  CASE obliq ],
                           VAL.SPR < > ],
                     CONT [ HOOK.XARG #xarg,
                            RELS <! !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL [ PRED #min,
                            ARG1 #xarg ] ] ].

; 'right away'
pp_-_i-vm_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a ] > ].

; 'each'
pp_-_i-nm_le := pp_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ --MIN basic_nom_rel ] >,
                   CONT.HOOK.INDEX.E.TENSE no_tense ] ].

; below, down, ...
pp_dir_lexent := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ --MIN nom_nbar_rel,
                                    LOCAL.CAT.HEAD noun ] >,
                            MINORS.MIN dir_rel ] ].

pp_-_i-dir_le := pp_dir_lexent.

; DPF 14-nov-05 - To avoid rampant ambiguity for now, make variant for "in"
; which restricts modification to nouns with SORT place - a hack. FIX.
; Also FIX name, since -nnm elsewhere signifies no-nmod.
pp_-_i-dir-nnm_le := basic_pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD prep &
                          [ MOD < [ --MIN nom_nbar_rel,
                                    LOCAL [ CAT.HEAD noun,
                                            CONT.HOOK.INDEX.SORT place ] ] >,
                            MINORS.MIN dir_rel ] ].
; 'after'
pp_-_i-nm-tmp_le := pp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ --MIN basic_nom_rel,
                                    LOCAL.CAT.VAL.SPR 
                                                 < [ LOCAL.CAT.HEAD det ] >,
                                    --SIND ref-ind & [ SORT time ] ] >,
             LKEYS.KEYREL.ARG0.E.TENSE nontense ] ].

; Postpositions
pp_-_i-po_lexent := noncqrs-hm-nab & word &
  [ SYNSEM norm_lex_pp_synsem &
	   [ LOCAL [ CAT [ HEAD prep & [ PRD + ],
                           VAL.SPR < synsem_min & 
                                     [ LOCAL
                                        [ CAT [ HEAD noun,
                                                VAL [ SPR *olist*,
                                                      COMPS < >,
                                                      SPCMPS < > ] ],
                                          CONT.HOOK.INDEX #ind ],
                                       NONLOC.QUE 0-dlist,
                                       OPT - ] >,
                           POSTHD + ],
                     CONT [ RELS <! relation &
                                  [ ARG2 #ind ] !>,
                            HCONS <! !> ] ] ] ].

; For 'ago', constrain SPR to be only temporal NPs.
pp_-_i-po-tm_le := pp_-_i-po_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --SIND.SORT time ] > ].

; For e.g. 'Kim's objections notwithstanding, we won't stay.'
pp_-_i-po_le := pp_-_i-po_lexent.

; DPF 10-sept-07 - Restrict MOD to RPERIPH - to avoid attaching after 
; depictives as in "things we are concerned about"
pp_-_i-nnm_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a_or_p,
                                  MODIFD.RPERIPH - ] > ].

; Prepositions with lexically idiosyncratic complements:

; DPF 08-Jan-01 - was built for "as of", but don't remember why, since
; it seems "as of" is an ordinary prep.
;p_idiom_le := basic_prep_word &
;  [ SYNSEM trans_prep_synsem &
;	   [ LOCAL [ CAT.VAL.COMPS < [ OPT - ], ... > ] ] ].

; DPF 29-Nov-02 - Stipulate HOOK.XARG nothing to prevent these from appearing
; as complements of predicative 'be'.
; DPF 4-Feb-03 - But the HOOK of a modifier is now the HOOK of the hadj phrase,
; and a VP (with or without a PP modifier) has to present its XARG as the 
; index of its SUBJ, so it can't be 'nothing' - must be ref-ind.  And anyway,
; by-PPs can be complements of the copula: "The best route is by car".  So
; instead constrain subtype for e.g. "per" with incompatible value for TENSE.
; DPF 4-Feb-03 - Changed COMPS type from lex_synsem to abstr_lex_synsem to
; admit compound nouns, as in "I paid by credit card".

p_nbar_comp_lexent := basic_prep_word &
  [ SYNSEM [ LOCAL 
             [ CAT [ VAL [ SPR < [ NONLOC.SLASH 0-dlist ] >,
                           COMPS < [ OPT -,
                                     --MIN gen_nom_nbar_rel,
                                     LOCAL 
                                      [ CAT [ HEAD noun,
                                              VAL [ SPR < synsem &
                                                   [ LOCAL.CAT.HEAD det,
                                                     NONLOC non-local_none ] >,
                                                    COMPS < > ] ],
                                        AGR.DIV - ],
                                     NONLOC.SLASH 0-dlist ] > ],
                     POSTHD + ] ],
             LKEYS [ KEYREL prep_relation & [ ARG2 #arg ],
                     ALTKEYREL [ PRED udef_q_rel,
                                 ARG0 #arg ] ] ] ].

; DPF 9-jul-04 - But this blocks e.g. "per day", so make this constraint be
; specific to the lex entry for "by".
; DPF 27-aug-04 - Changed COMPS..MODIFD notmod to notmod_or_lmod to allow
; 'by private car' or 'by large Zodiac raft'.

basic_p_nbar_comp_spr_lexent := p_nbar_comp_lexent &
  [ SYNSEM basic_one_arg_prep_synsem &
    [ LOCAL [ CAT 
              [ HEAD.PRD +,
                VAL.COMPS < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN implicit_q_rel,
                                      CONT.HOOK.LTOP #nhand ],
                              MODIFD notmod_or_lmod,
                              --SIND #ind ] > ],
              CONT [ RELS.LIST < #keyrel, #altkeyrel, ... >,
                     HCONS.LIST < qeq & [ HARG #rhand,
                                          LARG #nhand ], ... > ] ],
      LKEYS [ KEYREL #keyrel & [ ARG2 #ind & non_expl ] ,
              ALTKEYREL #altkeyrel & [ RSTR #rhand ] ] ] ].

p_nbar_comp_spr_lexent := basic_p_nbar_comp_spr_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
              VAL [ SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                               [ MIN much_deg_rel,
                                                 ALTMIN abstr_meas_nom_rel ],
                                          VAL [ SPR *olist*,
                                                SPEC < synsem >,
                                                COMPS < > ] ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #arg0 ] ] ] >,
                    COMPS < [ LOCAL.CAT [ HEAD.MINORS.MIN #ckey,
                                          VAL.SPR 
                                            < [ LOCAL.AGR.DIV - ] > ] ] > ] ],
        CONT [ RELS <! relation, relation !>,
               HCONS <! qeq !> ] ],
      LKEYS [ KEYREL [ LBL #ltop,
                       ARG0 #arg0 ],
              --COMPKEY #ckey,
              --+COMPKEY #ckey ] ] ].

; DPF 12-Apr-03 - Added COMP..MIN non_temp_nom_rel to block e.g. means reading
; for "by three o'clock'
; DPF 21-Mar-07 - Since this also blocks "sorted by date", instead constrain
; the SPR of the nbar-complement to be HEAD det, which will still block this
; analysis for "by three o'clock".  If sustainable, then lose the type
; p_nb_i-per_le.  FIX.

p_nbar_comp_spr_lexcomp_lexent := p_nbar_comp_spr_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < abstr_lex_synsem > ].

p_nb_i_le := p_nbar_comp_spr_lexcomp_lexent.
p_nb_i-per_le := p_nbar_comp_spr_lexcomp_lexent.

; For preps like "as" which can take phrasal nbar complements
p_nb_i-phr_le := p_nbar_comp_spr_lexent.

; 'step by step'
p_nb_i-oblspr_le := basic_p_nbar_comp_spr_lexent &
  [ SYNSEM.LOCAL 
     [ CAT.VAL [ SPR < [ OPT -,
                         --MIN gen_nom_nbar_rel,
                         LEX +,
                         LOCAL [ AGR.PNG.PN unsp_pernum,
                                 CAT [ VAL [ SPCMPS < >,
                                             COMPS < > ],
                                       POSTHD + ],
                                 CONT.HOOK [ LTOP #sltop,
                                             INDEX #arg ] ],
                         LKEYS.KEYREL.PRED #pred ] >,
                 COMPS < abstr_lex_synsem &
                         [ LEX +,
                           LKEYS.KEYREL.PRED #pred ] > ],
       CONT [ RELS <! relation, relation, [ PRED udef_q_rel,
                                            ARG0 #arg,
                                            RSTR #rstr ] !>,
              HCONS <! qeq, qeq & [ HARG #rstr,
                                    LARG #sltop ] !> ] ] ].

; DPF 24-Jun-01 - Added SUBJ <anti_synsem_min> to block 'per' reading: "Abrams
; is a manager"
; DPF 29-Nov-02 - But [E.TENSE no_tense] should be enough
; DPF 5-Sep-03 - Added SPR < anti_synsem_min > to prevent spurious readings 
; like for "three times a day"
; DPF 27-Sep-03 - no_tense won't be enough to block this as copula complement
; since all PPs are no_tense.  Instead use new value 'nontense'.

p_nbar_comp_nospr_lexent := p_nbar_comp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < anti_synsem_min >,
                             COMPS < abstr_lex_synsem  > ],
             LKEYS.KEYREL.ARG0.E [ TENSE nontense,
                                   ASPECT no_aspect ] ] ].

; Added MOD..ALTMIN no_rel to prevent "a person" from modifying e.g. gerunds.
; 10-Nov-01 - But now gerunds are unmarked for ALTMIN, since they need to be
; able to appear as left members of noun-noun compounds.  
; DPF 3-Jul-02 - Added [MOD..LEX +] to block spurious analyses as for 
; e.g. "every manager who has a bookcase"
; DPF 30-Aug-01 - Added COMPS <[MODIFD notmod]> to block "a ten percent
; probability" with a_per.
; DPF 16-oct-03 - Changed MOD..ALTMIN to impl_or_expl_q_rel to exclude proper 
; nouns, to still block e.g. "Kim a book".
; DPF 19-may-05 - Added MOD..NORM no_rel to prevent modification of
; e.g. locative 'there', while still avoiding modification of gerunds, as
; in 'hiring a consultant'
; DPF 26-mar-06 - But this blocks "ten days a week", so changed NORM to
; norm_rel (still blocks modif of 'there' and gerunds).
; DPF 28-aug-07 - Added COMPS..NORM no_rel to block unusual nouns like
; in "a little".
; DPF 20-jun-08 - Changed MOD..MIN nonpro_rel to gen_nom_nbar_rel to exclude
; proper names, to avoid e.g. "Browne an office and interviewed programmers"

; 'a (per)'
p_nbar_comp_nmod_lexent := p_nbar_comp_nospr_lexent &
  [ SYNSEM basic_trans_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ MOD < [ LOCAL.CAT [ HEAD noun &
                                         [ MINORS [ MIN gen_nom_nbar_rel,
                                                    ALTMIN impl_or_expl_q_rel,
                                                    NORM norm_rel ] ] ],
                             NONLOC.QUE 0-dlist,
                             PUNCT.RPUNCT pair_or_no_punct,
                             LEX + ] >,
                     MINORS.ALTMIN no_rel,
                     PRD - ],
              VAL.COMPS < [ LOCAL [ CAT.HEAD.MINORS.NORM no_rel,
                                    AGR.PNG.PN 3s,
                                    CONT.HOOK.LTOP #nhand ],
                            MODIFD notmod ] > ],
        CONT [ RELS <! #keyrel, #altkeyrel !>,
               HCONS <! qeq & [ HARG #rhand,
                                LARG #nhand ] !> ] ],
      LKEYS [ KEYREL #keyrel,
              ALTKEYREL #altkeyrel & [ RSTR #rhand ] ] ] ].

p_nb_i-nm_le := p_nbar_comp_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET con_or_unk ] > ].

p_nb_i-nm-an_le := p_nbar_comp_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET voc_or_unk ] > ].

; 'of' in "what kind of book(s)'
; 'the 25th to 28th of May'
; 'from hut to hut'

p_nb_i-nmd_le := p_nbar_comp_nospr_lexent &
  [ SYNSEM basic_prep_nomod_synsem &
    [ LOCAL [ CAT [ HEAD [ MINORS.ALTMIN #min,
                           PRD - ],
                    VAL [ SPR < [ --MIN much_deg_rel ] >,
                          COMPS < [ --MIN #min,
                                    LOCAL [ CAT.HEAD.PRD -,
                                            CONT.HOOK [ LTOP #ltop,
                                                        INDEX #index ] ] ] >]],
              CONT [ HOOK [ LTOP #ltop,
                            INDEX #index ],
                     RELS <! !>,
                     HCONS <! !> ] ] ] ].

; 'planes leave _every_ four hours'
p_np_i-msr_le := basic_prep_word &
  [ SYNSEM one_arg_prep_synsem &
    [ LOCAL 
      [ CAT 
        [ HEAD.PRD +,
          VAL 
          [ SPR < [ NONLOC.SLASH 0-dlist ] >,
            COMPS < abstr_lex_synsem &
                    [ OPT -,
                      LOCAL 
                      [ CAT [ HEAD noun,
                              VAL [ SPR < [ --MIN degree_rel,
					    NONLOC [ SLASH 0-dlist,
						     QUE 0-dlist ] ] >,
                                    COMPS < > ] ],
                        CONT.HOOK.INDEX #nind,
                        AGR.PNG.PN 3s ],
                      NONLOC.SLASH 0-dlist ] > ],
          POSTHD + ],
        CONT [ HOOK [ LTOP #plbl,
                      INDEX #pind,
                      XARG #arg1 ],
               RELS <! prep_relation & #keyrel &
                       [ LBL #plbl,
                         PRED loc_nonsp_rel,
                         ARG0 #pind,
                         ARG1 #arg1,
                         ARG2 #iind ],
                       [ LBL #ihand,
                         PRED interval_rel,
                         ARG0 #iind,
                         ARG1 #nind ],
                       [ PRED udef_q_rel,
                         ARG0 #iind,
                         RSTR #rhand ] !>,
               HCONS <! qeq & [ HARG #rhand,
                                LARG #ihand ] !> ] ],
      LKEYS.KEYREL #keyrel ] ].



;; Temporal prepositions:

; "ten minutes to three" - "to" as head
; Use POSTHD to allow "half past three" and "three thirty" but block
;      "?thirty past three" and "*three half"
; DPF (12-Jul-98) The specifier on hour_prep_words has to be [ OPT + ] in 
; order to block prenominal adjectives from attaching, since they distinguish 
; proper from common nouns by the optionality (or absence) of the specifier.  
; This distinction doesn't seem to work well here, but it's the only case, so 
; perhaps the analysis of "ten after three" should be reconsidered.
; DPF (11-Jul-99) But this [OPT +] incorrectly predicts that "To five thirty 
; suits me" is good, and worse, it allows "to five thirty" to act like an NP in
; appositive constructions.  So instead of this hack, constrain adjectives to
; only modify nominals with a DET specifier.
; DPF 23-May-03 - Since we now treat the specifier as the semantic head in the
; spr-head rule, "ten" of "ten to three" will determine the index of the phrase
; But this finally drives us to revise the analysis of this construction, so
; now we have a lexical rule that converts one- and two-digit cardinal number
; adjectives into nouns which take an optional "minute" complement and an
; obligatory prepositional complement (which is itself underspecified for 
; whether it is complement-saturated).  This should give us "ten to two",
; "ten minutes to two", and "ten to" and "ten after".

minute_noun_synsem := lex_synsem &
  [ LOCAL 
    [ CAT 
      [ HEAD noun & [ MOD < >,
                      MINORS.MIN hour_prep_rel ],
        VAL [ SPR < >,
              SUBJ < >,
              COMPS < [ LOCAL [ CAT nomp_cat &
                                    [ HEAD.MINORS [ MIN _minute_n_1_rel,
                                                    ALTMIN implicit_q_rel ] ],
                                CONT.HOOK.INDEX #minst & index,
                                CONJ cnil ],
                        NONLOC.SLASH 0-dlist,
                        OPT +,
                        PUNCT.LPUNCT no_punct ],
                      [ LOCAL [ CAT [ HEAD prep & 
                                        [ PRD -,
                                          MINORS [ MIN minute_prep_sel_rel,
                                                   ALTMIN numbered_hour_rel ]],
                                      VAL.SPR *olist*,
                                      MC na ],
                                CONT.HOOK [ LTOP #nhand,
                                            INDEX #ninst &
                                                 [ SORT time ] ],
                                CONJ cnil ],
                        NONLOC.SLASH 0-dlist,
                        OPT -,
                        PUNCT.LPUNCT no_punct ] > ] ],
      CONT nom-obj &
          [ HOOK [ LTOP #nhand,
                   INDEX ref-ind & #ninst &
                        [ PNG png & [ PN 3s ] ] ],
            HCONS <! !> ] ],
    LKEYS.KEYREL [ LBL #nhand,
                   PRED hour_prep_rel,
                   ARG1 #ninst,
                   ARG2 #minst ] ].

; ten pm to two am
; Tuesday to Friday
; ten mph to twenty mph
; DPF 3-Jul-02 - If MIN is interval_rel, then we predict wrongly that all of
; these constructions can be modifier NPs like "Tuesday".  But the modifying
; capability seems to be whatever the interval endpoints are: "Kim stayed
; Tuesday to Saturday" but "*Kim stayed Abrams to Browne".  So let's try 
; making the MIN be the SPR's MIN instead.
; DPF 28-Apr-03 - The [PRD -] feature prevents this from undergoing the
; temp_np rule, so we don't get "Kim stayed Tuesday to Saturday".  Let's try
; removing this constraint and see what happens.
; DPF 15-jun-04 - Restrict two arguments to [LEX +] to avoid spurious
; ambiguities; so admit "Tuesday - Wednesday" but not "Hire Kim -- his brother"
; with the sense of x_to_y.
; DPF 21-aug-04 - Removed SYNSEM..ALTMIN never_unify_rel, since it prevents
; these from appearing in NP-N compounds, as in "the Berlin - Paris route".
; Don't know what it was trying to exclude.
; DPF 25-sept-04 - Can't use LEX + to avoid 'Hire Kim - his brother'
; (cf. 15-jun-04) since this would also block 'Two - three p.m. is okay'
; since 'two' is [LEX -] in order to sustain contrast of 'we have a two p.m.
; meeting' vs. '*we have a two meeting'.  But happily we already have the
; constraint on MIN of each dtr NP requiring abstr_named_rel, which does the
; job we want, as long as we correct the erroneous type definition for
; reason_rel which wrongly unified norm_nom_rel and abstr_named_rel.  Sigh.
; DPF 7-mar-05 - Removed [PRD -] constraint on SPR and COMPS, since proper NPs
; now have their PRD value identified with their INFL value.  Don't know why
; this constraint was originally imposed.  Now only require that the PRD values
; of the two be identified, to avoid spurious ambiguity.
; Also changed parent type from norm_msg_word to norm_word since it needs
; to be unmarked for INFL in order to appear in compounds 
; (eg. "the Berlin - Paris route").
; DPF 14-nov-05 - Hack: added [AUX +] to prevent these from being modified by
; PPs, avoiding spurious analysis for "from Paris [[to Rome] on Thursday]"
; DPF 06-mar-06 - Propagated LEX from right dtr via HS-LEX, to block 'the 
; Paris to a city in Italy tour'
; DPF 24-may-06 - Further constrained NPs to be not post-modified, to avoid
; further spurious ambiguity.
; DPF 15-sept-07 - Removed identif of INFLECTD and PRD, since want to constrain
; HCOMP rule to require INFL + hd-dtr, to avoid spurious edges for e.g.
; 'hire Kim'.  We'll remind ourselves of why this identity was clever?

n_x_to_y_synsem := basic_two_arg.

n_x_to_y_lexent := noncqrs-hm &
  [ SYNSEM n_x_to_y_synsem &
      [ LOCAL [ CAT [ HEAD noun &
                      [ POSS -,
                        MOD < >,
                        AUX + ],
                      VAL 
                      [ SPR < synsem &
                              [ LOCAL 
                                [ CAT 
                                  [ HEAD noun &
                                    [ POSS -,
                                      MOD < >,
                                      PRD #prd,
                                      MINORS [ MIN nonpro_rel,
                                               ALTMIN 
                                                 abstr_def_or_udef_q_rel ] ],
                                    VAL [ SUBJ *olist*,
                                          COMPS < >,
					  SPEC < [ LOCAL.CAT.VAL.COMPS < >] >,
					  SPCMPS < > ] ],
				  CONJ cnil ],
                                NONLOC non-local_none,
                                --SIND #arg1 & [ SORT #sort ],
                                MODIFD notmod_or_lmod,
                                OPT - ] >,
                        SUBJ < >,
                        COMPS < synsem &
                                [ --MIN #cmin,
                                  LOCAL [ CAT [ HEAD noun &
                                                [ POSS -,
                                                  MOD < >,
                                                  PRD #prd ],
                                                VAL [ SUBJ *olist*,
                                                      COMPS < > ] ],
                                          CONJ cnil ],
				  NONLOC non-local_none,
                                  LEX #lex,
                                  --SIND #arg2 & [ SORT #sort ],
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ] >,
                        SPCMPS < > ],
                      HS-LEX #lex ],
                AGR.DIV -,
                CONT nom-obj &
                    [ HOOK.INDEX #index,
                      RELS.LIST < #keyrel &
                                  [ LBL #nhand,
                                    PRED interval_rel,
                                    ARG0 #index ],
                                  [ PRED udef_q_rel,
                                    ARG0 #index,
                                    RSTR #rhand ],
                                  prep_relation &
                                  [ LBL #nhand,
                                    PRED interval_p_start_rel,
                                    ARG0.E [ TENSE no_tense,
                                             ASPECT no_aspect ],
                                    ARG1 #index,
                                    ARG2 #arg1 ],
                                  prep_relation &
                                  [ LBL #nhand,
                                    PRED interval_p_end_rel,
                                    ARG0.E [ TENSE no_tense,
                                             ASPECT no_aspect ],
                                    ARG1 #index,
                                    ARG2 #arg2 ], ... >,
                      HCONS.LIST < qeq & [ HARG #rhand,
                                           LARG #nhand ], ...> ] ],
        LKEYS [ KEYREL #keyrel,
                ALTKEYREL.PRED never_unify_rel,
                --COMPKEY #cmin ] ] ].

n_np_x-to-y-sg_le := n_x_to_y_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT 
	[ HEAD.MINORS.MIN interval_rel,
	  VAL [ SPR < [ LOCAL 
			[ AGR.PNG.PN 3s,
			  CAT [ HEAD.MINORS [ MIN abstr_named_rel & #sprmin,
					      ALTMIN impl_or_proper_q_rel ],
				VAL [ SPR *olist* ] ] ] ] >, 
		COMPS < [ --MIN abstr_named_rel,
			  LOCAL [ AGR.PNG.PN 3s,
				  CAT.VAL.SPR *olist* ],
			  MODIFD notmod_or_lmod ] > ] ],
	CONT [ RELS <! relation, relation, relation, relation !>,
               HCONS <! qeq !> ] ],
      LKEYS [ --COMPKEY #cmin,
              --+COMPKEY #cmin,
              --+OCOMPKEY #sprmin ] ] ].

n_np_x-to-y-pl_le := n_x_to_y_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD.MINORS.MIN interval_rel,
	      VAL [ SPR < [ --MIN part_nom_rel,
			    LOCAL.CAT.VAL.SPR *olist* ] >, 
		    COMPS < [ --MIN abstr_named_rel,
			      LOCAL [ CAT.VAL.SPR *olist*,
				      AGR.PNG.PN 3p ],
			      MODIFD notmod_or_lmod ] > ] ],
	CONT [ RELS <! relation, relation, relation, relation !>,
	       HCONS <! qeq !> ] ],
      LKEYS [ --+COMPKEY card_rel,
	      --+OCOMPKEY card_rel ] ] ].

; 'the 25th to 26th (of July)'
n_nb_x-to-y_le := n_x_to_y_lexent &
  [ SYNSEM
    [ LOCAL 
      [ CAT [ HEAD.MINORS.MIN interval_modable_rel,
              VAL [ SPR < [ --MIN dofm_rel & #sprmin,
                            LOCAL.CAT.VAL.SPR *olist* ] >,
		    COMPS < [ --MIN dofm_rel,
                              LOCAL [ CAT.VAL.SPR < synsem >,
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX #cind ] ] ] > ] ],
        CONT [ RELS <! relation, relation, relation, relation,
                     [ PRED udef_q_rel,
                       ARG0 #cind,
                       RSTR #crstr ] !>,
               HCONS <! qeq,
                      qeq & [ HARG #crstr,
                              LARG #cltop ] !> ] ],
      LKEYS [ --COMPKEY #cmin,
              --+COMPKEY #cmin,
              --+OCOMPKEY #sprmin ] ] ].

; DPF 13-Aug-01 - For 'mid to upper' as in "the mid to upper nineties"
; Meaning intended to be something like "the nineties in the interval whose
; start is the mid somethings and whose end is the upper somethings"
; DPF 01-sept-04 - Removed MINORS.MIN basic_adj_rel from SPR and COMPS, to 
; allow "three to five chairs"

aj_pp_i-x-to-y_le := noncqrs-m-nab & word &
  [ SYNSEM 
    [ LOCAL 
      [ CAT 
        [ HEAD adj & 
          [ MOD < [ LOCAL intersective_mod &
                    [ CAT nbar_cat_min,
                      CONT.HOOK [ LTOP #hand,
                                  INDEX #nomarg & ref-ind & [ PNG #png ] ],
                      CONJ cnil ] ] >,
            MINORS.MIN interval_p_end_rel ],
          VAL 
          [ SUBJ < >,
            SPR < synsem &
                  [ OPT -,
                    LOCAL [ CAT [ HEAD adj_or_intadj &
                                       [ TAM [ TENSE no_tense,
                                               ASPECT no_aspect ],
                                         MOD < synsem & 
                                               [ LOCAL intersective_mod ] > ],
                                  VAL [ SPR *olist*,
                                        COMPS < >,
                                        SPCMPS < >,
                                        SPEC < [ LOCAL.CAT.VAL.COMPS < > ]>]],
			    CONT.HOOK [ LTOP #fghand,
                                        XARG #fromarg ],
                            CONJ cnil ],
                    NONLOC.SLASH 0-dlist ] >,
            COMPS < [ OPT -,
                      LOCAL [ CAT [ HEAD adj_or_intadj &
                                         [ TAM [ TENSE no_tense,
                                                 ASPECT no_aspect ],
                                           MOD < synsem & 
                                                [ LOCAL intersective_mod ] > ],
                                    VAL [ SPR *olist*,
                                          COMPS < > ] ],
                              CONT.HOOK [ LTOP #tghand,
                                          XARG #toarg ],
                              CONJ cnil ],
                      NONLOC.SLASH 0-dlist,
                      PUNCT.LPUNCT no_punct ] > ] ],
        CONT [ HOOK [ LTOP #hand,
                      INDEX #arg0,
                      XARG #nomarg ],
               RELS <! #keyrel &
                     prep_relation &
                     [ LBL #ihand,
                       PRED interval_p_end_rel,
                       ARG0 #arg0,
                       ARG1 #intarg & [ DIV + ],
                       ARG2 #toarg ],
                     prep_relation &
                     [ LBL #ihand,
                       PRED interval_p_start_rel,
                       ARG0.E [ TENSE no_tense,
                                ASPECT no_aspect ],
                       ARG1 #intarg,
                       ARG2 #fromarg ],
                     [ LBL #fghand,
                       PRED elliptical_n_rel,
                       ARG0 #fromarg ],
                     [ PRED udef_q_rel,
                       ARG0 #fromarg,
                       RSTR #fgrhand ],
                     [ LBL #tghand,
                       PRED elliptical_n_rel,
                       ARG0 #toarg ],
                     [ PRED udef_q_rel,
                       ARG0 #toarg,
                       RSTR #tgrhand ],
                     [ LBL #ihand,
                       PRED interval_rel,
                       ARG0 #intarg ],
                     [ PRED udef_q_rel,
                       ARG0 #intarg,
                       RSTR #irhand ],
                     prep_relation &
                     [ LBL #hand,
                       PRED loc_nonsp_rel,
                       ARG0.E [ TENSE no_tense,
                                ASPECT no_aspect ],
                       ARG1 #nomarg,
                       ARG2 #intarg ] !>,
               HCONS <! qeq & [ HARG #irhand,
                                LARG #ihand ],
                      qeq & [ HARG #fgrhand,
                              LARG #fghand ],
                      qeq & [ HARG #tgrhand,
                              LARG #tghand ] !> ],
        AGR [ PNG #png,
              DIV - ] ],
      LKEYS.KEYREL #keyrel,
      MODIFD.LPERIPH na ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADVERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Adverbs modify VPs and APs either pre-head or post-head (or both).
; Sentence-initial adverbials are treated as extractions of post-VP modifiers,
; unless the adverbial is a pre-head modifier. Otherwise, it would be hard to
; block post-S attachment along with post-VP attachment, which would give 
; spurious ambiguity.
; DPF 19-Oct-02 - Removed nonprd_synsem parent, since trying to make
; head_adj rule constrain adj to be PRD +.

basic_adverb_synsem := basic_one_arg & basic_lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_adv &
		       [ MOD < [ LOCAL local_basic &
				       [ CAT.MC #mc,
                                         CONT [ HOOK.XARG #xarg ],
					 CONJ cnil ],
                                 MODIFD.LPERIPH #lperiph,
                                 OPT - ] >,
                         MINORS.MIN basic_adv_rel ],
                  VAL [ SUBJ < >,
                        SPR #spr,
			COMPS < > ],
                  MC #mc ],
	    CONT [ HOOK.XARG #xarg,
		   RELS.LIST < #keyrel, ... > ],
            ARG-S #spr ],
    MODIFD.LPERIPH #lperiph,
    LKEYS.KEYREL #keyrel & adv_relation ].

basic_scopal_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal_mod &
				   [ CAT.HEAD adverbee,
				     CONT.HOOK [ LTOP #mhand,
                                                 INDEX #index ] ] ] >,
	    CONT [ HOOK.INDEX #index,
                   RELS <! relation !>,
                   HCONS <! qeq &
                          [ HARG #hand,
                            LARG #mhand ] !> ] ],
    LKEYS.KEYREL.ARG1 #hand & handle ].


; DPF 17-Dec-01 - Made MOD..E-INDEX reentrant with E-INDEX, and the INDEX 
; values the same: 
; 'Chairs currently available arrived"
; DPF 04-may-05 - We consider restricting intersective adverbs to not modify
; auxiliary VPs, to avoid generating e.g. "Abrams carefully is leaving."
; But this also blocks e.g. "Abrams will often be early" - if anything, the
; generalization is that these adverbs don't want to attach to finite aux VPs,
; but that constraint is hard to express, and it's probably even more tricky
; to get the real constraint right - cf. ellipsis: "Kim often will." Or even
; "Kim sometimes might say this".  So remove AUX - from MOD.

basic_int_adverb_synsem := basic_adverb_synsem & isect_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.MC na,
                                   CONT.HOOK.INDEX #index ] ] >,
    LKEYS.KEYREL.ARG1 #index & event ].

basic_spec_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT.VAL.SPR < synsem & 
			  [ LOCAL [ CAT [ VAL [ SUBJ < >,
						SPR *olist* ],
					  MC na ],
                                    CONT.HOOK [ LTOP #hand,
                                                XARG #arg0 ] ] ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #arg0 ] ].

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
spec_adverb_synsem := basic_spec_adverb_synsem &
  [ LOCAL.CAT.VAL.SPR < [ --MIN more_or_very_deg_rel,
                          LOCAL.CAT.HEAD adv ] > ].

intersect_spec_adverb_synsem := basic_int_adverb_synsem & 
                                basic_spec_adverb_synsem.
scopal_spec_adverb_synsem := basic_scopal_adverb_synsem & spec_adverb_synsem.

; VP, PP, AP
scopal_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD adv & 
                   [ MOD < [ LOCAL.CAT [ VAL.COMPS < >,
                                         MC na_or_- ] ] > ] ].

basic_intersect_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ VAL [ SUBJ *synlist*,
					     COMPS < > ],
				       MC na_or_- ] ] > ].

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
intersect_adverb_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD reg_adv & [ MOD < [ LOCAL.CAT adverbee_cat ] > ],
                  VAL.SPR < [ --MIN more_or_very_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
            CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; Adverbs like "once" as in "just once" ("*very once")
intersect_adverb_just_only_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD reg_adv & [ MOD < [ LOCAL.CAT adverbee_cat ] > ],
                  VAL.SPR < [ --MIN just_only_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
            CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; 'now' but not 'then' - appears after auxiliary as in "You are now ready"
; DPF 10-apr-05 - Changed SPR..MIN from no_rel to very_deg_rel in order
; to get "Kim is very often unhappy" and "Kim very often refuses to leave"
; Will have to find some other way to block "*Kim is very now unhappy",

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
intersect_adverb_auxv_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD lexadv & [ MOD < [ LOCAL [ CAT adverbee_cat &
                                                      [ HEAD v_or_g ],
                                                  CONT.HOOK.LTOP #ltop ],
                                          MODIFD.LPERIPH na_or_- ] > ],
                  VAL.SPR < [ --MIN more_or_very_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
            CONT.HOOK.LTOP #ltop ] ].

; VP only
; Block adj modifiee to avoid spurious parse for "almost empty"
; DPF 09-Aug-99 - Relaxed MOD..HEAD value to be v_or_g_or_a because okay for 
; adjectives as pre-head modifiers ("an apparently difficult problem"), though
; not post-head.
; DPF 25-Oct-01 - Removed MOD..MOD < synsem > constraint since it blocked
; 'I should never have arrived'
; DPF 30-aug-04 - Changed MOD..SUBJ from <synsem_min> to *synlist* in order
; to return to letting adverbs modify adjectives, while still distinguishing
; VPs from clauses.
; DPF 04-sept - But this prevents modification of inverted sentences as in
; 'why hasn't kim arrived yet'.  So use MOD..MSG no_msg instead.

scopal_vp_adverb_synsem := scopal_adverb_synsem &
  [ LOCAL.CAT.HEAD [ MOD < [ LOCAL [ CAT [ HEAD v_or_g_or_a,
                                           VAL.SPR < synsem_min > ] ] ] >,
                     MINORS.MIN adv_rel ],
    LKEYS.KEYREL adv_relation ].

; Adverbs like "also" that either (pre) modify VPs or appear as complements of
; aux Vs.
; DPF 24-May-00 - Restrict MOD value to be no_aspect, to avoid spurious
; ambiguity for "kim is probably leaving"
; DPF 14-Oct-00 - But this prevents the desired parse for "Kim is not currently
; sleeping" since "not" should modify a pres-participle VP, not the gerund.  So
; as long as the gerund rule is a lexical rule, we're stuck with the ambiguity.
; DPF 13-Mar-02 - Added [MOD..PRD +] to ensure that when these adverbs modify
; deverbal adjectives, they not appear attributively, as in *the not yet 
; finished book
; DPF 18-Mar-02 - But this [PRD +] prevents these adverbs from pre-modifying
; ordinary finite VPs.  So let's instead accept "the not yet finished book" as
; okay.
; DPF 30-aug-04 - Changed MOD..SUBJ from <synsem_min> to *synlist* in order
; to return to letting adverbs modify adjectives, while still distinguishing
; VPs from clauses.

scopal_vp_aux_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD lexadv &
                   [ MOD < [ LOCAL.CAT [ HEAD v_or_g_or_a,
                                         VAL [ SUBJ *synlist*,
                                               COMPS < > ],
                                         MC na ] ] >,
                     MINORS.MIN adv_rel ] ].

scopal_negadv_adverb_synsem := scopal_adverb_synsem &
  [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT [ HEAD negadv,
                                         VAL.SUBJ < > ] ] >,
                     MINORS.MIN adv_rel ],
    LKEYS.KEYREL adv_relation ].

; rather: 'would you rather leave' 'I would rather not'
scopal_adv_would_v_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT [ HEAD adv & [ MOD < [ --MIN _would_v_modal_rel,
                                     LOCAL.CAT [ HEAD verb,
                                                 VAL.COMPS *cons* ],
                                     MODIFD.RPERIPH na_or_- ] >,
                             MINORS.MIN adv_rel ],
                POSTHD + ] ].

; DPF 21-Mar-02 - Added MOD..MSG no_msg, which seemingly should have
; been here all along - needed to block e.g. spurious parse for "kindly leave"
intersect_vp_adverb_synsem := intersect_adverb_synsem &
  [ LOCAL.CAT.HEAD.MINORS.MIN basic_adv_rel,
    LKEYS.KEYREL adv_relation ].

; S (for pre-S scopal adverbs only)
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.

scopal_s_adverb_synsem := spec_adverb_synsem &
  [ LOCAL [ CAT.HEAD adv &
                     [ MOD < [ LOCAL scopal_mod &
                                     [ CAT [ HEAD verb,
                                             VAL [ SUBJ *olist*,
                                                   COMPS < > ],
                                             MC bool ],
                                       CONT [ HOOK [ LTOP #arghand,
                                                     INDEX #index ] ] ] ] > ],
            CONT [ HOOK [ LTOP #khand,
                          INDEX #index & [ SF #iforce ] ],
		   RELS <! relation !>,
		   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #arghand ] !> ] ],
    PUNCT.RPUNCT.PSF #iforce,
    LKEYS.KEYREL [ LBL #khand,
                   ARG1 handle & #mhand ] ].

; S or VP (for pre-head intersective adverbs only) 
; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
intersect_s_or_vp_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL [ CAT [ HEAD adv &
                       [ MOD < [ LOCAL.CAT adverbee_cat &
                                           [ VAL.COMPS < > ] ] > ],
                  VAL.SPR < [ --MIN more_or_very_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; For adverbs like "maybe" which take no degree specifier
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.
; DPF 03-dec-05 - Generalized MOD..HEAD to 'verbal' to allow e.g.
; "they believed therefore that Kim was right"
scopal_s_adverb_nospec_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT [ VAL.SPR < anti_synsem_min >,
		  HEAD adv &
                          [ MOD < [ LOCAL scopal_mod &
                                          [ CAT [ HEAD verbal,
                                                  VAL [ SUBJ *olist*,
                                                        COMPS < > ],
                                                  MC bool ],
                                            CONT.HOOK [ LTOP #arghand,
                                                        INDEX #index ] ] ] >,
                            MINORS.MIN adv_rel ] ],
	    CONT [ HOOK [ LTOP #khand,
                          INDEX #index & [ SF #iforce ] ],
		   RELS <! relation !>,
		   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #arghand ] !> ] ],
    PUNCT.RPUNCT.PSF #iforce,
    LKEYS.KEYREL [ LBL #khand,
                   ARG1 handle & #mhand ] ].

basic_adverb_word := noncrs-m-nab & word &
   [ SYNSEM basic_lex_synsem &
	    [ LOCAL.CONT.HOOK.LTOP #ltop,
              LKEYS.KEYREL.LBL #ltop ] ].


adverb_word := basic_adverb_word &
  [ SYNSEM scopal_vp_adverb_synsem ].

av_-_s-negmod_le := basic_adverb_word &
  [ SYNSEM scopal_negadv_adverb_synsem ].

av_-_s-rather_le := basic_adverb_word &
  [ SYNSEM scopal_adv_would_v_synsem ].

; DPF (27-Apr-99) Assume for now that S-initial adverbs can only modify [INV -]
; S's, in order to block "*Never does kim sleep?"
; DPF 28-Oct-01 - But this blocked e.g. "Meanwhile when does kim sleep"

norm_adv_word := noncrs-nab & word &
   [ SYNSEM basic_lex_synsem ].

adv_s_pre_lexent := norm_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT [ POSTHD -,
			 HEAD.MOD < [ LOCAL.CAT.MC bool ] > ] ] ].
    
av_-_s-cp-pr_le := adv_s_pre_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN adv_rel ].

; For "(3)" or "3)" meaning 'thirdly'
av_-_s-cp-gen_le := adv_s_pre_lexent & generic_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN adv_rel,
	     LKEYS.KEYREL.PRED "nth_rel" ] ].

; 'evidently' - only pre-modifies declaratives, not questions or commands
av_-_s-cpp_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT 
              [ HEAD [ MOD < [ LOCAL [ CAT.MC +,
                                       CONT.HOOK.INDEX.SF basic-prop ] ] >,
                       MINORS.MIN adv_rel ] ] ] ].
    
; DPF 10-Apr-02 - Removed MOD..VFORM imp_vform since this blocked e.g 
; "I would like to know when my order is going to arrive , please"
av_-_s-cp-nsp-po_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHD + ] ].

av_-_s-cp-nsp-pr_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHD - ] ].
    
av_-_s-cp-mc-pr_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT [ HEAD.MOD < [ NONLOC.SLASH 0-dlist ] >,
                         MC +,
                         POSTHD - ] ] ].
    
av_-_s-cp_le := norm_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD.INV - ] >,
                              MINORS.MIN adv_rel ] ] ].

av_-_s-vp_lexent := adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                    MODIFD [ LPERIPH na_or_-,
                                             RPERIPH na_or_- ] ] >,
                            MINORS.MIN adv_rel ] ].

av_-_s-vp_le := av_-_s-vp_lexent.
av_-_s-vp-only_le := av_-_s-vp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g ] > ].

av_-_s-vp-x_le := basic_adverb_word &
  [ SYNSEM scopal_vp_aux_adverb_synsem &
           [ LOCAL.CAT [ POSTHD -,
                         HEAD.MOD < [ MODIFD.LPERIPH na_or_- ] > ] ] ].
    
; DPF 7-Jun-00 - To avoid apparently spurious ambiguity of attachment of
; VP-final scopal adverbs in e.g. "I have won too", require these adverbs to
; attach only to finite or imperative VP, forcing high attachment.

av_-_s-vp-po_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g & 
                                                   [ VFORM fin_or_imp ],
                                    MODIFD.RPERIPH na_or_- ] >,
                       POSTHD + ] ].

av_-_s-vp-pr_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT [ POSTHD -,
                       HEAD [ MINORS.MIN adv_rel,
                              MOD < [ MODIFD.LPERIPH na_or_- ] > ] ] ].

av_-_i-ap-pp_le := basic_adverb_word &
  [ SYNSEM intersect_adverb_synsem & 
    [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD a_or_p &
                                     [ MOD < [ LOCAL intersective_mod ] > ]] >,
                       MINORS.MIN adv_rel ] ] ].
    
int_vp_adverb_word := basic_adverb_word &
  [ SYNSEM intersect_vp_adverb_synsem ].
    
int_vp_adv_just_only_word := basic_adverb_word &
  [ SYNSEM intersect_adverb_just_only_synsem ].
    
int_vp_aux_adverb_word := basic_adverb_word &
  [ SYNSEM intersect_adverb_auxv_synsem &
           [ LOCAL.CAT.HEAD.MINORS.MIN adv_rel ] ].
    
av_-_i-vp_lexent := int_vp_adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD adv & 
                          [ MINORS.MIN adv_rel,
                            MOD < [ LOCAL.CAT.HEAD v_or_g_or_a_or_int,
                                    MODIFD [ LPERIPH na_or_-,
                                             RPERIPH na_or_- ] ] > ] ].

av_-_i-vp_le := av_-_i-vp_lexent.

; 'much' - want to avoid "*older much"
av_-_i-vp-only_le := av_-_i-vp_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
		       POSTHD + ] ].

; DPF 06-sept-07 - Add type to allow restrictions on which adverbs can take
; part in the v_mod rule which allows modifiers before NP complements.

av_-_i-vp-nvm_le := av_-_i-vp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM no_rel ].

av_-_i-vp-j_le := int_vp_adv_just_only_word &
  [ SYNSEM.LOCAL.CAT.HEAD adv & 
                          [ MINORS.MIN adv_rel,
                            MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                    MODIFD [ LPERIPH na_or_-,
                                             RPERIPH na_or_- ] ] > ] ].

av_-_i-vp-x_le := int_vp_aux_adverb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
                           POSTHD - ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

av_-_i-vp-x-only_le := int_vp_aux_adverb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < anti_synsem &
                                      [ LOCAL [ CAT.HEAD verb,
                                                CONT.HOOK.LTOP #ltop ] ] > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

; 'long' as in "we have long admired abrams"
av_-_i-vp-x-nmd_le := int_vp_aux_adverb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < anti_synsem >,
                           POSTHD - ],
                     CONT [ RELS <! #keyrel !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

; 'now'
av_-_i-vp-x-now_le := noncrs-hm & word &
  [ INFLECTD +,
    SYNSEM intersect_adverb_auxv_synsem &
           [ LOCAL [ CAT [ HEAD.TAM #tam,
                           POSTHD - ],
                     CONT [ RELS <! [ PRED temp_loc_x_rel,
                                      ARG2 #inst ],
                                   [ LBL #nhand, 
                                     PRED time_n_rel,
                                     ARG0 #inst ],
                                   [ PRED def_implicit_q_rel,
                                     ARG0 #inst,
                                     RSTR #rhand ],
                                   [ LBL #nhand,
                                     PRED _now_a_1_rel,
                                     ARG1 #inst ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #nhand ] !> ] ],
             LKEYS.KEYREL.ARG1 [ E #tam,
                                 SORT time ] ] ].

; DPF 25-aug-07 - Added MODIFD hasmod to prevent these from appearing in
; the robust v_mod construction preceding complements, to avoid spurious
; ambiguity for e.g. "Abrams has more consultants."

av_-_i-vp-po_le := int_vp_adverb_word & 
  [ SYNSEM [ LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                      MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                              MODIFD.RPERIPH na_or_- ] > ],
                         POSTHD + ],
             MODIFD hasmod ] ].

; DPF 13-nov-05 - Generalized MOD..HEAD from v_or_g to v_or_g_or_a in order
; to get modification of deverbal attrib adjs.
; DPF 24-may-07 - And generalized again in order to get modification of
; PPs as in "professors now at Stanford ..."
;
av_-_i-vp-pr_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                    MOD < [ LOCAL.CAT.HEAD v_or_g_or_a_or_p,
                                            MODIFD.LPERIPH na_or_- ] > ],
                       POSTHD - ] ].

av_-_i-vp-po-nmb_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob & 
                            [ MINORS.MIN adv_rel,
                              MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                      MODIFD.RPERIPH na_or_- ] > ],
                       POSTHD + ] ].

; ERB (31-10-96) See notes near n_wh_pro_le.
; where, when, how
; DPF 31-may-06 - SPR constraint propagated from supertype - maybe unneeded.
; DPF 30-sept-06 - Changed MOD..HEAD from v_or_g_or_a to v_or_n_or_g_or_a
; in order to enable e.g "the reason why is obvious." as well as
; "why are there stars?"
; DPF 23-may-07 - Changed MOD..HEAD to just 'subst' since also want modif. of
; PPs as in "They knew why Kim was in Paris."
; DPF 18-feb-08 - Added PRD - to exclude spurious reading for "how is Kim?".

pp_-_i-wh_le := noncrs-hm-nab &
  [ SYNSEM prep_p_mod_synsem &
      [ LOCAL [ CAT [ HEAD prep &
                           [ PRD -,
			     MOD < [ LOCAL.CAT.HEAD subst ] >,
                             MINORS.ALTMIN nom_rel ],
		      VAL [ COMPS < >,
                            SPR < [ LOCAL.CAT [ HEAD.MINORS.ALTMIN 
                                                     abstr_meas_nom_rel,
                                                VAL [ SPEC < synsem >,
                                                      COMPS < > ] ] ] >,
			    SPEC < > ],
		      POSTHD +,
                      MC na ],
		CONT [ RELS <! #keyrel & [ ARG2 #objind ],
			        [ PRED which_q_rel,
                                  ARG0 #objind,
                                  RSTR #rhand ],
			        nom_relation & #altkeyrel &
                                [ LBL #nhand,
                                  ARG0 #objind ] !>,
		       HCONS <! qeq &
			       [ HARG #rhand,
				 LARG #nhand ] !> ],
                CONJ cnil ],
        LKEYS [ KEYREL #keyrel,
                ALTKEYREL #altkeyrel ],
        NONLOC.QUE 1-dlist &
              [ LIST < param > ],
        PUNCT no_punctuation_min ] ].
 
pp_-_i-rel_le := nonc-hm-nab &
  [ SYNSEM basic_lex_pp_synsem &
      [ LOCAL [ CAT [ HEAD prep &
                           [ PRD +,
                             MINORS.MIN #min,
			     MOD < [ LOCAL [ CAT vp_cat &
						 [ HEAD verb ],
					     CONJ cnil ],
                                     --SIND #event & event ] > ],
		      VAL.SPR < synsem & 
                                [ --MIN degree_rel,
                                  LOCAL [ CAT [ HEAD n_or_adv,
                                                VAL [ SPR *olist*,
                                                      COMPS < > ] ],
                                          CONT.HOOK [ LTOP #khand,
                                                      XARG #event ] ],
                                  NONLOC.QUE 0-dlist,
                                  OPT + ] >,
		      POSTHD +,
                      MC na,
                      HC-LEX - ],
                CONT [ HOOK [ LTOP #khand,
                              INDEX #event ],
		       RELS <! #keyrel & [ ARG1 #event,
                                           ARG2 #objind ] !>,
		       HCONS <! !> ],
                CONJ cnil ],
        LKEYS.KEYREL #keyrel & [ LBL #khand,
                                 PRED #min ],
        NONLOC [ REL 1-dlist & [ LIST < [ INDEX #objind ] > ],
                 SLASH 0-dlist,
                 QUE 0-dlist ],
        PUNCT no_punctuation_min ] ].

; 'on vacation', 'in bed'

; DPF 26-aug-07 - Don't know why this is here, but it's not good, since it
; licenses unification of abstr_lex_synsem and phr_synsem. So commented out.
;
; prep_p_mod_phr_synsem := prep_p_mod_synsem & phr_synsem.

prep_nomod_phr_synsem := phr_synsem &
  [ LOCAL [ CAT [ HEAD prep & [ TAM #tam,
                                MOD < > ],
                  VAL [ SUBJ < >,
                        COMPS #comps ] ],
            CONT.RELS.LIST < relation & [ PRED norm_rel,
                                          ARG0.E #tam ], ... >,
            ARG-S #comps ] ].

; FIX - should not be asking for COMPS..COMPS..LTOP :)
p_ap_i_le := basic_prep_word &
  [ INFLECTD +,
    SYNSEM basic_prep_nomod_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ MINORS.MIN _as_p_comp_rel,
                     PRD - ],
              VAL [ SPR < unexpressed >,
                    COMPS < [ LOCAL 
                              [ CAT [ HEAD adj,
                                      VAL.COMPS
                                           < unexpressed &
                                             [ LOCAL.CAT.HEAD prep ],
                                             unexpressed &
                                             [ LOCAL.CONT.HOOK.LTOP #mltop] >],
                                CONT.HOOK [ LTOP #ltop,
                                            INDEX #index,
                                            XARG it-ind ],
                                CONJ cnil ],
                              LEX +,
                              NONLOC non-local_none ] > ],
              HC-LEX - ],
        CONT [ HOOK [ LTOP #ltop,
                      INDEX #index ],
               RELS <! basic_arg12_relation & #keyrel &
                     [ PRED prep_rel],
                     arg1_relation &
                     [ LBL #ehand,
                       ARG0.SF prop,
                       PRED ellipsis_rel ] !>,
               HCONS <! qeq & [ HARG #mltop,
                                LARG #ehand ] !> ],
        CONJ cnil ],
      NONLOC [ SLASH 0-dlist,
               REL 0-dlist,
               QUE 0-dlist ],
      LKEYS [ KEYREL #keyrel &
                     [ LBL #ltop,
                       ARG0.E [ TENSE nontense,
                                ASPECT no_aspect ] ],
              --+ARGIND it-ind ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DETERMINERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Determiners must have the MIN relation be the quantifier, since nouns
; select their determiner in part based on the type of the quantifier rel.
; The basic determiner synsem has a non-null value for its specifier; this is 
; to account for cases like "nearly all books, only his book, exactly which
; book, almost every book".  
;
; Quantifiers need to accommodate expressions like
; 'almost every book'.  One might expect to have the degree_rel of 'almost'
; take the handle of 'every' as its ARG1 value, but this may interfere with 
; the treatment of scope which needs to identify the set of quantifier handles.
; So we do this by adding separate lexical entries for these det-specs.
; DPF 8-Jun-03 - Removed COMPS < > from basic_det_synsem, since want to allow
; possibility of non-empty comps (e.g. for "a/an" as in "an hour and a half"
; analogous to "as tall as kim"
; DPF 17-jun-07 - Restored COMPS < >, since this "a/an" is now an adjective

basic_det_synsem := nomod_synsem &
  [ LOCAL [ CAT [ HEAD det & [ MINORS.MIN #pred ],
		  VAL [ SPR < [ --MIN degree_rel,
                                LOCAL.CAT.HEAD adv,
                                NONLOC [ QUE 0-dlist,
                                         REL 0-dlist ],
				OPT + ] >, 
			SPEC < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #pred,
                                         CONT.HOOK [ LTOP #nhand,
                                                     INDEX #index ] ] ] >,
                        COMPS < >,
                        SPCMPS < > ] ],
	    CONT nom-obj &
		[ HOOK.INDEX #index,
		  RELS.LIST < quant_or_wh_relation & #keyrel &
                              [ ARG0 #index,
                                RSTR #rhand ], ... >,
                  HCONS.LIST < qeq &
				[ HARG #rhand,
				  LARG #nhand ], ... > ],
	    ARG-S < > ],
    LKEYS.KEYREL #keyrel ].

norm_det_synsem := basic_det_synsem & 
  [ LOCAL.CAT [ HEAD.MINORS.MIN #min,
                VAL.SPR < [ LOCAL.CONT.HOOK.LTOP #lbl ] > ],
    LKEYS.KEYREL [ LBL #lbl,
                   PRED #min ] ].

nonpart_det_synsem := norm_det_synsem.

det_synsem := nonpart_det_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

basic_part_det_synsem := norm_det_synsem.

part_det_synsem := basic_part_det_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

part_det_synsem_nonwh := part_det_synsem & 
  [ NONLOC.QUE 0-dlist ].

; DPF 21-Nov-01 - Removed BV..DIV -* and AGR.DIV -: last Christmas
next_last_det_synsem := nonpart_det_synsem &
  [ LOCAL [ CAT [ HEAD [ POSS -,
                         MINORS.MIN def_implicit_q_rel ],
                  VAL [ SPEC < [ LOCAL [ CAT [ HEAD.MINORS 
                                                    [ MIN temp_abstr_rel,
                                                      ALTMIN norm_rel ],
                                               VAL.COMPS < > ],
                                         CONT.HOOK.LTOP #nhand ],
                                 MODIFD notmod ] >,
                        COMPS < > ] ],
	    CONT [ RELS <! [ PRED def_implicit_q_rel,
                             ARG0 #ind & [ PNG png & [ PN 3s ] ] ],
			    relation & #altkeyrel &
			    [ LBL #nhand,
			      ARG1 #ind ] !>,
		   HCONS <! qeq !> ],
            AGR.PNG.PN 3s ],
    NONLOC.QUE 0-dlist,
    MODIFD hasmod,
    LKEYS.ALTKEYREL #altkeyrel ].

basic_det_word :< word.
abstr_det_word := basic_det_word & que_word.
det_word := abstr_det_word &
  [ SYNSEM det_synsem & [ LOCAL.CAT.HEAD.POSS - ] ].

; DPF 15-Apr-03 - ALTMIN allows most determiners to appear with day-part nouns
; like 'morning' as VP modifiers, as in 'i arrive every morning' but not
; 'I arrive the morning'
; DPF 06-dec-03 - Moved constraint PN 3s down but leave DIV - so we can allow
; coordination in "every dog and cat" where the nbar is PN 3p, but not
; constrained for DIV.  Still blocking "*every dogs"

det_word_sing := det_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                     AGR.DIV - ],
             NONLOC.QUE 0-dlist,
             LKEYS.KEYREL.ARG0.DIV - ] ].

basic_det_word_nonque := det_word &
  [ SYNSEM.NONLOC.QUE 0-dlist ].
det_word_nonque := basic_det_word_nonque &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ RELS <! relation !>,
                          HCONS <! qeq !> ] ] ].

det_pl_lexent := det_word_nonque &
  [ SYNSEM [ LOCAL [ AGR.PNG.PN 3p,
                     CAT.HEAD.MINORS.ALTMIN dofw_or_poss_q_rel ],
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ],
             MODIFD hasmod ] ].

d_-_pl_le := det_pl_lexent.

; 'another two chairs' but '*another chairs'
d_-_pl-modn_le := det_pl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ MODIFD lmod ] > ].

d_-_sgm_le := det_word_nonque &
  [ SYNSEM [ LOCAL.AGR.PNG.PN 3s,
             LKEYS.keyrel.ARG0.PNG png & [ PN 3s ],
	     MODIFD hasmod ] ].

; 'zero effect'
d_-_m_le := det_word_nonque &
  [ SYNSEM [ LOCAL.AGR.PNG.PN 3s,
             LKEYS.keyrel.ARG0 [ PNG png & [ PN 3s ],
                                 DIV + ] ] ].

; DPF 8-may-04 - Restricted SPEC..MIN to non_day_rel to block spurious parse 
; for "next tuesday"
d_-_next_le := abstr_det_word &
  [ SYNSEM next_last_det_synsem & 
	   [ LOCAL.CAT.VAL.SPEC < [ --MIN non_day_rel ] > ] ].

d_-_last_le := abstr_det_word &
  [ SYNSEM next_last_det_synsem ].

; "yesterday morning, tomorrow afternoon"
d_-_proxday_le := abstr_det_word &
  [ SYNSEM next_last_det_synsem & 
	   [ LOCAL.CAT.VAL.SPEC < [ --MIN day_part_rel ] > ] ].

; "all month", "all day" - FIX - not yet blocking "*all October, *all Tuesday"
d_-_all-tm_le := abstr_det_word &
  [ SYNSEM next_last_det_synsem ].

; DPF 20-Feb-01 - Use SPEC..ALTMIN to block det-N analysis of 
; "both kim and sandy"
; DPF 11-Mar-02 - Use ALTMIN to block phrasal partitive-NP rule

basic_pdet_word_nonque := abstr_det_word &
  [ SYNSEM part_det_synsem_nonwh &
      [ LOCAL [ CAT.HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                CONT [ RELS.LIST < quant_or_wh_relation, ... >,
                       HCONS <! qeq !> ] ],
        NONLOC.QUE 0-dlist,
        MODIFD hasmod ] ].

pdet_word_nonque := basic_pdet_word_nonque &
  [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].

; 'any'
d_-_prt_le := pdet_word_nonque &
  [ SYNSEM.LOCAL.CAT.NEGPOL + ].

; DPF 19-Oct-02 - Would like to make DIV +* not + to allow coordination of 
; unlike NPs ("my book and some other stuff"), but then we can't block
; spurious "some programmer" whose DIV value ends up +_and_-.  An example
; of problems with this overspecification approach to coordination.

; some
d_-_prt-div_le := pdet_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ VAL.SPR < [ --MIN just_only_deg_rel ] >,
			 NEGPOL - ],
             LKEYS.KEYREL.ARG0.DIV + ] ].

; For "another one/two (of the chairs)"
; Still don't have analysis for "another two chairs" (cf. "*another chairs")
d_-_prt-anthr_le := pdet_word_nonque &
  [ SYNSEM 
    [ LOCAL.CAT.VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                      SPEC < [ --MIN part_nom_rel ] > ],
      LKEYS.KEYREL.ARG0.DIV + ] ].

; DPF 06-dec-03 - Removed constraint PN 3s but leave DIV - so we can allow
; coordination in "another time and date" where the nbar is PN 3p, but not
; constrained for DIV.  Still blocking "*another chairs"
d_-_prt-sg_le := pdet_word_nonque &
  [ SYNSEM [ LOCAL.AGR.DIV -,
             LKEYS.KEYREL.ARG0.DIV - ] ].

d_-_prt-sgm-nag_le := pdet_word_nonque &
  [ SYNSEM [ LOCAL.AGR [ PNG.PN 3s,
                         DIV + ],
             LKEYS.KEYREL [ PRED explicit_quant_noagr_q_rel,
                            ARG0 [ PNG png & [ PN 3s ],
                                   DIV + ] ] ] ].

det_part_pl-or-m_lexent := basic_pdet_word_nonque &
  [ SYNSEM [ LOCAL.CONT [ RELS.LIST < [ ARG0 #arg0 ],
                                      #altkeyrel &
                                      [ LBL #lbl,
                                        ARG0 event & [ E [ TENSE no_tense,
                                                         ASPECT no_aspect ] ],
                                        ARG1 #arg0 ], ... >,
			  HCONS <! [ LARG #lbl ] !> ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

d_-_prt-pl_le := det_part_pl-or-m_lexent &
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3p,
		   CONT.RELS <! [ PRED udef_q_rel,
				  ARG0.PNG png & [ PN 3p ] ],
			        relation !> ] ].

d_-_prt-more_le := det_part_pl-or-m_lexent &
  [ SYNSEM.LOCAL [ AGR.DIV +,
		   CONT.RELS <! [ ARG0.DIV + ],
			        [ PRED much-many_a_rel, LBL #lbl, ARG0 #e ],
			        [ PRED comp_rel,
				  LBL #lbl,
				  ARG0 event & [ E [ TENSE no_tense,
						     ASPECT no_aspect ] ],
				  ARG1 #e ] !> ] ].

d_-_prt-pl-both_le := basic_pdet_word_nonque &
  [ SYNSEM [ LOCAL [ AGR.PNG.PN 3p,
                     CONT [ HOOK.INDEX #index,
                            RELS <! relation, [ LBL #lbl,
                                                PRED card_rel,
                                                ARG0 event & 
                                                    [ E [ TENSE no_tense,
                                                          ASPECT no_aspect ] ],
                                                ARG1 #index,
                                                CARG "2" ] !>,
                            HCONS <! qeq & [ LARG #lbl ] !> ] ],
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ] ].

; This assumes (falsely) that all plurals are divisible (cf "oats", "clothes")
; It also incorrectly blocks coordinations like "Kim and all children" since 
; the alternative (DIV +) would fail to block "all book".
; DPF 28-oct-03 - Added LEX + to block e.g. "a person all of us" as hd-spec.
; DPF 01-may-04 - Changed SPR..MIN from very_deg_rel to just_only_deg_rel

det_part_pl_mass_lexent := pdet_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ --MIN just_only_deg_rel,
                                     LEX + ] >,
                     AGR.DIV + ],
             LKEYS.KEYREL.ARG0.DIV +,
             MODIFD hasmod ] ].

d_-_prt-plm_le := det_part_pl_mass_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_quant_agr_q_rel ].

d_-_prt-plm-unsp_le := det_part_pl_mass_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_q_rel ].

d_-_prt-plm-nag_le := det_part_pl_mass_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_quant_noagr_q_rel ].

d_-_prt-unsp_le := abstr_det_word &
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD.POSS -,
		     CONT [ RELS <! quant_or_wh_relation !>,
			    HCONS <! qeq !> ] ],
	     NONLOC.QUE 1-dlist &
		           [ LIST < param > ],
             LKEYS.KEYREL.PRED which_q_rel ] ].

; DPF 10-May-00 - We add subtypes of determiners to distinguish "We met every 
; week" from "*We met the week".  The distinction makes use of the feature 
; MODIFD, where the head-specifier rule's mother's MODIFD value is 
; determined by the specifier daughter, so each specifier has to say whether it
; passes on the MODIFD value from its head, or supplies its own.  Thus "the"
; assigns its own value,"every" supplies its own 'hasmod' 
; value, and "a" supplies the opposite value "notmod", to block "*Kim arrived 
; a big week".

; 'no'
d_-_no_le := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                         VAL.SPEC < [ MODIFD #modif ] >,
			 NEGPOL + ],
             LKEYS.KEYREL.PRED no_q_rel,
             MODIFD #modif ] ].


; 'some'
d_-_ndiv_le := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                         VAL.SPEC < [ MODIFD #modif ] > ],
             LKEYS.KEYREL [ PRED some_q_rel,
                            ARG0.DIV - ],
             MODIFD #modif ] ].

; 'the'
; DPF 2-May-03 - Divide this type into two subtypes, one [MODIFD notmod]
; and one [MODIFD lmod] to support the treatment of VP-modifying NPs with
; the following pattern of grammaticality:
;   Kim arrived the first week
;  *Kim arrived the week
;   Kim arrived the week Sandy left
;   Kim arrived the week of the party
;  *Kim arrived week of the party
;
; DPF 27-May-03 - See discussion in syntax.tdl's npadv_mod_rule for why we
; considered and then abandoned two separate entries for "the".
; DPF 03-dec-03 - Replaced ALTMIN no_rel with dofw_or_poss_q_rel in
; order to get "on the weekend".  But then get two parses for "the night",
; so go back to no_rel.
; DPF 19-sept-07 - Since 'no_rel' blocked "the day we arrived", changed this
; ALTMIN to _the_q_rel, which is compatible with extracted-napdv construction.

d_-_the_lexent := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN _the_q_rel,
                         VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                               SPEC < [ MODIFD #mod ] > ],
			 NEGPOL - ],
             LKEYS.ALTKEYREL.PRED no_rel,
             MODIFD #mod ] ].

d_-_the_le := d_-_the_lexent.

; For "the the"
d_-_the-rbst_le := d_-_the_lexent &
  [ GENRE robust ].

; 'half the time'
det_word_modable := det_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                           VAL.COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             MODIFD hasmod ] ].

d_-_wh_le := det_word_modable &
  [ SYNSEM [ LKEYS.KEYREL.PRED which_q_rel,
	     NONLOC.QUE 1-dlist &
			   [ LIST < param > ] ] ].

; 'a/an'
; DPF 15-Nov-01 - Removed [SPR <anti_synsem_min>] since this blocke "more than 
; a week ago"
; DPF 12-nov-05 - Removed 3s constraint from ARG0, since want to allow 
; "A number who sing also dance." where the semantic index is plural,
; but the syntactic agreement is still singular.
; DPF 30-sept-06 - Changed MODIFD notmod to instead identify value with that
; of SPEC.MODIFD, in order to get e.g. "We arrived a week after you."

det_sg_nomod_lexent := det_word_sing &
  [ SYNSEM [ LOCAL 
             [ CAT [ VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			   SPEC < [ MODIFD #modif ] >,
			   COMPS < > ],
		     NEGPOL - ],
               AGR.PNG.PN 3s,
               CONT [ RELS <! relation !>,
                      HCONS <! qeq !> ] ], 
             MODIFD #modif,
             LKEYS.KEYREL.PRED some_q_rel ] ].

d_-_sg-nmd_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_unk ] > ].

d_-_sg-nmd-an_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc_or_unk ] > ].

d_-_sg-a-rbst_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc ] >,
    GENRE robust ].

d_-_sg-an-rbst_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con ] >,
    GENRE robust ].

det_sg_lexent := det_word_sing &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR < [ --MIN very_deg_rel ] >,
                               COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             MODIFD hasmod,
             LKEYS [ KEYREL.LBL #lbl,
                     ALTKEYREL.LBL #lbl ] ] ].

; 'every'
d_-_sg-every_le := det_sg_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < [ --MIN just_only_very_deg_rel ] >,
             LKEYS.KEYREL.PRED every_q_rel ] ].

; We make the non-quantifier relation generically pron_rel, and have each
; individual pronoun simply constrain the ARG0 index of that pron_rel.
;   This type is used for both WH "whose" and relative "whose", so it leaves 
; both  QUE  and  REL  values unspecified, but supplies all other defaults.
; DPF 24-aug-06 - Added ALTMIN no_rel to block possessive determiners from
; combining with e.g.day-of-month nouns as in  "*My five is booked."

poss_word := noncs-m-nab & basic_det_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ POSS +,
                                MINORS.ALTMIN no_rel ],
                         VAL.COMPS < > ],
		   CONT nom-obj &
			[ HOOK.INDEX #index,
			  RELS.LIST < relation,
                                      prep_relation &
                                      [ PRED poss_rel,
                                        ARG0.E [ TENSE no_tense,
                                                ASPECT no_aspect ],
                                        ARG1 #index ], ... > ] ] ].

; ERB (31-10-96) See notes near n_wh_pro_le.

d_-_wh-poss_le := poss_word &
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN def_implicit_q_rel,
                           VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #nhand ] > ],
		     CONT [ RELS <! #keyrel & [ PRED def_implicit_q_rel ],
                                    [ LBL #nhand,
                                      ARG2 #ind ],
				    [ LBL #phand,
                                      PRED person_rel,
                                      ARG0 #ind ],
                                    [ ARG0 #ind,
                                      PRED which_q_rel,
                                      RSTR #rhand2 ] !>,
			    HCONS <! qeq, 
                                     qeq &
                                     [ HARG #rhand2,
                                       LARG #phand ] !> ] ],
             LKEYS.KEYREL #keyrel,
	     NONLOC [ REL 0-dlist,
                      QUE 1-dlist &
			   [ LIST < param > ] ] ] ].

; DPF 17-dec-03 - Added HS-LEX + to avoid sentence "*about my arrives"

nonwh_poss_word := poss_word &
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN def_explicit_q_rel,
                           VAL.SPR < [ --MIN just_only_deg_rel ] >,
                           HS-LEX + ],
                     CONT [ RELS.LIST < relation, #altkeyrel, ... >,
                            HCONS.LIST < qeq, ... > ] ],
             NONLOC.QUE 0-dlist,
             LKEYS [ KEYREL.PRED def_explicit_q_rel,
                     ALTKEYREL #altkeyrel ] ] ].

det_poss_lexent := nonwh_poss_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #hand ] >,
                     CONT [ HOOK.XARG #ind,
			    RELS <! relation,
                                  [ LBL #hand,
                                    ARG2 #ind ],
                                  [ PRED pronoun_q_rel,
                                    RSTR #rhand,
                                    ARG0 #ind ],
				  [ LBL #prohand,
                                    PRED pron_rel,
                                    ARG0 #ind &
                                        [ PRONTYPE std_pron,
                                          SORT entity ] ] !>,
                            HCONS <! qeq, qeq & [ HARG #rhand,
                                                  LARG #prohand ] !> ] ],
             NONLOC.REL 0-dlist ] ].

d_-_poss-her_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
                             [ ARG0 [ PNG png & [ PN 3s,
                                                  GEN fem ],
                                      PRONTYPE std_pron ] ] !> ].
d_-_poss-his_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3s,
						    GEN masc ],
					PRONTYPE std_pron ] ] !> ].

; DPF 26-sept-04 - Temporary solution until we add determiner coordination,
; at least.
d_-_poss-his-her_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
                             [ ARG0 [ PNG png & [ PN 3s,
                                                  GEN andro ],
                                      PRONTYPE std_pron ] ] !> ].

d_-_poss-its_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3s,
						    GEN neut ],
					PRONTYPE std_pron ] ] !> ].
d_-_its-rbst_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3s,
						    GEN neut ],
					PRONTYPE std_pron ] ] !>,
    GENRE robust ].

d_-_poss-my_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1s ],
					PRONTYPE std_pron ] ] !> ].
d_-_poss-our_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1p ],
					PRONTYPE std_pron ] ] !> ].
d_-_poss-their_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3p ],
					PRONTYPE std_pron ] ] !> ].
d_-_poss-your_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 2 ],
					PRONTYPE std_pron ] ] !> ].

d_-_poss-rel_le := nonwh_poss_word &
  [ SYNSEM [ LOCAL.CONT [ RELS <! relation,
                                [ LBL #hand,
                                  ARG2 #ind ] !>,
                          HCONS <! qeq !> ],
	     NONLOC.REL 1-dlist &
			   [ LIST < [ LTOP #hand,
				      INDEX #ind ] > ] ] ].


; 'of mine'
det_nospec_synsem := nomod_synsem.
det_poss_nospec_lexent := basic_det_word & noncrs-m-nab &
  [ SYNSEM det_nospec_synsem &
           [ LOCAL [ CAT [ HEAD det & [ POSS +,
                                        MINORS [ MIN implicit_q_rel,
                                               ALTMIN poss_rel ] ],
                           VAL [ SPR < anti_synsem_min >,
                                 SPEC < anti_synsem_min >,
                                 COMPS < > ] ],
                     CONT [ HOOK.INDEX #ind,
                            RELS <! [ PRED pronoun_q_rel,
                                      RSTR #rhand,
                                      ARG0 #ind ],
                                  [ LBL #prohand,
                                    PRED pron_rel,
                                    ARG0 #ind &
                                        [ PRONTYPE std_pron,
                                          SORT entity ] ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !> ] ],
             NONLOC non-local_none ] ].

d_-_poss-mine_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 1s ] !> ].

d_-_poss-ours_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 1p ] !> ].

d_-_poss-yours_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 2 ] !> ].

d_-_poss-his-ns_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG [ PN 3s,
                                                     GEN masc ] ] !> ].

d_-_poss-hers_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG [ PN 3s,
                                                     GEN fem ] ] !> ].

d_-_poss-theirs_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 3p ] !> ].

; 'preposition' "a/an" for predicative NPs, as in "It is a (real/rare) 
; pleasure to visit Oslo" and "Oslo is a pleasure to visit"

pred_a_prep_lexent := word &
  [ SYNSEM synsem &
    [ LOCAL [ CAT [ HEAD prep &
                         [ PRD +,
                           MOD < anti_synsem &
                                 [ LOCAL intersective_mod ] >,
                           TAM #tam & [ TENSE tense ],
                           MINORS.MIN pred_a_rel ],
                    VAL [ SPR < >, 
                          SUBJ < >,
                          COMPS < [ --MIN prednom_rel,
                                    LOCAL [ CAT 
                                             [ HEAD noun &
                                                    [ POSS - ],
                                               VAL [ SUBJ < >,
                                                     COMPS < > ],
                                               MC na ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #index,
                                                        XARG #xarg ] ],
                                    NONLOC non-local_none &
                                          [ SLASH.LIST < > ],
                                    OPT - ] > ],
                    MC na ],
              CONT [ HOOK [ LTOP #ltop,
                            INDEX #event & event & [ E #tam ],
                            XARG #xarg ],
                     RELS <! #keyrel & quant_or_wh_relation, 
                             arg1_relation & 
                             [ LBL #ltop,
                               PRED prednom_state_rel,
                               ARG0 #event,
                               ARG1 #index ] !>,
                     HCONS <! qeq &
                             [ HARG #rhand,
                               LARG #nhand ] !> ],
              CONJ cnil,
              ARG-S < > ],
      LKEYS.KEYREL #keyrel & [ PRED some_q_rel,
                            ARG0 #index,
                            RSTR #rhand ],
      NONLOC [ SLASH 0-dlist,
               QUE 0-dlist,
               REL 0-dlist ] ],
    INFLECTD + ].

p_np_i-prd-a_le := pred_a_prep_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET con_or_unk ] > ].

p_np_i-prd-an_le := pred_a_prep_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET voc_or_unk ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Free relatives
;
; One crucial property of free relatives is that they have a non-empty QUE
; value whose single list element is an index (rather than the param which
; is employed for ordinary question WH-words).
; The other is that they encode the constraints for their S/XP sister in the
; free-relative construction, in their SLASH attribute.

free_rel_pro_word := noncr-hm-nab & basic_pronoun_word &
  [ SYNSEM synsem &
	   [ LOCAL [ CAT [ HEAD partn & [ MOD < > ],
			   VAL [ SPR < [ --MIN just_only_deg_rel,
					 LOCAL [ CAT.HEAD adv,
						 CONT.HOOK.LTOP #lbl ],
					 NONLOC [ QUE 0-dlist,
						  REL 0-dlist ] ],
				       anti_synsem_min & [ OPT - ] >,
				 SUBJ < >,
				 COMPS < >,
				 SPEC < > ] ],
		     AGR #ind,
		     CONT [ HOOK [ INDEX non_expl-ind & #ind & [ PNG.PN 3s ],
                                   XARG #nhand ],
			    RELS.LIST < [ LBL #lbl,
                                          PRED basic_free_relative_q_rel,
                                          ARG0 #ind,
                                          RSTR #rhand ], 
                                        [ LBL #nhand,
                                          ARG0 #ind ], ... >,
			    HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !> ],
		     ARG-S < > ],
	     NONLOC [ REL 0-dlist,
                      QUE 1-dlist & <! #ind !>,
                      SLASH 1-dlist &
                          <! [ CAT.VAL.COMPS < >,
                               CONJ cnil ] !> ] ] ].

; whatever, whoever
; DPF 20-Aug-01 - Added SLASH..PRD - to block "what my offers are" with 
; predicative copula.

n_freerel_pro_lexent := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ PRD -,
                                MINORS [ MIN reg_nom_rel & #pred,
                                         ALTMIN free_relative_ever_q_rel ] ],
		     CONT [ HOOK.INDEX #ind & [ PNG.PN 3s,
                                                SORT entity ],
                            RELS <! relation & #altkeyrel, #keyrel !> ] ],
             LKEYS [ KEYREL #keyrel & [ PRED #pred ],
                     ALTKEYREL #altkeyrel ],
	     NONLOC.SLASH 1-dlist &
                   <! [ CAT.HEAD noun & [ MOD < >,
                                          PRD - ],
                        CONT.HOOK.INDEX #ind,
                        AGR non_expl-ind & [ PNG.PN 3s ] ] !> ] ].

; DPF 25-aug-07 - Need to leave underspecified for PN: "We bought what we
; thought were the right amounts"
n_-_pr-fr_le := n_freerel_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_q_rel ].
                                          
n_-_pr-fr-ever_le := n_freerel_pro_lexent &
  [ SYNSEM [ LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel,
             NONLOC.SLASH <! [ AGR.PNG.PN 3s ] !> ] ].

; when, where
; DPF 15-Apr-02 - Added SLASH..VAL.SUBJ..INDEX #arg to accommodate predicative
; 'be' as in "Find where Kim is"
; DPF 19-Oct-02 - Removed PRD - since need to allow head_adj_phr to have 
; adjunct be PRD +.
; DPF 06-sept-07 - Added INDEX.SORT location to prevent these from appearing
; as non-heads in appositives.
; DPF 07-apr-08 - But this blocks coord with other free rels, as in
; "we admired what he said and where he'd been."  So instead try constraining
; ALTMIN to non_freerel_rel, replacing nonpro_rel.

n_freerel_pro_adv_lexent := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN #min,
				       ALTMIN free_relative_q_rel,
				       NORM prep_mod_rel ],
		     CONT [ RELS <! relation, 
                                   #keyrel & [ ARG0 #ind ],
                                   #alt2key &
                                   [ LBL #lochand,
                                     PRED prep_mod_rel,
                                     ARG0 [ E [ TENSE no_tense,
                                                 ASPECT no_aspect ] ],
                                     ARG1 #arg,
                                     ARG2 #ind ] !> ] ],
             LKEYS [ KEYREL #keyrel & [ PRED #min ],
                     ALTKEYREL #keyrel,
                     ALT2KEYREL #alt2key ],
	     NONLOC.SLASH 1-dlist &
                   <! [ CAT.HEAD prep & 
                                 [ MOD < synsem &
                                         [ --SIND #arg ] > ],
                        CONT.HOOK [ LTOP #lochand,
                                    XARG #arg ] ] !> ] ].

n_-_pr-fr-wh_le := n_freerel_pro_adv_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_q_rel ].

n_-_pr-fr-whever_le := n_freerel_pro_adv_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel ].

; DPF 10-jul-04 - Replacing SLASH..HEAD n_or_p with noun since we don't want
; an extracted adjunct reading for e.g. "kim chases whichever cats bark".
; To still get "kim stays at whichever place he lands", maybe we have to
; make two separate entries for "whichever" - one a simple determiner
; which would in principle allow either NP or PP (maybe appropriately
; constrained ...), and the other the partitive which only allows NP slash.
; FIX ...

free_rel_det_word_gen := noncr-hm-nab &
  [ SYNSEM norm_det_synsem & 
	   [ LOCAL [ CAT [ HEAD.POSS -,
			   VAL [ SPEC < [ LOCAL.CONT.HOOK.LTOP #althand ] >,
                                 COMPS < > ] ],
                     CONT [ RELS <! [ PRED basic_free_relative_q_rel,
                                      ARG0 #arg0 ] !>,
			    HCONS <! qeq !> ] ],
             LKEYS.ALTKEYREL.LBL #althand,
	     NONLOC [ QUE 1-dlist &
			     [ LIST < index  > ],
			 SLASH 1-dlist &
			     <! [ CAT.HEAD noun & [ MOD < > ],
                                  CONT.HOOK.INDEX #arg0 ] !> ] ] ].

; whatever, what
; DPF 25-Nov-03 - Removed [SLASH..CASE acc] since also want "whichever books
; arrived".

d_-_freerel_le := free_rel_det_word_gen &
  [ SYNSEM det_synsem & 
           [ LOCAL [ CAT [ HEAD [ POSS -,
                                  MINORS.ALTMIN no_rel ],
                           VAL.COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             LKEYS.ALTKEYREL.PRED no_rel ] ].

; whichever
n_-_pr-fr-part_le := free_rel_det_word_gen &
  [ SYNSEM part_det_synsem ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Possessives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Possessive "'s" takes an NP[-Poss] specifier and projects either an
;; NP[+Poss] phrase (for "the book of Kim's") or a DetP[+Poss] phrase (for
;; "Kim's book").  Either way, the content of the possessive phrase will be a
;; definite possessive quantifier.  The NP[+Poss] things also work pretty well
;; for things like "Kim's is under the desk" if we allow governed NPs to be
;; +Poss.  The tricky thing will be figuring out exactly where `bare
;; possessives' can show up.  Also, we need to add the restriction that the SPR
;; must be non-pronominal.  We cannot simply make the synsem of the SPR be
;; the type nonpronominal, since that NP might be either lexical or phrasal,
;; distinguished by the synsem types lex_synsem and phr_synsem.  So we use
;; the semantic MIN relation to identify nonpronominals.

;; Another question is what do we do with the scope
;; of quantifiers in the possessor?  This entry assumes that they always have
;; narrow scope.  That should be an empirical question, as the saying goes.
; DPF 10-oct-04 - Added SPR..CASE non_obliq constraint to exclude reflexive 
; pronouns as in "*ourselves's chairs arrived", while still allowing
; reciprocals, as in "we hired each other's consultants."
; DPF 18-Nov-04 - Added SPR..PRD + to require that proper NPs be INFLECTD +,
; possible since the proper_np rule identifies PRD and INFLECTD.  This is
; needed since proper-NPs need to be [INFLECTD -] for NP-N-cmpnd rule which
; is also used for measure-NP compounds like "ten foot wall" (cf "*ten feet
; wall"); and further, the hspechc rule must leave the non-hd-dtr unspecified
; for INFLECTD since this rule is used to build "ten foot high (wall)", as
; well as the possessive phrase "kim 's".  Since the value of SPR is a list
; of synsems (with no access to the INFLECTD value), we smuggle in the
; needed constraint by coercing the otherwise unused feature PRD on proper
; NPs (note in defense that this same identity of PRD and INFLECTD is used
; legitimately in measure-NPs).

basic_n_poss_clitic_lexent := nonc-m-nab &
  [ ALTS.SQPNCT -,
    SYNSEM lex_synsem &
     [ LOCAL [ ARG-S < #spr >,
	       CAT [ HEAD det &
			  [ POSS +,
                            MOD < >,
                            MINORS.ALTMIN poss_rel ],
                     VAL [ SUBJ < >,
                           SPR < #spr & synsem &
                                 [ --MIN nonpro_rel,
                                   LOCAL [ CAT nomp_cat_min &
                                               [ HEAD.PRD +,
                                                 VAL.SPCMPS < > ],
                                           CONT.HOOK.INDEX index,
                                           CONJ cnil ],
                                   NONLOC [ SLASH #slash,
                                            REL #rel,
                                            QUE #que ],
                                   --SIND #pindex & individual_min,
                                   OPT - ] >,
                           COMPS < > ] ],
               CONT.HOOK [ INDEX #index,
			   XARG #pindex ] ],
       LKEYS.ALTKEYREL prep_relation &
             [ PRED poss_rel,
               ARG0.E [ TENSE no_tense,
                        ASPECT no_aspect ],
               ARG1 #index,
               ARG2 #pindex ],
       NONLOC [ SLASH #slash,
                REL #rel,
                QUE #que ] ] ].

n_poss_clitic_lexent := basic_n_poss_clitic_lexent &
  [ SYNSEM lex_synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN def_explicit_q_rel,
                     VAL.SPEC < [ LOCAL.CONT.HOOK [ LTOP #phand,
                                                    INDEX #index ] ] > ],
	       CONT [ HOOK.INDEX #index,
                      RELS <! #keyrel & [ PRED def_explicit_q_rel,
                                       ARG0 #index,
                                       RSTR #rhand ],
                              #altkeyrel !>,
		      HCONS <! qeq & [ HARG #rhand,
                                       LARG #phand ] !> ] ],
       LKEYS [ KEYREL #keyrel,
               ALTKEYREL #altkeyrel & [ LBL #phand,
                                     ARG1 #index ] ] ] ].

n_-_cl-poss_le := n_poss_clitic_lexent.
n_-_cl-poss-pl_le := n_poss_clitic_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --SIND.PNG.PN 3p ] > ].

; For "That dog of Kim's barks."
n_-_cl-poss-nq_le := basic_n_poss_clitic_lexent &
  [ SYNSEM lex_synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN implicit_q_rel,
                     VAL [ SPR < [ LOCAL.CONT.HOOK #hook ] >,
                           SPEC < anti_synsem > ] ],
	       CONT [ HOOK #hook,
                      RELS <! !>,
		      HCONS <! !> ] ],
       LKEYS.KEYREL.PRED no_rel ] ].

; Should eventually constrain this based on a PHON.FINAL feature to allow
; "Abrams' chairs" but block "Browne' chairs".  Overgenerate for now.
n_-_cl-poss-pr_le := n_poss_clitic_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --MIN named_rel,
                                 --SIND.PNG.PN 3s ] > ].

;; The possessive "of" takes an NP[+Poss] complement (e.g., "Kim's", "mine")
;; and modifies an N'[-Poss].  Unfortunately, the way the hierarchy of
;; preposition types is built, there wasn't any type this could inherit from.
;; We could probably rearrange things so this inherits some preposition
;; properties, but right now I'm too lazy.  Also, somehow we'll have to make
;; sure that this doesn't modify a pronoun.  The semantic manipulation here is
;; tricky - keep your eyes on the definite quantifier.  This def_implicit_q_rel
;; provided by the apostrophe-s (for its other life as a determiner), is 
;; dropped by the possessive-of, analogous to nouns, verbs, and adjectives 
;; dropping the semantics of the prepositions that can mark their complements.
;; This dropping of the relation is effected by having the possessive-of 
;; neglect to grab the handle of the def_implicit_q_rel for its complement, 
;; but grab instead the handle (and instance variable) of the NP complement 
;; of the apostrophe-s.  Then the general semantic pruning mechanism will 
;; ignore the def_implicit_q_rel, since its handle will not be a value in any 
;; other relation.

one_arg_isect := one_arg & isect_synsem.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBORDINATING CONJUNCTIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; These are not restricted to modifying only main VPs, since e.g. "if" needs
; to take scope over modals as in "I'd be pleased if we made an appointment."
; This lack of constraint means there will be structural ambiguity for 
; if-clauses, but not spurious - get different scopes of "if" and modals.
; But we restrict them to modifying only finite VPs or imperatives.

; DPF (10-Jan-99) Changed these to modify S rather than VP, since they don't
; appear to survive extraction from embedded clauses, nor do they appear inside
; an extraposed subject relative clause.

; DPF (10-Jan-98) For some reason, can't make the HEAD value prep* - fails to
; unify with strict_type in "Kim sleeps if Sandy sleeps".  Solve later.

; DPF 02-Oct-00 Changed subconj_inf_synsem to modify S rather than VP, in 
; order to make semantics consistent with other subord rels.

; DPF 26-Apr-03 Our analysis prevented subordinating phrases from modifying
; embedded clauses, but clearly we need these for examples like "I wonder
; whether Sandy arrived before Kim left".  So relax MOD..CAT to s_cat_unspec
; and make the subord's MSG be that of its modifiee, to block e.g.
; "*I wonder Kim arrived before Sandy left".  And further relax MOD..CAT to
; allow modification of infinitival VPs as in "Kim didn't want to leave before
; Sandy arrived", which means also dropping [ MOD..E.TENSE real_tense].
; DPF 17-Jul-03 - Removed PRD - since it blocks "Kim arrives two weeks after
; Sandy leaves", given our analysis of measure-NPs.  Not clear what it was for.
; DPF 22-Nov-03 - Removed MOD..SLASH 0-dlist since want to also get "the chair
; (that) I'll buy if you like it is expensive" and "who did you say Kim would
; hire if we were supportive".
; DPF 25-Nov-03 - Added MOD..LPERIPH na_or_- to avoid spurious disc_adv reading
; for "hiring kim and firing sandy happened"
; DPF 7-Jun-04 - This constraint prevented desired analysis for "if kim 
; arrives then sandy arises", so instead only use it in subjconj_vp rule.
; DPF 18-jul-04 - Removed constraint of MOD..MSG message to allow these to
; modify VPs as well as S's, to get e.g. "I found a book to read before 
; Abrams arrives"
; DPF 26-mar-05 - Restricting MOD.HEAD to verbal blocked modification of
; verbal gerunds, such as "safe practices for using a phone while driving",
; so changed to HEAD v_or_g.  Also removed MOD..LEX - since this prevented
; "for singing while driving"
; DPF 14-aug-05 - Re 17-Jul-03: PRD - prevents "not happy" from being
; built spuriously as "not" modifying the subconj-prdp "happy".
; DPF 13-nov-05 - Added MOD..SPR *cons* to exclude complementizer-phrases,
; to avoid spurious ambiguity for e.g. "Kim tried to leave while we slept."
; DPF 04-may-06 - Removed MOD..SUBJ *cons* since this prevents attaching
; subord clauses in relative clauses, as in "The guy that leaves if we
; stay is famous."
; DPF 13-may-06 - FIX - strictly speaking, we should have two versions of
; the filler-head-non-wh rule, one root and one non-root, analogous to the
; two subject-head rules, since the root one incorporates the mood
; of the punctuation mark, while the non-root one would pass it up.
; Right now, we don't parse 'Arise, whereas in Paris we arrive.' since the
; subord-clause prematurely declares the mood to be prop, when
; it should stay underspecified in this clause, and then become comm
; at the root.
; DPF 24-apr-08 - Add MOD..MOD anti_synsem_min to block modification of
; relative clauses (spurious analyses)

basic_subconj_synsem := canonical_lex_or_phrase_synsem &
  [ LOCAL [ CAT [ HEAD prep &
		       [ MOD < synsem &
                               [ LOCAL scopal_mod &
				       [ CAT [ HEAD v_or_g &
						    [ MOD < anti_synsem_min >],
					       VAL.COMPS < >,
					       MC #mc ],
					 CONT [ HOOK [ LTOP #modltop,
                                                       INDEX #ind ] ],
                                         CONJ cnil ] ] >,
                         MINORS.MIN subord_rel ],
		  VAL.SUBJ < >,
                  MC #mc,
                  HC-LEX - ],
            CONT [ HOOK.INDEX #ind,
		   RELS.LIST < subord_relation &
                                [ ARG0 [ E [ TENSE no_tense,
                                             ASPECT no_aspect ] ],
                                  ARG1 #main ], ... >,
                   HCONS.LIST < qeq & [ HARG #main,
                                        LARG #modltop ], ... > ] ] ].

subconj_lex_synsem := basic_subconj_synsem &
  [ LOCAL [ CAT.VAL.SPR < [ --MIN just_only_deg_rel,
                            LOCAL [ CAT [ HEAD n_or_adv,
                                          VAL.SPR *olist* ],
                                    CONT.HOOK [ LTOP #sltop,
                                                XARG #arg0 ] ],
                            NONLOC.QUE 0-dlist,
                            OPT + ] >,
            CONT [ HOOK.LTOP #sltop,
                   RELS.LIST < [ LBL #sltop,
                                 ARG0 #arg0 ], ... > ] ] ].

basic_onearg_subconj_synsem := subconj_lex_synsem & basic_one_arg &
                               lex_synsem &
  [ LOCAL [ ARG-S #comps,
            CAT.VAL.COMPS #comps & < synsem &
                                     [ --MIN #cmin,
                                       NONLOC [ SLASH 0-dlist,
                                                REL 0-dlist,
                                                QUE 0-dlist ],
                                       OPT -,
                                       PUNCT [ LPUNCT no_punct,
                                               RPUNCT.PSF #iforce ] ] >,
            CONT [ HOOK.INDEX.SF #iforce,
                   RELS.LIST < #keyrel, ... > ] ],
    LKEYS [ KEYREL #keyrel,
            --COMPKEY #cmin ] ].

norm_onearg_subconj_synsem := basic_onearg_subconj_synsem &
  [ LOCAL.CAT.HEAD.PRD - ].

subconj_cp_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #cltop,
                                                INDEX event ],
                              NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                       QUE 0-dlist,
                                       REL 0-dlist ] ] >,
            CONT [ RELS <! relation &
                           [ ARG2 #subord ] !>,
                   HCONS <! qeq, qeq & [ HARG #subord,
                                         LARG #cltop ] !> ] ] ].

subconj_synsem := subconj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT s_cat_unspec & 
					[ MC -,
					  HEAD.VFORM fin ],
				    CONT.HOOK.INDEX.SF prop-or-comm ],
			    --SIND.E.TENSE real_tense ] > ].

subconj_ind_synsem := subconj_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin &
                                      [ HEAD.TAM.MOOD ind_or_modal_subj ]] > ].

#|
subconj_cp_nocop_synsem := subconj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD frag &
                                             [ TAM.TENSE no_tense ],
                                        VAL [ SUBJ *olist*,
                                              SPR *olist*,
                                              COMPS < > ],
                                        MC - ] ] > ].
|#

; 'Kim arrived, as did Abrams.'
subconj_cp_inv_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                            [ INV +,
                                              MINORS.ALTMIN ellipsis_rel ],
                                            VAL [ SUBJ < anti_synsem_min >,
                                                  COMPS < > ] ],
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX event ] ],
                              NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                       QUE 0-dlist,
                                       REL 0-dlist ] ] >,
            CONT [ RELS <! relation &
                           [ ARG2 #mtop ] !>,
                   HCONS <! qeq, qeq & [ HARG #mtop,
                                         LARG #cltop ] !> ] ] ].

; 'We'll stay as time permits'
; Restrict to nonaux subord clause, to avoid spurious ambig for id-copula
subconj_cp_gap_synsem := subconj_lex_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD.PRD -,
		  VAL.COMPS #comps &
                          < [ --MIN #cmin,
                              LOCAL [ CAT [ HEAD verb &
                                                 [ INV -,
                                                   AUX - ],
                                            VAL [ SUBJ < anti_synsem_min >,
                                                  COMPS < > ],
                                            MC - ],
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX event ] ],
                              NONLOC [ SLASH 1-dlist &
                                             <! [ CAT [ HEAD noun &
                                                             [ MOD < > ],
                                                        VAL.SPR *olist* ]] !> ,
                                       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT -,
                              PUNCT [ LPUNCT no_punct,
                                      RPUNCT.PSF #iforce ] ] > ],
            CONT [ HOOK.INDEX.SF #iforce,
                   RELS <! relation & #keyrel &
                           [ ARG2 #mtop ] !>,
                   HCONS <! qeq, qeq & [ HARG #mtop,
                                         LARG #cltop ] !> ],
            ARG-S #comps ],
    NONLOC non-local_none,
    LKEYS [ KEYREL #keyrel,
            --COMPKEY #cmin ] ].

subconj_cp_cp-gap_synsem := subconj_lex_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CONT.HOOK.INDEX #mevent ] >,
			 PRD - ],
		  VAL.COMPS #comps &
                          < [ --MIN #cmin,
                              LOCAL [ CAT [ HEAD verb &
                                                 [ AUX +,
						   MINORS.ALTMIN passive_rel,
						   TAM indic_tam,
						   VFORM fin ],
					    VAL [ SUBJ 
						  < [ NONLOC.SLASH 0-dlist ] >,
						  COMPS < > ],
                                            MC na_or_- ],
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX event ] ],
                              NONLOC [ SLASH 1-dlist &
                                         <! [ CAT [ HEAD comp,
						    VAL [ SPR *olist*,
							  COMPS *olist* ] ],
					      CONT.HOOK.LTOP #sltop ] !>,
				       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT -,
                              PUNCT [ LPUNCT no_punct,
                                      RPUNCT.PSF #iforce ] ] > ],
	    CONT [ HOOK.INDEX.SF #iforce,
                   RELS <! relation & #keyrel &
                           [ ARG2 #mtop ],
			   relation & [ LBL #sltop,
					PRED v_event_rel,
					ARG0 #proarg0 & event ],
			   relation & [ LBL #sltop,
					PRED id_rel,
					ARG1 #mevent,
					ARG2 #proarg0 ] !>,
                   HCONS <! qeq, qeq & [ HARG #mtop,
                                         LARG #cltop ] !> ],
            ARG-S #comps ],
    NONLOC non-local_none,
    LKEYS [ KEYREL #keyrel,
            --COMPKEY #cmin ] ].


; DPF 28-jul-06 - Dropped the zero-pronoun semantics for the subordinate
; infinitival clause - no motivation for it.  But still constrain the XARG
; of the infinitival to be non_expl, and SORT entity to reduce ambiguity
; for e.g. 'Kim tried to be winning.'
; DPF 21-apr-08 - Removed MOD..CAT s_cat_fin_or_imp to allow modif of
; VPs, as in "He arose to wave and sat down again"

subconj_bse_or_inf_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ MODIFD.LPERIPH - ] >,
			 PRD + ],
                  VAL.COMPS < [ LOCAL 
                                [ CAT vp_cat &
                                      [ VAL [ SPR *olist* ] ],
                                  CONT.HOOK [ LTOP #vpltop,
                                              INDEX event &
                                                [ E.TENSE no_tense ],
                                              XARG non_expl-ind ] ] ] > ],
            CONT [ RELS <! subord_relation & [ ARG2 #subord ] !>,
                   HCONS <! qeq, 
                            qeq & [ HARG #subord,
                                    LARG #vpltop ] !> ] ] ].

subconj_bse_synsem := subconj_bse_or_inf_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT vp_bse_cat &
				      [ VAL.SUBJ < unexpressed_reg > ] ] > ].

subconj_inf_synsem := subconj_bse_or_inf_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT vp_inf_cat &
				      [ VAL.SUBJ < pro_ss > ] ] > ].

; DPF 2/6/02 - Changed COMPS..SPR synsem to synsem_min in order to support 
; e.g. 'I slipped while dancing'
; DPF 5/20/02 - Cannot require that COMPS..SUBJ..INDEX be re-entrant with
; the MOD..AGR, since get sentences like "There are age restrictions when
; renting a car" where the AGR is there_expl, but the INDEX is ref-ind.  
; So the subject of the predicative phrase must be discourse-bound.
; DPF 30-May-02 - TO DO - constrain complement to be non-temporal, to allow
; "when there" but block "when Tuesday".
; DPF 3-May-03 - Made [COMPS..MOD..HEAD noun] to avoid some of the  spurious 
; ambiguity for e.g. "Kim knows when to arrive".
; DPF 22-apr-04 - Removed SPR < synsem_min > from complement, since this
; prevents "when really necessary", and it's not clear what it was supposed
; to be blocking.
; DPF 20-aug-04 - Removed [MOD..MSG message] even though this was helping
; with seemingly spurious ambiguity, because it blocked attachment to
; subordinate clauses, as in "if you slip while dancing, you fall".

subconj_prd_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.VFORM non_inf ] >,
                  VAL.COMPS < [ LOCAL [ CAT prd_cat,
                                        CONT.HOOK [ LTOP #prdltop,
                                                    XARG non_expl-ind ] ]] > ],
            CONT [ RELS <! subord_relation & [ ARG2 #cltop ] !>,
                   HCONS <! qeq, qeq & [ HARG #cltop,
                                         LARG #prdltop ] !> ] ] ].

subconj_prd_pre_synsem := subconj_prd_synsem &
  [ LOCAL.CAT.POSTHD - ].

subconj_prd_post_synsem := subconj_prd_synsem &
  [ LOCAL [ CAT.POSTHD +,
            CONT.HOOK.INDEX.SF #iforce ],
    PUNCT.RPUNCT.PSF #iforce ].

; For "so" of "I can be there, so yes/no/okay"
subconj_disc_adv_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT s_cat_fin_or_imp,
                               MODIFD.LPERIPH - ] >,
                  VAL.COMPS < [ LOCAL [ CAT [ HEAD root-marker,
                                              POSTHD - ],
                                        CONT.HOOK [ LTOP #cltop,
                                                    INDEX.SF prop ] ],
                                LEX + ] >,
                  POSTHD + ],
            CONT [ HOOK.INDEX.SF #iforce,
                   RELS <! subord_relation & [ ARG2 #subord ] !>,
                   HCONS <! qeq, qeq & [ HARG #subord,
                                         LARG #cltop ] !> ] ],
    PUNCT.RPUNCT.PSF #iforce ].

; DPF 14-May-02 - Cost of having this complementizer-like analysis is that
; we don't get conjoined if-clauses like "If you leave and he stays, I win"
; So why do we have this analysis?  Can't remember ...
; DPF 01-Jun-07 - Removed identity of MOOD on main and subord clauses, due to
; "If it were true, you can be sure we would know" where the irrealis is in
; the complement clause - too hard to pass through, so let's overgenerate.

#|
subconj_if_synsem := subconj_lex_synsem & basic_two_arg &
  [ LOCAL [ ARG-S #comps,
            CAT [ HEAD [ MOD < [ LOCAL.CAT [ HEAD verb & 
                                                  [ VFORM fin_or_imp,
                                                    TAM.TENSE real_tense ],
                                             VAL.COMPS < > ],
                                 NONLOC.SLASH 0-dlist,
                                 MODIFD.LPERIPH - ] >,
                         TAM.MOOD #mood ],
                  VAL.COMPS < synsem &
                      [ LOCAL [ CAT [ HEAD prep_or_modnp &
                                       [ TAM [ TENSE no_tense,
                                               ASPECT no_aspect ],
                                         MOD < [ LOCAL intersective_mod ] > ],
                                      VAL.COMPS < > ],
                                CONT.HOOK [ LTOP #chand,
                                            INDEX #event ] ],
                        NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                 REL 0-dlist & [ LIST < > ],
                                 QUE 0-dlist ],
                        OPT +,
                        PUNCT.LPUNCT no_punct ] . #comps & 
                              < synsem &
                                [ LOCAL [ CAT np_cat_nom_min,
                                          AGR #agr,
                                          CONJ cnil ],
                                  NONLOC.SLASH 0-dlist & #slash,
                                  --SIND #ind,
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ],
                                synsem &
                                [ LOCAL
                                  [ CAT [ HEAD verbal &
                                               [ VFORM fin,
                                                 TAM #tam & [ MOOD #mood ],
                                                 --ADDIN [ ADDTAM #tam,
                                                           ADDPN #pn ] ],
                                          VAL [ SUBJ < synsem &
                                                     [ LOCAL [ AGR #agr,
                                                               CAT.HEAD noun ],
                                                       NONLOC.SLASH #slash ] >,
                                                COMPS < > ] ],
                                    AGR #agr & [ PNG.PN #pn ],
                                    CONT.HOOK [ LTOP #chand,
                                                INDEX #event &
                                                     [ SF prop ],
                                                XARG #ind ] ],
                                  NONLOC.SLASH 0-dlist,
                                  OPT -,
                                  PUNCT [ LPUNCT no_punct,
                                          RPUNCT.PSF #iforce ] ] > > ],
            CONT [ HOOK.INDEX.SF #iforce,
                   RELS <! subord_relation & #keyrel &
                           [ ARG2 #sub,
                             ARG0 [ E [ TENSE no_tense,
                                        ASPECT no_aspect ] ] ] !>,
                   HCONS <! qeq, qeq & [ HARG #sub,
                                         LARG #chand ] !> ] ],
    LKEYS.KEYREL #keyrel ].
|#

; 'For Kim to win, Abrams must lose'

#|
subconj_for_synsem := subconj_lex_synsem & basic_two_arg &
  [ LOCAL [ ARG-S #comps,
            CAT [ HEAD [ TAM.MOOD #mood,
                         MOD < [ LOCAL [ CAT s_cat_fin_or_imp &
                                           [ HEAD.TAM.MOOD #mood ] ],
                                 NONLOC.SLASH 0-dlist,
                                 MODIFD.LPERIPH - ] > ],
                  VAL.COMPS #comps &
                              < synsem &
                                [ LOCAL [ CAT np_cat_acc_min,
                                          AGR #agr,
                                          CONJ cnil ],
                                  NONLOC.SLASH 0-dlist & #slash,
                                  --SIND #ind,
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ],
                                synsem &
                                [ LOCAL
                                  [ CAT [ HEAD verbal &
                                               [ VFORM inf,
                                                 TAM.MOOD #mood ],
                                          VAL [ SUBJ < synsem &
                                                     [ LOCAL [ AGR #agr,
                                                               CAT.HEAD noun ],
                                                       NONLOC.SLASH #slash ] >,
                                                COMPS < > ] ],
                                    CONT.HOOK [ LTOP #chand,
                                                INDEX.SF prop,
                                                XARG #ind ] ],
                                  NONLOC.SLASH 0-dlist,
                                  OPT -,
                                  PUNCT [ LPUNCT no_punct,
                                          RPUNCT.PSF #iforce ] ] > ],
            CONT [ HOOK.INDEX.SF #iforce,
                   RELS <! subord_relation & #keyrel &
                           [ ARG2 #sub,
                             ARG0 [ E [ TENSE no_tense,
                                        ASPECT no_aspect ] ] ] !>,
                   HCONS <! qeq, qeq & [ HARG #sub,
                                         LARG #chand ] !> ] ],
    LKEYS.KEYREL #keyrel ].
|#

subconj_twoarg_synsem := subconj_lex_synsem & basic_two_arg &
  [ LOCAL [ ARG-S #comps,
            CAT [ HEAD [ TAM.MOOD #mood,
			 PRD -,
                         MOD < [ LOCAL [ CAT s_cat_fin_or_imp &
                                           [ HEAD.TAM.MOOD #mood ] ],
                                 NONLOC.SLASH 0-dlist,
                                 MODIFD.LPERIPH - ] > ],
                  VAL.COMPS #comps &
                              < synsem &
                                [ LOCAL [ CAT np_cat_acc_min,
                                          CONJ cnil ],
                                  NONLOC.SLASH 0-dlist,
                                  --SIND #ind,
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ],
                                synsem &
                                [ LOCAL
                                  [ CAT [ HEAD.TAM.MOOD #mood,
                                          VAL.COMPS *olist* ],
                                    CONT.HOOK [ LTOP #chand,
                                                INDEX.SF prop,
                                                XARG #ind ] ],
                                  NONLOC.SLASH 0-dlist,
                                  OPT -,
                                  PUNCT [ LPUNCT no_punct,
                                          RPUNCT.PSF #iforce ] ] > ],
            CONT [ HOOK.INDEX.SF #iforce,
                   RELS <! subord_relation & #keyrel &
                           [ ARG2 #sub,
                             ARG0 [ E [ TENSE no_tense,
                                        ASPECT no_aspect ] ] ] !>,
                   HCONS <! qeq, qeq & [ HARG #sub,
                                         LARG #chand ] !> ] ],
    LKEYS.KEYREL #keyrel ].

subconj_for_synsem := subconj_twoarg_synsem &
  [ LOCAL.CAT.VAL.COMPS 
		  < [ LOCAL.AGR #agr ],
		    [ LOCAL.CAT [ HEAD comp & [ VFORM inf ],
				  VAL.SUBJ < synsem &
					     [ LOCAL [ AGR #agr,
						       CAT.HEAD noun ],
					       NONLOC.SLASH 0-dlist ] > ]] > ].
                                                
subconj_with_synsem := subconj_twoarg_synsem &
  [ LOCAL.CAT.VAL.COMPS 
		  < synsem, 
		    [ LOCAL.CAT [ HEAD v_or_a_or_p &
				       [ PRD + ],
				  VAL.SUBJ *olist* ] ] > ].

; For sentence-initial discourse-level PPs like in "as for Chiang, who hired
; her?"
subconj_np_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT s_cat_fin_or_imp,
				       CONT.HOOK.INDEX.SF basic-prop ],
			       NONLOC.SLASH 0-dlist,
			       MODIFD.LPERIPH - ] >,
		  VAL.COMPS < [ LOCAL [ CAT nomp_cat_nonnom_min,
                                        CONT.HOOK.INDEX #ind &
                                            [ PNG.PN 3p ] ] ] >,
                  POSTHD - ],
            CONT [ RELS <! subord_relation & [ ARG2 #subord ],
                           unknown_relation &
                           [ LBL #cltop,
                             ARG #ind ] !>,
                   HCONS <! qeq, qeq & [ HARG #subord,
                                         LARG #cltop ] !> ] ] ].

subconj_word := noncqrs-h-nab &
  [ SYNSEM subconj_lex_synsem &
           [ LOCAL [ CAT.VAL.COMPS < [ OPT -,
				       NONLOC.SLASH 0-dlist,
				       PUNCT.RPUNCT.PSF #iforce ] >,
                     CONT.HOOK.INDEX.SF #iforce ] ] ].
    
; For subordinating preps like 'after' which don't allow topicalized S compl:
; "*Kim left, after on Tuesday Kim had already arrived."
p_cp_s-notop_le := subconj_word &
  [ SYNSEM subconj_synsem & 
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.MC - ] > ] ].

; For subordinating preps like 'since' which allow topicalized S compl, as in
; 'Kim left, since on Tuesday Browne had already arrived'
p_cp_s_le := subconj_word &
  [ SYNSEM subconj_ind_synsem ].

; "for"
p_cp_s-post_le := subconj_word &
  [ SYNSEM subconj_ind_synsem &
           [ LOCAL.CAT.POSTHD + ] ].

; For ones like "as if" which can take subjunctive CP complement
p_cp_s-unsp_le := subconj_word &
  [ SYNSEM subconj_synsem ].

; 'Kim left, as did Abrams'
p_cp_inv-s_le := subconj_word &
  [ SYNSEM subconj_cp_inv_synsem ].

; 'Kim will stay as time permits'
p_cp_gap-s_le := noncqrs-h-nab &
  [ SYNSEM subconj_cp_gap_synsem ].

; 'as has been shown'
p_cp_cp-gap_le := noncqrs-h-nab &
  [ SYNSEM subconj_cp_cp-gap_synsem ].

;p_cp_s-ncop_le := subconj_word &
;  [ SYNSEM subconj_cp_nocop_synsem ].

; Post-head subordinating prep colon, which also allows
; imperatives: "Berlin: See brochure"

p_cp_s-cln_le := subconj_word &
  [ SYNSEM subconj_cp_synsem &
           [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ *anti_list* ] >,
                         VAL.COMPS < [ LOCAL.CAT s_cat_unspec &
                                          [ HEAD [ VFORM fin_or_inf_or_imp,
                                                   TAM indic_tam ],
                                            VAL.SPR *olist*,
                                            MC + ] ] >,
                         POSTHD + ] ] ].

; DPF 14-Oct-02 - Collapse above two, just specifying real_tense.

#|
p_cp_s-if-unsp_le := noncqrs-nab & word &
  [ SYNSEM subconj_if_synsem &
           [ LOCAL.CAT.VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAM.TENSE real_tense ] >]].
|#

p_cp_s-for_le := noncqrs-nab & word &
  [ SYNSEM subconj_for_synsem ].

p_cp_s-ncop_le := noncqrs-nab & word &
  [ SYNSEM subconj_with_synsem ].

p_vp_bse_le := noncqrs-nab & word &
  [ SYNSEM subconj_bse_synsem ].

p_vp_inf_le := noncqrs-nab & word &
  [ SYNSEM subconj_inf_synsem ].

p_prd_s_le := noncqrs-nab & word &
  [ SYNSEM subconj_prd_synsem ].

p_prd_s-v-p_le := noncqrs-nab & word &
  [ SYNSEM subconj_prd_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD v_or_p &
                                         [ TAM.ASPECT.PROGR - ] ] > ] ].

p_np_s_le := noncqrs-nab & word &
  [ SYNSEM subconj_np_synsem ].

p_adv_s_le := noncqrs-nab & word &
  [ SYNSEM subconj_disc_adv_synsem ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Coordinating conjunctions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; HACK: For efficiency, restrict conjunctions to only coordinate phrases which 
; are saturated for COMPS.  This falsely excludes "Kim bought and sold a car".
; DPF (25-Apr-98) Removed COMPS..HEAD subst constraint, to allow 
; "your and my offices"
; DPF 8-Jun-99 - Removed hack on saturated COMPS - was blocking e.g. "between
; eleven and one p.m."
; DPF 15-May-03 - Discovered that the change to use LKEYS meant all subtypes
; of word were undesirably being coerced to be [LEX +] since type inference
; determined from the LKEYS attribute in 'word' that the synsem type should be
; abstract_lex_synsem which also introduces [LEX +].  This meant among other
; things that conj_word was always [LEX +*] rather than unspecified, and hence
; we could not parse e.g. "Kim is hiring Abrams and firing Browne" though we
; could still parse "Kim hired Abrams and fired Browne".  Now corrected, maybe.
; DPF 29-may-07 - Made conj_word be [LEX na] so we can prevent these from
; being right dtrs in coord phrases by themselves.  Were using nonlex_synsem
; constraint on those right dtrs, but this was inconsistent with "Kim etc,"
; where "etc," has lex_punct_synsem.
; DPF 10-sept-07 - Finally realized that conjunctions were interacting badly
; with chart dependencies, since these words identify their HEAD value with
; that of their complement, which means that they are lexically underspecified
; and hence unifiable with any requirement on MINORS.MIN.  In principle,
; should constrain the chart dependency mechanism to ignore CONJ + entries.
; For now, exclude coordination of selected PPs to gain better efficiency.

conj_word := word &
  [ INFLECTD +,
    SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD #head & [ MINORS.MIN independent_rel ],
		     MC #mc,
		     VAL [ SUBJ #subj,
			   SPR #spr,
                           SPEC #spec,
			   COMPS < synsem &
				   [ LOCAL [ CAT [ HEAD #head,
						   MC #mc,
						   VAL [ SUBJ #subj,
							 SPR #spr,
                                                         SPEC #spec,
                                                         COMPS #comps ],
                                                   HC-LEX #hclex ],
                                             CONT.HOOK.XARG #xarg,
                                             CONJ cnil ],
				     OPT -,
                                     PUNCT.LPUNCT pair_or_no_punct ] 
				   . #comps > ],
                     HC-LEX #hclex ],
               CONT.HOOK.XARG #xarg ],
       LEX na,
       PUNCT no_punctuation_min ] ].

; A coordinating conjunction needs to "prime" the CONJ.LBLS and
; CONJ.INDICES lists, so that the right side of a binary coordination looks
; like an iterated coordination.

norm_conj_word := conj_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR.DIV #div ], ... >,
                     AGR.DIV #div ],
             LKEYS.KEYREL basic_conj_relation ] ].

basic_conj_complex_lexent := conj_word &
  [ SYNSEM [ LOCAL [ CONJ.CREL #keyrel,
                     CONT [ HOOK [ LTOP #chand,
                                   INDEX #cind ],
                            RELS <! #keyrel &
                                  [ LBL #chand,
                                    ARG0 #cind ] !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

conj_complex_lexent := basic_conj_complex_lexent & norm_conj_word.

; DPF 14-apr-05 - We should distinguish conjoined mass nouns, which can produce
; a still singular phrase ('this hardiness and zest for life') from count nouns
; which are always(?) plural when conjoined, whether singular or plural.  But
; we don't have a natural class of count (whether sg or pl) vs mass, so can't
; easily split this entry into two.
; DPF 01-sept-06 - Re 14-apr-05: Now that we have multiple n-bar coord rules,
; we can locate the AGR..PN 3p in the specific construction that coordinates
; DIV - nouns.  So removed AGR..PN 3p from c_xp_and_le, cp_xp_and-both_le.
; DPF 20-sept-06 - But this would mean we parse "Abrams and Browne arrives", 
; so we use the new attribute CONJ.CPNG to distinguish 'and' from 'or', and
; have only the NP-coord rule (not the nbar-coord rule) include this
; constraint on the mother.

c_xp_and_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD both_or_cnil,
                                     CPNG.PN 3p ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

; '(first) Kim and then Sandy'
c_xp_and-then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD subst ], ... >,
                   CONJ lex-conj & [ CHEAD first_or_cnil ],
		   CONT.RELS <! [ PRED _and+then_c_rel ] !> ] ].

c_xp_and-also_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+also_c_rel ] !> ] ].

c_xp_and-yet_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+yet_c_rel ] !> ] ].

c_xp_and-thus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+thus_c_rel ] !> ] ].

c_xp_and-not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+not_c_rel ] !> ] ].

; DPF 31-oct-05 - Make [CONJ phr-conj] to avoid spurious ambiguity for
; "Then we should go."
; 'first Kim, then Sandy'
c_xp_then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL.COMPS < > ] ] >,
		   CONJ phr-conj & [ CHEAD first_or_cnil ],
		   CONT.RELS <! [ PRED _then_c_rel ] !> ] ].


c_xp_and-so_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+so_c_rel ] !> ] ].


c_xp_and-finally_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+finally_c_rel ] !> ] ].

c_xp_or-else_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _or+else_c_rel ] !> ] ].

c_xp_except-that_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _except+that_c_rel ] !> ] ].

c_xp_except_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD n_or_p,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _except_c_rel ] !> ] ].

c_xp_aswellas_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD n_or_p_or_a,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD both_or_cnil ],
		   CONT.RELS <! [ PRED _as+well+as_c_rel ] !> ] ].

c_xp_but_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD non_noun_or_adv ] >,
                   CONJ lex-conj & [ CHEAD notonly_or_cnil ],
		   CONT.RELS <! [ PRED _but_c_rel ] !> ] ].

c_xp_but-np_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD noun ] >,
                   CONJ lex-conj & [ CHEAD not-conj ],
		   CONT.RELS <! [ PRED _but_c_rel ] !> ] ].

c_xp_nor_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD neither_or_cnil ],
		   CONT.RELS <! [ PRED _nor_c_rel ] !> ] ].

c_xp_or_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD either_or_cnil ],
		   CONT.RELS <! [ PRED _or_c_rel ] !> ] ].  

c_xp_plus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _plus_c_rel ] !> ] ].

c_xp_plus-minus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _plus-minus_c_rel ] !> ] ].

; DPF 31-oct-05 - Make [CONJ phr-conj] to avoid spurious ambiguity for
; "So we should leave."
; DPF 10-oct-10 - But this makes external interface too mysterious for
; generation, so live with ambiguity.
c_xp_so_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --SIND event ] >,
		   CONJ.CHEAD cnil,
		   CONT.RELS <! [ PRED _so_c_rel ] !> ] ].

c_xp_vs_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _versus_c_rel ] !> ] ].

c_xp_minus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _minus_c_rel ] !>,
                   AGR.PNG png & [ PN 3s ] ] ].

c_xp_but-not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _but+not_c_rel ] !> ] ].

c_xp_if-not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _if+not_c_rel ] !> ] ].

c_xp_but-then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD n_or_p_or_a,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _but+then_c_rel ] !> ] ].

c_xp_but-also_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD notonly_or_cnil ],
		   CONT.RELS <! [ PRED _but+also_c_rel ] !> ] ].

#|
c_xp_but-also-obl_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD notonly ],
		   CONT.RELS <! [ PRED _but+also_c_rel ] !> ] ].
|#

c_xp_much-less_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _much+less_c_rel ] !> ] ].

c_xp_let-alone_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _let+alone_c_rel ] !> ] ].

c_xp_nottomentn_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _not+to+mention_c_rel ] !> ] ].

c_xp_amp_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD both_or_cnil ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

; DPF 18-Mar-03 - How to block finite VP right conjunct?  Note that not only
; VPs can be conjoined.  Note also that blocking VP right conjunct will also
; correctly block sentence conjunction.
;   This data means either having two lexical entries, or pushing VFORM up to
; type 'head' so non-verbal conjuncts are still permitted here even with
; constraint on VFORM nonfin.  Also suggests that lexical conjunctions and 
; not the coord rules determine which properties of 'head' are unified on the
; two conjuncts, if we want to treat these as regular conjunctions.
;   'Kim will buy a truck rather than rent a car'
;   'Kim will buy a truck rather than renting a car'
;   '*Kim bought a truck rather than rented a car'
;   'Kim wanted to buy a truck rather than to rent a car'
;   '*Kim bought a truck rather than Sandy rented a car'
;   'Kim arrived on Tuesday rather than on Wednesday'

c_xp_rather_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _rather+than_c_rel ] !> ] ].  

; DPF 18-Mar-03 - Need to block not only finite VP right conjunct, but also 
; base form (and maybe infinitival?)
;   '*Kim will buy a truck instead of rent a car'
;   'Kim will buy a truck instead of renting a car'
;   '*Kim bought a truck instead of rented a car'
;   '?Kim wanted to buy a truck instead of to rent a car'
;   'Kim arrived on Tuesday instead of on Wednesday'

c_xp_instead_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _instead+of_c_rel ] !> ] ].  

c_xp_and-or_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

; For e.g. slash in A/B - limit to lexical conjuncts
c_xp_and-or-lx_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil,
				     CLEX + ],
		   CONT.RELS <! [ PRED _and_c_rel ] !>,
		   CAT.VAL.COMPS.FIRST.LEX + ] ].

c_xp_not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.--SIND ref-ind,
		   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _not_c_rel ] !> ] ].

; DPF 18-aug-07 - Also for non-finite VPs, PPs, APs, etc., as in
; "We want to win the game, not lose it!"
c_xp_not-ev_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ *synlist*,
                             COMPS.FIRST.--SIND event & [ E.TENSE untensed ] ],
		   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _not_c_rel ] !> ] ].

c_xp_yet_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.--SIND event,
		   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _yet_c_rel ] !> ] ].

c_xp_even_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD n_or_p_or_a,
                                                   VAL.SPR *olist* ],
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _even_c_rel ] !> ] ].

; Different since it sets DIV to +, to get e.g.
; 'chair after chair arrived.'
c_xp_after_le := basic_conj_complex_lexent &
  [ SYNSEM [ LOCAL [ AGR [ PNG.PN #pn,
                           DIV + ],
                     CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD noun,
                                                     VAL.SPR < synsem > ],
                                               AGR.PNG.PN #pn ] ] >,
                     CONJ lex-conj & [ CHEAD cnil ],
                     CONT.RELS <! [ PRED _after_c_rel ] !> ],
             LKEYS.KEYREL conj_relation ] ].

c_xp_albeit_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adj ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _albeit_c_rel ] !> ] ].


; DPF 31-jul-06 - Constrain to *olist* SPR to avoid '*the both dog and cat"
conj_atomic_lexent := norm_conj_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ CAT.VAL.SPR *olist*,
                                               CONT.HOOK #hook,
                                               CONJ cnil ],
		   CONJ atomic-conj,
		   CONT [ HOOK #hook,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

c_xp_both-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ both ].

c_xp_either-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ either ].
                   
c_xp_neither-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ neither ].

c_xp_notonly-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ notonly ].

c_xp_not-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ not-conj ].

; 'First Kim, then Sandy'
c_xp_first-mrk_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ first ].

; two hundred and fifty
c_xp_and-num_le := conj_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN integer_rel,
                           VAL.COMPS.FIRST [ LOCAL [ CAT.HEAD intadj2- &
                                                     [ MINORS.ALTMIN #altmin ],
                                                     CONT.HOOK.LTOP #hand,
                                                     CONJ cnil,
                                                     AGR.DIV #div ],
                                             MODIFD.LPERIPH na ] ],
                     CONJ num-conj,
                     CONT [ HOOK.LTOP #hand,
                            RELS <! !>,
                            HCONS <! !> ],
                     AGR.DIV #div ],
             LKEYS [ KEYREL integer_relation,
                     ALTKEYREL.PRED #altmin ] ] ].

; 'five and a half'
c_xp_and-fract_le := conj_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN fraction_rel,
                           VAL.COMPS.FIRST [ LOCAL [ CAT.HEAD fractadj &
                                                     [ MINORS.ALTMIN #altmin ],
                                                     CONT.HOOK [ LTOP #hand,
                                                                 XARG #ind ],
                                                     CONJ cnil,
                                                     AGR.DIV #div ],
                                             MODIFD.LPERIPH na ] ],
                     CONJ num-conj,
                     CONT [ HOOK [ LTOP #hand,
                                   INDEX #ind ],
                            RELS <! !>,
                            HCONS <! !> ],
                     AGR.DIV #div ],
             LKEYS [ KEYREL.PRED fraction_rel,
                     ALTKEYREL.PRED #altmin ],
             NONLOC [ SLASH 0-dlist,
                      REL 0-dlist,
                      QUE 0-dlist ] ] ].

et_conj_lexent := word_or_lexrule &
  [ INFLECTD +,
    SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_rel,
                     VAL.COMPS < > ],
               CONJ phr-conj,
               AGR.PNG png & [ PN 3p ],
               CONT [ HOOK [ LTOP #chand,
                             INDEX #cind ],
                      RELS <! relation &
                             [ LBL #chand,
                               ARG0 #cind ] !>,
                      HCONS <! !> ] ],
       PUNCT [ LPUNCT comma_or_no_punct,
               RPUNCT no_punct ] ] ].

etc_conj_lexent := et_conj_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _etc_c_rel ] !> ].

c_-_etc_le := etc_conj_lexent &
  [ SYNSEM.PUNCT.PNCTPR ppair ].

; For "did Kim arrive etc.?" where the PUNCT.PAIRED value must be unconstrained
; even though there's a qmark which would ordinarily stamp PAIRED no_ppair.
c_-_etc-qmark_le := etc_conj_lexent &
  [ SYNSEM.PUNCT.PNCTPR no_ppair ].

; Similarly for "Kim hired everyone except:" where the colon affix would
; stamp PAIRED no_ppair, but we want it in PNCTPR since this odd "except"
; is acting like a head-marker phrase.

c_-_except_le := et_conj_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD n_or_p,
                     CONT.RELS <! [ PRED _except_c_rel ] !> ],
             PUNCT.PNCTPR ppair ] ].

c_-_except-coln_le := et_conj_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD n_or_p,
                           VAL.SPR *anti_list* ],
                     CONT.RELS <! [ PRED _except_c_rel ] !> ],
             PUNCT.PNCTPR no_ppair ] ].

c_-_etal_le := et_conj_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD supnoun,
                         VAL.SPR < > ],
                   CONT.RELS <! [ PRED _et+al_c_rel ] !> ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NEG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; not

; "not" requires its VP complement to be [VFORM non_fin], which is a supersort
; for all non-finite vforms except imp_vform, which is a subsort of bse; the
; other subsort of bse, bse_only, is a subsort of non_fin.  Most verbs with
; base morphology are [VFORM bse], and hence (the VPS they project) can be
; modified by "not", and they can also head imperative clauses, which require
; the head to be [VFORM imp_vform].  Only if modified by "not" will a base
; VP be unable to project an imperative clause; in contrast, "never sleep" is 
; fine as an imperative, since "never" does not further restrict its VP 
; complement leaving it [VFORM bse], which is consistent with the imperative 
; rule.  This fine distinction is due to Rob M.
; DPF 2-Feb-01 - Changed MOD..HEAD from verbal to v_or_g, to allow e.g.
; "I tried not hiring kim"

adv_neg_lexent := basic_adverb_word &
  [ SYNSEM lex_synsem & 
	 [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL scopal_mod &
					    [ CAT [ VAL.COMPS < >,
                                                    MC na ],
                                              CONT [ HOOK [ LTOP #mhand,
                                                            INDEX non_expl &
                                                                  #vevent,
                                                            XARG #xarg ] ],
                                              CONJ cnil ] ] >,
                                MINORS.MIN neg_rel ],
                         VAL [ SUBJ < >,
			       COMPS < >,
			       SPR < > ],
                         MC na,
			 POSTHD - ],
		   CONT [ HOOK [ INDEX #vevent,
                                 XARG #xarg ],
			  RELS <! #keyrel &
                                  [ ARG0.E [ TENSE no_tense,
                                             ASPECT no_aspect ],
                                    ARG1 handle & #hand ] !>,
			  HCONS <! qeq &
				  [ HARG #hand,
				    LARG #mhand ] !> ] ],
           NONLOC.QUE 0-dlist,
           LKEYS.KEYREL #keyrel ] ].

av_-_s-not_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD negadv &
                       [ MOD < [ LOCAL.CAT [ HEAD.VFORM non_fin,
                                             VAL.SUBJ < synsem_min > ] ] > ],
		       NEGPOL + ] ].

; DPF 05-apr-05 - MOD..HEAD v_or_a_or_p allows modnp subtype, which is not
; a subtype of a_or_p for independent reasons.  No spurious ambiguity here, 
; since the SUBJ < > constraint rules out all PRD + verbal projections.

av_-_s-not-prdp_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD adv_nonmob &
                          [ MOD < [ LOCAL.CAT [ HEAD v_or_a_or_p &
                                                     [ PRD + ],
                                                VAL.SUBJ < > ] ] > ] ].

; for "non-" as in "non-intrusive"
av_-_s-not-ap_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD adv_nonmob &
                          [ MOD < [ LOCAL.CAT [ HEAD adj,
                                                VAL.SUBJ < > ] ] > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; COMPLEMENTIZERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Complementizers except for 'to' are marked [SUBJ < >] which prevents them
; from having PP modifiers.

; ERB (07-10-96) 'whether' clauses are made with the regular hcomp rule, so
; the polar_q_rel must come from 'whether' itself.  This means that whether
; can't identify its MIN with its --COMPKEY.  Also, I made complementizer_word
; inherit from msg_word (see comments near that type).  This has the effect of
; making non_affix_bearing be inherited by this type, instead of the lower
; types.

; ERB (14-12-97) to_c_prop needs to be MC + for infinitival relatives
; (see notes near to and non_wh_rel_cl) so this type can't say MC -.
; There is no convenient supertype to all of the MC - ones, so I'm
; just going to put it in on each for now.

; ERB (14-12-97) Complementizer_word can't be nonmod_local because 
; to_c_nonprop is going to have a non-empty mod value.  Again, For
; now I'm scattering this constraint among the lower types as appropriate.

; ERB (13-01-98) In fact, complementizer_word can't even be MC bool,
; because to_c_nonprop has to be MC na in order to head hcomps that
; serve as modifiers, as in "a teacher to talk to Sandy".

;;; DPF 01-Mar-00 - Reconsider, now that support_rel has been eliminated.
; DPF (27-Sept-98) Made MIN be v_event_rel, since "to" needs to pass up the
; KEY.LBL of its complement, in order to get the desired semantics for e.g.
; "Kim is going to lose" where the copula's support_rel identified its LBL
; with that of its complement's KEY.
; 
; DPF (13-Jan-99) Generalized to make MIN be v_event_rel for all 
; complementizers, needed in particular to avoid treating complementizers as 
; particles, which are selected by MIN value.
; DPF 25-oct-03 - Change SPR from *olist* to < > to block PP modification.

complementizer_word := noncr-h-nab & word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.INV -,
                         VAL.SPR < > ],
		   AGR.PNG.PN 3s,
		   CONT.HOOK.INDEX non_expl ] ].

plain_compl_word := complementizer_word &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SUBJ < #subj >,
                               COMPS #comps & 
                                    < [ --MIN #cmin,
                                        --SIND #ind,
                                        OPT - ], ... > ],
                     CONT.HOOK.INDEX #ind,
                     ARG-S < #subj . #comps > ],
             LKEYS.--COMPKEY #cmin ] ].

; These are the subject-to-object raising complementizers.  We're giving a
; funny three-constituent analysis to CPs: "that [Kim] [walks]" and "for [Kim]
; [to walk]".  One (beneficial) side effect of this is that finite and
; non-finite CPs get a uniform analysis, and we also can do real subject
; extraction without running afoul of the dreaded that-trace filter
; (Perlmutter 1971).  

; We also need another "that", one that combines with an adverbial and an
; S/Adv.  This accounts for why you get preposed modifiers with that clauses
; and not with for/to clauses, and why you don't get the that-t effect when
; you have an adverb in there.  But, that second "that" is going to have to
; bind off a SLASH value, sort of like the tough-movement cases, and that will
; have to wait for lexicalized SLASH passing.

; ERB (14-12-97) See notes at complementizer_word.

; DPF 2-Apr-01 - Added PP modifier argument to COMPS, to allow for sentence-
; initial modification, as in "I knew that on Tuesday I would be early", and in
; particular for "how come when I arrive he leaves" (given that we treat this
; "how come" as a main-clause-compatible complementizer).
; DPF 26-apr-08 - Generalized COMPS.FIRST..HEAD prep_or_modnp to p_or_adv
; to allow e.g. "Kim thinks that often we arise"

basic_two_place_compl_word := complementizer_word & 
  [ SYNSEM basic_two_arg & 
    [ LOCAL nomod_local &
      [ ARG-S #comps,
        CAT [ HEAD [ VFORM #vform,
                     TAM #tam & [ TENSE #tense,
                                  ASPECT #aspect,
                                  MOOD #mood ] ],
              VAL [ SUBJ < >,
                    COMPS 
                     < synsem &
                       [ --MIN independent_rel,
                         LOCAL [ CAT 
                                 [ HEAD p_or_adv & 
                                      [ TAM [ TENSE no_tense,
                                              ASPECT no_aspect ],
                                        MOD < [ LOCAL.CONT.HOOK 
                                                           [ LTOP #chand,
                                                             XARG #event ] ]>],
                                   VAL.COMPS < > ],
                                 CONT.HOOK.LTOP #ltop ],
                         NONLOC [ SLASH 0-dlist,
                                  REL 0-dlist & [ LIST < > ],
                                  QUE 0-dlist ],
                         PUNCT [ LPUNCT no_punct,
                                 RPUNCT comma_or_rbc_or_pair_or_no_punct,
                                 PNCTPR ppair ] ] . #comps & 
                       < synsem & 
                         [ NONLOC #nloc &
                                  [ SLASH 0-dlist,
                                    REL 0-dlist ],
                           PUNCT [ RPUNCT comma_or_rbc_or_pair_or_no_punct,
                                   PNCTPR ppair ] ],
                         [ --MIN #cmin,
                           LOCAL [ CAT [ HEAD verbal &
                                              [ VFORM #vform,
                                                TAM #tam ],
                                         VAL [ SUBJ < [ NONLOC #nloc ] >,
                                               COMPS < > ] ],
                                   CONT [ HOOK [ LTOP #chand,
                                                 INDEX #event ] ] ],
                           OPT -,
                           PUNCT.LPUNCT no_punct ] > > ] ],
        CONT [ HOOK [ LTOP #ltop,
                      INDEX #event & [ E [ TENSE #tense,
                                           ASPECT #aspect,
                                           MOOD #mood ] ] ] ] ],
      LKEYS.--COMPKEY #cmin ] ].

two_place_compl_word := basic_two_place_compl_word &
  [ SYNSEM.LOCAL.CAT.HEAD comp ].

; Instead of doing raising here by identifying whole synsems, only identify
; semantic indices, as with regular raising for verbs above.  This lets us get
; "I prefer that he be here early" treating the second (VP) complement of 
; "that" as a simple base-form VP, rather than some new morphological form.

basic_sor_compl_word := basic_two_place_compl_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < synsem,
                                 synsem &
				 [ LOCAL [ CAT #cat & nomp_cat_min,
                                           AGR #agr,
					   CONJ cnil ],
                                   --SIND #ind & index,
				   OPT - ],
				 [ LOCAL [ CAT.VAL.SUBJ < synsem &
                                                          [ LOCAL
                                                             [ CAT #cat,
                                                               AGR #agr ] ] >,
                                           CONT.HOOK.XARG #ind ] ] > ].

sor_compl_word := basic_sor_compl_word & two_place_compl_word.

; Optional intersective modifier PP
sor_compl_word_int := basic_sor_compl_word &
  [ SYNSEM.LOCAL 
      [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
                          OPT + ],
                        synsem, 
                        [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
        CONT.HOOK.LTOP #ltop ] ].

; Obligatory scopal modifier PP
sor_compl_word_scp := basic_sor_compl_word &
  [ SYNSEM.LOCAL 
      [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal_mod ] >,
                                  CONT.HOOK.LTOP #ltop ],
                          OPT - ], 
                        synsem, synsem >,
        CONT.HOOK.LTOP #ltop ] ].

cm_np-vp_that_lexent := sor_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  TAM.MOOD #mood & indicative,
				  CASE nom,
				  AUX -,
				  MINORS.MIN verb_aspect_rel ],
			   VAL.COMPS < synsem, 
				       [ LOCAL.CAT np_cat_nom_min ],
				       [ LOCAL [ CAT.HEAD 
						     [ TAM #tam & indic_tam &
							   [ TENSE real_tense,
							     MOOD #mood ],
						       --ADDIN [ ADDTAM #tam,
								 ADDPN #pn ] ],
						 AGR.PNG.PN #pn ] ] >,
			   MC - ],
		     CONT [ HOOK.INDEX.SF prop,
			    RELS <! !>,
			    HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

cm_np-vp_i-that_le := cm_np-vp_that_lexent & sor_compl_word_int.
cm_np-vp_s-that_le := cm_np-vp_that_lexent & sor_compl_word_scp.

;; "I prefer that he be here early"
cm_np-vp_that-sv_lexent := sor_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM bse,
                                TAM.MOOD #mood,
                                AUX -,
                                MINORS.MIN verb_aspect_rel ],
                         VAL.COMPS < synsem, 
                                     [ LOCAL.CAT np_cat_nom_min ],
                                     [ LOCAL.CAT.HEAD.TAM subjnct_tam &
                                                          [ MOOD #mood ] ] >,
                         MC - ],
                   CONT [ RELS <! !>,
                          HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

cm_np-vp_i-that-sv_le := cm_np-vp_that-sv_lexent & sor_compl_word_int.
cm_np-vp_s-that-sv_le := cm_np-vp_that-sv_lexent & sor_compl_word_scp.

cm_np-vp_for_le := sor_compl_word_int &
  [ SYNSEM [ LOCAL [ CAT [ HEAD comp &
				[ VFORM inf,
				  AUX -,
				  MINORS.MIN verb_aspect_rel ],
                         VAL.COMPS < [ --MIN no_rel ],
                                     [ LOCAL.CAT np_cat_acc_min ], 
                                     synsem >,
                         MC - ],
                   CONT [ HOOK.INDEX.SF prop,
                          RELS <! !>,
                          HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

cm_np-vp_like_lexent := sor_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                AUX -,
                                MINORS.MIN verb_aspect_rel ],
                         VAL.COMPS < synsem,
                                     [ LOCAL.CAT np_cat_nom_min ],
                                     [ LOCAL 
                                       [ CAT.HEAD.TAM indic_tam,
                                         CONT.HOOK.INDEX.SF like-iforce ] ] >,
                         MC - ],
                   CONT [ RELS <! !>,
                          HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

cm_np-vp_i-like_le := cm_np-vp_like_lexent & sor_compl_word_int.
cm_np-vp_s-like_le := cm_np-vp_like_lexent & sor_compl_word_scp.

; ERB (13-01-98) to_compl_word says SUBJ < unexpressed >, but I don't
; how that can be, unless the analysis of raising has changed drastically.
; (With it that way, raising is broken).  So I am getting rid of it.

; ERB (19-01-98) SUBJ < unexpressed > was in there because something
; had to take care of giving that subject a SLASH value.  The solution
; we've opted for is this: the subject of to_c_prop is always PRO, and
; the subject of to_c_nonprop is always raised (that is, all
; infinitival tos except those in raising constructions are to_c_prop).
; So there is no constraint on to_compl_word, but to_c_prop says
; SUBJ < pro_ss > and to_c_nonprop says SUBJ canonical_synsem.

; ERB (03-02-98) MIN should be no_rel.  It used to be identified with
; --COMPKEY, but that causes at least one problem: to was able to be the
; SPR of the, since the constrains its choice of SPR by a semantic
; constraint on the KEY.
; DPF (13-Jan-99) This problem should be solved by the above decision to
; make all complementizers have the MIN be of type v_event_rel.
; DPF 17-Sep-01 - Removed INDEX.E.TENSE no_tense, since it prevents e.g. 
; "I am going to arrive".
; DPF 14-Nov-01 - Returned to identifying MIN with --COMPKEY, in order to get
; intended constraint on --COMPKEY.E.ASPECT for e.g. "I have yet to arrive"
; DPF 17-sept-07 - Restrict VP complement to SUBJ..HEAD noun to avoid spurious
; analyses with locative inversion verbs as in "to run".

to_compl_word := plain_compl_word &
  [ SYNSEM basic_two_arg &
     [ LOCAL [ CAT [ HEAD [ AUX +,
                            PRD -,
                            MINORS #mins & [ MIN verb_aspect_rel ] ],
                     VAL [ SUBJ < [ LOCAL.AGR #agr,
                                    --SIND #semind ] >,
                           COMPS 
                              < synsem &
				[ LOCAL 
                                  [ CAT vp_cat &
                                        [ HEAD.MINORS #mins,
                                          VAL.SUBJ 
                                           < [ LOCAL [ CAT.HEAD noun,
                                                       AGR #agr ],
                                               --SIND #semind,
                                               NONLOC
                                                     [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ],
                                    CONT [ HOOK [ INDEX #ind,
                                                  XARG #xarg ] ] ] ] > ] ],
               CONT [ HOOK [ INDEX #ind,
                             XARG #xarg ] ] ],
       MODIFD notmod ] ].

; ERB (14-12-97) Why is the SUBJ here specified as acc?? I'm taking it
; out because that follows now from pro_ss.

; ERB (08-01-98) Presumably that had to do with "for him/*he to sleep..."
; but that's the other to: to_c_nonprop.

; ERB (14-12-97) In order to implement infinitival relatives (I found
; a teacher to talk to Sandy, I found a teacher to talk to), I am
; making to_c_prop MC +.  The reasons for this is that the relevant
; cx (non_wh_rel_cl) needs to be able to take subjh_decl and hcomps
; headed by to_c_prop as its head-dtr, but not an extrasubj phrase.

; ERB (19-01-98) This to has to have a mod value so that it can
; head the infinitival relatives.  Something needs to be said about
; the features mentioned in nomod_local, probably, but I'm not sure
; what yet.  It also needs to be MC na so it can feed extrasubj.

; DPF 4-apr-04 - Removed identification of AGR and COMPS.FIRST..AGR, since
; we need to have complementizers stipulate AGR.PNG.PN 3s to get the agreement
; right for sentential subjects (?), but we also say that 'and' is inherently
; AGR.PNG.PN 3p (to get NP coordination right (?)), and the result of both
; of these (dubious?) assertions is that we were not parsing "to arrive and
; arise" with the to-prop guy.  Probably room for improvement, but for now
; let's see what happens removing this AGR identity.

basic_comp_to_prop_lexent := to_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD comp &
                              [ MOD < anti_synsem &
                                      [ LOCAL intersective_mod &
                                              [ CAT nbar_cat_min ] ] > ],
                         VAL [ SUBJ < pro_ss >,
                               COMPS < canonical_synsem &
                                       [ LOCAL.CONT.HOOK 
                                         [ LTOP #chand,
                                           INDEX [ E.TENSE no_tense,
                                                   SF prop-or-ques ] ] ] > ],
                         MC na_or_-,
                         POSTHD + ],
                   CONT [ HOOK.LTOP #chand,
                          RELS <! !>,
                          HCONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

cm_vp_to_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].
; try and win
cm_vp_and_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_and,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].
; help but notice
cm_vp_but_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_but,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].

; prevent him from leaving (cf "*prevent him from danger")
cm_vp_from_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_from,
                       VAL.COMPS < [ LOCAL.CAT vp_prp_cat ] > ] ].

; ERB (14-12-97) This one will have a non-empty MOD value in order to
; build things like "Kim found a friend to talk to Sandy" where the
; subject of talk has to be bound to friend (unlike in "Kim found a
; friend to talk to" where we're convinced it is discourse bound.)
;
; The semantics are probably not right -- as a place holder in the
; modcont I put a appropriate_rel.  The idea is that "I found a person
; to talk to Sandy" means something like "I found a person who is willing/
; appropriate/suitable to talk to Sandy."  But I don't see how to make
; (something like) the appropriate_rel take the comlement of the to
; as an argument.  There is also the question of whether there should be
; any message associated with this.  One would think not, given that we've
; decided the relevant to is the nonprop one...
;   For now, we're not including this rel.

; ERB (13-01-98) to_compl_nonprop_word must be MC na if it is
; to head hcomps that serve as modifiers as in "a teacher to talk to Sandy".
;
; ERB (19-01-98) All infinitival relatives are now headed by
; to_c_prop.  To_c_nonprop only appears in raising constructions.
; Accordingly, it has no MOD value, and its subject is constrained
; to be canonical_synsem.  I'm not sure the latter constraint is
; actually doing any work for us, but I believe it to be true.
; It can also now inherit from nomod_local.  The MC value might
; could be changed, as well.

; ERB (2003-08-11) Try changing SUBJ < canonical_synsem > to
; SUBJ < unexpressed >.  There are several places in the grammar
; where the SLASH value of the SUBJ here is being constrained.
; Since it is, in fact, always unxpressed, it would seem safe.
; Testing to see whether coverage is lost or gained because something
; was relying on this constraint.

#|
comp_to_nonprop_le := to_compl_word & 
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD comp &
                              [ VFORM inf,
                                CASE acc,
                                POSS - ],
                         VAL [ SUBJ < unexpressed_reg & 
                                      [ OPT - ] >,
			       COMPS < [ LOCAL [ CAT vp_bse_cat,
                                                 CONT.HOOK.LTOP #hand ] ] > ],
                         MC na ],
		   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !> ] ] ].
|#

;;; DPF (21-Oct-98) Added types for elided "to", since we can't use the lexical
;; rule of auxiliary verbs, since we need to block the NP "the book to", which
;; would be built by that lexical rule, then by the application of subject
;; extraction, and then the infinitival relative rule.

to_compl_elided_word := noncqr-h-nab & word &
  [ SYNSEM basic_one_arg &
	   [ LOCAL nomod_local &
		   [ CAT [ HEAD comp &
				[ VFORM inf,
				  INV -,
				  AUX +,
				  PRD -,
                                  MINORS [ MIN ellipsis_rel,
                                           ALTMIN ellipsis_rel ] ],
                           VAL [ SUBJ #subj &
				      < nongappro &
					[ --SIND #index,
					  NONLOC.SLASH 0-dlist ] >,
				 SPR *olist*,
				 COMPS < > ],
			   MC na ],
		     CONT [ HOOK [ INDEX #event,
                                   XARG #index ],
			    RELS.LIST < #keyrel & arg1_relation &
                                        [ PRED ellipsis_ref_rel,
                                          ARG0 #event,
                                          ARG1 #index ], ... > ],
                     ARG-S #subj ],
             LKEYS.KEYREL #keyrel ] ].

cm_-_to_le := to_compl_elided_word & 
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < pro_ss >,
                   CONT [ HOOK.LTOP #chand,
                          RELS <! [ LBL #chand,
                                    ARG0.SF prop ] !>,
                          HCONS <! !> ] ] ].

; ERB (08-10-96) Whether was previously a que_word so that things selecting
; for questions could select by QUE values.  This is clearly a hack, and
; further, one that is no longer necessary now that we have semantic selection.
; I have split the old type whether_compl_word into two types: finite and
; nonfinite.  I have also gotten rid of the feature CMP.  
; As for the semantics, whether contributes a polar_q_rel (see notes near
; polar_q_rel in fundamentals.tdl).  Now, according to Rob, things that
; take complements with message-type semantics usually take the handle of
; those complements as the argument in their KEYs.  However, also according
; to Rob, if we did that here, it would imply that "whether Kim left every
; party" has more readings than "Kim left every party", which doesn't seem
; to be true.  Accordingly, whether will identify its handle with the
; handle of its complement, and take the complement's INDEX as the value
; of the ARG1 in the polar_q_rel.  Now, if whether further identified its
; INDEX with that one, things would be getting pretty twisty, so whether
; will have its own INDEX of type event.

; ERB (24-10-96) MSG now functions like KEYREL as a pointer to
; a certain rel on the RELS.  Both wh and yn questions will have an
; int_m_rel on their RELS.  This is actually sewn into the RELS
; by the constructions.  Whether just carries it in its MSG value
; so that it unifies with the right constructions.  In this way, we
; even kind of get Rob's intuition -- whether doesn't, in a sense,
; have a message, because that message isn't on its RELS.
; Anyway, all of this makes the polar_q_rel irrelevant, so I am removing
; it.  The hcomp_yn_nr construction will make sure the MARG value
; of the int_m_rel takes the LBL of whether's complement.   I don't
; know what to do about whether's LBL and ARG0 now, so I am 
; leaving them unspecified.

; ERB (14-12-97) See notes at complementizer_word.

whether_compl_word := complementizer_word &
  [ SYNSEM [ LOCAL nomod_local &
		   [ CONT.HOOK.INDEX.SF ques ],
             NONLOC.SLASH 0-dlist ] ].

comp_whether_if_fin_lexent := whether_compl_word & basic_sor_compl_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD comp &
                                [ VFORM fin,
                                  MINORS.MIN verb_aspect_rel ],
                           VAL.COMPS < synsem, 
                                       [ LOCAL.CAT np_cat_nom_min ],
                                       [ LOCAL [ CAT.HEAD 
                                                     [ TAM #tam,
                                                       --ADDIN [ ADDTAM #tam,
                                                                 ADDPN #pn ] ],
                                                 AGR.PNG.PN #pn ] ] >,
                           MC - ],
                     CONT [ RELS <! !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL.PRED verb_aspect_rel ] ].

cm_np-vp_wh_lexent := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.MOOD indicative,
                       VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAm indic_tam ] > ] ].

cm_np-vp_i-wh_le := cm_np-vp_wh_lexent & sor_compl_word_int.
cm_np-vp_s-wh_le := cm_np-vp_wh_lexent & sor_compl_word_scp.

; DPF 10-sept-07 - Add NORM no_rel to prevent these from undergoing the np_cp
; rule, to avoid spurious analysis for e.g. "if Kim arrives, Abrams is."
; And similarly for the subjunctive variant.

cm_np-vp_if-indc_lexent := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD [ CASE acc,
                              MINORS.NORM no_rel ],
                       VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL 
                                     [ CAT.HEAD.TAM indic_tam,
                                       CONT.HOOK.INDEX.SF prop-or-ques ]] > ]].

cm_np-vp_i-if-indc_le := cm_np-vp_if-indc_lexent & sor_compl_word_int.
cm_np-vp_s-if-indc_le := cm_np-vp_if-indc_lexent & sor_compl_word_scp.

cm_np-vp_if-sv_lexent := basic_sor_compl_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD comp &
                                [ CASE acc,
                                  VFORM fin,
                                  MINORS [ MIN verb_aspect_rel,
                                           NORM no_rel ] ],
                           VAL.COMPS < synsem, 
                                       [ LOCAL.CAT np_cat_nom_min ],
                                       [ LOCAL.CAT.HEAD.TAM.MOOD 
                                                         basic_subjunctive ] >,
                           MC - ],
                     CONT [ RELS <! !>,
                            HCONS <! !> ] ],
             NONLOC.SLASH 0-dlist,
	     LKEYS.KEYREL.PRED no_rel ] ].             

cm_np-vp_i-if-sv_le := cm_np-vp_if-sv_lexent & sor_compl_word_int.
cm_np-vp_s-if-sv_le := cm_np-vp_if-sv_lexent & sor_compl_word_scp.

; DPF 13-Mar-02 - Blocked first (optional PP) complement from being picked up
; to avoid misparse for e.g. "I need an explanation of how to return the 
; order to you"
; DPF 12-Apr-03 - But the entry for "how" leads to spurious ambiguity for e.g.
; "I know how kim arrived", and doesn't help with other WH-S's as objects of
; prepositions: "I need an explanation of who we hired".  Seems better to 
; return to our analysis treating WH-S's as NPs, and look again at the
; resulting spurious ambiguities there.  So we'll use this type only for
; "how come".

; 'how come they left'
cm_np-vp_how_le := sor_compl_word_int & whether_compl_word & 
  [ SYNSEM [ LOCAL 
             [ CAT [ HEAD comp &
                          [ VFORM fin,
                            TAM.MOOD indicative ],
                     VAL.COMPS < synsem & 
                                 [ --MIN no_rel ],
                                 [ LOCAL.CAT np_cat_nom_min ],
                                 [ LOCAL [ CAT.HEAD.TAM.MOOD ind_or_modal_subj,
                                           CONT.HOOK [ LTOP #cltop,
                                                       INDEX #cind &
                                                       [ SF prop-or-ques ]]]]>,
                     MC + ],
               CONT [ HOOK.INDEX #cind & [ SF prop-or-ques ],
                      RELS <! #keyrel & 
                            [ LBL #cltop,
                              ARG0.E [ TENSE no_tense,
                                       ASPECT no_aspect ],
                              ARG1 #cind,
                              ARG2 #objind ],
                            [ PRED which_q_rel,
                              ARG0 #objind,
                              RSTR #rhand ],
                            #altkeyrel &
                            [ LBL #nhand,
                              ARG0 #objind ] !>,
                      HCONS <! qeq &
                             [ HARG #rhand,
                               LARG #nhand ] !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ] ] ].


; ERB (08-10-96) In the older version, I had whether_compl_word_inf 
; selecting for something that was just vp_inf_cat.  I never
; tested for this, but this probably allowed Sandy knew whether whether
; to leave, etc.  One way to get around this is for whether to
; select for something that is MSG no_msg.  In order to do 
; this, I need to build to CPs that are no_rel, but we want this
; anyway (even though I talked Dan out of it at one point).
; DPF 09-Jan-00 - Made "whether" be MC -, not MC na, since e.g. "know"
; wants [MC -] CP complements.

cm_vp_wh_le := whether_compl_word &
  [ SYNSEM basic_one_arg &
	   [ LOCAL [ CAT [ HEAD comp &
                                [ VFORM inf,
                                  MINORS.MIN verb_aspect_rel ],
			   VAL [ SUBJ < >,
                                 COMPS #comps &
                                      < [ LOCAL [ CAT [ HEAD comp &
							  [ VFORM inf ],
						       VAL [ SUBJ *cons*,
                                                             COMPS < >,
							     SPR *olist* ] ],
                                                  CONT [ HOOK.LTOP #chand ] ],
                                          --SIND #ind,
                                          OPT - ] > ],
                           MC - ],
		     CONT [ HOOK [ LTOP #chand,
                                   INDEX #ind ],
			    RELS <! !>,
			    HCONS <! !> ],
                     ARG-S #comps ],
	     LKEYS.KEYREL.PRED no_rel ] ].

s_compl_phrase_lexent := noncqr-h-nab &
  [ SYNSEM [ LOCAL nomod_local &
		 [ CAT [ HEAD verb & 
			      [ INV -,
				VFORM fin ],
			 VAL [ SUBJ < >,
			       SPR *olist*,
			       COMPS < > ] ],
		   CONT [ HOOK [ LTOP #khand,
                                 INDEX #event ],
			  RELS.LIST < arg1_relation &
                                      [ LBL #khand,
                                        PRED ellipsis_rel,
                                        ARG0 #event ], ... > ],
                   ARG-S < > ],
	     NONLOC.SLASH 0-dlist,
             LEX + ] ].

; 'so'
x_-_so-cp_le := s_compl_phrase_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN v_event_rel,
                     CONT [ HOOK.INDEX.SF prop,
                            RELS <! relation & #keyrel !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ PRED v_event_rel ] ] ].

x_-_wh-cp_le := s_compl_phrase_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN prep_mod_rel,
                     CONT [ HOOK.INDEX.SF ques,
                            RELS <! relation & 
                                 [ LBL #hand,
                                   ARG0 #event ],
                                 #keyrel &
                                 [ LBL #hand,
                                   PRED prep_mod_rel,
                                   ARG0.E [ TENSE no_tense,
                                            ASPECT no_aspect ],
                                   ARG1 #event,
                                   ARG2 #objind ],
                                 [ PRED which_q_rel,
                                   ARG0 #objind,
                                   RSTR #rhand ],
                                 #altkeyrel & [ LBL #nhand,
                                             ARG0 #objind ] !>,
                          HCONS <! qeq &
                                   [ HARG #rhand,
                                     LARG #nhand ] !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Imperative words "don't" and "let's"

; ERB (05-10-97) In order to conflate hcomp_root and hcomp_nc into just one
; hcomp, root_marker_words have to identify their value for mc with that of
; their complement.  (Hcomp_root identified MC for mother and non-head
; daughter.)

root_marker_word := noncqr-h-nab & word &
  [ SYNSEM synsem &
	 [ LOCAL [ CAT [ HEAD verb & [ AUX -,
                                       INV - ],
			 VAL.COMPS < synsem &
                                     [ LOCAL [ CAT.VAL.COMPS < >,
                                               CTXT #ctxt ],
                                       NONLOC [ SLASH #slash,
                                                QUE 0-dlist,
                                                REL 0-dlist ] ] > ],
                   CTXT #ctxt ],
	   NONLOC.SLASH #slash ] ].

; DPF 14-jul-06 - moved SUBJ < anti_synsem_min > down to 'lets' subtype, so 
;'dont' subtype can say SUBJ < >, which (nearly) enables it to be modified 
; by VP adverbs, as in "Still don't move!".  But we await the departure of
; messages, since adj_head_intersective rule requires head to be MSG no_msg.
; Leave for now.
; DPF 31-jul-06 - But this blocks e.g. 'Kim arrived but don't move!"  So
; will have to find some other solution for VP modifiers
; DPF 30-sept-06 - Changed MIN no_rel to nonaux_v_rel in order to admit
; "arise; don't move!"

lex_imperative := root_marker_word &
  [ SYNSEM [ LOCAL 
             [ CAT [ HEAD [ MOD < anti_synsem_min >,
                            TAM.MOOD #mood,
                            PRD -,
                            VFORM imp_vform,
                            MINORS.MIN nonaux_v_rel ],
                     VAL 
		    [ SPR < >,
                      SUBJ < anti_synsem & [ LOCAL.CAT.HEAD.CASE acc,
                                             --SIND #inst & ref-ind ] >,
		      COMPS < [ LOCAL 
                                 [ CAT [ HEAD verb & 
                                              [ VFORM bse_only,
                                                TAM.MOOD #mood ],
                                         VAL.SUBJ 
                                             < synsem &
                                               [ NONLOC [ SLASH 0-dlist,
                                                          QUE 0-dlist,
                                                          REL 0-dlist ] ] >,
                                         MC na ],
                                   CONT.HOOK [ INDEX #ind,
                                               XARG #inst ] ],
                                OPT +,
                                PUNCT.LPUNCT no_punct ] > ],
                     MC bool ],
               AGR #inst,
               CONT [ HOOK [ LTOP #khand,
                             INDEX #ind & [ E.TENSE present,
                                            SF comm ] ],
                      RELS.LIST < [ PRED pronoun_q_rel,
                                    RSTR #rhand,
                                    ARG0 #inst ],
                                  [ LBL #prohand,
                                    PRED pron_rel,
                                    ARG0 #inst &
                                        [ PRONTYPE zero_pron,
                                          SORT entity ] ], ... >,
                      HCONS.LIST < qeq &
                                   [ HARG #rhand,
                                     LARG #prohand ], ... > ] ],
             LKEYS.KEYREL [ LBL #khand,
                            PRED no_rel  ] ] ].
		    
v_vp_lets-imp_le := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
		   AGR.PNG png & [ PN 1p ],
		   CONT [ HOOK.LTOP #chand,
                          HCONS <! qeq !>,
			  RELS <! relation, relation !> ] ] ].

v_vp_dont-imp_le := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CONT [ HOOK.LTOP #chand ],
                                             CAT.HEAD.MINORS.ALTMIN 
                                                            non_conj_rel ] ] >,
                   AGR.PNG png & [ PN 2 ],
		   CONT [ HOOK.LTOP #neghand,
                          RELS <! relation,
				   relation,
                                 [ LBL #neghand,
                                   PRED neg_rel,
				   ARG1 #arg ] !>,
			  HCONS <! qeq,
                                   qeq &
				    [ HARG #arg,
				      LARG #chand ] !> ] ] ].

; 09-09-97  Added ARG0 and BODY attributes temporarily for VM2, since the
; whq external relation for how_about is like a quantifier, needing four args.
; Had to change the relation introduced by "how about" to '_which_q_rel'
; rather than '_how_about_rel' because of some property of vitADT.  Similar
; change made to the 'frag-msg' instance in syntax.tdl.
; 06-Oct-98 DPF - Changed MC value from na to +, to allow "okay, how about kim"
; DPF 25-sept-04 - Changed SUBJ, SPR, and MOD from < > to < anti_synsem_min > 
; so these can conjoin with ordinary clauses.

basic_how_about_word := word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < anti_synsem_min >,
                                  MINORS.MIN how+about_r_rel,
                                  VFORM fin,
                                  AUX -,
                                  INV -,
                                  TAM.TENSE real_tense ],
                           VAL [ SUBJ < anti_synsem_min >,
                                 SPR < anti_synsem_min > ],
                           MC +,
                           HC-LEX - ],
                     CONT [ HOOK.LTOP #rhand,
                            RELS.LIST < event_relation &
                                        [ PRED generic_verb_rel,
                                          LBL #arghand ],
                                        relation & #keyrel &
                                        [ LBL #rhand,
                                          ARG0.SF prop-or-ques,
                                          ARG1 #arg ], ... >,
                            HCONS <! qeq &
                                     [ HARG #arg,
                                       LARG #arghand ] !> ],
                     CONJ cnil ],
             NONLOC non-local_none,
             LKEYS.KEYREL norm_adj_relation & #keyrel,
             PUNCT no_punctuation_min ] ].

how_about_word := basic_how_about_word & root_marker_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM.MOOD indicative,
                         VAL.COMPS < [ --MIN independent_rel,
                                       LOCAL [ CAT.VAL [ SPR *olist*,
                                                         COMPS < > ],
                                               CTXT #ctxt ],
                                       PUNCT.RPUNCT.PSF #pred ] > ],
                   CONT.HOOK.INDEX.SF #pred,
                   CTXT #ctxt ] ].

; DPF 12-Apr-03 - Constrained COMPS..VAL.COMPS to be < > to avoid spurious
; ambiguity due to application of noptcomp rule (e.g. "how about sometime").
comp_how_about_n_or_p_lexent := how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD n_or_p,
                                                   VAL.COMPS < > ],
                                             CONT.HOOK.LTOP #ltop ],
                                     --SIND #ind ] >,
                   CONT [ HOOK.INDEX #event & event,
                          RELS.LIST < relation, 
                                      [ LBL #ltop,
                                        ARG0 #event,
                                        ARG2 #ind ], ... > ] ] ].

; how about
x_xp_howabt-n-p_le := comp_how_about_n_or_p_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --SIND #ind,
                                     OPT - ] >,
                   CONT.RELS <! relation, [ ARG2 #ind ] !> ] ].

; how long before the end?  how long before kim arrives?
x_pp_howabt_le := comp_how_about_n_or_p_lexent &
  [ SYNSEM.LOCAL 
     [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD prep &
                                  [ MOD < [ LOCAL scopal_mod &
                                                  [ CONT.HOOK.LTOP #mtop ] ]>],
                                 CONT.HOOK.LTOP #ltop ],
                         OPT - ] >,
       CONT.RELS <! relation, 
                  [ ARG2 #ltop ],
                  event_relation &
                  [ PRED generic_verb_rel,
                    LBL #mtop ] !> ] ].

x_cp_howabt_le := how_about_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM.MOOD #mood,
                         VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                          [ TAM.MOOD #mood ],
                                                     MC + ],
                                               CONT.HOOK.LTOP #ltop ],
                                       OPT - ] > ],
                   CONT [ HOOK.INDEX #event,
                          RELS <! relation, 
                                 [ ARG0 #event,
                                   ARG1 #ltop ] !> ] ] ].

; DPF 25-Nov-01 - Removed INDEX..TENSE no_tense since root_strict requires
; real_tense.
comp_how_about_or_why_vp_lexent := how_about_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM.MOOD #mood,
                         VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                          [ TAM.MOOD #mood ],
                                                     VAL.SUBJ < synsem > ],
                                             CONT.HOOK [ LTOP #cltop,
                                                         INDEX.SF prop ] ],
                                     OPT - ] > ],
                   CONT [ HOOK.INDEX #ind & event,
                          RELS <! relation, 
                                 [ ARG0 #ind,
                                   ARG1 #cltop ] !> ] ] ].

; DPF 17-Apr-01 - Changed COMPS.FIRST..SUBJ from canonical_synsem to synsem
; since the former blocked "Why be late"

x_vp_howabt_le := comp_how_about_or_why_vp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM prp ] > ].

x_vp_why_le := comp_how_about_or_why_vp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM bse_only ] > ].

x_-_why_le := basic_how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ HOOK.INDEX #ind & event,
                          RELS <! relation, 
                                [ ARG0 #ind ] !> ] ] ].

; Discourse-related sentential adverbs
;   (e.g. 'then, but')
; DPF 06-Oct-98 - Added MC + to MOD, to block "Kim says but sandy left"
; DPF 15-Oct-98 - Changed HEAD from adv to root-marker, to get "yes, okay"
; DPF 22-Oct-98 - Added MC + to the SYNSEM itself to block the relative clause
;   in "a programmer but he hired".
; DPF 09-Jun-99 - Added SLASH 0-dlist to MOD, to block e.g. "when yes Kim left"
; DPF 03-Oct-99 - Added SUBJ *olist* to MOD specific. - why wasn't it here 
; before?
; DPF 17-Apr-00 - Removed CONJ cnil to enable e.g. "yes and Kim left"
; DPF 22-Nov-01 - We have to make sure that disc_adv_words propagate the MC 
; feature of their modifiee, to block e.g. yes-no parse for "I would like to 
; arrive"

basic_disc_adv_synsem := synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT.MC #mc ] > ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < > ],
                  MC #mc ],
	    CONJ cnil ],
    NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ] ].

disc_adv_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD root-marker &
		       [ PRD -,
			 MOD < [ LOCAL scopal_mod &
                                   [ CAT [ HEAD disc_adverbee &
                                              [ TAM.TENSE real_tense ],
                                           VAL [ SUBJ *olist*,
                                                 SPR *olist*,
                                                 COMPS < >,
                                                 SPEC < > ] ] ],
                                 NONLOC.SLASH 0-dlist ] > ],
                  MC + ] ] ].

disc_adv_phr_synsem := basic_disc_adv_synsem & phr_synsem &
  [ LOCAL.CAT.HEAD adv &
                   [ MOD < [ LOCAL.CAT.VAL [ SPR *olist*,
                                             COMPS < > ],
                             NONLOC.SLASH 0-dlist ] > ] ].

;; DPF 24-Oct-98 Removed [MC +] from disc_adv_word, since this runs afoul of
;; the carefully balanced constraint on head-modifier structures which requires
;; [MC na], to allow relative clauses as modifiers while preventing ordinary
;; finite clauses from being modifiers.

disc_adv_word := noncqr-h-nab & word &
  [ SYNSEM disc_adv_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN abstr_excl_rel,
                     CONT [ HOOK [ LTOP #chand & handle,
                                   INDEX #cind ],
			    RELS.LIST < #keyrel,
                                        [ LBL #chand,
                                          PRED discourse_rel,
                                          ARG0 #cind ], ... >,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel & [ PRED abstr_excl_rel ] ] ].

adv_disc_preh_lexent := disc_adv_word &
  [ SYNSEM.LOCAL [ CAT [ POSTHD -,
                         HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #mltop,
                                      --SIND #mindex ] > ],
                   CONT.RELS <! [ LBL #khand,
                                  ARG0 #kind ],
                              [ L-HNDL #khand,
                                L-INDEX #kind,
                                R-HNDL #mltop,
                                R-INDEX #mindex ] !> ] ].

av_-_dc-pr_le := adv_disc_preh_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED excl_rel ].

av_-_dc-grt-pr_le := adv_disc_preh_lexent &
  [ SYNSEM [ LKEYS.KEYREL.PRED greet_rel,
             MODIFD.LPERIPH + ] ].

; DPF 18-aug-07 - Constrain the modifiee to be comma-marked, to avoid
; spurious ambiguity for e.g. "The goal brought more cheers."

adv_disc_posth_lexent := disc_adv_word &
  [ SYNSEM.LOCAL [ CAT [ POSTHD +,
                         HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #mltop,
                                      PUNCT.RPUNCT comma_or_pair_punct,
                                      --SIND #mindex ] > ],
                   CONT.RELS <! [ LBL #khand,
                                  ARG0 #kind ],
                                [ R-HNDL #khand,
                                  R-INDEX #kind,
                                  L-HNDL #mltop,
                                  L-INDEX #mindex ] !> ] ].

av_-_dc-po_le := adv_disc_posth_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED excl_rel ].

av_-_dc-grt-po_le := adv_disc_posth_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED greet_rel ].

; This is like really necessary
disc_adv_like_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD root-marker &
                     [ PRD -,
                       MOD < [ LOCAL scopal_mod &
                                     [ CAT [ HEAD subst,
                                             MC na_or_+ ],
                                       CONT [ HOOK #hook ] ] ] >,
                       MINORS.MIN abstr_excl_rel ],
            CONT [ HOOK #hook,
                   RELS <! !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL.PRED abstr_excl_rel ].

adv_disc_like_lexent := noncqr-h-nab &
  [ SYNSEM disc_adv_like_synsem &
           [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL [ LBL #ltop,
                            PRED excl_rel ] ] ].

av_-_dc-like-pr_le := adv_disc_like_lexent &
 [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.COMPS < >,
				     NONLOC.SLASH 0-dlist ] >,
			POSTHD - ],
	    MODIFD.LPERIPH na ] ].
; 'i think'
av_-_dc-like-po_le := adv_disc_like_lexent &
 [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
		      POSTHD + ] ].

; 'ten minutes or so'
av_-_dc-meas-po_le := adv_disc_like_lexent &
 [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ --MIN meas_nom_rel,
                                   PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
                      POSTHD + ] ].

; General sentence or phrase particle
disc_adv_any_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD root-marker &
                     [ PRD -,
                       MOD < [ LOCAL scopal_mod &
                                   [ CAT.VAL [ SPR *olist*,
                                               COMPS < > ],
                                     CONT [ HOOK #hook ] ],
                               NONLOC.SLASH 0-dlist ] > ],
            CONT [ HOOK #hook,
                   RELS <! !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL.PRED no_rel ].

; Tell me please if my account is closed
av_-_dc-pls_le := noncqr-h-nab & word &
  [ SYNSEM basic_disc_adv_synsem &
	   [ LOCAL [ CAT [ HEAD adv &
                                [ MOD < [ LOCAL intersective_mod &
                                                [ CAT [ HEAD subst,
                                                        VAL [ SPR *olist*,
                                                              COMPS < > ] ],
                                                  CONT.HOOK #hook ],
					  MODIFD notmod_or_rmod,
                                          NONLOC.SLASH 0-dlist ] >,
                                  MINORS.MIN abstr_excl_rel ] ],
                     CONT [ HOOK #hook &
                                 [ LTOP #ltop,
                                   INDEX #ind ],
                            RELS <! #rel !>,
                            HCONS <! !> ] ],
             LEX +,
             LKEYS.KEYREL #rel & [ PRED polite_rel,
                                   LBL #ltop,
                                   ARG1 #ind ] ] ].

x_-_wh-the-hell_le := noncqr-h-nab & word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD wh_adv &
                                [ MOD < >,
                                  MINORS.MIN wh_the_hell_rel ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ] ],
		     CONT [ RELS <! !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL.PRED wh_the_hell_rel,
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Temporal nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Extend to COMPS of temporal nouns the hack blocking extraction of subjects of
; inverted auxiliaries, which exploits CASE value.
; Block N-N compound of "a two meeting" by stipulating that hour_words are
; PRD +, incompatible with requirement of compound rule.  In contrast, e.g.,
; day_of_week words are unmarked for PRD.
;
; Made CONT.HOOK.LTOP be the handle of the numbered_hour_rel rather than that 
; of the implicit def_implicit_q_rel, since hour_words can be modified, as in 
; "two o'clock on the sixteenth".  Since the PP unifies its LTOP handle with 
; the ; LTOP handle of the phrase it modifies, that handle can't be the handle
; of the quantifier, so must be that of the numbered_hour_rel.

; DPF (18-Oct-98) - Removed PRD + from hour_word, so it can combine with its
; minute or am-pm complements and still be a prenominal adjective, as in
; "a ten thirty am meeting"

; DPF (22-Dec-98) - SYNSEM is typed phr_synsem in order to block 
; "a two meeting" while admitting "a two o'clock meeting" - this works because
; "two o'clock" combines with "meeting" using the noun-noun compound rule, 
; which requires the left member to have SYNSEM of type lex_synsem.

; DPF 13-May-01 - Added [RPERIPH +] to prevent hour words from being modified
; (especially by relative clauses), and therefore added optional prd-pp 
; complement to still get e.g. "three in the morning"
; DPF 9-Oct-02 - Can't have these be phr_synsem, since that prevents them from
; undergoing the (necessary) noptcomp rule (which is constrained to lex_synsem
; dtrs in order to prevent spurious ambiguity from n-n-cmpnds).  So instead
; make it LEX - without commitment to the synsem type.
; DPF 27-Oct-02 - Changed HC-LEX from + to +* so we can get coordination of
; "two and two thirty".
; DPF 30-Apr-03 - Considered adding ALTMIN no_rel to prevent these from 
; appearing as left member of np-n compounds after getting a specifier, as in
; "*the at least two chairs", but this fails because the entry for 'from'
; as in "from ten to two" requires the first comp to have non-empty ALTMIN.
; So look for a more general reason to block the above.
; DPF 05-dec-03 - Added SPEC < anti_synsem_min > to prevent these from being 
; specifiers of the hspec rule; preferring instead the hspechc rule for "nine 
; to ten pm'.  Can't say SPEC < > since particle preps want NP complement
; which is SPEC < anti_synsem_min >.

basic_abstr_hour_word := noncqrs-m & basic_noun_word &
  [ INFLECTD +,
    SYNSEM basic_lex_synsem &
    [ LOCAL nomod_local &
            [ CAT [ HEAD noun & [ POSS -,
                                  MINORS [ MIN numbered_hour_rel,
                                           ALTMIN implicit_q_rel,
                                           NORM norm_rel ] ],
                    VAL [ SUBJ < >,
                          SPR < [ --MIN just_only_very_deg_rel,
                                  LOCAL
                                  [ CAT [ HEAD adv,
                                          VAL [ SPR  *olist*,
                                                COMPS < >,
                                                SPEC < [ LOCAL.CAT.VAL.COMPS 
                                                                  < > ] > ] ],
                                    CONT.HOOK [ LTOP #nhand,
                                                XARG #index ] ],
                                  OPT + ] >,
                          SPEC < anti_synsem_min >,
                          COMPS < [ LOCAL [ CAT [ HEAD intadj2 &
                                                  [ MOD < [ --MIN minute_rel,
                                                            LOCAL.CONT.HOOK 
                                                            [ LTOP #nhand ]]>],
                                                  VAL [ COMPS < >,
                                                        SPEC *synlist* ] ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #min ] ],
                                    NONLOC.SLASH 0-dlist,
                                    OPT +,
                                    PUNCT.LPUNCT no_punct ],
                                  synsem &
                                  [ --MIN am_pm_rel,
                                    LOCAL [ CAT.HEAD no_head,
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #ampm ] ],
                                    NONLOC.SLASH 0-dlist,
                                    OPT +,
                                    PUNCT.LPUNCT no_punct ],
                                  synsem & 
                                  [ --MIN temp_loc_rel,
                                    LOCAL 
                                    [ CAT prd_cat &
                                      [ HEAD prep &
                                        [ MOD < [ --MIN #pred ] > ] ],
                                      CONT.HOOK.LTOP #nhand,
                                      CONJ cnil ],
                                    --SIND #index,
                                    NONLOC.SLASH 0-dlist ] > ],
                    HC-LEX +,
                    HS-LEX - ],
              CONT nom-obj &
                       [ HOOK.INDEX #index & [ PNG.PN 3s,
                                               SORT time ],
                         RELS.LIST < #keyrel & basic_arg12_relation &
                                     [ LBL #nhand,
                                       PRED #pred & basic_numbered_hour_rel,
                                       ARG0 #index,
                                       ARG1 #min,
                                       ARG2 #ampm ],
				     [ PRED def_implicit_q_rel,
                                       ARG0 #index,
                                       RSTR #rhand ], ... >,
			 HCONS <! qeq &
                                  [ HARG #rhand,
                                    LARG #nhand ] !> ],
		   AGR #index,
		   ARG-S < > ],
      LKEYS.KEYREL #keyrel,
      MODIFD notmod & [ RPERIPH + ] ] ].

abstr_hour_word := basic_abstr_hour_word &
  [ SYNSEM.LKEYS.KEYREL.PRED numbered_hour_rel ].

n_-_pn-hour_le := abstr_hour_word &
  [ SYNSEM [ LOCAL.CONT.RELS <! relation, relation !>,
             LEX - ] ].

; sixish
n_-_pn-hour-apx_le := abstr_hour_word &
  [ SYNSEM.LOCAL.CONT.RELS <! relation &
			         [ LBL #hand,
				   ARG0 #arg0 ],
			         relation, 
			         [ LBL #hand,
                                   PRED approx_grad_rel,
				   ARG1 #arg0 ] !> ].

; For clocktime ersatz from preprocessor, as in '14.30', which is not
; marked [LEX -] since 'a 14.30 appointment' is fine.
n_np_pn-hour_le := abstr_hour_word &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation !> ].

n_np_pn-hour-unk_le := basic_abstr_hour_word & unknown_word &
  [ SYNSEM.LOCAL.CONT.RELS <! basic_arg12_carg_relation, relation !> ].

abstr_minute_word := np_word_no_quant &
  [ SYNSEM [ LOCAL [ CAT.HEAD intadj2 &
                              [ MINORS.MIN minute_rel,
                                PRD + ],
                     CONT.HOOK [ LTOP #hand,
                                 INDEX non_expl-ind & #inst &
                                      [ PNG png & [ PN 3s ] ] ] ],
             LKEYS.KEYREL [ LBL #hand,
                            PRED minute_rel,
                            ARG0 #inst ],
	     MODIFD notmod ] ].

aj_-_i-mnt-pr_le := abstr_minute_word &
  [ SYNSEM.LOCAL [ CAT.POSTHD -,
                   CONT.RELS <! relation !> ] ].


aj_-_i-mnt-po_le := abstr_minute_word &
  [ SYNSEM.LOCAL [ CAT.POSTHD +,
                   CONT.RELS <! relation !> ] ].

aj_-_i-mnt-app_le := abstr_minute_word &
  [ SYNSEM [ LOCAL [ CAT.POSTHD +,
                     CONT [ HOOK.LTOP #hand,
                            RELS <! relation, 
                                  [ LBL #hand,
                                    PRED approx_grad_rel,
                                    ARG1 #arg0 ] !> ] ],
             LKEYS.KEYREL.ARG0 #arg0 ] ].

; am/pm, AD/BC
xp_suffix_lexent := np_word_no_quant &
  [ SYNSEM [ LOCAL [ CAT.HEAD no_head,
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #arg0 ],
                            RELS <! [ LBL #ltop,
                                      ARG0 #arg0 ] !> ] ],
             LKEYS.KEYREL const_arg0_relation ] ].

x_-_am-pm_le := xp_suffix_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN am_pm_rel ].

x_-_bc-ad_le := xp_suffix_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN bc_ad_rel ].

; DPF 01-dec-05 - Constrain these to only appear as complements of preps,
; to avoid spurious ambiguity with the ordinary noun of same spelling in
; each case.
; DPF 20-mar-06 - Also exclude these from modification by relative clauses,
; to avoid e.g. "*dinner that I had yesterday was late."

n_-_pn-mealtm_le := noncqrs-hm-nab & basic_noun_word &
  [ SYNSEM noun_synsem &
	 [ LOCAL [ CAT [ HEAD [ POSS -,
                                MINORS [ MIN gen_hour_rel,
                                         ALTMIN #altmin,
                                         NORM mealtime_rel ],
				MOD < >,
                                CASE obliq ],
			 VAL [ SUBJ < >,
			       SPR < [ --MIN just_only_deg_rel,
                                       LOCAL [ CAT [ HEAD adv,
                                                     VAL [ SPR  *olist*,
							   COMPS < > ] ],
                                               CONT.HOOK [ LTOP #nhand,
                                                           XARG #index ] ],
                                       OPT + ] >,
			       COMPS < > ] ],
		   CONT nom-obj &
		       [ HOOK [ LTOP #nhand,
                                INDEX #index & [ SORT time ] ],
			 RELS <! #keyrel &
                               [ LBL #nhand,
                                 ARG0 #index ],
                               [ PRED def_implicit_q_rel & #altmin,
                                 ARG0 #index,
                                 RSTR #rhand ] !>,
			 HCONS <! qeq &
			   [ HARG #rhand,
			     LARG #nhand ] !> ],
		   ARG-S < > ],
           LKEYS.KEYREL #keyrel,
           MODIFD notmod ] ].

; DPF 16-Apr-03 - Finally added type for odd entries "October the" as in
; 'October the fifth'.  Duplicates much of what is in date_det_lr type, but
; not easy to see how to abstract (cf. HCONS for example).

det_month_synsem := norm_det_synsem &
  [ LOCAL [ CAT [ HEAD [ POSS -,
                         MINORS [ MIN def_explicit_q_rel,
                                  ALTMIN mofy_rel ] ],
                  VAL [ COMPS < >,
                        SPEC < [ --MIN dofm_rel,
                                 --SIND #ind ] > ] ],
            CONT [ RELS <! #keyrel,
                           #altkeyrel,
                           prep_relation &
                           [ LBL #nltop,
                             PRED of_p_rel,
                             ARG1 #ind,
                             ARG2 #spind ],
                           [ PRED def_implicit_q_rel,
                             ARG0 #spind,
                             RSTR #mhand ] !>,
                   HCONS <! qeq & [ LARG #nltop ],
                            qeq &
                            [ HARG #mhand,
                              LARG #mltop ] !> ] ],
    LKEYS [ KEYREL #keyrel,
            ALTKEYREL #altkeyrel & [ LBL #mltop,
                                  PRED mofy_rel,
                                  ARG0 #spind ] ],
    NONLOC [ SLASH 0-dlist,
             QUE 0-dlist,
             REL 0-dlist ],
    MODIFD hasmod ].

d_-_month_le := abstr_det_word &
  [ SYNSEM det_month_synsem ].

common_noun_nomod_comp_synsem := basic_count_noun_synsem & 
                                 nonpro_nomod_synsem & two_arg.
; DPF 22-May-01 Added LPERIPH + constraint to block these from beings heads of
; n-n compounds.
; DPF 24-mar-06 For now, require SPR to be unexpressed, to avoid generating
; '*Kim arrived in the 1997.'  So we lose e.g. 'I imagine that your 1997
; was more enjoyable.'  In general, want to avoid 'the' as spr of unadorned
; proper names.  FIX ...
; DPF 28-jun-07 - Added REL 0-dlist.
         
n_-_pn-yoc_lexent := nonc-hm & basic_noun_word &
  [ SYNSEM temp_noun_comp_two_arg_synsem &
   [ LOCAL [ CAT [ HEAD [ MOD < >,
                          MINORS [ MIN yofc_rel,
                                   NORM norm_rel ] ],
                   VAL [ SPR < unexpressed &
                               [ --MIN quant_or_wh_rel,
                                 NONLOC.QUE #que ] >,
                         COMPS < expressed_synsem &
                                 [ --MIN bc_ad_rel,
                                   LOCAL [ CAT.HEAD no_head,
                                           CONJ cnil,
                                           CONT.HOOK [ LTOP #nhand,
                                                       INDEX #bcad ] ],
                                   NONLOC.SLASH 0-dlist,
                                   OPT + ] > ] ],
             AGR [ DIV -,
                   PNG.PN 3s ],
             CONJ cnil,
             CONT [ HOOK [ LTOP #nhand,
                           INDEX.PNG png & [ PN 3s ] ],
                    RELS <! relation !>,
                    HCONS <! !> ] ],
     NONLOC [ QUE #que,
              SLASH 0-dlist,
              REL 0-dlist ],
     LKEYS [ KEYREL [ PRED basic_yofc_rel,
                      LBL #nhand,
                      ARG1 #bcad ],
             ALTKEYREL.PRED quant_or_wh_rel ],
     MODIFD notmod & [ LPERIPH + ] ] ].

n_-_pn-yoc_le := n_-_pn-yoc_lexent & noun_word &
  [ SYNSEM.LKEYS.KEYREL.PRED yofc_rel ].

n_-_pn-yoc-unk_le := n_-_pn-yoc_lexent & unknown_word &
  [ SYNSEM.LKEYS.KEYREL diadic_nom_carg_relation ].

; 'the first', 'October first', 'the first of October'
; Need to find way to block '*October first of October'
; DPF 20-Nov-99 - Added PRD + to block membership in N-N-compounds
; DPF 23-Oct-03 - Instead of PRD +, (which is now not consistent with making
; all non-measure NPs [PRD -]), use ALTMIN no_rel to block ordinals as 
; heads of n-n-compounds.
; DPF 25-aug-04 - Try adding LPERIPH - to prevent these from appearing as
; heads of n-n-compounds.  Can't be LPERIPH + since 'May 23 to 25' uses 'to'
; which requires complement to be LPERIPH na_or_- (for reasons no longer 
; clear).
; DPF 24-sept-04 - But LPERIPH - prevents application of npadv rule, as in
; 'we arrived the tenth', and anyway that LPERIPH constraint for 'to' is no
; longer used, so we make these LPERIPH +.

generic_dom_synsem := basic_unsp_common_noun_synsem & noun_synsem &
  [ LOCAL [ CAT [ HEAD noun & [ MINORS [ MIN dofm_rel,
                                         NORM never_unify_rel ] ],
                  VAL.SPEC < anti_synsem_min > ],
            CONT [ HOOK.LTOP #hand,
		   RELS.LIST < generic_named_nom_relation &
                               [ LBL #hand,
                                 PRED dofm_rel,
                                 ARG0.PNG png & [ PN 3s,
                                                  GEN neut ] ], ... > ] ] ].

basic_dom_synsem := generic_dom_synsem & count_noun_synsem &
  [ LOCAL [ CAT.VAL.SPR < synsem &
                          [ --MIN quant_or_wh_rel,
                            LOCAL.AGR.PNG.PN 3s ] >,
            CONT.HOOK.INDEX.DIV - ],
    MODIFD hasmod & [ LPERIPH + ] ].

basic_dom_ord_synsem := basic_dom_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.ALTMIN basic_def_explicit_q_rel,
                VAL.SPR < [ --MIN def_q_rel,
                            LOCAL.CAT.HEAD.POSS - ] > ] ].

dom_ord_synsem := basic_dom_ord_synsem & nonpro_nomod_synsem & one_arg &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN temp_abstr_rel, 
                  VAL [ SUBJ < >,
                        COMPS < >,
                        SPR < [ OPT - ] >,
                        SPEC < anti_synsem_min > ] ],
            CONT [ HOOK.INDEX.SORT time,
                   RELS <! relation !> ] ] ].

; DPF 31-May-02 - Changed SPR..MIN from implicit_q_rel to def_q_rel, 
; to make sure these dom's don't undergo the robust bare_pl_sg rule.
basic_dom_card_synsem := basic_dom_synsem &
  [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.MINORS [ MIN def_q_rel,
                                                  ALTMIN mofy_rel ] ] >,
    LKEYS.ALTKEYREL relation ].

dom_card_synsem := basic_dom_card_synsem & nonpro_nomod_synsem & one_arg &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN temp_abstr_rel,
                  VAL [ SUBJ < >,
                        COMPS < >,
                        SPR < [ OPT - ] >,
                        SPEC < anti_synsem_min > ] ],
            CONT [ HOOK.INDEX.SORT time,
                   RELS <! relation !> ] ] ].

dom_card_yofc_synsem := basic_dom_card_synsem & basic_noun_npcomp_synsem & 
                        two_arg &
  [ LOCAL.CAT.VAL [ COMPS < #comp &
                            [ --MIN yofc_rel & #cmin,
                              NONLOC.SLASH 0-dlist,
                              MODIFD notmod,
                              OPT - ] >,
                    KCMP #comp ],
    LKEYS [ ALTKEYREL relation,
            --+COMPKEY #cmin ] ].

;; 12 october (2003)
dom_euro_synsem := generic_dom_synsem & basic_noun_npcomp_synsem &
                   basic_mass_noun_synsem &
  [ LOCAL [ CAT.VAL [ SPR < unexpressed &
                            [ --MIN udef_q_rel ] >,
                      COMPS < #keycomp &
                              [ --MIN mofy_rel,
                                LOCAL [ CONT.HOOK.LTOP #ltop,
                                        CONJ cnil ],
                                OPT -,
                                PUNCT.LPUNCT hyphen_sgl_or_no_punct ] >,
                      KCMP #keycomp ],
            CONT.HOOK.LTOP #ltop ],
    MODIFD notmod ].

abstr_n_day_of_month_lexent := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM generic_dom_synsem &
           [ LOCAL.AGR.PNG.PN 3s ] ].

n_-_pn-dom-ord_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_ord_synsem ].

n_-_pn-dom-card_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_card_synsem ].

n_-_pn-dom-euro_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_euro_synsem ].

; 'Tuesday (the first (of October))', 'Tuesday (October first)'
; 'Tuesday of that week'
; DPF 31-Jul-99 - Made SYNSEM be nonpro_nomod_onearg_synsem instead of 
; nomod_basic_onearg_synsem since they can appear in noun-noun compounds,
; and also in appositive constructions.


; 'morning' of 'each morning', 'Tuesday morning'
; DPF 19-Oct-02 - Broke this up into two entries, one with empty COMPS
; that excludes "the" to block "I arrived the morning"; and the other with
; PP-of to allow "I arrived the morning of the fifth."
; DPF 23-Apr-03 - Moved MODIFD from basic_n_day_part_lexent to the nocomp
; subtype, to continue to block "*I arrived the morning" (where the temp_np
; rule requires the dtr to be [MODIFD hasmod], and where the determiner "the"
; passes up the MODIFD value of its SPEC) while allowing "I arrived the
; morning of the third" where this pp-comp 'morning' is unmarked for MODIFD.
; DPF 26-Apr-03 - Note that this awkward machinery for three entries (at least)
; for day-part words like "morning" will have to be generalized, since the same
; constraints hold for a few non-temporal nouns like "way" as in 
; 'Kim sang the way you did'  and 'Kim sings that way' but '*Kim sang the way'.
; Also "time" as in "I fell the time he was here" but "*I fell the time".

;basic_n_day_part_lexent := que_word & basic_noun_word &

basic_n_day_part_lexent := noncqrs-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM lex_synsem &
           [ LOCAL [ CAT [ HEAD noun &
                                [ MINORS.MIN day_part_rel ],
                          VAL.SPR < synsem &
                                     [ --MIN quant_or_wh_rel,
                                       LOCAL
					  [ CAT [ HEAD det,
                                                  VAL [ SUBJ < >,
							COMPS < > ] ] ],
                                       --SIND #ind,
                                       OPT - ] > ],
                     AGR #ind,
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #ind ],
			    RELS <! #keyrel & [ LBL #ltop ] !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #keyrel &
                   [ LBL #ltop,
                     ARG0 #ind ] ] ].

onearg_count_n_synsem := nonpro_nomod_onearg_synsem & count_noun_synsem.
twoarg_count_n_synsem := noun_two_arg_nomod_synsem & count_noun_synsem.

n_-_c-dpt_le := basic_n_day_part_lexent &
  [ SYNSEM onearg_count_n_synsem &
	   [ LOCAL [ ARG-S < #spr >,
                     CAT.VAL [ SPR < #spr &
                                    [ LOCAL.CAT.HEAD.MINORS.ALTMIN 
                                                    dofw_or_poss_q_rel ] >,
                               COMPS < > ] ],
	     MODIFD notmod ] ].

n_day_part_ppcomp_lexent := basic_n_day_part_lexent &
  [ SYNSEM twoarg_count_n_synsem &
    [ LOCAL [ ARG-S < #spr . #comps >,
              CAT.VAL [ SPR < #spr >,
                        COMPS #comps &
                            < [ LOCAL [ CAT [ HEAD.MINORS [ MIN _of_p_sel_rel,
							    ALTMIN dofm_rel ],
					      VAL.COMPS < > ],
                                        CONT.HOOK [ LTOP #nhand,
                                                    INDEX #ind ] ],
                                NONLOC.SLASH 0-dlist,
                                OPT - ] > ],
              AGR #ind & [ DIV - ] ],
      LKEYS.KEYREL.LBL #nhand ] ].

n_pp_c-dpt-sg-of_le := n_day_part_ppcomp_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s,
                                         GEN neut ] ].

n_pp_c-dpt-pl-of_le := n_day_part_ppcomp_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ].

n_np_pn-hol_le := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM basic_common_noun_npcomp_synsem &
           [ LOCAL [ CAT [ HEAD.MINORS [ MIN holiday_rel,
                                         ALTMIN proper_q_rel ],
                           VAL.COMPS < [ --MIN yofc_rel,
                                         NONLOC.SLASH 0-dlist ] > ],
                     CONT.HOOK.INDEX [ PNG png & [ PN 3s ],
                                       SORT time ] ],
             LKEYS.KEYREL.PRED holiday_rel ] ].

; 'Advent', 'summer', 'Christmas'
; DPF 20-jan-08 - Removed NORM norm_rel since this blocked e.g. "summer day"
; DPF 27-jan-08 - Remoevd LPERIPH na since this blocked "Paris summer day"
                           
n_-_m-ssn_lexent := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
           [ LOCAL [ CAT.VAL.SPR < unexpressed_reg >,
                     CONT [ HOOK.INDEX.PNG png & [ PN 3s ],
                            RELS <! nom_relation !> ] ],
             MODIFD notmod,
             LKEYS.KEYREL.PRED season_rel ] ].

; 'winter, summer' - "in winter", "*at winter"
n_-_m-ssn_le := n_-_m-ssn_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN season_rel ].

; 'Advent, Christmas' - "at Christmas"
n_-_m-hldy_le := n_-_m-ssn_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN season_nomod_rel ].

; DPF 21-dec-05 - Removed MODIFD.LPERIPH na, since it prevented e.g.
; NP-N-N compound 'Avdalen summer farm'
; DPF 29-jun-07 - But now getting 'summer farm' via making 'summer' a
; bare meas-NP, so add NORM norm_rel to prevent spurious N-N-cmpnd.
n_-_m-ssn-spr_le := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem &
           [ LOCAL [ CAT [ HEAD.MINORS [ MIN season_rel,
                                         ALTMIN quant_or_wh_rel,
                                         NORM norm_rel ],
                           VAL.SPR < expressed_synsem > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! !> ] ],
             MODIFD notmod,
             LKEYS.KEYREL.PRED season_rel ] ].

n_np_m-ssn_le := noun_noninfl_word &
  [ SYNSEM mass_noun_npcomp_synsem &
           [ LOCAL [ CAT [ HEAD.MINORS [ MIN season_rel,
                                         ALTMIN quant_or_wh_rel ],
                           VAL.COMPS < [ --MIN yofc_rel ] > ],
                     CONT.HOOK.INDEX.PNG png & [ PN 3s ] ],
             MODIFD notmod,
             LKEYS.KEYREL.PRED season_rel ] ].

; "the morning" etc.
; DPF 14-Oct-02 - Added ALTMIN relation to prevent these entries from 
; appearing as complements of "per", to avoid spurious ambiguity for e.g.
; "per night"
; DPF 15-Apr-03 - Removed strange constraint SPR..CONT.RELS <! relation !>,
; which blocked (among other things) "my mornings".  Instead, made
; SPR..MIN be def_explicit_q_rel to allow only "the" and possessive pronouns.

n_def_day_part_lexent := noncqrs-hm-nab & basic_noun_word &
  [ SYNSEM nomod_onearg_synsem &
	   [ LOCAL [ ARG-S < #spr >,
		     CAT [ HEAD noun & [ MINORS [ MIN def_day_part_rel,
                                                  ALTMIN norm_rel ] ],
			   VAL 
			    [ SPR < synsem & #spr &
				  [ --MIN basic_def_explicit_q_rel,
                                    LOCAL.CAT [ HEAD det,
                                                VAL [ SUBJ < >,
                                                      COMPS < > ] ],
                                   --SIND #inst,
                                    OPT - ] >,
			      COMPS < > ],
                           POSTHD + ],
		     AGR #inst,
                     CONT [ HOOK [ LTOP #nhand,
                                   INDEX #inst ],
			    RELS <! #keyrel !> ] ],
             LKEYS [ KEYREL #keyrel &
                            [ LBL #nhand,
                              ARG0 #inst & [ SORT time ] ],
                     ALTKEYREL relation ],
             MODIFD notmod & [ LPERIPH na_or_- ] ] ].

n_-_c-dpt-df-sg_le := n_def_day_part_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN neut ],
                               DIV - ] ].

n_-_c-dpt-df-pl_le := n_def_day_part_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Degree specifiers for adjectives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 'very, really, much, a lot, almost';
; Treated as measure phrases, selected as specifiers by adjectives.

;; DPF 27-Aug-01 - Removed INDEX ref-ind constraint, which was blocking
;; e.g. "kim is just behind the door"
;; DPF 8-Sep-01 - Added MODIFD.LPERIPH na to make sure that "about two weeks"
;; has this value, to block its appearing as head in n_n_compounds.
;; DPF 25-Sep-01 - Block specification of conjoined phrase for now, since we
;; don't know what to do with the semantics anyway.
;; DPF 10-Apr-03 - Made HEAD simply adv rather than old adv_or_partn, since
;; no need to treat these phrases as noun-like - solves several problems,
;; including avoiding these appearing as complements of prepositions.
;; Can probably get rid of LPERIPH specification now - check later.
;; DPF 26-sept-04 - Moved [XARG individual_min] down to lex_degree_spec
;; subtype, in order to allow measure-NPs (with phr_degree_spec_synsem) to
;; appear in appositive constructions like "three meters (10')".  (Can't
;; remember what this constraint is meant to exclude, but it's probably useful)
;; DPF 8-oct-05 - Yes, that constraint helps to block the spurious use of
;; the nonhead-compos variant of the head-specifier rule to pick up 
;; degree-specifiers, as in "at least part of ..." (since the nonhead-compos
;; variant requires its XARG to be a handle).

basic_degree_spec_synsem := canonical_synsem &
  [ LOCAL nomod_local &
          [ CAT [ VAL [ SUBJ < >,
                        COMPS < >,
                        SPR < [ --MIN degree_rel,
                                LOCAL [ CAT [ HEAD n_or_adv,
                                              VAL [ SPR *olist*,
                                                    SPEC < synsem > ] ],
                                        CONT.HOOK [ LTOP #khand,
                                                    XARG #spind ] ],
                                NONLOC.QUE 0-dlist ] > ] ],
            CONT.RELS.LIST.FIRST [ LBL #khand,
                                   ARG0 #spind ] ] ].

; DPF 11-Feb-02 - Can't have this be POSTHD - (and why did we want it?), 
; since the spec-head rule takes the value of POSTHD from the head's spr
; value, which blocked "kim arrives really soon".
; DPF 25-May-03 - Need POSTHD of specifier to be that of its SPEC, to make
; sure that "maybe in Berlin" is still POSTHD +.

basic_lex_degree_spec_synsem := basic_degree_spec_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD adv,
                  VAL.SPEC < [ LOCAL.CAT.POSTHD #ph,
                               MODIFD #modif ] >,
                  POSTHD #ph ],
            CONT [ HOOK [ INDEX #index,
                          XARG individual_min ],
                   RELS.LIST.FIRST #keyrel & [ ARG0 #index ] ] ],
    MODIFD #modif,
    LKEYS.KEYREL #keyrel ].

lex_degree_spec_synsem := basic_lex_degree_spec_synsem &
  [ LOCAL [ CAT.HEAD.MINORS.MIN degree_rel,
            CONT [ HOOK [ LTOP #ltop,
                          INDEX.E [ TENSE no_tense,
                                    ASPECT no_aspect ],
                          XARG #xarg ],
                   RELS.LIST.FIRST [ LBL #ltop,
                                     ARG1 #xarg ] ] ] ].

; For measure_nps as in "two foot tall"
; DPF 4-Nov-02 - Removed [ LOCAL.CONT.HOOK.XARG nothing ], since now identify
; XARGs of modifier and modifiee.  Why was it added before?

; phr_degree_spec_synsem := degree_spec_synsem & phr_synsem.
phr_degree_spec_synsem := basic_degree_spec_synsem & lex_phr_synsem &
  [ LOCAL [ CAT.VAL [ SPR < [ --MIN just_only_very_deg_rel ] >,
                      SPEC < [ LOCAL.CAT.VAL.COMPS #comps & < > ] >,
                      SPCMPS #comps ],
            CONT [ HOOK.XARG #xarg,
                   RELS.LIST.FIRST.ARG1 #xarg ] ] ].

; For "as" of "as soon as possible" and "too" in "too good to miss"

basic_comp_degree_spec_synsem := basic_lex_degree_spec_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN comp_rel,
                  VAL.SPEC < [ LOCAL [ CAT [ HEAD n_or_a_or_adv_or_det,
                                             VAL.COMPS < > ],
                                       CONT.HOOK.LTOP #ltop ] ] > ],
            CONT [ HOOK [ LTOP #ltop,
                          XARG #xarg ],
                   RELS <! arg12_relation &
                           [ LBL #ltop,
                             ARG0 event & [ E [ TENSE no_tense,
                                                ASPECT no_aspect ] ],
                             ARG1 #xarg ] !>,
                   HCONS <! !> ] ],
    NONLOC.QUE 0-dlist ].

comp_degree_wcomps_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_enough_rel,
                VAL [ SPCMPS < synsem & [ LOCAL.CONJ cnil,
                                          OPT -,
                                          PUNCT.LPUNCT no_punct ] > ] ] ].

comp_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL.SPCMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
						 INDEX #ind ],
			       NONLOC non-local_none ] > ],
    LKEYS.KEYREL [ LBL #ltop,
                   ARG2 #ind ] ].

as_degree_spec_synsem := comp_degree_spec_synsem &
  [ LOCAL.CAT.VAL.SPCMPS < [ --MIN _as_p_comp_rel,
                             LOCAL.CAT [ HEAD prep,
                                         VAL.COMPS < > ] ] >,
    LKEYS.KEYREL.PRED comp_equal_rel ].

more_degree_spec_synsem := comp_degree_spec_synsem &
  [ LOCAL.CAT.VAL.SPCMPS < [ --MIN _than_p_compar_rel,
                             LOCAL.CAT [ HEAD prep,
                                         VAL.COMPS < > ] ] > ].
                           
basic_too_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL [ SPCMPS < [ LOCAL [ CAT s_or_vp_inf_cat,
					 CONT [ HOOK.LTOP #ltop ] ] ] > ] ],
    LKEYS.KEYREL [ PRED comp_too_rel,
                   ARG2 #ltop ] ].

too_degree_spec_slash_synsem := basic_too_degree_spec_synsem &
  [ LOCAL.CAT.VAL [ SPCMPS < [ NONLOC.SLASH 1-dlist &
                                    <! [ CAT np_cat_acc_min &
                                             [ HEAD [ MINORS.MIN norm_nom_rel,
                                                      MOD < > ] ],
                                         CONT.HOOK.INDEX #ind ] !> ] >,
                    SPEC < [ LOCAL.CONT.HOOK.XARG #ind ] > ] ].

too_degree_spec_synsem := basic_too_degree_spec_synsem &
  [ LOCAL.CAT.VAL.SPCMPS < [ NONLOC.SLASH 0-dlist ] > ].

; DPF 15-aug-07 - Removed HEAD comp to allow "He was so late we couldn't wait"
so_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL [ SPCMPS < [ LOCAL [ CAT s_cat_fin_v_c,
					 CONT.HOOK [ LTOP #ltop,
						     INDEX.SF prop ] ],
				 NONLOC.SLASH 0-dlist ] > ] ],
    LKEYS.KEYREL [ PRED comp_so_rel,
                   ARG2 #ltop ] ].

; DPF 28-Apr-03 - Until we move to always discharging optional complements,
; we have to split 'as' into two lexical entries, one with an as-comp and one
; without, in order to be able to coordinate "as early and as late" where
; the top_coord_nom rule requires COMPS to be empty (since this 'as' pushes
; its complement to 'as early').

comp_degree_spec_nc_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL.CAT.VAL.SPCMPS < > ].

#|
comp_degree_spec_enough_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN enough_deg_rel,
                VAL [ SPR < anti_synsem_min >,
                      SPCMPS < > ] ],
    LKEYS.KEYREL.PRED comp_enough_rel ].
|#

comp_degree_spec_enough_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN enough_deg_rel,
		VAL [ SPCMPS < [ LOCAL [ CAT s_or_vp_inf_cat,
					 CONT [ HOOK.LTOP #ltop ] ] ] >,
		      SPR  < anti_synsem_min > ] ],
    LKEYS.KEYREL [ PRED comp_enough_rel,
                   ARG2 #ltop ] ].

basic_degree_spec_word := que_word &
  [ SYNSEM basic_lex_degree_spec_synsem &
           [ LOCAL.CONT.RELS.LIST < #keyrel, ... >,
             LKEYS.KEYREL #keyrel ] ].

degree_spec_word := basic_degree_spec_word &
  [ SYNSEM lex_degree_spec_synsem &
           [ LOCAL.CONT [ RELS <! degree_relation !>,
                          HCONS <! !> ],
             NONLOC.QUE 0-dlist ] ].

basic_adv_degree_spec_lexent :< degree_spec_word.

adv_degree_spec_lexent := basic_adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.ALTMIN non_event_rel,
                       VAL [ SPEC < [ LOCAL.CAT.VAL.COMPS #comps ] >,
                             SPCMPS #comps ] ] ].

; DPF 18-feb-08 - Changed MIN deg_rel to MIN much_or_very_deg_rel to avoid
; spurious spr-hd analysis for e.g. "under Berlin".
av_-_dg_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_or_very_deg_rel,
                       VAL.SPEC < [ LEX + ] > ] ].

av_-_dg-v_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN very_this_that_rel,
                       VAL.SPCMPS < > ] ].

av_-_dg-m_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL.SPEC < [ LEX + ] > ] ].

; This type allows unification with very_deg_rel, while the next does not.
av_-_dg-jov_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN just_only_degree_rel,
                       VAL.SPCMPS < > ] ].

av_-_dg-jo_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN just_only_deg_rel,
                       VAL.SPCMPS < > ] ].

; 'this much' 'this tall'
; DPF 18-mar-06 - To block "*my this tall chairs", allow SPEC to unify HS-LEX
; value '-', so "this tall" will be LEX -, and hence cannot modify 
; prenominally.  While 'tall' does this unification, 'many' does not, so we
; can still get "this many chairs'
av_-_dg-tt_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN this_that_deg_rel,
                       VAL.SPCMPS < >,
                       HS-LEX - ] ].

; This type requires unification with much_deg_rel, so cannot be used with
; e.g. determiner 'the', as in "straight (into ...)" or "up to (ten ...)"
av_-_dg-jom_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN just_only_much_deg_rel,
                       VAL.SPCMPS < > ] ].

; Set [HS-LEX +] which adj_synsem identifies with the spr's SPEC..HS-LEX,
; which is what the head-spec rule uses to set LEX on phrase, so we block
; '*the lake most beautiful' but allow 'the most beautiful lake'
av_-_dg-sup_le := basic_adv_degree_spec_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN this_that_deg_rel,
                                     ALTMIN superl_rel ],
                         VAL [ SPR < [ --MIN very_deg_rel ] >,
                               SPEC < [ LOCAL.CAT.HEAD a_or_adv ] >,
                               SPCMPS < [ --MIN #cmin & _of_p_sel_rel,
                                          LOCAL.CAT [ HEAD prep & 
                                                       [ PRD -,
                                                         TAM.TENSE nontense ],
                                                      VAL.COMPS < > ],
                                          NONLOC.SLASH 0-dlist ] > ],
                         HS-LEX + ],
             LKEYS.--COMPKEY #cmin ] ].

; Only for degree specs of determiners: 'not all, not many, not every'
av_-_dg-det_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN just_only_degree_rel,
                       VAL [ SPEC < [ LOCAL.CAT.HEAD det ] >,
                             SPCMPS < > ] ] ].

; Degree specs of directional preps: "all over New York"
;
av_-_dg-ppdir_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL [ SPEC < [ --MIN dir_rel ] >,
                             SPCMPS < > ] ] ].

; 'due' only for directions
av_-_dg-dir_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL [ SPEC < [ --MIN place_n_rel ] >,
                             SPCMPS < > ] ] ].

; 'roughly', 'wide(-spread)', 'jam(-packed)'
av_-_dg-ap_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN very_this_that_rel,
                       VAL [ SPEC < [ LOCAL.CAT [ HEAD adj,
                                                  VAL.COMPS #comps ] ] >,
                             SPCMPS #comps ] ] ].

; 'any'
av_-_dg-any_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL [ SPEC < [ LOCAL.CAT.VAL.COMPS #comps,
                                      LEX + ] >,
                             SPCMPS #comps ] ] ].

; "how tall"
; DPF 21-Jul-03 - Will want opt comp of-PP or indef-NP to get "how good (of) a
; player is he"
; DPF 07-mar-06 - Made semantics analogous to that of "To what degree is Kim
; tall?", thereby relating the degree index to Kim's index.
; DPF 30-sept-06 - Removed ALTMIN no_rel, since positive adj's now have
; ALTMIN norm_rel so 'most beautiful' can be treated as superlative in
; partitives like "the most beautiful arrived."

adv_wh_degree_spec_lexent := basic_degree_spec_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN degree_rel,
                           VAL [ SPCMPS #comps,
                                 SPEC < [ LOCAL 
                                          [ CAT.VAL.COMPS #comps & *obllist*,
                                            CONT.HOOK [ LTOP #sphand,
                                                        INDEX #spind ] ],
                                          NONLOC.SLASH 0-dlist ] > ],
                           HS-LEX - ],
                     CONT [ RELS <! [ LBL #hand,
                                      PRED abstr_deg_rel,
                                      ARG0 #arg0 ],
                                  [ PRED which_q_rel,
                                    ARG0 #arg0,
                                    RSTR #harg ],
                                  [ PRED measure_rel,
                                    LBL #sphand,
                                    ARG0.E.TENSE no_tense,
                                    ARG1 #spind,
                                    ARG2 #arg0 ] !>,
                            HCONS <! qeq & [ HARG #harg,
                                             LARG #hand ] !> ] ],
	     NONLOC.QUE 1-dlist & [ LIST < param > ] ] ].

; How tall
av_-_dg-v-wh_le := adv_wh_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN very_deg_rel ].

; How much taller
av_-_dg-m-wh_le := adv_wh_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN much_deg_rel ].

av_pp_dg-as_le := que_word &
  [ SYNSEM as_degree_spec_synsem ].

av_vp_dg-too_le := que_word &
  [ SYNSEM too_degree_spec_synsem ].

av_vpslnp_dg-too_le := que_word &
  [ SYNSEM too_degree_spec_slash_synsem ].

av_cp_dg-so_le := que_word &
  [ SYNSEM so_degree_spec_synsem ].

av_pp_dg-cmp_le := que_word &
  [ SYNSEM more_degree_spec_synsem ].

; DPF 13-Nov-03 - Constrained SPEC value to be PRD + to prevent "The as tall
; player ..." or "the too beautiful chair ..."
; DPF 16-mar-06 - But this is in conflict with our revised treatment of
; 'many' as an adjective, as in "too many chairs".  So instead constrain
; the SPEC's HS-LEX to be -.

av_-_dg-cmp-so_le := que_word &
  [ SYNSEM comp_degree_spec_nc_synsem & 
           [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
                         HS-LEX - ] ] ].

; DPF 12-jul-06 - Changed MIN much_or_very_deg_rel to more_deg_rel
; to block "more many" but still allow "very many"
av_-_dg-cmp-more_le := que_word &
  [ SYNSEM comp_degree_spec_nc_synsem &
           [ LOCAL.CAT.HEAD.MINORS.MIN more_deg_rel ] ].

av_-_dg-enough_le := que_word &
  [ SYNSEM comp_degree_spec_enough_synsem ].

; For measure-np ersatz
; NORM norm_rel prevents these from also appearing in noun_n_cmpnds, 
; leaving only the np_n_cmpnd we want for "200m climb"
; DPF 7-mar-05 - Removed MODIFD notmod since this prevented "200m away" from
; undergoing the npadv rule, and its motivation remained obscure.
; DPF 29-mar-05 - Changed MIN to deg_rel so we get "half an hour before Kim
; arrives"
n_-_meas_le := noncqrs-hm & word &
  [ INFLECTD #bool,
    SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MINORS [ MIN meas_nom_rel,
                                                  ALTMIN udef_q_rel,
                                                  NORM quantity_rel ],
                                         PRD #bool,
                                         MOD < > ],
                           VAL [ SPR < anti_synsem_min >,
                                 SPEC < >,
                                 COMPS < > ] ],
                     AGR.PNG.PN 3s,
                     CONT [ HOOK [ LTOP #nhand,
                                   INDEX #nindex ],
                            RELS <! #keyrel & named_nom_relation &
                                    [ LBL #nhand,
                                      ARG0 #nindex ],
                                    [ PRED udef_q_rel,
                                      ARG0 #nindex,
                                      RSTR #rhand ] !>,
                            HCONS <! qeq &
                                   [ HARG #rhand,
                                     LARG #nhand ] !> ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             LKEYS.KEYREL #keyrel ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Numbers
;;
;; DPF 14-Apr-01 - Numerals combine with their complements and specifiers as
;; laid out in Smith 2000, but since the specifier-head rule makes the TOP
;; handle of the phrase be that of the spr dtr, we can't have numerals simply
;; identify their LTOP value with their KEY.LBL value or something similar.
;; Hence, numerals combine using the LBL of the attribute ALTMIN, which
;; points to the MIN for simple numerals like "two", but to the plus_rel or
;; the times_rel for more interesting numerals like "hundred".  
;;   The LTOP handle is identified with the SPEC's handle, so when a numeral is
;; built using the specifier-head rule, the resulting LTOP handle will be the 
;; same as the LTOP handle of the head-dtr.  This is useful because of two other
;; regularities:
;;   (1) the MOD's handle is identified with the ALTKEY's handle; and
;;   (2) the intersective modifier-head rule identifies the MOD's handle with
;;       the modifier's LTOP handle.
;; This ensures that the LTOP handle of a numeral modifier will be identified
;; with the ALTKEY's handle, as desired.

; For numerals
anycard_norm_num_synsem := canonical_synsem & basic_zero_arg &
  [ LOCAL [ CAT [ HEAD intadj,
                  VAL.SUBJ < >,
		  POSTHD - ],
	    CONT [ HOOK.XARG non_expl,
                   RELS.LIST < integer_relation, ... > ] ] ].

; DPF 6-Jun-01 - Added MODIFD.LPERIPH - to avoid unwanted reading for 
; "two hundred three chairs".
; But this blocks "two competent programmers", so make [LPERIPH na].
; DPF 28-Apr-03 - This PERIPH feature is overloaded since it does not
; distinguish directionality - the two uses clash for examples like "the
; first chair that I bought arrived" where for ordering of thatless and
; full relatives we want "chair that I bought" to be (right) [PERIPH +] but 
; to avoid double ordinals we want it to be (left) [PERIPH -].  So change to
; two features LPERIPH and RPERIPH.
; DPF 16-oct-03 - Since now making adj+N be [LPERIPH +], change this type so
; it asks for a MOD..LPERIPH bool but projects LPERIPH na so we can still
; block unwanted parse for "two hundred three chairs" but allow "two hundred
; big chairs".
; Pushed this down to cards, not ords, so we can get "the first seven chairs...
; DPF 06-jun-06 - Moved constraint MOD..SPR expressed_synsem down to cards,
; since this wrongly rejected "many second homes", "some third floors".  
; 24-aug-06 - Re: 16-oct-03: Making "three chairs" be LPERIPH na sadly means
; they can appear within N-N compounds, as in "*mountain first hotel".  Happily
; we aren't actually claiming that adj-N be [LPERIPH +] now, so we can go
; back to requiring that these numerical adjectives modify something which
; is LPERIPH - (could probably also be na, but leave out for now), but they
; themselves are LPERIPH +, still preventing recursion.

basic_norm_num_synsem := anycard_norm_num_synsem &
  [ LOCAL 
     [ CAT 
        [ HEAD.MOD 
           < [ LOCAL intersective_mod &
               [ CAT nbar_cat_min & [ HEAD.MINORS.MIN nonpro_rel ],
                 CONT.HOOK.INDEX #xarg,
                 CONJ cnil ] ] >,
          HC-LEX + ],
       CONT [ HOOK [ INDEX #index,
                     XARG #xarg ],
              RELS.LIST.FIRST [ ARG0 #index,
                                ARG1 #xarg ] ] ],
    MODIFD notmod_or_rmod & [ LPERIPH na_or_+ ] ].

norm_num_synsem := basic_norm_num_synsem & zero_arg &
  [ LOCAL.CONT.RELS.LIST.FIRST #keyrel,
    LKEYS.KEYREL #keyrel ].

; DPF 9-jul-04 - Is this used?
phr_norm_num_synsem := basic_norm_num_synsem & phr_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ MODIFD.LPERIPH bool ] >,
            CONT [ HOOK.INDEX event & 
                              [ E [ TENSE no_tense,
                                    ASPECT no_aspect ] ],
                   HCONS <! !> ] ] ].

; DPF 05-apr-05 - Moved PRD - to norm_card_word since it blocks "Kim was third"

norm_num_word := noncqrs-m-nab & word &
  [ SYNSEM norm_num_synsem ].

;; some norm_card-words must remain unspecified for CARDINAL
;; DPF 10-Apr-02 - Moved MOD..DIV +* from norm_num_word to norm_card_word
;; since ordinals don't require this: "the eleventh child"
; DPF 27-nov-04 - In fact, DIV value must come from the same source as
; the value for CARDINAL: "twenty ninth" isn't DIV + but "twenty nine" is
; DPF 17-jun-07 - Enabled cardinals to be specifiers of 'more' as in
; 'ten more cats arrived'.

norm_card_word := norm_num_word &
  [ SYNSEM 
    [ LOCAL.CAT [ HEAD [ MOD < [ MODIFD.LPERIPH -,
                                 LOCAL.CAT.VAL.SPR < expressed_synsem &
                                                    [ --MIN explicit_q_rel]>]>,
                         PRD -,
                         MINORS.MIN card_rel ],
                  VAL [ SPEC < [ LOCAL.CAT.VAl.COMPS #comps ] >,
                        SPCMPS #comps ] ],
      LKEYS.KEYREL.PRED basic_card_rel ] ].

;; those cardinals that take no complements may be safely specified as 
;; +CARDINAL, and as plural (since they're normal)

card_only_word := norm_card_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.CARDINAL +,
                   CONT.HOOK.XARG.PNG png & [ PN 3p ] ] ].

; should be POSTHD -
; These are adjectives only

; DPF 25-apr-04 - Added SPEC < anti_synsem_min > to prevent ordinals from
; undergoing the partitive_num rule, which is designed to handle not only
; cardinal numbers but also superlatives as in "the best arrived", and
; measure phrases ("ten feet of rope"), while excluding ordinary NPs.
; --FIX-- This won't scale up to complex ordinals like "twenty-second"
; which are different from "twenty-two" only in the CARDINAL feature, so
; CARDINAL would have to be introduced higher up than on the type intadj.
; DPF 26-aug-04 - Added variant of partitive rule for cardinals and ordinals,
; (which produces a sign that like common nouns requires a determiner),
; still using SPEC < anti_synsem_min > to distinguish the two.

ord_word := norm_num_word & 
  [ SYNSEM [ LOCAL.CAT [ HEAD [ CARDINAL -,
                                MINORS.MIN ord_rel ],
                         VAL [ COMPS < >,
                               SPEC < synsem &
                                      [ LOCAL.CAT [ HEAD basic_adj &
                                                         [ MINORS.ALTMIN 
                                                               superl_rel ],
                                                    VAL.COMPS #comps ] ] >,
                               SPCMPS #comps ] ],
             LKEYS.KEYREL.PRED basic_ord_rel ] ].

;;  Specifiers and modifiers will agree with heads on the value
;; of the head feature CARDINAL -- this allows propagation
;; of such a feature from complements, where (on the current account)
;; the CARDINAL feature gets a value from the lexicon.

;; distribution of CARDINAL:
;;   ordinal lex_entries are CARDINAL -
;;   complement_free lex_entries are CARDINAL +
;;   all lex_entries for "one" are CARDINAL +
;;   other lex_entries are unspecified for CARDINAL
;; Since (the HEAD feature of) the determiner "one" is outside this 
;; hierarchy, it can't appear as a specifier or complement.


;; The sorts below refer only to lexical entries, so there's presumably no
;; harm in making conventions about the order of the RELs on their RELSs
;; No particular order is assumed for any phrase containing these entries.

;; It will be hard to do optional complements here and get the RELSs to
;; come out right.  Another problem with optional complementation is that
;; entries with complements must be -ORD, while their complement-taking
;; counterparts must be underspecified for ORD 
;;   (cf. "twenty" vs. "twenty one" vs. "twenty first")


complement_free_number := norm_num_word &
			  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

complemented_number := norm_num_word &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD [ CARDINAL #card,
                           MOD < [ LOCAL.AGR.DIV #div ] > ],
		    VAL.KCMP lex_synsem &
                                [ OPT -,
				  LOCAL [ CAT [ HEAD intadj & 
						[ CARDINAL #card,
                                                  MOD < [ LOCAL.AGR.DIV 
                                                                   #div ] > ],
                                                VAL [ SPR *olist*,
						      COMPS < > ] ],
                                          CONT.HOOK.XARG #arg & [ PNG #num ] ],
                                  NONLOC.SLASH 0-dlist,
                                  PUNCT.LPUNCT no_punct ] ],
	      CONT [ HOOK.XARG.PNG #num,
		     RELS.LIST < relation, [ PRED plus_rel ], ... > ] ],
      LKEYS.KEYREL.ARG1 #arg ] ].
		   

; Non-identity stipulated for handle of SPR and handle of CONT in order to
; prevent the regular head-spec rule (non-head-compositional) from applying.
; Need head-compositional since the handle of the phrase "two hundred" must
; be the handle of the times_rel from the head "hundred" (which contains as
; arguments the other two handles).

specified_number := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < synsem &
                               [ OPT -,
                                 LOCAL [ CAT [ HEAD intadj & 
                                                    [ CARDINAL + ],
                                               VAL [ COMPS < >,
                                                     SPR *olist*,
                                                     SPCMPS < > ] ] ] ] > ].
				 
; DPF 01-Feb-03 - Removed the degree specifier, since we don't want to parse
; "*the exactly five chairs arrived".  We'll ignore "the nearly fifty people".
; DPF 10-dec-03 - Made SPR be < anti_synsem_min > so we can still use the 
; normal adjective-coordination rule.  
; DPF 21-sept-04 - But we also want "exactly five people arrived".  Seems to
; support the idea of ambiguous 'five': (1) an adjective which takes no 
; specifier and which always co-occurs with a determiner; and (2) a 
; determiner which can have a degree specifier.  Already have this ambiguity
; for 'one' (necessarily, to get "one chair arrived"), but degree sprs give
; reason to do it consistently for cardinals.  Note that only the cardinals
; would have the determiner entry; ordinals are only adjectives, and don't
; occur with degree specifiers.  So added num_det syntactic rule, and removed
; the idiosyncratic lexical type (and entries) for determiner "one".
; DPF 22-sept-04 - Removed SPEC < anti_synsem_min > which was preventing
; "(exactly) two of the chairs arrived"

unspecified_num := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < anti_synsem_min > ].

; DPF 17-jun-07 - Removed SPEC..COMPS < > since this blocks e.g 'ten more
; cats than dogs', and can't remember why it was here.

unspecified_num_without_complements := complement_free_number & 
                                       unspecified_num &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN const_rel,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! const_relation & [ LBL #ltop ] !> ] ] ].

approx_unspecified_num_without_complements := complement_free_number & 
                                              unspecified_num &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
                           VAL.SPEC < anti_synsem_min > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! const_relation & [ LBL #ltop ],
                                    [ PRED approx_grad_rel,
                                      ARG1 #arg0 ]  !> ] ],
             LKEYS.KEYREL.ARG0 #arg0 ] ].

unspecified_num_with_complements := complemented_number & unspecified_num &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
                         VAL.KCMP [ --MIN integer_rel,
                                    LOCAL.CONT.HOOK.LTOP #chandle ] ],
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! const_relation &
                                  [ LBL #khandle,
                                    ARG1 #arg ],
                                  [ LBL #ltop,
                                    ARG1 #arg,
                                    ARG2 handle & #khandle,
                                    ARG3 handle & #chandle] !> ] ] ].

specified_num_without_complements := complement_free_number & 
                                     specified_number &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
                         VAL [ SPR < [ LOCAL.CONT.HOOK [ LTOP #shandle,
                                                         XARG #arg ] ] >,
                               SPEC < [ LOCAL.CAT.VAL.COMPS < > ] > ] ],
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! const_relation & 
                                  [ LBL #khandle,
                                    ARG1 #arg & [ PNG.PN 3p ] ],
                                  [ LBL #ltop,
                                    PRED times_rel,
                                    ARG1 #arg,
                                    ARG2 handle & #shandle,
                                    ARG3 handle & #khandle ] !> ] ] ].

specified_num_with_complements := complemented_number & specified_number & 
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
                         VAL [ SPR < [ LOCAL.CONT.HOOK [ LTOP #shandle,
                                                         XARG #arg ] ] >,
                               SPEC < [ LOCAL.CAT.VAL.COMPS < > ] >,
                               KCMP #kcmp,
                               COMPS < #kcmp &
                                       [ LOCAL.CONT.HOOK [ LTOP #chandle,
                                                           XARG #arg ] ] > ] ],
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! [ LBL #khandle,
                                  ARG1 #arg ],
                                [ LBL #ltop,
                                  ARG1 #arg,
                                  ARG2 handle & #thandle,
                                  ARG3 handle & #chandle ],
                                [ LBL #thandle,
                                  PRED times_rel,
                                  ARG1 #arg,
                                  ARG2 handle & #shandle,
                                  ARG3 handle & #khandle ] !> ] ] ].

basic_adj_bare_unspecified_card_lexent := card_only_word & 
                                          unspecified_num_without_complements.
adj_bare_unspecified_card_lexent := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM [ MODIFD.LPERIPH na,
	     LKEYS.KEYREL.PRED card_rel ] ].
adj_bare_unspecified_card_wcomps_lexent := card_only_word & 
                                           unspecified_num_with_complements &
  [ SYNSEM [ LOCAL.CAT.VAL [ KCMP #kcmp,
			     COMPS < #kcmp &
                                   [ LOCAL [ CAT.HEAD fractadj,
                                             CONJ num-conj ] ] > ],
	     LKEYS.KEYREL.PRED card_rel ] ].

; DPF 12-aug-07 - Add variants to enable named numbers in compounds, as in
; "the 280 freeway", while still blocking spurious parse for "the five cats"

aj_-_i-crd-one_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].
aj_-_i-crd-two_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].
aj_-_i-crd-thr_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj3 ].
aj_-_i-crd-six_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj6 ].
aj_-_i-crd-nine_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj9 ].
aj_-_i-crd-twlv_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj12 ].

aj_-_i-dig-one_le := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj1,
             MODIFD.LPERIPH +,
	     LKEYS.KEYREL.PRED card_rel ] ].
aj_-_i-dig-two_le := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj2,
             MODIFD.LPERIPH +,
	     LKEYS.KEYREL.PRED card_rel ] ].
aj_-_i-dig-thr_le := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj3,
             MODIFD.LPERIPH +,
	     LKEYS.KEYREL.PRED card_rel ] ].

aj_np_i-crd-one_le := adj_bare_unspecified_card_wcomps_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].

adj_bare_specified_card_lexent := card_only_word & 
                                  specified_num_without_complements &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC *anti_list*,
             MODIFD.LPERIPH na,
	     LKEYS.KEYREL.PRED card_rel ] ].

aj_-_i-crd-hnd_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].
aj_-_i-crd-dzn_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj2,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].
aj_-_i-crd-thd_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
aj_-_i-crd-mln_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
aj_-_i-crd-bln_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
aj_-_i-crd-trln_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj15,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].

aj_np_i-crd-nsp_le := norm_card_word & unspecified_num_with_complements &
  [ SYNSEM [ LOCAL.CAT [ HEAD intadj2,
                       VAL [ KCMP #kcmp,
                             COMPS < [ LOCAL.CAT.HEAD punct_hd,
                                       PUNCT [ LPUNCT hyphen_sgl,
                                               RPUNCT no_punct ] ],
                                     #kcmp & 
                                     [ LOCAL [ CAT.HEAD intadj1,
                                               CONJ cnil ] ] > ] ],
	     LKEYS.KEYREL.PRED card_rel ] ].

adj_complemented_specified_card_lexent := norm_card_word & 
                                          specified_num_with_complements &
  [ SYNSEM.LKEYS.KEYREL.PRED card_rel ].

aj_np_i-crd-hnd_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj2-,
                             COMPS.FIRST [ LOCAL.CAT.HEAD intadj2-,
                                           MODIFD.LPERIPH na ] ] ] ].
aj_np_i-crd-thd_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj3- ] ] ].
aj_np_i-crd-mln_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj6- ] ] ].
aj_np_i-crd-bln_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj9- ] ] ].

aj_np_i-crd-trln_le := adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj15,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj12- ] ] ].

; unknown_word &
aj_-_i-crd-unk_le := basic_adj_bare_unspecified_card_lexent & unknown_word &
  [ SYNSEM.MODIFD.LPERIPH na ].

aj_-_i-two-gen_le := adj_bare_unspecified_card_lexent & generic_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].

aj_-_i-thr-gen_le := adj_bare_unspecified_card_lexent & generic_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD intadj3 ].

aj_-_i-six-gen_le := adj_bare_unspecified_card_lexent & generic_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD intadj6 ].

aj_-_i-nine-gen_le := adj_bare_unspecified_card_lexent & generic_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD intadj9 ].

aj_-_i-twlv-gen_le := adj_bare_unspecified_card_lexent & generic_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD intadj12 ].

basic_adj_bare_unspecified_ord_lexent := ord_word & 
					 unspecified_num_without_complements.
adj_bare_unspecified_ord_lexent := basic_adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED ord_rel ].

aj_-_i-ord-one_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].
aj_-_i-ord-two_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].
aj_-_i-ord-thr_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj3 ].
aj_-_i-ord-six_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj6 ].
aj_-_i-ord-nine_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj9 ].
aj_-_i-ord-twlv_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj12 ].

adj_bare_specified_ord_lexent := ord_word & specified_num_without_complements &
  [ SYNSEM.LKEYS.KEYREL.PRED ord_rel ].

aj_-_i-ord-hnd_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
aj_-_i-ord-thd_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
aj_-_i-ord-mln_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj6- ] ].

aj_-_i-ord-unk_le := basic_adj_bare_unspecified_ord_lexent & unknown_word.

aj_-_i-crd-app_le := card_only_word & 
                     approx_unspecified_num_without_complements &
  [ SYNSEM [ LOCAL.CAT.HEAD intadj2,
             MODIFD.LPERIPH na,
	     LKEYS.KEYREL.PRED card_rel ] ].

;; the constraints appropriate for all lexical entries for "one"
;; DPF 2-Feb-01 - Removed [ SPEC..OPT - ], since blocked "the one year old boy"
;; and it's not clear what it was for.
;; DPF 17-Nov-01 - Added LPERIPH na like with other numbers.  Don't know why
;; a_one_sing and a_one_plur were marked [LPERIPH -], but need LPERIPH + to 
;; block application of nominal modifier rules to measure_nps including 
;; "an inch"
; DPF 25-Jun-03 - Tried making this [DIV -] to block "*one tobacco 
; arrived" but this is the same "one" used in "one dozen chairs arrived".
; Would want something fancier, where [DIV +] implied plural number,
; to just exclude mass nouns.

basic_one_num_synsem := anycard_norm_num_synsem & zero_arg &
  [ LOCAL [ CAT [ HEAD intadj & 
                       [ CARDINAL +,
                         MINORS.MIN card_rel ],
                  VAL [ SPR < anti_synsem_min >,
                        SPEC < [ LOCAL.CAT.VAL.COMPS #comps ] >,
                        SPCMPS #comps ] ],
            CONT [ HOOK [ INDEX #arg0,
                          XARG #index ],
                   RELS.LIST.FIRST #keyrel &
                             [ PRED card_rel,
                               ARG0 #arg0,
                               ARG1 #index ] ] ],
    LKEYS.KEYREL #keyrel,
    PUNCT [ LPUNCT no_punct,
            RPUNCT no_punct,
            PNCTPR ppair ] ].

one_num_synsem := basic_one_num_synsem &
  [ LKEYS.KEYREL.CARG "1" ].

one_num_fract_synsem := one_num_synsem & 
  [ LOCAL [ CAT [ HEAD.PRD -,
                  VAL.COMPS < [ --MIN fraction_rel,
                                LOCAL [ CAT [ HEAD fractadj,
                                              VAL.COMPS < > ],
                                        CONT.HOOK [ LTOP #fhand,
                                                    XARG #ind ] ],
                                OPT -,
                                PUNCT.LPUNCT no_punct ] > ],
            CONT [ HOOK.LTOP #hand,
                   RELS <! [ LBL #chand,
                             ARG1 #ind ],
                         [ LBL #hand,
                           PRED plus_rel,
                           ARG1 #ind,
                           ARG2 handle & #chand,
                           ARG3 handle & #fhand ] !> ] ],
    MODIFD.LPERIPH + ].

one_word := word_or_lexrule &
  [ INFLECTD +,
    SYNSEM one_num_synsem & 
           [ MODIFD.LPERIPH + ] ].

; DPF 29-May-02 - Made adj_one_lexent be HEAD intadj1 not intadj, to
; avoid "let's meet at five one" meaning "five oh one"
; DPF 13-May-03 - Managed to get by with just one entry for adj "one", even
; though we need "forty one chairs" to sustain plural number on the semantic
; index for "one", by making the 3s constraint on the AGR of the modified
; noun, so when "one" is directly a modifier, it will only modify 3s nouns.
; (This simplification also required modifying the part-num rule to unify the
; daughter's MOD..AGR value with the dtr's own AGR.
; DPF 31-May-02 - Added PRD stipulation to distinguish "one" from "a/an" for
; e.g. partitive-num and num-noun rules.
; DPF 30-sept-06 - Removed MOD..INDEX.PNG.PN 3s since this prevents making
; "one hundred" since "hundred" modifies plural noun.

aj_-_i-one_le := one_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD intadj1 &
                            [ PRD -,
                              MOD < [ --MIN nonpro_rel,
                                      LOCAL intersective_mod &
                                            [ CAT nbar_cat_min,
                                              CONT.HOOK [ LTOP #ltop,
                                                          INDEX #index ],
                                              CONJ cnil,
                                              AGR.PNG.PN 3s ],
                                      MODIFD.LPERIPH - ] > ],
                           VAL.COMPS < > ],
                     CONT [ HOOK [ LTOP #ltop,
                                   XARG #index ],
                            RELS <! relation !> ] ],
             LKEYS.KEYREL.LBL #ltop ] ].


aj_np_i-frct-one_le := one_word &
  [ SYNSEM one_num_fract_synsem &
           [ LOCAL [ CAT [ HEAD intadj1 & 
                                [ MOD < [ --MIN nonpro_rel,
                                          LOCAL intersective_mod &
                                                [ CAT nbar_cat_min,
                                                  CONT.HOOK [ LTOP #ltop,
                                                              INDEX #index ],
                                                  CONJ cnil,
                                                  AGR.PNG.PN 3s ],
                                          MODIFD.LPERIPH - ] > ],
                           VAL.COMPS < lex_synsem >,
                           HC-LEX + ],
                     CONT.HOOK [ LTOP #ltop,
                                 XARG #index ] ] ] ].

; 'a/an' of 'the string is an inch long'
; DPF 21-May-03 - Even though these are PRD + to keep them out of partitives
; and num-nouns, we still don't want them showing up as predicative complements
; and so we make them MOD anti_synsem_min, so they are incompatible with 
; prd_cat.
; DPF 5-jul-04 - While these are MOD < anti_synsem_min >, we still want to 
; prevent them from combining with plural nouns in measure-NP constructions 
; which are indifferent to PRD value, namely as complements of PPs - e.g. to 
; block *Kim arrives in a weeks".  So add AGR constraint to MOD value, which 
; the measure-NP rule already enforces.
; DPF 28-aug-04 - Since no longer using PRD to distinguish types of NPs (see
; note by nomp_cat), constrain these to combine with lexically marked 
; measure-nouns to keep an artificial lid on spurious ambiguity.  So
; allowing "an inch is enough" with MNP, but not "an engineer is enough".
; DPF 12-oct-05 - These were PRD + (see 21-May-03), but this meant we were
; parsing "*Kim found it a" analogous to "Kim found it pleasant".  So instead,
; make these [PRD -] and constrain the rules for partitives and num-dets to 
; exclude anti_synsem MOD values. (The num-noun rule is already blocking due 
; to the ALTMIN value.)
; DPF 26-apr-08 - Re 21-may-03: removed MOD < anti_synsem_min ... > because 
; the measure_np rule requires MOD < synsem >.  These no longer undergo
; num_noun rule because of ALTMIN no_rel.  
; DPF 27-apr-08 Added MODIFD hasmod to prevent these from undergoing 
; partitive_num rule.

adj_one_an_lexent := word_or_lexrule &
  [ INFLECTD +,
    SYNSEM one_num_synsem & 
           [ LOCAL.CAT.HEAD intadj1 &
                                [ MOD < [ --MIN abstr_meas_nom_rel,
                                          LOCAL [ CAT.HEAD noun,
						  AGR.PNG.PN 3s ] ] >,
                                  MINORS.ALTMIN no_rel ],
	     MODIFD hasmod ] ].

; DPF 27-apr-08 - Tried adding MODIFD lmod but this also blocks "a hundred", 
; which we want. So instead, constrain num_det rule

adj_one_prd_lexent := adj_one_an_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.PRD -,
			   VAL.COMPS < > ],
		     CONT [ HOOK.LTOP #ltop,
                            RELS <! [ LBL #ltop ] !> ] ],
             MODIFD.LPERIPH na ] ].

aj_-_i-one-nmd_le := adj_one_prd_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET con_or_unk ] > ].

aj_-_i-an-nmd_le := adj_one_prd_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET voc_or_unk ] > ].

; For 'several thousand' 'a few dozen'
; DPF 3-May-08 - Add MOD..NORM norm_rel to block "a few cat" from being
; left member of n-n-cmpnd.

aj_-_i-num_le := word_or_lexrule &
  [ INFLECTD +,
    SYNSEM basic_one_num_synsem &
           [ LOCAL [ CAT [ HEAD intadj1 &
                                [ PRD -,
                                  MOD < anti_synsem_min & 
                                        [ --MIN abstr_meas_nom_rel,
                                          LOCAL [ CAT.HEAD.MINORS.NORM norm_rel,
						  AGR.PNG.PN 3s ] ] >,
				  MINORS.ALTMIN no_rel ],
                           VAL.COMPS < > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! [ LBL #ltop ] !> ] ] ] ].

; 'a/an' of 'a meter and a half of snow'
; DPF 10-dec-03 - The 'and a half' synsem cannot be represented as a COMP
; since it can't be discharged until after 'a/an' has combined with the noun
; using the measure-NP rule, unlike say 'twenty' of 'twenty two foot'.  So
; this synsem is treated as a SPEC value, and is propagated by the MNP rule
; onto the COMPS list of the phrase.
; [HC-LEX -] prevents "*an and a half hours" since MNP rule requires left dtr
; to be LEX +, so get "one and a half hours".
; DPF 05-may-05 - Re 10-dec-03: corrected, and now put the complement on COMPS.

adj_one_fract_lexent := adj_one_an_lexent &
  [ SYNSEM one_num_fract_synsem &
           [ LOCAL.CAT [ VAL.COMPS < phr_synsem >,
                         HC-LEX - ],
             MODIFD.LPERIPH + ] ].

aj_np_i-frct-a_le := adj_one_fract_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET con_or_unk ] > ].

aj_np_i-frct-an_le := adj_one_fract_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET voc_or_unk ] > ].

aj_np_i-frct-ath_le := adj_one_fract_lexent.

; 'a half'
fraction_num_synsem := anycard_norm_num_synsem & abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD fractadj & 
                       [ CARDINAL +,
                         MINORS.MIN fraction_rel ],
                  VAL [ SPR < >,
                        COMPS < >,
                        SPEC < > ] ],
            CONT [ HOOK [ LTOP #lbl,
                          XARG #index ],
                   RELS <! #keyrel &
                         [ PRED fraction_rel,
                           LBL #lbl,
                           ARG1 #index ] !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL #keyrel,
    MODIFD.LPERIPH na ].

fraction_word := word_or_lexrule &
  [ INFLECTD +,
    SYNSEM fraction_num_synsem &
           [ PUNCT no_punctuation_min ] ].

aj_np_i-frct_le := fraction_word.

; Temporary types to cope with unknown words - used in PET
generic_lex_entry := word.

basic_unknown_word := generic_lex_entry & nonconj & mcna.

unknown_word := basic_unknown_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL [ LBL #ltop,
			    PRED generic_unk_rel ],
	     PHON.ONSET unk_onset ] ].

generic_v_np*_trans_lex_entry := unknown_word & basic_main_verb &
  [ SYNSEM np_trans_verb &
	   [ LOCAL [ CAT.VAL.COMPS < [ OPT + ] >,
		     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel & arg12_carg_relation &
                          [ PRED generic_unk_verb_rel ] ] ].

v_np*_bse-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL bse_verb ].
v_np*_pr-3s-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL third_sg_fin_verb ].
v_np*_pr-n3s-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL non_third_sg_fin_verb ].
v_np*_pa-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL past_or_subj_verb ].
v_np*_psp-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL psp_verb ].
v_np*_prp-unk_le := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL prp_verb ].
v_-_pas-unk_le := unknown_word & basic_main_verb & 
  [ SYNSEM passive_unerg_synsem &
           [ LOCAL.CONT.HCONS <! !>,
	     LKEYS.KEYREL arg12_carg_relation &
			      [ PRED generic_unk_verb_rel ] ] ].

; DPF 15-may-08 - Don't identify AGR with HOOK.INDEX, since we want uninflctd
; mass-or-count to be modifiable by plural adjectives, as in "six glump house"
;
generic_n_intr_lex_entry := basic_unknown_word &
  [ SYNSEM unsp_common_noun_synsem &
	   [ LOCAL [ CAT [ HEAD noun & [ MINORS.MIN norm_nom_rel ],
                           VAL.SPR < [ --MIN quant_or_wh_rel ] > ],
                     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel & reg_nom_wcarg_relation &
                   [ PRED generic_unk_nom_rel ],
             MODIFD notmod ] ].

n_-_c-sg-unk_le := generic_n_intr_lex_entry & unknown_word &
  [ SYNSEM noun_nocomp_synsem & [ LOCAL sing_noun ] ].

n_-_m-unk_le := generic_n_intr_lex_entry & unknown_word &
  [ SYNSEM mass_noun_synsem & [ LOCAL mass_noun ] ].

; DPF 12-may-08 - Let's try restricting this to singular, letting the
; tagger predict plural nouns separately

n_-_mc-unk_le := generic_n_intr_lex_entry &
  [ INFLECTD -,
    SYNSEM basic_mass_or_count_nocomp_synsem & 
           [ LOCAL noun_local &
		   [ CAT [ HEAD.--BARE -,
			   VAL.SPR < [ LOCAL.AGR.PNG.PN 3s ] > ],
                     CONT.HOOK.LTOP #ltop,
		     AGR.PNG.PN 3s ],
             LKEYS.KEYREL.LBL #ltop,
	     PHON.ONSET unk_onset ] ].

n_-_c-pl-unk_le := generic_n_intr_lex_entry & unknown_word &
  [ SYNSEM mass_or_count_nocomp_synsem & 
           [ LOCAL plur_noun ] ].

n_-_c-tt-unk_le := noncqrs-m-nab & unknown_word &
  [ SYNSEM title_synsem &
           [ LKEYS.KEYREL reg_nom_wcarg_relation ] ].

; DPF 12-sept-07 - Restrict these to attributives, since the predicatives
; give rise to too much ambiguity (esp. with depictives and robust-np-sg).
; DPF 11-may-08 - But we need these in predicative position as well, so
; block from depictives via MINORS.NORM
aj_-_i-unk_le := unknown_word &
  [ SYNSEM intrans_adj_synsem &
           [ LOCAL [ CAT [ HEAD adj & 
			      [ MOD < [ --SIND #ind ] >,
				MINORS [ ALTMIN norm_adj_rel,
					 NORM norm_rel ] ],
			   VAL.SPR < anti_synsem_min > ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! #keyrel !> ] ],
             LKEYS.KEYREL #keyrel & adj_wcarg_relation &
                          [ PRED generic_unk_adj_rel,
                            ARG1 #ind ],
	     NONLOC non-local_none ] ].

aj_-_i-cmp-unk_le := unknown_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind ] >,
                                  MINORS.ALTMIN comp_rel ],
                           VAL [ SPR < [ --MIN much_deg_rel ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
                                      ARG1 #ind ],
                                  #altkeyrel &
                                  [ LBL #hand,
                                    ARG1 #ind ] !> ] ],
             LKEYS [ KEYREL adj_wcarg_relation & [ PRED generic_unk_adj_rel ],
                     ALTKEYREL #altkeyrel & [ PRED comp_rel ] ] ] ].

aj_-_i-sup-unk_le := unknown_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind ] >,
                                  MINORS.ALTMIN superl_rel ],
                           VAL [ SPR < [ --MIN much_deg_rel ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
                                      ARG0 #arg0,
                                      ARG1 #ind ],
                                  #altkeyrel &
                                  [ LBL #hand,
                                    ARG1 #arg0 ] !> ] ],
             LKEYS [ KEYREL adj_wcarg_relation & [ PRED generic_unk_adj_rel ],
                     ALTKEYREL #altkeyrel & [ PRED superl_rel ] ] ] ].

av_-_i-unk_le := unknown_word & noncqrs &
  [ SYNSEM intersect_adverb_synsem & 
            [ LOCAL [ CAT.HEAD adv_nonmob &
                               [ MOD < [ LOCAL.CAT.HEAD v_or_g_or_a ] > ] ],
              LKEYS.KEYREL adv_carg_relation &
		    [ PRED generic_unk_adv_rel ] ] ].

; **FIX**

punct_word := nonrs-nab &
  [ SYNSEM [ LOCAL [ CAT [ HEAD punct_hd & [ PRD -, MOD < >, 
                                             MINORS.MIN punct_rel ],
                           VAL [ SUBJ < >, SPR < >, SPEC < >,
                                 COMPS < expressed_synsem &
                                         [ OPT -, 
                                           LOCAL.CAT.HEAD subst_or_func ] > ]],
                     CONT [ RELS <! !>, 
			    HCONS <! !> ],
                     CONJ cnil ],
             LKEYS.KEYREL.PRED punct_rel ] ].

punct_right_word := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < abstr_lex_synsem & 
                                   [ NONLOC.QUE #que,
                                     PUNCT.RPUNCT no_punct ] >,
             NONLOC.QUE #que,
             PUNCT [ LPUNCT no_punct,
                     RPUNCT punct_mark ] ] ].

; Sentence-ending dash, for informal writing
pt_-_s-dash_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT s_dash_punct ].

; Sentence-ending threedots
pt_-_3dots-rgt_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT 3dots_punct ].
    
; Sentence-initial threedots
pt_-_3dots-lft_le := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT 3dots_or_clause,
                                     LOCAL.CONJ cnil ] >,
             PUNCT [ LPUNCT 3dots_punct,
                     RPUNCT 3dots_or_clause_or_no_punct ] ] ].

pt_-_dbl-hyphn_le := punct_right_word &
  [ SYNSEM.PUNCT [ RPUNCT hyphen_dbl,
                   PNCTPR no_ppair ] ].

pt_-_hyphn-rgt_le := punct_right_word &
  [ SYNSEM.PUNCT [ RPUNCT hyphen_sgl,
                   PNCTPR no_ppair ] ].
                                 
; For colon copula with NP subject, as in "Owners: Abrams and Browne"
v_np_colon_le := nonc-hm & word &
  [ INFLECTD +,
    ALTS.ADVADD -,
    SYNSEM norm_two_arg_subst &
      [ LOCAL [ CAT [ HEAD verb &
                           [ VFORM fin,
                             MOD < >,
                             MINORS.MIN be_v_id_rel,
                             PRD -,
                             AUX -,
                             INV -,
                             TAM #tam & [ ASPECT [ PRF -,
                                                   PROGR - ] ] ],
                      POSTHD -,
                      VAL [ SUBJ < canonical_synsem &
                                   [ --MIN nom_or_mnp_rel,
                                     LOCAL [ CAT nomp_cat_min,
                                             CONJ cnil ],
                                     --SIND #id1ind & non_expl-ind,
                                     OPT - ] >,
                            SPR < anti_synsem_min >,
                            COMPS < [ --MIN nom_or_mnp_rel,
                                      LOCAL [ CAT nomp_cat_min & 
                                                  [ HEAD.MOD < >,
                                                    VAL.SPEC *cons* ],
                                              CONJ cnil ],
                                      --SIND #id2ind & non_expl-ind,
                                      NONLOC non-local_none,
                                      OPT - ] > ] ],
                CONT [ HOOK [ LTOP #ltop,
                              INDEX #event & [ E #tam ],
                              XARG #id1ind ],
                       RELS <! #keyrel !>,
		       HCONS <! !> ],
                AGR.PNG png & [ PN 3 ] ],
        NONLOC non-local_none,
        MODIFD hasmod,
        LKEYS.KEYREL #keyrel & arg12_relation &
              [ PRED _colon_v_id_rel,
                LBL #ltop,
                ARG0 #event,
                ARG1 #id1ind,
                ARG2 #id2ind ] ] ].

; For colon copula with nbar subject, as in "Owner: Abrams"
; Only for uninflected nouns, since cannot force inflection on singular nbars.
v_np_colon-nb_le := nonc-h &
  [ INFLECTD +,
    SYNSEM basic_two_arg &
           [ LOCAL [ CAT [ HEAD verb &
                                [ VFORM fin,
                                  MOD < >,
                                  MINORS.MIN be_v_id_rel,
                                  PRD -,
                                  AUX -,
                                  INV -,
                                  TAM #tam & [ ASPECT [ PRF -,
                                                        PROGR - ] ] ],
                           POSTHD -,
                           VAL [ SUBJ < >,
                                 SPR < synsem_min & 
                                      [ --MIN norm_nom_rel,
                                        LOCAL [ CAT nbar_cat &
                                                    [ VAL.SPCMPS < > ],
                                                CONT.HOOK [ LTOP #nltop,
                                                            INDEX #nind ],
                                                AGR [ PNG.PN 3p,
                                                      DIV - ],
                                                CONJ cnil ],
                                        --SIND #id1ind & non_expl-ind,
                                        NONLOC non-local_none,
                                        OPT - ] >,
                                 COMPS < [ --MIN nom_or_mnp_rel,
                                           LOCAL [ CAT nomp_cat_min & 
                                                       [ HEAD.MOD < >,
                                                         VAL.SPEC *cons* ],
                                                   CONJ cnil ],
                                           --SIND #id2ind & non_expl-ind,
                                           NONLOC [ SLASH 0-dlist,
                                                    REL 0-dlist ],
                                           OPT - ] > ],
                           MC + ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #event & [ E #tam ],
                                   XARG #id1ind ],
			    RELS <! #keyrel, 
                                    [ PRED udef_q_rel,
                                      ARG0 #nind,
                                      RSTR #rstr ] !>,
                            HCONS <! qeq & [ HARG #rstr, LARG #nltop ] !> ],
                     AGR.PNG png & [ PN 3 ] ],
             NONLOC non-local_none,
             MODIFD notmod,
             LKEYS.KEYREL #keyrel &
                          [ PRED _colon_v_id_rel,
                            LBL #ltop,
                            ARG0 #event,
                            ARG1 #id1ind,
                            ARG2 #id2ind ] ] ].

; For 'owner: young consultant'
v_nb_colon-nb_le := nonc-h &
  [ INFLECTD +,
    SYNSEM basic_two_arg &
           [ LOCAL [ CAT [ HEAD verb &
                                [ VFORM fin,
                                  MOD < >,
                                  MINORS.MIN be_v_id_rel,
                                  PRD -,
                                  AUX -,
                                  INV -,
                                  TAM #tam & [ ASPECT [ PRF -,
                                                        PROGR - ] ] ],
                           POSTHD -,
                           VAL [ SUBJ < >,
                                 SPR < synsem_min & 
                                      [ --MIN norm_nom_rel,
                                        LOCAL [ CAT nbar_cat &
                                                    [ VAL.SPCMPS < > ],
                                                CONT.HOOK [ LTOP #nltop,
                                                            INDEX #nind ],
                                                AGR [ PNG.PN 3p,
                                                      DIV - ],
                                                CONJ cnil ],
                                        --SIND #id1ind & non_expl-ind,
                                        NONLOC non-local_none,
                                        OPT - ] >,
                                 COMPS < [ --MIN reg_nom_rel,
                                           LOCAL [ CAT nbar_cat & 
                                                       [ HEAD.MOD < >,
                                                         VAL.SPCMPS < > ],
                                                   CONT.HOOK [ LTOP #ctop,
                                                               INDEX #cind ],
                                                   CONJ cnil ],
                                           --SIND #id2ind & non_expl-ind,
                                           NONLOC [ SLASH 0-dlist,
                                                    REL 0-dlist ],
                                           OPT - ] > ],
                           MC + ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #event & [ E #tam ],
                                   XARG #id1ind ],
			    RELS <! #keyrel, 
                                    [ PRED udef_q_rel,
                                      ARG0 #nind,
                                      RSTR #rstr ],
                                    [ PRED udef_q_rel,
                                      ARG0 #cind,
                                      RSTR #crstr ] !>,
                            HCONS <! qeq & [ HARG #rstr, LARG #nltop ],
                                     qeq & [ HARG #crstr, LARG #ctop ]!> ],
                     AGR.PNG png & [ PN 3 ] ],
             NONLOC non-local_none,
             MODIFD notmod,
             LKEYS.KEYREL #keyrel &
                          [ PRED _colon_v_id_rel,
                            LBL #ltop,
                            ARG0 #event,
                            ARG1 #id1ind,
                            ARG2 #id2ind ] ] ].
