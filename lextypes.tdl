;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright (c) 1994-2005
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see erg/licence.txt for conditions
;;;
;;;  lextypes.tdl
;;;
;;;  Lexical types (i.e., word classes)
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$

;:message "Lexical types".



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LEXICAL DEFAULTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nonslash := word &
  [ SYNSEM.NONLOC.SLASH 0-dlist ].

; Lexical types that may have subtypes or instances with nonempty QUE values.

nonque := word &
  [ SYNSEM.NONLOC.QUE 0-dlist ].  

nonrel := word &
  [ SYNSEM.NONLOC.REL 0-dlist ].  

nonconj := word &
  [ SYNSEM [ LOCAL.CONJ cnil,
             PUNCT no_punctuation ] ].

mcna := word &
  [ SYNSEM.LOCAL.CAT.MC na ].

nonmsg := word &
  [ SYNSEM.LOCAL.CONT.MSG no_msg ].

; Most words combine with their complements (if any) to produce a phrase,
; but a few, like "twenty" as in "twenty-two" and "five" as in "five o'clock",
; produce a sign which is still a word -- one with [ SYNSEM lex_synsem ].

hc-to-phr := word &
  [ SYNSEM.LOCAL.CAT.HC-LEX - ].

basic_no_affix := nonconj & nonslash & nonrel & mcna & non_affix_bearing.

no_affix_np := basic_no_affix & nonque & nonmsg.

; hcons_amalg_word's have all the defaults EXCEPT non_affix_bearing,
; nonslash, nonrel, nonque.
basic_hcons_amalg_word := mcna &
	    nonconj &
	    nonmsg &
	    hc-to-phr &
  [ SYNSEM.LKEYS.KEYREL.WLINK *cons* ].

basic_nonltop_word := basic_hcons_amalg_word & nonslash & nonrel.

hcons_amalg_word := basic_hcons_amalg_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

basic_norm_word := hcons_amalg_word & basic_nonltop_word & nonque.


basic_norm_no_affix_word := basic_norm_word & non_affix_bearing.

basic_norm_no_affix_sign := non_affix_bearing &
  [ SYNSEM [ LOCAL [ CAT [ MC na,
                           HC-LEX - ],
                     CONT.MSG no_msg,
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ],
             PUNCT no_punctuation ] ].

; norm_word's have all the defaults except non_affix_bearing
norm_word := basic_norm_word &
  [ SYNSEM lex_synsem ].
	     
norm_no_affix_word := norm_word & non_affix_bearing.

norm_mod_no_affix_word := nonconj & nonslash & nonrel & mcna &
                          non_affix_bearing &
   [ SYNSEM basic_lex_synsem &
	    [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.MSG #msg ] >,
                      CONT [ HOOK.LTOP #ltop,
                             MSG #msg ] ],
              LKEYS.KEYREL.LBL #ltop ] ].

norm_mod_nonque_no_affix_word := norm_mod_no_affix_word & nonque.

basic_mod_no_affix_word := nonconj & nonslash & nonrel & non_affix_bearing.

norm_mod_no_affix_adv_word := basic_mod_no_affix_word &
   [ SYNSEM basic_lex_synsem &
	    [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.MSG #msg ] >,
		      CONT.MSG #msg ] ] ].

; ERB (04-10-96) I have added nonmsg to the following types, as
; appropriate.

; que_word's have all the defaults EXCEPT nonque
que_word := nonconj & non_affix_bearing &
	    mcna &
	    nonslash &
	    nonrel &
	    nonmsg &
	    hc-to-phr.

; rel_word's have all the defaults EXCEPT nonrel.
rel_word := nonque & non_affix_bearing &
	    mcna &
            nonslash &
	    nonconj &
	    nonmsg &
	    hc-to-phr &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

; ERB (04-10-96) msg_word's have all the defaults EXCEPT nonmsg, nonslash, mcna
basic_msg_word := non_affix_bearing &
	    nonrel &
	    nonconj &
	    hc-to-phr.

msg_word := basic_msg_word & nonque.

norm_msg_word := msg_word & nonslash & mcna & 
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

hcons_amalg_affixed_word := hcons_amalg_word & 
  [ INFLECTD - ].

hcons_amalg_non_affixed_word := hcons_amalg_word & non_affix_bearing.

amalg_word := mcna & 
              nonconj &
              nonmsg &
              non_affix_bearing &
              hc-to-phr &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

msg_amalg_word := nonconj &
                  non_affix_bearing &
                  hc-to-phr &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

msg_amalg_prep_word := non_affix_bearing &
  [ SYNSEM [ LOCAL [ CAT.HC-LEX -,
                     CONJ cnil ],
             PUNCT no_punctuation ] ].

; hc_word's repeat all the defaults EXCEPT hc-to-phr, which means they can 
; decide to build head_complement structures which are still words (with 
; [ SYNSEM lex_synsem ].  Also, they are not inherently themselves 
; [ SYNSEM lex_synsem ], so we don't use inheritance at the moment, but 
; replicate the inheritable properties, for an experiment.

hc_word := word_or_lexrule &
  [ SYNSEM [ LOCAL [ CAT.MC na,
                     CONT [ HOOK.LTOP #ltop,
                            MSG no_msg ],
		     CONJ cnil ],
	     NONLOC [ QUE 0-dlist,
			 REL 0-dlist,
			 SLASH 0-dlist ],
             LKEYS.KEYREL [ LBL #ltop,
                            WLINK *cons* ],
             ROOT - ],
    POSSCL - ].

que_no_wlink_word := nonconj &
                     mcna &
                     nonslash &
                     nonrel &
                     nonmsg &
                     hc-to-phr &
  [ INFLECTD + ].

affix_neutral_word := nonconj &
                      mcna &
                      nonslash &
                      nonrel &
                      nonque &
                      nonmsg &
                      hc-to-phr.

; e.g. adj-le types for "sure" as in "make sure"
kpred_lexent := word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY #keypred,
	     LKEYS.KEYREL.PRED #keypred,
             PUNCT no_punctuation ] ].

;;;;;
;; Non-local amalgmation types
;;

basic_zero_arg := synsem &
  [ LOCAL.ARG-S < >,
    NONLOC [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

zero_arg := basic_zero_arg & lex_synsem &
  [ LOCAL.CONT.HCONS <! !> ].

basic_one_arg := canonical_synsem &
  [ LOCAL.ARG-S < [ NONLOC [ SLASH #slash,
				REL #rel,
				QUE #que ] ] >,
    NONLOC [ SLASH #slash,
		REL #rel,
		QUE #que ] ].

one_arg := basic_one_arg &
  [ LOCAL.CONT.HCONS <! !> ].

basic_two_arg := lex_synsem &
  [ LOCAL.ARG-S < [ NONLOC [ SLASH [ LIST #smiddle,
					LAST #slast ],
				REL [ LIST #rmiddle,
				      LAST #rlast ],
				QUE [ LIST #qmiddle,
				      LAST #qlast ] ] ],
		  [ NONLOC [ SLASH [ LIST #sfirst,
					LAST #smiddle ],
				REL [ LIST #rfirst,
				      LAST #rmiddle ],
				QUE [ LIST #qfirst,
				      LAST #qmiddle ] ] ] >,
    NONLOC [ SLASH [ LIST #sfirst,
			LAST #slast ],
		REL [ LIST #rfirst,
		      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

two_arg := basic_two_arg &
  [ LOCAL.CONT.HCONS <! !> ].

generic_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ REL [ LIST #rmiddle2,
					LAST #rlast ],
				  QUE [ LIST #qmiddle2,
					LAST #qlast ] ] ],
                    [ NONLOC [ REL [ LIST #rfirst,
					LAST #rmiddle1 ],
				  QUE [ LIST #qfirst,
					LAST #qmiddle1 ] ] ],
                    [ NONLOC [ REL [ LIST #rmiddle1,
					LAST #rmiddle2 ],
				  QUE [ LIST #qmiddle1,
					LAST #qmiddle2 ] ] ] > ],
    NONLOC [ REL [ LIST #rfirst,
		      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

basic_three_arg := generic_three_arg &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle2,
                                      LAST #slast ] ],
                  [ NONLOC.SLASH [ LIST #sfirst,
                                      LAST #smiddle1 ] ],
                  [ NONLOC.SLASH [ LIST #smiddle1,
                                      LAST #smiddle2 ] ] >,
    NONLOC.SLASH [ LIST #sfirst,
                      LAST #slast ] ].

three_arg := basic_three_arg &
  [ LOCAL.CONT.HCONS <! !> ].

; Don't amalgamate SLASH of last complement
tough_three_arg := generic_three_arg &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle1,
                                      LAST #slast ] ],
                  [ NONLOC.SLASH [ LIST #sfirst,
                                      LAST #smiddle1 ] ],
                  synsem >,
    NONLOC.SLASH [ LIST #sfirst,
                      LAST #slast ] ].

; Don't amalgamate REL of last complement (it-cleft, 'have X to finish')
norel_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle2,
				   	  LAST #slast ],
                                  REL [ LIST #rmiddle,
                                        LAST #rlast ],
				  QUE [ LIST #qmiddle2,
					LAST #qlast ] ] ],
                    [ NONLOC [ SLASH [ LIST #sfirst,
					  LAST #smiddle1 ],
                                  REL [ LIST #rfirst,
                                        LAST #rmiddle ],
				  QUE [ LIST #qfirst,
					LAST #qmiddle1 ] ] ],
                    [ NONLOC [ SLASH [ LIST #smiddle1,
					  LAST #smiddle2 ],
				  QUE [ LIST #qmiddle1,
					LAST #qmiddle2 ] ] ] > ],
    NONLOC [ SLASH [ LIST #sfirst,
		        LAST #slast ],
                REL [ LIST #rfirst,
                      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

basic_four_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle3,
					  LAST #slast ],
				  REL [ LIST #rmiddle3,
					LAST #rlast ],
				  QUE [ LIST #qmiddle3,
					LAST #qlast ] ] ],
		    [ NONLOC [ SLASH [ LIST #sfirst,
					  LAST #smiddle1 ],
				  REL [ LIST #rfirst,
					LAST #rmiddle1 ],
				  QUE [ LIST #qfirst,
					LAST #qmiddle1 ] ] ],
		    [ NONLOC [ SLASH [ LIST #smiddle1,
					  LAST #smiddle2 ],
				  REL [ LIST #rmiddle1,
					LAST #rmiddle2 ],
				  QUE [ LIST #qmiddle1,
					LAST #qmiddle2 ] ] ],
		    [ NONLOC [ SLASH [ LIST #smiddle2,
					  LAST #smiddle3 ],
				  REL [ LIST #rmiddle2,
					LAST #rmiddle3 ],
				  QUE [ LIST #qmiddle2,
					LAST #qmiddle3 ] ] ] > ],
    NONLOC [ SLASH [ LIST #sfirst,
			LAST #slast ],
		REL [ LIST #rfirst,
		      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

four_arg := basic_four_arg &
  [ LOCAL.CONT.HCONS <! !> ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBCATEGORIZATIONS -- synsems for verbs, adjectives, prepositions, nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nomod_local := local &
  [ CAT.HEAD.MOD < > ].

nomod_synsem := lex_synsem &
  [ LOCAL.CAT [ HEAD.MOD < >,
		VAL.SUBJ < > ] ].

scopal_mod :< local_min.
intersective_mod :< local_min.

scopal_mod_local := scopal_mod & local.
int_mod_local := intersective_mod & local.

; DPF 27-May-99 - Changed [MC na] in NOMP_CAT to [MC na_or_-] to allow 
; acc-verbal-gerunds to be NP complements, even though they are built via the 
; head_subj rule.
; DPF 18-Nov-99 - Removed PRD + since this prevented e.g. "ten past five" where
; "ten" is [PRD -], and "past" requires a nomp_cat specifier.
; DPF 07-Jan-01 - We would like to capture the generalization that nominal
; phrases which have been assigned case (nominative or accusative) must also
; be [ MSG no_msg ] to block, e.g., spurious analyses for verbal gerunds
; which have been built via the subj-head rule.  But for now have to stipulate
; this for each occurrence in subcats.
; DPF 21-Mar-01 - Made COMPS for nomp_cat be < > rather than *olist* to avoid
; spurious ambiguity for partitives, as in "some arrived", since they have to
; undergo the n_optcomp pumping rule in order to be able to take a specifier
; as in "almost all arrived".
; DPF 20-Dec-01 - Added SPEC < > in nomp_cat to exclude measure-NPs.
; DPF 8-Feb-02 - But this prevents NPs from ever being specifiers (given the
; constraint on SPR..SPEC in the h-spec rule.  So remove this constraint, and
; try to remember the examples that were supposed to be excluded.
; DPF 20-May-02 - Why MOOD on nomp_cat?
; DPF 27-Oct-02 - Would like to say about all nomp's that they are 
; [DIVISIBLE strict_sort], as we've already been doing (asymmetrically) for
; verbs' subjects for a while now, to avoid spurious ambiguity for e.g.
; "Fridays are inconvenient",  thus extending this to other uses of NPs.
; But AGR.DIVISIBLE is not in CAT, so we can't, and we have to replicate this
; constraint everywhere, as we've already had to do for [CONJ cnil].  Maybe
; a better approach could be found, maybe with defaults?
; DPF 4-Nov-02 - Added MOD < > since we can no longer distinguish modnp guys
; (output of npadv_mod rule) by their having a non-empty SUBJ.
; DPF 7-jul-04 - Removed [ TAM.MOOD ind_or_mod_subj ] from nomp_cat, since
; it's not clear what it was supposed to do.
; DPF 27-aug-04 - Removed [PRD -] constraint, since we want "as much rice
; as possible" which is [PRD +].

nomp_cat_min :< cat_min.

nomp_cat := nomp_cat_min & cat &
  [ HEAD nominal &
	 [ POSS -,
           MOD < > ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS < > ],
    MC na_or_- ].

; DPF (8-Jan-99) Added accusative and nominative subtypes of nomp_cat, since 
; nominative ones are not 'mobile' - see fundamentals.tdl, and still want to
; keep _min types to reduce size of feature structures, even with CASE
; restriction.

nomp_cat_nom_min :< nomp_cat_min.
nomp_cat_acc_min :< nomp_cat_min.
nomp_cat_nonnom_min :< nomp_cat_min.

nomp_cat_nom := nomp_cat_nom_min & nomp_cat &
  [ HEAD.CASE nom ].

nomp_cat_acc := nomp_cat_acc_min & nomp_cat &
  [ HEAD.CASE acc ].

nomp_cat_nonnom := nomp_cat_nonnom_min & nomp_cat &
  [ HEAD.CASE non_nom ].

np_cat_min :< nomp_cat_min.
np_cat_nom_min := nomp_cat_nom_min & np_cat_min.
np_cat_acc_min := nomp_cat_acc_min & np_cat_min.

np_cat_nom := nomp_cat_nom & np_cat_nom_min &
  [ HEAD noun_or_gerundive ].

np_cat_acc := nomp_cat_acc & np_cat_acc_min &
  [ HEAD noun_or_gerundive ].

;; DPF (30-Apr-98) In saturated phrase subcats, SUBJ must be < >, not *olist*,
;; since we need to have SUBJ < > unify with the filler in filler_head phrases,
;; and the filler is constrained to be SUBJ *prolist* which has a distinct 
;; synsem type (pro_ss) which is constrained to be [OPT -].
;; DPF 27-May-99 - Having eliminated the need for *prolist* to be OPT -, we
;; can now make saturated phrases require SUBJ to be *olist* rather than < >, 
;; which means verbal gerunds can have an optional SUBJ but still themselves 
;; be subjects or complements.
;; DPF (28-Jul-98) Added MOD < > to exclude non-finite relative clauses, which
;; are otherwise not distinguishable from nomp's.  Maybe also needed to 
;; exclude the second (modifier) entries for temporal NPs like "Tuesday".
;; DPF 09-Jun-99 - Removed MOD < > (see above), since relative clauses are now
;; all marked with non-empty REL, and because this constraint was falsely 
;; blocking "one to three pm" as an NP complement, because it has a 
;; non-empty MOD.

s_cat_unspec := cat &
  [ HEAD verbal & [ TAM.TENSE real_tense ],
    VAL [ SUBJ *olist*,
	  COMPS < > ] ].

s_cat_v_c := s_cat_unspec &
  [ HEAD.INV -,
    VAL.SPR *olist*,
    MC - ].

s_cat_fin_or_inf_unspec := s_cat_unspec &
  [ HEAD [ VFORM fin_or_inf,
           TAM basic_ind_or_mod_subj_tam ] ].

s_cat_fin_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD [ VFORM fin,
           TAM ind_or_mod_subj_tam &
                 [ TENSE real_tense ] ] ].

s_cat_inf_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD.VFORM inf ].

s_cat_fin_or_inf_v_c := s_cat_v_c & s_cat_fin_or_inf_unspec &
  [ HEAD.TAM.MOOD ind_or_mod_subj ].

s_cat_fin_v_c := s_cat_v_c & s_cat_fin_unspec &
  [ HEAD.TAM.MOOD ind_or_mod_subj ].

s_cat_inf_v_c := s_cat_v_c & s_cat_inf_unspec &
  [ HEAD.TAM.MOOD ind_or_mod_subj ].

; Removed HEAD comp, to allow "I demand he be here"
s_cat_bse := s_cat_v_c &
  [ HEAD.VFORM bse ].

s_cat := s_cat_unspec &
  [ HEAD verb ].

s_cat_fin := s_cat & s_cat_fin_unspec &
  [ HEAD.INV - ].

; DPF 17-Jul-03 - Removed MC + since blocked e.g. "I assume you stayed to chat"
s_cat_fin_or_imp := s_cat &
  [ HEAD [ VFORM fin_or_imp,
	   TAM.MOOD ind_or_mod_subj ] ].

n_or_v_cat_min := cat_min.
n_or_v_cat := n_or_v_cat_min & cat &
  [ HEAD nominal_or_verbal,
    VAL.COMPS < > ].

vp_cat := n_or_v_cat &
  [ HEAD verbal &
	 [ INV - ],
    VAL.SUBJ < synsem_min & [ NONLOC [ SLASH 0-dlist,
                                          REL 0-dlist,
                                          QUE 0-dlist ] ] >,
    MC na ].

vp_inf_cat := vp_cat &
  [ HEAD [ VFORM inf,
	   PRD - ] ].

vp_bse_unspec_cat := vp_cat &
  [ HEAD verb &
	 [ VFORM bse_only,
	   PRD - ] ].

vp_prp_cat := vp_cat &
  [ HEAD.VFORM prp ].

; DPF 19-Oct-02 - Changed MOOD from indicative to indicative* to
; allow coord of "I will stay so you should leave"
vp_bse_cat := vp_bse_unspec_cat &
  [ HEAD.TAM [ MOOD indicative,
               TENSE no_tense ] ].

s_or_vp_inf_cat := cat &
  [ HEAD verbal &
         [ VFORM inf ],
    VAL [ SUBJ *prolist*,
          COMPS < > ] ].

; DPF 10-Jun-99 - Removed MOD < > (cf note in templates.tdl)
; DPF 11-Jul-99 - Added restriction that SPR be [HEAD det] to prevent 
; adjectives from modifying partitives and odd nouns like hour_prep words.
; DPF 28-Aug-99 - Removed SPR: OPT - to allow relative clauses to modify
; generic-pro's like "anything" and still have the result look like an NP.
; DPF 10-May-01 - Removed [SPR..HEAD det] to allow modifiers of generic_pro
; entries as in "everyone important to me"
; DPF 2-Nov-01 - Added SPR < synsem > to exclude "happy here" with n_adv "here"
; DPF 03-may-04 - Consider adding SPEC < anti_synsem_min > to nbar_cat, so these
; aren't tempted to unify with measure_nps.

nbar_cat_min := n_or_v_cat_min.
nbar_cat := nbar_cat_min & n_or_v_cat &
  [ HEAD noun_or_nomger &
	 [ POSS - ],
    VAL [ SUBJ < >,
          SPR < synsem & [ LOCAL.CAT.HEAD.KEYS.KEY quant_or_deg_rel ] >,
          COMPS < > ],
    MC na ].

adverbee_cat := cat &
  [ HEAD adverbee ].

; DPF 4-Nov-02 - Added MOD < synsem_min > to block NPs, now that we don't have
; presence of SUBJ synsem on all predicative phrases.
; DPF 24-Jun-03 - Removed MOD, since verbs now MOD empty.  Instead, use
; HEAD v_or_a_or_p to exclude NPs.

basic_prd_cat := cat &
  [ HEAD v_or_a_or_p & 
         [ PRD +,
           MOD < [ LOCAL intersective_mod ] >,
           TAM.TENSE tense ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS < > ],
    MC na ].

; DPF 18-oct-03 - Restricted prd_cat to phrases which can modify nouns, in 
; order to avoid spurious ambiguity for e.g. prepositions that are lexically
; split between noun-modifying and verb-modifying, as "make the check to Kim".

prd_cat := basic_prd_cat &
  [ HEAD [ MOD < [ LOCAL.CAT.HEAD noun ] >,
           TAM.TENSE untensed ] ].

basic_pp_cat := cat &
  [ HEAD prep_or_modnp & [ PRD - ],
    VAL [ SPR *olist*,
          COMPS < > ],
    MC na ].

; Only for complements of verbs, to avoid spurious ambiguity (e.g with 'into')
pp_cat := basic_pp_cat &
  [ HEAD.MOD < [ LOCAL.CAT.HEAD verb ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Linking Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Linking types specify the relationship between valence positions and 
;; semantic roles.

linking_type :< lex_synsem.

atrans_lt := linking_type &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY no_role_rel,
                  VAL.SUBJ < [ LOCAL local_min,
                               --SIND it-ind & #subjind ] > ],
            CONT.HOOK.XARG #subjind ] ].

arg1_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local_min &
				   [ CAT.HEAD.KEYS.KEY nom_or_mnp_rel ],
                             --SIND #subjind & non_expl-ind ] >,
            CONT.HOOK.XARG #subjind ],
    LKEYS.KEYREL arg1_relation & [ ARG1 #subjind ] ].

; DPF 12-Mar-03 - As per agreement with AAC, changed treatment of unaccusatives
; so they introduce an ARG1, not an ARG2 - they are to be related to their
; causative alternation (if any) via lexical rule which introduces an 
; additional cause_rel.
unacc_lt := arg1_subj_lt.

arg12_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS 
                    < [ LOCAL local_min,
                        --SIND #objind & non_expl-ind ], ... > ],
    LKEYS.KEYREL arg12_relation & [ ARG2 #objind ] ].

trans_lt :< arg12_lt.

arg12h_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				    [ CAT.HEAD.KEYS.KEY event_rel,
				      CONT [ HOOK.LTOP #mhand,
                                             MSG message ] ] ], ... > ],
    LKEYS.KEYREL arg12_relation & [ ARG2 #mhand ] ].

; Maybe only for main verb "have" and for possessive "got"

poss_lt := linking_type &         
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local_min,
                               --SIND #subjind & non_expl-ind ] >,
		      COMPS < [ LOCAL local_min,
                                --SIND #objind & non_expl-ind ] , ... > ],
            CONT [ HOOK.XARG #subjind,
                   RELS <! arg12_relation & 
                         [ ARG1 #subjind,
                           ARG2 #objind ] !> ] ] ].

expl_obj_lt := arg1_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL local_min,
                            --SIND it-ind ], ... > ].

; 'prefer it if ...'
; 'make it clear that ...'
expl_obj_cp_lt := expl_obj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    [ LOCAL local_min &
                                    [ CONT.HOOK.LTOP #mhand ] ],
			    ... > ],
    LKEYS.KEYREL arg12_relation & [ ARG2 #mhand ] ].

expl_obj_prdp_lt := expl_obj_lt & basic_control_expr_lt &
  [ LOCAL.CAT.VAL [ COMPS < [ --SIND #objind ], 
                            #keycomp &
                            [ LOCAL local_min &
                                    [ CONT.HOOK.XARG #objind ] ],
                            ... >,
                    KCMP #keycomp ],
    LKEYS.KEYREL arg12_relation ].

particle_cp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #xarg ],
                            [ LOCAL local_min &
                                    [ CAT.HEAD.KEYS.KEY event_rel,
                                      CONT [ HOOK.LTOP #mhand,
                                             MSG message ] ] ], ... > ],
    LKEYS.KEYREL arg12_relation & [ ARG2 #mhand,
                                    ARG0 #xarg ] ].

particle_oeq_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < synsem,
                            [ LOCAL local_min,
                                --SIND #index & non_expl-ind ],
			      #comp &
			      [ LOCAL local_min &
				      [ CAT.VAL.SUBJ 
					 < pro_ss &
                                           [ NONLOC.SLASH 0-dlist ] >,
                                        CONT [ HOOK [ LTOP #hand,
                                                      XARG #index ],
                                               MSG message ] ] ] >,
                      KCMP #comp ] ],
    LKEYS.KEYREL arg123_relation & [ ARG2 #index,
                                     ARG3 #hand ] ].

; DPF 19-Oct-02 - Removed SORT entity from second COMPS, since want to
; allow "that gives me an hour"
ditrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
                  < [ LOCAL local_min,
                      --SIND #obj2ind & non_expl-ind &
                            [ SORT entity ] ], 
                    [ LOCAL local_min,
                      --SIND #objind & non_expl-ind ], ... > ],
    LKEYS.KEYREL arg123_relation & [ ARG2 #objind,
                                     ARG3 #obj2ind ] ].

tritrans_lt := ditrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, *top*, 
			    [ LOCAL local_min &
				 [ CAT.HEAD.KEYS.KEY v_event_rel,
				   CONT [ HOOK.LTOP #mhand,
                                          MSG message ] ] ],
				... > ],
    LKEYS.KEYREL arg1234_relation & [ ARG4 #mhand ] ].

basic_prep_intrans_lt := linking_type &
  [ LOCAL [ CAT.VAL.COMPS 
			< [ LOCAL local_min &
				  [ CAT.HEAD [ TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                               KEYS.KEY prep_rel ],
                                    CONT.HOOK.XARG #index ] ],
			  ... >,
            CONT [ HOOK.INDEX #index,
		   RELS.LIST < #key, ... > ] ],
    LKEYS.KEYREL #key ].

prep_intrans_unerg_lt := basic_prep_intrans_lt & arg1_subj_lt.
prep_intrans_lt := prep_intrans_unerg_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
            CONT [ HOOK.LTOP #ltop,
                   RELS <! relation !> ] ] ].
prep_intrans_unacc_lt := basic_prep_intrans_lt & unacc_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
            CONT [ HOOK.LTOP #ltop,
                   RELS <! relation !> ] ] ].
prep_intrans_nosubj_lt := prep_intrans_unerg_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
    LKEYS.KEYREL.LBL #ltop ].

;; DPF 14-Sept-00 - This type does not conform to our assumption that only 
;; handles, indices, and external arguments of COMPS synsems can be referred 
;; to in semantic construction.  But we believe we have a better analysis on 
;; the way which collapses these collocation constructions into a more general
;; account of multi-word expressions, so we allow the hack for now.

basic_empty_prep_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				      [ CAT.HEAD.KEYS.KEY selected_rel,
                                        CONT.HOOK.LTOP #ltop ] ], ... >,
            CONT.HOOK.LTOP #ltop ] ].
		   
empty_prep_intrans_lt := basic_empty_prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #objind & 
                                                  non_expl-ind ], ... >,
    LKEYS.KEYREL arg12_relation & [ ARG2 #objind ] ].

; Argument coercion as in "Kim suggests on Friday"
prep_intrans_event_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			 < [ LOCAL local_min &
				   [ CAT.HEAD [ TAM [ TENSE no_tense,
                                                      ASPECT no_aspect ],
                                                KEYS.KEY prep_rel ],
                                     CONT.HOOK [ LTOP #ltop,
                                                 INDEX #event ] ] ], ... >,
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #key !> ] ],
    LKEYS.KEYREL #key & arg12_relation & [ ARG2 #event ] ].

basic_prep_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ LOCAL local_min &
				    [ CAT.HEAD [ MOD < synsem_min >,
                                                 TAM [ TENSE no_tense,
                                                       ASPECT no_aspect ],
                                                 KEYS.KEY prep_rel ] ] ],
                            ... >,
            CONT.RELS.LIST < #key, ... > ],
    LKEYS.KEYREL #key ].

prep_trans_lt := basic_prep_trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND #objind ], 
                            [ LOCAL.CONT.HOOK [ LTOP #cltop,
                                                XARG #objind ] ], ... >,
            CONT [ RELS <! relation, message & [ LBL #hand,
                                                 PRED prpstn_m_rel,
                                                 MARG #arghand ] !>,
                   HCONS <! qeq & [ HARG #arghand,
                                    LARG #cltop ] !> ] ],
    LKEYS.KEYREL arg123_relation & [ ARG3 #hand ] ].

empty_prep_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL local_min &
				       [ CAT.HEAD.KEYS.KEY selected_rel,
					 CONT.HOOK [ LTOP #ltop,
                                                     INDEX #objind &
                                                     non_expl-ind ]]], ... >,
	    CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL arg123_relation & [ ARG3 #objind ] ].
		   
basic_prep_particle_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL local_min &
					 [ CONT.HOOK [ LTOP #ltop,
                                                       XARG #event ] ]], ... >,
	    CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL arg12_relation & [ ARG0 #event ] ].
		   
prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ LOCAL.CAT.HEAD.KEYS.KEY independent_rel ] > ].

empty_prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ LOCAL [ CAT.HEAD.KEYS.KEY selected_rel,
                                    CONT.HOOK.INDEX #arg2 &
                                                    non_expl-ind ] ] >,
    LKEYS.KEYREL.ARG2 #arg2 ].

cp_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
			    [ LOCAL local_min &
				 [ CAT.HEAD.KEYS.KEY event_rel,
                                   CONT [ HOOK.LTOP #mhand,
                                          MSG message ] ] ], 
			    ...> ],
    LKEYS.KEYREL arg123_relation & [ ARG3 #mhand ] ].

; "explain to Kim that ..."
pp_cp_lt := basic_empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #index ],
			    [ LOCAL local_min &
				  [ CAT.HEAD.KEYS.KEY event_rel,
				    CONT [ HOOK.LTOP #mhand,
                                           MSG message ] ] ],
			    ... > ],
    LKEYS.KEYREL arg123_relation & [ ARG2 #mhand,
                                     ARG3 #index ] ].

double_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				    [ CAT.HEAD [ TAM [ TENSE no_tense,
                                                       ASPECT no_aspect ],
                                                 KEYS.KEY prep_rel ],
				      CONT.HOOK [ LTOP #ltop,
                                                  XARG #event ] ] ], 
			    [ LOCAL local_min &
				    [ CAT.HEAD [ TAM [ TENSE no_tense,
                                                       ASPECT no_aspect ],
                                                 KEYS.KEY prep_rel ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #event ] ] ], ... >,
	    CONT.HOOK [ LTOP #ltop,
                        INDEX #event ] ] ].

double_pp_empty_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				    [ CAT.HEAD [ TAM [ TENSE no_tense,
                                                       ASPECT no_aspect ],
                                                 KEYS.KEY prep_rel ],
				      CONT.HOOK.LTOP #ltop ] ], 
                            [ LOCAL local_min &
				    [ CAT.HEAD [ TAM [ TENSE nontense,
                                                       ASPECT no_aspect ],
                                                 KEYS.KEY selected_rel ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #objind &
                                                     non_expl-ind,
                                                  XARG #arg0 ] ] ], ... >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL [ ARG0 #arg0,
                   ARG2 #objind ] ].

; For dative passive, as in "a book was assigned to Kim by Sandy"
double_empty_pp_lt := linking_type &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				    [ CAT.HEAD [ TAM [ TENSE nontense,
                                                       ASPECT no_aspect ],
                                                 KEYS.KEY selected_rel ],
				      CONT.HOOK [ LTOP #ltop,
                                                  INDEX non_expl-ind,
                                                  XARG #arg0 ] ] ], 
                            [ LOCAL local_min &
				    [ CAT.HEAD [ TAM [ TENSE nontense,
                                                       ASPECT no_aspect ],
                                                 KEYS.KEY selected_rel ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #objind &
                                                     non_expl-ind,
                                                  XARG #arg0 ] ] ], ... >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL [ ARG0 #arg0,
                   ARG3 #objind ] ].

arg12_double_pp_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ LOCAL local_min &
				    [ CAT.HEAD [ TAM [ TENSE nontense,
                                                       ASPECT no_aspect ],
                                                 KEYS.KEY selected_rel ],
				      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #ind1 &
                                                        non_expl-ind,
                                                  XARG #arg0 ] ] ], 
			    [ LOCAL local_min &
				    [ CAT.HEAD [ TAM [ TENSE nontense,
                                                       ASPECT no_aspect ],
                                                 KEYS.KEY selected_rel ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #ind2 &
                                                       non_expl-ind,
                                                  XARG #arg0 ] ] ], ... >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL [ ARG0 #arg0,
                   ARG2 #ind1,
                   ARG3 #ind2 ] ].

s_equi_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local_min,
                             --SIND #index & non_expl-ind ] >,
            CONT.HOOK.XARG #index ],
    LKEYS.KEYREL arg12_relation & [ arg1 #index ] ].
		   

equi_prd_lt := linking_type & 
  [ LOCAL [ CAT.VAL.KCMP.LOCAL [ CAT.HEAD.KEYS.KEY independent_rel,
				      CONT.HOOK.INDEX #event ],
	    CONT.RELS <! relation !> ],
    LKEYS.KEYREL.ARG2 #event ].

; ERB (14-12-97) Subj_equi verbs now require that their complement have
; a pro_ss subject.  This might be redundant if some other supertype of
; all equi verbs requires prpstn_m_rel on the complement.

; ERB (21-01-98) This pro_ss needs to be constrained to be unslashed.

subj_equi_lt := s_equi_lt &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #index ] >,
		    KCMP.LOCAL local_min &
				    [ CONT.HOOK.XARG #index ] ] ].

; 'try to leave'
subj_equi_inf_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL local_min &
				    [ CAT.VAL.SUBJ < pro_ss >,
				      CONT [ HOOK.LTOP #hand,
                                             MSG message &
                                               [ PRED propositional_m_rel ]]]],
    LKEYS.KEYREL.ARG2 #hand ].

subj_equi_prp_or_bse_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL local_min &
				    [ CONT.HOOK [ LTOP #hand,
                                                  INDEX.E.TENSE no_tense ] ],
            CONT [ RELS <! relation, message & [ LBL #chand,
                                                 PRED prpstn_m_rel,
                                                 MARG #shand ] !>,
                   HCONS <! qeq &
			   [ HARG #shand,
			     LARG #hand ] !> ] ],
    LKEYS.KEYREL.ARG2 #chand ].

obj_equi_prp_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL [ KCMP.LOCAL local_min &
				    [ CONT.HOOK [ LTOP #hand,
                                                  INDEX.E.TENSE no_tense ] ],
                      COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #ind ],
            CONT [ RELS <! relation, message & [ LBL #chand,
                                                 PRED prpstn_m_rel,
                                                 MARG #shand ] !>,
                   HCONS <! qeq &
			   [ HARG #shand,
			     LARG #hand ] !> ] ],
    LKEYS.KEYREL [ ARG2 #ind,
                   ARG3 #chand ] ].

; ERB (14-12-97) comp's subj is a pro_ss.  This is probably redundant since
; the to_c_prop will say that its subject is a pro_ss.

; ERB (21-01-98) The pro_ss needs to be constrained to be unslashed.

; 'persuade Kim to leave'
obj_equi_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL local_min,
                                --SIND #index & non_expl-ind ],
			      #comp &
			      [ LOCAL local_min &
				      [ CONT.HOOK.XARG #index ] ]>,
                      KCMP #comp ] ],
    LKEYS.KEYREL arg123_relation & [ ARG2 #index ] ].

; 'persuade Kim to leave'
obj_equi_inf_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL local_min &
				    [ CAT.VAL.SUBJ 
					 < pro_ss &
                                           [ NONLOC.SLASH 0-dlist ] >,
                                      CONT [ HOOK.LTOP #hand,
                                             MSG message ] ] ],
    LKEYS.KEYREL.ARG3 #hand ].

; 'help Kim leave'
obj_equi_bse_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL local_min &
				    [ CAT.VAL.SUBJ 
					 < unexpressed_reg >,
                                      CONT [ HOOK.LTOP #vhand,
                                             MSG no_msg ] ],
            CONT [ RELS <! relation, 
                         message &
                         [ LBL #mhand,
                           PRED prpstn_m_rel,
                           MARG #marg ] !>,
                   HCONS <! qeq & [ HARG #marg,
                                    LARG #vhand ] !> ] ],
    LKEYS.KEYREL.ARG3 #mhand ].

obj_equi_sel_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL local_min,
                                --SIND #index2 & non_expl-ind ],
			      #comp &
			      [ LOCAL local_min &
                                      [ CAT.HEAD.KEYS.KEY selected_rel,
                                        CONT.HOOK [ LTOP #ltop,
                                                    INDEX #index3 ] ] ] >,
                      KCMP #comp ] ],
    LKEYS.KEYREL arg123_relation & [ LBL #ltop,
                                     ARG2 #index2,
                                     ARG3 #index3 ] ].

basic_prd_comp_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind ] >,
		      KCMP.LOCAL.CONT.HOOK.LTOP #chand ],
            CONT [ HOOK.XARG #subjind,
                   RELS <! #key, message & #alt2key & 
                                 [ PRED prpstn_m_rel,
                                   MARG #marg ] !>,
		   HCONS <! qeq & [ HARG #marg,
                                    LARG #chand ] !> ] ],
    LKEYS [ KEYREL #key,
            ALT2KEYREL #alt2key ] ].

prd_comp_lt := basic_prd_comp_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT.HEAD.KEYS.KEY independent_rel ].

pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				     [ CONT.HOOK.INDEX #arg2 ] ],
			   [ LOCAL local_min &
				     [ CONT.HOOK.LTOP #hand ] ] > ],
   LKEYS.KEYREL arg123_relation & [ ARG2 #arg2,
                                    ARG3 #hand ] ].

; 'consider Kim wise'

obj_equi_prd_lt := prd_comp_lt & obj_equi_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				  [ CAT.HEAD.KEYS.KEY basic_nom_or_mnp_rel ],
                              --SIND #index ],
                            [ LOCAL local_min &
				  [ CONT.HOOK.XARG #index ] ] > ],
    LKEYS [ KEYREL.ARG3 #arghand,
            ALT2KEYREL.LBL #arghand ] ].

; 'promise Kim to leave'
anom_equi_lt := s_equi_lt &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #subjind ] >,
                    COMPS < [ LOCAL local_min &
				[ CONT.HOOK [ INDEX #objind & non_expl-ind ]]],
                            [ LOCAL local_min &
				[ CAT.VAL.SUBJ < pro_ss &
						 [ NONLOC.SLASH 0-dlist ] >,
				  CONT [ HOOK [ LTOP #hand,
                                                XARG #subjind ],
                                         MSG message ] ] ] > ],
    LKEYS.KEYREL arg123_relation &
          [ ARG3 #hand,
            ARG2 #objind ] ].

; 'turn out unreliable' (also resultatives like 'turned up drunk')
anom_equi_prd_lt := equi_prd_lt & s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #chand,
                                             INDEX #index ] ] >,
                  KCMP #comp,
		  COMPS < *top*,
			  #comp &
			  [ LOCAL local_min &
				  [ CONT.HOOK [ LTOP #chand,
                                                XARG #index ] ] ] > ] ] ].

                                                     

; 'turn out to be red'
anom_equi_particle_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ --SIND #index ] >,
		  COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                              XARG #event ] ],
                          [ LOCAL local_min &
				  [ CAT.VAL.SUBJ < pro_ss &
						   [ NONLOC.SLASH 0-dlist]>,
				    CONT [ HOOK [ LTOP #hand,
                                                  XARG #index ],
                                           MSG message ] ] ] > ],
            CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL [ ARG0 #event,
                   ARG2 #hand ] ].

basic_control_expr_lt := linking_type &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT [ RELS <! relation, 
                           message &
                           [ LBL #mhand,
                             PRED prpstn_m_rel,
                             MARG #arghand ] !>,
                   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & [ ARG2 #mhand ] ].

ssr_expr_lt := basic_control_expr_lt &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < [ LOCAL.CONT.HOOK.INDEX #arg ], 
			      #comp, ... > ] ],
    LKEYS.KEYREL.ARG1 #arg ].

basic_seq_prdp_expr_lt := basic_control_expr_lt &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind ] >,
                      KCMP #comp,
                      COMPS < #comp,
                              [ LOCAL [ CAT.HEAD.KEYS.KEY #ocompkey &
                                                          selected_rel,
                                        CONT.HOOK [ LTOP #ltop,
                                                    INDEX #arg ] ] ],
                              ... > ],
            CONT.HOOK [ LTOP #ltop,
                        XARG #subjind ] ],
    LKEYS [ KEYREL.ARG1 #arg & non_expl-ind,
            --OCOMPKEY #ocompkey ] ].

seq_prdp_expr_lt := basic_seq_prdp_expr_lt &
  [ LKEYS.--OCOMPKEY _to_p_sel_rel ].

sor_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local_min,
                               --SIND #index & non_expl-ind ] >,
                      COMPS < synsem & [ LOCAL local_min ], 
                              [ LOCAL local_min &
                                      [ CONT.HOOK.LTOP #chand ] ] > ],
	    CONT [ HOOK.XARG #index,
                   RELS <! relation, 
                           message &
                           [ LBL #mhand,
                             PRED prpstn_m_rel,
                             MARG #arghand ] !>,
                   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & [ ARG1 #index,
                                    ARG2 #mhand ] ].
expl_it_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local_min & [ CONT.HOOK 
                                                     [ LTOP #hand,
                                                       INDEX it-ind & 
                                                             #subjind ] ] ] >,
		      KCMP.LOCAL local_min & [ CONT [ HOOK.LTOP #chand,
                                                      MSG message ] ] ],
            CONT [ HOOK.XARG #subjind,
                   HCONS <! !> ] ],
    LKEYS.KEYREL arg1_relation &
          [ LBL #hand,
            ARG1 #chand ] ].

expl_it_subj_np_cp_lt := expl_it_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #arg2 ], ... >,
    LKEYS.KEYREL arg12_relation &
                        [ ARG2 #arg2 ] ].

; take, cost
expl_it_subj_np_np_cp_or_vp_lt := expl_it_subj_np_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ --SIND #ind ],
                          ... >,
    LKEYS.KEYREL arg123_relation &
                        [ ARG3 #ind ] ].

; cost: "It will cost (me) ten dollars for you to come along"
expl_it_subj_np_np_cp_lt := expl_it_subj_np_np_cp_or_vp_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT.VAL.SUBJ < > ].

; cost, take: "it took me ten minutes to leave"
expl_it_subj_np_np_vp_lt := expl_it_subj_np_np_cp_or_vp_lt &
  [ LOCAL.CAT.VAL [ COMPS < [ --SIND #ind ], ... >,
                    KCMP.LOCAL [ CAT.VAL.SUBJ < pro_ss >,
                                      CONT.HOOK.XARG #ind ] ] ].

expl_it_subj_pp_cp_lt := expl_it_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL local_min &
                                  [ CONT.HOOK.INDEX #arg ] ], ... >,
    LKEYS.KEYREL arg12_relation &
                        [ ARG2 #arg ] ].

expl_it_subj_prtcl_cp_lt := expl_it_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem >,
    LKEYS.KEYREL arg1_relation ].

; 'It follows that ..."
expl_it_subj_cp_lt := expl_it_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem >,
    LKEYS.KEYREL arg1_relation ].

expl_pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL [ COMPS < [ --SIND it-ind ],
                             [ LOCAL local_min &
                                     [ CONT.HOOK [ LTOP #ltop,
                                                   INDEX #arg ] ] ],
			       [ LOCAL local_min &
				     [ CONT.HOOK.LTOP #hand ] ] > ],
	   CONT.HOOK.LTOP #ltop ],
   LKEYS.KEYREL arg123_relation & [ ARG2 #arg,
                                    ARG3 #hand ] ].

; 'leave it to Kim to find the answer'

expl_pp_inf_oeq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL.COMPS < *top*,
			 [ LOCAL.CONT.HOOK.INDEX #arg ],
			 [ LOCAL.CONT.HOOK.XARG #arg ] > ].

; 'arrange with Kim to meet her'

pp_inf_seq_lt := pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #arg1 ] >,
		   COMPS < *top*,
			  [ LOCAL.CONT.HOOK.XARG #arg1 ] > ] ].

; 'arrange it with Kim to meet her'

expl_pp_inf_seq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #arg1 ] >,
		   COMPS < *top*,
			   *top*,
			   [ LOCAL.CONT.HOOK.XARG #arg1 ] > ]].

; suffice
atrans_inf_lt := linking_type &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
				  [ CONT.HOOK.LTOP #hand ] ] > ],
    LKEYS.KEYREL arg12_relation & [ ARG2 #hand ] ].

particle_NP_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.KEYS.KEY selected_rel,
                                      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #index &
                                                        non_expl-ind,
                                                  XARG #arg0 ] ] ],
                            [ --SIND #index & non_expl-ind ], ... >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL arg12_relation & [ ARG0 #arg0,
                                    ARG2 #index ] ].

NP_particle_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND #index & non_expl-ind ],
                            [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                INDEX #index,
                                                XARG #arg0 ] ], ... >,
	    CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL arg12_relation & [ ARG0 #arg0,
                                    ARG2 #index ] ].

np_particle_pp_lt := np_particle_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            synsem,
                            synsem &
			      [ LOCAL local_min & 
                                      [ CAT.HEAD.KEYS.KEY selected_rel,
                                        CONT.HOOK [ LTOP #ltop,
                                                    INDEX #objind &
                                                          non_expl-ind,
                                                    XARG #arg0 ] ] ], ... >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS.KEYREL arg123_relation & [ ARG0 #arg0,
                                     ARG3 #objind ] ].

np_particle_np_lt := np_particle_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          synsem,
                          synsem &
                          [ LOCAL local_min & 
                                  [ CONT.HOOK.INDEX #objind &
                                                    non_expl-ind ] ], ... >,
    LKEYS.KEYREL arg123_relation & [ ARG3 #objind ] ].
		   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Val Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Valence types specify the number and type of subcategorized complements.
  
valence_type :< canonical_synsem.

unsat_subst := valence_type &
  [ LOCAL.CAT.VAL.SUBJ < synsem_min & [ LOCAL [ CAT nomp_cat_min,
                                                CONJ cnil ] ] > ].
intrans_subst := one_arg & unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < > ].

unsat_two_arg_subst := unsat_subst & abstr_lex_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL local_min &
					[ CAT.HEAD.KEYS.KEY #ckey ],
                                     PUNCT.LPUNCT pair_or_no_punct ], ... >,
    LEX +,
    LKEYS.--COMPKEY #ckey ].

two_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

; For verbs that passivize.
; 21-Apr-00 Changed np_cat_acc_min to nomp_cat_acc_min for e.g. "kim liked 
; hiring abrams"
; DPF 29-May-01 - Removed COMPS..MSG no_msg, since this blocked
; acc-gerunds as in "I resent you giving him that" -- later reconsidered?
; DPF 26-May-03 - We don't have one obvious place to state the constraint that
; VPs are REL empty (no pied piping within VP - Ross 67?), so let's at least
; catch a good bunch of cases with this type.
trans_subst := unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil,
                                             CONT.MSG no_msg ],
                                     NONLOC.REL 0-dlist ], ... > ].
  
np_trans_subst := trans_subst & two_arg_subst & two_arg & 
  [ LOCAL.CAT.VAL.COMPS < synsem > ].
  
; For verbs with nominal complement but that don't passivize.
non_trans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CONT.MSG no_msg,
					     CONJ cnil ] ], ... > ].
  
np_non_trans_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                             CONT.MSG no_msg ] ] > ].

basic_cp_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT s_cat_v_c,
				      CONJ cnil ] ] > ] ].

cp_intrans_subst := basic_cp_intrans_subst &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT.HEAD.TAM.TENSE real_tense ].
  
; For input to nom-gerund lexical rule
basic_prep_intrans_subst := two_arg_subst.

prep_intrans_subst := basic_prep_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT basic_pp_cat,
				    CONJ cnil ] ] > ].

unsat_three_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem & [ LOCAL local_min &
                                        [ CAT.HEAD.KEYS.KEY #ckey ] ], ... >,
    LKEYS.--OCOMPKEY #ckey ].

basic_three_arg_subst := unsat_three_arg_subst & basic_three_arg.

three_arg_subst := unsat_three_arg_subst & three_arg.

three_arg_trans_subst := three_arg_subst & trans_subst.

basic_three_arg_trans_subst := basic_three_arg_subst & trans_subst.
three_arg_nontrans_subst := three_arg_subst & non_trans_subst.
basic_three_arg_nontrans_subst := basic_three_arg_subst & non_trans_subst.

three_arg_raising_subst := basic_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONT.MSG no_msg,
					     CONJ cnil ] ], ... > ].

basic_prep_trans_subst := basic_three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONT.MSG no_msg,
					     CONJ cnil ] ], 
                          synsem &
                          [ LOCAL [ CAT [ HEAD prep_or_modnp,
                                          VAL [ SPR *olist*,
                                                COMPS < > ],
                                          MC na ],
                                    CONJ cnil ] ] > ].
  
prep_trans_subst := basic_prep_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CAT pp_cat ] > ].

prep_non_trans_subst := three_arg_nontrans_subst & 
  [ LOCAL.CAT.VAL.COMPS < lex_synsem & [ LOCAL [ CAT nomp_cat_acc_min,
						 CONT.MSG no_msg,
                                                 CONJ cnil ],
                                         LEX +],
			  synsem &
			  [ LOCAL [ CAT basic_pp_cat,
				    CONJ cnil ] ] > ].
  
; DPF 15-Apr-02 - Maybe none of these obj_equi_prd verbs should passivize, 
; since the control of the predicative phrase is already the syntactic subject
; when the PrdP is just a VP modifier rather than a complement.  We'll try 
; making all of them prd_non_trans.

basic_prd_subst := basic_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONT.MSG no_msg,
					     CONJ cnil ] ], 
			  synsem & 
			  [ LOCAL [ CAT prd_cat &
                                        [ HEAD.MOD 
                                          < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                          norm_rel ] > ],
                                    CONJ cnil ] ] > ].

prd_trans_subst := basic_prd_subst & trans_subst.
; DPF 14-mar-05 - Constraining NP to be definite, to block annoying spurious
; parses for e.g. "I have a meeting on Tuesday".
; DPF 20-mar-05 - But this also blocks "I have a lot of mornings free" and
; "I'll get a room ready".  So it seems we have to pay this price with
; ambiguity. Sigh.
prd_non_trans_subst := basic_prd_subst & non_trans_subst.

; Removed nonpro_rel from second NP, since we want to get "sell me this" and
; maybe even "sell me them" even if not "*sell Abrams it"
; DPF 2-Jun-02 - Put this back, since deictics no longer pron_rel.  We do give
; up "sell me them", but we really don't want "sell the customers it".
; DPF 21-may-04 - Changed nonpro_rel to nonpro_or_num_rel, consistent with
; recent treatment of number nouns.
; DPF 24-feb-05 - And then further generalized to nonpro_or_refl_or_num_rel,
; so we still get ditrans reading for "Abrams gave Browne himself"

ditrans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & 
                          [ LOCAL [ CAT nomp_cat_acc_min,
                                    CONT.MSG no_msg,
                                    CONJ cnil ] ], 
			  synsem & 
                          [ LOCAL [ CAT nomp_cat_acc_min &
                                    [ HEAD.KEYS.KEY nonpro_or_refl_or_num_rel],
                                    CONJ cnil,
                                    CONT.MSG no_msg ] ] > ].
  
; 'inform Kim that S'
cp_trans_subst := three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONT.MSG no_msg,
					       CONJ cnil ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_v_c,
				      CONJ cnil ] ] > ] ]. 
  
pp_cp_subst := three_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem &
			    [ LOCAL [ CAT basic_pp_cat,
				      CONJ cnil ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_or_inf_unspec &
                                          [ MC - ],
				      CONJ cnil ] ] > ] ].
  
np_comp_subst := basic_three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONT.MSG no_msg,
					     CONJ cnil ] ],
			  [ LOCAL local_min &
				 [ CAT [ HEAD prep,
                                         VAL.COMPS < > ],
                                   CONT.HOOK.XARG individual_min ] ] > ].
; 'talk to Kim about Sandy'
double_pp_subst := three_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT pp_cat,
                                    CONJ cnil ] ], 
			  synsem &
			  [ LOCAL [ CAT [ HEAD prep_or_modnp,
                                          VAL [ SPR *olist*,
                                                COMPS < > ],
                                          MC na ],
				    CONJ cnil ] ] > ].
  
np_trans_double_pp_subst := four_arg & trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          synsem &
                          [ LOCAL [ CAT pp_cat &
                                        [ HEAD.KEYS.KEY #ockey ],
                                    CONJ cnil ] ], 
                          synsem &
                          [ LOCAL [ CAT pp_cat,
                                    CONJ cnil ] ] >,
    LKEYS.--OCOMPKEY #ockey ].
  
basic_inf_or_prp_intrans_subst := valence_type &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_or_prp ],
                                      CONJ cnil ],
                              --SIND.E.TENSE no_tense ] > ] ].

inf_or_prp_intrans_subst := basic_inf_or_prp_intrans_subst & 
                            unsat_two_arg_subst.

basic_inf_intrans_subst := basic_inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL local_min &
				  [ CAT.HEAD.VFORM inf ] ] > ].

inf_intrans_subst := basic_inf_intrans_subst & unsat_two_arg_subst.

inf_intrans_particle_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
                      COMPS < synsem &
                              [ LOCAL [ CAT.HEAD.KEYS.KEY independent_rel,
                                        CONT.HOOK.LTOP #hand ] ],
                              #comp & synsem &
                              [ LOCAL [ CAT vp_cat & [ HEAD.VFORM inf ],
                                        CONT.HOOK.LTOP #hand,
                                        CONJ cnil ] ] > ] ] ].

; for "I will try and find it" - analysis following Pullum and Gazdar

inf_intrans_and_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_and ],
                                      CONJ cnil ] ] > ] ].

; for "couldn't help but notice"
inf_intrans_but_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_but ],
                                      CONJ cnil ] ] > ] ].


for_inf_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & 
			  [ LOCAL [ CAT s_cat_v_c &
					[ HEAD comp &
                                               [ VFORM inf ] ],
                                    CONJ cnil ] ] > ].

inf_trans_subst := three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < *top*, #comp & synsem &
			           [ LOCAL [ CAT vp_inf_cat,
					     CONJ cnil ] ] > ] ].

inf_trans_from_subst := three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < *top*, #comp & synsem &
			           [ LOCAL [ CAT vp_cat &
                                                 [ HEAD.VFORM inf_from ],
                                             CONJ cnil ] ] > ] ].

inf_trans_raising_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

prp_intrans_subst := inf_or_prp_intrans_subst & basic_two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL local_min &
				  [ CAT.HEAD.VFORM prp ] ] > ].

bse_intrans_subst := unsat_two_arg_subst & basic_two_arg &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM bse ],
                                      CONJ cnil ],
                              --SIND.E.TENSE no_tense ] > ] ].

; 'make, let, watch' don't passivize.  Some of these have an apparently
; corresponding passive, but with an ordinary 'to-VP' complement, not vform bse
bse_nontrans_raising_subst := three_arg_raising_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem &
			  [ LOCAL [ CAT vp_bse_cat,
				    CONJ cnil ] ] > ].

; want (doesn't passivize)
basic_inf_non_trans_subst := unsat_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                               CONT.MSG no_msg ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

inf_non_trans_subst := basic_inf_non_trans_subst & basic_three_arg_subst.

prp_non_trans_subst := basic_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                               CONT.MSG no_msg ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT vp_prp_cat,
				      CONJ cnil ] ] > ] ].

basic_pp_vp_subst := valence_type &
  [ LOCAL.CAT.VAL [ KCMP #comp,
                    COMPS < synsem &
                            [ LOCAL [ CAT basic_pp_cat &
                                          [ HEAD.KEYS.KEY selected_rel ],
                                      CONJ cnil ],
                              PUNCT.LPUNCT no_punct ],
                            #comp & synsem &
                            [ LOCAL [ CAT vp_cat & [ HEAD.VFORM inf_or_prp ],
                                      CONJ cnil ],
                              PUNCT.LPUNCT no_punct ] > ] ].

basic_pp_inf_subst := basic_pp_vp_subst &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT vp_inf_cat ].

pp_inf_subst := basic_pp_inf_subst & unsat_three_arg_subst.

; We treat raising as the identification of the CONT attribute of the SUBJ and
; the COMPS.SUBJ, rather than the whole synsem, in part to enable the 
; underspecification of the base/non3sg lex-entry for verbs, where otherwise
; CASE information would clash in examples like "Kim believes Sandy to be 
; ready."  In fact, we only identify the INDEX of the two subjects - see 
; comments by sor_inf_subst.
; 
; DPF 17-Nov-99 - The LTOP handle of the SUBJ must be identified with the
; KEY.LBL of the ssr_subst predicate, since contracted negation auxiliary
; verbs have the LTOP be the neg_rel's handle, but the subject as in 
; "I can't leave" should have its LBL identified with that of the
; can_rel, not the neg_rel.

subj_control_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #sind ] >,
                      COMPS < [ LOCAL local_min &
                                      [ CAT.VAL.COMPS < >,
                                        CONT.MSG #msg ] ], ... > ],
            CONT [ HOOK.XARG #sind,
                   MSG #msg ] ] ].

ssr_subst := subj_control_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #sind ] >,
            CONT.HOOK.XARG #sind ] ].

control_two_arg_subst := subj_control_subst & basic_two_arg.
control_three_arg_subst := subj_control_subst & basic_three_arg.
ssr_two_arg_subst := ssr_subst & control_two_arg_subst.

ssr_inf_subst := ssr_subst & inf_intrans_subst.

ssr_pp_inf_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
	   [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                        INDEX #subj ] ] >,
	     COMPS < synsem &
		     [ LOCAL [ CAT basic_pp_cat & 
                                   [ HEAD [ KEYS.KEY _to_p_sel_rel,
                                            MOD < > ] ],
                               CONJ cnil ] ] ,
		     [ LOCAL local_min &
			  [ CAT [ HEAD verbal &
                                       [ VFORM inf ],
                                  VAL [ SUBJ < [ NONLOC [ SLASH 0-dlist,
                                                             REL 0-dlist,
                                                             QUE 0-dlist ]] >,
                                        COMPS < > ] ],
                            CONT [ HOOK.XARG #subj,
                                   MSG no_msg ] ] ] > ],
            CONT.HOOK.LTOP #ltop ] ].

seq_prdp_pp_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
              [ COMPS < [ LOCAL local_min &
			  [ CAT [ HEAD [ PRD +,
                                         TAM.TENSE no_tense,
                                         MOD < [ LOCAL intersective_mod ] > ],
                                  VAL [ SUBJ *olist*,
                                        SPR *olist*,
					COMPS < > ],
				  MC na ],
                            CONT.HOOK.XARG #xarg ] ],
                        synsem &
			[ LOCAL [ CAT basic_pp_cat &
                                      [ HEAD.MOD < > ],
				  CONJ cnil ] ] > ],
	    CONT.HOOK.XARG #xarg ] ].

expl_pp_cp_subst :=  basic_three_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ] ], 
                            synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c,
                                      CONJ cnil ] ] >,
                    KCMP #keycomp ],
    LKEYS.--COMPKEY _to_p_sel_rel ].

expl_np_cp_subst :=  basic_three_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT nomp_cat_acc_min,
                                      CONT.MSG no_msg,
				      CONJ cnil ] ], 
                            synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ] ] >,
                    KCMP #keycomp ] ].

expl_np_cp_fin_subst := expl_np_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ LOCAL.CAT s_cat_fin_v_c ] > ].

four_arg_subst := unsat_three_arg_subst & four_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem & [ LOCAL.CAT.HEAD.KEYS.KEY #ockey ],
                          synsem, ... >,
    LKEYS.--OCOMPKEY #ockey ].

; 'cost/take' - restrict first NP to non-measure-NP, and the second to MNP.
; But this is too strong for second argument, since "a couple of days" is not
; analyzed as a MNP.
expl_np_np_cp_subst :=  four_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT nomp_cat_acc_min &
                                          [ VAL.SPEC < anti_synsem_min > ],
                                      CONT.MSG no_msg,
				      CONJ cnil ] ], 
			    synsem &
			    [ LOCAL [ CAT [ HEAD nominal &
                                                 [ POSS -,
                                                   MOD < >,
                                                   TAM.MOOD ind_or_mod_subj ],
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ],
                                            MC na_or_- ],
                                      CONT.MSG no_msg,
				      CONJ cnil ] ], 
			    synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ] ] >,
                    KCMP #keycomp ] ].
                                                 
expl_np_np_cp_inf_subst := expl_np_np_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem,
                          [ LOCAL.CAT.HEAD.VFORM inf ] > ].

expl_prtcl_cp_subst :=  basic_three_arg_subst & particle_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem, 
                            synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c & [ HEAD comp ],
                                      CONJ cnil ] ] >,
                    KCMP #keycomp ] ].

expl_cp_subst :=  two_arg_subst & two_arg &
  [ LOCAL.CAT.VAL [ COMPS < synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c & [ HEAD comp ],
                                      CONJ cnil ] ] >,
                    KCMP #keycomp ] ].

expl_vp_subst :=  two_arg_subst & two_arg &
  [ LOCAL.CAT.VAL [ COMPS < synsem & #keycomp &
                            [ LOCAL [ CAT vp_inf_cat,
                                      CONJ cnil ] ] >,
                    KCMP #keycomp ] ].

; Raising synsems have to identify the LOCAL value of the raised synsem with
; that of the VP's subject's synsem, rather than identifying the synsems
; themselves, due to our lexical threading of SLASH: if the raised complement
; is extracted, it will be of type gap, and therefore have a non-empty SLASH,
; but we don't want the lower VP complement's subject to also then have a
; non-empty SLASH.  But cf. note above for subj-subj raising, where maybe we
; even want to restrict the identity to CONT only.
;   Indeed, this seems necessary, since CASE blocks unification for
; 'Kim made him sleep' where our (dual-purpose) 'sleep' requires its subject
; to be [CASE nom] (in order to block the sentence "them sleep"), but when its
; subject is raised to object as with "make", there's a conflict with the
; [CASE acc] on the object of "make".  So here again, we make the raising
; identity hold only for CONT.
; DPF (30-Apr-99) In fact, we now have to further restrict the identity to
; only the INDEX, since if we identify all of CONT, we get the handles of the
; higher NP and the VP's subject being identified, but since we also want to 
; lexically identify a predicate's handle with that of its arguments (subject
; to classes of lexical exceptions like for entries with CP complements), we 
; get an unwanted identity of the handles of the higher and lower verbs through
; the identity of the two NPs.  So if we can't sustain this minimal 
; identification for equi and raising, we'll have to give up on identifying 
; the handles of lexical entries and their arguments.  Possible trouble spots 
; are locative inversions like "On the corner seemed to be an abandoned house".

sor_inf_subst := inf_trans_raising_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL.AGR #agr,
                            --SIND #subj,
                            OPT - ], 
			  [ LOCAL local_min &
				  [ CAT.VAL.SUBJ 
					     < [ LOCAL.AGR #agr,
                                                 NONLOC [ SLASH 0-dlist,
                                                             REL 0-dlist,
                                                             QUE 0-dlist ] ] >,
                                    CONT [ HOOK [ XARG #subj,
                                                  INDEX.E.TENSE no_tense ],
                                           MSG no_msg ] ],
				OPT - ] > ].

sor_bse_subst := bse_nontrans_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj,
			    OPT - ], 
			  [ LOCAL local_min &
				  [ CAT.VAL.SUBJ 
					  < [ NONLOC [ SLASH 0-dlist,
                                                          REL 0-dlist,
                                                          QUE 0-dlist ] ] >,
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

sor_inf_non_trans_subst := inf_non_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj,
			    OPT - ],
			  [ LOCAL local_min &
				  [ CAT.VAL.SUBJ 
					     < [ NONLOC [ SLASH 0-dlist,
							     REL 0-dlist,
							     QUE 0-dlist ] ]>,
                                    CONT [ HOOK.XARG #subj,
                                           MSG no_msg ] ],
                            OPT - ] > ].

sor_prd_subst := three_arg_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj ], 
			  [ LOCAL local_min &
                                  [ CAT basic_prd_cat &
                                        [ HEAD.TAM.TENSE untensed ],
				    CONJ cnil,
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

sor_prd_trans_subst := sor_prd_subst & trans_subst.
sor_prd_nontrans_subst := sor_prd_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CAT prd_cat ] > ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; Instead, identify single-word particles by constraint on RELS - a hack.

particle_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
                            [ LOCAL local_min &
				    [ CAT.HEAD [ PRD -,
                                                 KEYS.KEY selected_rel ],
                                      CONT [ HOOK [ LTOP #hand,
                                                    XARG #arg0 ],
                                             RELS <! relation !> ] ],
                              NONLOC [ SLASH 0-dlist,
					  REL 0-dlist,
					  QUE 0-dlist ] ], ... > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #arg0 ] ].


;; DPF (29-Jan-99) Modified particle_NP_subst to exclude pronominal NP objects,
;; to block *Kim looked up it"
; DPF 2-Sept-04 - Changed COMPS.REST.FIRST..CAT from nomp_cat_acc_min to
; nomp_cat_nonnom_min to allow np_cp's like "We wrote down who won".

particle_NP_subst := particle_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
			  synsem & 
                          [ LOCAL [ CAT nomp_cat_nonnom_min &
                                    [ HEAD.KEYS.KEY nonpro_or_refl_or_num_rel],
                                    CONJ cnil,
                                    CONT.MSG no_msg ] ], ... > ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; Instead, identify single-word particles by constraint on RELS - a hack.

generic_NP_particle_subst := trans_subst & abstr_lex_synsem &
  [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL.CONT.MSG no_msg ],
                            synsem &
                          [ LOCAL local_min &
                                  [ CAT.HEAD [ PRD -,
                                               KEYS.KEY #ckey & 
                                                   selected_rel ],
                                    CONT.RELS <! relation !> ],
                            NONLOC [ SLASH 0-dlist,
                                        REL 0-dlist,
                                        QUE 0-dlist ] ], ... > ],
    LEX +,
    LKEYS.--COMPKEY #ckey ].

NP_particle_subst := generic_NP_particle_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

NP_particle_pp_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem,
                          synsem &
                          [ LOCAL [ CAT basic_pp_cat &
                                        [ HEAD.KEYS.KEY #ockey ],
                                    CONJ cnil ] ] >,
    LKEYS.--OCOMPKEY #ockey ].

NP_particle_np_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem,
                          synsem &
                          [ LOCAL [ CAT nomp_cat_acc_min,
                                    CONJ cnil,
                                    CONT.MSG no_msg ] ] > ].

particle_plus_subst := particle_subst & three_arg_subst.

particle_prd_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem & 
			  [ LOCAL [ CAT prd_cat,
				    CONJ cnil ] ] > ].

; 'turn out to be'
particle_inf_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

; 'keep on driving'
particle_prp_subst := particle_subst & basic_three_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_prp_cat,
				      CONJ cnil ] ] > ] ].

particle_pp_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem &
			  [ LOCAL [ CAT basic_pp_cat,
				    CONJ cnil ] ] > ].

; 'find out that S'
particle_cp_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ] ] > ] ].

particle_oeq_subst := particle_NP_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem, synsem,
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

; 'leave it to Kim to find the answer'
expl_pp_inf_subst := four_arg_subst & trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    synsem &
			    [ LOCAL [ CAT basic_pp_cat,
				      CONJ cnil ] ] ,
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

;; 'bet Kim a fortune that Sandy would win'
;; DPF (19-Oct-98) Added hack to block extraction from the CP complement, since
;; don't know how to avoid topicalized imperative parse for "Abrams bet Browne
;; Chiang slept with subject of "slept" topicalized.

np_np_cp_subst := four_arg_subst & trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONT.MSG no_msg,
					       CONJ cnil ] ],
			    synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONT.MSG no_msg,
					       CONJ cnil ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
			      NONLOC.SLASH 0-dlist ] > ] ].

; E.g., "I'm not doing too badly"
; DPF 30-aug-04 - Changed COMPS..HEAD p_or_adv to just adv, since we were
; overgenerating "Kim did in Paris", and it's not clear why we wanted prep.

adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
			    [ LOCAL local_min &
			      [ CAT [ HEAD p_or_adv &
                                       [ MOD < [ LOCAL intersective_mod ] > ],
                                      VAL [ SPR *olist*,
                                            COMPS < > ] ],
                                CONT [ HOOK [ LTOP #hand,
                                              INDEX #event ],
                                       MSG no_msg ] ],
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERB SYNSEMS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Verb synsems should inherit from one valence type and one linking type.
; The type verb_synsem is given a non-empty SPR value so VPs can be modified
; by PPs, but (hack) the synsem is of type anti_synsem_min to block unification, 
; to avoid ever picking up an actual specifier.
;   Added VIT links for the moment, to satisfy VIT requirements for visibility
; of TENSE and MOOD information.  (Actually, moved VITTENSE specification to
; the various inflectional affixes in lexrules.tdl, to accommodate the collapse
; of the base and fin-non3sg verb forms.
; DPF (8-Jul-98) Added QUE 0-dlist, REL 0-dlist to block pied piping in verb
; phrases (taking advantage of lexical amalgamation of these features, together
; with our treatment of subject-WH as extraction (where only local features are
; propagated in SLASH).
; DPF 8-dec-03 - Removed QUE 0-dlist, since we may now be ready for in-situ
; WH-questions.

basic_verb_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD verb & [ MOD < anti_synsem_min >,
                                KEYS.KEY v_event_rel ],
                  VAL [ SUBJ < synsem_min & #subj >,
			SPR < anti_synsem_min >,
			COMPS #comps ] ],
	    ARG-S < #subj . #comps > ],
    LKEYS.KEYREL event_relation,
    NONLOC.REL 0-dlist ].

norm_verb_synsem := basic_verb_synsem &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local_min & [ AGR #agr ] ] >,
            AGR #agr ] ].

verb_synsem := norm_verb_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD.TAM #tam,
            CONT.HOOK.INDEX.E #tam ] ].

atrans_verb := verb_synsem & intrans_subst & atrans_lt &
  [ LOCAL.CAT.HEAD.KEYS.KEY weather_v_rel ].

unerg_verb := verb_synsem & intrans_subst & arg1_subj_lt.
  
passive_or_unacc_synsem :< unsat_subst.
unacc_verb := verb_synsem & intrans_subst & unacc_lt & passive_or_unacc_synsem.
  
; For at least main verb "have" (e.g, "Kim has some rice")
poss_verb := verb_synsem & two_arg_subst & two_arg & poss_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
		        	   	       CONT.MSG no_msg,
			        	       CONJ cnil ] ] >,
            CONT.RELS.LIST.FIRST #key ],
    LKEYS.KEYREL #key ].
  
np_trans_verb := verb_synsem & np_trans_subst & trans_lt.
  
np_non_trans_verb := verb_synsem & np_non_trans_subst & two_arg & trans_lt.

;np_non_trans_unacc_verb := verb_synsem & np_non_trans_subst & two_arg & 
;			   unacc_lt.

basic_prep_intrans_verb := verb_synsem & prep_intrans_subst & basic_two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT pp_cat ] > ].

;; come to
prep_intrans_verb := basic_prep_intrans_verb & prep_intrans_lt & two_arg.

;; move to
prep_intrans_unacc_verb := basic_prep_intrans_verb & prep_intrans_unacc_lt
                           & two_arg.
;; thanks (hack)
prep_intrans_nosubj_verb := basic_prep_intrans_verb & prep_intrans_nosubj_lt.

;; look for
;;
empty_prep_intrans_verb := verb_synsem & prep_intrans_subst & two_arg & 
			   empty_prep_intrans_lt.

;; suggest on Tuesday
;;
prep_intrans_event_verb := verb_synsem & prep_intrans_subst & two_arg & 
			   prep_intrans_event_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT pp_cat ] > ].

;; verbs of motion
prep_intrans_dir_verb := verb_synsem & basic_prep_intrans_subst &
                         prep_intrans_lt & two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD prep_or_modnp &
                                             [ KEYS.KEY dir_or_unsp_loc_rel,
                                               MOD < [ LOCAL.CAT.HEAD verb ]>],
                                        VAL [ SPR *olist*,
                                              COMPS < > ],
                                        MC na ] ] > ].
;; put, move
;;
prep_trans_verb := verb_synsem & prep_trans_subst & prep_trans_lt.
  
;; change one's mind about X (where 'about' is only noun-modifier)
basic_prep_trans_verb := verb_synsem & basic_prep_trans_subst & prep_trans_lt.

;; remind-of
;;
empty_prep_trans_verb := verb_synsem & basic_prep_trans_subst & 
                         empty_prep_trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, [ LOCAL.CAT basic_pp_cat ] >,
            CONT.HCONS <! !> ] ].

;; interest him in X
;;
empty_prep_non_trans_verb := verb_synsem & prep_non_trans_subst & 
			     empty_prep_trans_lt.

;; get-hold-of
;;
;empty_prep_nbar_verb := verb_synsem & prep_nbar_subst & 
;			     empty_prep_nbar_lt.


;; regard Kim as tall
np_comp_verb := verb_synsem & np_comp_subst & obj_equi_sel_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ LOCAL.CAT.VAL.SUBJ *olist* ] >,
            CONT [ RELS <! relation !>,
		   HCONS <! !> ] ] ].

;; strike Kim as tall
np_comp_obj_verb := verb_synsem & np_comp_subst & 
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #sind ] >,
                      COMPS < [ --SIND #index ],
                              [ LOCAL.CONT.HOOK [ INDEX #sind,
                                                  LTOP #chand ] ] > ],
            CONT [ HOOK.XARG #sind,
                   RELS <! relation, message & [ LBL #lbl,
                                                 PRED prpstn_m_rel,
                                                 MARG #marg ] !>,
		   HCONS <! qeq & [ HARG #marg,
                                    LARG #chand ] !> ] ],
    LKEYS.KEYREL arg12_relation & [ ARG1 #index,
                                    ARG2 #lbl ] ].


; DPF 4-Jun-01 - Changed dative-to to be contentful "to", in order to sustain
; 'underspecified' semantics for "kim sent it to Sandy/Paris".  Verbs like 
; "hand" are now of type empty_to_trans_verb.
; DPF 3-May-03 - But since then we've altered our views again, and are now
; treating "send" as taking an empty to-PP, so we do the same for derived
; to-datives as well.
  
empty_to_trans_verb := empty_prep_trans_verb &
  [ LKEYS.--OCOMPKEY _to_p_sel_rel ].

ditrans_verb := verb_synsem & ditrans_subst & ditrans_lt.
  
ditrans_only_verb := verb_synsem & ditrans_subst & ditrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

; 'talk to Kim about Sandy'
; DPF 26-aug-04 - Counter-intuitively, constrain second complement to be
; noun-modifying PP, to avoid spurious ambiguity (at present) for e.g.
; 'they range from low prices to high prices'
double_pp_verb := verb_synsem & double_pp_subst & double_pp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD
                                   < [ LOCAL.CAT.HEAD verb ] > ],
                          [ LOCAL.CAT.HEAD.MOD
                                   < [ LOCAL.CAT.HEAD noun ] > ] > ].

; Unwanted type if freer order of obliques- 'pay with a check for it"
double_pp_empty_pp_verb := verb_synsem & double_pp_subst & 
                           double_pp_empty_pp_lt.

; For passive of dative
double_empty_pp_verb := verb_synsem & double_pp_subst & 
                        double_empty_pp_lt.

; 'change the meeting from Tuesday to Wednesday'
np_trans_double_pp_verb := verb_synsem & np_trans_double_pp_subst & 
                           arg12_double_pp_lt.

; Raising verbs which take an infinitival complement restrict it to being
; [ MSG no_msg ], which ensures that the VP will be headed by the 
; non-propositional "to" complementizer, which identifies its handle with
; that of its VP complement.

ssr_verb := verb_synsem & ssr_inf_subst & basic_two_arg &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT.HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !> ],
    LKEYS.KEYREL arg1_relation & [ ARG1 #arghand ] ].

; 'It started raining'
ssr_prp_verb := verb_synsem & ssr_subst & prp_intrans_subst &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT.HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !> ],
    LKEYS.KEYREL arg1_relation & [ ARG1 #arghand ] ].

ssr_pp_inf_verb := verb_synsem & ssr_pp_inf_subst & ssr_expr_lt.

seq_prdp_pp_verb := verb_synsem & seq_prdp_pp_subst & seq_prdp_expr_lt.

seq_prdp_pp_about_verb := verb_synsem & seq_prdp_pp_subst & 
                          basic_seq_prdp_expr_lt &
  [ LKEYS.--OCOMPKEY _about_p_sel_rel ].

sor_verb := verb_synsem & sor_inf_subst & sor_lt.

sorb_verb := verb_synsem & sor_bse_subst & sor_lt.

sor_non_trans_verb := verb_synsem & sor_inf_non_trans_subst & sor_lt.

sor_prd_verb := verb_synsem & sor_prd_trans_subst & sor_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CAT prd_cat ] > ].

sor_prd_nontrans_verb := verb_synsem & sor_prd_nontrans_subst & sor_lt.

subj_equi_prp_verb := verb_synsem & prp_intrans_subst & 
                      subj_equi_prp_or_bse_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT [ HEAD verb,
                                        VAL.SUBJ < pro_ss > ] ].

subj_equi_bse_verb := verb_synsem & bse_intrans_subst &
                      subj_equi_prp_or_bse_lt.

ssr_two_arg_verb := norm_verb_synsem & ssr_two_arg_subst.

; "K became quiet"
basic_subj_prd_verb := verb_synsem & subj_control_subst &
                       basic_prd_comp_lt &
  [ LOCAL [ CAT.VAL [ COMPS < synsem & #comp &
                              [ LOCAL [ CAT.HEAD.TAM.ASPECT.PROGR -,
                                        CONJ cnil ] ], ... >,
                      KCMP #comp ] ],
    LKEYS [ KEYREL.ARG2 #arghand,
            ALT2KEYREL.LBL #arghand ] ].

subj_prd_verb := basic_subj_prd_verb & prd_comp_lt & ssr_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT prd_cat ] > ].

subj_equi_prd_verb := subj_prd_verb & subj_equi_lt.

subj_equi_prd_adj_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                            LOCAL.CAT.HEAD adj ] > ].

subj_equi_prd_prep_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                            LOCAL.CAT.HEAD prep ] > ].

; "K got hired"
; DPF 3-Jul-03 - Need to block "*Kim got hiring" - seems to be same need to
; distinguish passive from pres-participle - group passive with A and P.
subj_equi_prd_v_a_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                            LOCAL.CAT.HEAD v_or_a ] > ].

; 'shows as empty'
subj_equi_empty_prep_verb := basic_subj_prd_verb & s_equi_lt & basic_two_arg &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #index ] >,
                    COMPS < [ OPT -,
                              LOCAL [ CAT [ HEAD prep &
                                                 [ KEYS.KEY selected_rel ],
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ] ],
                                      CONT.HOOK.INDEX #index ] ] > ] ].

; DPF 15-Apr-02 - Changed these to prd_non_trans_subst, since get spurious 
; ambiguity with alternate analysis of PrdP as adjunct, with right semantics in
; passive case.  
; DPF 13-Oct-03 - But that adjunct analysis gives the wrong semantics for
; "Kim was made angry" where we what result proposition, not state of Kim
; while she was made. So changing back to 

obj_equi_prd_verb := verb_synsem & prd_trans_subst & obj_equi_prd_lt.

obj_equi_non_trans_prd_verb := verb_synsem & prd_non_trans_subst & 
			       obj_equi_prd_lt.

; 'I have X to get rid of'
obj_equi_vpslash_prd_verb := verb_synsem & basic_inf_non_trans_subst & 
                             tough_three_arg & arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND #ind & non_expl-ind ],
                            [ LOCAL.CONT [ HOOK [ LTOP #ltop,
                                                  XARG #xarg ],
                                           MSG message ],
                              NONLOC.SLASH <! unexpr_local &
                                               [ CAT np_cat_acc_min,
                                                 CONT.HOOK.INDEX #ind ] !> ] >,
            CONT [ HOOK.XARG #xarg,
                   HCONS <! !> ] ],
    LKEYS.KEYREL arg123_relation & [ ARG2 #ind,
                                     ARG3 #ltop ] ].


; ERB (07-10-96) I am working with the verb 'know' as a prototype for a verb
; that selects by the semantic type (for now expressed as a feature) of its
; sentential complement rather than by the value of CMP or some such hack.  In
; order to do so, I have changed the types around here.  In particular, I am
; adding a new type cp_prop+ques_intrans_verb that takes a sentential
; complement but doesn't care if its a proposition or a question (for verbs
; like 'know').  A further axis of variation is the VFORM of the complement
; (fin vs. inf).  Since my analysis of 'know' never makes use of the resolved
; subtypes (e.g., cp_prop_intrans_verb) I am not adding to the resolved
; subtypes, and just making the old ones inherit from the finite side of
; things for now.  The future inf_cp_prop_intrans_verb will probably be the
; type of subject equi verbs. A further future modification would involve the
; addition of cp_command_intrans_verb and cp_command+prop_intrans_verb for
; verbs like 'insist'.
;
; DPF (19-Jun-98) This type cannot itself simply add the complement CP's 
; (underspecified) message to its RELS, since the generation algorithm requires
; that no relation on RELS will ever get more specialized during parsing.  So 
; we make MSG be list-valued (the empty list for all but complementizers
; and clauses), and have the Head-Complement rule append the values of MSG
; from both of its daughters, since the msg comes from the head if it's a
; complementizer, and from the non-head if the head is a verb.

basic_cp_prop+ques_verb := basic_verb_synsem &
  [ LOCAL [ CAT.VAL.KCMP [ LOCAL local_min &
                                 [ CAT [ HEAD verbal &
                                              [ INV - ] ],
                                   CONT.MSG message ] ],
            CONT.RELS.LIST < relation, ... > ] ].

norm_cp_prop+ques_verb := basic_cp_prop+ques_verb & verb_synsem.

cp_prop+ques_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CONT.MSG.PRED prop_ques_m_rel ].

fin_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_fin_unspec ].

fin_or_inf_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_fin_or_inf_v_c ].

cp_like_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL [ CAT s_cat_fin_v_c,
                                    CONT.MSG.PRED like_mood_m_rel ] ].

bse_cp_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_bse ].

;; DPF 4/21/98 - Moved [ COMPS.FIRST.LOCAL.CAT.MC - ] from cp_ques_intrans_verb
;; to cp_intrans_verb, to block spurious parse for e.g. "Kim knows who left"

cp_intrans_verb := fin_cp_prop+ques_verb & cp_intrans_subst & two_arg &
		   arg12h_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.TAM.MOOD ind_or_mod_subj ] > ].

cp_like_intrans_verb := cp_like_verb & cp_intrans_subst & two_arg &
		   arg12h_lt &
  [ LOCAL.CAT.VAL.COMPS 
                   < [ LOCAL [ CAT.HEAD.TAM.MOOD ind_or_mod_subj,
                               CONT.MSG.PRED like_mood_m_rel ] ] > ].
; Type for inputs to cp_passive lexical rule
cp_passivable_verb := basic_verb_synsem.

; 'know'
cp_fin_inf_intrans_verb := fin_or_inf_cp_prop+ques_verb & cp_intrans_subst &
                           two_arg & arg12h_lt & cp_passivable_verb.

cp_intrans_passivable_verb := cp_intrans_verb & cp_passivable_verb.

cp_prop_intrans_verb := cp_intrans_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.MSG.PRED propositional_m_rel ] > ].

cp_only_prop_intrans_verb := cp_intrans_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD comp,
                                    CONT.MSG.PRED propositional_m_rel ] ] > ].

cp_ques_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.MSG.PRED int_m_rel ] > ].

;; suppose
cp_prop_raise_key_verb := basic_cp_prop+ques_verb & cp_intrans_subst & 
                          two_arg & arg12h_lt & cp_passivable_verb &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY #key,
                  VAL [ KCMP.LOCAL.CAT s_cat_fin_unspec,
                        COMPS < [ LOCAL [ CAT.HEAD [ KEYS.KEY #key,
                                                     TAM.MOOD ind_or_mod_subj],
                                          CONT.MSG.PRED propositional_m_rel,
                                          AGR #agr ],
                                  OPT - ] > ] ],
            CONT.RELS <! relation !>,
            AGR #agr ] ].

; Make lexical entries inflected (manual entries for each form, sigh) since 
; can't use inflectional rules to do it since they constrain AGR which is 
; here instead identified with complement's AGR.
v_cp_prop_raise_key_lexent := main_verb_sans_key & 
  [ INFLECTD +,
    SYNSEM cp_prop_raise_key_verb ].

;; tell Kim that/whether S
;; inform Kim that S
np_trans_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt.

np_trans_cp_fin_or_inf_verb := fin_or_inf_cp_prop+ques_verb & cp_trans_subst & 
                               cp_trans_lt.

;; bet Kim ten cents that S
np_np_cp_verb := fin_cp_prop+ques_verb & np_np_cp_subst & tritrans_lt.

;; explain to Kim that S
; DPF 10-Sep-01 - Removed MSG prpstn_m_rel since want to get e.g.
; 'Can you confirm whether Kim arrived?"
pp_cp_verb := cp_prop+ques_verb & pp_cp_subst & pp_cp_lt & cp_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX non_expl-ind ], 
			  [ LOCAL.CONT.MSG message ] > ].

pp_cp_fin_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
                  cp_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX non_expl-ind ],
			  [ LOCAL.CONT.MSG message ] > ].

pp_expl_cp_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
                  cp_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX it-ind ],
			  [ LOCAL.CONT.MSG message ] > ].

;; ask Kim whether S
np_trans_cp_ques_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CONT.MSG.PRED int_m_rel ] > ].

;; persuade Kim that S
np_trans_cp_prop_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
			  [ LOCAL.CONT.MSG.PRED propositional_m_rel ] > ].

;; ask that Kim be released
cp_bse_intrans_verb := bse_cp_verb & cp_intrans_subst & two_arg &
                       arg12h_lt.

;; try to
subj_equi_verb := cp_prop+ques_verb & inf_intrans_subst & two_arg & 
                  subj_equi_inf_lt.

;; try and find it
;; Allow "I/you/we/they try and find it" but block "*He tries and find it"
;; but allow "I/you/we/they/he will try and find it" and "Try and find it".
subj_equi_and_verb := cp_prop+ques_verb & inf_intrans_and_subst & two_arg & 
                      subj_equi_inf_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
            CONT.HOOK.INDEX.E [ ASPECT no_aspect,
                                MOOD ind_or_mod_subj ] ],
    LKEYS [ --COMPKEY #ckey,
            --+COMPKEY #ckey ] ].

;; couldn't help but notice
subj_equi_but_verb := cp_prop+ques_verb & inf_intrans_but_subst & two_arg & 
                      subj_equi_inf_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
            CONT.HOOK.INDEX.E [ ASPECT no_aspect,
                                MOOD ind_or_mod_subj ] ],
    LKEYS [ --COMPKEY #ckey,
            --+COMPKEY #ckey ] ].

;; have yet to find it
ssr_particle_verb := verb_synsem & inf_intrans_particle_subst & 
  [ LOCAL [ CAT [ HEAD.KEYS.KEY #key & v_event_rel,
                  VAL [ SUBJ < [ --SIND #sind ] >,
                        COMPS < synsem,
                                [ LOCAL local_min &
                                        [ CAT.HEAD verbal &
                                                   [ INV -,
                                                     KEYS.KEY #key ],
                                          CONT [ HOOK [ LTOP #cltop,
                                                        INDEX.E.ASPECT.PERF +,
                                                        XARG #sind ],
                                                 MSG no_msg ] ] ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
                          XARG #sind ],
                   RELS <! norm_adj_relation &
                          [ LBL #ltop,
                            PRED neg_rel,
                            ARG1 #argh ] !>,
                   HCONS <! qeq & [ HARG #argh,
                                    LARG #cltop ] !>,
                   MSG no_msg ] ] ].

;; tell, persuade
obj_equi_verb := cp_prop+ques_verb & inf_trans_subst & obj_equi_inf_lt.

;; help
obj_equi_bse_verb := verb_synsem & sor_bse_subst & obj_equi_bse_lt.

;; appeal, intend
oeq_pp_inf_verb := verb_synsem & pp_inf_subst & three_arg & obj_equi_inf_lt &
		   empty_prep_intrans_lt.

;; gear up the team to ...
particle_oeq_verb := cp_prop+ques_verb & particle_oeq_subst & four_arg &
                     particle_oeq_lt.

;; arrange with kim to meet
pp_inf_seq_verb := cp_prop+ques_verb & pp_inf_subst & three_arg & 
                   pp_inf_seq_lt.

; promise
anom_equi_verb := cp_prop+ques_verb & inf_non_trans_subst & anom_equi_lt &
  [ LOCAL.CONT.HCONS <! !> ].

; use X to do Y
anom_equi_trans_verb := cp_prop+ques_verb & inf_trans_subst & anom_equi_lt &
  [ LOCAL.CONT.HCONS <! !> ].

; have trouble sleeping
anom_equi_prp_verb := verb_synsem & prp_non_trans_subst & obj_equi_prp_lt.

; prevent X from Ving
obj_equi_from_verb := cp_prop+ques_verb & inf_trans_from_subst & 
                      obj_equi_inf_lt.

particle_inf_verb := cp_prop+ques_verb & particle_inf_subst & 
		     anom_equi_particle_lt.

particle_prp_verb := verb_synsem & particle_prp_subst & 
		     subj_equi_prp_or_bse_lt.

particle_cp_verb := fin_cp_prop+ques_verb & particle_cp_subst & 
		    particle_cp_lt & cp_passivable_verb.

expl_it_subj_pp_cp_verb := norm_cp_prop+ques_verb & expl_pp_cp_subst & 
		     expl_it_subj_pp_cp_lt.

expl_it_subj_np_cp_verb := norm_cp_prop+ques_verb & expl_np_cp_subst & 
                           expl_it_subj_np_cp_lt.

expl_it_subj_np_cp_fin_verb := norm_cp_prop+ques_verb & 
                               expl_np_cp_fin_subst & expl_it_subj_np_cp_lt.

; 'It costs me ten dollars for you to enter'
expl_it_subj_np_np_cp_inf_verb := norm_cp_prop+ques_verb & 
                          expl_np_np_cp_inf_subst & expl_it_subj_np_np_cp_lt.

expl_it_subj_np_np_vp_inf_verb := norm_cp_prop+ques_verb & 
                          expl_np_np_cp_inf_subst & expl_it_subj_np_np_vp_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
                          [ LOCAL.CAT.VAL.SUBJ
                                    < pro_ss & 
                                      [ NONLOC.SLASH 0-dlist ] > ] > ].

expl_it_subj_prtcl_cp_verb := norm_cp_prop+ques_verb & expl_prtcl_cp_subst & 
                              expl_it_subj_prtcl_cp_lt.

expl_it_subj_cp_verb := norm_cp_prop+ques_verb & expl_cp_subst & 
                        expl_it_subj_cp_lt.

expl_it_subj_vp_verb := norm_cp_prop+ques_verb & expl_vp_subst & 
                        expl_it_subj_cp_lt.

expl_pp_inf_oeq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_oeq_lt.

expl_pp_inf_seq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_seq_lt.

atrans_inf_verb := cp_prop+ques_verb & inf_intrans_subst & two_arg & 
		   atrans_inf_lt.

for_to_verb := verb_synsem & for_inf_intrans_subst & two_arg & arg12h_lt.

particle_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

; 'going on'
particle_3only_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND.PNG.PN 3per ] >,
                    COMPS < *top* > ] ].

generic_particle_NP_verb := verb_synsem & particle_NP_subst & particle_NP_lt.

generic_NP_particle_verb := verb_synsem & generic_NP_particle_subst & 
                            NP_particle_lt.

NP_particle_verb := generic_NP_particle_verb & NP_particle_subst.

; 'credit back the money to the account'
NP_particle_pp_verb := generic_NP_particle_verb & NP_particle_pp_subst &
                       NP_particle_pp_lt.

; 'give him back his dog'
NP_particle_np_verb := generic_NP_particle_verb & NP_particle_np_subst &
                       NP_particle_np_lt.

NP_particle_noalt_verb := NP_particle_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CONT.HOOK.INDEX #index ], ...>,
    LKEYS.KEYREL.ARG2 #index ].

particle_prd_verb := verb_synsem & particle_prd_subst & anom_equi_prd_lt.

particle_pp_verb := verb_synsem & particle_pp_subst & 
		    prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CAT pp_cat ] > ].

particle_empty_pp_verb := verb_synsem & particle_pp_subst & 
                          empty_prep_particle_intrans_lt.

; prefer it if ...
expl_obj_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & expl_obj_cp_lt.

; make it clear that ...
expl_obj_prd_verb := verb_synsem & sor_prd_trans_subst & expl_obj_prdp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX it-ind ], 
                          [ LOCAL.CAT.HEAD adj ] > ].

; 'i am doing fine/badly/well', but also 'how are you doing?'
adv_verb := verb_synsem & adv_subst & arg1_subj_lt & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < *top* >,
	    CONT.RELS <! #key !> ],
    LKEYS.KEYREL #key ].

; Verbs of saying: "Kim left, Sandy said"
; Could be the output of a lexical rule, but enter in lexicon for now.

quoting_verb_top_synsem := verb_synsem & arg1_subj_lt & unsat_subst &
  [ LOCAL [ CAT [ VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                 [ VFORM fin_or_imp ],
                                              VAL [ SUBJ < anti_synsem_min >,
                                                    COMPS < > ],
                                              MC + ],
                                        CONT [ HOOK.LTOP #compltop,
                                               MSG message ],
                                        CONJ cnil ],
                                NONLOC.SLASH 0-dlist ] > ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #event ],
                   RELS <! relation & #key !>,
                   HCONS <! !> ],
            CONJ cnil ],
    LKEYS.KEYREL #key & [ LBL #ltop,
                          ARG0 #event,
                          ARG2 #slashltop,
                          ARG3 #compltop ],
    NONLOC.SLASH 1-dlist & 
                 <! [ CAT [ HEAD verb & [ VFORM fin_or_imp ],
                            VAL [ SUBJ < anti_synsem_min >,
                                  COMPS < > ] ],
                      CONT [ HOOK.LTOP #slashltop,
                             MSG message ],
                      CONJ cnil ] !> ].

; Inverted verbs of saying: "Kim left, said Sandy"

quoting_verb_inv_synsem := verb_synsem & three_arg &
  [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL [ CAT [ HEAD verb &
                                                  [ VFORM fin_or_imp ],
                                               VAL [ SUBJ < anti_synsem_min >,
                                                     COMPS < > ] ],
                                         CONT [ HOOK.LTOP #subjltop,
                                                MSG message ],
                                         CONJ cnil ],
                                 OPT - ] >,
                        COMPS < [ LOCAL [ CAT np_cat_nom,
                                          CONT.HOOK.INDEX #compind,
                                          CONJ cnil ],
                                  OPT - ],
                                [ LOCAL [ CAT [ HEAD verb &
                                                     [ VFORM fin_or_imp ],
                                                VAL [ SUBJ < anti_synsem_min >,
                                                      COMPS < > ] ],
                                          CONT [ HOOK.LTOP #compltop,
                                                 MSG message ],
                                          CONJ cnil ] ]> ] ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #event ],
                   RELS <! relation & #key !>,
                   HCONS <! !> ],
            CONJ cnil ],
    LKEYS.KEYREL #key & [ LBL #ltop,
                          ARG0 #event,
                          ARG1 #compind,
                          ARG2 #subjltop,
                          ARG3 #compltop ],
    NONLOC.SLASH 0-dlist ].

; Verbs taking quotations which can be inverted: 'Kim said, Who are you?'
quoting_verb_mc_synsem := verb_synsem & arg1_subj_lt & unsat_subst & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                 [ VFORM fin_or_imp ],
                                            VAL [ SUBJ < anti_synsem_min >,
                                                  COMPS < > ],
                                            MC + ],
                                      CONT [ HOOK.LTOP #compltop,
                                             MSG message ],
                                      CONJ cnil ],
                              OPT - ] >,
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #event ],
                   RELS <! relation & #key !>,
                   HCONS <! !> ],
            CONJ cnil ],
    LKEYS.KEYREL #key & [ LBL #ltop,
                          ARG0 #event,
                          ARG2 #compltop ],
    NONLOC.SLASH 0-dlist ].



; DPF 13-May-02 - Made passive_synsem inherit from basic_verb_synsem rather
; than verb_synsem since we don't want it to be subtype of lex_synsem, since
; simple passives can be post-nominal modifiers, as in "the price quoted is
; too high"

passive_synsem := norm_verb_synsem & passive_or_unacc_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD [ AUX -,
                         VFORM pas,
                         VOICE passive,
                         TAM.MOOD #mood ],
                  VAL [ SUBJ < synsem &
                               [ LOCAL [ CAT nomp_cat_min,
                                         CONJ cnil ] ] >,
                        COMPS < synsem & 
                                [ LOCAL local &
                                        [ CAT [ HEAD prep &
                                                     [ KEYS.KEY _by_p_cm_rel ],
                                                VAL [ SUBJ < >,
                                                      SPR *olist*,
                                                      COMPS < > ] ] ],
                                  OPT + ], ... > ] ],
            CONT.HOOK.INDEX.E.MOOD #mood,
            CONJ cnil ] ].

passive_atrans_synsem := passive_synsem & atrans_lt.
passive_unerg_synsem := passive_synsem & arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                XARG #index ] ] >,
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #index,
                          XARG #xarg ],
                   RELS <! [ LBL #ltop,
                             ARG0 #index,
                             ARG1 #xarg ] !> ] ] ].

; For using lexical passives as reduced relatives: "the prices quoted are ..."
; DPF 17-Sep-03 - Block for now - don't want "abrams hired"
;passive_phr_synsem := passive_synsem & phr_synsem.

ssr_particle_v_lexent := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTD -,
    SYNSEM ssr_particle_verb &
           [ LOCAL.CAT.HEAD verb & [ AUX -,
                                     INV - ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modifier synsems
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; When changing, remember to also modify verb_participle_affix in lexrules.tdl
isect_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
	    CONT.HOOK.LTOP #hand ],
    LKEYS.KEYREL.LBL #hand ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The semantics of a main verb consists of the "main" handel for the sentence
; and a list of relations.  A pointer to the main or head relation in the list
; is kept in the KEY attribute.
;
; DPF 26-Jan-01 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.

main_verb_sans_key := nonconj & hc-to-phr &
  [ SYNSEM [ LOCAL [ CAT.HEAD verb & [ AUX -,
                                       INV -,
                                       KEYS [ KEY v_event_rel,
                                              ALTKEY role_rel ] ],
                     CONT.RELS.LIST < relation & #key, ... > ],
             LKEYS.KEYREL #key & [ WLINK *cons* ] ] ].

basic_main_verb := main_verb_sans_key &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY nonaux_event_rel ].

;;; AAC - all main_verbs have single element RELSs

main_verb := basic_main_verb & mcna & nonmsg &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! relation !> ],
             LKEYS.KEYREL.LBL #ltop ] ].

main_verb_std := main_verb.

main_verb_mliszt := basic_main_verb & mcna & nonmsg &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

main_verb_mliszt_infl := basic_main_verb &
  [ INFLECTD +,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; AUXILIARY VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Auxiliary verbs are subject-to-subject raising verbs which also raise the 
; content of the VP complement, possibly tacking an additional relation on the
; end.  They also raise the context of the VP complement, for now at least to
; propagate tense information.
; AUX verbs are further classified by the type of VP complement they 
; select for.  Also, AUX verbs optionally take a neg (post-head) specifier.

basic_aux_verb := verb_synsem &
  [ LOCAL [ CAT.HEAD [ TAM #tam,
                       KEYS.KEY #keypred ],
	    CONT.HOOK.INDEX.E #tam ],
    LKEYS.KEYREL.PRED #keypred ].
		
aux_verb := basic_aux_verb &
  [ LOCAL.CAT.HEAD.KEYS.ALTKEY aux_event_rel ].
aux_verb_ssr_subst := aux_verb & ssr_subst.
aux_verb_ssr := aux_verb_ssr_subst & basic_two_arg &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp, ... > ] ].

aux_verb_word_super := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTD + ]. 

aux_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
           [ LOCAL.CAT [ HEAD.AUX +,
                         POSTHD + ] ] ].

bse_aux_verb_word := aux_verb_word &
  [ SYNSEM.LOCAL local_min &
		 [ CAT [ VAL.COMPS < synsem &
                                     [ LOCAL [ CAT vp_bse_unspec_cat,
                                               CONJ cnil ],
                                       OPT - ] > ] ] ].
;; ought, going
inf_aux_verb_word := aux_verb_word_super & 
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL local_min &
		 [ CAT [ POSTHD +,
			 VAL.COMPS < synsem &
				     [ LOCAL [ CAT vp_inf_cat,
					       CONJ cnil ],
				       OPT - ] > ] ] ] ].

;; Only for auxiliary "have" and "should+of"
psp_aux_verb_word := aux_verb_word &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.COMPS < synsem &
				     [ LOCAL [ CAT vp_cat &
						   [ HEAD verb &
							  [ VFORM psp ] ],
					       CONJ cnil ],
                                       OPT - ] > ] ] ].
; Only for the copula
; DPF 29-Nov-02 - Predicative copula has to identify COMPS..MOD..INDEX with
; COMPS..XARG since predicative PPs cannot lexically identify XARG with their
; KEY.ARG1, because PPs acting as modifiers of VPs have to project the XARG
; of the VP.
; DPF 20-Nov-03 - But now identifying INDEX of PP with its event, not its XARG.

prd_aux_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr_subst &
     [ LOCAL [ CAT [ HEAD.AUX +, 
                     POSTHD +,
                     VAL.COMPS 
                     < [ LOCAL local_min &
                               [ CAT basic_prd_cat &
                                     [ HEAD [ MOD < [ --SIND #ind ] >,
                                              KEYS.KEY independent_rel ],
                                       VAL.SUBJ *olist* ],
                                 CONT.HOOK [ INDEX #index &
                                                   [ E [ TENSE tense,
							 ASPECT.STATIVE + ] ],
                                             XARG #ind & individual_min ] ],
                         OPT - ] > ],
               CONT.HOOK [ INDEX #index,
                           XARG #ind ],
               ARG-S < [ NONLOC [ SLASH [ LIST #smiddle,
                                             LAST #slast ],
                                     REL #rel,
                                     QUE [ LIST #qmiddle,
                                           LAST #qlast ] ] ],
                       [ NONLOC [ SLASH [ LIST #sfirst,
                                             LAST #smiddle ],
                                     QUE [ LIST #qfirst,
                                           LAST #qmiddle ] ] ] > ],
       NONLOC [ SLASH [ LIST #sfirst,
                           LAST #slast ],
                   REL #rel,
                   QUE [ LIST #qfirst,
                         LAST #qlast ] ] ] ].

raise_cont := word_or_lexrule &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
					   [ CONT.HOOK
                                               [ LTOP #hand,
                                                 INDEX #index ] ] ], ... >,
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index ],
			  RELS <! !> ] ] ].

add_cont := word_or_lexrule &
  [ SYNSEM [ LOCAL.CONT.RELS.LIST < relation & #key, ... >,
             LKEYS.KEYREL #key ] ].
		   
; Real modal verbs are auxiliary verbs which select a base form complement.
; They only exist in finite forms.
; DPF 2-Oct-01 - Removed [KCMP..INDEX.E.TENSE no_tense] since this
; prevented low attachment of "when" in "when can Kim arrive"

generic_modal_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
	   [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #chand,
                                                    INDEX.E.TENSE no_tense ],
                     CONT [ HOOK.INDEX #event,
			    HCONS.LIST < qeq &
					   [ HARG #arghand,
					     LARG #chand ], ... > ] ],
             LKEYS.KEYREL arg1_relation &
                          [ ARG0 #event,
                            ARG1 #arghand ] ] ].

fin_modal_verb_word := generic_modal_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
				VFORM fin,
                                TAM ind_or_mod_subj_tam ],
			 POSTHD +,
			 VAL.SUBJ < synsem & [ LOCAL 
                                                 [ CAT nomp_cat_nom_min,
                                                   CONT.MSG no_msg,
                                                   CONJ cnil ],
                                               OPT - ] > ],
		   CONT psoa ] ].

pres_modal_verb_word := fin_modal_verb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM [ TENSE present,
                                  ASPECT no_aspect ],
                       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.TAM.TENSE no_tense ] ].

; Assume for now that all modals have simple present tense semantics,
; ignoring the habitual past readings possible for "would" and "could" -
; these will have to be separate lexical entries.
; DPF 26-Jun-03 - Changed this to allow underspecification of tense for at
; least 'could'

modal_verb_word := fin_modal_verb_word & bse_aux_verb_word &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ OPT - ] >,
                           COMPS.FIRST.LOCAL.CAT vp_bse_cat ] ].

pos_modal_verb_word := modal_verb_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.AUX +,
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #key !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #key & [ LBL #ltop,
                                   WLINK *cons* ] ] ].

ought_verb_word := pres_modal_verb_word & inf_aux_verb_word &
  [ SYNSEM.LOCAL.CAT.HEAD.AUX - ].

pos_ought_verb_word := ought_verb_word &
  [ SYNSEM [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! #key !>,
                          HCONS <! qeq !> ],
             LKEYS.KEYREL #key & [ LBL #ltop ] ] ].

past_ought_verb_word := fin_modal_verb_word & inf_aux_verb_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ AUX -,
                                TAM [ TENSE past,
                                      ASPECT no_aspect ] ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #key !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #key & [ LBL #ltop ] ] ].

;; DPF 24-Jun-03 ***FIX?:  [ HEAD.MOD < anti_synsem_min >,
basic_quasimodal_verb_word := generic_modal_verb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ KEYS.KEY _going+to_v_rel,
                                  TAM [ TENSE real_tense,
                                        ASPECT.PROGR + ] ],
                           VAL [ COMPS.FIRST #comp,
                                 KCMP #comp ] ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #key !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #key & [ LBL #ltop,
                                   PRED will_would_rel ] ] ].

quasimodal_word := basic_quasimodal_verb_word & inf_aux_verb_word &
  [ SYNSEM.LOCAL.CAT.HEAD.AUX + ].

quasimodal_psp_word := inf_aux_verb_word & generic_modal_verb_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ VFORM psp,
                                TAM.TENSE present,
                                AUX -,
                                PRD -],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #key !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #key &
                   [ LBL #ltop,
                     WLINK *cons* ] ] ].

; 21-apr-04 - Removed STATIVE + from INDEX
quasimodal_bse_word := basic_quasimodal_verb_word & bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM prp,
				PRD + ],
			 VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ] ].

; DPF 09-Jan-00 - Removed SLASH 0-dlist from COMPS.FIRST, since it was blocking
; e.g. "When's he leaving"

contracted_aux_word := word &
  [ ALTS.VPELLIP - ].

; copula, 'exists'
; DPF 12-Apr-02 - The second (predicative) complement was being blocked by
; KEY no_rel - avoided unwanted ambiguity, but now prevents e.g. "where is
; there a problem" since we now want to avoid spurious adjunct extraction.
; So removed no_rel, and instead require this second complement to be 
; non_canonical - allows extraction, but not the spuriosity of in-situ PrdPs.
; DPF 01-Feb-03 - Since we're now allowing adjunct extraction for independent
; reasons, let's try abandoning that second complement of the 'there'-copula
; altogether.  Then we avoid the awkward semantic composition problem of
; having to find the LBL of the noun_rel inside the first complement - does
; violence to our semantic algebra.
; DPF 28-oct-03 - Restored the three-arg there-copula since we need it at
; least for extractions like "what is there to do" (& "there is nothing to do")
; where the last complement has a non-empty rel (to avoid spurious ambig).
; Since the optional second complement will be RELS non-empty, can't use the
; default appending of non-local feats, so have to do cumbersome repeat here,
; to avoid propagating that non-empty RELS.  But don't want to say explicitly
; here that it's non-empty, since then constraint on *olist* not satisfied.

; there-copula and it-cleft copula

expl_verb_synsem := unsat_three_arg_subst & verb_synsem & norel_three_arg &
  [ LOCAL [ CAT [ VAL [ SUBJ < [ --SIND expl-ind & #subjind ] >,
                        COMPS < synsem &
			    [ LOCAL [ AGR non_expl-ind,
                                      CAT np_cat_acc_min &
                                          [ HEAD #head ],
                                      CONT.HOOK.XARG #chand,
				      CONJ cnil ],
                              --SIND #cind,
                              OPT - ],
			    [ LOCAL local &
				    [ CAT [ HEAD 
                                             [ MOD < synsem &
                                                     [ LOCAL.CAT.HEAD #head,
                                                       --SIND #cind ]> ],
                                            VAL [ SPR *olist*,
                                                  SUBJ *olist*,
						  COMPS < > ],
					    MC na ],
                                      CONT.HOOK [ LTOP #chand,
                                                  XARG #cind ] ] ] > ] ],
            CONT.HOOK.XARG #subjind ],
    LKEYS.KEYREL arg1_relation &
          [ ARG1 #cind & non_expl-ind,
            WLINK *cons* ] ].

there_verb_synsem := expl_verb_synsem &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND there-ind & 
                                      [ PNG [ PN #pn,
                                              GEN no_gend_there ] ] ] >,
                    COMPS < [ LOCAL [ CAT.HEAD.KEYS.KEY 
                                                 nonpro_or_refl_or_num_rel,
                                      AGR.PNG [ PN #pn,
                                                GEN neut ] ] ],
                            [ LOCAL.CAT [ HEAD v_or_a_or_p &
                                               [ PRD - ],
                                          MC na,
                                          POSTHD + ],
                              OPT + ] > ] ].

itcleft_verb_synsem := expl_verb_synsem & aux_verb &
  [ LOCAL.CAT [ HEAD.AUX +,
                VAL [ SUBJ < [ --SIND it-ind & [ PNG.GEN no_gend_it ] ] >,
                      COMPS < synsem & [ LOCAL.CONT.HOOK.XARG #ltop ],
                              [ LOCAL.CAT.HEAD verb & 
                                  [ VFORM fin,
                                    MOD < [ LOCAL.CONT.HOOK.LTOP #ltop ] > ],
                                NONLOC.REL 1-dlist,
                                OPT - ] > ] ],
    LKEYS.KEYREL.PRED _be_v_itcleft_rel ].

; 'In the corner is a chair'
; 'Especially popular is Rondane'
; POSTHD - is hack to prevent these from undergoing adjunct extraction
loc_inv_verb_word := norm_no_affix_word &
  [ SYNSEM verb_synsem &
     [ LOCAL [ CAT [ HEAD [ AUX -, 
                            INV - ],
                     VAL [ SUBJ < canonical_synsem &
                                  [ LOCAL local_min &
                                    [ CAT basic_prd_cat &
                                     [ HEAD a_or_p &
                                            [ MOD < [ --SIND #cind ] >,
                                              KEYS.KEY independent_rel ],
                                       VAL.SUBJ *olist* ],
                                      CONT.HOOK 
                                          [ LTOP #ltop,
                                            INDEX #index &
                                                  [ E [ TENSE tense,
                                                        ASPECT.STATIVE + ] ],
                                            XARG #cind & individual_min ] ],
                                    OPT - ] >,
                           COMPS < synsem_min & 
                                   [ LOCAL [ CAT nomp_cat_min,
                                             CONT.HOOK.INDEX #cind,
                                             CONJ cnil ],
                                     OPT - ] > ],
                     POSTHD - ],
               CONT [ HOOK [ LTOP #ltop,
                             INDEX #index,
                             XARG #cind ],
                      RELS <! !>,
                      HCONS <! !> ] ],
       NONLOC non-local_none ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NOUNS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;       TYPE                 ISA                what's it for?
;       nominal_synsem       lex_synsem         all nouns
;       xpro_synsem          nominal_synsem     pro v. non-pro dimension
;       xref_synsem          nominal_synsem     ref v. non-ref dimension
;       pronominal_synsem    xpro_synsem        all pronouns
;       nonpronominal_synsem xpro_synsem        all non-pronominal nouns
;       ref_synsem           xref_synsem        personal pro's & nouns
;       non_ref_synsem       xref_synsem        it, there, wh-pronouns
;       ref_pro_synsem       pronominal_synsem  personal pronouns
;                            & ref_synsem
;       non_ref_pro_synsem   pronominal_synsem  it, there, wh-pronouns
;                            & non_ref_synsem
;       noun_synsem          nonpronominal_synsem all non-pro nouns
;                            & ref_synsem 

; The "default" statement that most nouns identify their AGR and INDEX
; will live on noun_synsem and non_ref_pro_synsem, and then be restated for
; personal pronouns other than my special 'they'.  (All this because I can't
; be bothered now to set up a special default type...) 

; DPF 3-May-03 - Why can't we make [MODIFD notmod] true for all nouns, rather
; than stipulating it on (almost) all subtypes?  Who wants to stay unmarked?
; Answer: day-of-month nouns like "tenth", which can combine with the simple
; determiner "the" and still be modifiers: "He arrived the tenth" but "*He
; arrived the week"

basic_nom_synsem := lex_synsem & 
  [ LOCAL [ CAT.HEAD nominal,
	    CONT nom-obj ] ].

nominal_synsem := basic_nom_synsem &
  [ LOCAL.CAT.HEAD.POSS - ].

xpro_synsem :< nominal_synsem.
xref_synsem :< nominal_synsem.

; DPF 23-Jul-99 - Add missing MOD < >.  Hmm.

pronominal_synsem := xpro_synsem &
  [ LOCAL [ CAT [ HEAD noun &
		       [ MOD < > ],
		  VAL.SUBJ < > ] ] ].

nonpronominal_synsem :< xpro_synsem.

; AAC - added following types for verbal_gerund, poss_clitic etc

nonpro_nomod_synsem := nomod_synsem & nonpronominal_synsem.
nonpro_onearg_synsem := nonpronominal_synsem & basic_one_arg.
nomod_onearg_synsem := nomod_synsem & one_arg.
nonpro_nomod_onearg_synsem := nonpro_nomod_synsem & basic_one_arg.

ref_synsem := xref_synsem &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY basic_nom_rel,
                  VAL.SPEC < anti_synsem_min > ],
            CONT [ HOOK.INDEX #inst & ref-ind,
                   RELS.LIST < nom_relation & #key & 
                               [ ARG0 #inst ], ... > ] ],
    LKEYS.KEYREL #key ].

non_ref_synsem := xref_synsem & nomod_synsem & zero_arg &
  [ LOCAL.CAT.VAL [ SPR < >,
		    COMPS < >,
                    SPEC < anti_synsem_min > ] ].

ref_pro_synsem := pronominal_synsem & ref_synsem & nomod_synsem.

non_ref_pro_synsem := pronominal_synsem & non_ref_synsem &
  [ LOCAL [ AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

basic_noun_synsem := nonpronominal_synsem & ref_synsem &
  [ LOCAL.CAT.HEAD noun ].

noun_synsem := basic_noun_synsem &
  [ LOCAL [ AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

mass_or_count_synsem := basic_noun_synsem.
count_noun_synsem := mass_or_count_synsem. 

;;
;; Common nouns
;;
;; DPF 16-Nov-00 - Added SPR.NONLOC.SLASH 0-dlist - don't know how we did
;; without this up to now.
;; DPF 14-Jul-01 - Well, we don't actually want SPR..SLASH 0-dlist since it
;; blocks free relative det constructions like "whichever person you hired"
;; where the "whichever" has a non-empty SLASH value.  Don't know what
;; motivated the above addition of 0-dlist, but I'm sure we'll soon see.
; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).
; DPF 8-Jun-03 - Removed SPR..COMPS *olist* since want to allow discontinuous
; analysis for e.g. "a week and a half"
; DPF 8-Jun-03 - Try requiring sprs of nouns to be LEX +, to block "*a and a
; half week" while enabling "a week and a half".  May want to consider making
; the head-spec rule impose this constraint on all specifiers, given similar
; need for allowing "kim is as tall as Sandy" but blocking "*Kim is as as 
; Sandy tall"

unsp_common_noun_synsem := basic_noun_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
	    CAT [ VAL [ SPR < #spr & synsem &
                              [ LOCAL local_min &
                                      [ CAT [ HEAD det,
                                              VAL [ SUBJ < >,
                                                    SPR *olist* ] ] ],
                                LEX +,
                                OPT - ] >,
                        COMPS #comps,
                        SPEC < anti_synsem_min > ],
                  HS-LEX - ] ] ].
            
basic_common_noun_synsem := unsp_common_noun_synsem & noun_synsem.

basic_count_noun_synsem := basic_common_noun_synsem & count_noun_synsem.
common_noun_synsem := basic_count_noun_synsem.

common_noun_nocomp_synsem := basic_count_noun_synsem & basic_one_arg &
  [ LOCAL [ CAT.VAL.COMPS < > ] ].

basic_mass_or_count_synsem := basic_common_noun_synsem & nonpro_nomod_synsem &
                              mass_or_count_synsem &
  [ LOCAL [ CONT.RELS <! relation !> ] ].

mass_or_count_nocomp_synsem := basic_mass_or_count_synsem & one_arg.

noun_nocomp_synsem := common_noun_nocomp_synsem & nonpro_nomod_onearg_synsem.

noun_nonpro_nomod_synsem := basic_common_noun_synsem & nonpro_nomod_synsem.
noun_two_arg_nomod_synsem := noun_nonpro_nomod_synsem & basic_two_arg.

; DPF 22-Jul-03 - Constraint on COMPS < expressed_synsem, ... > ensures that
; this complement is either realized or discharged via noptcomp, to avoid
; spurious ambiguity.

unsp_noun_ppcomp_synsem := unsp_common_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < expressed_synsem &
                          [ LOCAL local_min &
                                  [ CAT [ HEAD prep & [ PRD -,
                                                        KEYS.KEY #ckey ],
                                          VAL.COMPS < > ],
                                    CONT.HOOK.LTOP #hand ],
                            PUNCT.LPUNCT no_punct ], ... >,
    LKEYS [ KEYREL.LBL #hand,
            --COMPKEY #ckey ] ].

basic_noun_ppcomp_synsem := unsp_noun_ppcomp_synsem & basic_common_noun_synsem.

noun_nondeverb_ppcomp_synsem := basic_noun_ppcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ INDEX #index,
                                              XARG #xarg ] ] >,
    LKEYS.KEYREL [ ARG0 #xarg,
                   ARG1 #index ] ].

noun_deverb_ppcomp_synsem := basic_noun_ppcomp_synsem & nonpro_nomod_synsem &
                             common_noun_synsem & basic_two_arg.

unsp_ppcomp_two_arg_synsem := unsp_noun_ppcomp_synsem & two_arg &
                              nonpro_nomod_synsem & count_noun_synsem.

noun_ppcomp_two_arg_synsem := unsp_ppcomp_two_arg_synsem &
                              basic_noun_ppcomp_synsem & common_noun_synsem.

noun_ppcomp_three_arg_synsem := basic_noun_ppcomp_synsem & three_arg &
                                nonpro_nomod_synsem & common_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          expressed_synsem &
                          [ LOCAL local_min &
                                  [ CAT [ HEAD prep & [ PRD -,
                                                        KEYS.KEY #ckey ],
                                          VAL.COMPS < > ],
                                    CONT.HOOK.LTOP #hand ],
                            PUNCT.LPUNCT no_punct ] >,
    LKEYS [ KEYREL.LBL #hand,
            --OCOMPKEY #ckey ] ].

temp_noun_ppcomp_synsem := nonpro_nomod_synsem & 
  [ LOCAL [ CAT [ HEAD.KEYS.KEY temp_abstr_rel, 
                  VAL [ SUBJ < >,
                        SPR < [ OPT - ] >,
                        SPEC < anti_synsem_min > ] ],
	    CONT [ HOOK.INDEX.SORT time,
                   RELS <! relation !> ] ] ].

; DPF 25-mar-05 - Added MODIFD notmod to avoid spurious ambig with adjN rules.
; DPF 26-mar-05 - But this conflicts with the constraint in the NP-ADV rule
; which distinguishes "we arrived the week before" from "*we arrived the week"
; since we also want "We arrived Tuesday".  So try just excluding lmod value.

temp_noun_ppcomp_two_arg_synsem := basic_noun_ppcomp_synsem & two_arg & 
                                   count_noun_synsem & 
                                   temp_noun_ppcomp_synsem &
  [ MODIFD notmod_or_rmod ].

; For e.g. "hotel" as in "the hotel Marriott" or "the Marriott hotel Hannover"c
basic_noun_nomcomp_synsem := noun_nonpro_nomod_synsem &
  [ LOCAL [ CAT.VAL.KCMP
                     expressed_synsem & 
                     [ LOCAL [ CONJ cnil,
                               CONT [ HOOK.INDEX #cindex,
                                      MSG no_msg ] ] ],
            CONT [ HOOK [ LTOP #hand,
                          INDEX #index ],
		   RELS.LIST < relation, 
                               prep_notense_relation &
                               [ LBL #hand,
                                 PRED compound_rel,
                                 ARG1 #index,
                                 ARG2 #cindex ], ... > ] ],
    LKEYS.KEYREL.LBL #hand ].

basic_noun_npcomp_synsem := basic_noun_nomcomp_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL [ CAT nomp_cat_acc_min &
                                          [ HEAD.KEYS.KEY abstr_named_rel ],
                                 CONT.HOOK.LTOP #hand ],
            CONT [ HOOK.LTOP #hand,
                   RELS <! relation, relation !>,
                   HCONS <! !> ] ] ].

common_noun_npcomp_synsem := basic_noun_npcomp_synsem & basic_two_arg &
                             count_noun_synsem &
  [ LOCAL.CAT.VAL [ COMPS < #comp & [ OPT -,
                                      PUNCT.LPUNCT no_punct ] >,
                    KCMP #comp ],
    LKEYS.KEYREL reg_diadic_nom_relation ].

; 'kinda' as in "what kinda chair is that"
common_noun_nbarcomp_synsem := basic_noun_nomcomp_synsem & basic_two_arg &
                               count_noun_synsem &
  [ LOCAL [ CAT.VAL [ SPR < [ NONLOC.SLASH 0-dlist ] >,
                      COMPS < #comp & abstr_lex_synsem &
                              [ LOCAL [ CAT nbar_cat_min & [ HEAD noun ],
                                        CONT.HOOK [ LTOP #nhand,
                                                    INDEX #arg ] ],
                                OPT -,
                                PUNCT.LPUNCT no_punct ] >,
                      KCMP #comp ],
            CONT [ RELS <! relation, relation,
                         [ PRED udef_q_rel,
                           ARG0 #arg,
                           RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ],
    LKEYS.KEYREL reg_diadic_nom_relation ].

common_noun_numcomp_synsem := common_noun_nocomp_synsem &
  [ LOCAL.CAT.HEAD [ KEYS.KEY mnp_symb_rel,
                     PRD + ] ].

; ERB (14-12-97) It might be cleaner in some sense for pro_ss to have that
; pron_rel as its key and then have this construction and others like it
; take the value of that KEY and put it on their RELS.  Also, if we
; ever move to lexical amalgamation of relations, the pron_rel should get
; incorporated automatically. ... So I'm going to try to do it that way.

; ERB (14-12-97) We just decided that there shouldn't be a pron_rel here.
; The feature PRONTYPE is enough to distinguish the instance introduced
; by the pro_ss as one that doesn't have to be bound.

; ERB (21-01-98) The pro_ss should be unslashed.

basic_mass_noun_synsem := basic_common_noun_synsem & nonpro_nomod_synsem &
                          mass_or_count_synsem &
  [ LOCAL [ CONT.HOOK.INDEX [ PNG png & [ PN 3sg ],
                              DIVISIBLE + ] ] ].

basic_scoping_noun_synsem := noun_nonpro_nomod_synsem &
  [ LOCAL [ CAT.VAL.KCMP [ LOCAL.CONT [ HOOK.LTOP #hand,
                                        MSG message ],
                           PUNCT.LPUNCT no_punct ] ],
    LKEYS.KEYREL hcomp_nom_relation & [ ARG1 #hand ] ].

scoping_noun_synsem := basic_scoping_noun_synsem & noun_two_arg_nomod_synsem.

;; a way to meet

basic_common_noun_vpcomp_synsem := basic_scoping_noun_synsem & 
                                   common_noun_synsem &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < #comp & phr_synsem &
			      [ LOCAL [ CAT vp_inf_cat &
					 [ VAL.SUBJ 
					    < pro_ss &
					      [ NONLOC.SLASH 0-dlist ] > ],
                                        CONT [ HOOK.XARG #inst,
                                               MSG.PRED propositional_m_rel ],
					CONJ cnil ],
				OPT - ] > ],
	    CONT [ RELS <! relation, 
                          [ PRED pronoun_q_rel,
                            RSTR #rhand,
                            ARG0 #inst ],
                          [ LBL #prohand,
                            PRED pron_rel,
			    ARG0 #inst & [ PRONTYPE zero_pron,
                                           SORT entity ] ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #prohand ] !> ] ],
    LKEYS.KEYREL hcomp_nom_relation ].

common_noun_vpcomp_synsem := basic_common_noun_vpcomp_synsem & 
                             scoping_noun_synsem.

; pleasure: "it is a pleasure to visit Abrams"

; It is a pleasure to visit abrams.
common_noun_vpcomp_expl_synsem := common_noun_vpcomp_synsem &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY prednom_rel,
                  VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY no_rel ] >,
                        COMPS < [ NONLOC.SLASH 0-dlist,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG it-ind ],
    MODIFD notmod ].


; Abrams is a pleasure to visit.
common_noun_vpcomp_slash_synsem := basic_common_noun_vpcomp_synsem &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY prednom_rel,
                  VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY no_rel ] >,
                        COMPS < [ NONLOC.SLASH 1-dlist & 
                                         <! [ CAT nomp_cat_min,
                                              CONT.HOOK.INDEX #xarg ] !>,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG #xarg ],
    NONLOC.SLASH 0-dlist,
    MODIFD notmod ].

basic_common_noun_cpcomp_synsem := scoping_noun_synsem &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < #comp & synsem &
			    [ LOCAL.CONJ cnil,
			      OPT - ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

basic_count_noun_cpcomp_synsem := basic_common_noun_cpcomp_synsem & 
                                  count_noun_synsem.
common_noun_cpcomp_synsem := basic_count_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp ] >,
    LKEYS.KEYREL hcomp_nom_relation ].

common_noun_cpcomp_fin_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ].

common_noun_cpcomp_inf_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_inf_v_c ] > ].

common_noun_cpcomp_bse_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_bse ] > ].

mass_count_noun_cpcomp_fin_synsem := basic_common_noun_cpcomp_synsem &
                                     basic_mass_or_count_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c & [ HEAD comp ] ] > ],
    LKEYS.KEYREL hcomp_nom_relation ].

mass_noun_onearg_synsem := basic_mass_noun_synsem & one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

mass_noun_synsem := mass_noun_onearg_synsem &
  [ LOCAL [ CAT.HEAD.KEYS.KEY norm_nom_rel,
            CONT.RELS <! reg_nom_relation !> ] ].

mass_noun_ppcomp_synsem := basic_mass_noun_synsem & two_arg &
                           noun_nondeverb_ppcomp_synsem &
  [ LOCAL [ CAT.HEAD.KEYS.KEY norm_nom_rel,
            CONT.RELS <! reg_diadic_nom_relation !> ] ].

basic_mass_or_count_ppcomp_synsem := basic_mass_or_count_synsem & two_arg &
                                     noun_nondeverb_ppcomp_synsem &
  [ LOCAL.CAT.HEAD.KEYS.KEY diadic_nom_rel,
    LKEYS.KEYREL diadic_nom_relation ].

mass_or_count_ppcomp_synsem := basic_mass_or_count_ppcomp_synsem &
  [ LKEYS.KEYREL reg_diadic_nom_relation ].

mass_noun_npcomp_synsem := basic_mass_noun_synsem & basic_noun_npcomp_synsem &
                           basic_two_arg &
  [ LOCAL.CAT.VAL [ COMPS < #comp & [ OPT -,
                                      PUNCT.LPUNCT no_punct ] >,
                    KCMP #comp ],
    LKEYS.KEYREL reg_diadic_nom_relation ].

; PRD feature used as a hack to avoid partitives in noun-noun compounds,
; pending a better analysis.
; DPF 9-Sept-99 - Changed N-N block to be based on non-empty ALTKEY, rather 
; than PRD. The handle of the of-NP should probably be an argument of the 
; part_of relation, as the value of a feature SET.  But for now we simply 
; identify the handles of the part_of and the of_NP.
; DPF 17-Apr-03 - Changed set-up so the KEY of partitives will be the KEY of
; the of-PP's NP if there is a complement and an underspecified nom_rel as
; the default.
; DPF 2-May-03 - Changed SPR..KEY from degree_rel to just_only_very_deg_rel
; to block a lot of overgeneration, but still leaving a little (e.g. 
; "very all chairs arrived").  We'll fix this once we move to relation names
; as values of PRED feature in relation.
; DPF 27-Jul-03 - Removed SPR..KEY, since it needs to preserve the constraints
; from the non-partitive determiner (the input to the lexical rule for which
; this type is the output), as in "too much of the rice was spilled".
; DPF 31-Oct-03 - But need some SPR..KEY constraint since not all partitives
; are constructed via that lexical rule, and they need some kind of 
; restriction.  So added this constraint to n_part_lexent below.
; DPF 13-Nov-03 - Removed SPR..COMPS *olist* since want these to be able to
; take comparative degree specifiers (which have a non-empty COMPS list), 
; like in "kim hired as many as sandy"
; DPF 22-feb-04 - Identified INDEX and AGR, as with noun_synsem -- was there
; a reason this wasn't done earlier?  It's needed to get the right agreement
; for e.g. "we climbed peaks all of which are tall".
; DPF 09-may-04 - Changed SPEC < > to SPEC < anti_synsem_min > so partitives can
; appear as complements of empty-preps, as in "kim relied on all the chairs"

partitive_noun_synsem := nonpronominal_synsem & xref_synsem &
  [ LOCAL [ CAT [ HEAD partn &
                       [ MOD < >,
                         KEYS [ KEY basic_nom_rel,
                                ALTKEY quant_or_wh_rel & #altkeypred ] ],
                  VAL [ SUBJ < >,
                        SPR < [ LOCAL local_min &
                                    [ CAT.VAL.SPR  *olist*,
                                      CONT.HOOK.LTOP #alt2hand ],
                              NONLOC [ QUE 0-dlist,
                                          REL 0-dlist ],
                              OPT + ] >,
                        SPEC < anti_synsem_min >,
                        KCMP [ LOCAL local_min &
					[ CAT [ HEAD prep & 
						     [ PRD -,
                                                       TAM.TENSE nontense,
                                                       KEYS.KEY #ckey & 
                                                           _of_p_sel_rel ],
						VAL.COMPS < > ],
                                          CONT.HOOK.LTOP #nhand ],
                               NONLOC.SLASH 0-dlist,
                               OPT - ] ] ],
            CONT [ HOOK [ LTOP #nhand,
                          INDEX #index & ref-ind ],
		   HCONS.LIST < qeq & [ HARG #phand,
                                        LARG #nhand ], ... > ],
	    AGR #index ],
    LKEYS [ KEYREL nom_relation &
                   [ LBL #nhand,
                     ARG0 #index ],
            ALTKEYREL quant_or_wh_relation &
                        [ PRED #altkeypred,
                          ARG0 #index,
                          RSTR #phand ],
            ALT2KEYREL.LBL #alt2hand,
            --COMPKEY #ckey ] ].

; DPF 17-Apr-03 - Identify KEY relation with the of-PP's complement's ALTKEY,
; (the KEY of that PP's NP complement) to maintain visibility of that NP's
; relation, for example to block "*Kim arrives one of these chairs" but allow
; "Kim arrives one of these days".
; DPF 17-dec-03 - Changed KEYREL from reg_diadic_nom_relation to just
; diadic_nom_relation to avoid [SORT entity] constraint, so we can get e.g.
; "hiring sandy is (only) some of the challenge".

basic_partitive_noun_ppof_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY #key,
                  VAL.KCMP [ LOCAL [ CAT.HEAD.KEYS.ALTKEY #key,
                                     CONT.HOOK.INDEX #arg ],
                             NONLOC.REL #rel,
                             PUNCT.LPUNCT no_punct ] ] ],
    NONLOC.REL #rel,
    LKEYS.KEYREL diadic_nom_relation &
          [ PRED part_of_rel,
            ARG1 #arg & non_expl-ind ] ].

partitive_noun_ppof_synsem := basic_partitive_noun_ppof_synsem &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
                      COMPS < #comp > ],
            CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS.KEYREL #keyrel ].

partitive_noun_ppof_agr_synsem := partitive_noun_ppof_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.AGR [ PNG.PN #pn,
                                          DIVISIBLE #div ],
            AGR [ PNG.PN #pn,
                  DIVISIBLE #div ] ] ].

partitive_noun_ppof_noagr_synsem :< partitive_noun_ppof_synsem.

; all the books, half your salary
; DPF 11-Sept-01 - Added COMPS..ALTKEY norm_non_conj_rel to block e.g.
; 'both Abrams or Browne arrived'
; DPF 1-Oct-01 - Replaced the above with ALTKEY explicit_q_rel to avoid
; spurious parse for "All books".  Maybe no longer need norm_non_conj_rel.
; DPF 25-apr-04 - Deleted the spurious of_p_sel_rel from RELS.

partitive_noun_NP_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY #key,
                  VAL.COMPS < synsem & 
                            [ LOCAL [ CAT nomp_cat_acc_min &
                                      [ HEAD.KEYS [ KEY #key,
                                                    ALTKEY explicit_q_rel ] ],
                                      CONT.MSG no_msg,
                                      CONJ cnil ],
                              NONLOC non-local_none,
                              --SIND #arg,
                              OPT -,
                              PUNCT.LPUNCT no_punct ] > ],
            CONT.RELS <! reg_diadic_nom_relation & #keyrel &
                         [ PRED part_of_rel,
                           ARG1 #arg & non_expl-ind,
                           WLINK #wlink ],
                         relation & [ WLINK #wlink ] !> ],
    NONLOC.REL 0-dlist,
    LKEYS.KEYREL #keyrel ].

partitive_noun_NP_agr_synsem := partitive_noun_NP_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR [ PNG.PN #pn,
                                          DIVISIBLE #div ] ] >,
            AGR [ PNG.PN #pn,
                  DIVISIBLE #div ] ],
    LKEYS.ALTKEYREL.PRED explicit_quant_agr_q_rel ].

; both
partitive_noun_NP_noagr_synsem := partitive_noun_NP_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3pl ] > ].

; DPF 03-Dec-03 - Added LPERIPH na to prevent these from appearing as heads
; of appositive phrases: "both abrams"
; DPF 06-dec-03 - Moved COMPS < > to le-type using this synsem, so the lexrule
; for partitives with no of-PP can still propagate any other comps of that
; det, in particular for free-rels like "whichever".
; DPF 11-dec-03 - Made KEY part_of_rel so these fit with constraint on "than"
; as in "Kim has more (of the chairs) to offer than Kim"
partitive_noun_nocomp_synsem := partitive_noun_synsem &
  [ LOCAL.CAT.HEAD.KEYS.KEY part_of_rel,
    MODIFD.LPERIPH na,
    NONLOC.REL 0-dlist,
    LKEYS.KEYREL.PRED generic_nonpro_rel ].

basic_noun_word := word &
  [ SYNSEM [ ROOT -,
             PUNCT no_punctuation ] ].
basic_pronoun_word :< basic_noun_word.
noun_noninfl_word := hcons_amalg_word & basic_noun_word &
  [ INFLECTD - ].

noun_word := hcons_amalg_affixed_word & basic_noun_word.

basic_intr_noun_word := noun_noninfl_word &
  [ SYNSEM common_noun_nocomp_synsem &
	   [ LOCAL.CONT [ RELS <! relation !>,
                          HCONS <! !> ] ] ].

basic_intr_lex_entry := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	  [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY quant_or_wh_rel ] >,
            MODIFD notmod ] ].

n_intr_lex_entry := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_intr_le := n_intr_lex_entry.

; 'handheld'
n_no_cmpnd_le := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD.KEYS [ KEY norm_nom_rel,
                                     ALTKEY quant_or_wh_rel,
                                     ALT2KEY norm_rel ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

; phone (like number, order)
n_intr_nosort_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel,
             LKEYS.KEYREL nom_relation ] ].

; For determinerless-PPs: 'within range'
; DPF 25-apr-04 - Added ALTKEY quant_or_wh_rel to prevent these from
; appearing as left members of N-N compounds.
n_bare_lex_entry := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ CASE obliq,
                                KEYS [ KEY bare_nom_rel,
                                       ALTKEY quant_or_wh_rel ] ],
                         VAL.SPR < unexpressed > ],
             LKEYS.KEYREL reg_nom_relation ] ].

; 'in (family/open) court'
n_bare_le := n_bare_lex_entry.

; 'at eye level' ('*at level')
n_bare_nmod_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY bare_n_nmod_rel,
             MODIFD.LPERIPH na ] ].

; 'on (summer) vacation' ('*on long vacation')
n_bare_nmod_opt_le := n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY bare_n_nmod_rel ].

; 'at close range' ('*at range')
n_bare_jmod_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY bare_n_jmod_rel,
             MODIFD.LPERIPH - ] ].

; 'in (sharp) contrast'
; 'at (long) last'
n_bare_jmod_opt_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY bare_n_jmod_rel,
             MODIFD.LPERIPH bool ] ].

; 'at (considerable/company) expense' ('*at expense')
n_bare_mod_le := n_bare_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY bare_nom_rel,
             MODIFD.LPERIPH na_or_- ] ].

; 'on top', 'of course'
n_bare_nomod_le := n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY bare_n_nomod_rel ].


; his own
n_intr_poss_le := n_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT [ HEAD.KEYS.ALTKEY def_explicit_q_rel,
                         VAL.SPR < [ LOCAL.CAT.HEAD.POSS + ] > ],
             LKEYS.ALTKEYREL relation ] ].

; Idiom nouns: e.g.
; ahold: 'I got ahold of sandy'
; part: 'I took part in the meeting'

n_intr_nospr_le := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
           [ LOCAL [ CAT [ HEAD.KEYS.KEY norm_nom_rel,
                           VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY idiom_q_rel ]>],
                     CONT.RELS <! reg_nom_relation !> ],
             MODIFD lmod  ],
    IDIOM + ].

; 'rest': 'rest of the week', 'rest of the book'
n_intr_unspec_le :=  basic_intr_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY modable_nom_rel ].

n_intr_temp_lexent := basic_intr_noun_word & 
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.KEYS.KEY temp_abstr_rel,
                           VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                      quant_or_wh_rel ] > ],
                     CONT.HOOK.INDEX.SORT time ],
             MODIFD notmod ] ].

n_intr_temp_le := n_intr_temp_lexent.

n_intr_temp_d_le := n_intr_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY day_rel ].

n_intr_temp_nd_le := n_intr_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY non_day_modable_rel ].

n_intr_temp_h_le := n_intr_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY gen_hour_rel ].

n_intr_temp_ssn_le := n_intr_temp_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY season_rel,
             LKEYS.KEYREL.PRED season_rel ] ].

; 'while' as in "Kim stayed for a while"
n_temp_nomod_le := n_intr_temp_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.KEYS [ KEY non_day_nonmodable_rel,
                                     ALTKEY quant_or_wh_rel ],
                         VAL.SPR < canonical_synsem > ],
             MODIFD.LPERIPH +,
             LKEYS.KEYREL.ARG0.PNG.PN 3sg ] ].

n_intr_sg_le := basic_intr_lex_entry &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD.KEYS [ KEY norm_nom_rel,
                                     ALTKEY quant_or_wh_rel ],
                     CONT.RELS <! reg_nom_relation !> ],
             LKEYS.KEYREL.ARG0.PNG.PN 3sg ] ].

; 'the DFKI'

n_intr_named_lexent := mcna & nonmsg & nonmsg & hc-to-phr &
  [ INFLECTD -,
    SYNSEM noun_nocomp_synsem &
     [ LOCAL [ CAT [ HEAD.KEYS.KEY norm_nom_rel,
                     VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY quant_or_wh_rel ] >],
               CONT [ HOOK.LTOP #ltop,
                      RELS <! relation !>,
                      HCONS <! !> ],
               CONJ cnil ],
       MODIFD notmod,
       LKEYS.KEYREL named_nom_relation &
             [ LBL #ltop,
               PRED named_n_rel ],
       ROOT - ] ].

n_intr_named_le := n_intr_named_lexent &
  [ SYNSEM.PUNCT no_punctuation ].

; For period-final names like "u.s."
n_intr_named_punct_le := n_intr_named_lexent &
  [ SYNSEM.PUNCT [ LPUNCT no_punct,
                   RPUNCT clause_or_no_punct ] ].

; 'dollar'
n_intr_dollar_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY _dollar_n_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_intr_unk_le := n_intr_lex_entry &
  [ SYNSEM.LKEYS.KEYREL.PRED unk_n_rel ].

basic_noun_ppcomp_word := noun_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL.CONT.RELS <! relation !> ] ].

norm_noun_ppcomp_word := basic_noun_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.KEYS.KEY independent_rel,
                                             CONT.HOOK.XARG #index ]  ]>,
             LKEYS.KEYREL.ARG1 #index ] ].

; DPF 12-mar-05 - Added MODIFD notmod to prevent spurious rule for prenom
; adjectives
noun_empty_ppcomp_word := basic_noun_ppcomp_word &
  [ SYNSEM [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.KEYS.KEY selected_rel,
                                             CONT.HOOK.INDEX #index ] ] >,
             LKEYS.KEYREL.ARG1 #index ] ].

noun_ppcomp_word := norm_noun_ppcomp_word &
  [ SYNSEM [ MODIFD notmod,
             LOCAL.CAT.HEAD.KEYS.KEY unspec_diadic_nom_rel ] ].

n_ppcomp_lexent := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY diadic_nom_rel,
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

n_ppcomp_le := n_ppcomp_lexent.

n_ppcomp_spr_le := n_ppcomp_lexent &
  [ SYNSEM [ MODIFD.LPERIPH -,
             LKEYS.--COMPKEY _of_p_nbar_rel ] ].

; 'thing about X'; 'rest of X': "I am here the rest of the day"
n_ppcomp_oblig_lexent := noun_empty_ppcomp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

n_ppcomp_oblig_le := n_ppcomp_oblig_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY diadic_nom_rel,
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

; 'rest': modable
n_ppcomp_oblig_unspec_le := n_ppcomp_oblig_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY modable_nom_rel ].

n_ppof_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

n_ppof_unsp_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY reg_diadic_nom_rel,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_ppof_unsp_reg_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY reg_diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

n_ppof_oblig_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT [ HEAD.KEYS.KEY norm_nom_rel,
                         VAL.COMPS < [ OPT - ] > ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; Since partitive rule already applies to measure NPs to produce
; "ten feet of rope", remove the pp-of complement here to avoid spurious
; ambiguity.
n_ppof_meas_le := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY meas_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_meas_nocmpnd_le := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
       [ LOCAL.CAT [ HEAD.KEYS [ KEY meas_nom_rel,
                                 ALTKEY no_rel,
                                 ALT2KEY norm_rel ] ],
         MODIFD rmod,
         LKEYS.KEYREL reg_nom_relation ] ].

n_ppof_place_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY abstr_place_rel,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_ppof_unspec_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel,
             LKEYS [ KEYREL diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

n_ppcomp_unspec_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel,
             LKEYS.KEYREL diadic_nom_relation ] ].

; 'way': modable
n_ppof_unspec_mod_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY modable_nom_rel,
             LKEYS [ KEYREL diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; For abbrev "no." and similarly for "north, south, east, west"

n_ppof_nocmpnd_le := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS [ KEY diadic_nom_rel,
                                   ALTKEY quant_or_wh_rel ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

noun_double_ppcomp_word := noun_word &
  [ SYNSEM noun_ppcomp_three_arg_synsem &
         [ LOCAL [ CAT [ HEAD.KEYS.KEY norm_nom_rel,
                         VAL.COMPS < [ LOCAL [ CAT.HEAD.KEYS.KEY selected_rel,
                                               CONT.HOOK.INDEX #index1 ] ],
                                     [ LOCAL [ CAT.HEAD.KEYS.KEY selected_rel,
                                               CONT.HOOK.INDEX #index2 ] ] > ],
                   CONT.RELS <! relation !> ],
           LKEYS.KEYREL reg_triadic_nom_relation &
                        [ ARG1 #index1,
                          ARG2 #index2 ] ] ].

n_double_ppcomp_le := noun_double_ppcomp_word.

n_ppon_le := noun_ppcomp_word &
  [ SYNSEM.LKEYS [ KEYREL reg_diadic_nom_relation,
                   --COMPKEY _on_p_rel ] ].

noun_ppin_word := noun_empty_ppcomp_word &
  [ SYNSEM [ LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _in_p_sel_rel ] ] ].

basic_n_temp_ppcomp_lexent := noun_word &
  [ SYNSEM temp_noun_ppcomp_two_arg_synsem &
           [ LKEYS.KEYREL generic_diadic_named_relation ] ].

norm_n_temp_ppcomp_lexent := basic_n_temp_ppcomp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY _of_p_sel_rel,
                                   OPT + ] > ].

; DPF 22-May-02 - Note that we have to have two entries for the word "time",
; one which must take a determiner, and which can appear in a temp-mod phrase;
; and the other which denotes a temporal chunk and can't appear as temp-mod:
; "He'll stay this time" but "*He stayed time for a meeting" (Cf. "Do you 
; have time for a meeting.")

; DPF 05-dec-03 - Added ALT2KEY as hack to prevent these from appearing as 
; left members of n-n-cmpnds like 'afternoon Monday' though maybe actually OK.
; DPF 06-dec-03 - Removed of-PP complement since possessive of-PP now does the
; work, and we avoid spurious ambiguity.
; DPF 22-sept-04 - Changed SPR from expressed_synsem to synsem so these will
; undergo the bare_np rule, which requires the SPR to be 'unexpressed'.

n_temp_ppcomp_lexent := n_intr_temp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < synsem >,
             MODIFD notmod ] ].

n_temp_ppcomp_day_le := norm_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY unnamed_day_rel,
             MODIFD notmod ] ].

n_temp_ppcomp_time_le := basic_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             MODIFD notmod & [ LPERIPH - ] ] ].

n_temp_ppcomp_hour_le := n_temp_ppcomp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY gen_hour_rel ].

n_temp_ppcomp_minute_le := n_temp_ppcomp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY _minute_n_rel ].

n_temp_ppcomp_nd_le := n_temp_ppcomp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY non_day_diadic_modable_rel ].

n_temp_ppcomp_year_le := n_temp_ppcomp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY non_day_diadic_modable_rel ].

; DPF 22-May-02 - Changed ALTKEY from basic_nom_rel to quant_or_wh_rel to be 
; consistent with constraints on relative clause modifiees.
n_day_of_week_le := norm_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.KEYS [ KEY dofw_rel,
                                     ALTKEY quant_or_wh_rel ],
                         VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.ALTKEY
                                              non_day_diadic_modable_rel ] > ],
             LKEYS [ KEYREL.PRED dofw_rel,
                     ALTKEYREL.PRED quant_or_wh_rel ] ] ].

; DPF 13-May-02 - Added LPERIPH + to prevent these from appearing as heads of
; noun-noun compounds.
; DPF 22-May-02 - But this also blocks "rainy April" - try again.
; DPF 22-May-02 - Changed ALTKEY from basic_nom_rel to quant_or_wh_rel to be 
; consistent with constraints on relative clause modifiees.

n_month_le := norm_n_temp_ppcomp_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.KEYS [ KEY mofy_rel,
                                     ALTKEY proper_q_rel ],
                         VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.ALTKEY yofc_rel ]>],
             LKEYS [ KEYREL.PRED mofy_rel,
                     ALTKEYREL.PRED quant_or_wh_rel ],
             MODIFD notmod ] ].

; "way" as in "find a way to do that" -- was used in VM, but analysis changed
; so this type not currently in use.  Its semrel.tdl entry was as follows:
;   _way_rel := hcomp_nom_rel &
;     [ ARG0.SORT entity ].

n_vpcomp_le := noun_word &
  [ SYNSEM common_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel ] ].

n_cpcomp_fin_le := noun_word &
  [ SYNSEM common_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel ] ].

; 'reason' - The reason Kim left bothered sandy"
n_cpcomp_fin_optthat_lexent := noun_word &
  [ SYNSEM basic_count_noun_cpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ] ].

n_cpcomp_fin_optthat_le := n_cpcomp_fin_optthat_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel ].

; 'way': modable
n_cpcomp_fin_optthat_unspec_le := n_cpcomp_fin_optthat_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY modable_nom_rel ].

; 'request'
n_cpcomp_bse_le := noun_word &
  [ SYNSEM common_noun_cpcomp_bse_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel ] ].

; procedure
n_cpcomp_inf_le := noun_word &
  [ SYNSEM common_noun_cpcomp_inf_synsem &
	   [ MODIFD notmod ] ].

; notification
n_mass_count_cpcomp_fin_le := noun_word &
  [ SYNSEM mass_count_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel ] ].

n_npcomp_le := hc_word & basic_noun_word &
  [ INFLECTD -,
    SYNSEM common_noun_npcomp_synsem &
	   [ LOCAL.CAT [ HEAD.KEYS.KEY norm_nom_rel,
                         HC-LEX + ],
	     MODIFD notmod ] ].

n_nomcomp_le := hc_word & basic_noun_word &
  [ INFLECTD -,
    SYNSEM common_noun_nbarcomp_synsem &
	   [ LOCAL.CAT [ HEAD.KEYS.KEY norm_nom_rel,
                         HC-LEX + ],
	     MODIFD notmod ] ].

; Use special inflectional rule to produce plural inflected form without 's'
n_numcomp_lexent := mcna & nonconj & nonmsg & hc-to-phr & basic_noun_word &
  [ INFLECTD -,
    SYNSEM common_noun_numcomp_synsem &
	   [ LOCAL.CONT [ HOOK.LTOP #ltop,
                          RELS <! relation !>,
                          HCONS <! !> ],
             LKEYS.KEYREL [ LBL #ltop,
                            WLINK *cons* ],
             MODIFD notmod ] ].

n_numcomp_le := n_numcomp_lexent.
n_numcomp_gen_le := n_numcomp_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED gen_currency_rel ].

n_mass_le := noun_noninfl_word &
  [ SYNSEM mass_noun_synsem &
	   [ MODIFD notmod ] ].

; Removed LPERIPH na because it prevents these from heading NP-N cmpnds.
n_mass_count_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_mass_count_nosort_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod & [ LPERIPH na ],
             LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel,
             LKEYS.KEYREL nom_relation ] ].

; 'time': modable
; LPERIPH is na_or_- so it can be head of N-N-cmpnd rule as in "work times"

n_mass_count_time_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod & [ LPERIPH na_or_- ],
             LOCAL [ CAT.HEAD.KEYS.KEY non_day_time_rel,
                     CONT.HOOK.INDEX.SORT time ] ] ].

n_mass_ppcomp_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ MODIFD notmod ] ].

n_mass_ppcomp_oblig_le := noun_noninfl_word &
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

n_mass_count_ppcomp_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
	   [ MODIFD notmod ] ].

n_mass_count_ppcomp_oblig_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

n_mass_count_ppof_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

; For "order" as in "my order, number 12345" where appositive rule requires
; compatibility of sorts.

n_mass_count_ppof_unspec_le := noun_noninfl_word &
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
           [ LOCAL.CAT.HEAD.KEYS.KEY reg_diadic_nom_rel,
             MODIFD notmod,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_mass_count_ppfor_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
	     LKEYS.--COMPKEY _for_p_sel_rel ] ].

n_mass_count_ppto_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
	     LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS.--COMPKEY _to_p_sel_rel ] ].

n_mass_count_ppin_le := noun_noninfl_word &
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ MODIFD notmod,
	     LKEYS.--COMPKEY _in_p_sel_rel ] ].

; Don't appear as left or right members of compounds: e.g. 'last'
n_mass_no_cmpnd_le := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ MODIFD notmod,
             LOCAL [ CAT.HEAD.KEYS [ KEY norm_nom_rel,
                                     ALTKEY quant_or_wh_rel,
                                     ALT2KEY norm_rel ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

basic_n_plur_lexent := noun_noninfl_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL.CONT [ HOOK.INDEX.PNG png & [ PN 3pl ],
                          HCONS <! !> ] ] ].

n_plur_lexent := basic_n_plur_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].

n_plur_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel,
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; e.g. 'goods': "*the good boat" with nominal 'good'
n_plur_nocmpnd_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS [ KEY norm_nom_rel,
                                   ALT2KEY norm_rel ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

n_plur_idiom_le := n_plur_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel,
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ],
    IDIOM + ].

; "euro's" which the preprocessor turns into "euro 's"
n_plur_mwe_lexent := amalg_word & basic_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CONT [ HOOK.INDEX.PNG png & [ PN 3pl ],
                            RELS <! relation !>,
                            HCONS <! !> ] ] ] ].

n_plur_mwe_le := n_plur_mwe_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel,
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

n_ones_le := basic_n_plur_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.KEYS.KEY _one_n_rel,
                     CONT.RELS <! [ LBL #lbl,
                                    PRED generic_nonpro_rel,
                                    ARG0 #arg0 ],
                                [ LBL #lbl,
                                  PRED card_rel,
                                  ARG1 #arg0,
                                  CARG "1" ] !> ],
             MODIFD notmod_or_rmod ] ].

; For plurals like "sixties" which can directly undergo the npadv_mod rule.
; DPF 8-nov-03 - Can't see why we want "sixties" to under npadv_mod rule, so
; changed gen_numval_rel to not inherit from modable_rel.

n_plur_xmod_le := n_plur_mwe_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY gen_numval_rel,
             LKEYS.KEYREL.PRED gen_numval_rel ] ].

n_plur_ppcomp_lexent := noun_noninfl_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.KEYS.KEY norm_nom_rel,
                           VAL [ COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
							     INDEX #index ]] >,
				 SPR < [ LOCAL.AGR.PNG.PN 3pl ] > ] ],
                     CONT [ HOOK.INDEX.PNG png & [ PN 3pl ],
                            RELS <! reg_diadic_nom_relation !> ] ],
	     MODIFD notmod,
             LKEYS.KEYREL [ LBL #ltop,
			    ARG1 #index ] ] ].

n_plur_ppcomp_le := n_plur_ppcomp_lexent.
; 'millions of ...'
n_plur_ppcomp_oblig_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
                   CONT.RELS <! [ PRED card_rel ] !> ] ].
; 'others of you'
n_plur_ppcomp_oblig_unsp_le := n_plur_ppcomp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

; "kind"
n_plur_sing_ppcomp_le := amalg_word & basic_noun_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.KEYS.KEY norm_nom_rel,
                           VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #index ] > ],
                     AGR.DIVISIBLE -,
                     CONT [ HOOK.INDEX.PNG png & [ PN 3pl ],
                            RELS <! reg_diadic_nom_relation !> ] ],
	     MODIFD notmod,
             LKEYS.KEYREL.ARG1 #index ] ].

; 'bunch', 'lot', 'number'
n_group_ppof_le := amalg_word & basic_noun_word &
  [ SYNSEM unsp_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.KEYS.KEY norm_nom_rel,
                           VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY _a_q_rel ] >,
                                 COMPS < [ LOCAL.CONT.HOOK.INDEX #ind ] > ] ],
                     AGR [ DIVISIBLE -,
                           PNG.PN 3pl ],
                     CONT.RELS <! reg_diadic_nom_relation !> ],
	     MODIFD notmod,
             LKEYS [ KEYREL.ARG1 #ind,
                     --COMPKEY _of_p_sel_rel ] ] ].

n_part_lexent := amalg_word & basic_noun_word &
  [ SYNSEM partitive_noun_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CAT.HEAD adv &
                                           [ KEYS.KEY just_only_deg_rel ] ] >,
                     CONT [ RELS.LIST < #keyrel, #altkey, ... >,
                            HCONS <! qeq !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkey ],
             NONLOC [ SLASH 0-dlist,
                         QUE 0-dlist ] ] ].

n_part_ppof_agr_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_agr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !>,
             LKEYS.ALTKEYREL.PRED explicit_quant_agr_q_rel ] ].

n_part_ppof_noagr_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_noagr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !> ] ].

n_part_ppof_noagr_pl_le := n_part_lexent &
  [ SYNSEM partitive_noun_ppof_noagr_synsem &
           [ LOCAL [ CONT.RELS <! relation, relation !>,
                     AGR.PNG.PN 3pl ] ] ].

n_part_npcomp_agr_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_agr_synsem ].

n_part_npcomp_noagr_le := n_part_lexent &
  [ SYNSEM partitive_noun_np_noagr_synsem ].

n_part_nocomp_le := n_part_lexent &
  [ SYNSEM partitive_noun_nocomp_synsem &
           [ LOCAL [ CAT.VAL.COMPS < >,
                     CONT.RELS <! #key, relation !> ],
             MODIFD notmod,
             LKEYS.KEYREL #key ] ].

; pleasure
n_vpcomp_expl_le := noun_word &
  [ SYNSEM common_noun_vpcomp_expl_synsem ].

n_vpcomp_slash_le := noun_word &
  [ SYNSEM common_noun_vpcomp_slash_synsem ].


;;
;; Lexical NPs
;;
;;   (proper names, pronouns, names of weekdays, ...)

basic_np_synsem := ref_synsem &
  [ LOCAL.CAT [ HEAD noun,
                VAL.SUBJ < > ] ].

basic_np_word := basic_no_affix & hc-to-phr & basic_noun_word &
  [ SYNSEM basic_np_synsem ].

basic_non_affixed_np := basic_no_affix & hc-to-phr & nonque & nonmsg & 
                  basic_noun_word &
  [ SYNSEM.MODIFD notmod ].

non_affixed_np := basic_non_affixed_np &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

np_word := basic_np_word & basic_non_affixed_np &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < > ].

np_synsem := noun_synsem & nomod_synsem.

basic_np_sing_synsem := basic_np_synsem &
  [ LOCAL.CONT [ RELS.LIST < nom_relation &
                             [ PRED basic_nom_rel,
                               ARG0 #ind ],
                             [ PRED quant_rel,
                               ARG0 #ind,
                               RSTR #rhand ], ... >,
                 HCONS <! qeq & [ HARG #rhand,
                                  LARG #keyhand ] !> ],
    LKEYS.KEYREL.LBL #keyhand ].

basic_np_sing_word := basic_np_word &
  [ SYNSEM basic_np_sing_synsem ].

np_sing_synsem := basic_np_sing_synsem & np_synsem &
  [ LOCAL [ CAT.VAL [ SPR < >,
                      COMPS < > ],
            CONT.RELS <! relation, [ PRED proper_q_rel ] !> ],
    MODIFD notmod ].

np_sing_word := basic_np_sing_word & nonque & nonmsg &
  [ SYNSEM np_sing_synsem ].

; DPF 10-Apr-02 - Changed ALTKEY from basic_nom_rel to implicit_q_rel so
; proper names can form compounds like in "the Kim Browne story"

; DPF 15-May-02 - Changed proper names so they now inflect, allowing plural
; forms as in "they hired two Chiangs"
; DPF 5-Sep-03 - Changed ALTKEY from implicit_q_rel to proper_q_rel to
; block compound "the Browne hired Chiang".  Later changed.
; DPF 7-may-04 - Removed nonque supertype, since we want to allow e.g.
; "which Elvis did you see"
; DPF 24-aug-04 - Added RPERIPH + to enable blocking of red-rel analysis
; of "Abrams hired" while still allowing "people hired"

basic_n_proper_lexent := basic_nonltop_word & basic_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD notmod & [ RPERIPH + ],
             LOCAL [ CAT [ HEAD.KEYS [ KEY named_np_rel,
                                       ALTKEY quant_or_wh_rel ],
                           VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                      quant_or_wh_rel,
                                         NONLOC.QUE #que ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #index ],
                            RELS <! relation !>,
                            HCONS <! !> ],
                     AGR #index ],
             NONLOC.QUE #que,
             LKEYS [ KEYREL named_nom_relation &
                            [ PRED named_rel,
                              LBL #ltop ],
                     ALTKEYREL.PRED implicit_q_rel ] ],
    INFLECTD - ].

; Distinguish ordinary proper names like "Kim" from city proper names like
; "Paris", which allow a following comma as in "Paris, France".
n_proper_lexent := basic_n_proper_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY named_rel ].

; KEY allows specialization to named_rel ('Kim') or named_city_rel ('Paris')
; to enable correct treatment of commas: '*Kim, Abrams' but 'Paris, France'
n_proper_city_le := basic_n_proper_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY named_np_rel ].

; DPF 26-Mar-01 - Added MODIFD.LPERIPH + to prevent (restrictive) post-nom
; modifiers of bare proper names, as in "*Abrams by Browne arrived." though
; this will also block "Abrams from New York just called".  Not clear what
; the contrast is due to.
; DPF 1-Jun-02 - But this was too strong, so relaxed the reduced-rel rule
; but keep this constraint here, since it still serves to prevent proper names
; from appearing as heads of n-n compounds, blocking "interview Sandy"

n_proper_le := n_proper_lexent &
  [ SYNSEM.MODIFD.LPERIPH + ].
n_proper_fem_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.GEN fem ].
n_proper_masc_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.GEN masc ].
; For "i", which we don't want as plural "is"
n_proper_sg_le := n_proper_lexent &
  [ SYNSEM.LOCAL.AGR.PNG.PN 3sg ].

n_proper_unk_le := n_proper_lexent &
  [ SYNSEM.MODIFD.LPERIPH + ].

proper_n_synsem := np_sing_synsem &
  [ LOCAL [ CAT.HEAD.KEYS.KEY gen_named_rel,
            CONT.HOOK.INDEX.PNG png & [ PN 3sg ] ],
    LKEYS.KEYREL.PRED gen_named_rel ].

; Add ALTKEY to block these in left position of noun-noun compounds
n_proper_abb_le := np_sing_word & 
  [ SYNSEM proper_n_synsem &
           [ LOCAL.CAT.HEAD.KEYS [ KEY named_abb_rel,
                                   ALTKEY pron_rel ],
             LKEYS [ KEYREL.PRED named_abb_rel,
                     ALTKEYREL.PRED pron_rel ] ] ].

; "here, there" as in "get out of here/there" 
; Make SYNSEM pronominal_synsem to block N-N cmpnds like "the there meeting"
; Added PRD + so appositives with left member np_adv won't join in N-N-cmpnds.
; DPF 23-Oct-00 - Since pronominal_synsem no longer constrains left member of
; noun-noun compounds, use alternate hack of making ALTKEY not unify with
; the [ALTKEY no_rel] constraint in the n-n-cmpnd rule.

np_adv_synsem := basic_np_sing_synsem & pronominal_synsem &
  [ LOCAL [ CAT.HEAD.KEYS [ KEY #keypred,
                            ALTKEY def_explicit_q_rel,
                            ALT2KEY never_unify_rel ],
            CONT.HOOK.LTOP #ltop ],
    LKEYS [ KEYREL [ LBL #ltop,
                     PRED #keypred ],
            ALTKEYREL relation,
            ALT2KEYREL relation ] ].

basic_np_adv_word := basic_np_sing_word & nonmsg &
  [ SYNSEM np_adv_synsem &
	   [ LOCAL [ CONT [ HOOK.INDEX #ind & [ PNG png & [ PN 3sg ] ],
                            RELS.LIST < relation, #altkey, ... > ],
		     AGR #ind ],
             LKEYS.ALTKEYREL #altkey ] ].

basic_np_adv_nonwh_word := basic_np_adv_word & nonque &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
	     LKEYS.ALTKEYREL.LBL #ltop ] ].

basic_np_adv_lexent := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
		     CONT.RELS <! relation & [ LBL #hand,
					       ARG0 #inst ], 
				[ PRED def_q_rel ],
				#alt2key & [ LBL #hand,
					     ARG1 #inst ] !> ],
	     LKEYS.ALT2KEYREL #alt2key ] ].

; 6-jun-04 - Changed SPR..HEAD from adv to n_or_adv to allow measure NPs
; as specifiers, as in "two weeks early"
np_adv_lexent := basic_np_adv_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < [ LOCAL [ CAT.HEAD n_or_adv,
					   CONT.HOOK [ LTOP #ltop,
						       XARG #arg0 ] ],
				   NONLOC.QUE #que ] >,
	     NONLOC.QUE #que,
	     LKEYS.ALT2KEYREL [ LBL #ltop,
                                ARG0 #arg0 ] ] ].

norm_np_adv_lexent := np_adv_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                           just_only_very_deg_rel ] > ].

n_adv_pl_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY place_rel,
                   CONT.HOOK.INDEX.SORT place ] ].

n_adv_pl_nonprd_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD [ KEYS.KEY place_rel,
                              PRD - ],
                   CONT.HOOK.INDEX.SORT place ] ].

n_adv_tm_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY time_rel,
                   CONT.HOOK.INDEX.SORT time ] ].

; e.g. 'early', which allows "too/so early", unlike 'now', 'then'
n_adv_tm_unsp_le := np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY time_rel,
                   CONT.HOOK.INDEX.SORT time ] ].

n_adv_event_lexent := norm_np_adv_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY place_rel,
             LKEYS.ALT2KEYREL.ARG0 [ E [ TENSE no_tense,
                                         ASPECT no_aspect ],
                                     SORT place ] ] ].

n_adv_event_le := n_adv_event_lexent.

; 'there'
n_adv_acc_le := norm_np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD [ CASE acc,
                              KEYS.KEY place_rel ],
                   CONT.HOOK.INDEX.SORT place ] ].

; 'north' etc, which take degree specifiers like "far" or "ten miles",
; and an optional of-PP complement.
n_adv_dir_le := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY place_rel,
                           VAL [ SPR < [ LOCAL [ CAT.HEAD n_or_adv &
                                                     [ KEYS.KEY much_deg_rel ],
                                                 CONT.HOOK [ LTOP #ltop,
                                                             XARG #arg0 ] ],
                                         NONLOC.QUE #que ] >,
                                 COMPS < expressed_synsem &
                                         [ LOCAL local_min &
                                           [ CAT [ HEAD prep & 
                                                    [ PRD -,
                                                      KEYS.KEY _of_p_sel_rel ],
                                                   VAL.COMPS < > ],
                                             CONT.HOOK [ LTOP #hand,
                                                         INDEX #ppind ] ],
                                           NONLOC.SLASH #slash,
                                           PUNCT.LPUNCT no_punct ] > ] ],
                     CONT [ HOOK.INDEX.SORT place,
                            RELS <! relation & [ LBL #hand,
                                                 ARG0 #inst ], 
                                  [ PRED def_q_rel ],
                                  #alt2key & [ LBL #hand,
                                               ARG1 #inst ] !> ] ],
             NONLOC [ SLASH #slash,
                      QUE #que ],
             LKEYS.ALT2KEYREL #alt2key &
                              [ LBL #ltop,
                                ARG0 #arg0,
                                ARG2 #ppind ] ] ].

; 'then' -- to block "then Kim left" as N+RelClause.  Hack, since this
; also blocks "right then".
; [ACTIVATED -] prevents "then" from being topicalized, to avoid filler-head
; reading for "then kim arrived"
n_adv_nospr_le := basic_np_adv_lexent & nonque &
  [ SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY time_rel,
                         VAL.SPR < > ],
                   CONT.HOOK.INDEX.SORT time,
                   CTXT.ACTIVATED - ] ].

; 'long' as in 'Kim stayed for too long', 'Kim stayed too long', and
; 'it took too long to finish'

basic_n_adv_gradable_lexent := np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY time_rel,
                           VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                          degree_rel ] > ],
                     CONT.HOOK [ LTOP #lbl,
                                 INDEX.SORT time,
                                 XARG #ind ] ],
             LKEYS.KEYREL [ LBL #lbl,
                            ARG0 #ind ] ] ].

n_adv_gradable_lexent := basic_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD grad_n ].

n_adv_gradable_le := n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY very_deg_rel ] > ].

; longer
n_adv_gradable_comp_le := n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY much_deg_rel ] > ].

; soon
; DPF 07-may-04 - Added HEAD noun_nom as hack to prevent e.g. 'until soon'
n_adv_gradable_nom_le := basic_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD noun & [ CASE nom ],
                       VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY very_deg_rel ] > ]].
;sooner
n_adv_gradable_nom_comp_le := basic_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD noun & [ CASE nom ],
                       VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY much_deg_rel ] > ]].

; 'awhile'
; DPF 4-Apr-01 - Made ALTKEY be def_explicit_q_rel to block these guys as left 
; members of compounds as in "*the there books"
; DPF 11-Mar-02 - Changed SPR from anti_synsem_min to [KEY just_only_very_deg_rel]
; to allow "kim arrived just yesterday".
; DPF 04-Feb-03 - Can't make this [PRD -] because hadj rule now wants [PRD +]
; adjunct, but this means we overgenerate "the event awhile" since there's no
; way to say that "awhile" once turned into a modifier doesn't want to modify
; a nominal phrase.

n_adv_simp_acc_le := basic_np_adv_nonwh_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ CASE acc,
                                  KEYS.KEY time_rel ],
                           VAL [ SPR < [ LOCAL [ CAT.HEAD adv & 
						  [ KEYS.KEY 
                                                    just_only_very_deg_rel ],
						 CONT.HOOK.XARG #arg0 ] ]>,
				 COMPS < > ] ],
                     CONT [ HOOK.INDEX.SORT time,
                            RELS <! relation, relation !> ] ],
             LKEYS.ALTKEYREL [ PRED def_explicit_q_rel,
			       ARG0 #arg0 ] ] ].

; later (in the day)
n_comp_adv_le := basic_np_adv_nonwh_word &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR < [ LOCAL [ CAT.HEAD n_or_adv &
                                                [ KEYS.KEY 
						  just_only_very_deg_rel ],
                                               CONT.HOOK.XARG #arg0 ] ] >,
                               COMPS < synsem & 
                                       [ OPT +,
                                         LOCAL [ CAT basic_pp_cat,
                                                 CONT.HOOK [ LTOP #ltop,
                                                             INDEX #ind ],
                                                 CONJ cnil ],
                                         NONLOC.SLASH 0-dlist ] > ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #ind ],
                            RELS <! [ LBL #hand, 
                                      PRED modable_rel,
                                      ARG0 #inst ],
                                  [ PRED def_explicit_q_rel ],
                                  arg1_relation & #alt2key &
                                  [ LBL #hand,
				    ARG0 #arg0 &
					[ E [ TENSE no_tense,
					      ASPECT no_aspect ] ],
				    ARG1 #inst ],
                                  [ LBL #hand,
                                    PRED comp_rel,
                                    ARG1 #inst ] !> ] ],
             LKEYS.ALT2KEYREL #alt2key ] ].

; DPF 27-Apr-00 - Added [CASE acc] to block spurious parse for "where is kim"
; DPF 19-Oct-02 - But this unfortunately also blocks "when would be a good 
; time to meet", and besides, "where would be a good place to meet" is okay.
; DPF 9-Jun-03 - Still, what's worse? extra parses for "where does kim work?"
; or no parse for "where would please sandy"?  Maybe we treat the latter as
; the result of robust parsing with relaxation of the CASE constraint, and
; exclude it as strictly grammatical (and likewise for "when would be a good
; time?").

n_wh_adv_lexent := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.CASE acc,
                           VAL [ SPR < anti_synsem_min >,
                                 COMPS 
                                   < [ OPT +,
                                       LOCAL [ CAT.HEAD wh_adv &
                                                [ KEYS.KEY wh_the_hell_rel ],
                                               CONJ cnil  ],
                                       NONLOC.SLASH 0-dlist ] > ] ],
                     CONT.RELS <! relation, [ PRED which_q_rel ] !> ],
             NONLOC.QUE 1-dlist &
		         [ LIST < handle > ] ] ].

n_wh_adv_pl_le := n_wh_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY place_rel,
                   CONT.HOOK.INDEX.SORT place ] ].

n_wh_adv_tm_le := n_wh_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY time_rel,
                   CONT.HOOK.INDEX.SORT time ] ].

n_wh_adv_whither_le := n_wh_adv_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY place_rel,
                   CONT.HOOK.INDEX.SORT place ] ].


; Lexical NP plurals - maybe only in British English? ("IBM are hiring again.")
;
np_pl_word := np_word &
  [ SYNSEM np_synsem &
	   [ LOCAL.CAT.VAL.COMPS < >,
             --SIND.PNG png & [ PN 3pl ] ] ].

; DPF 25-May-03 - Added MOD..LTOP so "o'clock" and "fifteen" can both be
; combined with hour-words the same way, by getting at the MOD..LTOP value
; of the complement phrase (necessary since intersective adjectives do not
; lexically bind their LTOP to their key's LBL).
np_ersatz_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < anti_synsem_min & 
                               [ LOCAL.CONT.HOOK.LTOP #hand ] >,
                         KEYS.ALTKEY no_rel ],
                  VAL [ SPR < >,
			SUBJ < >,
			COMPS < >,
                        SPEC < > ] ],
	    CONT nom-obj &
		[ HOOK.LTOP #hand,
		  RELS.LIST < #key, ... >,
		  HCONS <! !> ] ],
    MODIFD.LPERIPH -,
    LKEYS.KEYREL #key & [ LBL #hand ] ].

np_word_no_quant := non_affixed_np &
  [ SYNSEM np_ersatz_synsem ].

ref_pro_np_synsem := basic_np_synsem & ref_pro_synsem.

; DPF 19-dec-04 - Added non-empty specifier to allow restrictive relatives 
; with pronouns: "He who saves...", "you who have...", and "that which you
; did will be rewarded".
pers_pro_synsem := ref_pro_np_synsem &
  [ LOCAL.CAT.VAL.SPR < anti_synsem_min > ].

; For 'them all' as in 'we read them all', but not "*they hired me all"

pro_wcomps_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL.COMPS 
                    < [ LOCAL.CAT [ HEAD partn &
                                    [ KEYS.ALTKEY both_all_q_rel ],
                                    VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                                          COMPS < unexpressed &
                                                  [ LOCAL [ CAT nomp_cat_min,
                                                            AGR #ind ],
                                                    --SIND #ind ] > ] ],
                        OPT +,
                        LEX +,
                        PUNCT.LPUNCT no_punct ] >,
            CONT.HOOK.INDEX #ind ] ].

basic_personal_pro := basic_np_word & basic_pronoun_word & 
                      basic_non_affixed_np &
  [ SYNSEM pers_pro_synsem &
	   [ LOCAL.CONT [ HOOK.XARG #prohand,
                          RELS <! [ LBL #prohand,
                                    PRED pron_rel,
                                    ARG0 #inst ],
                                  #altkeyrel &
                                  [ PRED pronoun_q_rel,
                                    RSTR #rhand,
                                    ARG0 #inst ] !>,
                          HCONS <! qeq & [ HARG #rhand,
                                           LARG #prohand ] !> ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

personal_pro := basic_personal_pro &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

n_pers_pro_noagr_le := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE nom,
                                KEYS.KEY pron_rel ],
                     AGR.PNG png & [ PN 3pl ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3sg,
                                             GEN andro ],
                                 SORT entity,
                                 PRONTYPE std_pron ] ] ].

basic_n_pers_pro_lexent := basic_personal_pro & 
  [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY pron_rel,
                   AGR #agr,
		   CONT.HOOK.INDEX #agr &
			        [ PRONTYPE std_pron ] ] ].

n_pers_pro_lexent := basic_n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT.HOOK.INDEX.SORT entity ] ].

n_pers_pro_he_le := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.CASE nom,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3sg,
                                             GEN masc ],
                                 PRONTYPE std_pron ] ] ].

n_pers_pro_she_le := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.CASE nom,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3sg,
                                             GEN fem ],
                                 PRONTYPE std_pron ] ] ].

n_pers_pro_her_le := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.CASE acc,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3sg,
                                             GEN fem ],
                                 PRONTYPE std_pron ] ] ].

n_pers_pro_him_le := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.CASE acc,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3sg,
                                             GEN masc ],
                                 PRONTYPE std_pron ] ] ].

n_pers_pro_i_le := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.CASE nom,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1sg ],
                                 PRONTYPE std_pron ] ] ].

n_pers_pro_me_le := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.CASE acc,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1sg ],
                                 PRONTYPE std_pron ] ] ].

; 'yours truly'
n_pers_pro_1sg_noagr_le := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD.KEYS.KEY pron_rel,
                     AGR.PNG png & [ PN 3sg ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1sg ],
                                 PRONTYPE std_pron ] ] ].

n_pers_pro_one_another_le := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.CASE acc,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3sg,
                                           GEN andro1 ] ] ].

; DPF 7-Dec-02 - ACTIVATED is here experimentally, and at present only prevents
; "it" from being topicalized as in "*It I like".

n_pers_pro_it_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.ALTKEY _all_q_rel]>,
                     CTXT.ACTIVATED - ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3sg,
                                             GEN neut ],
                                 PRONTYPE std_pron ] ] ].

n_pers_pro_them_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL.CAT.HEAD.CASE acc,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3pl ],
                                 PRONTYPE std_pron ] ] ].

n_pers_pro_they_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL.CAT.HEAD.CASE nom,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3pl ],
                                 PRONTYPE std_pron ] ] ].

n_pers_pro_us_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.HEAD.CASE acc,
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1pl ],
                                 PRONTYPE std_pron ] ] ].
            


n_pers_pro_we_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.HEAD.CASE nom,
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1pl ],
                                 PRONTYPE std_pron ] ] ].


n_pers_pro_you_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL.CONT.HOOK.INDEX.SORT entity,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2per ],
                                 PRONTYPE std_pron ] ] ].


n_pers_pro_thou_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.HEAD.CASE nom,
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2per ],
                                 PRONTYPE std_pron ] ] ].


n_pers_pro_thee_le := basic_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.HEAD.CASE acc,
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2per ],
                                 PRONTYPE std_pron ] ] ].


n_refl_pro_lexent := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE acc,
                                KEYS.KEY refl_pron_rel ],
                     AGR #agr,
                     CONT.HOOK.INDEX #agr ],
             LKEYS.KEYREL [ PRED pron_rel,
                            ARG0 [ PRONTYPE refl,
                                   SORT entity ] ] ] ].

n_refl_pro_herself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3sg,
                                         GEN fem ] ].
n_refl_pro_himself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3sg,
                                         GEN masc ] ].
n_refl_pro_itself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3sg,
                                         GEN neut ] ].
n_refl_pro_myself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 1sg ] ].
n_refl_pro_ourselves_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 1pl ] ].
n_refl_pro_themselves_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3pl ] ].
n_refl_pro_yourself_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 2sg ] ].
n_refl_pro_yourselves_le := n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 2pl ] ].

n_recip_pro_le := np_word &
  [ SYNSEM ref_pro_np_synsem &
	   [ LOCAL [ CAT [ HEAD [ CASE acc,
                                  KEYS.KEY recip_pro_rel ],
                           VAL.COMPS < > ],
                     AGR #ind,
                     CONT [ HOOK.INDEX #ind,
			    RELS <! [ LBL #prohand,
                                      PRED recip_pro_rel,
                                      ARG0.PRONTYPE recip ],
                                    [ PRED pronoun_q_rel,
                                      ARG0 #ind,
                                      RSTR #rhand ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !> ] ],
             LKEYS.KEYREL.ARG0.PNG png & [ PN non1sg ] ] ].

; 'yours'
; DPF 15-Apr-00 = Changed KEY to be pron_rel rather than pronoun_q_rel, since
; e.g. prepositions want a non_temp_nom_rel as their argument.

n_poss_pro_lexent := basic_no_affix & nonmsg & hc-to-phr & 
                     basic_pronoun_word &
  [ SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD noun & [ KEYS [ KEY pron_rel,
                                                ALTKEY basic_poss_rel ] ],
                           VAL [ SPR < >,
				 COMPS < >,
				 SPEC < anti_synsem_min > ] ],
                     AGR #index,
		     CONT [ HOOK.INDEX #index,
			    RELS <! #key & 
				     [ LBL #prohand,
                                       PRED pron_rel,
                                       ARG0 #eind &
                                           [ PRONTYPE std_pron,
                                             SORT entity ] ],
                                     [ PRED pronoun_q_rel,
                                       ARG0 #eind,
				       RSTR #rhand ],
				     [ PRED def_q_rel,
                                       ARG0 #index,
				       RSTR #phand ],
                                     nom_relation &
                                     [ LBL #nhand,
                                       PRED generic_nom_rel,
                                       ARG0 #index ],
                                     #altkey & prep_relation &
				     [ LBL #nhand,
                                       PRED basic_poss_rel,
                                       ARG0.E [ TENSE no_tense,
                                                ASPECT no_aspect ],
				       ARG1 #eind,
				       ARG2 #index ] !>,
			    HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ],
                                      qeq & [ HARG #phand,
                                              LARG #nhand ] !> ] ],
             LKEYS [ KEYREL #key,
                     ALTKEYREL #altkey ],
             NONLOC.QUE <! !>,
	     MODIFD notmod ] ].

n_poss_pro_hers_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3sg,
                                                        GEN fem ] ].
n_poss_pro_his_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3sg,
							GEN masc ] ].
n_poss_pro_its_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3sg,
							GEN neut ] ].
n_poss_pro_mine_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1sg ] ].
n_poss_pro_ours_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1pl ] ].
n_poss_pro_theirs_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3pl ] ].
n_poss_pro_yours_le := n_poss_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 2per ] ].

; Expletive pronouns "there" and "it"
; DPF 3-Jul-02 - Changed KEY from no_rel to pron_rel, to allow simpler
; generalization about subjects of tag-phrases.  Still have empty RELS

n_expl_it_le := no_affix_np & basic_pronoun_word &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ CAT.HEAD.KEYS.KEY pron_rel,
                     CONT [ HOOK.INDEX it-ind,
                            RELS <! !> ] ],
             LKEYS.KEYREL.PRED pron_rel,
	     MODIFD notmod ] ].

n_expl_there_le := no_affix_np & basic_pronoun_word &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ CAT.HEAD.KEYS.KEY pron_rel,
                     CONT [ HOOK.INDEX there-ind,
                            RELS <! !> ] ],
             LKEYS.KEYREL.PRED pron_rel,
	     MODIFD notmod ] ].
			  

; ERB (31-10-96) A hack:  I want the wh_interrogs to be able to
; get their hands on the which_q_rel so they can put it on the PARAMS
; list, but QSTORE isn't working yet.  So I am making the QUE value
; of wh_pro_word, wh_adverb_word, and wh_poss_word be the handle of
; the which_q_rel, so that this gets passed up in such a way that I can see it.

; DPF (3-May-99) We can't just put the handle of the which_q_rel in QUE, since
; in coordinate structures like "which book and which record did sandy buy?"
; we want to unify the NONLOCs of "which book" and "which record", but this
; would mean that the handles of the two which_q_rel's would be wrongly 
; identified. 
; So for now I'm just putting in an unbound handle - we'll have to sort out
; with Ivan what the right solution is.

; who, what

n_wh_pro_lexent := que_word & basic_pronoun_word &
  [ SYNSEM ref_pro_synsem &
	 [ LOCAL [ CAT [ HEAD.KEYS.KEY norm_nom_rel,
                         VAL [ SPR < >,
                               COMPS < [ OPT +,
                                         LOCAL [ CAT.HEAD wh_adv &
                                                [ KEYS.KEY wh_the_hell_rel ],
                                                 CONJ cnil ],
                                         PUNCT.LPUNCT no_punct ] > ] ],
                   AGR #index,
                   CONT [ HOOK [ INDEX #index & [ PNG png & [ PN 3sg ] ],
                                 XARG #nhand ],
                          RELS <! [ LBL #nhand ],
                                  [ PRED which_q_rel,
                                    ARG0 #index,
                                    RSTR #rhand ] !>,
			  HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !> ] ],
	   NONLOC.QUE 1-dlist &
		         [ LIST < handle > ],
	   MODIFD notmod ] ].

n_wh_pro_le :< n_wh_pro_lexent.
n_wh_pro_acc_le := n_wh_pro_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE acc ].

basic_n_rel_pro_lexent := rel_word & basic_pronoun_word & 
  [ SYNSEM pronominal_synsem &
	 [ LOCAL [ CAT [ HEAD [ MOD < >,
                                KEYS [ KEY non_temp_nonpro_rel,
                                       ALTKEY norm_rel ] ],
			 VAL [ SUBJ < >,
			       COMPS < > ] ],
                   AGR #index,
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index,
                                 XARG #xarg ],
			  RELS <! !>,
			  HCONS <! !> ] ],
           LKEYS [ KEYREL.PRED non_temp_nom_rel,
                   ALTKEYREL relation ],
           NONLOC.REL 1-dlist &
		         [ LIST < [ LTOP #hand,
				    INDEX #index,
                                    XARG #xarg ] > ] ] ].

n_rel_pro_lexent := basic_n_rel_pro_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < > ].

n_rel_pro_who_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD.KEYS.KEY norm_nom_rel,
                     CONT.HOOK.INDEX.SORT human ],
             LKEYS.KEYREL.PRED reg_nom_rel ] ].

n_rel_pro_what_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD.KEYS.KEY norm_nom_rel,
                     CONT.HOOK.INDEX.SORT nominal-sort ],
             LKEYS.KEYREL.PRED reg_nom_rel ] ].

; Not notmod to let us get "the day that I arrived"/"*the day which i arrived"

n_rel_pro_acc_le := n_rel_pro_lexent &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD [ CASE acc,
                                KEYS.KEY norm_nom_rel ],
                     CONT.HOOK.INDEX.SORT human ],
             LKEYS.KEYREL.PRED reg_nom_rel ] ].

; Unmarked for MODIFD, so can undergo temp_np rule to get "the day that I
; arrived"  But to get this, also need to make SPR be non-empty, since the
; extracted-adj-temp rule only allows n-bar slashed elements.
; DPF 19-dec-03 - In fact, need two entries for 'that', since we want to
; allow "the place that Kim stood" but not "*the car that Kim stood" (cf
; "the car where Kim stood".  The one entry is the nbar-filler for the gap
; for the npadv.

n_rel_pro_nonwh_lexent := basic_n_rel_pro_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.PRD -,
                     CONT.HOOK.INDEX.SORT nominal-sort ],
             LKEYS.KEYREL.PRED non_temp_nonpro_rel ] ].

n_rel_pro_nonwh_le := n_rel_pro_nonwh_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < > ].

; DPF 2-apr-05 - Removed AGR.DIVISIBLE - since this blocks "on the days that
; we perform"
n_rel_pro_npadv_le := n_rel_pro_nonwh_lexent &
  [ SYNSEM [ LOCAL.CAT nbar_cat_min & [ HEAD.KEYS [ KEY modable_nom_rel,
                                                    ALT2KEY modable_rel ],
                                        VAL.SPR < unexpressed > ],
             MODIFD.LPERIPH + ] ].

; DPF 28-Aug-99 - SPR..KEY no_rel prevents these from undergoing bare_np rule
; DPF 09-Jan-00 - In fact, can now eliminate bogus SPR, since picking up
; post-head adjuncts as complements.
; DPF 06-May-03 - Removed COMPS..HEAD adj* restriction, since we need to have
; these guys pick up post-head PPs as complements so "anytime after three"
; can still be compatible with the npadv_mod rule's requirement that the dtr
; be [HODIFIED lmod], in order to get the desired analysis for "Kim arrived
; sometime after three".
; DPF 03-Dec-03 - But now getting posthead PPs as modifiers, so go back to
; only allowing adjectival complements.

generic_pro_adv_word := que_word & basic_pronoun_word &
  [ SYNSEM np_synsem &
     [ LOCAL 
        [ CAT [ HEAD #head & 
                     [ KEYS [ ALTKEY nondef_explicit_q_rel ] ],
                VAL [ SPR < [ LOCAL local_min &
                                    [ CAT.HEAD.KEYS.KEY degree_rel,
                                      CONT.HOOK [ LTOP #khand,
                                                  XARG #inst ] ],
                              NONLOC [ QUE 0-dlist,
                                          REL 0-dlist ],
                              OPT + ] >,
                      COMPS < [ OPT +,
                                LOCAL 
                                 [ CAT prd_cat & 
                                       [ HEAD v_or_a &
                                         [ MOD < [ LOCAL.CAT.HEAD #head ] > ]],
                                   CONJ cnil,
                                   CONT.HOOK [ LTOP #nhand,
                                               XARG #inst ] ],
                                NONLOC non-local_none,
                                PUNCT.LPUNCT no_punct ] > ] ],
          CONT [ HOOK [ LTOP #nhand,
			XARG #nhand ],
                 RELS <! [ PRED basic_nom_rel ],
                       #altkey & [ PRED quant_rel ] !>,
                 HCONS <! qeq &
                        [ HARG #rhand,
                          LARG #nhand ] !> ] ],
       LKEYS [ KEYREL [ LBL #nhand,
                        ARG0 #inst & [ PNG png & [ PN 3sg ] ] ],
               ALTKEYREL #altkey & 
                      [ LBL #khand,
                        ARG0 #inst,
                        RSTR #rhand ] ],
       NONLOC.QUE 0-dlist ] ].

n_generic_pro_adv_le := generic_pro_adv_word &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY modable_rel ].

n_generic_pro_lexent := generic_pro_adv_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.SORT entity,
             MODIFD notmod ] ].

n_generic_pro_le := n_generic_pro_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel ].
                     
; 'one'
; DPF 23-sept-04 - Curious note: If we don't make COMPS < anti_synsem_min >,
; then we get an asymmetry in how PET and the LKB process "one should": PET
; allows "one" to undergo hoptcomp rule in addition to noptcomp rule, even
; though hoptcomp says head is KEY event_rel while 'one' says KEY is not
; (obviously) a subtype of event_rel.  FIX...
n_generic_pro_jspr_le := n_generic_pro_lexent &
  [ SYNSEM.LOCAL 
           [ CAT [ HEAD.KEYS.KEY norm_nom_rel,
                   VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY just_only_deg_rel ] >,
                         COMPS < anti_synsem_min > ] ],
             CONT.HOOK.INDEX.PNG.GEN andro ] ].

n_deictic_pro_lexent := no_affix_np & basic_pronoun_word &
  [ SYNSEM ref_pro_synsem &
	   [ LOCAL [ CAT [ HEAD.KEYS [ KEY generic_nom_rel,
                                       ALTKEY demonstrative_q_rel,
                                       ALT2KEY norm_rel ],
                           VAL [ SPR < [ LOCAL local_min &
                                         [ CAT.HEAD.KEYS.KEY just_only_deg_rel,
                                           CONT.HOOK [ LTOP #khand,
                                                       XARG #pred ] ],
                                         NONLOC [ QUE 0-dlist,
                                                     REL 0-dlist ],
                                         OPT + ] >,
                                 COMPS < > ] ],
		     CONT [ HOOK [ LTOP #nhand,
                                   INDEX #index,
				   XARG #nhand ],
			    RELS <! [ LBL #nhand,
				      PRED generic_nom_rel & #pred ], 
				     #altkey &
				     [ LBL #khand,
                                       PRED demonstrative_q_rel,
                                       ARG0 #ind,
				       RSTR #rhand ] !>,
			    HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #hand ] !> ],
		     AGR #index ],
             LKEYS [ KEYREL [ LBL #hand,
                              ARG0 #ind ],
                     ALTKEYREL #altkey ],
	     MODIFD notmod ] ].

; DPF 16-oct-03 - Added ALT2KEY norm_rel to prevent singular deictics from
; being modified, to get contrast of "*that he bought yesterday arrived" vs
; "those he bought yesterday arrived".
; DPF 19-dec-04 - But this also rules out relative clauses with "which", as
; in 'that which you need will be provided'.  Not clear how to exclude the
; thatless-relatives for singular deictics: odd constraint.  For now, remove
; the old constraint, and overgenerate the first example above.

n_deictic_pro_sg_le := n_deictic_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3sg,
                                         GEN neut ] ].

n_deictic_pro_pl_le := n_deictic_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3pl ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsems for Auxiliary verb lexical rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ERB (05-10-97) Making this specific to question auxes.  See notes near sai
; in syntax.tdl.
; DPF 26-Jan-01 - Changed HEAD.INV + to HEAD.INV +* to allow for coordination
; of inverted and non-inverted sentences.  Prevent yes-no question rule from
; applying to main verbs by making inverted auxiliaries [MC na], so they have
; to undergo the yes-no rule.
; ERB (2003-10-13) Need a supertype to allow mal_sai_synsem: making
; basic_sai_synsem.

basic_sai_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD verb & [ INV +,
                                PRD -,
                                MOD < [ LOCAL intersective_mod &
                                              [ CAT [ HEAD.KEYS.KEY no_rel,
                                                      VAL.SPR *cons* ] ] ] >,
                                TAM ind_or_mod_subj_tam ],
                  VAL.COMPS #comps & < [ NONLOC.SLASH 0-dlist ], ... >,
                  POSTHD +,
		  MC na ],
            CONT.MSG no_msg,
	    ARG-S #comps ] ].

sai_synsem := basic_sai_synsem &
  [ LOCAL.CAT.HEAD.AUX + ].

; DPF 3-Jul-02 Changed to COMPS..KEY pron_rel from COMPS..ALTKEY no_rel,
; since common nouns are often unmarked for ALTKEY, and it was a hack.
; DPF 19-Oct-02 - Were using hack of SPEC < > to keep poss-pronouns like
; "mine" out of COMPS, but this also blocked "than mine", so instead use
; difference in ALTKEY for "she" and "hers".
; DPF 9-Feb-03 Changed HEAD value from 'verb' to 'tagaux' so bare tag
; questions don't show up as root clauses (we can't just make them MC -,
; since the MC of a head-mod phrase comes from the modifier daughter).

tag_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD tagaux &
		       [ AUX -,
			 INV -,
			 TAM ind_or_mod_subj_tam & [ TENSE #tense ],
			 MOD < [ LOCAL scopal_mod &
				       [ CAT s_cat_fin &
					     [ HEAD [ TAM.TENSE #tense,
                                                      KEYS.KEY #key ],
                                               MC + ],
					 AGR.PNG #png & png,
					 CONT [ HOOK [ LTOP #modhand,
                                                       INDEX #ind &
                                                        [ E.TENSE real_tense]],
                                                MSG #presup & 
						 [ PRED propositional_m_rel]]],
                                 NONLOC [ SLASH 0-dlist,
					     REL 0-dlist,
					     QUE 0-dlist ],
                                 PUNCT.RPUNCT no_punct ] >,
                         KEYS.KEY #key ],
		  POSTHD +,
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < [ OPT -,
				  LOCAL [ CAT.HEAD.KEYS 
                                                 [ KEY pron_rel,
                                                   ALTKEY never_unify_rel ],
                                          AGR #tagagr ],
                                  --SIND.PNG #png,
                                  PUNCT.LPUNCT no_punct ] > ],
                  MC + ],
            AGR #tagagr,
	    CONT [ HOOK [ LTOP #nehand,
                          INDEX #ind ],
		   HCONS <! !>,
                   MSG [ LBL #nehand,
                         PRED ne_m_rel,
                         MARG #modhand,
                         PARAMS <! !> ] ],
            CTXT.PRESUP <! #presup !> ] ].

loc_inv_synsem := lex_synsem &
  [ LOCAL [ CAT [ VAL [ SUBJ < >,
                        SPR < >,
                        COMPS < [ OPT -,
                                  LOCAL.CAT.HEAD.KEYS.KEY nonpro_rel ], ...>],
                  MC + ],
            CONT [ HOOK.LTOP #hand,
                   HCONS <! qeq & [ HARG #marghand,
                                    LARG #vhand ] !>,
                   MSG [ LBL #hand,
                         PRED prpstn_m_rel,
                         MARG #marghand ] ] ],
    LKEYS.KEYREL.LBL #vhand ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADJECTIVES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (See prep_synsem definition for discussion of ARG1 attribute.)

; Predicative adjectives used to introduce an ARG0 attribute in a separate 
; support relation, as did predicative PPs, but now each introduces its own
; ARG0 attribute directly in the KEY relation.

; Assume that if adjectives have a specifier, it will be either a measure-NP,
; as in "two feet tall', 'a week later"; or a degree_adverb like "very".

; Since most adjectives are underspecified for being predicative, we have to be
; sure that when they act as modifiers, the unexpressed subject's SLASH value 
; gets terminated (given lexical SLASH amalgamation).  We can't just make the
; adjective's SUBJ be 'unexpressed' since it must unify with the real subject
; in a raising construction.  So we identify the SLASH of the MOD value with
; that of the SUBJ - only one of the two will be realized syntactically.

; Most but not all adjectives can be modifiers, so the most basic adj_snsem
; type does not introduce the MOD feature, to allow for adjectives like
; "impossible" as in "it is impossible to find Kim".

;; DPF 3-Feb-01 - Removed SPR..COMPS *olist* to allow for equatives like
;; "as tall as you" where first "as" combines with "tall" and passes up its
;; as-complement.
;; DPF 5-Apr-01 - Added [LPERIPH na] to interact correctly with adj-head rule 
;; and noun-noun-cmpnd rule, to block "*towel rusty rack" - the adj-head rule 
;; makes its LPERIPH value that of the adjunct dtr, and the n-n-cmpnd rule 
;; blocks all but [LPERIPH -] head-dtr.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so adjs can
;; coordinate with VPs (which are necessarily SPR anti_synsem_min).

;; DPF 25-Sep-01 - Added AGR reentrancy with SUBJ's AGR, like with verbs, to
;; make sure modification works right in no_copula constructions as in "skies
;; light becoming dark.  But for now must also hardwire link between SUBJ's
;; AGR and INDEX, since the bare-np rule necessarily breaks this link to get
;; DIVISIBLE right.  Sigh - this will break a few tag questions, as in
;; "Someone is happy, aren't they?"
;; DPF 14-Oct-03 - Changed LPERIPH value from na to + since we want "same day"
;; to be LPERIPH +, not na.  Needed in particular for tempnp rule as in
;; 'Kim arrived the same day' since it requires the NP to be modified and
;; LPERIPH +.
;; DPF 22-Nov-03 - But now make LPERIPH bool since we need "annual report"
;; to be compatible with LPERIPH na_or_- in order to get "IBM annual report"

basic_adj_synsem_lex_or_phrase := canonical_synsem &
  [ LOCAL [ AGR #agr,
            CAT [ HEAD [ TAM #tam,
                         KEYS.KEY basic_adj_rel ],
		  VAL.SUBJ < > ],
            CONT [ HOOK.XARG #agr,
                   RELS.LIST.FIRST basic_adj_relation &
                             [ ARG0.E #tam ] ] ],
    MODIFD.LPERIPH bool ].

; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).
; DPF 8-Jun-03 -Added SPR..LEX + to block "Kim is as as Sandy tall" but allow
; "Kim is as tall as Sandy"
; DPF 11-Sep-03 - But this prevents measure-phrase specifiers, so remove, and
; look for an alternative to block above.  **FIX**
; DPF 21-oct-03 - Fixed, since MNPs are now LEX +.
; DPF 19-aug-04 - But then we block "the structures forty feet tall" (along
; with "*the structures very tall").  So we'll try making the HS-LEX value
; be constrained by the specifier, and adjust the relevant head_spec rule
; accordingly.

basic_adj_abstr_lex_synsem := basic_adj_synsem_lex_or_phrase & 
                              abstr_lex_synsem.

basic_adj_synsem := basic_adj_abstr_lex_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
            CAT [ HEAD adj,
                  VAL [ SPR 
                        < #spr & synsem_min &
                          [ LOCAL local_min &
                           [ CAT [ HEAD.KEYS.KEY degree_rel,
                                   VAL [ SPR *olist*,
                                         SPEC < [ LOCAL.CAT.HS-LEX #hslex ] >],
                                   MC na ],
                             CONT.HOOK [ LTOP #ltop,
                                         XARG #arg0 ] ],
                            NONLOC.SLASH 0-dlist,
                            OPT +,
                            LEX + ] >,
                        COMPS #comps ],
                  HS-LEX #hslex ],
            CONT.RELS.LIST < #key, ... > ],
    LKEYS.KEYREL #key & [ LBL #ltop,
                          ARG0 #arg0 ] ].

basic_adj_lex_synsem := basic_adj_synsem & lex_synsem &
  [ LOCAL.CONT.HOOK.INDEX #arg0,
    LKEYS.KEYREL.ARG0 #arg0 ].

;; We assume for now, counterfactually, that all modifying adjectives are
;; intersective.

;; ERB (03-02-98) Maybe should add MOD < [ LOCAL.SPR.OPT ] > - to keep 
;; adjectives from modifying partitives.

;; DPF (16-Feb-98) Made XARG be 'ref-ind' rather than non_expl-ind,
;; to ensure that it gets discourse-bound if the adjective is used in a 
;; fragment.

;; DPF (12-Jul-98) Constrain adjectives to only modify nominals with obligatory
;; specifiers (which distinguishes "common" from "proper" nominals).

adj_synsem_lex_or_phrase := basic_adj_synsem_lex_or_phrase &
  [ LOCAL [ CAT.HEAD.MOD 
             < synsem_min &
               [ LOCAL [ CAT [ HEAD nom_or_ttl &
                                    [ POSS - ],
                               VAL [ SUBJ < >,
                                     SPR < synsem & 
                                           [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                        quant_or_deg_rel ] >,
                                     COMPS < > ],
                               MC na ],
                         CONJ cnil ],
                 --SIND #ind & non_expl-ind ] >,
            CONT.HOOK.XARG #ind ] ].

adj_synsem := basic_adj_lex_synsem & adj_synsem_lex_or_phrase & isect_synsem.
adj_onearg_lex_synsem := basic_adj_lex_synsem & one_arg.
adj_twoarg_lex_synsem := basic_adj_lex_synsem & two_arg.
basic_adj_twoarg_synsem := basic_adj_synsem & two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ PUNCT.LPUNCT no_punct ] > ].
adj_twoarg_synsem := adj_synsem & two_arg.

; For measure-nouns used as adjectives, as in "ten foot pole"
adj_synsem_phr := adj_synsem_lex_or_phrase & phr_synsem &
  [ LOCAL.CAT [ HEAD adj &
                     [ PRD -,
                       MOD < [ LOCAL intersective_mod &
                                     [ CAT.HEAD.KEYS.ALTKEY no_rel ] ] > ],
                VAL [ SPR < >,
                      COMPS < > ] ] ].

nomod_adj_synsem := basic_adj_lex_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD no_head ] > ].

nonprd_synsem := lex_synsem &
  [ LOCAL.CAT.HEAD.PRD - ].

; 21-apr-04 - Removed STATIVE +
prd_synsem := lex_synsem &
  [ LOCAL [ CAT.HEAD.PRD + ] ].

intrans_adj_synsem := adj_synsem & one_arg &
  [ LOCAL.CAT [ HEAD.KEYS.KEY abstr_adj_rel,
                VAL.COMPS < > ] ].

basic_attr_adj_synsem := intrans_adj_synsem & nonprd_synsem &
  [ LOCAL.CAT.POSTHD -,
    NONLOC non-local_none ].

; DPF 27-nov-04 - Block SPR for these, to avoid e.g. "*a very mere child"
attr_adj_synsem := basic_attr_adj_synsem &
  [ LOCAL.CAT.VAL.SPR < anti_synsem > ].

pred_adj_synsem := adj_synsem & prd_synsem &
  [ LOCAL [ CAT.POSTHD +,
            CONT.HOOK.XARG #ind ],
    LKEYS.KEYREL.ARG1 #ind ].

; Not marked for LEX
; 21-apr-04 - Removed STATIVE + from INDEX

intrans_pred_adj_synsem := basic_adj_synsem & one_arg & isect_synsem &
                           adj_synsem_lex_or_phrase &
  [ LOCAL [ CAT [ HEAD [ PRD +,
                         MOD < [ --SIND #ind ] >,
                         KEYS.KEY adj_rel ],
                  VAL [ SPR < [ LOCAL.CAT.HEAD n_or_adv &
                                  [ KEYS.ALTKEY abstr_meas_nom_rel ] ] >,
                        COMPS < > ] ],
            CONT [ HOOK [ INDEX #arg0,
			  XARG #ind ],
                   RELS <! adj_relation !> ] ],
    LKEYS.KEYREL [ ARG0 #arg0,
                   ARG1 #ind ] ].

;;; We should have a trans_adj_attr_synsem too, for 'easy' and the likes ...

pred_adj_two_arg_synsem := pred_adj_synsem & two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ PUNCT.LPUNCT no_punct ] > ].

trans_adj_pred_synsem := pred_adj_two_arg_synsem &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
			    [ LOCAL [ CAT basic_pp_cat &
                                          [ HEAD.KEYS.KEY #ckey & 
                                                           selected_rel ],
                                      CONJ cnil,
				      CONT.HOOK [ LTOP #ltop,
                                                  INDEX #ind &
                                                        non_expl-ind ] ] ] >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS [ KEYREL.ARG2 #ind,
            --COMPKEY #ckey ] ].

; For adjectives like "accessible (by car)" which take a contentful PP compl.
trans_adj_pp_ind_synsem := pred_adj_two_arg_synsem &
  [ LOCAL [ CAT.VAL.COMPS < synsem &
			    [ LOCAL [ CAT basic_pp_cat &
                                          [ HEAD.KEYS.KEY #ckey & 
                                                           independent_rel ],
                                      CONJ cnil,
				      CONT.HOOK [ LTOP #ltop,
                                                  XARG #ind &
                                                        non_expl-ind ] ] ] >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS [ KEYREL.ARG2 #ind,
            --COMPKEY #ckey ] ].

irreg_trans_adj_pred_synsem := pred_adj_two_arg_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem &
                          [ LOCAL.CAT np_cat_acc_min &
                                      [ HEAD.KEYS.KEY #ckey ] ] >,
    LKEYS.--COMPKEY #ckey ].

adj_np_trans_le := reg_adj_word &
  [ SYNSEM irreg_trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ --SIND #index,
				       OPT - ] >,
		     CONT.RELS <! [ ARG2 #index ] !> ] ] ].

; e.g. 'able' - Can't use equi_intrans_lt since it specifies an arg12_rel, 
; which is incompatible with adj_rel.  

basic_adj_equi_synsem := pred_adj_synsem & basic_inf_or_prp_intrans_subst &
                         basic_two_arg &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY adj_rel,
                  VAL.COMPS < [ LOCAL [ CAT.VAL.SUBJ 
                                        < [ NONLOC.SLASH 0-dlist ] >,
                                        CONT.HOOK.XARG #subjind ],
                                OPT -,
                                PUNCT.LPUNCT no_punct ] > ],
            CONT.HOOK.XARG #subjind ],
    LKEYS.KEYREL adj_arg12_relation &
                   [ ARG1 #subjind ] ].


reg_adj_equi_synsem := basic_adj_equi_synsem & basic_inf_intrans_subst &
                       two_arg &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT [ HOOK.LTOP #hand,
                                           MSG message ] ] >,
            CONT.RELS <! adj_relation !> ],
    LKEYS.KEYREL.ARG2 #hand ].

; 'done working'
adj_equi_prp_synsem := basic_adj_equi_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local_min &
                                    [ CAT.HEAD.VFORM prp,
                                      CONT.HOOK.LTOP #hand ] ] >,
            CONT [ RELS <! relation, message & 
                                     [ LBL #chand,
                                       PRED prpstn_m_rel,
                                       MARG #shand ] !>,
                   HCONS <! qeq & [ HARG #shand,
                                    LARG #hand ] !> ] ],
    LKEYS.KEYREL.ARG2 #chand ].

scoping_adj_synsem := basic_adj_lex_synsem & prd_synsem &
  [ LOCAL.CAT [ HEAD.KEYS.KEY adj_rel,
                VAL.KCMP [ LOCAL.CONT [ HOOK.LTOP #hand,
                                        MSG message ],
                           PUNCT.LPUNCT no_punct ] ],
    LKEYS.KEYREL.ARG2 #hand ].

basic_adj_atrans_synsem := basic_adj_lex_synsem & prd_synsem & 
                           basic_pp_vp_subst &
  [ LOCAL 
    [ CAT [ HEAD.KEYS.KEY adj_rel,
            VAL [ COMPS < [ LOCAL [ CAT.HEAD.KEYS.KEY _for_p_sel_rel,
                                    CONT.HOOK [ LTOP #ahand,
                                                INDEX #expr ] ],
                            OPT + ],
                          #comp &
                          [ LOCAL 
                             [ CAT.VAL.SUBJ < [ NONLOC.SLASH 0-dlist ] >,
                               CONT.HOOK.INDEX.E.TENSE no_tense ],
                            PUNCT.LPUNCT no_punct,
                            OPT - ], ...>,
                  KCMP #comp ] ] ],
    LKEYS.KEYREL it_adj_arg123_relation &
                   [ LBL #ahand,
                     ARG1.PNG.PN 3sg,
                     ARG3 #expr ] ].

generic_adj_atrans_synsem := basic_adj_atrans_synsem & basic_pp_inf_subst &
                             scoping_adj_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.INDEX.E.ASPECT no_aspect,
            CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; DPF 30-aug-04 - Generalize to take either inf or prp VP complements, as in
; 'it is tough climbing that hill' or 'it is tough to climb that hill'
reg_adj_atrans_synsem := basic_adj_atrans_synsem & basic_three_arg &
                         nomod_adj_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL local_min &
                               [ CONT [ HOOK.LTOP #hand,
                                        MSG no_msg ] ],
            CONT [ HOOK.XARG it-ind,
                   RELS <! relation, message & 
                                     [ LBL #chand,
                                       PRED prpstn_m_rel,
                                       MARG #shand ] !>,
                   HCONS <! qeq & [ HARG #shand,
                                    LARG #hand ] !> ] ],
    LKEYS.KEYREL.ARG2 #chand ].

; 'Kim is easy to please'
tough_adj_atrans_synsem := generic_adj_atrans_synsem & tough_three_arg &
                           adj_synsem_lex_or_phrase &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ NONLOC.SLASH <! unexpr_local &
                                               [ CAT np_cat_acc_min,
                                                 CONT.HOOK.INDEX #slind ] !>]>,
            CONT.HOOK.XARG #slind & ref-ind ] ].

;; DPF (9-Mar-99) It appears that there are no CP-taking adjectives which 
;; select for a 'like-CP' of the kind some verbs take (e.g. 'It sounds like
;; Kim will leave').  So we constrain the KCMP to be prop_ques_m_rel.
;; But there are adjectives (like 'doubtful, unclear, unsure') which can take 
;; a whether-CP, so we introduce a subtype of reg_adj_cp_synsem for those that 
;; only take a 'that-CP', and similarly for expletive-it subject-taking 
;; adjectives.

; 'uncertain': '?Kim is uncertain that Sandy left' 
;              'Kim is uncertain whether Sandy left' 
;              'It is uncertain that Sandy left'
;              'It is uncertain whether Sandy left'

basic_adj_cp_synsem := scoping_adj_synsem & two_arg &
  [ LOCAL [ CAT.VAL [ COMPS < synsem & #comp &
                              [ LOCAL
                               [ CAT s_cat_v_c,
                                 CONJ cnil,
                                 CONT.MSG.PRED prop_ques_m_rel ] ] >,
                      KCMP #comp ],
	    CONT.RELS <! relation !> ],
    LKEYS.KEYREL adj_arg12_relation ].

adj_cp_fin_inf_synsem := basic_adj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_or_inf_v_c ] > ].

; 'unclear' '*Kim is unclear that/whether Sandy left'
;           'It is unclear that Sandy left'
;           'It is unclear whether Sandy left'
; DPF 10-jul-04 - FIX -- Why is the ARG1 constrainted to PNG.PN 3sg?  
; Shouldn't that ARG1 be for an optional (experiencer) to-PP (not yet
; provided)?

adj_atrans_cp_fin_inf_synsem := adj_cp_fin_inf_synsem & nomod_adj_synsem &
  [ LOCAL.CONT.HOOK.XARG it-ind,
    LKEYS.KEYREL it_adj_arg12_relation & [ ARG1.PNG.PN 3sg ] ].

; 'imperative': 'it is imperative that you be here'
adj_atrans_bse_cp_synsem := basic_adj_cp_synsem & nomod_adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT s_cat_bse ] >,
            CONT.HOOK.XARG it-ind ],
    LKEYS.KEYREL it_adj_arg12_relation & [ ARG1.PNG.PN 3sg ] ].

reg_adj_cp_synsem := adj_cp_fin_inf_synsem & adj_synsem.

; 'afraid'  'Kim is afraid that Sandy left'
;           '*Kim is afraid whether Sandy left'
;           '*It is afraid that/whether Sandy left'
reg_adj_that_cp_synsem := reg_adj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    CONT.MSG.PRED propositional_m_rel ] ] > ].

; 'obvious' '*Kim is obvious that/whether Sandy left'
;           'It is obvious that Sandy left'
;           '*It is obvious whether Sandy left'
;   but cf. 'It is not obvious whether Sandy left' ***Needs fixing***

adj_atrans_that_cp_synsem := adj_atrans_cp_fin_inf_synsem &
  [ LOCAL.CAT.VAL.KCMP.LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    CONT.MSG.PRED propositional_m_rel ] ].

adj_word := hcons_amalg_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT.HEAD.MOD < [ --SIND #ind ] >,
                     CONT [ HOOK.XARG #ind,
                            RELS <! adj_relation !> ] ],
             LKEYS.KEYREL.ARG1 #ind ] ].

reg_adj_word := adj_word & 
  [ INFLECTD -,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY adj_rel ].

reg_intrans_adj := reg_adj_word & 
  [ SYNSEM intrans_adj_synsem ].

adj_intrans_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY norm_adj_rel ].

adj_intrans_kpred_le := reg_intrans_adj & kpred_lexent.


adj_prtcl_le := hcons_amalg_word &
  [ INFLECTD -,
    SYNSEM basic_adj_twoarg_synsem &
              [ LOCAL [ CAT [ HEAD [ MOD < >,
                                     KEYS.KEY selected_rel & #key ],
                              VAL.COMPS < [ --SIND #ind,
                                            OPT - ] >,
                              POSTHD - ],
                        CONT [ HOOK.INDEX #ind,
                               RELS <! relation !> ] ],
                LKEYS.KEYREL [ PRED #key,
                               ARG2 #ind ] ] ].

; own: 'his own books'
adj_poss_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ KEYS.KEY norm_adj_rel,
			    MOD < [ LOCAL.CAT.VAL.SPR 
                                    < [ LOCAL.CAT.HEAD.POSS + ] > ] > ] ].

; Not bare adj-noun : *we arrived last weeks
adj_intrans_notb_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ KEYS.KEY norm_adj_rel,
			    MOD 
       < [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                 explicit_q_rel ] > ] > ] ].

adj_attr_intrans_le := reg_adj_word &
  [ SYNSEM basic_attr_adj_synsem ].

adj_attr_nospec_le := reg_adj_word &
  [ SYNSEM attr_adj_synsem ].

adj_attr_intrans_prtcl_le := adj_word &
  [ INFLECTD -,
    SYNSEM attr_adj_synsem &
           [ LOCAL.CAT.HEAD.KEYS.KEY selected_adj_rel ] ].

adj_pred_intrans_le := hcons_amalg_word &
  [ INFLECTD -,
    SYNSEM intrans_pred_adj_synsem &
	      [ LOCAL.CAT.HEAD.KEYS.KEY norm_adj_rel ] ].

;adj_pred_intrans_kpred_le := hcons_amalg_word & kpred_lexent &
;  [ INFLECTD -,
;    SYNSEM intrans_pred_adj_synsem ].

adj_pred_nomod_le := hcons_amalg_word &
  [ INFLECTD -,
    SYNSEM intrans_pred_adj_synsem & 
              [ LOCAL.CAT [ POSTHD -,
                            HEAD [ KEYS.KEY norm_adj_rel,
				   MOD < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                               non_temp_nonpro_rel ] > ] ] ] ].

intrans_adj_oddsem := norm_no_affix_word &
  [ SYNSEM intrans_adj_synsem &
           [ LOCAL [ CAT [ POSTHD -,
                           HEAD.KEYS.KEY norm_adj_rel ],
                     CONT.HOOK.XARG #ind ],
             LKEYS.KEYREL.ARG1 #ind ] ].

; DPF 10-Jun-03 - Added MOD..HEAD no_head to prevent these from appearing as
; modifiers. They have to be MOD nonempty in order to combine with the copula, 
; and in fact MOD < synsem> to combine with base form "be".
adj_atrans_le := basic_norm_word &
  [ SYNSEM adj_onearg_lex_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < synsem & [ LOCAL.CAT.HEAD no_head ] >,
                                  KEYS.KEY expl_adj_rel ],
                           VAL.COMPS < > ],
                     CONT [ HOOK.XARG it-ind,
                            RELS <! relation !> ] ] ],
    INFLECTD - ].

adj_atrans_pp_le := basic_norm_word &
  [ SYNSEM adj_twoarg_lex_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < synsem & [ LOCAL.CAT.HEAD no_head ] >,
                                  KEYS.KEY expl_adj_rel ],
                           VAL.COMPS < [ LOCAL [ CAT basic_pp_cat &
                                                     [ HEAD.KEYS.KEY 
                                                              selected_rel ],
                                                 CONT.HOOK [ LTOP #ltop,
                                                             INDEX 
                                                               non_expl-ind ],
                                                 CONJ cnil ],
                                         NONLOC.SLASH 0-dlist,
                                         OPT + ] > ],
                     CONT [ HOOK [ LTOP #ltop,
                                   XARG it-ind ],
                            RELS <! relation !> ] ] ],
    INFLECTD - ].

; DPF 23-Oct-01 - Hack for "That costs less than $50"
adj_dollar_le := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD -,
                            MOD < [ LOCAL.CAT.HEAD.KEYS.KEY _dollar_n_rel ]>]].

;; doctor's appointment
adj_compound_le := intrans_adj_oddsem &
  [ SYNSEM attr_adj_synsem &
	 [ LOCAL 
	   [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                INDEX #nind ] ] >,
	     CONT [ HOOK.LTOP #hand,
		    RELS <! relation & [ ARG1 #aind ],
                            prep_notense_relation &
                            [ LBL #hand,
                              PRED compound_rel,
                              ARG1 #nind,
                              ARG2 #aind ] !> ] ] ] ].

;; {OPT +] is on reg_trans_adj and not on trans_adj_synsem because the 
;; comparison_lr uses trans_adj_synsem and requires OPT -. Same for semantics.

adj_trans_lexent := reg_adj_word &
  [ SYNSEM trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >, 
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !> ] ] ] ].

adj_trans_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY norm_adj_rel ].

adj_pred_trans_le := adj_trans_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD +,
                            KEYS.KEY norm_adj_rel ] ].

adj_trans_kpred_le := adj_trans_lexent & kpred_lexent.

adj_trans_oblig_le := adj_trans_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS [ --COMPKEY #ckey,
                     --+COMPKEY #ckey ] ] ].

adj_trans_pp_ind_le := reg_adj_word &
  [ SYNSEM trans_adj_pp_ind_synsem &
           [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !> ] ] ] ].

adj_reg_equi_lexent := hcons_amalg_affixed_word &
  [ INFLECTD -,
    SYNSEM reg_adj_equi_synsem ].

adj_reg_equi_le := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY norm_adj_rel ].

adj_reg_equi_kpred_le := adj_reg_equi_lexent & kpred_lexent.

; For e.g. "supposed to"
adj_reg_equi_nomod_le := adj_reg_equi_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD [ KEYS.KEY norm_adj_rel,
			    MOD < [ LOCAL.CAT.HEAD.KEYS.KEY no_rel ] > ] ].

adj_equi_prp_le := hcons_amalg_affixed_word &
  [ INFLECTD -,
    SYNSEM adj_equi_prp_synsem & [ LOCAL.CAT.HEAD.KEYS.KEY norm_adj_rel ] ].

adj_reg_atrans_le := hcons_amalg_affixed_word &
  [ SYNSEM reg_adj_atrans_synsem ].

reg_adj_atrans_cp_word := hcons_amalg_affixed_word &
  [ SYNSEM adj_atrans_cp_fin_inf_synsem ].

adj_reg_atrans_cp_le := reg_adj_atrans_cp_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

adj_reg_atrans_that_cp_le := reg_adj_atrans_cp_word &
  [ SYNSEM adj_atrans_that_cp_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

adj_tough_atrans_le := hcons_amalg_affixed_word &
  [ SYNSEM tough_adj_atrans_synsem ].

reg_adj_cp_word := hcons_amalg_affixed_word &
  [ SYNSEM reg_adj_cp_synsem &
	   [ LOCAL.CONT.HOOK.XARG #ind,
             LKEYS.KEYREL.ARG1 #ind ] ].

adj_reg_cp_le := reg_adj_cp_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.KEYS.KEY norm_adj_rel,
		       VAL.COMPS < [ OPT - ] > ] ].

adj_reg_cp_kpred_le := reg_adj_cp_word & kpred_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

adj_reg_that_cp_le := reg_adj_cp_word &
  [ SYNSEM reg_adj_that_cp_synsem &
           [ LOCAL.CAT [ HEAD.KEYS.KEY norm_adj_rel,
			 VAL.COMPS < [ OPT - ] > ] ] ].

adj_atrans_bse_cp_le := hcons_amalg_affixed_word &
  [ SYNSEM adj_atrans_bse_cp_synsem ].


; How is Sandy?  How does Tuesday look?
; We adopt the following second-order quantification semantics for these:
;    which (p, property(p), look_seem(proposition_to_property(adj(x),p)))
; where we exploit a type-shifting relation to change the proposition "adj(x)"
; into the associated property "the set of entities of which adj(x) is true",
; so the "which" operator can quantify over that property.

;; DPF 14-Apr-00 - Changed SUBJ.CAT from nomp_cat_nom_min to nomp_cat_min
;; since [CASE nom] conflicts with the CASE hack on pro_ss to prevent the
;; latter from undergoing subject xxtraction (see ERB notes for pro_ss).

adj_wh_le := nonconj & non_affix_bearing & mcna & nonslash & 
                        nonrel & nonmsg &
  [ SYNSEM lex_synsem &
      [ LOCAL [ ARG-S < >,
		CAT [ POSTHD +,
		      HEAD adj & [ MOD < [ LOCAL [ CAT nbar_cat_min,
                                                   CONJ cnil ],
                                           --SIND #ind & ref-ind ] >,
                                   KEYS.KEY adj_abstract_rel ],
		      VAL [ SPR < >,
			    COMPS < > ] ],
		CONT [ HOOK [ LTOP #ltop,
                              INDEX #ind,
                              XARG #ind ],
		       RELS <! [ LBL #ahand,
                                 PRED unspec_adj_rel,
                                 ARG1 #ind ],
			        [ PRED which_q_rel,
                                  ARG0 #pind,
                                  RSTR #hand ],
			        [ LBL #hand,
                                  PRED property_rel,
                                  ARG0 #pind ],
			        prpstn_to_prop_relation & #key &
			        [ LBL #ltop,
				  ARG1 #ahand,
				  ARG2 #pind ] !>,
		       HCONS <! !> ] ],
        LKEYS.KEYREL #key,
	NONLOC.QUE 1-dlist &
	              [ LIST < handle > ] ] ].

compar_superl_adj_word := hcons_amalg_non_affixed_word &
  [ SYNSEM abstr_lex_synsem &
           [ LOCAL [ CAT.HEAD.MOD < [ --SIND #ind ] >,
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
                                      ARG0 #arg0,
                                      ARG1 #ind ],
                                  #altkey &
                                  [ LBL #hand,
                                    ARG0 #arg0,
                                    ARG1 #ind ] !> ] ],
             LKEYS.ALTKEYREL #altkey ] ].

basic_compar_adj_word := compar_superl_adj_word &
  [ SYNSEM adj_synsem & 
           [ LOCAL.CAT [ HEAD.KEYS.ALTKEY comp_rel,
                         VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                   much_or_very_deg_rel ] > ],
             LKEYS.ALTKEYREL.PRED comp_rel ] ].

adj_comp_lexent := basic_compar_adj_word &
  [ SYNSEM adj_twoarg_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < synsem &
                                     [ LOCAL [ CAT basic_pp_cat &
                                                   [ HEAD.KEYS.KEY #ckey ],
                                               CONJ cnil,
                                               CONT.HOOK [ LTOP #ltop,
                                                           INDEX #ind ] ] ] >,
                     CONT.HOOK [ LTOP #ltop,
                                 XARG #xarg ] ],
             LKEYS [ KEYREL.ARG1 #xarg,
                     ALTKEYREL.ARG2 #ind,
                     --COMPKEY #ckey ] ] ].

adj_comp_le := adj_comp_lexent &
  [ SYNSEM [ LKEYS.--COMPKEY _than_p_compar_rel,
             LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY much_deg_rel ] > ]].

; For 'different from/than', 'similar_to'
; (Takes both 'very' and 'much' specifiers.)
adj_comp_alt_le := adj_comp_lexent.

; For 'same as' - Note "*Kim is same", "*A same car arrived"
adj_same_le := adj_comp_lexent &
  [ SYNSEM 
    [ LOCAL.CAT [ HEAD 
          [ PRD -,
            MOD < [ LOCAL.CAT.VAL.SPR 
                      < [ LOCAL.CAT.HEAD.KEYS.KEY def_or_demon_q_rel ] > ] > ],
                  VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY much_deg_rel ] > ],
      LKEYS.--COMPKEY _as_p_comp_rel ] ].

adj_atrans_comp_le := hcons_amalg_non_affixed_word &
  [ SYNSEM basic_adj_lex_synsem &
        [ LOCAL [ CAT [ HEAD [ MOD < >,
                               KEYS.ALTKEY comp_rel ],
                        VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY much_deg_rel ]>,
                              COMPS < > ] ],
                  CONT [ HOOK.XARG it-ind,
                         RELS <! [ LBL #hand ],
                               #altkey &
                               [ LBL #hand ] !> ] ],
          LKEYS.ALTKEYREL #altkey & [ PRED comp_rel ] ] ].


adj_comp_trans_le := basic_compar_adj_word &
  [ SYNSEM trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                         INDEX #index ] ] >, 
                               SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                           much_deg_rel ] > ],
                     CONT.HOOK.LTOP #ltop ],
             LKEYS.KEYREL.ARG2 #index ] ].

basic_superl_adj_word := compar_superl_adj_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.ALTKEY superl_rel,
             LKEYS.ALTKEYREL.PRED superl_rel ] ].

adj_superl_le := basic_superl_adj_word &
  [ SYNSEM intrans_adj_synsem & 
           [ LOCAL.CAT [ HEAD.PRD -,
                         VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY very_deg_rel ] >,
                         POSTHD - ] ] ].

superl_adj_synsem := basic_adj_abstr_lex_synsem & one_arg &
  [ LOCAL.CONT.RELS <! #key, relation !>,
    LKEYS.KEYREL #key ].

adj_superl_prd_le := basic_superl_adj_word &
  [ SYNSEM superl_adj_synsem &
           [ LOCAL [ CAT [ HEAD superl_adj & 
                                [ KEYS.KEY abstr_adj_rel,
                                  MOD < anti_synsem_min >,
                                  PRD - ],
                           VAL [ SPR < anti_synsem_min >,
                                 COMPS < > ],
                           POSTHD - ],
                     CONT.HOOK.INDEX #arg0 ],
             LKEYS.KEYREL.ARG0 #arg0 ] ].

adj_atrans_superl_lexent := hcons_amalg_non_affixed_word &
  [ SYNSEM basic_adj_lex_synsem &
       [ LOCAL [ CAT [ HEAD [ MOD < >,
                              KEYS.ALTKEY superl_rel ],
                       VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY very_deg_rel ] >,
                             COMPS < > ] ],
                 CONT [ HOOK.XARG it-ind,
                        RELS <! [ LBL #hand ],
                              #altkey &
                              [ LBL #hand ] !> ] ],
         LKEYS.ALTKEYREL #altkey & [ PRED superl_rel ] ] ].

adj_atrans_superl_le := adj_atrans_superl_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

; 21-apr-04 - Removed STATIVE + from INDEX
adj_atrans_superl_prd_le := adj_atrans_superl_lexent &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRD + ] ].

; Titles like 'mister', 'professor' which modify proper names
; DPF 5-Apr-01 - Changed MOD..KEY to abstr_named_rel from named_rel, to
; include integers, as in "number ten"
; Removed LPERIPH na - it blocked "order fivedigitersatz" since the num-np
; rule cannot accept numerals modified by adjectives or noun-noun compounds -
; we want to block the NP "Toshiba 2000" but allow the NP "order (number) 2000"
; DPF 12-Nov-03 - Removed MOD.MODIFD notmod_or_rmod since it prevented
; "number 222" where "222" is MODIFD lmod.  We'll see what that constraint
; was trying to block.
; DPF 03-may-04 - Added LPERIPH + to distinguish "number five" from "five",
; so the former can appear in appositives but not the latter.

basic_title_synsem := basic_zero_arg & basic_lex_synsem &
  [ LOCAL [ CAT [ HEAD ttl &
                       [ MOD < [ LOCAL intersective_mod &
				       [ CAT nbar_cat_min &
                                         [ HEAD.KEYS.KEY gen_named_rel,
                                           VAL.SPR <[ LOCAL.CAT.HEAD.KEYS
                                                      [ALTKEY proper_q_rel]]>],
                                         CONJ cnil,
					 CONT.HOOK [ LTOP #nhand,
                                                     INDEX #nind ] ] ] >,
                         KEYS.KEY non_temp_nonpro_rel ],
                  VAL [ SUBJ < >,
			SPR < synsem & 
                              [ LOCAL.CAT.HEAD.KEYS.KEY quant_or_deg_rel ] >,
                        COMPS < > ] ],
	    CONT [ HOOK.INDEX #arg0,
		   RELS <! #key & 
                          [ LBL #khand,
                            ARG0 #ind ],
                          [ PRED udef_q_rel,
                            ARG0 #ind,
                            RSTR #rhand ],
                          [ LBL #nhand,
                            PRED title_id_rel,
                            ARG0 #arg0,
                            ARG1 #ind,
                            ARG2 #nind ] !>,
                   HCONS <! qeq &
                           [ HARG #rhand,
                             LARG #khand ] !> ] ],
    MODIFD.LPERIPH +,
    LKEYS.KEYREL #key ].

title_synsem := basic_title_synsem &
  [ LOCAL.CAT [ POSTHD -,
                HEAD [ MOD < [ LOCAL.CAT.HEAD.KEYS.KEY non_temp_nom_rel ] >,
                       KEYS.ALTKEY no_rel ]],
    LEX + ].

n_title_le := no_affix_np &
  [ SYNSEM title_synsem ].

; 'ms.'
n_title_unsp_le := no_affix_np &
  [ SYNSEM title_synsem &
	   [ LKEYS.KEYREL.PRED title_rel ] ].

; DPF 7-mar-05 - Added MOD..MODIFD notmod to remove spurious analysis of e.g.
; '[Abrams in Berlin] river rises.'
n_post_title_le := basic_nonltop_word & nonque & non_affix_bearing &
  [ SYNSEM basic_title_synsem &
	   [ LOCAL.CAT [ POSTHD +,
                         HEAD.MOD < [ MODIFD notmod ] > ] ] ].

; 'number', 'age', 'aged'
n_title_num_le := no_affix_np &
  [ SYNSEM title_synsem &
     [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.KEYS.KEY integer_rel ] > ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PREPOSITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Most prepositions can be modifiers.  If they act as a modifier, we'll assume
; they have no subject (leaving for some distinct analysis Carl's "A unicorn
; at the helm, the ship sailed into the horse latitudes."  This lets us use a
; single attribute, ARG, for the index of the phrase modified, or for the
; index of the subject of the PP, in a predicative construction.

; Prepositions also have a distinguished role ARG2 which has as value the
; index of the object of the preposition.  We could introduce distinct role
; names for each preposition (e.g. "ON" for on_rel, "IN" for in-rel) but this
; would complicate the definition of the prep_synsem type, since it needs to
; know the role name to which it assigns the object's index.

; An ARG0 attribute is needed for PPs (and other substs used predicatively)
; occurring as complements of the copula as in "the meeting is on Tuesday",
; but on this analysis not postnominally.  This ARG0 role used to be
; introduced in a separate support_rel, supplied by the copula, but is now
; introduced directly in the relation introduced by the predicate (prep or
; adj or verb).

; Prepositions, like adjectives and participial verbs, can have either
; predicative or nonpredicative synsems, so each ordinary preposition
; (actually the PP headed by the P) can unify with either a pred. or non-pred.
; constraint, which resolves the underspecification.  One assumption here is 
; that there are no contexts which are underspecified for the PRD feature 
; for PPs.

; N.B. The RELS value of basic_prep_synsem cannot be a singleton list, since
; adverbs like "when" inherit this synsem, and add additional rels lexically.

; Here we only amalgamate non-local features from the complements, not the
; subject.  This is so we don't get two identical gaps in an example like "Who
; does kim think is under the bed?".  On the other hand, binding theory
; suggests that the subjects of prepositions really are on the ARG-S list.

; DPF (14-Mar-99) Constrained prepositions to not allow pied-piping in
; free relative constructions, where the QUE value is an index rather than
; a handle.

; DPF 18-Nov-04 - FIX - make HEAD be prep rather than n_or_p: no longer any
; visible motive for n_or_p.

basic_prep_synsem := canonical_synsem & 
  [ LOCAL [ CAT [ HEAD prep & [ TAM #tam,
                                KEYS.KEY #key ],
                  VAL.SUBJ < > ],
	    CONT [ RELS.LIST < relation & 
                               [ PRED #key & norm_rel,
                                 ARG0.E #tam ], ... > ] ] ].

; DPF 18-Apr-01 - Removed ident. of ALTKEY with COMPS..KEY, since it prevents
; selection in v-np-pp verbs for a PP which is temporal or locative: want to
; block "When did kim put the book", but allow "Where did Kim put the book"
; We'll see where this constraint was being used.

prep_synsem := basic_prep_synsem & lex_synsem &
  [ LOCAL [ CAT [ VAL.COMPS < synsem &
                              [ PUNCT.LPUNCT pair_or_no_punct ], ... >,
                  POSTHD + ],
	    CONT.RELS.LIST < #key, ... > ],
    LKEYS.KEYREL #key ].

; For predicative Ps and PPs like "when" which have a (non-expletive) NP subj

prep_p_synsem := basic_prep_synsem &
  [ LOCAL [ CAT.VAL.COMPS #comps,
	    ARG-S #comps ] ].

;; DPF 17-Jul-01 - Restricted SPR to be very_deg_rel, to avoid e.g. "much 
;; for Kim".  
;; DPF 16-Nov-01 - But "very for Kim" is also bad", and note "very much for
;; Kim" is good, but not "very very for Kim".  Seems reminiscent of contrast
;; between "*I want much to stay" and "I want very much to stay".  Don't know
;; how to get this, but in any case fixed SPR.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so PPs can
;; coordinate with VPs (which are necessarily SPR anti_synsem_min).
;; DPF 27-Apr-03 - Note that making SPR be much_deg_rel means that for now we
;; have to have two degree specifier lex-entries for the just_only_deg ones,
;; since we want them to work for positive adjectives, and cannot underspecify
;; much_deg vs. very_deg yet.  Once we move to PRED for relation names, we
;; should be able to get rid of those duplicate deg-spec entries.

prep_with_spr_synsem := basic_prep_synsem &
  [ LOCAL [ CAT.VAL.SPR < synsem_min & 
                          [ LOCAL local_min &
                                  [ CAT [ HEAD n_or_adv &
                                               [ KEYS.KEY much_deg_rel ],
                                          VAL [ SPR *olist*,
                                                COMPS < > ] ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #arg0 ] ],
                            NONLOC.QUE 0-dlist ] >,
            CONT.RELS.LIST.FIRST [ LBL #ltop,
                                   ARG0 #arg0 ] ] ].


; Ps and PPs that can be modifiers.
; Block PP modification of infinitival "to" - spurious ambiguity.
; Constrain MOD < [ --SIND > to be non_expl, for fragments like 
; "perhaps in a week"
; DPF 10-Sept-01 - Removed MOD..KEY relation, since it prevents modification
; of no_copula VPs, as in "rain likely tomorrow"
; DPF 19-Feb-03 - Added link between HOOK.INDEX and KEY.ARG1 - don't know why
; this went missing (example: "Can kim arrive on tuesday after four").
; DPF 11-Nov-03 - Removed reentrancy of LTOP and MOD..LTOP since this is being
; supplied by the head-modifier constructions generally, as required by the
; solution to the "apparently unsolvable problem" Kasper scoping examples.
; One extra benefit of this division of labor is that we now also get the 
; right scoping for "On Tuesday who arrives?" where the PP does not want to 
; share the handle with the filler-head phrase that it modifies.
; DPF 12-Mar-04 - Added MOD..SPEC < anti_synsem_min > to block modification by
; PPs of measure-NPs.  Though this prevents "Five kilometers on snow is
; difficult", so we should reconsider.
; DPF 19-nov-04 - Okay, we reconsidered, and removed this constraint, in order
; to provide an analysis for "five kilometers on artificial snow is difficult".
; The apparently spurious additional ambiguity seems to be manageable.
; DPF 11-mar-05 - Finally decided to take the plunge and allow PPs to modify
; other PPs (along with Nbars, VPs, and APs), so we can get rid of the
; spurious ambiguity for "Kim will arrive on Tuesday":  also constrain
; MOD to AUX -.  Note that this analysis assumes that elided VPs are not
; marked for AUX: 'Kim can on Tuesdays'.

basic_mod_n_or_vp_synsem := isect_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT [ HEAD subst & 
                                                  [ AUX -,
                                                    KEYS.KEY independent_rel ],
                                             VAL [ SPR < synsem_min >,
                                                   COMPS < > ],
                                             MC #mc ],
                                       CONT [ MSG #msg ],
				       CONJ cnil ],
                               PUNCT.RPUNCT clause_or_pair_or_no_punct,
                               --SIND #ind & non_expl ] >,
                  MC #mc,
                  POSTHD + ],
            CONT [ HOOK [ INDEX #event,
                          XARG #ind ],
                   MSG #msg ] ],
    LKEYS.KEYREL [ ARG0 #event,
                   ARG1 #ind ] ].

mod_n_or_vp_synsem := basic_mod_n_or_vp_synsem & prep_with_spr_synsem.

prep_p_mod_synsem := prep_p_synsem & mod_n_or_vp_synsem &
  [ LOCAL.CAT.VAL.SPR < [ OPT +,
                          LOCAL.CAT.HEAD.KEYS.ALTKEY abstr_meas_nom_rel ] > ].

prep_prd_or_nonprd_synsem := prep_synsem & prep_p_mod_synsem.

; Strict transitive prepositions which can be either predicative or non-pred:

one_arg_prep_synsem := prep_prd_or_nonprd_synsem & basic_one_arg &
  [ LOCAL.CONT.RELS.LIST < prep_relation, ... > ].

basic_trans_prep_synsem := one_arg_prep_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #ind ] >,
    LKEYS.KEYREL.ARG2 #ind ].

; DPF 21-Jun-01 - Changed COMPS..INDEX from ref-ind to non_expl-ind so preps
; can be particles.
; DPF 8-Aug-01 - Removed identification of LTOP and COMPS..LTOP - unwanted.

norm_trans_prep_synsem := basic_trans_prep_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND non_expl-ind,
                              LOCAL.CAT.HEAD.KEYS.KEY #ckey,
                              NONLOC.QUE.LIST *handlelist* ] >,
            CONT [ RELS <! prep_relation !>,
		   HCONS <! !> ] ],
    LKEYS.--COMPKEY #ckey ].

; DPF 27-sept-04 - Added TAM.TENSE tense to enable blocking of coordination
; of ordinary PPs with nbar-complement PPs like "per unit" or "a person"

trans_prep_synsem := norm_trans_prep_synsem &
  [ LOCAL.CAT.HEAD.TAM.TENSE tense ].

ditrans_prep_synsem := prep_prd_or_nonprd_synsem & basic_two_arg &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY #compkey,
                              NONLOC.QUE.LIST *handlelist*,
                              --SIND #objind ], 
                            [ LOCAL.CAT.HEAD [ TAM [ TENSE nontense,
                                                     ASPECT no_aspect ],
                                               KEYS.KEY #ocompkey ] ] >,
            CONT.RELS.LIST < prep_relation &
                             [ ARG2 #objind ], ... > ],
    LKEYS [ --COMPKEY #compkey,
            --OCOMPKEY #ocompkey ] ].

basic_lex_pp_synsem := prep_p_synsem & abstr_lex_synsem &
  [ LOCAL [ ARG-S < >,
	    CAT.VAL.COMPS < >,
            CONT [ HCONS <! !>,
                   RELS.LIST.FIRST #keyrel ] ],
    LKEYS.KEYREL #keyrel,
    LEX - ].

; 21-apr-04 - Removed STATIVE + from INDEX

norm_lex_pp_synsem := basic_lex_pp_synsem & basic_mod_n_or_vp_synsem &
  [ LOCAL [ CAT.HEAD [ MOD < [ MODIFD notmod_or_rmod ] >,
                       PRD + ] ] ].

; DPF 25-mar-05 - Added hack [CASE obliq] to prevent lexical PPs from
; fronting (except for relative clause PP pro-forms), to block spurious
; analysis for e.g. "on the first kim arrived".  Yes, this also blocks
; "and on we went" or "out you go!" but let's try living without these
; for now.  Also added this constraint in pp_prtcl_le.

unsp_lex_pp_synsem := norm_lex_pp_synsem & prep_with_spr_synsem.

lex_pp_synsem := unsp_lex_pp_synsem &
  [ LOCAL.CAT.HEAD.CASE obliq ].


; Ordinary prepositions:

; Moved [ OPT - ] specification to subtypes, to allow "the day before" where
; the complement is missing.
; DPF (9-Mar-99) Made basic_prep_word not inherit from nonmsg, since it has
; its MSG identified with that of its modifiee (via the head_modifier rule)
; and that modifiee will sometimes have a non-empty message, as in
; "Is kim happy in Berlin"
; DPF 19-Nov-01 - Removed COMPS..MSG no_msg, since now want to get "this
; depends on whether kim arrives" and "I'm interested in who you met"

basic_prep_word := msg_amalg_prep_word &
  [ SYNSEM norm_trans_prep_synsem &
	 [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_nonnom_min,
                                                    CONT.MSG no_msg,
						    CONJ cnil ] ] > ] ].

; Changed ref-ind constraint to non_expl-ind so prep's can be used as particles
; DPF 20-Oct-02 - Made SORT of ARG1 and first COMP be identified, to avoid
; spurious ambiguity for e.g. "ten to five"
; DPF 27-Oct-02 - But this runs afoul of the facts (1) that preps identify 
; their own index with that of their MOD's index (since they're intersective),
; (which is also their ARG's index) and (2) that predicative ones identify 
; their XARG index with their ARG's index.  And anyway, "ten to five" doesn't
; use the preposition, but rather the n_x_to_y lexical entry.

prep_word := basic_prep_word &
  [ SYNSEM trans_prep_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ --SIND non_expl-ind ] > ] ].

; DPF 02-Apr-02 - For now, block measure-phrase specifiers of ordinary 
; prepositions -- too many spurious parses.
; DPF 17-Jul-03 - But we're losing too many good sentences, such as "Kim
; arrived a week after me" so removed SPR..LEX +.

p_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

; DPF 24-aug-04 - For prepositions like "as" that exclude gerundive complements
; (to avoid spurious ambiguity)

p_noger_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT -,
                                   LOCAL.CAT.HEAD noun ] > ].


; 21-apr-04 - Removed STATIVE + from INDEX
basic_p_nmod_lexent := basic_prep_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >,
                           VAL.COMPS < [ OPT -,
                                         --SIND non_expl-ind ] > ] ],
             NONLOC.SLASH 0-dlist ] ].

p_nmod_prd_le := basic_p_nmod_lexent & 
  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].

p_nmod_lexent := basic_p_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

p_nmod_le := p_nmod_lexent.

; 'than' of "kim had more of them than sandy"
p_than_le := p_nmod_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD 
                            < [ LOCAL.CAT.HEAD.KEYS [ KEY part_of_rel,
                                                      ALTKEY _more_q_rel ] ] >,
             LKEYS.KEYREL.ARG0.E.TENSE nontense ] ].


; For "to", to avoid so much ambiguity for e.g. "ten to twelve"
; DPF 3-nov-03 - Changed MOD..KEY from non_temp_nom_rel to norm_nom_rel to
; prevent attachment to proper names.

p_nmod_no_tmod_le := p_nmod_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.KEYS.KEY norm_nom_rel ] >,
                         VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                     non_temp_nonpro_rel ] > ],
                   CONT.HOOK.INDEX.E.TENSE no_tense ] ].

; possessive 'of'
; DPF 28-mar-05 - Removed ARG0..TENSE nontense since this prevents e.g.
; 'Pollock is of what nationality?'  Also removed PRD - for same reason.
p_nmod_poss_le := basic_p_nmod_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SPR 
                                               < [ LOCAL.CAT.HEAD det ] > ] >,
                         VAL.COMPS < synsem &
                                [ LOCAL.CAT [ HEAD.KEYS.KEY nonpro_rel,
                                              VAL.SPEC < anti_synsem_min >]]>],
                   CONT.HOOK.XARG ref-ind ] ].

p_poss_pron_le := msg_amalg_prep_word &
  [ SYNSEM one_arg_prep_synsem &
     [ LOCAL 
        [ CAT [ HEAD [ TAM.TENSE tense,
                       MOD < [ LOCAL [ CAT [ HEAD noun,
                                             VAL.SPR 
                                                  < [ LOCAL.CAT.HEAD det ] > ],
                                       CONT.HOOK [ LTOP #ltop,
                                                   INDEX #ind ] ] ] > ],
                VAL.COMPS < synsem &
                            [ LOCAL [ CAT [ HEAD det &
                                                 [ KEYS [ KEY implicit_q_rel,
                                                          ALTKEY poss_rel ] ],
                                            VAL.SPEC < anti_synsem_min > ],
                                      CONT.HOOK [ INDEX #ind,
                                                  XARG #ltop ],
                                      CONJ cnil ],
                              OPT - ] > ],
          CONT [ HOOK.LTOP #ltop,
                 RELS <! prep_relation !>,
                 HCONS <! !> ] ],
       NONLOC.SLASH 0-dlist ] ].

; e.g. since
p_noslash_le := prep_word & 
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             NONLOC.SLASH 0-dlist ] ].

; For particles

basic_p_prtcl_lexent := msg_amalg_prep_word &
  [ SYNSEM basic_prep_nomod_synsem &
      [ LOCAL [ CAT [ HEAD [ KEYS [ KEY selected_prep_rel,
                                    ALTKEY #ckey ],
                             PRD - ],
                      VAL [ SPR < unexpressed >,
                            COMPS < synsem &
                                  [ LOCAL [ CAT [ HEAD [ 
                                                      TAM.MOOD ind_or_mod_subj,
                                                      KEYS.KEY #ckey ],
                                                  VAL [ SUBJ *olist*,
                                                        SPR *olist*,
                                                        COMPS < > ],
                                                  MC na_or_- ],
                                            CONJ cnil ],
                                    OPT - ] > ] ],
                AGR #index,
                CONT [ HOOK [ LTOP #ltop,
                              INDEX #index,
                              XARG #arg1 ],
		       RELS <! basic_arg12_relation & [ PRED prep_rel ] !>,
		       HCONS <! !> ] ],
        LKEYS.KEYREL [ LBL #ltop,
                       ARG0 [ E [ TENSE nontense,
                                  ASPECT no_aspect ] ],
                       ARG1 #arg1,
                       ARG2 #index ] ] ].

; DPF 06-may-04 - Changed COMPS..CASE from acc to non_nom to allow obliq
; complement NPs, including WH-S NPs, as in "that depends on who stays"
p_prtcl_lexent := basic_p_prtcl_lexent &
  [ SYNSEM.LOCAL 
           [ CAT.VAL.COMPS < synsem &
                             [ LOCAL [ CAT [ HEAD nominal &
                                                  [ POSS -,
                                                    MOD < >,
                                                    CASE non_nom ],
                                             VAL.COMPS < > ],
                                       CONT [ HOOK.INDEX #index,
                                              MSG no_msg ] ] ] >,
             CONT.HOOK.INDEX #index ] ].

; Disallow measure-NPs for most particle preps (except 'of')
norm_p_prtcl_lexent := p_prtcl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SPEC < anti_synsem_min > ] >].

p_prtcl_le := norm_p_prtcl_lexent.

; DPF - This is a place-holder solution for equative and comparative phrases,
; until we work out an adequate semantics for e.g. "taller than Abrams" or
; "as soon as convenient"
; DPF 31-mar-05 COMPS..MOD *anti_list* excludes subord-preps as in spurious
; analysis for "(as soon) as possible"

p_noslash_prtcl_lexent := basic_p_prtcl_lexent &
  [ SYNSEM [ LOCAL 
             [ CAT.VAL.COMPS < synsem &
                             [ LOCAL [ CAT [ HEAD subst &
                                                  [ KEYS.KEY norm_rel,
                                                    CASE non_nom,
                                                    MOD *anti_list* ],
                                             VAL [ SUBJ *anti_list*,
                                                   COMPS < > ] ],
                                       CONT.HOOK [ LTOP #ltop,
                                                   INDEX #index ] ] ] >,
               CONT.HOOK [ LTOP #ltop,
                           INDEX #index ] ],
             NONLOC.SLASH 0-dlist ] ].

; For VP,AP,PP complements, where need to bind LTOP
p_noslash_prtcl_le := basic_p_prtcl_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD v_or_a_or_p,
                                             CONT.HOOK.LTOP #ltop ] ] >,
                   CONT.HOOK.LTOP #ltop ] ].

; For NP complements, where cannot bind LTOP (given that for some lexical NPs
; like 'anyone' or 'that', the LTOP exposes the nominal relation's LBL, in
; order to support intersective post-nom modification, e.g. 'anyone in Paris'

p_noslash_prtcl_ncomp_le := basic_p_prtcl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD nominal ] > ].

p_prtcl_of_le := p_prtcl_lexent.

p_prtcl_prd_le := basic_p_prtcl_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < synsem &
                                   [ LOCAL [ CAT prd_cat,
                                             CONT [ HOOK [ LTOP #ltop,
                                                           XARG #xarg ],
                                                    MSG no_msg ] ] ] >,
                   CONT.HOOK [ LTOP #ltop,
                               INDEX #xarg ] ] ].

; DPF 8-Jan-02 - Added constraint on SPR to exclude measure-NP specifiers, as
; in "*There are a book in the office"
p_reg_lexent := prep_word &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LEX + ] >,
                           COMPS < [ LOCAL local_min &
                                      [ CAT.HEAD.KEYS.KEY non_temp_nom_rel ],
                                     OPT - ] > ] ].


p_reg_le := p_reg_lexent.

; DPF 02-Apr-02 - blocks e.g. "an office by Sandy" as in "kim was shown an 
; office by Sandy".  Hack, since it also blocks "Kim lives right by the river"
; DPF 31-oct-03 - Changed this constraint from SPR < unexpressed > to 
; restriction excluding measure NPs which are now [HEAD noun].
; DPF 18-mar-05 - Further constrained to locative sense which does not take
; gerundive complements, and introduce separate "by" for "by means of", to
; enable blocking of unwanted coordinations such as "from here and by arriving"

p_reg_degsp_le := p_reg_lexent &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                           COMPS < [ --SIND.SORT entity ] > ] ].

; 'by hiring Abrams'
p_gercomp_le := p_reg_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a ] >,
                       VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                             COMPS < [ LOCAL.CAT.HEAD noun_or_gerund,
                                       --SIND.SORT nom-event ] > ] ] ].

; DPF 24-Oct-01 - Added identity of AGR..PN, DIV and NP comp's AGR..PN, DIV to
; support agreement in partitives, as in "none of the rice arrives" but "*none
; of the rice arrive"
; DPF 1-Mar-02 - Removed TAM.TENSE no_tense since this blocked predicative 
; of-PP as in "this picture is of Sandy".  Also replaced
; [MOD..KEY never_unify_rel] with never_unify_event_rel since it blocked the 
; no-copula "a chance of rain".
; DPF 17-Apr-03 - Identified prep's ALTKEY with its complement's KEY, to
; preserve visibility of the embedded NP's key relation for NP's like
; 'both of the days' where this can still serve as an adverbial modifier,
; while 'both of the chairs' cannot.
; DPF 2-Sept-04 - Restricted MOD..INDEX to ref-ind, to block "a bit of rain"
; as a no_copula construction (contra 1-Mar-02 view - now treat those as
; NP fragments).

; 'of'
p_nogap_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT -,
                                   NONLOC.SLASH 0-dlist ] > ].

; DPF 31-May-02 - Constrain to only modify nominals.
p_nospec_nogap_le := prep_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >,
                       VAL [ SPR < unexpressed >,
                             COMPS < [ OPT -,
                                       NONLOC.SLASH 0-dlist ] > ] ] ].

p_temp_lexent :=  msg_amalg_prep_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT [ HEAD.KEYS.KEY temp_loc_rel,
                       VAL.COMPS < synsem & 
                                 [ LOCAL [ CAT [ HEAD nominal &
                                                      [ CASE acc,
                                                        POSS - ],
                                                 VAL [ SUBJ *olist*,
                                                       SPR *olist*,
                                                       COMPS < > ],
                                                 MC na ],
                                           CONJ cnil ],
                                   OPT - ] > ] ] ].

p_temp_le :< p_temp_lexent.
p_temp_vmod_le := p_temp_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] > ].

; 'before'
p_temp_spr_le := prep_word & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ --SIND.SORT time ] >,
                           COMPS < [ OPT - ] > ] ].

; Used e.g. for "from", as in "from under the table"
; DPF 6-Apr-01 - Also used for "worth" as in "ten dollars worth of food"
; DPF 01-sept-04 - Removed PRD + since it prevents "Kim put it back in the box"

p_ppcomp_lexent := msg_amalg_prep_word &
  [ SYNSEM one_arg_prep_synsem &
	 [ LOCAL [ CAT [ HEAD [ TAM.TENSE tense,
                                MOD < [ LOCAL.CAT 
                                         [ HEAD noun,
                                           VAL.SPR 
                                              < [ LOCAL.CAT.HEAD det ] > ]]> ],
                         VAL.COMPS < synsem &
				   [ LOCAL local_min &
					   [ CAT [ HEAD prep &
                                                        [ KEYS.KEY #key ],
						   VAL [ SPR *olist*,
							 COMPS < > ] ],
                                             CONT.MSG no_msg,
					     CONJ cnil ] ] > ],
                   CONT [ HOOK.XARG ref-ind,
                          RELS <! prep_relation !>,
                          HCONS <! !> ] ],
           NONLOC.SLASH 0-dlist,
           LKEYS.--COMPKEY #key ] ].

; 'worth'
p_ppcomp*_le := p_ppcomp_lexent &
  [ SYNSEM one_arg_prep_synsem &
           [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >,
                         VAL.COMPS < [ OPT +,
                                       LOCAL [ CAT.HEAD.KEYS.KEY _of_p_sel_rel,
                                               CONT.HOOK.INDEX #arg ],
                                     --SIND non_expl-ind ] > ],
             LKEYS.KEYREL.ARG2 #arg ] ].

p_ppcomp_copred_le := p_ppcomp_lexent &
  [ SYNSEM one_arg_prep_synsem &
    [ LOCAL 
      [ CAT.VAL.COMPS < [ OPT -,
                          LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
                                  CONT.HOOK [ LTOP #ltop,
                                              INDEX #ind &
                                                [ E [ TENSE no_tense,
                                                      ASPECT no_aspect ] ] ] ],
                          --SIND event ] >,
        CONT.HOOK.LTOP #ltop ],
      LKEYS.KEYREL.ARG2 #ind ] ].

; 'from now on', maybe 'from two to four'
p_ditrans_lexent := norm_msg_word &
  [ SYNSEM ditrans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL 
                                               [ CONT.MSG no_msg,
                                                 CONJ cnil ],
					      OPT - ], 
                                   synsem & [ LOCAL local_min &
						    [ CAT [ HEAD.PRD -,
							    MC na ],
						      CONT.HOOK.LTOP #ltop ],
					      NONLOC.QUE.LIST *handlelist*,
                                              OPT -,
                                              PUNCT.LPUNCT no_punct ] >,
		   CONT.HOOK.LTOP #ltop ],
           LKEYS [ --COMPKEY #ckey,
                   --+COMPKEY #ckey,
                   --OCOMPKEY #ockey,
                   --+OCOMPKEY #ockey ] ] ].

p_ditrans_le := p_ditrans_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CAT nomp_cat_acc_min,
                   CONT [ RELS <! relation !>,
                          HCONS <! !> ] ] ].
                                                 
p_ditrans_from_to_lexent := p_ditrans_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ --SIND #arg2 & [ SORT #sort ],
                                       LOCAL.CAT.HEAD.KEYS 
                                              [ KEY nonpro_rel,
                                                ALTKEY quant_rel ] ],
                                    [ LOCAL [ CAT [ HEAD.KEYS.KEY selected_rel,
                                                    VAL.COMPS < > ],
                                              CONT.HOOK [ LTOP #ltop,
                                                          INDEX #arg3 &
                                                            non_expl-ind & 
                                                            [ SORT #sort ]]]]>,
                     CONT.HOOK.LTOP #ltop ],
             LKEYS.KEYREL [ ARG2 #arg2,
                            ARG3 #arg3 ] ] ].

p_ditrans_from_to_le := p_ditrans_from_to_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CAT nomp_cat_acc_min,
                   CONT [ RELS <! relation !>,
                          HCONS <! !> ] ] ].

p_ditrans_from_to_nbar_le := p_ditrans_from_to_lexent &
  [ SYNSEM.LOCAL
           [ CAT.VAL.COMPS
                      < abstr_lex_synsem &
                        [ OPT -,
                          LOCAL [ CAT [ HEAD noun &
                                             [ KEYS.KEY nom_nbar_rel ],
                                        VAL [ SPR < synsem &
                                                    [ LOCAL.CAT.HEAD det,
                                                      NONLOC [ SLASH 0-dlist,
                                                               QUE 0-dlist ]]>,
                                              COMPS < > ] ],
                                  CONT.HOOK [ LTOP #nhand,
                                              INDEX #arg ] ],
                          NONLOC.SLASH 0-dlist ],
                        [ LOCAL [ CAT.HEAD.KEYS.KEY _to_p_interval_rel,
                                  CONT.HOOK.XARG #event ] ] >,
             CONT [ HOOK.INDEX #event,
                    RELS <! relation,
                          [ PRED udef_q_rel,
                            ARG0 #arg,
                            RSTR #rhand ] !>,
                    HCONS <! qeq & [ HARG #rhand,
                                     LARG #nhand ] !> ] ] ].

; DPF 13-Mar-02 - Changed PRD - to PRD +: "the response was as expected"
; DPF 2-Jul-02 - Added MOD..HEAD verb to prevent spurious analysis for e.g.
; "Abrams sees Browne as being a competent manager."
; DPF 8-Jun-03 - Split this "as" into two lexical entries, one with an
; independent rel, taking verbal (PRD +) complements and able to serve as a 
; modifier phrase or copular complement, and one with a selected_rel
; taking adj-or-prep complements, but MOD < >. and nonprd.

; 21-apr-04 - Removed STATIVE + from INDEX
p_prdp_vp_le := msg_amalg_prep_word &
  [ SYNSEM basic_trans_prep_synsem &
           [ LOCAL [ CAT [ HEAD [ PRD +,
                                  MOD < [ LOCAL.CAT.HEAD verb ] > ],
                           VAL.COMPS 
                                < synsem &
                                  [ LOCAL [ CAT prd_cat & [ HEAD verb ],
                                            CONJ cnil,
                                            CONT.HOOK #hook & [ LTOP #ltop,
                                                                INDEX #ind ] ],
                                    NONLOC [ SLASH 0-dlist,
                                                QUE 0-dlist,
                                                REL 0-dlist ],
                                    OPT - ] > ],
                     CONT [ HOOK #hook,
                            RELS <! prep_relation & [ LBL #ltop,
                                                      ARG0 #ind ] !>,
                            HCONS <! !> ] ] ] ].

p_prdp_sel_le := msg_amalg_prep_word &
  [ SYNSEM basic_prep_nomod_synsem &
           [ LOCAL 
             [ CAT [ HEAD.PRD -,
                     VAL.COMPS 
                         < synsem &
                           [ LOCAL [ CAT prd_cat,
                                     CONJ cnil,
                                     CONT.HOOK [ LTOP #ltop,
                                                 INDEX #ind,
                                                 XARG #xarg ] ],
                             NONLOC [ SLASH 0-dlist,
                                         QUE 0-dlist,
                                         REL 0-dlist ],
                             OPT - ] > ],
               CONT [ HOOK [ LTOP #ltop,
                             INDEX #xarg,
                             XARG #ind ],
                      RELS <! prep_relation & [ LBL #ltop,
                                                ARG0 #ind,
                                                ARG2 #xarg ] !>,
                      HCONS <! !> ] ] ] ].


; when: "use of this device when shaving/angry/in Berlin is ..."
; 21-apr-04 - Removed STATIVE + from INDEX
p_prdp_le := msg_amalg_prep_word &
  [ SYNSEM basic_trans_prep_synsem &
           [ LOCAL [ CAT [ HEAD [ PRD +,
                                  MOD < [ LOCAL.CAT.HEAD noun ] > ],
                           VAL.COMPS 
                                < synsem &
                                  [ LOCAL [ CAT prd_cat,
                                            CONJ cnil,
                                            CONT.HOOK.LTOP #ltop ],
                                    NONLOC [ SLASH 0-dlist,
                                                QUE 0-dlist,
                                                REL 0-dlist ],
                                    OPT - ] > ],
                     CONT [ HOOK [ LTOP #ltop ],
                            RELS <! prep_relation !>,
                            HCONS <! !> ] ] ] ].

; Prepositions that don't modify nominals - e.g, 'until'

p_no_nmod_lexent := prep_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a_or_p ] >,
                       VAL.COMPS < [ OPT - ] > ] ].

; DPF 1-May-03 - Additionally, block phrasal degree specifiers to avoid
; spurious reading for "Abrams showed an office to Browne".

; 'into'
p_no_nmod_le := p_no_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LEX + ] > ].

; Additionally block pronominal NP complements - e.g. 'as'
p_no_nmod_nopro_le := p_no_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY nonpro_rel ] > ].

; 'from': Allow "I'll be there from Friday to Monday" but not "*I'll be there
; from Friday" (though we'll want this latter for British English); the noun-
; modifying variant is not restricted, so allows "My order from yesterday"
p_no_nmod_no_tmod_le := p_no_nmod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                  non_temp_nom_rel ] > ].

; "Case-marking" prepositions, which cannot be modifiers
; and (let's assume) also cannot be modified, so stipulate [ SUBJ < > ].
;
; DPF 10-Jun-99 - But they can take specifiers: "Kim fell nearly to the bottom"

basic_prep_nomod_synsem := lex_synsem & prep_with_spr_synsem & basic_one_arg & 
                           prep_p_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < >,
		  VAL [ SPR < [ OPT +,
                                LOCAL.CAT.HEAD adv ] >,
                        COMPS < synsem & 
				[ OPT -,
                                  LOCAL.CAT.HEAD.KEYS.KEY #ckey ] > ] ],
	    CONT [ RELS.LIST.FIRST #key,
                   MSG no_msg ] ],
    LKEYS [ KEYREL basic_arg12_relation & #key & [ PRED prep_rel ],
            --COMPKEY #ckey ] ].

prep_nomod_synsem := basic_prep_nomod_synsem &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL.COMPS < [ --SIND #ind,
                                NONLOC [ QUE.LIST *handlelist*,
                                         SLASH 0-dlist ] ] > ],
	    CONT [ HOOK [ INDEX #arg0,
                          XARG #pind ],
                   RELS <! prep_relation !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL [ ARG0 #arg0,
                   ARG1 #pind,
                   ARG2 #ind ] ].

; Lexical PPs

basic_pp_word := basic_norm_no_affix_sign &
  [ SYNSEM unsp_lex_pp_synsem &
    [ LOCAL [ CAT.VAL.SPR < [ OPT +,
                              LOCAL.CAT.HEAD n_or_adv &
                                  [ KEYS [ KEY much_deg_rel,
                                           ALTKEY abstr_meas_nom_rel ] ] ] >,
              CONT.RELS <! relation !> ] ] ].

pp_word := basic_pp_word &
  [ SYNSEM lex_pp_synsem ].

; 'astray'
pp_le := pp_word.

; Frontable lexical PPs: 'en route'
pp_mob_le := basic_pp_word.

pp_prtcl_le := basic_norm_no_affix_sign &
  [ SYNSEM basic_lex_pp_synsem &
           [ LOCAL [ CAT [ HEAD [ KEYS.KEY selected_rel & #keypred,
                                  MOD < >,
                                  PRD -,
                                  CASE obliq ],
                           VAL.SPR < > ],
                     CONT [ HOOK [ LTOP #ltop,
                                   XARG #xarg ],
                            RELS <! #key & [ LBL #ltop,
                                             PRED #keypred,
                                             ARG1 #xarg ] !> ] ],
             LKEYS.KEYREL #key ] ].

; 'right away'
pp_vpmod_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a ] > ].
; 'available'
pp_nmod_le := pp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.KEYS.KEY basic_nom_rel ] >,
             LKEYS.KEYREL.ARG0.E.TENSE nontense ] ].

pp_nmod_dir_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.KEYS.KEY basic_nom_rel ] > ].

; 'after'
pp_nmod_temp_le := pp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD.KEYS.KEY basic_nom_rel,
                                                VAL.SPR 
                                                 < [ LOCAL.CAT.HEAD det ] > ],
                                    --SIND.SORT time ] >,
             LKEYS.KEYREL.ARG0.E.TENSE nontense ] ].
; ago
pp_post_le := basic_norm_no_affix_sign &
  [ SYNSEM norm_lex_pp_synsem &
	   [ LOCAL [ CAT [ VAL.SPR < synsem_min & 
                                     [ LOCAL local_min &
                                             [ CAT [ HEAD noun,
                                                     VAL [ SPR < >,
                                                           COMPS < > ] ],
                                               CONT.HOOK.XARG #ind ],
                                       NONLOC.QUE 0-dlist,
                                       OPT - ] >,
                           POSTHD + ],
                     CONT.RELS <! relation &
                                  [ ARG2 #ind ] !> ] ] ].

pp_no_nmod_le := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a_or_p ] > ].

; Prepositions with lexically idiosyncratic complements:

; DPF 08-Jan-01 - was built for "as of", but don't remember why, since
; it seems "as of" is an ordinary prep.
;p_idiom_le := msg_amalg_prep_word &
;  [ SYNSEM trans_prep_synsem &
;	   [ LOCAL [ CAT.VAL.COMPS < [ OPT - ], ... > ] ] ].

; DPF 29-Nov-02 - Stipulate HOOK.XARG nothing to prevent these from appearing
; as complements of predicative 'be'.
; DPF 4-Feb-03 - But the HOOK of a modifier is now the HOOK of the hadj phrase,
; and a VP (with or without a PP modifier) has to present its XARG as the 
; index of its SUBJ, so it can't be 'nothing' - must be ref-ind.  And anyway,
; by-PPs can be complements of the copula: "The best route is by car".  So
; instead constrain subtype for e.g. "per" with incompatible value for TENSE.
; DPF 4-Feb-03 - Changed COMPS type from lex_synsem to abstr_lex_synsem to
; admit compound nouns, as in "I paid by credit card".

p_nbar_comp_lexent := msg_amalg_prep_word &
  [ SYNSEM.LOCAL 
      [ CAT [ VAL [ SPR < [ NONLOC.SLASH 0-dlist ] >,
                    COMPS < abstr_lex_synsem &
                            [ OPT -,
                              LOCAL [ CAT [ HEAD noun &
                                                 [ KEYS.KEY gen_nom_nbar_rel ],
                                            VAL [ SPR < synsem &
                                                        [ NONLOC
                                                           [ SLASH 0-dlist,
                                                             QUE 0-dlist ] ] >,
                                                  COMPS < > ] ],
                                      CONT.HOOK.LTOP #nhand ],
                              NONLOC.SLASH 0-dlist ] > ],
              POSTHD + ],
        CONT [ RELS <! prep_relation & [ ARG2 #arg ],
                     [ PRED udef_q_rel,
                       ARG0 #arg,
                       RSTR #rhand ] !>,
               HCONS <! qeq & [ HARG #rhand,
                                LARG #nhand ] !> ] ] ].

; DPF 12-Apr-03 - Added COMP..KEY non_temp_nom_rel to block e.g. means reading
; for "by three o'clock'
; DPF 9-jul-04 - But this blocks e.g. "per day", so make this constraint be
; specific to the lex entry for "by".
; DPF 27-aug-04 - Changed COMPS..MODIFD notmod to notmod_or_lmod to allow
; 'by private car' or 'by large Zodiac raft'.

p_nbar_comp_le := p_nbar_comp_lexent &
  [ SYNSEM basic_trans_prep_synsem &
           [ LOCAL.CAT 
              [ HEAD.MOD < [ PUNCT.RPUNCT pair_or_no_punct ] >,
                VAL.COMPS < [ LOCAL.CAT [ HEAD.KEYS [ KEY nom_nbar_rel,
                                                      ALTKEY no_rel ],
                                          VAL.SPR < [ LOCAL.AGR.PNG.PN 3sg ]>],
                              MODIFD notmod_or_lmod ] > ] ] ].

; DPF 24-Jun-01 - Added SUBJ <anti_synsem_min> to block 'per' reading: "Abrams
; is a manager"
; DPF 29-Nov-02 - But [E.TENSE no_tense] should be enough
; DPF 5-Sep-03 - Added SPR < anti_synsem_min > to prevent spurious readings 
; like for "three times a day"
; DPF 27-Sep-03 - no_tense won't be enough to block this as copula complement
; since all PPs are no_tense.  Instead use new value 'nontense'.

p_nbar_comp_nospr_lexent := p_nbar_comp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < anti_synsem_min >,
             LKEYS.KEYREL.ARG0.E [ TENSE nontense,
                                   ASPECT no_aspect ] ] ].

; Added MOD..ALTKEY no_rel to prevent "a person" from modifying e.g. gerunds.
; 10-Nov-01 - But now gerunds are unmarked for ALTKEY, since they need to be
; able to appear as left members of noun-noun compounds.  
; DPF 3-Jul-02 - Added [MOD..LEX +] to block spurious analyses as for 
; e.g. "every manager who has a bookcase"
; DPF 30-Aug-01 - Added COMPS <[MODIFD notmod]> to block "a ten percent
; probability" with a_per.
; DPF 16-oct-03 - Changed MOD..ALTKEY to impl_or_expl_q_rel to exclude proper 
; nouns, to still block e.g. "Kim a book".

; 'per'
p_nbar_comp_nmod_le := p_nbar_comp_nospr_lexent &
  [ SYNSEM basic_trans_prep_synsem &
           [ LOCAL.CAT [ HEAD [ MOD < [ LOCAL.CAT 
                                     [ HEAD noun &
                                      [ KEYS [ KEY nonpro_rel,
                                               ALTKEY impl_or_expl_q_rel ] ] ],
                                      PUNCT.RPUNCT pair_or_no_punct,
                                      LEX + ] >,
                                PRD - ],
                         VAL.COMPS < [ LOCAL 
                                         [ AGR.PNG.PN 3sg,
                                           CAT.HEAD.KEYS [ KEY nom_nbar_rel,
                                                           ALTKEY no_rel ] ],
                                       MODIFD notmod ] > ] ] ].

p_nbar_comp_nomod_lexent := p_nbar_comp_nospr_lexent &
  [ SYNSEM basic_prep_nomod_synsem &
           [ LOCAL [ CAT [ HEAD [ KEYS.ALTKEY #ckey,
                                  PRD - ],
                           VAL.COMPS < [ LOCAL [ CAT.HEAD [ PRD -,
                                                            KEYS.KEY #ckey ],
                                                 CONT.HOOK.INDEX #index ] ] >],
                     CONT.HOOK [ LTOP #ltop,
                                 INDEX #index,
                                 XARG #xarg ] ],
             LKEYS.KEYREL prep_relation &
                          [ LBL #ltop,
                            ARG1 #xarg,
                            ARG2 #index ] ] ].

; 'of' in "what kind of book(s)'
p_nbar_comp_nomod_le := p_nbar_comp_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY nom_nbar_rel ] > ].

; 'the 25th to 28th of May'
p_nbar_comp_nomod_to_le := p_nbar_comp_nomod_lexent.

;; Temporal prepositions:

; Prepositions like "before" that take a prep_noun like "now, then".
;   'before now', 'since then'

before_prep_le := norm_msg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS 
		 < [ LOCAL local_min &
			   [ CAT [ HEAD n_or_p & 
                                        [ PRD -,
                                          KEYS.KEY temp_loc_rel ],
				   VAL [ SPR *olist*,
					 COMPS < > ] ] ],
                     OPT - ], ... > ] ] ].

; "ten minutes to three" - "to" as head
; Use POSTHD to allow "half past three" and "three thirty" but block
;      "?thirty past three" and "*three half"
; DPF (12-Jul-98) The specifier on hour_prep_words has to be [ OPT + ] in 
; order to block prenominal adjectives from attaching, since they distinguish 
; proper from common nouns by the optionality (or absence) of the specifier.  
; This distinction doesn't seem to work well here, but it's the only case, so 
; perhaps the analysis of "ten after three" should be reconsidered.
; DPF (11-Jul-99) But this [OPT +] incorrectly predicts that "To five thirty 
; suits me" is good, and worse, it allows "to five thirty" to act like an NP in
; appositive constructions.  So instead of this hack, constrain adjectives to
; only modify nominals with a DET specifier.
; DPF 23-May-03 - Since we now treat the specifier as the semantic head in the
; spr-head rule, "ten" of "ten to three" will determine the index of the phrase
; But this finally drives us to revise the analysis of this construction, so
; now we have a lexical rule that converts one- and two-digit cardinal number
; adjectives into nouns which take an optional "minute" complement and an
; obligatory prepositional complement (which is itself underspecified for 
; whether it is complement-saturated).  This should give us "ten to two",
; "ten minutes to two", and "ten to" and "ten after".

minute_noun_synsem := lex_synsem &
  [ LOCAL 
    [ CAT 
      [ HEAD noun & [ MOD < >,
                      KEYS.KEY hour_prep_rel ],
        VAL [ SPR < >,
              SUBJ < >,
              COMPS < [ LOCAL [ CAT nomp_cat &
                                    [ HEAD.KEYS 
                                                [ KEY _minute_n_rel,
                                                  ALTKEY implicit_q_rel ] ],
                                CONT.HOOK.INDEX #minst,
                                CONJ cnil ],
                        NONLOC.SLASH 0-dlist,
                        OPT +,
                        PUNCT.LPUNCT no_punct ],
                      [ LOCAL [ CAT [ HEAD prep & 
                                        [ PRD -,
                                          KEYS [ KEY minute_prep_sel_rel,
                                                 ALTKEY numbered_hour_rel ] ],
                                      VAL.SPR *olist*,
                                      MC na ],
                                CONT.HOOK [ LTOP #nhand,
                                            XARG #ninst &
                                                 [ SORT time ] ],
                                CONJ cnil ],
                        NONLOC.SLASH 0-dlist,
                        OPT -,
                        PUNCT.LPUNCT no_punct ] > ] ],
      CONT nom-obj &
          [ HOOK [ LTOP #nhand,
                   INDEX ref-ind & #ninst &
                        [ PNG png & [ PN 3sg ] ] ],
            RELS.LIST < #key, 
                        [ PRED def_q_rel,
                          RSTR #rhand,
                          ARG0 #ninst ], ... >,
            HCONS <! qeq & [ HARG #rhand,
                             LARG #nhand ] !> ] ],
    LKEYS.KEYREL #key & [ LBL #nhand,
                          PRED hour_prep_rel,
                          ARG0 #ninst,
                          ARG1 #minst ] ].

; ten pm to two am
; Tuesday to Friday
; ten mph to twenty mph
; DPF 3-Jul-02 - If KEY is interval_rel, then we predict wrongly that all of
; these constructions can be modifier NPs like "Tuesday".  But the modifying
; capability seems to be whatever the interval endpoints are: "Kim stayed
; Tuesday to Saturday" but "*Kim stayed Abrams to Browne".  So let's try 
; making the KEY be the SPR's KEY instead.
; DPF 28-Apr-03 - The [PRD -] feature prevents this from undergoing the
; temp_np rule, so we don't get "Kim stayed Tuesday to Saturday".  Let's try
; removing this constraint and see what happens.
; DPF 15-jun-04 - Restrict two arguments to [LEX +] to avoid spurious
; ambiguities; so admit "Tuesday - Wednesday" but not "Hire Kim -- his brother"
; with the sense of x_to_y.
; DPF 21-aug-04 - Removed SYNSEM..ALTKEY never_unify_rel, since it prevents
; these from appearing in NP-N compounds, as in "the Berlin - Paris route".
; Don't know what it was trying to exclude.
; DPF 25-sept-04 - Can't use LEX + to avoid 'Hire Kim - his brother'
; (cf. 15-jun-04) since this would also block 'Two - three p.m. is okay'
; since 'two' is [LEX -] in order to sustain contrast of 'we have a two p.m.
; meeting' vs. '*we have a two meeting'.  But happily we already have the
; constraint on KEY of each dtr NP requiring abstr_named_rel, which does the
; job we want, as long as we correct the erroneous type definition for
; reason_rel which wrongly unified norm_nom_rel and abstr_named_rel.  Sigh.
; DPF 7-mar-05 - Removed [PRD -] constraint on SPR and COMPS, since proper NPs
; now have their PRD value identified with their INFL value.  Don't know why
; this constraint was originally imposed.  Now only require that the PRD values
; of the two be identified, to avoid spurious ambiguity.
; Also changed parent type from norm_msg_word to norm_word since it needs
; to be unmarked for INFL in order to appear in compounds (eg. "the Berlin - Paris
; route").  

n_x_to_y_lexent := basic_nonltop_word & nonque &
  [ INFLECTD #infl,
    SYNSEM basic_two_arg &
	 [ LOCAL [ CAT [ HEAD noun &
			      [ POSS -,
				MOD < >,
                                PRD #infl,
                                KEYS.KEY interval_rel ],
                         VAL [ SPR < synsem &
				    [ LOCAL 
                                      [ CAT 
                                        [ HEAD noun &
                                          [ POSS -,
                                            MOD < >,
                                            PRD #prd,
                                            KEYS [ KEY nonpro_rel,
                                                   ALTKEY 
                                                   abstr_def_or_udef_q_rel ] ],
                                          VAL [ SUBJ *olist*,
                                                COMPS < > ] ],
                                        CONJ cnil,
                                        CONT.MSG no_msg ],
                                      NONLOC.QUE 0-dlist,
                                      --SIND #arg1 & [ SORT #sort ],
                                      OPT - ] >,
                               SUBJ < >,
			       COMPS < synsem &
				       [ LOCAL [ CAT 
                                                 [ HEAD noun &
                                                   [ POSS -,
                                                     MOD < >,
                                                     PRD #prd,
                                                     KEYS.KEY abstr_named_rel],
                                                   VAL [ SUBJ *olist*,
                                                         COMPS < > ] ],
                                                 CONJ cnil,
                                                 CONT.MSG no_msg ],
                                         NONLOC.QUE 0-dlist,
                                         --SIND #arg2 & [ SORT #sort ],
                                         OPT -,
                                         PUNCT.LPUNCT no_punct ] > ] ],
                   AGR.DIVISIBLE -,
		   CONT nom-obj &
		       [ HOOK.INDEX #index,
			 RELS <! #key &
                                 [ LBL #nhand,
                                   PRED interval_rel,
                                   ARG0 #index ],
                                [ PRED udef_q_rel,
                                  ARG0 #index,
                                  RSTR #rhand ],
                                prep_relation &
                                [ LBL #nhand,
                                  PRED interval_start_rel,
                                  ARG0.E [ TENSE no_tense,
                                           ASPECT no_aspect ],
                                  ARG1 #index,
				  ARG2 #arg1 ],
                                prep_relation &
				[ LBL #nhand,
                                  PRED interval_end_rel,
                                  ARG0.E [ TENSE no_tense,
                                           ASPECT no_aspect ],
				  ARG1 #index,
				  ARG2 #arg2 ] !>,
			 HCONS <! qeq & [ HARG #rhand,
                                          LARG #nhand ] !>,
                         MSG no_msg ] ],
           LKEYS [ KEYREL #key,
                   ALTKEYREL.PRED never_unify_rel ] ] ].

n_x_to_y_sg_le := n_x_to_y_lexent &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL [ AGR.PNG.PN 3sg,
                                           CAT [ HEAD.KEYS.KEY abstr_named_rel,
                                                 VAL.SPR *olist* ] ] ] >, 
                           COMPS < [ LOCAL 
                                     [ AGR.PNG.PN 3sg,
                                       CAT [ HEAD.KEYS.KEY nonpro_rel,
                                             VAL.SPR *olist* ] ] ] > ] ].

n_x_to_y_plur_le := n_x_to_y_lexent &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT [ HEAD.KEYS.KEY part_of_rel,
                                               VAL.SPR *olist* ] ] >, 
                           COMPS < [ LOCAL [ CAT.VAL.SPR *olist*,
                                             AGR.PNG.PN 3pl ] ] > ] ].

; DPF 13-Aug-01 - For 'mid to upper' as in "the mid to upper nineties"
; Meaning intended to be something like "the nineties in the interval whose
; start is the mid somethings and whose end is the upper somethings"
; DPF 01-sept-04 - Removed KEYS.KEY basic_adj_rel from SPR and COMPS, to 
; allow "three to five chairs"

adj_x_to_y_le := no_affix_np &
  [ SYNSEM 
	 [ LOCAL [ CAT [ HEAD adj & 
                              [ MOD < [ LOCAL intersective_mod &
                                              [ CAT nbar_cat_min,
                                                CONT.HOOK [ LTOP #hand,
                                                            INDEX #nomarg & 
                                                                 ref-ind ],
                                                CONJ cnil ] ] >,
                                KEYS.KEY interval_end_rel ],
                         VAL [ SUBJ < >,
                               SPR < synsem &
                                      [ OPT -,
                                       LOCAL [ CAT [ HEAD adj_or_intadj &
                                                    [ TAM [ TENSE no_tense,
                                                            ASPECT no_aspect]],
                                                     VAL [ SPR *olist*,
                                                           COMPS < > ] ],
                                               CONT.HOOK [ LTOP #fghand,
                                                           XARG #fromarg ],
                                               CONJ cnil ],
                                       NONLOC.SLASH 0-dlist ] >,
                               COMPS < [ OPT -,
                                         LOCAL 
                                          [ CAT [ HEAD adj_or_intadj &
                                                  [ TAM [ TENSE no_tense,
                                                          ASPECT no_aspect ] ],
                                                  VAL [ SPR *olist*,
                                                        COMPS < > ] ],
                                            CONT.HOOK [ LTOP #tghand,
                                                        XARG #toarg ],
                                            CONJ cnil ],
                                         NONLOC.SLASH 0-dlist,
                                         PUNCT.LPUNCT no_punct ] > ] ],
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #arg0,
                                 XARG #nomarg ],
                          RELS <! #key &
                                prep_relation &
                                [ LBL #ihand,
                                  PRED interval_end_rel,
                                  ARG0 #arg0,
                                  ARG1 #intarg & [ DIVISIBLE + ],
                                  ARG2 #toarg ],
                                prep_relation &
                                [ LBL #ihand,
                                  PRED interval_start_rel,
                                  ARG0.E [ TENSE no_tense,
                                           ASPECT no_aspect ],
                                  ARG1 #intarg,
                                  ARG2 #fromarg ],
                                [ LBL #fghand,
                                  PRED elliptical_n_rel,
                                  ARG0 #fromarg ],
                                [ PRED udef_q_rel,
                                  ARG0 #fromarg,
                                  RSTR #fgrhand ],
                                [ LBL #tghand,
                                  PRED elliptical_n_rel,
                                  ARG0 #toarg ],
                                [ PRED udef_q_rel,
                                  ARG0 #toarg,
                                  RSTR #tgrhand ],
                                [ LBL #ihand,
                                  PRED interval_rel,
                                  ARG0 #intarg ],
                                [ PRED udef_q_rel,
                                  ARG0 #intarg,
                                  RSTR #irhand ],
                                prep_relation &
                                [ LBL #hand,
                                  PRED unspec_loc_rel,
                                  ARG0.E [ TENSE no_tense,
                                           ASPECT no_aspect ],
                                  ARG1 #nomarg,
                                  ARG2 #intarg ] !>,
                         HCONS <! qeq & [ HARG #irhand,
                                          LARG #ihand ],
                                   qeq & [ HARG #fgrhand,
                                           LARG #fghand ],
                                   qeq & [ HARG #tgrhand,
                                           LARG #tghand ] !> ],
                   AGR.DIVISIBLE - ],
           LKEYS.KEYREL #key,
           MODIFD.LPERIPH na ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADVERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Adverbs modify VPs and APs either pre-head or post-head (or both).
; Sentence-initial adverbials are treated as extractions of post-VP modifiers,
; unless the adverbial is a pre-head modifier. Otherwise, it would be hard to
; block post-S attachment along with post-VP attachment, which would give 
; spurious ambiguity.
; DPF 19-Oct-02 - Removed nonprd_synsem parent, since trying to make
; head_adj rule constrain adj to be PRD +.

basic_adverb_synsem := basic_one_arg & basic_lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_adv &
		       [ MOD < [ LOCAL local_basic &
				       [ CAT.MC #mc,
                                         CONT [ HOOK.XARG #xarg,
                                                MSG #msg ],
					 CONJ cnil ] ] >,
                         KEYS.KEY basic_adv_rel ],
                  VAL [ SUBJ < >,
                        SPR #spr,
			COMPS < > ],
                  MC #mc ],
	    CONT [ HOOK [ INDEX #arg0,
                          XARG #xarg ],
		   RELS.LIST < #key, ... >,
                   MSG #msg ],
            ARG-S #spr ],
    LKEYS.KEYREL #key & adv_relation &
          [ ARG0 #arg0 ] ].

basic_scopal_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal_mod &
				   [ CAT.HEAD adverbee,
				     CONT.HOOK [ LTOP #mhand,
                                                 INDEX #index ] ] ] >,
	    CONT [ HOOK.INDEX #index,
                   RELS <! relation !>,
                   HCONS <! qeq &
                          [ HARG #hand,
                            LARG #mhand ] !> ] ],
    LKEYS.KEYREL.ARG1 #hand & handle ].


; DPF 17-Dec-01 - Made MOD..E-INDEX reentrant with E-INDEX, and the INDEX 
; values the same: 
; 'Chairs currently available arrived"
basic_int_adverb_synsem := basic_adverb_synsem & isect_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.MC na,
                                   CONT.HOOK.INDEX #index ] ] >,
    LKEYS.KEYREL.ARG1 #index ].

basic_spec_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT.VAL.SPR < synsem & 
			  [ LOCAL local_min &
				  [ CAT [ VAL [ SUBJ < >,
						SPR *olist* ],
					  MC na ],
                                    CONT.HOOK [ LTOP #hand,
                                                XARG #arg0 ] ] ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #arg0 ] ].

spec_adverb_synsem := basic_spec_adverb_synsem &
  [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD adv &
                                         [ KEYS.KEY very_deg_rel ] ] > ].

intersect_spec_adverb_synsem := basic_int_adverb_synsem & 
                                basic_spec_adverb_synsem.
scopal_spec_adverb_synsem := basic_scopal_adverb_synsem & spec_adverb_synsem.

; VP, PP, AP
scopal_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD adv & 
                   [ MOD < [ LOCAL.CAT [ VAL.COMPS < >,
                                         MC na_or_- ] ] > ] ].

basic_intersect_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ VAL [ SUBJ *synlist*,
					     COMPS < > ],
				       MC na_or_- ] ] > ].

intersect_adverb_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD reg_adv & [ MOD < [ LOCAL.CAT adverbee_cat ] > ],
                  VAL.SPR < [ LOCAL.CAT.HEAD adv &
                                             [ KEYS.KEY very_deg_rel ] ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; 'now' but not 'then' - appears after auxiliary as in "You are now ready"
intersect_adverb_auxv_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD lexadv & [ MOD < [ LOCAL [ CAT adverbee_cat &
                                                 [ HEAD v_or_g ],
                                                  CONT.HOOK.LTOP #ltop ] ] > ],
                  VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY no_rel ] >,
                  POSTHD - ],
            CONT.HOOK.LTOP #ltop ] ].

; VP only
; Block adj modifiee to avoid spurious parse for "almost empty"
; DPF 09-Aug-99 - Relaxed MOD..HEAD value to be v_or_g_or_a because okay for 
; adjectives as pre-head modifiers ("an apparently difficult problem"), though
; not post-head.
; DPF 25-Oct-01 - Removed MOD..MOD < synsem > constraint since it blocked
; 'I should never have arrived'
; DPF 30-aug-04 - Changed MOD..SUBJ from <synsem_min> to *synlist* in order
; to return to letting adverbs modify adjectives, while still distinguishing
; VPs from clauses.
; DPF 04-sept - But this prevents modification of inverted sentences as in
; 'why hasn't kim arrived yet'.  So use MOD..MSG no_msg instead.

scopal_vp_adverb_synsem := scopal_adverb_synsem &
  [ LOCAL.CAT.HEAD [ MOD < [ LOCAL [ CAT.HEAD v_or_g_or_a,
                                     CONT.MSG no_msg ] ] >,
                     KEYS.KEY adv_rel ],
    LKEYS.KEYREL adv_relation ].

; Adverbs like "also" that either (pre) modify VPs or appear as complements of
; aux Vs.
; DPF 24-May-00 - Restrict MOD value to be no_aspect, to avoid spurious
; ambiguity for "kim is probably leaving"
; DPF 14-Oct-00 - But this prevents the desired parse for "Kim is not currently
; sleeping" since "not" should modify a pres-participle VP, not the gerund.  So
; as long as the gerund rule is a lexical rule, we're stuck with the ambiguity.
; DPF 13-Mar-02 - Added [MOD..PRD +] to ensure that when these adverbs modify
; deverbal adjectives, they not appear attributively, as in *the not yet 
; finished book
; DPF 18-Mar-02 - But this [PRD +] prevents these adverbs from pre-modifying
; ordinary finite VPs.  So let's instead accept "the not yet finished book" as
; okay.
; DPF 30-aug-04 - Changed MOD..SUBJ from <synsem_min> to *synlist* in order
; to return to letting adverbs modify adjectives, while still distinguishing
; VPs from clauses.

scopal_vp_aux_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD lexadv &
                   [ MOD < [ LOCAL.CAT [ HEAD v_or_g_or_a,
                                         VAL [ SUBJ *synlist*,
                                               COMPS < > ],
                                         MC na ] ] >,
                     KEYS.KEY adv_rel ] ].

scopal_negadv_adverb_synsem := scopal_adverb_synsem &
  [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT [ HEAD negadv,
                                         VAL.SUBJ < > ] ] >,
                     KEYS.KEY adv_rel ],
    LKEYS.KEYREL adv_relation ].

; rather: 'would you rather leave' 'I would rather not'
scopal_adv_would_v_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT [ HEAD adv &
                     [ MOD < [ LOCAL.CAT [ HEAD verb &
                                                [ KEYS.KEY _would_v_rel ],
                                           VAL [ SUBJ < synsem >,
                                                 COMPS *cons* ] ] ] >,
                       KEYS.KEY adv_rel ],
                POSTHD + ] ].

; DPF 21-Mar-02 - Added MOD..MSG no_msg, which seemingly should have
; been here all along - needed to block e.g. spurious parse for "kindly leave"
; DPF 12-Apr-02 - But this also blocked "Is it available yet", so instead
; change parent's MOD..VAL.SUBJ from < synsem> to < synsem_min >.
intersect_vp_adverb_synsem := intersect_adverb_synsem &
  [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT [ HEAD v_or_g_or_a,
                                         VAL.SPR < synsem_min > ] ] >,
                     KEYS.KEY basic_adv_rel ],
    LKEYS.KEYREL adv_relation ].

; S (for pre-S scopal adverbs only)
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.

scopal_s_adverb_synsem := spec_adverb_synsem &
  [ LOCAL [ CAT.HEAD adv &
                     [ MOD < [ LOCAL scopal_mod &
                                     [ CAT [ HEAD verb,
                                             VAL [ SUBJ *olist*,
                                                   COMPS < > ],
                                             MC bool ],
                                       CONT [ HOOK.LTOP #mhand,
                                              MSG message ] ] ] > ],
            CONT [ HOOK.LTOP #ltop,
		   RELS <! relation, message &
			              [ LBL #ltop,
                                        PRED prpstn_m_rel,
					MARG #marghand ] !>,
		   HCONS <! qeq &
			   [ HARG #marghand,
			     LARG #khand ] !> ] ],
    LKEYS.KEYREL [ LBL #khand,
                   ARG1 #mhand ] ].

; S or VP (for pre-head intersective adverbs only) 
intersect_s_or_vp_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL [ CAT [ HEAD adv &
                       [ MOD < [ LOCAL.CAT adverbee_cat &
                                           [ VAL.COMPS < > ] ] > ],
                  VAL.SPR < [ LOCAL.CAT.HEAD adv &
                                             [ KEYS.KEY very_deg_rel ] ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ] ].

; For adverbs like "maybe" which take no degree specifier
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.
scopal_s_adverb_nospec_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT [ VAL.SPR < anti_synsem_min >,
		  HEAD adv &
                          [ MOD < [ LOCAL scopal_mod &
                                          [ CAT [ HEAD verb,
                                                  VAL [ SUBJ *olist*,
                                                        COMPS < > ],
                                                  MC bool ],
                                            CONT.HOOK.LTOP #mhand ] ] >,
                            KEYS.KEY adv_rel ] ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! relation, message &
                                     [ LBL #ltop,
                                       PRED prpstn_m_rel,
                                       MARG #marghand ] !>,
		   HCONS <! qeq &
			   [ HARG #marghand,
			     LARG #khand ] !> ] ],
    LKEYS.KEYREL [ LBL #khand,
                   ARG1 #mhand ] ].

adverb_word := norm_mod_no_affix_word &
  [ SYNSEM scopal_vp_adverb_synsem ].

adv_le :< adverb_word.

adv_negmod_le := norm_mod_no_affix_word &
  [ SYNSEM scopal_negadv_adverb_synsem ].

adv_rather_le := norm_mod_no_affix_word &
  [ SYNSEM scopal_adv_would_v_synsem ].

; 'back' of 'back on the table'
adv_int_pp_le := norm_mod_no_affix_word &
  [ SYNSEM basic_intersect_adverb_synsem &
	   [ LOCAL [ CAT [ HEAD adv &
                                [ MOD < [ LOCAL.CAT cat &
                                           [ HEAD prep ] ] >,
                                  KEYS.KEY adv_rel ],
                           VAL.SPR < [ LOCAL.CAT.HEAD adv &
                                                 [ KEYS.KEY very_deg_rel ] ] >,
                           POSTHD - ],
                     CONT [ RELS <! relation !>,
                            HCONS <! !> ] ] ] ].

; DPF (27-Apr-99) Assume for now that S-initial adverbs can only modify [INV -]
; S's, in order to block "*Never does kim sleep?"
; DPF 28-Oct-01 - But this blocked e.g. "Meanwhile when does kim sleep"

adv_s_pre_lexent := norm_mod_no_affix_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT [ POSTHD -,
			 HEAD.MOD < [ LOCAL.CAT.MC + ] > ] ] ].
    
adv_s_pre_le := adv_s_pre_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY adv_rel ].

; 'evidently' - only pre-modifies declaratives, not questions or commands
adv_s_prop_pre_le := norm_mod_no_affix_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT 
              [ POSTHD -,
                HEAD [ MOD < [ LOCAL [ CAT.MC +,
                                       CONT.MSG.PRED propositional_m_rel ] ] >,
                       KEYS.KEY adv_rel ] ] ] ].
    
; DPF 10-Apr-02 - Removed MOD..VFORM imp_vform since this blocked e.g 
; "I would like to know when my order is going to arrive , please"
adv_s_post_word_nospec_le := norm_mod_no_affix_adv_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHD + ] ].

adv_s_pre_word_nospec_le := norm_mod_no_affix_adv_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHD - ] ].
    
adv_s_pre_word_root_le := norm_mod_no_affix_adv_word &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT [ HEAD.MOD < [ ROOT +,
                                      NONLOC.SLASH 0-dlist ] >,
                         MC +,
                         POSTHD - ] ] ].
    
adv_s_le := norm_mod_no_affix_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD.INV - ] >,
                              KEYS.KEY adv_rel ] ] ].

adv_pre_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHD - ].

adv_post_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHD + ].

adv_vp_le := adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD v_or_g_or_a ] >,
                            KEYS.KEY adv_rel ] ].

; 'please'
adv_vp_bse_le := adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD verb & 
                                                   [ VFORM imp_vform ] ] >,
                            KEYS.KEY adv_rel ] ].

adv_vp_aux_le := norm_mod_no_affix_word &
  [ SYNSEM scopal_vp_aux_adverb_synsem &
           [ LOCAL.CAT.POSTHD - ] ].
    
adv_vp_aux_post_le := norm_mod_no_affix_word &
  [ SYNSEM scopal_vp_aux_adverb_synsem &
           [ LOCAL.CAT.POSTHD + ] ].

; 'long' as in "we have long admired abrams"
adv_vp_aux_only_le := norm_mod_no_affix_word &
  [ SYNSEM scopal_vp_aux_adverb_synsem &
           [ LOCAL.CAT.HEAD.MOD < anti_synsem > ] ].

; DPF 7-Jun-00 - To avoid apparently spurious ambiguity of attachment of
; VP-final scopal adverbs in e.g. "I have won too", require these adverbs to
; attach only to finite or imperative VP, forcing high attachment.

adv_vp_post_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g & 
                                                   [ VFORM fin_or_imp ] ] >,
                       POSTHD + ] ].

adv_vp_pre_le := adverb_word & 
  [ SYNSEM.LOCAL.CAT [ POSTHD -,
                       HEAD.KEYS.KEY adv_rel ] ].

adv_int_a_or_p_le := norm_mod_no_affix_word &
  [ SYNSEM intersect_adverb_synsem & 
           [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT.HEAD a_or_p ] >,
                              KEYS.KEY adv_rel ] ] ].
    
int_vp_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM intersect_vp_adverb_synsem ].
    
int_vp_aux_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM intersect_adverb_auxv_synsem &
           [ LOCAL.CAT.HEAD.KEYS.KEY adv_rel ] ].
    
adv_int_vp_le := int_vp_adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD adv & [ KEYS.KEY adv_rel ] ].

adv_int_vp_aux_le := int_vp_aux_adverb_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #key !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #key ] ].

; 'now'
adv_int_vp_aux_now_le := que_no_wlink_word &
  [ SYNSEM intersect_adverb_auxv_synsem &
           [ LOCAL [ CAT.HEAD.TAM #tam,
                     CONT [ RELS <! [ PRED temp_loc_rel,
                                      WLINK #wlink,
                                      ARG2 #inst ],
                                   [ LBL #nhand, 
                                     PRED time_rel,
                                     WLINK #wlink & *cons*,
                                     ARG0 #inst ],
                                   [ PRED def_q_rel,
                                     ARG0 #inst,
                                     RSTR #rhand ],
                                   [ LBL #nhand,
                                     PRED _now_a_rel,
                                     ARG1 #inst ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #nhand ] !> ] ],
             LKEYS.KEYREL.ARG1 [ E #tam,
                                 SORT time ] ] ].

adv_int_vp_post_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ KEYS.KEY adv_rel ],
                       POSTHD + ] ].

adv_int_vp_pre_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ KEYS.KEY adv_rel,
                                    MOD < [ LOCAL.CAT.HEAD v_or_g ] > ],
                       POSTHD - ] ].

adv_int_vp_post_nonmob_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob & [ KEYS.KEY adv_rel ],
                       POSTHD + ] ].

adv_int_vp_post_prtcl_le := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob & [ KEYS.KEY selected_rel ],
                       POSTHD + ] ].

; ERB (31-10-96) See notes near n_wh_pro_le.
; where, when, how

pp_wh_le := non_affix_bearing &
  [ SYNSEM prep_p_mod_synsem &
      [ LOCAL [ CAT [ HEAD [ PRD bool,
			     MOD < [ LOCAL.CAT.HEAD v_or_g_or_a ] >,
                             KEYS.ALTKEY nom_rel ],
		      VAL.COMPS < >,
		      POSTHD +,
                      MC na,
                      HC-LEX - ],
		CONT [ RELS <! #key & [ ARG2 #objind,
                                        WLINK #wlink ],
			        [ PRED which_q_rel,
                                  ARG0 #objind,
                                  RSTR #rhand ],
			        nom_relation & #altkey &
                                [ LBL #nhand,
                                  ARG0 #objind,
                                  WLINK #wlink ] !>,
		       HCONS <! qeq &
			       [ HARG #rhand,
				 LARG #nhand ] !>,
                       MSG no_msg ],
                CONJ cnil ],
        LKEYS [ KEYREL #key & [ WLINK *cons* ],
                ALTKEYREL #altkey ],
        NONLOC [ QUE 1-dlist &
                        [ LIST < handle > ],
                    SLASH 0-dlist,
                    REL 0-dlist ],
        PUNCT no_punctuation ] ].
 
; 21-apr-04 - Removed STATIVE + from INDEX
pp_rel_le := non_affix_bearing &
  [ SYNSEM basic_lex_pp_synsem &
      [ LOCAL [ CAT [ HEAD [ PRD +,
			     MOD < [ LOCAL [ CAT vp_cat &
						 [ HEAD verb ],
					     CONJ cnil,
					     CONT.MSG #msg ],
                                     --SIND #event & event ] > ],
		      VAL.SPR < synsem & 
                                [ LOCAL local_min &
                                        [ CAT [ HEAD n_or_adv &
                                                     [ KEYS.KEY degree_rel ],
                                                VAL [ SPR *olist*,
                                                      COMPS < > ] ],
                                          CONT.HOOK [ LTOP #khand,
                                                      XARG #event ] ],
                                  NONLOC.QUE 0-dlist,
                                  OPT + ] >,
		      POSTHD +,
                      MC na,
                      HC-LEX - ],
                CONT [ HOOK [ LTOP #khand,
                              INDEX #event ],
		       RELS <! #key & [ ARG1 #event,
                                        ARG2 #objind ] !>,
		       HCONS <! !>,
                       MSG #msg & no_msg ],
                CONJ cnil ],
        LKEYS.KEYREL #key & [ LBL #khand,
                              WLINK *cons* ],
        NONLOC [ REL 1-dlist & [ LIST < [ INDEX #objind ] > ],
                    SLASH 0-dlist,
                    QUE 0-dlist ],
        PUNCT no_punctuation ] ].

; 'on vacation', 'in bed'

prep_p_mod_phr_synsem := prep_p_mod_synsem & phr_synsem.
prep_nomod_phr_synsem := phr_synsem &
  [ LOCAL [ CAT [ HEAD prep & [ TAM #tam,
                                MOD < > ],
                  VAL [ SUBJ < >,
                        COMPS #comps ] ],
            CONT.RELS.LIST < relation & [ PRED norm_rel,
                                          ARG0.E #tam ], ... >,
            ARG-S #comps ] ].

p_as_adj_le := msg_amalg_prep_word &
  [ INFLECTD +,
    SYNSEM basic_prep_nomod_synsem &
	   [ LOCAL 
             [ CAT [ HEAD [ KEYS.KEY _as_p_comp_rel,
                            PRD - ],
                     VAL [ SPR < unexpressed >,
                           COMPS < reg_adj_atrans_synsem &
                                   [ LOCAL [ CAT.VAL.COMPS 
                                             < unexpressed,
                                               unexpressed &
                                               [ LOCAL.CONT.HOOK.LTOP #mltop]>,
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #index ],
                                             CONJ cnil ],
                                     LEX +,
                                     NONLOC non-local_none ] > ],
                     HC-LEX - ],
               CONT [ HOOK [ LTOP #ltop,
                             INDEX #index ],
                      RELS <! basic_arg12_relation & [ PRED prep_rel],
                              [ PRED prpstn_m_rel,
                                LBL #mltop,
                                MARG #marg ],
                              arg1_relation &
                               [ LBL #ehand,
                                 PRED ellipsis_rel ] !>,
                      HCONS <! qeq & [ HARG #marg,
                                       LARG #ehand ] !> ],
               CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                         REL 0-dlist,
                         QUE 0-dlist ],
             LKEYS.KEYREL [ LBL #ltop,
                            ARG0.E [ TENSE nontense,
                                     ASPECT no_aspect ] ] ],
    POSSCL - ].

adv_comparison_spec_le := norm_no_affix_word &
  [ SYNSEM nomod_synsem &
	  [ LOCAL [ CAT [ HEAD adv & [ KEYS.KEY comparative_rel ],
			  VAL [ COMPS < >,
				SPR < >,
                                SPEC < [ LOCAL.CAT.HEAD n_or_adv ] > ] ],
                    CONT [ HOOK [ LTOP #hand,
                                  INDEX #inst ],
			   RELS <! #key &
				    [ LBL #hand,
				      C-ARG0 #inst ] !>,
                           HCONS <! !> ] ],
            LKEYS.KEYREL #key ] ].
			   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DETERMINERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Determiners must have the KEY relation be the quantifier, since nouns
; select their determiner in part based on the type of the quantifier rel.
; The basic determiner synsem has a non-null value for its specifier; this is 
; to account for cases like "nearly all books, only his book, exactly which
; book, almost every book".  
;
; Quantifiers need to accommodate expressions like
; 'almost every book'.  One might expect to have the degree_rel of 'almost'
; take the handle of 'every' as its ARG1 value, but this may interfere with 
; the treatment of scope which needs to identify the set of quantifier handles.
; So we do this by adding separate lexical entries for these det-specs.
; DPF 8-Jun-03 - Removed COMPS < > from basic_det_synsem, since want to allow
; possibility of non-empty comps (e.g. for "a/an" as in "an hour and a half"
; analogous to "as tall as kim"

basic_det_synsem := nomod_synsem &
  [ LOCAL [ CAT [ HEAD det & [ KEYS.KEY #pred ],
		  VAL [ SPR < [ LOCAL local_min &
                                      [ CAT.HEAD adv &
                                                 [ KEYS.KEY degree_rel ],
                                        CONT.HOOK [ LTOP #lbl,
                                                    XARG #arg0 ] ],
                                NONLOC [ QUE 0-dlist,
					    REL 0-dlist ],
				OPT + ] >, 
			SPEC < [ LOCAL [ CAT.HEAD.KEYS.ALTKEY #pred,
                                         CONT.HOOK [ LTOP #nhand,
                                                     INDEX #index ] ] ] > ] ],
	    CONT nom-obj &
		[ HOOK [ INDEX #index,
                         XARG #nhand ],
		  RELS.LIST < quant_or_wh_relation & #key &
                              [ PRED #pred,
                                ARG0 #index,
                                RSTR #rhand ], ... >,
                  HCONS.LIST < qeq &
				[ HARG #rhand,
				  LARG #nhand ], ... > ],
	    ARG-S < > ],
    LKEYS [ KEYREL #key,
            ALTKEYREL [ LBL #lbl,
                        ARG0 #arg0 ] ] ].

nonpart_det_synsem := basic_det_synsem.

det_synsem := nonpart_det_synsem.

part_det_synsem := basic_det_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

part_det_synsem_nonwh := part_det_synsem & 
  [ NONLOC.QUE 0-dlist ].

; DPF 21-Nov-01 - Removed BV..DIVISIBLE -* and AGR.DIVISIBLE -: last Christmas
next_last_det_synsem := nonpart_det_synsem &
  [ LOCAL [ CAT [ HEAD [ POSS -,
                         KEYS.KEY def_q_rel ],
                  VAL [ SPEC < [ LOCAL [ CAT [ HEAD.KEYS [ KEY temp_abstr_rel,
                                                           ALTKEY norm_rel ],
                                               VAL.COMPS < > ],
                                         CONT.HOOK.LTOP #nhand ],
                                 MODIFD notmod ] >,
                        COMPS < > ] ],
	    CONT [ RELS <! [ PRED def_q_rel,
                             ARG0 #ind & [ PNG png & [ PN 3sg ] ] ],
			    relation & #altkey &
			    [ LBL #nhand,
			      ARG1 #ind ] !>,
		   HCONS <! qeq !> ],
            AGR.PNG.PN 3sg ],
    MODIFD hasmod,
    LKEYS.ALTKEYREL #altkey ].

basic_det_word :< word.
abstr_det_word := basic_det_word & que_word.
det_word := abstr_det_word &
  [ SYNSEM det_synsem & [ LOCAL.CAT.HEAD.POSS - ] ].

; DPF 15-Apr-03 - ALTKEY allows most determiners to appear with day-part nouns
; like 'morning' as VP modifiers, as in 'i arrive every morning' but not
; 'I arrive the morning'
; DPF 06-dec-03 - Moved constraint PN 3sg down but leave DIV - so we can allow
; coordination in "every dog and cat" where the nbar is PN 3pl, but not
; constrained for DIV.  Still blocking "*every dogs"

det_word_sing := det_word & nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS 
                                            [ ALTKEY dofw_or_poss_q_rel ] ] >,
                     AGR.DIVISIBLE - ],
             LKEYS.KEYREL.ARG0.DIVISIBLE - ] ].

basic_det_word_nonque := det_word & nonque.
det_word_nonque := basic_det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             LKEYS [ KEYREL.LBL #lbl,
                     ALTKEYREL.LBL #lbl ] ] ].

det_pl_lexent := det_word_nonque &
  [ SYNSEM [ LOCAL [ AGR.PNG.PN 3pl,
                     CAT.HEAD.KEYS.ALTKEY dofw_or_poss_q_rel ],
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3pl ],
             MODIFD hasmod ] ].

det_pl_le := det_pl_lexent.

; 'another two chairs' but '*another chairs'
det_pl_modn_le := det_pl_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ MODIFD lmod ] > ].

det_sm_le := det_word_nonque &
  [ SYNSEM [ LOCAL.AGR.PNG.PN 3sg,
             LKEYS.keyrel.ARG0.PNG png & [ PN 3sg ],
	     MODIFD hasmod ] ].

; DPF 8-may-04 - Restricted SPEC..KEY to non_day_rel to block spurious parse 
; for "next tuesday"
det_next_le := abstr_det_word & nonque &
  [ SYNSEM next_last_det_synsem & 
	   [ LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.KEYS.KEY non_day_rel ] > ]].

det_last_le := abstr_det_word & nonque &
  [ SYNSEM next_last_det_synsem ].

; "yesterday morning, tomorrow afternoon"
det_yesterday_tomorrow_le := abstr_det_word & nonque &
  [ SYNSEM next_last_det_synsem & 
	   [ LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.KEYS.KEY day_part_rel] > ]].

; "all month", "all day" - FIX - not yet blocking "*all October, *all Tuesday"
det_all_temp_le := abstr_det_word & nonque &
  [ SYNSEM next_last_det_synsem ].

; DPF 20-Feb-01 - Use SPEC..ALTKEY to block det-N analysis of 
; "both kim and sandy"
; DPF 11-Mar-02 - Use ALTKEY to block phrasal partitive-NP rule

basic_pdet_word_nonque := abstr_det_word & nonque &
  [ SYNSEM part_det_synsem_nonwh &
      [ LOCAL [ CAT.HEAD.KEYS.ALTKEY dofw_or_poss_q_rel,
                CONT [ RELS.LIST < quant_or_wh_relation, ... >,
                       HCONS <! qeq !> ] ],
        MODIFD hasmod ] ].

pdet_word_nonque := basic_pdet_word_nonque &
  [ SYNSEM [ LOCAL.CONT.RELS <! relation !>,
             LKEYS [ KEYREL.LBL #lbl,
                     ALTKEYREL.LBL #lbl ] ] ].

det_part_le := pdet_word_nonque.

; DPF 19-Oct-02 - Would like to make DIV +* not + to allow coordination of 
; unlike NPs ("my book and some other stuff"), but then we can't block
; spurious "some programmer" whose DIV value ends up +_and_-.  An example
; of problems with this overspecification approach to coordination.

; some
det_part_div_le := pdet_word_nonque &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                        just_only_deg_rel ] >,
             LKEYS.KEYREL.ARG0.DIVISIBLE + ] ].

; For "another one/two (of the chairs)"
; Still don't have analysis for "another two chairs" (cf. "*another chairs")
det_part_another_le := pdet_word_nonque &
  [ SYNSEM 
    [ LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY just_only_deg_rel ] >,
                      SPEC < [ LOCAL.CAT.HEAD.KEYS.KEY part_nom_rel ] > ],
      LKEYS.KEYREL.ARG0.DIVISIBLE + ] ].

; DPF 06-dec-03 - Removed constraint PN 3sg but leave DIV - so we can allow
; coordination in "another time and date" where the nbar is PN 3pl, but not
; constrained for DIV.  Still blocking "*another chairs"
det_part_sg_le := pdet_word_nonque &
  [ SYNSEM [ LOCAL.AGR.DIVISIBLE -,
             LKEYS.KEYREL.ARG0.DIVISIBLE - ] ].

det_part_ms_lexent := pdet_word_nonque &
  [ SYNSEM [ LOCAL.AGR [ PNG.PN 3sg,
                         DIVISIBLE + ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3sg ],
                                 DIVISIBLE + ] ] ].
                   

det_part_ms_le :< det_part_ms_lexent.

det_part_ms_noagr_le := det_part_ms_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_quant_noagr_q_rel ].

det_part_ms_much_le := det_part_ms_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY this_that_deg_rel]>,
             LKEYS.KEYREL.PRED much_many_q_rel ] ].

det_part_pl_le := basic_pdet_word_nonque &
  [ SYNSEM [ LOCAL [ AGR.PNG.PN 3pl,
                     CONT [ RELS <! [ ARG0 #arg0 ],
                                    #altkeyrel &
                                    [ LBL #lbl,
                                      ARG1 #arg0 ] !>,
                            HCONS <! [ LARG #lbl ] !> ] ],
             LKEYS [ KEYREL [ PRED udef_q_rel,
                              ARG0.PNG png & [ PN 3pl ] ],
                     ALTKEYREL #altkeyrel ] ] ].

det_part_pl_both_le := basic_pdet_word_nonque &
  [ SYNSEM [ LOCAL [ AGR.PNG.PN 3pl,
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3pl ] ] ].

; This assumes (falsely) that all plurals are divisible (cf "oats", "clothes")
; It also incorrectly blocks coordinations like "Kim and all children" since 
; the alternative (DIVISIBLE +) would fail to block "all book".
; DPF 28-oct-03 - Added LEX + to block e.g. "a person all of us" as hd-spec.
; DPF 01-may-04 - Changed SPR..KEY from very_deg_rel to just_only_deg_rel

det_part_pl_mass_lexent := pdet_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY just_only_deg_rel,
                                     LEX + ] >,
                     AGR.DIVISIBLE + ],
             LKEYS.KEYREL.ARG0.DIVISIBLE +,
             MODIFD hasmod ] ].

det_part_pl_mass_le := det_part_pl_mass_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_quant_agr_q_rel ].

det_part_pl_mass_unsp_le := det_part_pl_mass_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_q_rel ].

det_part_pl_mass_noagr_le := det_part_pl_mass_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_quant_noagr_q_rel ].

det_part_unsp_le := abstr_det_word &
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD.POSS -,
		     CONT [ RELS <! quant_or_wh_relation !>,
			    HCONS <! qeq !> ] ],
	     NONLOC.QUE 1-dlist &
		           [ LIST < handle > ],
             LKEYS.KEYREL.PRED which_q_rel ] ].

pdet_word_pl_mass_wh := abstr_det_word &
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD [ POSS -,
                                KEYS [ KEY udef_q_rel,
                                       ALTKEY basic_nom_rel ] ],
                     CONT [ HOOK.INDEX #mainind,
                            RELS <! [ PRED udef_q_rel ],
                                  [ PRED which_q_rel,
                                    ARG0 #index,
                                    RSTR #rhand ],
                                  diadic_nom_relation & #altkey &
				   [ LBL #nhand,
                                     PRED unspec_diadic_nom_rel,
                                     ARG0 #index ],
                                  prep_notense_relation &
                                  [ LBL #nhand, 
                                    PRED unspec_rel,
                                    ARG1 #mainind,
                                    ARG2 #index ] !>,
			    HCONS <! qeq,
                                     qeq &
                                   [ HARG #rhand,
                                     LARG #nhand ]!> ] ],
             LKEYS.ALTKEYREL #altkey,
             NONLOC.QUE 1-dlist &
		           [ LIST < handle > ] ] ].

det_part_ms_wh_le := pdet_word_pl_mass_wh &
  [ SYNSEM [ LOCAL [ AGR [ PNG.PN 3sg,
                           DIVISIBLE + ],
                     CAT.HEAD.KEYS.ALTKEY quantity_rel ],
             LKEYS [ KEYREL.ARG0 [ PNG png & [ PN 3sg ],
                                     DIVISIBLE + ],
                     ALTKEYREL.PRED quantity_rel  ] ] ].

det_part_pl_wh_le := pdet_word_pl_mass_wh &
  [ SYNSEM [ LOCAL [ AGR.PNG.PN 3pl,
                     CAT.HEAD.KEYS.ALTKEY number_rel ],
             LKEYS [ KEYREL.ARG0.PNG png & [ PN 3pl ],
                     ALTKEYREL.PRED number_rel ] ] ].
                   
; DPF 10-May-00 - We add subtypes of determiners to distinguish "We met every 
; week" from "*We met the week".  The distinction makes use of the feature 
; MODIFD, where the head-specifier rule's mother's MODIFD value is 
; determined by the specifier daughter, so each specifier has to say whether it
; passes on the MODIFD value from its head, or supplies its own.  Thus "the"
; assigns its own value,"every" supplies its own 'hasmod' 
; value, and "a" supplies the opposite value "notmod", to block "*Kim arrived 
; a big week".

; 'no'
det_no_le := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.KEYS.ALTKEY dofw_or_poss_q_rel,
                         VAL.SPEC < [ MODIFD #modif ] > ],
             LKEYS.KEYREL.PRED no_q_rel,
             MODIFD #modif ] ].


; 'some'
det_nondiv_le := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.KEYS.ALTKEY dofw_or_poss_q_rel,
                         VAL.SPEC < [ MODIFD #modif ] > ],
             LKEYS.KEYREL [ PRED some_q_rel,
                            ARG0.DIVISIBLE - ],
             MODIFD #modif ] ].

; 'the'
; DPF 2-May-03 - Divide this type into two subtypes, one [MODIFD notmod]
; and one [MODIFD lmod] to support the treatment of VP-modifying NPs with
; the following pattern of grammaticality:
;   Kim arrived the first week
;  *Kim arrived the week
;   Kim arrived the week Sandy left
;   Kim arrived the week of the party
;  *Kim arrived week of the party

; DPF 03-dec-03 - Replaced ALTKEYREL.PRED no_rel with dofw_or_poss_q_rel in
; order to get "on the weekend".  But then get two parses for "the night",
; so go back to no_rel.

det_the_lexent := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.KEYS.ALTKEY no_rel,
                         VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                             just_only_deg_rel ] > ],
             LKEYS [ KEYREL.PRED def_explicit_q_rel,
                     ALTKEYREL.PRED no_rel ] ] ].

; DPF 27-May-03 - See discussion in syntax.tdl's npadv_mod_rule for why we
; considered and then abandoned two separate entries for "the".

det_the_le := det_the_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC < [ MODIFD #mod ] >,
             MODIFD #mod ] ].

; 'half the time'
det_word_modable := det_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.ALTKEY dofw_or_poss_q_rel,
                           VAL.COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             MODIFD hasmod ] ].

det_wh_le := det_word_modable &
  [ SYNSEM [ LKEYS.KEYREL [ LBL #hand,
                            PRED which_q_rel ],
	     NONLOC.QUE 1-dlist &
			   [ LIST < #hand > ] ] ].

det_modable_le := det_word_modable & nonque.

; 'a/an'
; DPF 15-Nov-01 - Removed [SPR <anti_synsem_min>] since this blocke "more than 
; a week ago"

det_sg_nomod_lexent := det_word_sing &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR
                        < [ LOCAL.CAT.HEAD.KEYS.KEY just_only_deg_rel ] >,
                               COMPS < > ],
                     AGR.PNG.PN 3sg,
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ], 
             MODIFD notmod,
             LKEYS.KEYREL [ PRED some_q_rel,
                            ARG0 [ PNG png & [ PN 3sg ] ] ] ] ].

det_sg_nomod_a_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con ] > ].

det_sg_nomod_an_le := det_sg_nomod_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc ] > ].

; For robust a/the lex-entry
det_sg_nomod_le :=  det_sg_nomod_lexent.

; 'every'
det_sg_lexent := det_word_sing &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR 
                                < [ LOCAL.CAT.HEAD.KEYS.KEY very_deg_rel ] >,
                               COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             MODIFD hasmod,
             LKEYS [ KEYREL.LBL #lbl,
                     ALTKEYREL.LBL #lbl ] ] ].

det_sg_every_le := det_sg_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR 
                        < [ LOCAL.CAT.HEAD.KEYS.KEY just_only_very_deg_rel ] >,
             LKEYS.KEYREL.PRED every_q_rel ] ].

det_sg_some_le := det_sg_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED some_q_rel ].

det_compar_lexent := basic_det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL [ CAT [ HEAD prep &
                                                        [ KEYS.KEY 
                                                          selected_rel ],
                                                       VAL.COMPS < > ],
                                                 CONT.HOOK [ LTOP #hand,
                                                             INDEX #arg2 ],
                                                 CONJ cnil ],
                                         NONLOC non-local_none,
                                         PUNCT.LPUNCT no_punct ] >,
                               SPR < [ LOCAL.CAT.HEAD.KEYS 
                                            [ KEY very_deg_rel,
                                              ALTKEY dofw_or_poss_q_rel ] ] >,
                               SPEC < [ LOCAL.CONT.HOOK.LTOP #hand ] > ],
                     AGR.DIVISIBLE +,
                     CONT [ HOOK.INDEX #ind,
                            RELS <! relation,
                                    [ LBL #hand,
                                      PRED comp_rel,
                                      ARG1 #ind,
                                      ARG2 #arg2 ] !>,
                            HCONS <! qeq !> ] ],
             MODIFD hasmod ] ].

det_more_le := det_compar_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep &
                                                  [ KEYS.KEY 
                                                     _than_p_compar_rel ] ] >].

det_the_same_le := det_compar_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep &
                                                  [ KEYS.KEY 
                                                     _as_p_comp_rel ] ] >].

;; We make the non-quantifier relation generically pron_rel, and have each
;; individual pronoun simply constrain the ARG0 index of that pron_rel.
;;   This type is used for both WH "whose" and relative "whose", so it leaves 
;; both  QUE  and  REL  values unspecified, but supplies all other defaults.

poss_word := nonconj & non_affix_bearing & nonslash & nonmsg & 
	     mcna & basic_det_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.POSS +,
                         VAL.COMPS < > ],
		   CONT nom-obj &
			[ HOOK.INDEX #index,
			  RELS.LIST < relation,
                                      prep_relation &
                                      [ PRED basic_poss_rel,
                                        ARG2 #index ], ... > ] ] ].

; ERB (31-10-96) See notes near n_wh_pro_le.

det_wh_poss_le := poss_word & nonrel &
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CAT [ HEAD.KEYS.KEY def_q_rel,
                           VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #nhand ] > ],
		     CONT [ RELS <! #key & [ PRED def_q_rel ],
				    prep_relation &
                                    [ LBL #nhand,
                                      PRED pro_poss_rel,
                                      ARG1 #ind ],
				    [ LBL #phand,
                                      PRED person_rel,
                                      ARG0 #ind ],
                                    [ ARG0 #ind,
                                      PRED which_q_rel,
                                      RSTR #rhand2 ] !>,
			    HCONS <! qeq, 
                                     qeq &
                                     [ HARG #rhand2,
                                       LARG #phand ] !> ] ],
             LKEYS.KEYREL #key,
	     NONLOC.QUE 1-dlist &
			   [ LIST < handle > ] ] ].

; DPF 17-dec-03 - Added HS-LEX + to avoid sentence "*about my arrives"

nonwh_poss_word := poss_word & nonque &
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CAT [ HEAD.KEYS.KEY def_explicit_q_rel,
                           VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                just_only_deg_rel ] >,
                           HS-LEX + ],
                     CONT [ RELS.LIST < relation, #altkey, ... >,
                            HCONS.LIST < qeq, ... > ] ],
             LKEYS [ KEYREL.PRED def_explicit_q_rel,
                     ALTKEYREL #altkey ] ] ].

det_poss_lexent := nonwh_poss_word & nonrel &
  [ SYNSEM.LOCAL [ CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #hand ] >,
		   CONT [ RELS <! relation & [ WLINK #wlink ],
                                  prep_relation &
                                  [ LBL #hand,
                                    PRED pro_poss_rel,
                                    ARG1 #ind ],
                                  [ PRED pronoun_q_rel,
                                    RSTR #rhand,
                                    ARG0 #ind ],
				  [ LBL #prohand,
                                    PRED pron_rel,
                                    WLINK #wlink,
                                    ARG0 #ind &
                                        [ PRONTYPE std_pron,
                                          SORT entity ] ] !>,
                          HCONS <! qeq, qeq & [ HARG #rhand,
                                                LARG #prohand ] !> ] ] ].

det_poss_her_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
                             [ ARG0 [ PNG png & [ PN 3sg,
                                                  GEN fem ],
                                      PRONTYPE std_pron ] ] !> ].
det_poss_his_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3sg,
						    GEN masc ],
					PRONTYPE std_pron ] ] !> ].

; DPF 26-sept-04 - Temporary solution until we add determiner coordination,
; at least.
det_poss_his_her_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
                             [ ARG0 [ PNG png & [ PN 3sg,
                                                  GEN andro ],
                                      PRONTYPE std_pron ] ] !> ].

det_poss_its_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3sg,
						    GEN neut ],
					PRONTYPE std_pron ] ] !> ].
det_poss_its_robust_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3sg,
						    GEN neut ],
					PRONTYPE std_pron ] ] !>,
    ROBUST + ].

det_poss_my_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1sg ],
					PRONTYPE std_pron ] ] !> ].
det_poss_our_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1pl ],
					PRONTYPE std_pron ] ] !> ].
det_poss_their_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3pl ],
					PRONTYPE std_pron ] ] !> ].
det_poss_your_le := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 2per ],
					PRONTYPE std_pron ] ] !> ].

det_rel_poss_le := nonwh_poss_word &
  [ SYNSEM [ LOCAL.CONT [ RELS <! relation,
                                  prep_relation &
                                [ LBL #hand,
                                  PRED poss_rel,
                                  ARG1 #ind ] !>,
                          HCONS <! qeq !> ],
	     NONLOC.REL 1-dlist &
			   [ LIST < [ LTOP #hand,
				      INDEX #ind ] > ] ] ].


; 'of mine'
det_nospec_synsem := nomod_synsem.
det_poss_nospec_lexent := poss_word & nonrel &
  [ SYNSEM det_nospec_synsem &
           [ LOCAL [ CAT [ HEAD det,
                           VAL [ SPR < anti_synsem_min >,
                                 SPEC < anti_synsem_min >,
                                 COMPS < > ] ],
                     CONT [ HOOK [ INDEX #arg2,
                                   XARG #hand ],
                            RELS <! [ PRED pronoun_q_rel,
                                      RSTR #rhand,
                                      ARG0 #ind ],
                                  [ LBL #hand,
                                    PRED pro_poss_rel,
                                    ARG1 #ind,
                                    ARG2 #arg2 ],
                                  [ LBL #prohand,
                                    PRED pron_rel,
                                    ARG0 #ind &
                                        [ PRONTYPE std_pron,
                                          SORT entity ] ] !>,
                          HCONS <! qeq & [ HARG #rhand,
                                           LARG #prohand ] !> ] ],
             NONLOC non-local_none ] ].

det_poss_nospec_mine_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, 
                              [ ARG0.PNG.PN 1sg ] !> ].

det_poss_nospec_ours_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, 
                              [ ARG0.PNG.PN 1pl ] !> ].

det_poss_nospec_yours_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, 
                              [ ARG0.PNG.PN 2per ] !> ].

det_poss_nospec_his_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, 
                              [ ARG0.PNG [ PN 3sg,
                                           GEN masc ] ] !> ].

det_poss_nospec_hers_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, 
                              [ ARG0.PNG [ PN 3sg,
                                           GEN fem ] ] !> ].

det_poss_nospec_theirs_le := det_poss_nospec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, 
                              [ ARG0.PNG.PN 3pl ] !> ].


; 'preposition' "a/an" for predicative NPs, as in "It is a (real/rare) 
; pleasure to visit Oslo" and "Oslo is a pleasure to visit"

pred_a_prep_lexent := word &
  [ SYNSEM synsem &
    [ LOCAL [ CAT [ HEAD prep &
                         [ PRD +,
                           MOD < anti_synsem &
                                 [ LOCAL intersective_mod ] >,
                           TAM #tam & [ TENSE tense,
                                        ASPECT.STATIVE + ],
                           KEYS.KEY pred_a_rel ],
                    VAL [ SPR < >, 
                          SUBJ < >,
                          COMPS < [ LOCAL [ CAT 
                                             [ HEAD noun &
                                                    [ KEYS.KEY prednom_rel,
                                                      POSS - ],
                                               VAL [ SUBJ < >,
                                                     COMPS < > ],
                                               MC na ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #index,
                                                        XARG #xarg ] ],
                                    OPT - ] > ],
                    MC na ],
              CONT [ HOOK [ LTOP #ltop,
                            INDEX #event & event & [ E #tam ],
                            XARG #xarg ],
                     RELS <! #key & quant_or_wh_relation, 
                             arg1_relation & 
                             [ LBL #ltop,
                               PRED "prednom_state_rel",
                               ARG0 #event,
                               ARG1 #index ] !>,
                     HCONS <! qeq &
                             [ HARG #rhand,
                               LARG #nhand ] !> ],
              CONJ cnil,
              ARG-S < > ],
      LKEYS.KEYREL #key & [ PRED some_q_rel,
                            ARG0 #index,
                            RSTR #rhand ],
      NONLOC [ SLASH 0-dlist,
               QUE 0-dlist,
               REL 0-dlist ] ],
    INFLECTD + ].

pred_a_prep_le := pred_a_prep_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET con ] > ].

pred_an_prep_le := pred_a_prep_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET voc ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Free relatives
;
; One crucial property of free relatives is that they have a non-empty QUE
; value whose single list element is an index (rather than the handle which
; is employed for ordinary question WH-words).
; The other is that they encode the constraints for their S/XP sister in the
; free-relative construction, in their SLASH attribute.

free_rel_pro_word := nonconj & non_affix_bearing & mcna & nonrel & nonmsg &
		     hc-to-phr & basic_pronoun_word &
  [ SYNSEM synsem &
	   [ LOCAL [ CAT.VAL [ SPR < >,
			       SUBJ < >,
			       COMPS < > ],
		     AGR #ind,
		     CONT [ HOOK [ INDEX ref-ind & #ind & [ PNG.PN 3sg ],
                                   XARG #nhand ],
			    RELS.LIST < [ PRED basic_free_relative_q_rel,
                                          ARG0 #ind,
                                          RSTR #rhand ], 
                                        [ LBL #nhand,
                                          ARG0 #ind ], ... >,
			    HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !> ],
		     ARG-S < > ],
	     NONLOC [ REL 0-dlist,
                      QUE 1-dlist & <! #ind !>,
                      SLASH 1-dlist &
                          <! [ CAT.VAL.COMPS < >,
                               CONJ cnil ] !> ] ] ].

; whatever, whoever
; DPF 20-Aug-01 - Added SLASH..PRD - to block "what my offers are" with 
; predicative copula.

n_freerel_pro_lexent := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD noun &
			      [ MOD < >,
				PRD -,
                                KEYS [ KEY reg_nom_rel & #pred,
                                       ALTKEY free_relative_ever_q_rel ] ],
		     CONT [ HOOK.INDEX #ind,
                            RELS <! relation & #altkey, #key !> ] ],
             LKEYS [ KEYREL #key & [ PRED #pred ],
                     ALTKEYREL #altkey ],
	     NONLOC.SLASH 1-dlist &
                   <! [ CAT.HEAD noun & [ MOD < >,
                                          PRD - ],
                        CONT.HOOK.INDEX #ind,
                        AGR ref-ind & [ PNG.PN 3sg ] ] !> ] ].

n_freerel_pro_le := n_freerel_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_q_rel ].
                                          
n_freerel_ever_pro_le := n_freerel_pro_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel ].

; when, where
; DPF 15-Apr-02 - Added SLASH..VAL.SUBJ..INDEX #arg to accommodate predicative
; 'be' as in "Find where Kim is"
; DPF 19-Oct-02 - Removed PRD - since need to allow head_adj_phr to have 
; adjunct be PRD +.

n_freerel_pro_adv_lexent := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD noun &
			      [ MOD < >,
                                KEYS [ KEY #keypred,
                                       ALTKEY nonpro_rel,
                                       ALT2KEY prep_mod_rel ] ],
		     CONT.RELS <! relation, 
                                   #key & [ ARG0 #ind ],
                                   #alt2key &
                                   [ LBL #lochand,
                                     PRED prep_mod_rel,
                                     ARG0 [ E [ TENSE no_tense,
                                                 ASPECT no_aspect ] ],
                                     ARG1 #arg,
                                     ARG2 #ind ] !> ],
             LKEYS [ KEYREL #key & [ PRED #keypred ],
                     ALTKEYREL #key,
                     ALT2KEYREL #alt2key ],
	     NONLOC.SLASH 1-dlist &
                   <! [ CAT.HEAD prep & 
                                 [ MOD < synsem &
                                         [ --SIND #arg ] > ],
                        CONT.HOOK [ LTOP #lochand,
                                    XARG #arg ] ] !> ] ].

n_freerel_pro_adv_le := n_freerel_pro_adv_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_q_rel ].

n_freerel_ever_pro_adv_le := n_freerel_pro_adv_lexent &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel ].

; DPF 10-jul-04 - Replacing SLASH..HEAD n_or_p with noun since we don't want
; an extracted adjunct reading for e.g. "kim chases whichever cats bark".
; To still get "kim stays at whichever place he lands", maybe we have to
; make two separate entries for "whichever" - one a simple determiner
; which would in principle allow either NP or PP (maybe appropriately
; constrained ...), and the other the partitive which only allows NP slash.
; FIX ...

free_rel_det_word_gen := nonconj & non_affix_bearing & mcna & nonrel & nonmsg &
		     hc-to-phr &
  [ SYNSEM basic_det_synsem & 
	   [ LOCAL [ CAT [ HEAD.POSS -,
			   VAL [ SPEC < [ LOCAL.CONT.HOOK.LTOP #althand ] >,
                                 COMPS < > ] ],
                     CONT [ RELS <! [ PRED basic_free_relative_q_rel,
                                      ARG0 #arg0 ] !>,
			    HCONS <! qeq !> ] ],
             LKEYS.ALTKEYREL.LBL #althand,
	     NONLOC [ QUE 1-dlist &
			     [ LIST < index  > ],
			 SLASH 1-dlist &
			     <! [ CAT.HEAD noun & [ MOD < > ],
                                  CONT.HOOK.INDEX #arg0 ] !> ] ] ].

; whatever, what
; DPF 25-Nov-03 - Removed [SLASH..CASE acc] since also want "whichever books
; arrived".

det_freerel_le := free_rel_det_word_gen &
  [ SYNSEM det_synsem & 
           [ LOCAL [ CAT [ HEAD [ POSS -,
                                  KEYS.ALTKEY no_rel ],
                           VAL.COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !> ] ],
             LKEYS.ALTKEYREL.PRED no_rel ] ].

; whichever
n_freerel_part_le := free_rel_det_word_gen &
  [ SYNSEM part_det_synsem ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Possessives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Possessive "'s" takes an NP[-Poss] specifier and projects either an
;; NP[+Poss] phrase (for "the book of Kim's") or a DetP[+Poss] phrase (for
;; "Kim's book").  Either way, the content of the possessive phrase will be a
;; definite possessive quantifier.  The NP[+Poss] things also work pretty well
;; for things like "Kim's is under the desk" if we allow governed NPs to be
;; +Poss.  The tricky thing will be figuring out exactly where `bare
;; possessives' can show up.  Also, we need to add the restriction that the SPR
;; must be non-pronominal.  We cannot simply make the synsem of the SPR be
;; the type nonpronominal, since that NP might be either lexical or phrasal,
;; distinguished by the synsem types lex_synsem and phr_synsem.  So we use
;; the semantic KEY relation to identify nonpronominals.

;; Another question is what do we do with the scope
;; of quantifiers in the possessor?  This entry assumes that they always have
;; narrow scope.  That should be an empirical question, as the saying goes.
; DPF 10-oct-04 - Added SPR..CASE non_obliq constraint to exclude reflexive 
; pronouns as in "*ourselves's chairs arrived", while still allowing
; reciprocals, as in "we hired each other's consultants."
; DPF 18-Nov-04 - Added SPR..PRD + to require that proper NPs be INFLECTD +,
; possible since the proper_np rule identifies PRD and INFLECTD.  This is
; needed since proper-NPs need to be [INFLECTD -] for NP-N-cmpnd rule which
; is also used for measure-NP compounds like "ten foot wall" (cf "*ten feet
; wall"); and further, the hspechc rule must leave the non-hd-dtr unspecified
; for INFLECTD since this rule is used to build "ten foot high (wall)", as
; well as the possessive phrase "kim 's".  Since the value of SPR is a list
; of synsems (with no access to the INFLECTD value), we smuggle in the
; needed constraint by coercing the otherwise unused feature PRD on proper
; NPs (note in defense that this same identity of PRD and INFLECTD is used
; legitimately in measure-NPs).

#|
n_poss_clitic_lexent := mcna & nonconj & nonmsg & non_affix_bearing &
  [ SYNSEM lex_synsem &
     [ LOCAL [ ARG-S < #spr >,
	       CAT [ HEAD det &
			  [ POSS +,
                            MOD < >,
                            KEYS [ KEY def_explicit_q_rel,
                                   ALTKEY poss_rel ] ],
		     VAL [ SUBJ < >,
                           SPR < #spr & synsem &
				 [ LOCAL [ CAT nomp_cat_min &
                                               [ HEAD [ KEYS.KEY nonpro_rel,
                                                        PRD + ] ],
                                           CONJ cnil ],
				   NONLOC [ SLASH #slash,
					       REL #rel,
					       QUE #que ],
                                   --SIND #pindex & individual_min,
                                   OPT - ] >,
			   COMPS < >,
			   SPEC < [ LOCAL.CONT.HOOK [ LTOP #phand,
                                                      INDEX #index ] ] > ] ],
	       CONT [ HOOK [ INDEX #index,
                             XARG #phand ],
		      RELS <! #key & [ PRED def_explicit_q_rel,
                                       ARG0 #index,
                                       RSTR #rhand ],
                              #altkey & prep_relation &
                                        [ LBL #phand,
                                          PRED poss_rel,
                                          ARG1 #pindex,
                                          ARG2 #index ] !>,
		      HCONS <! qeq & [ HARG #rhand,
                                       LARG #phand ] !> ] ],
       LKEYS [ KEYREL #key,
               ALTKEYREL #altkey ],
       NONLOC [ SLASH #slash,
		   REL #rel,
		   QUE #que ] ] ].
|#

basic_n_poss_clitic_lexent := mcna & nonconj & nonmsg & non_affix_bearing &
  [ SYNSEM lex_synsem &
     [ LOCAL [ ARG-S < #spr >,
	       CAT [ HEAD det &
			  [ POSS +,
                            MOD < >,
                            KEYS.ALTKEY poss_rel ],
                     VAL [ SUBJ < >,
                           SPR < #spr & synsem &
                                 [ LOCAL [ CAT nomp_cat_min &
                                               [ HEAD [ KEYS.KEY nonpro_rel,
                                                        PRD + ] ],
                                           CONJ cnil ],
                                   NONLOC [ SLASH #slash,
                                            REL #rel,
                                            QUE #que ],
                                   --SIND #pindex & individual_min,
                                   OPT - ] >,
                           COMPS < >,
                           SPEC < [ LOCAL.CONT.HOOK [ LTOP #phand,
                                                      INDEX #index ] ] > ] ],
               CONT.HOOK [ INDEX #index,
                           XARG #phand ] ],
       LKEYS.ALTKEYREL prep_relation &
             [ LBL #phand,
               PRED poss_rel,
               ARG1 #pindex,
               ARG2 #index ],
       NONLOC [ SLASH #slash,
		   REL #rel,
		   QUE #que ] ] ].

n_poss_clitic_lexent := basic_n_poss_clitic_lexent &
  [ SYNSEM lex_synsem &
     [ LOCAL [ CAT.HEAD.KEYS.KEY def_explicit_q_rel,
	       CONT [ RELS <! #key & [ PRED def_explicit_q_rel,
                                       ARG0 #index,
                                       RSTR #rhand ],
                              #altkey !>,
		      HCONS <! qeq & [ HARG #rhand,
                                       LARG #phand ] !> ] ],
       LKEYS [ KEYREL #key,
               ALTKEYREL #altkey & [ LBL #phand,
                                     ARG2 #index ] ] ] ].

n_poss_clitic_le := n_poss_clitic_lexent.
n_poss_clitic_pl_le := n_poss_clitic_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --SIND.PNG.PN 3pl ] > ].

n_poss_clitic_noquant_le := basic_n_poss_clitic_lexent &
  [ SYNSEM lex_synsem &
     [ LOCAL [ CAT [ HEAD.KEYS.KEY implicit_q_rel,
                     VAL.SPEC < anti_synsem > ],
	       CONT [ RELS <! #altkey !>,
		      HCONS <!  !> ] ],
       LKEYS.ALTKEYREL #altkey ] ].

;; The possessive "of" takes an NP[+Poss] complement (e.g., "Kim's", "mine")
;; and modifies an N'[-Poss].  Unfortunately, the way the hierarchy of
;; preposition types is built, there wasn't any type this could inherit from.
;; We could probably rearrange things so this inherits some preposition
;; properties, but right now I'm too lazy.  Also, somehow we'll have to make
;; sure that this doesn't modify a pronoun.  The semantic manipulation here is
;; tricky - keep your eyes on the definite quantifier.  This def_q_rel provided
;; by the apostrophe-s (for its other life as a determiner), is dropped by the
;; possessive-of, analogous to nouns, verbs, and adjectives dropping the
;; semantics of the prepositions that can mark their complements.  This
;; dropping of the relation is effected by having the possessive-of neglect to
;; grab the handle of the def_q_rel for its complement, but grab instead the
;; handle (and instance variable) of the NP complement of the apostrophe-s.
;; Then the general semantic pruning mechanism will ignore the def_q_rel, since
;; its handle will not be a value in any other relation.

one_arg_isect := one_arg & isect_synsem.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBORDINATING CONJUNCTIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; These are not restricted to modifying only main VPs, since e.g. "if" needs
; to take scope over modals as in "I'd be pleased if we made an appointment."
; This lack of constraint means there will be structural ambiguity for 
; if-clauses, but not spurious - get different scopes of "if" and modals.
; But we restrict them to modifying only finite VPs or imperatives.

; DPF (10-Jan-99) Changed these to modify S rather than VP, since they don't
; appear to survive extraction from embedded clauses, nor do they appear inside
; an extraposed subject relative clause.

; DPF (10-Jan-98) For some reason, can't make the HEAD value prep* - fails to
; unify with strict_type in "Kim sleeps if Sandy sleeps".  Solve later.

; DPF 02-Oct-00 Changed subconj_inf_synsem to modify S rather than VP, in 
; order to make semantics consistent with other subord rels.

; DPF 26-Apr-03 Our analysis prevented subordinating phrases from modifying
; embedded clauses, but clearly we need these for examples like "I wonder
; whether Sandy arrived before Kim left".  So relax MOD..CAT to s_cat_unspec
; and make the subord's MSG be that of its modifiee, to block e.g.
; "*I wonder Kim arrived before Sandy left".  And further relax MOD..CAT to
; allow modification of infinitival VPs as in "Kim didn't want to leave before
; Sandy arrived", which means also dropping [ MOD..E.TENSE real_tense].
; DPF 17-Jul-03 - Removed PRD - since it blocks "Kim arrives two weeks after
; Sandy leaves", given our analysis of measure-NPs.  Not clear what it wss for.
; DPF 22-Nov-03 - Removed MOD..SLASH 0-dlist since want to also get "the chair
; (that) I'll buy if you like it is expensive" and "who did you say Kim would
; hire if we were supportive".
; DPF 25-Nov-03 - Added MOD..LPERIPH na_or_- to avoid spurious disc_adv reading
; for "hiring kim and firing sandy happened"
; DPF 7-Jun-04 - This constraint prevented desired analysis for "if kim 
; arrives then sandy arises", so instead only use it in subjconj_vp rule.
; DPF 18-jul-04 - Removed constraint of MOD..MSG message to allow these to
; modify VPs as well as S's, to get e.g. "I found a book to read before 
; Abrams arrives"
; DPF 26-mar-05 - Restricting MOD.HEAD to verbal blocked modification of
; verbal gerunds, such as "safe practices for using a phone while driving",
; so changed to HEAD v_or_g.  Also removed MOD..LEX - since this prevented
; "for singing while driving"

basic_subconj_synsem := canonical_lex_or_phrase_synsem &
  [ LOCAL [ CAT [ HEAD prep &
		       [ MOD < synsem &
                               [ LOCAL scopal_mod &
				       [ CAT [ HEAD v_or_g,
					       VAL [ SUBJ *cons*,
                                                     COMPS < > ],
					       MC #mc ],
					 CONT [ HOOK [ LTOP #modltop,
                                                       INDEX #ind ],
                                                MSG #msg ],
                                         CONJ cnil ] ] >,
                         KEYS.KEY subord_rel ],
		  VAL [ SUBJ < >,
			SPR < [ LOCAL local_min &
                                  [ CAT [ HEAD n_or_adv &
                                          [ KEYS.KEY just_only_deg_rel ],
                                          VAL.SPR *olist* ],
                                    CONT.HOOK.LTOP #sltop ],
                                NONLOC.QUE 0-dlist,
                                OPT + ] > ],
                  MC #mc ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #ind ],
		   RELS.LIST < subord_relation &
                                [ LBL #sltop,
                                  MAIN #modltop ],
                                message &
                                [ LBL #ltop,
                                  PRED prpstn_m_rel,
                                  MARG #sltop ], ... >,
                   MSG #msg ] ] ].

basic_onearg_subconj_synsem := basic_subconj_synsem & basic_one_arg &
                               lex_synsem &
  [ LOCAL [ ARG-S #comps,
            CAT.VAL.COMPS #comps & < synsem &
                                     [ LOCAL.CAT.HEAD.KEYS.KEY #ckey,
                                       NONLOC [ SLASH 0-dlist,
                                                   REL 0-dlist,
                                                   QUE 0-dlist ],
                                       ROOT -,
                                       OPT -,
                                       PUNCT.LPUNCT no_punct ] >,
            CONT.RELS.LIST.FIRST #keyrel ],
    LKEYS [ KEYREL #keyrel,
            --COMPKEY #ckey ] ].

subconj_cp_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.MC -,
                                      CONT [ HOOK [ LTOP #cltop,
                                                    INDEX event ],
                                             MSG message &
                                              [ PRED propositional_m_rel ] ] ],
                              NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                          QUE 0-dlist,
                                          REL 0-dlist ] ] >,
            CONT [ RELS <! relation &
                           [ SUBORD #cltop ],
                         relation !>,
                   HCONS <! !> ] ] ].

subconj_synsem := subconj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin,
                            --SIND.E.TENSE real_tense ] > ].

subconj_cp_nocop_synsem := subconj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD frag &
                                             [ TAM.TENSE no_tense ],
                                        VAL [ SUBJ *olist*,
                                              SPR *olist*,
                                              COMPS < > ] ] ] > ].

subconj_inf_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT s_cat_fin_or_imp ] >,
                  VAL.COMPS < [ LOCAL 
                                [ CAT vp_bse_cat &
                                 [ VAL [ SUBJ < unexpressed_reg >,
                                         SPR *olist* ] ],
                                  CONT [ HOOK [ LTOP #vpltop,
                                                INDEX event &
                                                [ E [ TENSE no_tense,
                                                      MOOD ind_or_mod_subj ] ],
                                                XARG #sind ],
                                         MSG no_msg ] ] ] > ],
            CONT [ RELS <! subord_relation & [ SUBORD #cltop ],
                           message,
                           message & [ LBL #cltop,
                                       PRED prpstn_m_rel,
                                       MARG #marg ],
                           [ PRED pronoun_q_rel,
                             RSTR #rhand,
                             ARG0 #sind ],
                           [ LBL #prohand,
                             PRED pron_rel,
                             ARG0 #sind &
                                 [ PRONTYPE zero_pron,
                                   SORT entity ] ] !>,
                   HCONS <! qeq & [ HARG #marg,
                                    LARG #vpltop ],
                            qeq & [ HARG #rhand,
                                    LARG #prohand ] !> ] ] ].

; DPF 2/6/02 - Changed COMPS..SPR synsem to synsem_min in order to support 
; e.g. 'I slipped while dancing'
; DPF 5/20/02 - Cannot require that COMPS..SUBJ..INDEX be re-entrant with
; the MOD..AGR, since get sentences like "There are age restrictions when
; renting a car" where the AGR is there_expl, but the INDEX is ref-ind.  
; So the subject of the predicative phrase must be discourse-bound.
; DPF 30-May-02 - TO DO - constrain complement to be non-temporal, to allow
; "when there" but block "when Tuesday".
; DPF 3-May-03 - Made [COMPS..MOD..HEAD noun] to avoid some of the  spurious 
; ambiguity for e.g. "Kim knows when to arrive".
; DPF 22-apr-04 - Removed SPR < synsem_min > from complement, since this
; prevents "when really necessary", and it's not clear what it was supposed
; to be blocking.
; DPF 20-aug-04 - Removed [MOD..MSG message] even though this was helping
; with seemingly spurious ambiguity, because it blocked attachment to
; subordinate clauses, as in "if you slip while dancing, you fall".

subconj_prd_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.VFORM non_inf ] >,
                  VAL.COMPS < [ LOCAL [ CAT prd_cat,
                                        CONT.HOOK [ LTOP #prdltop,
                                                    XARG non_expl-ind ] ]] > ],
            CONT [ RELS <! subord_relation & [ SUBORD #cltop ],
                           message,
                           message & [ LBL #cltop,
                                       PRED prpstn_m_rel,
                                       MARG #prdltop ] !>,
                   HCONS <! !> ] ] ].

; For "so" of "I can be there, so yes/no/okay"
subconj_disc_adv_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT s_cat_fin_or_imp ] >,
                  VAL.COMPS < [ LOCAL [ CAT [ HEAD root-marker,
                                              POSTHD - ],
                                        CONT.HOOK.LTOP #rmtop ],
                                LEX + ] > ],
            CONT [ RELS <! subord_relation & [ SUBORD #cltop ],
                           message,
                           message & [ LBL #cltop,
                                       PRED prpstn_m_rel,
                                       MARG #rmtop ] !>,
                   HCONS <! !> ] ] ].

; DPF 14-May-02 - Cost of having this complementizer-like analysis is that
; we don't get conjoined if-clauses like "If you leave and he stays, I win"
; So why do we have this analysis?  Can't remember ...

subconj_if_synsem := basic_subconj_synsem & basic_two_arg &
  [ LOCAL [ ARG-S #comps,
            CAT [ HEAD [ TAM.MOOD #mood,
                         MOD < [ LOCAL [ CAT s_cat_fin_or_imp &
                                           [ HEAD.TAM.MOOD #mood ],
                                         CONT.MSG message ] ] > ],
                  VAL.COMPS < synsem &
                      [ LOCAL [ CAT [ HEAD prep_or_modnp &
                                       [ TAM [ TENSE no_tense,
                                               ASPECT no_aspect ],
                                         MOD < [ LOCAL intersective_mod ] > ],
                                      VAL.COMPS < > ],
                                CONT.HOOK [ LTOP #chand,
                                            INDEX #event ] ],
                        NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                 REL 0-dlist & [ LIST < > ],
                                 QUE 0-dlist ],
                        OPT +,
                        PUNCT.LPUNCT no_punct ] . #comps & 
                              < synsem &
                                [ LOCAL [ CAT np_cat_nom_min,
                                          AGR #agr,
                                          CONJ cnil ],
                                  NONLOC.SLASH 0-dlist & #slash,
                                  --SIND #ind,
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ],
                                synsem &
                                [ LOCAL local_min &
                                  [ CAT [ HEAD verbal &
                                               [ VFORM fin ],
                                          VAL [ SUBJ < synsem &
                                                      [ LOCAL.AGR #agr,
                                                        NONLOC.SLASH #slash ]>,
                                                COMPS < > ] ],
                                    CONT [ HOOK [ LTOP #chand,
                                                  INDEX #event,
                                                  XARG #ind ],
                                           MSG no_msg ] ],
                                  NONLOC.SLASH 0-dlist,
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ] > > ],
            CONT [ RELS <! subord_relation & #keyrel &
                           [ SUBORD #cmsg ],
                           message,
                           message &
                            [ LBL #cmsg,
                              PRED prpstn_m_rel,
                              MARG #marg ] !>,
                   HCONS <! qeq & [ HARG #marg,
                                    LARG #chand ] !> ] ],
    LKEYS.KEYREL #keyrel ].

; For sentence-initial discourse-level PPs like in "as for Chiang, who hired
; her?"
subconj_np_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT s_cat_fin_or_imp,
                               NONLOC.SLASH 0-dlist ] >,
                  VAL.COMPS < [ LOCAL [ CAT nomp_cat_nonnom_min,
                                        CONT.HOOK.INDEX #ind &
                                            [ PNG.PN 3pl ] ] ] >,
                  POSTHD - ],
            CONT [ RELS <! subord_relation & [ SUBORD #cltop ],
                           message,
                           message & [ LBL #cltop,
                                       PRED prpstn_m_rel,
                                       MARG #prdltop ],
                           unknown_relation &
                           [ LBL #prdltop,
                             ARG #ind ] !>,
                   HCONS <! !> ] ] ].

; DPF 25-Nov-01 - Added parent hc-to-phr
subconj_word := basic_mod_no_affix_word & nonque & hc-to-phr &
  [ SYNSEM basic_subconj_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                                     NONLOC.SLASH 0-dlist ] > ] ].
    
p_subconj_le := subconj_word &
  [ SYNSEM subconj_synsem ].

p_subconj_nocop_le := subconj_word &
  [ SYNSEM subconj_cp_nocop_synsem ].

; DPF 14-Oct-02 - Collapse above two, just specifying real_tense.

p_subconj_if_unspec_le := basic_mod_no_affix_word & nonque &
  [ SYNSEM subconj_if_synsem &
           [ LOCAL.CAT.VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAM.TENSE real_tense ] >]].

p_subconj_inf_le := basic_mod_no_affix_word & nonque &
  [ SYNSEM subconj_inf_synsem ].

p_subconj_prd_le := basic_mod_no_affix_word & nonque &
  [ SYNSEM subconj_prd_synsem ].

p_subconj_prd_v_or_p_le := basic_mod_no_affix_word & nonque &
  [ SYNSEM subconj_prd_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD v_or_p &
                                         [ TAM.ASPECT.PROGR - ] ] > ] ].

p_subconj_np_le := basic_mod_no_affix_word & nonque &
  [ SYNSEM subconj_np_synsem ].

p_subconj_dadv_le := basic_mod_no_affix_word & nonque &
  [ SYNSEM subconj_disc_adv_synsem ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Coordinating conjunctions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; HACK: For efficiency, restrict conjunctions to only coordinate phrases which 
; are saturated for COMPS.  This falsely excludes "Kim bought and sold a car".
; DPF (25-Apr-98) Removed COMPS..HEAD subst constraint, to allow 
; "your and my offices"
; DPF 8-Jun-99 - Removed hack on saturated COMPS - was blocking e.g. "between
; eleven and one p.m."
; DPF 15-May-03 - Discovered that the change to use LKEYS meant all subtypes
; of word were undesirably being coerced to be [LEX +] since type inference
; determined from the LKEYS attribute in 'word' that the synsem type should be
; abstract_lex_synsem which also introduces [LEX +].  This meant among other
; things that conj_word was always [LEX +*] rather than unspecified, and hence
; we could not parse e.g. "Kim is hiring Abrams and firing Browne" though we
; could still parse "Kim hired Abrams and fired Browne".  Now corrected, maybe.

conj_word := word &
  [ INFLECTD +,
    SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD #head,
		     MC #mc,
		     VAL [ SUBJ #subj,
			   SPR #spr,
			   COMPS < synsem &
				   [ LOCAL local_min &
					   [ CAT [ HEAD #head,
						   MC #mc,
						   VAL [ SUBJ #subj,
							 SPR #spr,
							 COMPS #comps ],
                                                   HC-LEX #hclex ],
                                             CONT.HOOK.XARG #xarg ],
                                     LEX #lex,
				     OPT -,
                                     ROOT -,
                                     PUNCT.LPUNCT no_punct ] 
				   . #comps > ],
                     HC-LEX #hclex ],
               CONT.HOOK.XARG #xarg ],
       LEX #lex,
       PUNCT.RPUNCT no_punct ] ].

; A coordinating conjunction needs to "prime" the CONJ.LBLS and
; CONJ.INDICES lists, so that the right side of a binary coordination looks
; like an iterated coordination.

norm_conj_word := conj_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR.DIVISIBLE #div ], ... >,
                     AGR.DIVISIBLE #div ],
             LKEYS.KEYREL conj_relation ] ].

basic_conj_complex_lexent := conj_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.MSG #msg,
                     CONJ lex-conj & [ CREL #key ],
                     CONT [ HOOK [ LTOP #chand,
                                   INDEX #cind ],
                            RELS <! #key &
                                  [ LBL #chand,
                                    WLINK *cons*,
                                    ARG0 #cind ] !>,
                            MSG #msg,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #key ] ].

conj_complex_lexent := basic_conj_complex_lexent & norm_conj_word.

conj_complex_and_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3pl,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

conj_complex_and_both_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3pl,
                   CONJ lex-conj & [ CHEAD.LEFT < both > ],
                   CONT.RELS <! [ PRED _and_c_both_rel ] !> ] ].

conj_complex_and_then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _and+then_c_rel ] !> ] ].

conj_complex_then_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL.COMPS < > ] ] >,
		   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _then_c_rel ] !> ] ].

conj_complex_and_so_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _and+so_c_rel ] !> ] ].


conj_complex_or_else_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _or+else_c_rel ] !> ] ].

conj_complex_except_that_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _except+that_c_rel ] !> ] ].

conj_complex_except_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD n_or_p,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _except_c_rel ] !> ] ].

conj_complex_as_well_as_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _as+well+as_c_rel ] !> ] ].

conj_complex_as_well_as_both_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < both > ],
                   CONT.RELS <! [ PRED _as+well+as_c_both_rel ] !>,
                   AGR.PNG png & [ PN 3pl ] ] ].

conj_complex_but_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.--SIND event,
		   CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! [ PRED _but_c_rel ] !> ] ].

conj_complex_nor_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _nor_c_rel ] !> ] ].

conj_complex_nor_neither_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & 
                        [ CHEAD.LEFT < neither > ],
                   CONT.RELS <! [ PRED _nor_c_neither_rel ] !> ] ].

conj_complex_or_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _or_c_rel ] !> ] ].  

conj_complex_or_either_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < either > ],
                   CONT.RELS <! [ PRED _or_c_either_rel ] !> ] ].

conj_complex_plus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! [ PRED _plus_c_rel ] !> ] ].

conj_complex_so_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.--SIND event,
		   CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! [ PRED _so_c_rel ] !> ] ].

conj_complex_vs_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _versus_c_rel ] !> ] ].

conj_complex_minus_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! [ PRED _minus_c_rel ] !>,
                   AGR.PNG png & [ PN 3sg ] ] ].

conj_complex_but_not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _but+not_c_rel ] !> ] ].

conj_complex_amp_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

conj_complex_amp_both_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < both > ],
                   CONT.RELS <! [ PRED _and_c_both_rel ] !> ] ].

; DPF 18-Mar-03 - How to block finite VP right conjunct?  Note that not only
; VPs can be conjoined.  Note also that blocking VP right conjunct will also
; correctly block sentence conjunction.
;   This data means either having two lexical entries, or pushing VFORM up to
; type 'head' so non-verbal conjuncts are still permitted here even with
; constraint on VFORM nonfin.  Also suggests that lexical conjunctions and 
; not the coord rules determine which properties of 'head' are unified on the
; two conjuncts, if we want to treat these as regular conjunctions.
;   'Kim will buy a truck rather than rent a car'
;   'Kim will buy a truck rather than renting a car'
;   '*Kim bought a truck rather than rented a car'
;   'Kim wanted to buy a truck rather than to rent a car'
;   '*Kim bought a truck rather than Sandy rented a car'
;   'Kim arrived on Tuesday rather than on Wednesday'

conj_complex_rather_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _rather+than_c_rel ] !> ] ].  

; DPF 18-Mar-03 - Need to block not only finite VP right conjunct, but also 
; base form (and maybe infinitival?)
;   '*Kim will buy a truck instead of rent a car'
;   'Kim will buy a truck instead of renting a car'
;   '*Kim bought a truck instead of rented a car'
;   '?Kim wanted to buy a truck instead of to rent a car'
;   'Kim arrived on Tuesday instead of on Wednesday'

conj_complex_instead_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _instead+of_c_rel ] !> ] ].  

conj_complex_and_or_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
		   CONT.RELS <! [ PRED _and_c_or_rel ] !> ] ].

conj_complex_not_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.--SIND ref-ind,
		   CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! [ PRED _not_c_rel ] !> ] ].

conj_complex_yet_le := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.--SIND event,
		   CONJ lex-conj & [ CHEAD.LEFT < cnil > ],
		   CONT.RELS <! [ PRED _yet_c_rel ] !> ] ].

; Different since it sets DIVISIBLE to +, to get e.g.
; 'chair after chair arrived.'
conj_complex_after_le := basic_conj_complex_lexent &
  [ SYNSEM [ LOCAL [ AGR [ PNG.PN #pn,
                           DIVISIBLE + ],
                     CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN #pn ] >,
                     CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
                     CONT.RELS <! [ PRED _after_c_rel ] !> ],
             LKEYS.KEYREL conj_relation ] ].

conj_atomic_lexent := norm_conj_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ CONT.HOOK #hook,
                                               CONJ cnil ],
		   CONJ atomic-conj,
		   CONT [ HOOK #hook,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

conj_atomic_both_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ both ].

conj_atomic_either_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ either ].
                   
conj_atomic_neither_le := conj_atomic_lexent &
  [ SYNSEM.LOCAL.CONJ neither ].

; two hundred and fifty
conj_and_num_le := conj_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY integer_rel,
                           VAL.COMPS.FIRST [ LOCAL [ CAT.HEAD intadj2- &
                                                      [ KEYS.ALTKEY #altkey ],
                                                     CONT.HOOK.LTOP #hand,
                                                     CONJ cnil,
                                                     AGR.DIVISIBLE #div ],
                                             MODIFD.LPERIPH na ] ],
                     CONJ num-conj,
                     CONT [ HOOK.LTOP #hand,
                            RELS <! !>,
                            MSG no_msg,
                            HCONS <! !> ],
                     AGR.DIVISIBLE #div ],
             LKEYS [ KEYREL integer_relation,
                     ALTKEYREL.PRED #altkey ] ] ].

; 'five and a half'
conj_and_fract_le := conj_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY fraction_rel,
                           VAL.COMPS.FIRST [ LOCAL [ CAT.HEAD fractadj &
                                                      [ KEYS.ALTKEY #altkey ],
                                                     CONT.HOOK [ LTOP #hand,
                                                                 XARG #ind ],
                                                     CONJ cnil,
                                                     AGR.DIVISIBLE #div ],
                                             MODIFD.LPERIPH na ] ],
                     CONJ num-conj,
                     CONT [ HOOK [ LTOP #hand,
                                   INDEX #ind ],
                            RELS <! !>,
                            MSG no_msg,
                            HCONS <! !> ],
                     AGR.DIVISIBLE #div ],
             LKEYS [ KEYREL.PRED fraction_rel,
                     ALTKEYREL.PRED #altkey ],
             NONLOC [ SLASH 0-dlist,
                      REL 0-dlist,
                      QUE 0-dlist ] ] ].

etc_conj_lexent := word &
  [ INFLECTD +,
    POSSCL -,
    SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD.KEYS.KEY norm_rel,
                     VAL.COMPS < > ],
               CONJ lex-conj & [ CHEAD.LEFT < cnil, cnil > ],
               AGR.PNG png & [ PN 3pl ],
               CONT [ HOOK [ LTOP #chand,
                             INDEX #cind ],
                      RELS <! #key & relation &
                             [ LBL #chand,
                               ARG0 #cind ] !>,
                      HCONS <! !> ] ],
       LKEYS.KEYREL #key,
       PUNCT [ LPUNCT comma_or_no_punct,
               RPUNCT no_punct ] ] ].

etc_conj_le := etc_conj_lexent.

except_etc_conj_le := etc_conj_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD n_or_p ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NEG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; not

; "not" requires its VP complement to be [VFORM non_fin], which is a supersort
; for all non-finite vforms except imp_vform, which is a subsort of bse; the
; other subsort of bse, bse_only, is a subsort of non_fin.  Most verbs with
; base morphology are [VFORM bse], and hence (the VPS they project) can be
; modified by "not", and they can also head imperative clauses, which require
; the head to be [VFORM imp_vform].  Only if modified by "not" will a base
; VP be unable to project an imperative clause; in contrast, "never sleep" is 
; fine as an imperative, since "never" does not further restrict its VP 
; complement leaving it [VFORM bse], which is consistent with the imperative 
; rule.  This fine distinction is due to Rob M.
; DPF 2-Feb-01 - Changed MOD..HEAD from verbal to v_or_g, to allow e.g.
; "I tried not hiring kim"

adv_neg_lexent := norm_mod_nonque_no_affix_word &
  [ SYNSEM lex_synsem & 
	 [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL scopal_mod &
					    [ CAT [ VAL.COMPS < >,
                                                    MC na ],
                                              CONT [ HOOK [ LTOP #mhand,
                                                            INDEX non_expl &
                                                                  #vevent,
                                                            XARG #xarg ],
                                                     MSG #msg ],
                                              CONJ cnil ] ] >,
                                KEYS.KEY #keypred ],
                         VAL [ SUBJ < >,
			       COMPS < >,
			       SPR < > ],
                         MC na,
			 POSTHD - ],
		   CONT [ HOOK [ INDEX #vevent,
                                 XARG #xarg ],
			  RELS <! #key &
                                  [ PRED #keypred,
                                    ARG1 #hand ] !>,
			  HCONS <! qeq &
				  [ HARG #hand,
				    LARG #mhand ] !>,
                          MSG #msg ] ],
           LKEYS.KEYREL #key ] ].

adv_not_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD negadv &
                          [ MOD < [ LOCAL.CAT [ HEAD.VFORM non_fin,
                                                VAL.SUBJ < synsem_min > ] ] >,
                            KEYS.KEY neg_rel ] ].

; DPF 05-apr-05 - MOD..HEAD v_or_a_or_p allows modnp subtype, which is not
; a subtype of a_or_p for independent reasons.  No spurious ambiguity here, 
; since the SUBJ < > constraint rules out all PRD + verbal projections.

adv_neg_prdp_le := adv_neg_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD adv_nonmob &
                          [ MOD < [ LOCAL.CAT [ HEAD v_or_a_or_p &
                                                     [ PRD + ],
                                                VAL.SUBJ < > ] ] > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; COMPLEMENTIZERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Complementizers except for 'to' are marked [SUBJ < >] which prevents them
; from having PP modifiers.

; ERB (07-10-96) 'whether' clauses are made with the regular hcomp rule, so
; the polar_q_rel must come from 'whether' itself.  This means that whether
; can't identify its KEY with its --COMPKEY.  Also, I made complementizer_word
; inherit from msg_word (see comments near that type).  This has the effect of
; making non_affix_bearing be inherited by this type, instead of the lower
; types.

; ERB (14-12-97) to_c_prop needs to be MC + for infinitival relatives
; (see notes near to and non_wh_rel_cl) so this type can't say MC -.
; There is no convenient supertype to all of the MC - ones, so I'm
; just going to put it in on each for now.

; ERB (14-12-97) Complementizer_word can't be nonmod_local because 
; to_c_nonprop is going to have a non-empty mod value.  Again, For
; now I'm scattering this constraint among the lower types as appropriate.

; ERB (13-01-98) In fact, complementizer_word can't even be MC bool,
; because to_c_nonprop has to be MC na in order to head hcomps that
; serve as modifiers, as in "a teacher to talk to Sandy".

;;; DPF 01-Mar-00 - Reconsider, now that support_rel has been eliminated.
; DPF (27-Sept-98) Made KEY be v_event_rel, since "to" needs to pass up the
; KEY.LBL of its complement, in order to get the desired semantics for e.g.
; "Kim is going to lose" where the copula's support_rel identified its LBL
; with that of its complement's KEY.
; 
; DPF (13-Jan-99) Generalized to make KEY be v_event_rel for all 
; complementizers, needed in particular to avoid treating complementizers as 
; particles, which are selected by KEY value.
; DPF 25-oct-03 - Change SPR from *olist* to < > to block PP modification.

complementizer_word := basic_msg_word & 
  [ SYNSEM.LOCAL local_min &
		 [ CAT [ HEAD comp &
			      [ POSS -,
				INV - ],
			 VAL.SPR < > ],
		   AGR.PNG.PN 3sg,
		   CONT.HOOK.INDEX non_expl ] ].

plain_compl_word := complementizer_word &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SUBJ < #subj >,
                               COMPS #comps & 
                                    < [ LOCAL local_min &
					      [ CAT.HEAD.KEYS.KEY #ckey ],
                                        --SIND #ind,
                                        OPT - ], ... > ],
                     CONT.HOOK.INDEX #ind,
                     ARG-S < #subj . #comps > ],
             LKEYS.--COMPKEY #ckey ] ].

; These are the subject-to-object raising complementizers.  We're giving a
; funny three-constituent analysis to CPs: "that [Kim] [walks]" and "for [Kim]
; [to walk]".  One (beneficial) side effect of this is that finite and
; non-finite CPs get a uniform analysis, and we also can do real subject
; extraction without running afoul of the dreaded that-trace filter
; (Perlmutter 1971).  

; We also need another "that", one that combines with an adverbial and an
; S/Adv.  This accounts for why you get preposed modifiers with that clauses
; and not with for/to clauses, and why you don't get the that-t effect when
; you have an adverb in there.  But, that second "that" is going to have to
; bind off a SLASH value, sort of like the tough-movement cases, and that will
; have to wait for lexicalized SLASH passing.

; ERB (14-12-97) See notes at complementizer_word.

; DPF (25-Mar-00) Removed re-entrancy between --COMPKEY and KEY - not clear 
; what it was supposed to do, but it prevents WLINK from working as intended.
; AAC - killed WLINK 
; DPF 2-Apr-01 - Added PP modifier argument to COMPS, to allow for sentence-
; initial modification, as in "I knew that on Tuesday I would be early", and in
; particular for "how come when I arrive he leaves" (given that we treat this
; "how come" as a main-clause-compatible complementizer).

basic_two_place_compl_word := complementizer_word & 
  [ SYNSEM basic_two_arg & 
	 [ LOCAL nomod_local &
	   [ ARG-S #comps,
	     CAT [ HEAD [ VFORM #vform,
                          TAM #tam & [ TENSE #tense,
                                       ASPECT #aspect,
                                       MOOD #mood ] ],
                   VAL [ SUBJ < >,
			 COMPS 
			      < synsem &
                                [ LOCAL [ CAT [ HEAD prep_or_modnp & 
                                                     [ TAM [ TENSE no_tense,
                                                             ASPECT no_aspect],
                                                       MOD < [ LOCAL 
                                                          intersective_mod ] >,
                                                       KEYS.KEY 
                                                          independent_rel ],
                                                VAL.COMPS < > ],
                                          CONT.HOOK [ LTOP #chand,
                                                      XARG #event ] ],
                                  NONLOC [ SLASH 0-dlist,
                                              REL 0-dlist & [ LIST < > ],
                                              QUE 0-dlist ],
                                  OPT +,
                                  PUNCT.LPUNCT no_punct ] . #comps & 
                                < synsem & [ NONLOC #nloc &
                                                       [ SLASH 0-dlist ] ],
                                  [ LOCAL local_min &
					[ CAT [ HEAD verbal &
						     [ VFORM #vform,
                                                       TAM #tam,
                                                       KEYS.KEY #ckey ],
                                                VAL [ SUBJ 
                                                       < [ NONLOC #nloc ] >,
                                                      COMPS < > ] ],
                                          CONT [ HOOK [ LTOP #chand,
                                                        INDEX #event ],
                                                 MSG no_msg ] ],
                                    OPT -,
                                    PUNCT.LPUNCT no_punct ] > > ] ],
	     CONT [ HOOK [ LTOP #mhand,
                           INDEX #event & [ E [ TENSE #tense,
                                                ASPECT #aspect,
                                                MOOD #mood ] ] ],
                    RELS.LIST < #msg, ... >,
		    HCONS.LIST < qeq &
                                  [ LARG #chand ], ... >,
                    MSG message & #msg & [ LBL #mhand ] ] ],
           LKEYS.--COMPKEY #ckey ] ].

two_place_compl_word := basic_two_place_compl_word &
  [ SYNSEM.LOCAL.CONT [ HCONS.LIST < [ HARG #marghand ], ... >,
                        MSG message & [ MARG #marghand ] ] ].

; Instead of doing raising here by identifying whole synsems, only identify
; semantic indices, as with regular raising for verbs above.  This lets us get
; "I prefer that he be here early" treating the second (VP) complement of 
; "that" as a simple base-form VP, rather than some new morphological form.

basic_sor_compl_word := basic_two_place_compl_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < synsem,
                                 synsem &
				 [ LOCAL [ CAT #cat & nomp_cat_min,
                                           AGR #agr,
                                           CONT.MSG no_msg,
					   CONJ cnil ],
                                   --SIND #ind,
				   OPT - ],
				 [ LOCAL [ CAT.VAL.SUBJ < synsem &
                                                          [ LOCAL
                                                             [ CAT #cat,
                                                               AGR #agr ] ] >,
                                           CONT.HOOK.XARG #ind ] ] > ].

sor_compl_word := basic_sor_compl_word & two_place_compl_word.

comp_that_le := sor_compl_word & 
  [ SYNSEM 
     [ LOCAL 
        [ CAT [ HEAD [ VFORM fin,
                       TAM.MOOD #mood & ind_or_mod_subj,
                       CASE nom,
                       AUX -,
                       KEYS.KEY verb_aspect_rel ],
                VAL.COMPS < synsem, 
                            [ LOCAL.CAT np_cat_nom_min ],
                            [ LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                                                 [ TENSE real_tense,
                                                   MOOD #mood ] ] >,
                MC - ],
          CONT [ RELS <! relation !>,
                 HCONS <! qeq !>,
                 MSG.PRED prpstn_m_rel ] ],
       LKEYS.KEYREL.PRED verb_aspect_rel ] ].

;; "I prefer that he be here early"
comp_that_subj_le := sor_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM bse,
                                  TAM.MOOD #mood,
                                  AUX -,
                                  KEYS.KEY verb_aspect_rel ],
                           VAL.COMPS < synsem, 
                                       [ LOCAL.CAT np_cat_nom_min ],
                                       [ LOCAL.CAT.HEAD.TAM subjnct_tam &
                                                            [ MOOD #mood ] ] >,
                           MC - ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !>,
                            MSG.PRED prpstn_m_rel ] ],
             LKEYS.KEYREL.PRED verb_aspect_rel ] ].

comp_for_le := sor_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM inf,
                                  AUX -,
                                  KEYS.KEY verb_aspect_rel ],
                           VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY no_rel ],
                                       [ LOCAL.CAT np_cat_acc_min ], 
                                       synsem >,
                           MC - ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !>,
                            MSG.PRED prpstn_m_rel ] ],
             LKEYS.KEYREL.PRED verb_aspect_rel ] ].

comp_like_le := sor_compl_word & 
  [ SYNSEM [ LOCAL 
             [ CAT [ HEAD [ VFORM fin,
                            AUX -,
                            KEYS.KEY verb_aspect_rel ],
                     VAL.COMPS < synsem,
                                 [ LOCAL.CAT np_cat_nom_min ],
                                 [ LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam &
                                                  [ MOOD ind_or_mod_subj ] ] >,
                     MC - ],
               CONT [ RELS <! relation !>,
                      HCONS <! qeq !>,
                      MSG.PRED like_mood_m_rel ] ],
             LKEYS.KEYREL.PRED verb_aspect_rel ] ].

; ERB (13-01-98) to_compl_word says SUBJ < unexpressed >, but I don't
; how that can be, unless the analysis of raising has changed drastically.
; (With it that way, raising is broken).  So I am getting rid of it.

; ERB (19-01-98) SUBJ < unexpressed > was in there because something
; had to take care of giving that subject a SLASH value.  The solution
; we've opted for is this: the subject of to_c_prop is always PRO, and
; the subject of to_c_nonprop is always raised (that is, all
; infinitival tos except those in raising constructions are to_c_prop).
; So there is no constraint on to_compl_word, but to_c_prop says
; SUBJ < pro_ss > and to_c_nonprop says SUBJ canonical_synsem.

; ERB (03-02-98) KEY should be no_rel.  It used to be identified with
; --COMPKEY, but that causes at least one problem: to was able to be the
; SPR of the, since the constrains its choice of SPR by a semantic
; constraint on the KEY.
; DPF (13-Jan-99) This problem should be solved by the above decision to
; make all complementizers have the KEY be of type v_event_rel.
; DPF 17-Sep-01 - Removed INDEX.E.TENSE no_tense, since it prevents e.g. 
; "I am going to arrive".
; DPF 14-Nov-01 - Returned to identifying KEY with --COMPKEY, in order to get
; intended constraint on --COMPKEY.E.ASPECT for e.g. "I have yet to arrive"

to_compl_word := plain_compl_word &
  [ SYNSEM basic_two_arg &
     [ LOCAL [ CAT [ HEAD [ AUX +,
                            PRD -,
                            KEYS #keys & [ KEY verb_aspect_rel ] ],
                     VAL [ SUBJ < [ LOCAL.AGR #agr,
                                    --SIND #semind ] >,
                           
                           COMPS 
                              < synsem &
				[ LOCAL 
                                  [ CAT vp_cat &
                                        [ HEAD.KEYS #keys,
                                          VAL.SUBJ 
                                           < [ LOCAL.AGR #agr,
                                               --SIND #semind,
                                               NONLOC
                                                     [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ],
                                    CONT.HOOK [ INDEX #ind,
                                                XARG #xarg ] ] ] > ] ],
               CONT.HOOK [ INDEX #ind,
                           XARG #xarg ] ] ] ].


; ERB (14-12-97) Why is the SUBJ here specified as acc?? I'm taking it
; out because that follows now from pro_ss.

; ERB (08-01-98) Presumably that had to do with "for him/*he to sleep..."
; but that's the other to: to_c_nonprop.

; ERB (14-12-97) In order to implement infinitival relatives (I found
; a teacher to talk to Sandy, I found a teacher to talk to), I am
; making to_c_prop MC +.  The reasons for this is that the relevant
; cx (non_wh_rel_cl) needs to be able to take subjh_decl and hcomps
; headed by to_c_prop as its head-dtr, but not an extrasubj phrase.

; ERB (19-01-98) This to has to have a mod value so that it can
; head the infinitival relatives.  Something needs to be said about
; the features mentioned in nomod_local, probably, but I'm not sure
; what yet.  It also needs to be MC na so it can feed extrasubj.

; DPF 4-apr-04 - Removed identification of AGR and COMPS.FIRST..AGR, since
; we need to have complementizers stipulate AGR.PNG.PN 3sg to get the agreement
; right for sentential subjects (?), but we also say that 'and' is inherently
; AGR.PNG.PN 3pl (to get NP coordination right (?)), and the result of both
; of these (dubious?) assertions is that we were not parsing "to arrive and
; arise" with the to-prop guy.  Probably room for improvement, but for now
; let's see what happens removing this AGR identity.

basic_comp_to_prop_lexent := to_compl_word & 
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL intersective_mod &
                                            [ CAT nbar_cat_min ] ] >,
                         VAL [ SUBJ < pro_ss >,
                               COMPS < [ LOCAL 
                                            [ CONT.HOOK 
                                                   [ LTOP #chand,
                                                     INDEX.E.TENSE
                                                          no_tense ] ] ] > ],
                         MC na_or_-,
                         POSTHD + ],
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! #msg !>,
                          HCONS <! qeq &
                                 [ HARG #marghand,
                                   LARG #chand ] !>,
                          MSG #msg & [ LBL #ltop,
                                       PRED prpstn_m_rel,
                                       MARG #marghand ] ] ] ].

comp_to_prop_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].
; try and win
comp_inf_and_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_and,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].
; help but notice
comp_inf_but_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_but,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].

; prevent him from leaving (cf "*prevent him from danger")
comp_inf_from_le := basic_comp_to_prop_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_from,
                       VAL.COMPS < [ LOCAL.CAT vp_prp_cat ] > ] ].

; ERB (14-12-97) This one will have a non-empty MOD value in order to
; build things like "Kim found a friend to talk to Sandy" where the
; subject of talk has to be bound to friend (unlike in "Kim found a
; friend to talk to" where we're convinced it is discourse bound.)
;
; The semantics are probably not right -- as a place holder in the
; modcont I put a appropriate_rel.  The idea is that "I found a person
; to talk to Sandy" means something like "I found a person who is willing/
; appropriate/suitable to talk to Sandy."  But I don't see how to make
; (something like) the appropriate_rel take the comlement of the to
; as an argument.  There is also the question of whether there should be
; any message associated with this.  One would think not, given that we've
; decided the relevant to is the nonprop one...
;   For now, we're not including this rel.

; ERB (13-01-98) to_compl_nonprop_word must be MC na if it is
; to head hcomps that serve as modifiers as in "a teacher to talk to Sandy".
;
; ERB (19-01-98) All infinitival relatives are now headed by
; to_c_prop.  To_c_nonprop only appears in raising constructions.
; Accordingly, it has no MOD value, and its subject is constrained
; to be canonical_synsem.  I'm not sure the latter constraint is
; actually doing any work for us, but I believe it to be true.
; It can also now inherit from nomod_local.  The MC value might
; could be changed, as well.

; ERB (2003-08-11) Try changing SUBJ < canonical_synsem > to
; SUBJ < unexpressed >.  There are several places in the grammar
; where the SLASH value of the SUBJ here is being constrained.
; Since it is, in fact, always unxpressed, it would seem safe.
; Testing to see whether coverage is lost or gained because something
; was relying on this constraint.

comp_to_nonprop_le := to_compl_word & 
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ HEAD [ VFORM inf,
                                CASE acc ],
                         VAL [ SUBJ < unexpressed_reg >,
			       COMPS < [ LOCAL local_min &
					       [ CAT vp_bse_cat,
                                                 CONT.HOOK.LTOP #hand ] ] > ],
                         MC na ],
		   CONT [ HOOK.LTOP #hand,
			  RELS <! !>,
			  HCONS <! !>,
                          MSG no_msg ] ] ].

;;; DPF (21-Oct-98) Added types for elided "to", since we can't use the lexical
;; rule of auxiliary verbs, since we need to block the NP "the book to", which
;; would be built by that lexical rule, then by the application of subject
;; extraction, and then the infinitival relative rule.

to_compl_elided_word := msg_word &
  [ SYNSEM basic_one_arg &
	   [ LOCAL nomod_local &
		   [ CAT [ HEAD comp &
				[ VFORM inf,
				  INV -,
				  AUX +,
				  PRD -,
                                  KEYS [ KEY ellipsis_rel,
                                         ALTKEY ellipsis_rel ] ],
                           VAL [ SUBJ #subj &
				      < [ --SIND #index,
					  NONLOC.SLASH 0-dlist ] >,
				 SPR *olist*,
				 COMPS < > ],
			   MC na ],
		     CONT [ HOOK [ INDEX #event,
                                   XARG #index ],
			    RELS.LIST < #key & arg1_relation &
                                        [ PRED ellipsis_rel,
                                          ARG0 #event,
                                          ARG1 #index ], ... > ],
                     ARG-S #subj ],
             LKEYS.KEYREL #key ] ].

comp_to_prop_elided_le := to_compl_elided_word & 
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < pro_ss >,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! [ LBL #chand ], 
                                #msg !>,
                          HCONS <! qeq &
                                 [ HARG #marghand,
                                   LARG #chand ] !>,
                          MSG #msg & [ LBL #ltop,
                                       PRED prpstn_m_rel,
                                       MARG #marghand ] ] ] ].

comp_to_nonprop_elided_le := to_compl_elided_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.SUBJ < unexpressed_reg >,
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! relation !>,
                            HCONS <! !>,
                            MSG no_msg ] ],
             LKEYS.KEYREL.LBL #ltop ] ].

; ERB (08-10-96) Whether was previously a que_word so that things selecting
; for questions could select by QUE values.  This is clearly a hack, and
; further, one that is no longer necessary now that we have semantic selection.
; I have split the old type whether_compl_word into two types: finite and
; nonfinite.  I have also gotten rid of the feature CMP.  
; As for the semantics, whether contributes a polar_q_rel (see notes near
; polar_q_rel in fundamentals.tdl).  Now, according to Rob, things that
; take complements with message-type semantics usually take the handle of
; those complements as the argument in their KEYs.  However, also according
; to Rob, if we did that here, it would imply that "whether Kim left every
; party" has more readings than "Kim left every party", which doesn't seem
; to be true.  Accordingly, whether will identify its handle with the
; handle of its complement, and take the complement's INDEX as the value
; of the ARG1 in the polar_q_rel.  Now, if whether further identified its
; INDEX with that one, things would be getting pretty twisty, so whether
; will have its own INDEX of type event.

; ERB (24-10-96) MSG now functions like KEYREL as a pointer to
; a certain rel on the RELS.  Both wh and yn questions will have an
; int_m_rel on their RELS.  This is actually sewn into the RELS
; by the constructions.  Whether just carries it in its MSG value
; so that it unifies with the right constructions.  In this way, we
; even kind of get Rob's intuition -- whether doesn't, in a sense,
; have a message, because that message isn't on its RELS.
; Anyway, all of this makes the polar_q_rel irrelevant, so I am removing
; it.  The hcomp_yn_nr construction will make sure the MARG value
; of the int_m_rel takes the LBL of whether's complement.   I don't
; know what to do about whether's LBL, KEY, and ARG0 now, so I am 
; leaving them unspecified.

; ERB (14-12-97) See notes at complementizer_word.

whether_compl_word := complementizer_word &
  [ SYNSEM [ LOCAL nomod_local &
		   [ CONT [ RELS.LIST < #msg &
                                        [ MARG #lbl ],
                                        message &
                                        [ LBL #lbl,
                                          PRED prpstn_m_rel,
                                          MARG #marg ], ... >,
                            HCONS.LIST < [ HARG #marg ], ... >,
                            MSG #msg & [ PRED int_m_rel,
                                         PARAMS <! !> ] ] ],
             NONLOC.SLASH 0-dlist ] ].

comp_whether_if_fin_lexent := whether_compl_word & basic_sor_compl_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                  TAM.MOOD #mood,
                                  KEYS.KEY verb_aspect_rel ],
                           VAL.COMPS < synsem, 
                                       [ LOCAL.CAT np_cat_nom_min ],
                                       [ LOCAL.CAT.HEAD.TAM.MOOD #mood ] >,
                           MC - ],
                     CONT [ RELS <! relation, relation !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL.PRED verb_aspect_rel ] ].

comp_whether_fin_le := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT 
        [ HEAD.TAM.MOOD ind_or_mod_subj,
          VAL.COMPS < synsem, 
                      synsem, 
                      [ LOCAL.CAT.HEAD.TAM ind_or_mod_subj_tam ] > ] ].

comp_if_indic_le := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE acc,
                       VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAM 
                                                 ind_or_mod_subj_tam ] > ] ].

comp_if_subjnct_le := comp_whether_if_fin_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE acc,
                       VAL.COMPS < synsem, 
                                   synsem, 
                                   [ LOCAL.CAT.HEAD.TAM subjnct_tam ] > ] ].

; DPF 13-Mar-02 - Blocked first (optional PP) complement from being picked up
; to avoid misparse for e.g. "I need an explanation of how to return the 
; order to you"
; DPF 12-Apr-03 - But the entry for "how" leads to spurious ambiguity for e.g.
; "I know how kim arrived", and doesn't help with other WH-S's as objects of
; prepositions: "I need an explanation of who we hired".  Seems better to 
; return to our analysis treating WH-S's as NPs, and look again at the
; resulting spurious ambiguities there.  So we'll use this type only for
; "how come".

how_compl_lexent := basic_sor_compl_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                TAM.MOOD ind_or_mod_subj ],
                           VAL.COMPS < synsem & 
                                   [ LOCAL.CAT.HEAD.KEYS.KEY no_rel ], 
                                   [ LOCAL.CAT np_cat_nom_min ],
                                   [ LOCAL [ CAT.HEAD.TAM.MOOD ind_or_mod_subj,
                                             CONT.HOOK [ LTOP #cltop,
                                                         INDEX #cind ] ]] > ],
                     CONT [ HOOK.INDEX #cind,
                            RELS <! message,
                                    message,
                                    #key & [ LBL #cltop,
                                             ARG0.E [ TENSE no_tense,
                                                      ASPECT no_aspect ],
                                             ARG1 #cind,
                                             ARG2 #objind ],
                                    [ PRED which_q_rel,
                                      ARG0 #objind,
                                      RSTR #rhand ],
                                    #altkey &
                                    [ LBL #nhand,
                                      ARG0 #objind ] !>,
                            HCONS <! qeq, 
                                     qeq &
                                     [ HARG #rhand,
                                       LARG #nhand ] !> ] ],
             LKEYS [ KEYREL #key,
                     ALTKEYREL #altkey ] ] ].

; 'how come they left'
how_compl_mc_le := how_compl_lexent & whether_compl_word &
  [ SYNSEM.LOCAL.CAT.MC + ].

; ERB (08-10-96) In the older version, I had whether_compl_word_inf 
; selecting for something that was just vp_inf_cat.  I never
; tested for this, but this probably allowed Sandy knew whether whether
; to leave, etc.  One way to get around this is for whether to
; select for something that is MSG no_msg.  In order to do 
; this, I need to build to CPs that are no_rel, but we want this
; anyway (even though I talked Dan out of it at one point).
; DPF 09-Jan-00 - Made "whether" be MC -, not MC na, since e.g. "know"
; wants [MC -] CP complements.

comp_whether_inf_le := whether_compl_word &
  [ SYNSEM basic_one_arg &
	   [ LOCAL [ CAT [ HEAD [ VFORM inf,
                                  KEYS.KEY verb_aspect_rel ],
			   VAL [ SUBJ < >,
                                 COMPS #comps &
                                      < [ LOCAL [ CAT [ HEAD comp &
							  [ VFORM inf ],
						       VAL [ SUBJ *cons*,
                                                             COMPS < >,
							     SPR *olist* ] ],
                                                  CONT [ HOOK.LTOP #chand,
                                                         MSG no_msg ] ],
                                          --SIND #ind,
                                          OPT - ] > ],
                           MC - ],
		     CONT [ HOOK [ LTOP #mhand,
                                   INDEX #ind ],
			    RELS <! relation, relation !>,
			    HCONS <! qeq &
				    [ LARG #chand ] !>,
                            MSG.LBL #mhand ],
                     ARG-S #comps ],
             LKEYS.KEYREL.PRED verb_aspect_rel ] ].

s_compl_phrase_lexent := msg_word &
  [ SYNSEM [ LOCAL nomod_local &
		 [ CAT [ HEAD verb & 
			      [ INV -,
				VFORM fin ],
			 VAL [ SUBJ < >,
			       SPR *olist*,
			       COMPS < > ] ],
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #event ],
			  RELS.LIST < arg1_relation &
                                      [ LBL #khand,
                                        PRED ellipsis_rel,
                                        ARG0 #event ], #msg, ... >,
                          HCONS.LIST < qeq &
                                        [ HARG #marg,
                                          LARG #khand ], ... >,
                          MSG message & #msg &
                               [ LBL #hand,
                                 MARG #marg ] ],
                   ARG-S < > ],
	     NONLOC.SLASH 0-dlist,
             LEX + ] ].

; 'so'
s_compl_phrase_le := s_compl_phrase_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.KEYS.KEY v_event_rel,
                     CONT [ RELS <! relation & #key, [ PRED prpstn_m_rel ] !>,
                            HCONS <! qeq !> ] ],
             LKEYS.KEYREL #key & [ PRED v_event_rel ] ] ].

s_compl_wh_phrase_le := s_compl_phrase_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.KEYS.KEY prep_mod_rel,
                     CONT [ RELS <! relation & 
                                 [ LBL #hand,
                                   ARG0 #event ],
                                 [ PRED int_m_rel ], 
                                 #key &
                                 [ LBL #hand,
                                   PRED prep_mod_rel,
                                   ARG0.E [ TENSE no_tense,
                                            ASPECT no_aspect ],
                                   ARG1 #event,
                                   ARG2 #objind,
                                   WLINK #wlink ],
                                 [ PRED which_q_rel,
                                   ARG0 #objind,
                                   RSTR #rhand ],
                                 #altkey & [ LBL #nhand,
                                             ARG0 #objind,
                                             WLINK #wlink ] !>,
                          HCONS <! qeq, 
                                   qeq &
                                   [ HARG #rhand,
                                     LARG #nhand ] !> ] ],
             LKEYS [ KEYREL #key,
                     ALTKEYREL #altkey ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Imperative words "don't" and "let's"

; ERB (05-10-97) In order to conflate hcomp_root and hcomp_nc into just one
; hcomp, root_marker_words have to identify their value for mc with that of
; their complement.  (Hcomp_root identified MC for mother and non-head
; daughter.)

basic_root_marker_word := nonque & non_affix_bearing & nonrel & nonconj & 
                          hc-to-phr &
  [ SYNSEM synsem &
	 [ LOCAL [ CAT [ HEAD verb & [ TAM.MOOD #mood,
                                       AUX -,
                                       INV - ],
			 VAL.COMPS < [ LOCAL local_min &
                                             [ CAT [ HEAD.TAM.MOOD #mood,
                                                     VAL.COMPS < > ],
                                               CTXT #ctxt ],
                                       NONLOC [ SLASH 0-dlist,
                                                   QUE 0-dlist,
                                                   REL 0-dlist ] ] > ],
                   CTXT #ctxt ],
	   NONLOC.SLASH 0-dlist ] ].

root_marker_word := basic_root_marker_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < synsem > ].

lex_imperative := root_marker_word &
  [ SYNSEM [ LOCAL 
             [ CAT [ HEAD [ MOD < anti_synsem_min >,
                            KEYS.KEY no_rel ],
                     VAL 
		    [ SUBJ < anti_synsem_min >,
                      SPR < anti_synsem_min >,
		      COMPS < [ LOCAL 
                                 [ CAT [ HEAD verb & [ VFORM bse_only ],
                                         VAL.SUBJ 
                                             < synsem &
                                               [ NONLOC [ SLASH 0-dlist,
                                                             QUE 0-dlist,
                                                             REL 0-dlist ] ] >,
                                         MC na ],
                                   CONT.HOOK [ LTOP #khand,
                                               INDEX #ind,
                                               XARG #inst ] ],
                                OPT +,
                                PUNCT.LPUNCT no_punct ] > ],
                     MC + ],
               AGR #inst,
               CONT [ HOOK [ LTOP #hand,
                             INDEX #ind & [ E.TENSE present ] ],
                      RELS.LIST < #msg, 
                                  [ PRED pronoun_q_rel,
                                    RSTR #rhand,
                                    ARG0 #inst ],
                                  [ LBL #prohand,
                                    PRED pron_rel,
                                    ARG0 #inst &
                                        [ PRONTYPE zero_pron,
                                          SORT entity ] ], ... >,
                      HCONS.LIST < qeq &
                                   [ HARG #marg ], 
                                   qeq &
                                   [ HARG #rhand,
                                     LARG #prohand ], ... >,
                      MSG #msg &
                           [ LBL #hand,
                             PRED imp_m_rel,
                             MARG #marg ] ] ],
             LKEYS.KEYREL [ LBL #khand,
                            PRED no_rel  ] ] ].
		    
    

va_lets_imp_le := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
		   AGR.PNG png & [ PN 1pl ],
		   CONT [ HCONS <! [ LARG #chand ], qeq !>,
			  RELS <! relation, relation, relation !> ] ] ].

va_dont_imp_le := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CONT.HOOK.LTOP #chand,
                                             CAT.HEAD.KEYS.ALTKEY 
                                                            non_conj_rel ] ] >,
                   AGR.PNG png & [ PN 2per ],
		   CONT [ RELS <! relation,
				   relation,
                                   relation,
                                 [ LBL #neghand,
                                   PRED neg_rel,
				   ARG1 #arg ] !>,
			  HCONS <! [ LARG #neghand ],
                                    qeq,
				    qeq &
				    [ HARG #arg,
				      LARG #chand ] !> ] ] ].

; 09-09-97  Added ARG0 and BODY attributes temporarily for VM2, since the
; whq external relation for how_about is like a quantifier, needing four args.
; Had to change the relation introduced by "how about" to '_which_q_rel'
; rather than '_how_about_rel' because of some property of vitADT.  Similar
; change made to the 'frag-msg' instance in syntax.tdl.
; 06-Oct-98 DPF - Changed MC value from na to +, to allow "okay, how about kim"
; DPF 25-sept-04 - Changed SUBJ, SPR, and MOD from < > to < anti_synsem_min > 
; so these can conjoin with ordinary clauses.

basic_how_about_word := basic_root_marker_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < anti_synsem_min >,
                                  KEYS.KEY norm_rel,
                                  VFORM fin,
                                  TAM.TENSE real_tense ],
                           VAL [ SUBJ < anti_synsem_min >,
                                 SPR < anti_synsem_min >,
                                 COMPS < [ LOCAL.CAT.VAL [ SPR *olist*,
                                                           COMPS < > ] ] > ],
                           MC + ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS.LIST < #msg,
                                        event_relation &
                                        [ PRED generic_verb_rel,
                                          LBL #arghand ],
                                        relation & #key &
                                        [ LBL #rhand,
                                          ARG1 #arg ], ... >,
                            HCONS.LIST < qeq &
                                         [ HARG #cltop,
                                           LARG #rhand ],
                                         qeq &
                                         [ HARG #arg,
                                           LARG #arghand ], ... >,
                            MSG #msg & message &
                                      [ LBL #ltop,
                                        PRED prop_ques_m_rel,
                                        MARG #cltop ] ] ],
             LKEYS.KEYREL norm_adj_relation & #key ] ].

how_about_word := basic_how_about_word & root_marker_word.

; DPF 12-Apr-03 - Constrained COMPS..VAL.COMPS to be < > to avoid spurious
; ambiguity due to application of noptcomp rule (e.g. "how about sometime").
comp_how_about_n_or_p_lexent := how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD n_or_p,
                                                   VAL.COMPS < > ],
                                             CONT.HOOK.LTOP #ltop ],
                                     --SIND #ind,
                                     OPT - ] >,
                   CONT [ HOOK.INDEX #event & event,
                          RELS.LIST < relation, 
                                      [ LBL #ltop,
                                        ARG0 #event,
                                        ARG2 #ind ], 
                                      relation, ... >,
                          HCONS <! qeq, qeq !> ] ] ].

; how about
comp_how_about_n_or_p_le := comp_how_about_n_or_p_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --SIND #ind ] >,
                   CONT.RELS <! relation, [ ARG2 #ind ], relation !> ] ].

; how long before the end?  how long before kim arrives?
comp_how_about_pp_le := comp_how_about_n_or_p_lexent &
  [ SYNSEM.LOCAL 
     [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD prep &
                                  [ MOD < [ LOCAL scopal_mod &
                                                  [ CONT.HOOK.LTOP #mtop ] ]>],
                                 CONT.HOOK.LTOP #ltop ] ] >,
       CONT.RELS <! relation, 
                  [ ARG2 #ltop ],
                  relation,
                  event_relation &
                  [ PRED generic_verb_rel,
                    LBL #mtop ] !> ] ].

comp_how_about_s_le := how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD verb,
                                                   MC + ],
                                             CONT.HOOK.LTOP #ltop ],
                                     OPT - ] >,
                   CONT [ HOOK.INDEX #event,
                          RELS <! relation, 
                                 [ ARG0 #event,
                                   ARG1 #ltop ], 
                                   relation !>,
                          HCONS <! qeq, qeq !> ] ] ].

; DPF 25-Nov-01 - Removed INDEX..TENSE no_tense since root_strict requires
; real_tense.
comp_how_about_or_why_vp_lexent := how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD verb,
                                                   VAL.SUBJ < synsem > ],
                                             CONT.HOOK.LTOP #cltop ],
                                     OPT - ] >,
                   CONT [ HOOK.INDEX #ind & event,
                          RELS <! relation, 
                                 [ ARG0 #ind,
                                   ARG1 #mltop ], 
                                 relation,
                                 message & [ LBL #mltop,
                                             PRED prpstn_m_rel,
                                             MARG #marg ] !>,
                          HCONS <! qeq, qeq,
                                    qeq & [ HARG #marg,
                                            LARG #cltop ] !> ] ] ].


; DPF 17-Apr-01 - Changed COMPS.FIRST..SUBJ from canonical_synsem to synsem
; since the former blocked "Why be late"

comp_how_about_vp_le := comp_how_about_or_why_vp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM prp ] > ].

comp_why_vp_le := comp_how_about_or_why_vp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM bse_only ] > ].

comp_why_nocomp_le := basic_how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < anti_synsem >,
                   CONT [ HOOK.INDEX #ind & event,
                          RELS <! relation, 
                                 [ ARG0 #ind ], 
                                 relation !>,
                          HCONS <! qeq, qeq !> ] ] ].

; Discourse-related sentential adverbs
;   (e.g. 'then, but')
; DPF 06-Oct-98 - Added MC + to MOD, to block "Kim says but sandy left"
; DPF 15-Oct-98 - Changed HEAD from adv to root-marker, to get "yes, okay"
; DPF 22-Oct-98 - Added MC + to the SYNSEM itself to block the relative clause
;   in "a programmer but he hired".
; DPF 09-Jun-99 - Added SLASH 0-dlist to MOD, to block e.g. "when yes Kim left"
; DPF 03-Oct-99 - Added SUBJ *olist* to MOD specific. - why wasn't it here 
; before?
; DPF 17-Apr-00 - Removed CONJ cnil to enable e.g. "yes and Kim left"
; DPF 22-Nov-01 - We have to make sure that disc_adv_words propagate the MC 
; feature of their modifiee, to block e.g. yes-no parse for "I would like to 
; arrive"

basic_disc_adv_synsem := synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL [ CAT [ VAL [ SPR *olist*,
                                                     COMPS < > ],
                                               MC #mc ] ],
				 NONLOC.SLASH 0-dlist ] > ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < > ],
                  MC #mc ],
	    CONJ cnil ],
    NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ] ].

disc_adv_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD root-marker &
		       [ PRD -,
			 MOD < [ LOCAL scopal_mod &
                                   [ CAT [ HEAD disc_adverbee &
                                              [ TAM.TENSE real_tense ],
                                           VAL.SUBJ *olist* ],
                                     CONT.MSG #msg ] ] > ],
                  MC + ],
            CONT.MSG #msg ] ].

disc_adv_phr_synsem := basic_disc_adv_synsem & phr_synsem &
  [ LOCAL.CAT.HEAD adv ].

;; DPF 24-Oct-98 Removed [MC +] from disc_adv_word, since this runs afoul of
;; the carefully balanced constraint on head-modifier structures which requires
;; [MC na], to allow relative clauses as modifiers while preventing ordinary
;; finite clauses from being modifiers.

disc_adv_word := msg_word &
  [ SYNSEM disc_adv_synsem &
	   [ LOCAL [ CAT.HEAD.KEYS.KEY abstr_excl_rel,
                     CONT [ HOOK [ LTOP #chand & handle,
                                   INDEX #cind ],
			    RELS.LIST < #key,
                                        [ LBL #chand,
                                          PRED discourse_rel,
                                          ARG0 #cind ], ... >,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #key & [ PRED abstr_excl_rel ] ] ].

adv_disc_preh_lexent := disc_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ POSTHD -,
                           HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #mltop,
                                        --SIND #mindex ] > ],
                     CONT.RELS <! [ LBL #khand,
                                    ARG0 #kind ],
                                [ L-HNDL #khand,
                                  L-INDEX #kind,
                                  R-HNDL #mltop,
                                  R-INDEX #mindex ] !> ],
             MODIFD.LPERIPH + ] ].

adv_disc_preh_le := adv_disc_preh_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED excl_rel ].

adv_disc_preh_grt_le := adv_disc_preh_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED greet_rel ].

adv_disc_posth_lexent := disc_adv_word &
  [ SYNSEM.LOCAL [ CAT [ POSTHD +,
                         HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #mltop,
                                      --SIND #mindex ] > ],
                   CONT.RELS <! [ LBL #khand,
                                  ARG0 #kind ],
                                [ R-HNDL #khand,
                                  R-INDEX #kind,
                                  L-HNDL #mltop,
                                  L-INDEX #mindex ] !> ] ].

adv_disc_posth_le := adv_disc_posth_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED excl_rel ].

adv_disc_posth_grt_le := adv_disc_posth_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED greet_rel ].

disc_adv_sat_le := disc_adv_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ < > ] >,
                   CONT.RELS <! relation, relation !> ] ].

; This is like really necessary
disc_adv_like_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD root-marker &
                     [ PRD -,
                       MOD < [ LOCAL scopal_mod &
                                     [ CAT [ HEAD subst,
                                             MC na_or_+ ],
                                       CONT [ HOOK #hook,
                                              MSG #msg ] ] ] >,
                       KEYS.KEY abstr_excl_rel ],
            CONT [ HOOK #hook,
                   MSG #msg,
                   RELS <! !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL.PRED abstr_excl_rel ].

adv_disc_like_lexent := msg_word &
  [ SYNSEM disc_adv_like_synsem &
           [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL [ LBL #ltop,
                            PRED excl_rel ] ] ].

adv_disc_like_le :< adv_disc_like_lexent.
adv_disc_like_preh_le := adv_disc_like_lexent &
 [ SYNSEM.LOCAL.CAT.POSTHD - ].
; 'i think'
adv_disc_like_posth_le := adv_disc_like_lexent &
 [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PUNCT.RPUNCT pair_or_no_punct ] >,
                      POSTHD + ] ].

; General sentence or phrase particle
disc_adv_any_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD root-marker &
                     [ PRD -,
                       MOD < [ LOCAL scopal_mod &
                                   [ CONT [ HOOK #hook,
                                            MSG #msg ] ] ] > ],
            CONT [ HOOK #hook,
                   MSG #msg,
                   RELS <! !>,
                   HCONS <! !> ] ] ].

; Tell me please if my account is closed
adv_disc_please_le := msg_word &
  [ SYNSEM disc_adv_any_synsem &
	   [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL [ CAT.HEAD subst,
                                                  CONT.MSG.PRED imp_m_rel ]] >,
                                  KEYS.KEY abstr_excl_rel ],
                           POSTHD - ] ],
             LKEYS.KEYREL.PRED excl_rel ] ].

; Semantically empty particle: e.g. "-" as in "He arrived -"
adv_disc_nosem_le := msg_word &
  [ SYNSEM disc_adv_any_synsem &
	   [ LOCAL.CAT.HEAD [ KEYS.KEY no_rel,
                              MOD < [ LOCAL [ CAT.HEAD subst &
                                                       [ TAM.TENSE real_tense],
                                              CONT.MSG message ] ] > ],
             LKEYS.KEYREL.PRED no_rel ] ].

wh_the_hell_le := msg_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD wh_adv &
                                [ MOD < >,
                                  KEYS.KEY wh_the_hell_rel ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ] ],
		     CONT [ RELS <! !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL.PRED wh_the_hell_rel,
             NONLOC [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Temporal nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Extend to COMPS of temporal nouns the hack blocking extraction of subjects of
; inverted auxiliaries, which exploits CASE value.
; Block N-N compound of "a two meeting" by stipulating that hour_words are
; PRD +, incompatible with requirement of compound rule.  In contrast, e.g.,
; day_of_week words are unmarked for PRD.
;
; Made CONT.HOOK.LTOP be the handle of the numbered_hour_rel rather than that 
; of the implicit def_q_rel, since hour_words can be modified, as in "two 
; o'clock on the sixteenth".  Since the PP unifies its LTOP handle with the 
; LTOP handle of the phrase it modifies, that handle can't be the handle of the
; quantifier, so must be that of the numbered_hour_rel.

; DPF (18-Oct-98) - Removed PRD + from hour_word, so it can combine with its
; minute or am-pm complements and still be a prenominal adjective, as in
; "a ten thirty am meeting"

; DPF (22-Dec-98) - SYNSEM is typed phr_synsem in order to block 
; "a two meeting" while admitting "a two o'clock meeting" - this works because
; "two o'clock" combines with "meeting" using the noun-noun compound rule, 
; which requires the left member to have SYNSEM of type lex_synsem.

; DPF 13-May-01 - Added [RPERIPH +] to prevent hour words from being modified
; (especially by relative clauses), and therefore added optional prd-pp 
; complement to still get e.g. "three in the morning"
; DPF 9-Oct-02 - Can't have these be phr_synsem, since that prevents them from
; undergoing the (necessary) noptcomp rule (which is constrained to lex_synsem
; dtrs in order to prevent spurious ambiguity from n-n-cmpnds).  So instead
; make it LEX - without commitment to the synsem type.
; DPF 27-Oct-02 - Changed HC-LEX from + to +* so we can get coordination of
; "two and two thirty".
; DPF 30-Apr-03 - Considered adding ALTKEY no_rel to prevent these from 
; appearing as left member of np-n compounds after getting a specifier, as in
; "*the at least two chairs", but this fails because the entry for 'from'
; as in "from ten to two" requires the first comp to have non-empty ALTKEY.
; So look for a more general reason to block the above.
; DPF 05-dec-03 - Added SPEC < anti_synsem_min > to prevent these from being 
; specifiers of the hspec rule; preferring instead the hspechc rule for "nine 
; to ten pm'.  Can't say SPEC < > since particle preps want NP complement
; which is SPEC < anti_synsem_min >.

abstr_hour_word := hc_word & non_affix_bearing & basic_noun_word &
  [ SYNSEM synsem &
    [ LOCAL nomod_local &
            [ CAT [ HEAD noun & [ POSS -,
                                  KEYS [ KEY numbered_hour_rel,
                                         ALTKEY implicit_q_rel ] ],
                    VAL [ SUBJ < >,
                          SPR < [ LOCAL local_min &
                                  [ CAT [ HEAD n_or_adv &
                                           [ KEYS.KEY just_only_very_deg_rel ],
                                          VAL [ SPR  *olist*,
                                                COMPS < >,
                                                SPEC < [ LOCAL.CAT.VAL.COMPS 
                                                                  < > ] > ] ],
                                    CONT.HOOK [ LTOP #nhand,
                                                XARG #index ] ],
                                  OPT + ] >,
                          SPEC < anti_synsem_min >,
                          COMPS < expressed_synsem &
                                  [ LOCAL [ CAT [ HEAD intadj2 &
                                                  [ MOD < [ LOCAL.CONT.HOOK 
                                                            [ LTOP #nhand ]]>,
                                                    KEYS.KEY minute_rel ],
                                                  VAL.COMPS < > ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #min ] ],
                                    NONLOC.SLASH 0-dlist,
                                    OPT +,
                                    PUNCT.LPUNCT no_punct ],
                                  expressed_synsem &
                                  [ LOCAL [ CAT.HEAD no_head &
                                                     [ KEYS.KEY am_pm_rel ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #ampm ] ],
                                    NONLOC.SLASH 0-dlist,
                                    OPT +,
                                    PUNCT.LPUNCT no_punct ],
                                  expressed_synsem & 
                                  [ LOCAL 
                                    [ CAT prd_cat &
                                      [ HEAD prep &
                                        [ MOD < [ LOCAL.CAT.HEAD.KEYS.KEY
                                                                     #pred ] >,
                                          KEYS.KEY temp_loc_rel ] ],
                                      CONT.HOOK.LTOP #nhand,
                                      CONJ cnil ],
                                    --SIND #index,
                                    NONLOC.SLASH 0-dlist ] > ],
                    HC-LEX +,
                    HS-LEX - ],
              CONT nom-obj &
                       [ HOOK.INDEX #index,
                         RELS.LIST < #key &
                                     [ LBL #nhand,
                                       PRED #pred & numbered_hour_rel,
                                       ARG0 #index,
                                       ARG1 #min,
                                       ARG2 #ampm ],
				     [ PRED def_q_rel,
                                       ARG0 #index,
                                       RSTR #rhand ], ... >,
			 HCONS <! qeq &
                                  [ HARG #rhand,
                                    LARG #nhand ] !> ],
		   AGR #index,
		   ARG-S < > ],
      LKEYS.KEYREL #key,
      MODIFD notmod & [ RPERIPH + ] ] ].

n_hour_le := abstr_hour_word &
  [ SYNSEM [ LOCAL.CONT.RELS <! relation, relation !>,
             LEX - ] ].

; sixish
n_approx_hour_le := abstr_hour_word &
  [ SYNSEM.LOCAL.CONT.RELS <! relation &
			         [ LBL #hand,
				   ARG0 #arg0 ],
			         relation, 
			         [ LBL #hand,
                                   PRED approx_grad_rel,
				   ARG1 #arg0 ] !> ].

; For clocktime ersatz from preprocessor, as in '14.30', which is not
; marked [LEX -] since 'a 14.30 appointment' is fine.
n_hour_min_le := abstr_hour_word &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation !> ].

abstr_minute_word := np_word_no_quant &
  [ SYNSEM [ LOCAL [ CAT.HEAD intadj2 &
                              [ KEYS.KEY minute_rel,
                                PRD + ],
                     CONT.HOOK [ LTOP #hand,
                                 INDEX non_expl-ind & #inst &
                                      [ PNG png & [ PN 3sg ] ] ] ],
             LKEYS.KEYREL [ LBL #hand,
                            PRED minute_rel,
                            ARG0 #inst ],
	     MODIFD notmod ] ].

adj_minute_preh_le := abstr_minute_word &
  [ SYNSEM.LOCAL [ CAT.POSTHD -,
                   CONT.RELS <! relation !> ] ].


adj_minute_posth_le := abstr_minute_word &
  [ SYNSEM.LOCAL [ CAT.POSTHD +,
                   CONT.RELS <! relation !> ] ].

adj_approx_minute_le := abstr_minute_word &
  [ SYNSEM [ LOCAL [ CAT.POSTHD +,
                     CONT [ HOOK.LTOP #hand,
                            RELS <! relation, 
                                  [ LBL #hand,
                                    PRED approx_grad_rel,
                                    ARG1 #arg0 ] !> ] ],
             LKEYS.KEYREL.ARG0 #arg0 ] ].

; am/pm, AD/BC
xp_suffix_lexent := np_word_no_quant &
  [ SYNSEM [ LOCAL [ CAT.HEAD no_head,
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #arg0 ],
                            RELS <! [ LBL #ltop,
                                      ARG0 #arg0 ] !> ] ],
             LKEYS.KEYREL const_arg0_relation ] ].

xp_am_pm_le := xp_suffix_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY am_pm_rel ].

xp_bc_ad_le := xp_suffix_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY bc_ad_rel ].

n_mealtime_le := que_word & nonque & basic_noun_word &
  [ SYNSEM noun_synsem & nomod_synsem &
	 [ LOCAL [ CAT [ HEAD [ POSS -,
                                KEYS [ KEY gen_hour_rel,
                                       ALTKEY #altkey ] ],
			 VAL [ SPR < [ LOCAL local_min &
					     [ CAT [ HEAD adv &
                                                     [ KEYS.KEY 
                                                          just_only_deg_rel ],
                                                     VAL [ SPR  *olist*,
							   COMPS < > ] ],
                                               CONT.HOOK [ LTOP #nhand,
                                                           XARG #index ] ],
                                       OPT + ] >,
			       COMPS < > ] ],
		   CONT nom-obj &
		       [ HOOK [ LTOP #nhand,
                                INDEX #index & [ SORT time ] ],
			 RELS <! #key &
                               [ LBL #nhand,
                                 PRED hour_rel,
                                 ARG0 #index ],
                               [ PRED def_q_rel & #altkey,
                                 ARG0 #index,
                                 RSTR #rhand ] !>,
			 HCONS <! qeq &
			   [ HARG #rhand,
			     LARG #nhand ] !> ],
		   ARG-S < > ],
           LKEYS.KEYREL #key,
           MODIFD notmod ] ].

; June, June 1996, June of 1996
month_no_of_year_synsem := nonpro_nomod_synsem & one_arg &
  [ LOCAL [ ARG-S #comps,
            CAT [ HEAD noun &
                       [ KEYS [ KEY mofy_rel,
                                ALTKEY proper_q_rel ] ],
                  VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY quant_or_wh_rel,
                                OPT - ] >,
                        COMPS #comps &
                            < expressed_synsem & 
                              [ LOCAL local_min &
                                      [ CAT nomp_cat_acc_min &
                                            [ HEAD.KEYS.KEY yofc_rel,
                                              VAL [ SUBJ < >,
                                                    COMPS < >,
                                                    SPR *olist* ],
                                              MC na ],
                                        CONJ cnil ],
                                MODIFD notmod,
                                --SIND #yearind,
                                NONLOC.SLASH 0-dlist,
                                OPT - ] > ] ],
            AGR #ind,
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #ind & [ DIVISIBLE - ] ],
                   RELS <! #key &
                         [ LBL #ltop,
                           ARG1 #yearind ],
                           prep_relation &
                         [ LBL #hand,
                           PRED _of_p_sel_rel,
                           ARG2 #yearind ] !> ] ],
    LKEYS.KEYREL #key &
                  [ LBL #hand,
                    PRED mofy_rel,
                    ARG0 #ind &
                         [ PNG png & [ PN 3sg,
                                       GEN neut ] ] ],
    MODIFD notmod ].

n_month_year_le := no_affix_np & basic_noun_word &
  [ SYNSEM month_no_of_year_synsem ].

; DPF 16-Apr-03 - Finally added type for odd entries "October the" as in
; 'October the fifth'.  Duplicates much of what is in date_det_lr type, but
; not easy to see how to abstract (cf. HCONS for example).

det_month_synsem := basic_det_synsem &
  [ LOCAL [ CAT [ HEAD [ POSS -,
                         KEYS [ KEY def_explicit_q_rel,
                                ALTKEY mofy_rel ] ],
                  VAL [ COMPS < >,
                        SPEC < [ LOCAL [ CAT.HEAD.KEYS.KEY dofm_rel,
                                         CONT.HOOK.INDEX #ind ] ] > ] ],
            CONT [ RELS <! #key,
                           #altkey,
                           prep_relation &
                           [ LBL #nltop,
                             PRED of_p_rel,
                             ARG1 #ind,
                             ARG2 #spind ],
                           [ PRED def_q_rel,
                             ARG0 #spind,
                             RSTR #mhand ] !>,
                   HCONS <! qeq & [ LARG #nltop ],
                            qeq &
                            [ HARG #mhand,
                              LARG #mltop ] !> ] ],
    LKEYS [ KEYREL #key,
            ALTKEYREL #altkey & [ LBL #mltop,
                                  PRED mofy_rel,
                                  ARG0 #spind ] ],
    NONLOC [ SLASH 0-dlist,
             QUE 0-dlist,
             REL 0-dlist ],
    MODIFD hasmod ].

det_month_le := abstr_det_word &
  [ SYNSEM det_month_synsem ].

common_noun_nomod_comp_synsem := basic_count_noun_synsem & 
                                 nonpro_nomod_synsem & two_arg.
; DPF 22-May-01 Added LPERIPH + constraint to block these from beings heads of
; n-n compounds.
n_year_le := basic_non_affixed_np & 
  [ SYNSEM common_noun_nomod_comp_synsem &
         [ LOCAL [ CAT [ HEAD [ MOD < >,
                                KEYS.KEY yofc_rel ],
                         VAL [ SPR < [ LOCAL.AGR [ PNG.PN 3sg,
                                                 DIVISIBLE - ] ] >,
                               COMPS < expressed_synsem &
                                  [ LOCAL [ CAT.HEAD no_head &
                                                     [ KEYS.KEY bc_ad_rel ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #bcad ] ],
                                    NONLOC.SLASH 0-dlist,
                                    OPT + ] > ] ],
                   AGR.DIVISIBLE -,
		   CONJ cnil,
		   CONT [ HOOK [ LTOP #nhand,
                                 INDEX.PNG png & [ PN 3sg ] ],
                          RELS <! relation !>,
                          HCONS <! !> ] ],
           LKEYS [ KEYREL [ PRED yofc_rel,
                            LBL #nhand,
                            ARG1 #bcad ],
                   ALTKEYREL.PRED quant_or_wh_rel ],
           MODIFD notmod & [ LPERIPH + ] ] ].

; 'the first', 'October first', 'the first of October'
; Need to find way to block '*October first of October'
; DPF 20-Nov-99 - Added PRD + to block membership in N-N-compounds
; DPF 23-Oct-03 - Instead of PRD +, (which is now not consistent with making
; all non-measure NPs [PRD -]), use ALTKEY no_rel to block ordinals as 
; heads of n-n-compounds.
; DPF 25-aug-04 - Try adding LPERIPH - to prevent these from appearing as
; heads of n-n-compounds.  Can't be LPERIPH + since 'May 23 to 25' uses 'to'
; which requires complement to be LPERIPH na_or_- (for reasons no longer 
; clear).
; DPF 24-sept-04 - But LPERIPH - prevents application of npadv rule, as in
; 'we arrived the tenth', and anyway that LPERIPH constraint for 'to' is no
; longer used, so we make these LPERIPH +.

generic_dom_synsem := common_noun_synsem &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY dofm_rel,
                  VAL [ COMPS < synsem &
                                [ LOCAL [ CONJ cnil,
                                          CONT.HOOK.LTOP #hand ],
                                  NONLOC non-local_none ], ... >,
                        SPEC < anti_synsem_min > ] ],
            CONT [ HOOK.LTOP #hand,
		   RELS.LIST < generic_named_nom_relation &
                               [ LBL #hand,
                                 PRED dofm_rel,
                                 ARG0.PNG png & [ PN 3sg,
                                                  GEN neut ] ], ... > ] ],
    MODIFD hasmod & [ LPERIPH + ] ].

basic_dom_synsem := generic_dom_synsem &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY #key,
                  VAL [ SPR < synsem &
                            [ LOCAL [ CAT.HEAD.KEYS.KEY quant_or_wh_rel,
                                      AGR.PNG.PN 3sg ] ] >,
                        COMPS < [ LOCAL [ CAT [ HEAD.KEYS 
                                                   [ KEY _to_p_interval_rel,
                                                     ALTKEY #key ],
                                                VAL.COMPS < > ],
                                          CONT.HOOK.XARG #ind ],
                                  OPT +,
                                  PUNCT.LPUNCT no_punct ], ... > ] ],
            CONT.HOOK.INDEX #ind & [ DIVISIBLE - ] ] ].

basic_dom_ord_synsem := basic_dom_synsem &
  [ LOCAL.CAT [ HEAD.KEYS.ALTKEY def_explicit_q_rel,
                VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY abstr_def_q_rel ] >,
                      COMPS < synsem, ... > ] ] ].

dom_ord_synsem := basic_dom_ord_synsem & temp_noun_ppcomp_synsem & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem > ] ].

dom_ord_yofc_synsem := basic_dom_ord_synsem & basic_noun_npcomp_synsem &
                       three_arg &
  [ LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.ALTKEY mofy_rel ] >,
                    COMPS < synsem, 
                            #comp &
                            [ LOCAL.CAT.HEAD.KEYS.KEY yofc_rel & #ckey,
                              NONLOC.SLASH 0-dlist,
                              OPT - ] >,
                    KCMP #comp ],
    LKEYS.--+COMPKEY #ckey ].

; DPF 31-May-02 - Changed SPR..KEY from implicit_q_rel to def_q_rel, to make
; sure these dom's don't undergo the robust bare_pl_sg rule.
dom_card_synsem := basic_dom_synsem & basic_noun_npcomp_synsem & three_arg &
  [ LOCAL [ CAT [ HEAD [ PRD -,
                         KEYS.ALTKEY norm_rel ],
                  VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS [ KEY def_q_rel,
                                                      ALTKEY mofy_rel ] ] >,
                        COMPS < synsem,
                                #comp &
                                [ LOCAL.CAT.HEAD.KEYS.KEY yofc_rel,
                                  MODIFD notmod,
                                  OPT + ] >,
                        KCMP #comp ] ] ],
    LKEYS.ALTKEYREL relation ].

;; 12 october (2003)
dom_euro_synsem := generic_dom_synsem & basic_noun_npcomp_synsem &
  [ LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY udef_q_rel ] >,
                    COMPS < #keycomp &
                            [ LOCAL.CAT.HEAD.KEYS.KEY mofy_rel,
                              OPT -,
                              PUNCT.LPUNCT hyphen_sgl_or_no_punct ] >,
                    KCMP #keycomp ] ].

abstr_n_day_of_month_lexent := hc_word & non_affix_bearing & basic_noun_word &
  [ SYNSEM generic_dom_synsem ].

n_day_of_month_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_ord_synsem ].

n_day_of_month_card_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_card_synsem ].

n_day_of_month_euro_le := abstr_n_day_of_month_lexent &
  [ SYNSEM dom_euro_synsem ].

; 'Tuesday (the first (of October))', 'Tuesday (October first)'
; 'Tuesday of that week'
; DPF 31-Jul-99 - Made SYNSEM be nonpro_nomod_onearg_synsem instead of 
; nomod_basic_onearg_synsem since they can appear in noun-noun compounds,
; and also in appositive constructions.


; 'morning' of 'each morning', 'Tuesday morning'
; DPF 19-Oct-02 - Broke this up into two entries, one with empty COMPS
; that excludes "the" to block "I arrived the morning"; and the other with
; PP-of to allow "I arrived the morning of the fifth."
; DPF 23-Apr-03 - Moved MODIFD from basic_n_day_part_lexent to the nocomp
; subtype, to continue to block "*I arrived the morning" (where the temp_np
; rule requires the dtr to be [MODIFD hasmod], and where the determiner "the"
; passes up the MODIFD value of its SPEC) while allowing "I arrived the
; morning of the third" where this pp-comp 'morning' is unmarked for MODIFD.
; DPF 26-Apr-03 - Note that this awkward machinery for three entries (at least)
; for day-part words like "morning" will have to be generalized, since the same
; constraints hold for a few non-temporal nouns like "way" as in 
; 'Kim sang the way you did'  and 'Kim sings that way' but '*Kim sang the way'.
; Also "time" as in "I fell the time he was here" but "*I fell the time".

;basic_n_day_part_lexent := que_word & basic_noun_word &

basic_n_day_part_lexent := norm_word & basic_noun_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL [ CAT [ HEAD noun &
                                [ KEYS.KEY day_part_rel ],
                          VAL.SPR < synsem &
                                     [ LOCAL local_min &
					  [ CAT [ HEAD det &
                                                 [ KEYS.KEY quant_or_wh_rel ],
                                                  VAL [ SUBJ < >,
							COMPS < > ] ] ],
                                       --SIND #ind,
                                       OPT - ] > ],
                     AGR #ind,
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #ind ],
			    RELS <! #key & [ LBL #ltop ] !>,
                            HCONS <! !> ] ],
             LKEYS.KEYREL #key & day_part_relation &
                   [ ARG0 #ind ] ] ].

onearg_count_n_synsem := nonpro_nomod_onearg_synsem & count_noun_synsem.
twoarg_count_n_synsem := noun_two_arg_nomod_synsem & count_noun_synsem.

n_day_part_nocomp_le := basic_n_day_part_lexent &
  [ SYNSEM onearg_count_n_synsem &
	   [ LOCAL [ ARG-S < #spr >,
                     CAT.VAL [ SPR < #spr &
                                    [ LOCAL.CAT.HEAD.KEYS.ALTKEY 
                                                    dofw_or_poss_q_rel ] >,
                               COMPS < > ] ],
	     MODIFD notmod ] ].

n_day_part_ppcomp_lexent := basic_n_day_part_lexent &
  [ SYNSEM twoarg_count_n_synsem &
	   [ LOCAL [ ARG-S < #spr . #comps >,
                     CAT.VAL [ SPR < #spr >,
                               COMPS #comps &
                                 < [ LOCAL [ CAT [ HEAD.KEYS.KEY _of_p_sel_rel,
                                                   VAL.COMPS < > ],
                                             CONT.HOOK [ LTOP #nhand,
                                                         INDEX #ind ] ],
                                     LKEYS.--COMPKEY dofm_rel,
				     NONLOC.SLASH 0-dlist,
                                     OPT - ] > ],
                     AGR #ind & [ DIVISIBLE - ] ],
             LKEYS.KEYREL.LBL #nhand ] ].

n_day_part_sg_le := n_day_part_ppcomp_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3sg,
                                         GEN neut ] ].

n_day_part_pl_le := n_day_part_ppcomp_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3pl ] ].

n_holiday_le := n_intr_temp_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD.KEYS [ KEY holiday_rel,
                                     ALTKEY basic_nom_rel ],
                     CONT.HOOK.INDEX.PNG png & [ PN 3sg ] ],
             LKEYS.KEYREL.PRED holiday_rel ] ].


; 'Advent', 'summer', 'Christmas'
n_season_div_le := noun_noninfl_word &
  [ SYNSEM mass_noun_onearg_synsem &
           [ LOCAL [ CAT.HEAD.KEYS.KEY season_nomod_rel,
                     CONT [ HOOK.INDEX.PNG png & [ PN 3sg ],
                            RELS <! nom_relation !> ] ],
             MODIFD notmod & [ LPERIPH na ],
             LKEYS.KEYREL.PRED season_rel ] ].

n_season_wspec_le := noun_noninfl_word &
  [ SYNSEM noun_nocomp_synsem &
           [ LOCAL [ CAT.HEAD.KEYS [ KEY season_rel,
                                     ALTKEY quant_or_wh_rel ],
                     CONT [ HOOK.INDEX.PNG png & [ PN 3sg ],
                            RELS <! relation !>,
                            HCONS <! !> ] ],
             MODIFD notmod & [ LPERIPH na ],
             LKEYS.KEYREL.PRED season_rel ] ].

n_season_np_le := noun_noninfl_word &
  [ SYNSEM mass_noun_npcomp_synsem &
           [ LOCAL [ CAT [ HEAD.KEYS [ KEY season_rel,
                                       ALTKEY quant_or_wh_rel ],
                           VAL.COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY yofc_rel ] >],
                     CONT.HOOK.INDEX.PNG png & [ PN 3sg ] ],
             MODIFD notmod,
             LKEYS.KEYREL.PRED season_rel ] ].

; "the morning" etc.
; DPF 14-Oct-02 - Added ALTKEY relation to prevent these entries from 
; appearing as complements of "per", to avoid spurious ambiguity for e.g.
; "per night"
; DPF 15-Apr-03 - Removed strange constraint SPR..CONT.RELS <! relation !>,
; which blocked (among other things) "my mornings".  Instead, made
; SPR..KEY be def_explicit_q_rel to allow only "the" and possessive pronouns.

n_def_day_part_lexent := norm_no_affix_word & basic_noun_word &
  [ SYNSEM nomod_onearg_synsem &
	   [ LOCAL [ ARG-S < #spr >,
		     CAT [ HEAD noun & [ KEYS [ KEY def_day_part_rel,
                                                ALTKEY norm_rel ] ],
			   VAL 
			    [ SPR < synsem & #spr &
				  [ LOCAL local_min &
					  [ CAT 
                                            [ HEAD det &
                                              [ KEYS.KEY def_explicit_q_rel ],
                                              VAL [ SUBJ < >,
                                                    COMPS < > ] ] ],
                                    --SIND #inst,
                                    OPT - ] >,
			      COMPS < expressed_synsem &
                                      [ LOCAL [ CAT [ HEAD prep & 
                                                     [ PRD -,
                                                       TAM [ TENSE no_tense,
                                                             ASPECT no_aspect],
                                                       KEYS 
                                                         [ KEY _of_p_sel_rel,
                                                           ALTKEY dofm_rel ] ],
                                                      VAL.COMPS < > ],
                                                CONT.HOOK [ LTOP #nhand,
                                                            INDEX #arg2 ] ],
                                        NONLOC.SLASH 0-dlist,
                                        PUNCT.LPUNCT no_punct ] > ],
                           POSTHD + ],
		     AGR #inst,
                     CONT [ HOOK.INDEX #inst,
			    RELS <! #key !> ] ],
             LKEYS [ KEYREL #key &
                            [ LBL #nhand,
                              PRED def_day_part_rel,
                              ARG0 #inst,
                              ARG1 #arg2 ],
                     ALTKEYREL relation ],
             MODIFD notmod & [ LPERIPH na_or_- ] ] ].

n_def_day_part_sg_le := n_def_day_part_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3sg,
                                           GEN neut ],
                               DIVISIBLE - ] ].

n_def_day_part_pl_le := n_def_day_part_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3pl ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Degree specifiers for adjectives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 'very, really, much, a lot, almost';
; Treated as measure phrases, selected as specifiers by adjectives.

;; DPF 27-Aug-01 - Removed INDEX ref-ind constraint, which was blocking
;; e.g. "kim is just behind the door"
;; DPF 8-Sep-01 - Added MODIFD.LPERIPH na to make sure that "about two weeks"
;; has this value, to block its appearing as head in in n_n_compounds.
;; DPF 25-Sep-01 - Block specification of conjoined phrase for now, since we
;; don't know what to do with the semantics anyway.
;; DPF 10-Apr-03 - Made HEAD simply adv rather than old adv_or_partn, since
;; no need to treat these phrases as noun-like - solves several problems,
;; including avoiding these appearing as complements of prepositions.
;; Can probably get rid of LPERIPH specification now - check later.
;; DPF 26-sept-04 - Moved [XARG individual_min] down to lex_degree_spec
;; subtype, in order to allow measure-NPs (with phr_degree_spec_synsem) to
;; appear in appositive constructions like "three meters (10')".  (Can't
;; remember what this constraint is meant to exclude, but it's probably useful)

basic_degree_spec_synsem := canonical_synsem &
  [ LOCAL nomod_local &
          [ CAT [ VAL [ SUBJ < >,
                        SPR < [ LOCAL local_min &
                                      [ CAT [ HEAD n_or_adv &
                                                   [ KEYS.KEY degree_rel ],
                                              VAL.SPR *olist* ],
                                        CONT.HOOK [ LTOP #khand,
                                                    XARG #spind ] ],
                                NONLOC.QUE 0-dlist ] > ] ],
            CONT [ HOOK.XARG #ind,
                   RELS.LIST.FIRST 
                              [ LBL #khand,
                                ARG0 #spind,
                                ARG1 #ind ] ] ] ].

; DPF 11-Feb-02 - Can't have this be POSTHD - (and why did we want it?), 
; since the spec-head rule takes the value of POSTHD from the head's spr
; value, which blocked "kim arrives really soon".
; DPF 25-May-03 - Need POSTHD of specifier to be that of its SPEC, to make
; sure that "maybe in Berlin" is still POSTHD +.

basic_lex_degree_spec_synsem := basic_degree_spec_synsem & lex_synsem &
  [ MODIFD.LPERIPH na,
    LOCAL [ CAT [ HEAD adv,
                  VAL.SPEC < [ LOCAL.CAT [ POSTHD #ph,
                                           HS-LEX + ] ] >,
                  POSTHD #ph ],
            CONT [ HOOK.INDEX #index,
                   RELS.LIST.FIRST #keyrel & [ ARG0 #index ] ] ],
    LKEYS.KEYREL #keyrel ].

lex_degree_spec_synsem := basic_lex_degree_spec_synsem &
  [ LOCAL [ CAT [ HEAD.KEYS.KEY degree_rel,
                  VAL.COMPS < > ],
            CONT [ HOOK.LTOP #ltop,
                   RELS.LIST.FIRST.LBL #ltop ] ] ].

; For measure_nps as in "two foot tall"
; DPF 4-Nov-02 - Removed [ LOCAL.CONT.HOOK.XARG nothing ], since now identify
; XARGs of modifier and modifiee.  Why was it added before?

; phr_degree_spec_synsem := degree_spec_synsem & phr_synsem.
phr_degree_spec_synsem := basic_degree_spec_synsem & lex_phr_synsem &
  [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY just_only_very_deg_rel ] > ].

; For "as" of "as soon as possible" and "too" in "too good to miss"
basic_comp_degree_spec_synsem := basic_lex_degree_spec_synsem &
  [ LOCAL [ CAT.VAL.SPEC < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                               INDEX #ind ] ] >,
            CONT [ HOOK.LTOP #ltop,
                   RELS <! #key & [ LBL #ltop ],
                           #altkey &
                         [ LBL #hand,
                           PRED comp_rel,
                           ARG1 #ind ] !>,
                   HCONS <! !> ] ],
    NONLOC.QUE 0-dlist,
    LKEYS [ KEYREL #key,
            ALTKEYREL #altkey ] ].

; DPF 13-Nov-03 - Constrained SPEC value to be PRD + to prevent "The as tall
; player ..." or "the too beautiful chair ..."

comp_degree_wcomps_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL.CAT [ HEAD.KEYS.KEY comp_as_too_degree_rel,
                VAL [ COMPS < synsem & [ LOCAL.CONJ cnil,
                                         OPT -,
                                         PUNCT.LPUNCT no_punct ] >,
                      SPEC < [ LOCAL.CAT.HEAD.PRD + ] > ] ] ].

comp_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                INDEX #ind ],
                              NONLOC non-local_none ] >,
                    SPEC < [ LOCAL.CONT.HOOK.LTOP #ltop ] > ],
    LKEYS.ALTKEYREL.ARG2 #ind ].

as_degree_spec_synsem := comp_degree_spec_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD prep &
                                             [ KEYS.KEY _as_p_comp_rel ],
                                        VAL.COMPS < > ] ] > ].

more_degree_spec_synsem := comp_degree_spec_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD prep &
                                             [ KEYS.KEY _than_p_compar_rel ],
                                        VAL.COMPS < > ] ] > ].
                           
basic_too_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT.VAL [ COMPS < [ LOCAL [ CAT s_or_vp_inf_cat,
                                      CONT [ HOOK.LTOP #ltop,
                                             MSG message ] ] ] > ],
    LKEYS.ALTKEYREL.ARG2 #ltop ].

too_degree_spec_slash_synsem := basic_too_degree_spec_synsem &
  [ LOCAL.CAT.VAL [ COMPS < [ NONLOC.SLASH 1-dlist &
                                    <! [ CAT np_cat_min &
                                             [ HEAD.KEYS.KEY norm_nom_rel ],
                                         CONT.HOOK.INDEX #ind ] !> ] >,
                    SPEC < [ LOCAL.CONT.HOOK.XARG #ind ] > ] ].

too_degree_spec_synsem := basic_too_degree_spec_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ NONLOC.SLASH 0-dlist ] > ].

so_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT.VAL [ COMPS < [ LOCAL [ CAT s_cat_fin_v_c &
                                          [ HEAD comp ],
                                      CONT [ HOOK.LTOP #ltop,
                                             MSG message & 
                                                 [ PRED prpstn_m_rel ] ] ],
                              NONLOC.SLASH 0-dlist ] > ],
    LKEYS.ALTKEYREL.ARG2 #ltop ].

; DPF 28-Apr-03 - Until we move to always discharging optional complements,
; we have to split 'as' into two lexical entries, one with an as-comp and one
; without, in order to be able to coordinate "as early and as late" where
; the top_coord_nom rule requires COMPS to be empty (since this 'as' pushes
; its complement to 'as early').

comp_degree_spec_nc_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL.CAT [ HEAD.KEYS.KEY comp_as_too_degree_rel,
                VAL.COMPS < > ] ].

comp_degree_spec_enough_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL.CAT [ HEAD.KEYS.KEY enough_deg_rel,
                VAL [ SPR < anti_synsem_min >,
                      COMPS < > ] ] ].

basic_degree_spec_word := que_word &
  [ SYNSEM basic_lex_degree_spec_synsem &
           [ LOCAL.CONT.RELS.LIST < #key, ... >,
             LKEYS.KEYREL #key ] ].

degree_spec_word := basic_degree_spec_word & nonque &
  [ SYNSEM lex_degree_spec_synsem &
           [ LOCAL.CONT [ RELS <! degree_relation !>,
                          HCONS <! !> ] ] ].

adv_degree_spec_lexent :< degree_spec_word.

adv_degree_spec_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY deg_rel ].

adv_degree_spec_v_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY very_deg_rel ].

adv_degree_spec_m_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY much_deg_rel ].

; This type allows unification with very_deg_rel, while the next does not.
adv_degree_spec_jov_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY just_only_degree_rel ].

adv_degree_spec_jo_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY just_only_deg_rel ].

; This type requires unification with very_deg_rel, so cannot be used with
; e.g. determiner 'the', as in "straight (into ...)" or "up to (ten ...)"
adv_degree_spec_jov_only_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY just_only_very_deg_rel ].

; For 'only' (at least): 'only ten feet', 'only in Paris'
adv_degree_spec_deg_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY deg_rel ].

adv_degree_spec_tt_le := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY this_that_deg_rel ].

adv_degree_spec_div_lexent := degree_spec_word.

; 'all'
adv_degree_spec_div_le := adv_degree_spec_div_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY very_deg_rel ].

adv_degree_spec_div_tt_le := adv_degree_spec_div_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY this_that_deg_rel ].

; 'under'
adv_degree_spec_int_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY deg_rel ].


;;adv_degree_spec_pp_le := adv_degree_spec_lexent &
;;  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD prep ] > ].

; 'roughly', 'wide(-spread)', 'jam(-packed)'
adv_degree_spec_adj_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY very_deg_rel ].

; 'any' - want to block e.g. phrase "a laptop any" in "have a laptop any more"
adv_degree_spec_nospec_le := degree_spec_word &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY much_deg_rel ].

; "how tall"
; DPF 21-Jul-03 - Will want opt comp of-PP or indef-NP to get "how good (of) a
; player is he"
adv_wh_degree_spec_lexent := basic_degree_spec_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY degree_rel,
                           VAL.COMPS < > ],
                     CONT [ RELS <! [ LBL #hand,
                                      PRED abstr_deg_rel,
                                      ARG0 #arg0 ],
                                  [ PRED which_q_rel,
                                    ARG0 #arg0,
                                    RSTR #hand ] !>,
                            HCONS <! !> ] ],
	     NONLOC.QUE 1-dlist & [ LIST < handle > ] ] ].

; How tall
adv_wh_degree_spec_le := adv_wh_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY very_deg_rel ].

; How much taller
adv_wh_degree_spec_m_le := adv_wh_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY much_deg_rel ].

as_degree_spec_le := que_word &
  [ SYNSEM as_degree_spec_synsem ].

too_degree_spec_le := que_word &
  [ SYNSEM too_degree_spec_synsem ].

too_degree_spec_sl_le := que_word &
  [ SYNSEM too_degree_spec_slash_synsem ].

so_degree_spec_le := que_word &
  [ SYNSEM so_degree_spec_synsem ].

more_degree_spec_le := que_word &
  [ SYNSEM more_degree_spec_synsem ].

comp_degree_spec_nc_le := que_word &
  [ SYNSEM comp_degree_spec_nc_synsem ].

comp_degree_spec_enough_le := que_word &
  [ SYNSEM comp_degree_spec_enough_synsem ].

; For measure-np ersatz
; ALT2KEY norm_rel prevents these from also appearing in noun_n_cmpnds, 
; leaving only the np_n_cmpnd we want for "200m climb"
; DPF 7-mar-05 - Removed MODIFD notmod since this prevented "200m away" from
; undergoing the npadv rule, and its motivation remained obscure.
; DPF 29-mar-05 - Changed KEY to deg_rel so we get "half an hour before Kim
; arrives"
meas_np_le := affix_neutral_word &
  [ INFLECTD bool & #prd,
    SYNSEM phr_degree_spec_synsem &
           [ LOCAL [ CAT [ HEAD noun & [ PRD #prd,
                                         KEYS [ KEY deg_rel,
                                                ALT2KEY norm_rel ] ],
                           VAL [ COMPS < >,
                                 SPEC < synsem &
                                       [ LOCAL [ CAT.HEAD n_or_p_or_a & 
                                                      [ PRD #prd ] ] ] > ] ],
                     CONT [ HOOK.INDEX #index,
                            RELS <! #key & [ LBL #nhand,
                                             ARG0 #index ],
                                  [ PRED udef_q_rel,
                                    ARG0 #index,
                                    RSTR #rhand ] !>,
                            HCONS <! qeq &
                                   [ HARG #rhand,
                                     LARG #nhand ] !> ],
                     AGR.PNG.PN 3sg,
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             LKEYS.KEYREL #key,
             ROOT - ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Numbers
;;
;; DPF 14-Apr-01 - Numerals combine with their complements and specifiers as
;; laid out in Smith 2000, but since the specifier-head rule makes the TOP
;; handle of the phrase be that of the spr dtr, we can't have numerals simply
;; identify their LTOP value with their KEY.LBL value or something similar.
;; Hence, numerals combine using the LBL of the attribute ALTKEY, which
;; points to the KEY for simple numerals like "two", but to the plus_rel or
;; the times_rel for more interesting numerals like "hundred".  
;;   The LTOP handle is identified with the SPEC's handle, so when a numeral is
;; built using the specifier-head rule, the resulting LTOP handle will be the 
;; same as the LTOP handle of the head-dtr.  This is useful because of two other
;; regularities:
;;   (1) the MOD's handle is identified with the ALTKEY's handle; and
;;   (2) the intersective modifier-head rule identifies the MOD's handle with
;;       the modifier's LTOP handle.
;; This ensures that the LTOP handle of a numeral modifier will be identified
;; with the ALTKEY's handle, as desired.

; For numerals
anycard_norm_num_synsem := canonical_synsem & basic_zero_arg &
  [ LOCAL [ CAT [ HEAD intadj,
                  VAL.SUBJ < >,
		  POSTHD - ],
	    CONT [ HOOK.XARG non_expl-ind,
                   RELS.LIST < integer_relation, ... > ] ] ].

; DPF 6-Jun-01 - Added MODIFD.LPERIPH - to avoid unwanted reading for 
; "two hundred three chairs".
; But this blocks "two competent programmers", so make [LPERIPH na].
; DPF 28-Apr-03 - This PERIPH feature is overloaded since it does not
; distinguish directionality - the two uses clash for examples like "the
; first chair that I bought arrived" where for ordering of thatless and
; full relatives we want "chair that I bought" to be (right) [PERIPH +] but 
; to avoid double ordinals we want it to be (left) [PERIPH -].  So change to
; two features LPERIPH and RPERIPH.
; DPF 16-oct-03 - Since now making adj+N be [LPERIPH +], change this type so
; it asks for a MOD..LPERIPH bool but projects LPERIPH na so we can still
; block unwanted parse for "two hundred three chairs" but allow "two hundred
; big chairs".
; Pushed this down to cards, not ords, so we can get "the first seven chairs...

basic_norm_num_synsem := anycard_norm_num_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL intersective_mod &
                                   [ CAT nbar_cat_min &
                                         [ HEAD.KEYS.KEY nonpro_rel,
                                           VAL.SPR < expressed_synsem > ],
                                     CONT.HOOK.INDEX #xarg,
                                     CONJ cnil,
                                     AGR #xarg ] ] >,
                  HC-LEX + ],
            CONT [ HOOK [ INDEX #index,
                          XARG #xarg ],
                   RELS.LIST.FIRST [ ARG0 #index,
                                     ARG1 #xarg ] ] ],
    MODIFD.LPERIPH na ].

norm_num_synsem := basic_norm_num_synsem & zero_arg &
  [ LOCAL.CONT.RELS.LIST.FIRST #key,
    LKEYS.KEYREL #key ].

; DPF 9-jul-04 - Is this used?
phr_norm_num_synsem := basic_norm_num_synsem & phr_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ MODIFD.LPERIPH bool ] >,
            CONT.HCONS <! !> ] ].

; DPF 05-apr-05 - Moved PRD - to norm_card_word since it blocks "Kim was third"

norm_num_word := no_affix_np &
  [ SYNSEM norm_num_synsem ].

;; some norm_card-words must remain unspecified for CARDINAL
;; DPF 10-Apr-02 - Moved MOD..DIVISIBLE +* from norm_num_word to norm_card_word
;; since ordinals don't require this: "the eleventh child"
; DPF 27-nov-04 - In fact, DIVISIBLE value must come from the same source as
; the value for CARDINAL: "twenty ninth" isn't DIVISIBLE + but "twenty nine" is

norm_card_word := norm_num_word &
  [ SYNSEM [ LOCAL.CAT.HEAD [ MOD < [ MODIFD.LPERIPH bool ] >,
                              PRD -,
                              KEYS.KEY card_rel ],
             LKEYS.KEYREL.PRED card_rel ] ].

;; those cardinals that take no complements may be safely specified as 
;; +CARDINAL, and as plural (since they're normal)

card_only_word := norm_card_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.CARDINAL +,
                   CONT.HOOK.XARG.PNG png & [ PN 3pl ] ] ].

; should be POSTHD -
; These are adjectives only

; DPF 25-apr-04 - Added SPEC < anti_synsem_min > to prevent ordinals from
; undergoing the partitive_num rule, which is designed to handle not only
; cardinal numbers but also superlatives as in "the best arrived", and
; measure phrases ("ten feet of rope"), while excluding ordinary NPs.
; --FIX-- This won't scale up to complex ordinals like "twenty-second"
; which are different from "twenty-two" only in the CARDINAL feature, so
; CARDINAL would have to be introduced higher up than on the type intadj.
; DPF 26-aug-04 - Added variant of partitive rule for cardinals and ordinals,
; (which produces a sign that like common nouns requires a determiner),
; still using SPEC < anti_synsem_min > to distinguish the two.

ord_word := norm_num_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ CARDINAL -,
                                  KEYS.KEY ord_rel ],
                           VAL [ COMPS < >,
                                 SPEC < anti_synsem_min > ] ] ],
             LKEYS.KEYREL.PRED ord_rel ] ].

;;  Specifiers and modifiers will agree with heads on the value
;; of the head feature CARDINAL -- this allows propagation
;; of such a feature from complements, where (on the current account)
;; the CARDINAL feature gets a value from the lexicon.

;; distribution of CARDINAL:
;;   ordinal lex_entries are CARDINAL -
;;   complement_free lex_entries are CARDINAL +
;;   all lex_entries for "one" are CARDINAL +
;;   other lex_entries are unspecified for CARDINAL
;; Since (the HEAD feature of) the determiner "one" is outside this 
;; hierarchy, it can't appear as a specifier or complement.


;; The sorts below refer only to lexical entries, so there's presumably no
;; harm in making conventions about the order of the RELs on their RELSs
;; No particular order is assumed for any phrase containing these entries.

;; It will be hard to do optional complements here and get the RELSs to
;; come out right.  Another problem with optional complementation is that
;; entries with complements must be -ORD, while their complement-taking
;; counterparts must be underspecified for ORD 
;;   (cf. "twenty" vs. "twenty one" vs. "twenty first")


complement_free_number := norm_num_word &
			  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

complemented_number := norm_num_word &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD [ CARDINAL #card,
                           MOD < [ LOCAL.AGR.DIVISIBLE #div ] > ],
		    VAL.KCMP lex_synsem &
                                [ OPT -,
				  LOCAL [ CAT [ HEAD intadj & 
						[ CARDINAL #card,
                                                  MOD < [ LOCAL.AGR.DIVISIBLE 
                                                                   #div ] > ],
                                                VAL [ SPR *olist*,
						      COMPS < > ] ],
                                          CONT.HOOK.XARG #arg & [ PNG #num ] ],
                                  NONLOC.SLASH 0-dlist,
                                  PUNCT.LPUNCT no_punct ] ],
	      CONT [ HOOK.XARG.PNG #num,
		     RELS.LIST < relation, [ PRED plus_rel ], ... > ] ],
      LKEYS.KEYREL.ARG1 #arg ] ].
		   

; Non-identity stipulated for handle of SPR and handle of CONT in order to
; prevent the regular head-spec rule (non-head-compositional) from applying.
; Need head-compositional since the handle of the phrase "two hundred" must
; be the handle of the times_rel from the head "hundred" (which contains as
; arguments the other two handles).

specified_number := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < synsem &
			       [ OPT -,
				 LOCAL [ CAT [HEAD intadj & 
						   [ CARDINAL + ],
					      VAL [ COMPS < >,
						    SPR *olist* ] ] ] ] >].
				 
; DPF 01-Feb-03 - Removed the degree specifier, since we don't want to parse
; "*the exactly five chairs arrived".  We'll ignore "the nearly fifty people".
; DPF 10-dec-03 - Made SPR be < anti_synsem_min > so we can still use the 
; normal adjective-coordination rule.  
; DPF 21-sept-04 - But we also want "exactly five people arrived".  Seems to
; support the idea of ambiguous 'five': (1) an adjective which takes no 
; specifier and which always co-occurs with a determiner; and (2) a 
; determiner which can have a degree specifier.  Already have this ambiguity
; for 'one' (necessarily, to get "one chair arrived"), but degree sprs give
; reason to do it consistently for cardinals.  Note that only the cardinals
; would have the determiner entry; ordinals are only adjectives, and don't
; occur with degree specifiers.  So added num_det syntactic rule, and removed
; the idiosyncratic lexical type (and entries) for determiner "one".
; DPF 22-sept-04 - Removed SPEC < anti_synsem_min > which was preventing
; "(exactly) two of the chairs arrived"

unspecified_num := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < anti_synsem_min > ].

unspecified_num_without_complements := complement_free_number & 
                                       unspecified_num &
  [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY const_rel,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! const_relation & [ LBL #ltop ] !> ] ] ].

approx_unspecified_num_without_complements := complement_free_number & 
                                              unspecified_num &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY const_rel,
                           VAL.SPEC < anti_synsem_min > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! const_relation & [ LBL #ltop ],
                                [ PRED approx_grad_rel,
                                  ARG1 #arg0 ]  !> ] ],
             LKEYS.KEYREL.ARG0 #arg0 ] ].

unspecified_num_with_complements := complemented_number & unspecified_num &
  [ SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY const_rel,
                         VAL.KCMP [ LOCAL [ CAT.HEAD.KEYS.KEY integer_rel,
                                            CONT.HOOK.LTOP #chandle ] ] ],
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! const_relation &
                              [ LBL #khandle,
                                ARG1 #arg ],
                              [ LBL #ltop,
                                ARG1 #arg,
                                TERM1  #khandle,
                                TERM2  #chandle] !> ] ] ].

specified_num_without_complements := complement_free_number & 
                                     specified_number &
  [ SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY const_rel,
                         VAL.SPR < [ LOCAL.CONT.HOOK [ LTOP #shandle,
                                                       XARG #arg ] ] > ],
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! const_relation & [ LBL #khandle,
                                                   ARG1 #arg ],
                                [ LBL #ltop,
                                  PRED times_rel,
                                  FACTOR1  #shandle,
                                  FACTOR2  #khandle,
                                  ARG1 #arg & [ PNG.PN 3pl ] ] !> ] ] ].

specified_num_with_complements := complemented_number & specified_number & 
  [ SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY const_rel,
                         VAL [ SPR < [ LOCAL.CONT.HOOK [ LTOP #shandle,
                                                         XARG #arg ] ] >,
                               KCMP #kcmp,
                               COMPS < #kcmp &
                                       [ LOCAL.CONT.HOOK [ LTOP #chandle,
                                                           XARG #arg ] ] > ] ],
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! [ LBL #khandle,
                                  ARG1 #arg ],
                                [ LBL #ltop,
                                  TERM1  #thandle,
                                  TERM2  #chandle,
                                  ARG1 #arg ],
                                [ LBL #thandle,
                                  PRED times_rel,
                                  FACTOR1 #shandle,
                                  FACTOR2 #khandle,
                                  ARG1 #arg ] !> ] ] ].

adj_bare_unspecified_card_lexent := card_only_word & 
                                    unspecified_num_without_complements.
adj_bare_unspecified_card_wcomps_lexent := card_only_word & 
                                           unspecified_num_with_complements &
  [ SYNSEM.LOCAL.CAT.VAL [ KCMP #kcmp,
                           COMPS < #kcmp &
                                   [ LOCAL [ CAT.HEAD fractadj,
                                             CONJ num-conj ] ] > ] ].

adj_bare_unspecified_card_one_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].
adj_bare_unspecified_card_two_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].
adj_bare_unspecified_card_three_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj3 ].
adj_bare_unspecified_card_six_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj6 ].
adj_bare_unspecified_card_nine_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj9 ].
adj_bare_unspecified_card_twelve_le := adj_bare_unspecified_card_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj12 ].

adj_bare_unspecified_card_wcomps_one_le := 
                                  adj_bare_unspecified_card_wcomps_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].

adj_bare_specified_card_lexent := card_only_word & 
                                  specified_num_without_complements.
adj_bare_specified_card_hundred_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].
adj_bare_specified_card_dozen_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj2,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].
adj_bare_specified_card_thousand_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
adj_bare_specified_card_million_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
adj_bare_specified_card_billion_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
adj_bare_specified_card_trillion_le := adj_bare_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj15,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].

adj_complemented_unspecified_card_le := norm_card_word & 
                                        unspecified_num_with_complements &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj2,
                       VAL [ KCMP #kcmp,
                             COMPS < [ LOCAL.CAT.HEAD punct_hd,
                                       PUNCT [ LPUNCT hyphen_sgl,
                                               RPUNCT no_punct ] ],
                                     #kcmp & 
                                     [ LOCAL [ CAT.HEAD intadj1,
                                               CONJ cnil ] ] > ] ] ].

adj_complemented_specified_card_lexent := norm_card_word & 
                                          specified_num_with_complements.
adj_complemented_specified_card_hundred_le := 
                                  adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj2-,
                             COMPS.FIRST [ LOCAL.CAT.HEAD intadj2-,
                                           MODIFD.LPERIPH na ] ] ] ].
adj_complemented_specified_card_thousand_le := 
                                      adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj3- ] ] ].
adj_complemented_specified_card_million_le := 
                                     adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj6- ] ] ].
adj_complemented_specified_card_billion_le := 
                                      adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj9- ] ] ].

adj_complemented_specified_card_trillion_le := 
                                      adj_complemented_specified_card_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj15,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj12- ] ] ].

adj_bare_unspecified_ord_lexent := ord_word & 
                                   unspecified_num_without_complements.
adj_bare_unspecified_ord_one_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].
adj_bare_unspecified_ord_two_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].
adj_bare_unspecified_ord_three_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj3 ].
adj_bare_unspecified_ord_six_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj6 ].
adj_bare_unspecified_ord_nine_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj9 ].
adj_bare_unspecified_ord_twelve_le := adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD intadj12 ].

adj_bare_specified_ord_lexent := ord_word & specified_num_without_complements.
adj_bare_specified_ord_hundred_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
adj_bare_specified_ord_thousand_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
adj_bare_specified_ord_million_le := adj_bare_specified_ord_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj6- ] ].

adj_approx_bare_unspecified_card_le := card_only_word & 
			           approx_unspecified_num_without_complements &
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].

;; the constraints appropriate for all lexical entries for "one"
;; DPF 2-Feb-01 - Removed [ SPEC..OPT - ], since blocked "the one year old boy"
;; and it's not clear what it was for.
;; DPF 17-Nov-01 - Added LPERIPH na like with other numbers.  Don't know why
;; a_one_sing and a_one_plur were marked [LPERIPH -], but need LPERIPH + to 
;; block application of nominal modifier rules to measure_nps including 
;; "an inch"
; DPF 25-Jun-03 - Tried making this [DIVISIBLE -] to block "*one tobacco 
; arrived" but this is the same "one" used in "one dozen chairs arrived".
; Would want something fancier, where [DIVISIBLE +] implied plural number,
; to just exclude mass nouns.

one_num_synsem := anycard_norm_num_synsem & zero_arg &
  [ LOCAL [ CAT [ HEAD intadj & 
                       [ CARDINAL +,
                         KEYS.KEY card_rel ],
                  VAL.SPR < anti_synsem_min > ],
            CONT [ HOOK [ INDEX #arg0,
                          XARG #index ],
                   RELS.LIST.FIRST #key &
                             [ PRED card_rel,
                               ARG0 #arg0,
                               ARG1 #index,
                               CARG "1" ] ] ],
    LKEYS.KEYREL #key,
    MODIFD.LPERIPH na,
    PUNCT [ LPUNCT no_punct,
            RPUNCT no_punct ] ].

one_num_fract_synsem := one_num_synsem & 
  [ LOCAL [ CAT [ HEAD.PRD -,
                  VAL.COMPS < [ LOCAL [ CAT [ HEAD fractadj &
                                                   [ KEYS.KEY fraction_rel ],
                                              VAL.COMPS < > ],
                                        CONT.HOOK [ LTOP #fhand,
                                                    XARG #ind ] ],
                                OPT -,
                                PUNCT.LPUNCT no_punct ] > ],
            CONT [ HOOK.LTOP #hand,
                   RELS <! [ LBL #chand,
                             ARG1 #ind ],
                         [ LBL #hand,
                           PRED plus_rel,
                           ARG1 #ind,
                           TERM1 #chand,
                           TERM2 #fhand ] !> ] ] ].

one_word := non_affix_bearing &
  [ SYNSEM one_num_synsem ].

; DPF 29-May-02 - Made adj_one_lexent be HEAD intadj1 not intadj, to
; avoid "let's meet at five one" meaning "five oh one"
; DPF 13-May-03 - Managed to get by with just one entry for adj "one", even
; though we need "forty one chairs" to sustain plural number on the semantic
; index for "one", by making the 3sg constraint on the AGR of the modified
; noun, so when "one" is directly a modifier, it will only modify 3sg nouns.
; (This simplification also required modifying the part-num rule to unify the
; daughter's MOD..AGR value with the dtr's own AGR.
; DPF 31-May-02 - Added PRD stipulation to distinguish "one" from "a/an" for
; e.g. partitive-num and num-noun rules.

adj_one_nonprd_le := one_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD intadj1 &
                            [ PRD -,
                              MOD < [ LOCAL intersective_mod &
                                     [ CAT nbar_cat_min &
                                           [ HEAD.KEYS.KEY nonpro_rel ],
                                       CONT.HOOK [ LTOP #ltop,
                                                   INDEX #index ],
                                       CONJ cnil,
                                       AGR.PNG.PN 3sg ],
                                      MODIFD.LPERIPH bool ] > ],
                           VAL.COMPS < > ],
                     CONT [ HOOK [ LTOP #ltop,
                                   XARG #index ],
                            RELS <! relation !> ] ],
             LKEYS.KEYREL.LBL #ltop ] ].


adj_one_nonprd_fract_le := one_word &
  [ SYNSEM one_num_fract_synsem &
           [ LOCAL.CAT [ HEAD intadj1 & [ MOD < anti_synsem_min > ],
                         VAL.COMPS < lex_synsem >,
                         HC-LEX + ] ] ].

; 'a/an' of 'the string is an inch long'
; DPF 21-May-03 - Even though these are PRD + to keep them out of partitives
; and num-nouns, we still don't want them showing up as predicative complements
; and so we make them MOD anti_synsem_min, so they are incompatible with prd_cat.
; DPF 5-jul-04 - While these are MOD < anti_synsem_min >, we still want to 
; prevent them from combining with plural nouns in measure-NP constructions 
; which are indifferent to PRD value, namely as complements of PPs - e.g. to 
; block *Kim arrives in a weeks".  So add AGR constraint to MOD value, which 
; the measure-NP rule already enforces.
; DPF 28-aug-04 - Since no longer using PRD to distinguish types of NPs (see
; note by nomp_cat), constrain these combine with lexically marked 
; measure-nouns to keep an artificial lid on spurious ambiguity.  So
; allowing "an inch is enough" with MNP, but not "an engineer is enough".

adj_one_an_lexent := one_word &
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 &
                                [ MOD < anti_synsem_min &
                                        [ LOCAL [ CAT.HEAD.KEYS.KEY
                                                            abstr_meas_nom_rel,
                                                  AGR.PNG.PN 3sg ] ] >,
                                  KEYS.ALTKEY no_rel ] ].

adj_one_prd_le := adj_one_an_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.PRD +,
                         VAL.COMPS < > ],
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! [ LBL #ltop ] !> ] ] ].

; 'a/an' of 'a meter and a half of snow'
; DPF 10-dec-03 - The 'and a half' synsem cannot be represented as a COMP
; since it can't be discharged until after 'a/an' has combined with the noun
; using the measure-NP rule, unlike say 'twenty' of 'twenty two foot'.  So
; this synsem is treated as a SPEC value, and is propagated by the MNP rule
; onto the COMPS list of the phrase.
; [HC-LEX -] prevents "*an and a half hours" since MNP rule requires left dtr
; to be LEX +, so get "one and a half hours".

adj_one_fract_lexent := adj_one_an_lexent &
  [ SYNSEM one_num_fract_synsem &
           [ LOCAL.CAT [ VAL.COMPS < phr_synsem >,
                         HC-LEX - ] ] ].

adj_one_fract_a_le := adj_one_fract_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET con ] > ].

adj_one_fract_an_le := adj_one_fract_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET voc ] > ].

adj_one_fract_le := adj_one_fract_lexent.

; 'a half'
fraction_num_synsem := anycard_norm_num_synsem & abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD fractadj & 
                       [ CARDINAL +,
                         KEYS.KEY fraction_rel ],
                  VAL [ SPR < >,
                        COMPS < >,
                        SPEC < [ LOCAL.CONT.HOOK.LTOP #ltop ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
                          XARG #index ],
                   RELS <! #key &
                         [ PRED fraction_rel,
                           ARG1 #index ] !>,
                   HCONS <! !> ] ],
    LKEYS.KEYREL #key,
    MODIFD.LPERIPH na ].

fraction_word := non_affix_bearing &
  [ SYNSEM fraction_num_synsem ].

fraction_le := fraction_word.


; Temporary types to cope with unknown words - used in PET
basic_unknown_word := mcna & nonconj & nonmsg & hc-to-phr &
  [ INFLECTD +,
    SYNSEM.LKEYS.KEYREL.Wlink *cons* ].

unknown_word := basic_unknown_word & 
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

generic_v_np*_trans_lex_entry := unknown_word &
  [ SYNSEM np_trans_verb &
	   [ LOCAL [ CAT.VAL.COMPS < [ OPT + ] >,
		     CONT.RELS <! #key !> ],
             LKEYS.KEYREL #key & 
                          [ PRED generic_verb_rel ] ] ].

v_np*_trans_bse_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL bse_verb ].
v_np*_trans_pres3sg_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL third_sg_fin_verb ].
v_np*_trans_presn3sg_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL non_third_sg_fin_verb ].
v_np*_trans_past_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL past_or_subj_verb ].
v_np*_trans_psp_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL psp_verb ].
v_np*_trans_prp_nale := generic_v_np*_trans_lex_entry &
  [ SYNSEM.LOCAL prp_verb ].

generic_n_intr_lex_entry := unknown_word &
  [ SYNSEM basic_common_noun_synsem &
	   [ LOCAL [ CAT [ HEAD.KEYS.KEY norm_nom_rel,
                           VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                        quant_or_wh_rel ] > ],
                     CONT.RELS <! #key !> ],
             LKEYS.KEYREL #key & [ PRED generic_nom_rel ],
             MODIFD notmod ] ].

n_intr_sg_nale := generic_n_intr_lex_entry &
  [ SYNSEM noun_nocomp_synsem & [ LOCAL sing_noun ] ].

n_intr_mass_nale := generic_n_intr_lex_entry &
  [ SYNSEM mass_noun_synsem & [ LOCAL mass_noun ] ].

n_intr_pl_nale := generic_n_intr_lex_entry &
  [ SYNSEM mass_or_count_nocomp_synsem & 
           [ LOCAL plur_noun ] ].

; MS 2004-04-06 - changed CARG "noname" to CARG *top* for NE recognition in HoG
n_proper_nale := basic_unknown_word & nonslash & nonrel & nonque &
  [ SYNSEM proper_n_synsem &
           [ LOCAL.CAT.HEAD.KEYS.KEY named_abb_rel,
             LKEYS.KEYREL [ PRED named_abb_rel,
                            CARG *top* ] ] ].

n_title_nale := unknown_word &
  [ SYNSEM title_synsem &
	   [ LOCAL.CAT.POSTHD - ] ].

adj_intrans_nale := unknown_word &
  [ SYNSEM intrans_adj_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind ] >,
                                  PRD #bool ],
                           POSTHD #bool ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! #key !> ] ],
             LKEYS.KEYREL #key & 
                          [ PRED generic_adj_rel,
                            ARG1 #ind ] ] ].

adj_intrans_compar_nale := unknown_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind ] >,
                                  KEYS.ALTKEY comp_rel ],
                           VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                        much_deg_rel ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
                                      ARG1 #ind ],
                                  #altkey &
                                  [ LBL #hand,
                                    ARG1 #ind ] !> ] ],
             LKEYS.ALTKEYREL #altkey & [ PRED comp_rel ] ] ].

adj_intrans_superl_nale := unknown_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind ] >,
                                  KEYS.ALTKEY superl_rel ],
                           VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                         much_deg_rel ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
                                      ARG1 #ind ],
                                  #altkey &
                                  [ LBL #hand,
                                    ARG1 #ind ] !> ] ],
             LKEYS.ALTKEYREL #altkey & [ PRED superl_rel ] ] ].

adv_word_nale := unknown_word & nonque & nonslash & nonrel &
  [ SYNSEM intersect_adverb_synsem & 
            [ LOCAL [ CAT.HEAD adv_nonmob &
                               [ MOD < [ LOCAL.CAT.HEAD v_or_g_or_a ] > ] ],
              LKEYS.KEYREL.PRED generic_adv_rel ] ].

punct_word := non_affix_bearing &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD punct_hd & 
                   [ PRD -,
                     MOD < >,
                     KEYS.KEY punct_rel ],
              VAL [ SUBJ < >,
                    SPR < >,
                    SPEC < >,
                    COMPS < expressed_synsem &
                            [ OPT -,
                              LOCAL.CAT.HEAD subst_or_func ] > ] ],
        CONT [ RELS <! !>,
               HCONS <! !> ],
        CONJ cnil ],
      LKEYS.KEYREL.PRED punct_rel,
      NONLOC [ SLASH 0-dlist,
               REL 0-dlist ] ] ].

basic_punct_right_word := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < abstr_lex_synsem &
                                   [ PUNCT.RPUNCT no_punct ] >,
             PUNCT [ LPUNCT no_punct,
                     RPUNCT punct_mark ] ] ].

punct_right_word := basic_punct_right_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ NONLOC.QUE #que ] >,
             NONLOC.QUE #que ] ].

punct_period_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT basic_clause_punct &
                        [ MSGPRED prop_imp_m_rel ] ].
    
; For robust analysis of data where questions can end in period
punct_robust_period_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT basic_clause_punct &
                        [ MSGPRED message_m_rel ] ].
    
punct_qmark_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT basic_clause_punct &
                        [ MSGPRED abstr_int_m_rel ] ].

punct_bang_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT basic_clause_punct &
                        [ MSGPRED prop_imp_m_rel ] ].

; Sentence-ending dash, for informal writing
punct_s_dash_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT s_dash_punct ].

; Sentence-ending colon, for informal writing
punct_s_colon_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT s_colon_punct ].

; Sentence-ending threedots
punct_3dots_right_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT 3dots_punct ].
    
punct_3dots_left_le := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT 3dots_or_clause,
                                     LOCAL.CONJ cnil ] >,
             PUNCT [ LPUNCT 3dots_punct,
                     RPUNCT 3dots_or_clause_or_no_punct ] ] ].

semicolon_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT semicol_punct ].

colon_punct_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT colon_punct ].

punct_comma_right_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT comma_punct ].

; For transcribed speech data where comma indicates pause
punct_robust_comma_le := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < abstr_lex_synsem &
                                   [ PUNCT.RPUNCT no_punct,
                                     NONLOC.QUE #que ] >,
             NONLOC.QUE #que,
             PUNCT [ LPUNCT no_punct,
                     RPUNCT comma_or_clause_or_no_punct ] ] ].

; A left comma must combine with a phrase that ends in either a comma or
; a clausal punct mark, and it produces a phrase which is compatible with
; requirements for either a comma-final phrase or a no-punct-final phrase.
; This lets a right comma 'swallow' a right comma, as in 
; "Abrams, the manager, who just arrived, disappeared"
; where the non-restrictive relative rule requires a right comma for
; "who just arrived", but so does the appositive rule for 
; "the manager, who just arrived,"
; Added COMPS..CONJ cnil_or_phrconj to avoid spurious ambiguity for 
; 'She hired Abrams, Browne, and Chiang.' where the final period would
; otherwise license the comma after 'Browne' as a left comma.
; DPF 25-aug-04 - Added reentrancy for RPUNCT of COMPS and SYNSEM, since
; don't want "Kim hired Browe, a consultant," with S-final comma.

punct_comma_left_le := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT comma_or_clause & #rpunct,
                                     LOCAL.CONJ cnil ] >,
             PUNCT [ LPUNCT comma_punct,
                     RPUNCT comma_or_clause_or_no_punct & #rpunct ] ] ].

; for mid-coord commas, as in "Abrams, Browne, and Chiang"
punct_comma_coord_le := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONJ complex-conj,
                                     PUNCT [ LPUNCT no_punct,
                                             RPUNCT #rpunct ] ] >,
             PUNCT [ LPUNCT comma_punct,
                     RPUNCT #rpunct ] ] ].

punct_hyphen_right_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT hyphen_sgl ].
                                 
punct_hyphen_left_le := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT hyphen_sgl_or_clause,
                                     LOCAL.CONJ cnil ] >,
             PUNCT [ LPUNCT hyphen_sgl,
                     RPUNCT hyphen_sgl_or_clause_or_no_punct ] ] ].

punct_dbl_hyphen_right_le := punct_right_word &
  [ SYNSEM.PUNCT.RPUNCT hyphen_dbl ].
                                 
punct_dbl_hyphen_left_le := punct_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT hyphen_dbl_or_clause,
                                     LOCAL.CONJ cnil ] >,
             PUNCT [ LPUNCT hyphen_dbl,
                     RPUNCT hyphen_dbl_or_clause_or_no_punct ] ] ].

punct_pair_word := non_affix_bearing &
  [ SYNSEM [ LOCAL [ CAT [ HEAD punct_pair_hd &
                                [ PRD -,
                                  MOD < >,
                                  KEYS.KEY no_rel ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ] ],
                     CONT [ RELS <! !>,
                            HCONS <! !> ],
                     CONJ cnil ],
             LKEYS.KEYREL.PRED no_rel,
	     NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             PUNCT [ LPUNCT pair_punct,
                     RPUNCT no_punct ] ] ].


punct_sq_le := punct_pair_word &
  [ SYNSEM.LOCAL.CAT.HEAD sq_punct_hd ].

punct_leftq_le := punct_pair_word &
  [ SYNSEM.LOCAL.CAT.HEAD lq_punct_hd ].

punct_dq_le := punct_pair_word &
  [ SYNSEM.LOCAL.CAT.HEAD dq_punct_hd ].

punct_lp_le := punct_pair_word &
  [ SYNSEM.LOCAL.CAT.HEAD lp_punct_hd ].

punct_rp_le := punct_pair_word &
  [ SYNSEM.LOCAL.CAT.HEAD rp_punct_hd ].
