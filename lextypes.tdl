;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  lextypes.tdl
;;;
;;;  Lexical types (i.e., word classes)
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;  Last revised: Dan Flickinger, 24-Feb-97
;;;
;;;  $Id$

;:message "Lexical types".

:begin :type.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; DPF (14-Oct-98) --FINAL-ARG points to the final element in a word with 
;; spaces, since that element bears any inflection.

basic_affix_bearing := word &
  [ SYNSEM.LOCAL [ STEMHEAD #stemhead,
                   AGR #agr,
                   CAT #cat,
		   CONT [ TOP #hand,
			  INDEX #index,
			  KEY #key ],
		   CTXT #ctxt ],
    --FINAL-ARG [ AFFIX local & [ STEMHEAD #stemhead,
				  AGR #agr,
				  CAT #cat,
				  CONT [ TOP #hand,
					 INDEX #index,
					 KEY #key ],
				  CTXT #ctxt ] ] ].

affix_bearing := basic_affix_bearing &
  [ --FINAL-ARG #arg,
    ARGS < #arg > ].

affix_bearing_two := basic_affix_bearing &
  [ --FINAL-ARG #arg,
    ARGS < *top*, #arg > ].

non_affix_bearing := word_or_lexrule &
  [ ARGS < [ AFFIX no-affix ] , ... > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LEXICAL DEFAULTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nonslash := word &
  [ SYNSEM.NON-LOCAL.SLASH 0-dlist ].

; Lexical types that may have subtypes or instances with nonempty QUE values.
; Quantifiers introduce a nonempty value for their H-STORE attribute, but
; all nonque words assign the empty list for H-STORE.

nonque := word &
  [ SYNSEM.NON-LOCAL.QUE 0-dlist ].  

nonrel := word &
  [ SYNSEM.NON-LOCAL.REL 0-dlist ].  

nonconj := word &
  [ SYNSEM.LOCAL.CONJ cnil ].

mcna := word &
  [ SYNSEM.LOCAL.CAT.MC na ].

nonmsg := word &
  [ SYNSEM.LOCAL.CONT.MESSAGE <! !> ].

; Exceptions to this default include neg-contracted auxiliaries.
topkey := word &
  [ SYNSEM.LOCAL.CONT [ KEY #key,
			--TOPKEY #key ] ].

; Most words combine with their complements (if any) to produce a phrase,
; but a few, like "twenty" as in "twenty-two" and "five" as in "five o'clock",
; produce a sign which is still a word -- one with [ SYNSEM lex_synsem ].

hc-to-phr := word &
  [ SYNSEM.LOCAL.CAT.HC-LEX - ].

; nontopkey_word's have all the defaults except topkey and non_affix_bearing.
nontopkey := nonque & nonconj & nonslash & nonrel & nonmsg &
	     mcna.

; norm_word's have all the defaults except non_affix_bearing
norm_word := nonque & nonconj & nonslash & nonrel & nonmsg &
	     mcna & topkey & hc-to-phr.
	     
norm_no_affix_word := norm_word & non_affix_bearing.

; ERB (13-11-96) Default type for potential modifiers:
; Two types because they're not all non_affix_bearing.
; The reason for this is tags...  see notes there.

norm_mod_word := nonque & nonconj & nonslash & nonrel &
		 mcna & topkey &
   [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.MESSAGE #msg ] >,
		    CONT.MESSAGE #msg ] ].

norm_mod_no_affix_word := norm_mod_word & non_affix_bearing.

; ERB (04-10-96) I have added nonmsg to the following types, as
; appropriate.

; que_word's have all the defaults EXCEPT nonque and topkey.
que_word := nonconj & non_affix_bearing &
	    mcna &
	    nonslash &
	    nonrel &
	    nonmsg &
	    hc-to-phr.

; rel_word's have all the defaults EXCEPT nonrel.
rel_word := nonque & non_affix_bearing &
	    mcna &
            nonslash &
	    nonconj &
	    nonmsg &
	    topkey &
	    hc-to-phr.

; conj_word's have all the defaults EXCEPT nonconj, nonmsg, nonque, nonslash,
; and nonrel.
conj_word := word & non_affix_bearing.

; ERB (04-10-96) msg_word's have all the defaults EXCEPT nonmsg, nonslash,
; mcna, and topkey.
msg_word := nonque & non_affix_bearing &
	    nonrel &
	    nonconj &
	    hc-to-phr.

norm_msg_word := msg_word & nonslash & mcna & topkey.

; hcons_amalg_word's have all the defaults EXCEPT non_affix_bearing,
; nonslash, nonrel, and nonque.
hcons_amalg_word := mcna &
	    nonconj &
	    nonmsg &
	    topkey &
	    hc-to-phr.

amalg_word := mcna & 
	    nonconj &
	    nonmsg &
            non_affix_bearing &
	    topkey &
	    hc-to-phr.

msg_amalg_word := mcna & 
	    nonconj &
            non_affix_bearing &
	    topkey &
	    hc-to-phr.

; hc_word's repeat all the defaults EXCEPT hc-to-phr, which means they can decide
; to build head_complement structures which are still words (with 
; [ SYNSEM lex_synsem ].  Also, they are not inherently themselves 
; [ SYSNEM lex_synsem ], so we don't use inheritance at the moment, but replicate
; the inheritable properties, for an experiment.

hc_word := word_or_lexrule &
  [ SYNSEM [ LOCAL [ CAT.MC na,
		     CONT [ MESSAGE <! !>,
			    KEY #key,
			    --TOPKEY #key ],
		     CONJ cnil ],
	     NON-LOCAL [ QUE 0-dlist,
			 REL 0-dlist,
			 SLASH 0-dlist ] ],
    ROOT - ].

hc_word_no_affix := hc_word &
  [ ARGS < [ AFFIX no-affix ] , ... > ].

;;;;;
;; Non-local amalgmation types
;;

#|
zero_arg := lex_synsem &
  [ LOCAL [ ARG-S < >,
	    CONT [ TOP #hand,
		   --TOPKEY.HANDEL #hand,
		   H-STORE <! !>,
		   H-CONS <! !> ] ],  
    NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].
|#

zero_arg := lex_synsem &
  [ LOCAL [ ARG-S < >,
	    CONT [ TOP #ltop,
		   --TOPKEY.HANDEL #keyhand,
		   H-STORE <! !>,
		   H-CONS <! is-one-of &
			     [ SC-ARG #ltop,
			       CANDS <! #keyhand !> ],
                             leq &
			     [ SC-ARG #ltop,
			       OUTSCPD #keyhand ] !> ] ],
    NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

basic_nonzero_arg_synsem := lex_synsem &
  [ LOCAL [ CONT [ TOP #ltop,
		   --TOPKEY.HANDEL #keyhand,
		   H-STORE [ LIST #hslist,
			     LAST #hslast ],
		   H-CONS [ LIST < is-one-of &
                                   [ SC-ARG #ltop,
                                     CANDS *diff-list* &
                                            [ LIST < #keyhand . #hslist >,
                                              LAST #hslast ] ],
                                   leq &
                                   [ SC-ARG #ltop,
                                     OUTSCPD #keyhand ], ... > ] ] ] ].

nonzero_arg_synsem := basic_nonzero_arg_synsem &
  [ LOCAL.CONT.H-CONS <! is-one-of, leq !> ].

basic_one_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NON-LOCAL [ SLASH #slash,
				  REL #rel,
				  QUE #que ],
		      LOCAL.CONT [ INDEX individual,
				   H-STORE #hstore ] ] >,
	    CONT.H-STORE #hstore ],
    NON-LOCAL [ SLASH #slash,
		REL #rel,
		QUE #que ] ].

one_arg := basic_one_arg & nonzero_arg_synsem.

basic_two_arg := lex_synsem &
  [ LOCAL.ARG-S < [ NON-LOCAL [ SLASH [ LIST #smiddle,
					LAST #slast ],
				REL [ LIST #rmiddle,
				      LAST #rlast ],
				QUE [ LIST #qmiddle,
				      LAST #qlast ] ],
		    LOCAL.CONT.INDEX individual ],
		  [ NON-LOCAL [ SLASH [ LIST #sfirst,
					LAST #smiddle ],
				REL [ LIST #rfirst,
				      LAST #rmiddle ],
				QUE [ LIST #qfirst,
				      LAST #qmiddle ] ],
		    LOCAL.CONT.INDEX individual ] >,
    NON-LOCAL [ SLASH [ LIST #sfirst,
			LAST #slast ],
		REL [ LIST #rfirst,
		      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

basic_two_arg_nonzero := basic_two_arg & basic_nonzero_arg_synsem &
  [ LOCAL [ ARG-S < [ LOCAL.CONT.H-STORE [ LIST #hsmiddle,
					   LAST #hslast ] ],
		    [ LOCAL.CONT.H-STORE [ LIST #hsfirst,
					   LAST #hsmiddle ] ] >,
	    CONT.H-STORE [ LIST #hsfirst,
			   LAST #hslast ] ] ].

two_arg := basic_two_arg_nonzero &
  [ LOCAL.CONT.H-CONS <! is-one-of, leq !> ].

basic_two_arg_raising := basic_two_arg & basic_nonzero_arg_synsem &
  [ LOCAL [ ARG-S < synsem, [ LOCAL.CONT.H-STORE #hstore ] >,
	    CONT.H-STORE #hstore ] ].

two_arg_raising := basic_two_arg_raising &
  [ LOCAL.CONT.H-CONS <! is-one-of, leq !> ].

basic_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NON-LOCAL [ SLASH [ LIST #smiddle2,
					  LAST #slast ],
				  REL [ LIST #rmiddle2,
					LAST #rlast ],
				  QUE [ LIST #qmiddle2,
					LAST #qlast ] ],
		      LOCAL.CONT.INDEX individual ],
                    [ NON-LOCAL [ SLASH [ LIST #sfirst,
					  LAST #smiddle1 ],
				  REL [ LIST #rfirst,
					LAST #rmiddle1 ],
				  QUE [ LIST #qfirst,
					LAST #qmiddle1 ] ],
		      LOCAL.CONT.INDEX individual ],
                    [ NON-LOCAL [ SLASH [ LIST #smiddle1,
					  LAST #smiddle2 ],
				  REL [ LIST #rmiddle1,
					LAST #rmiddle2 ],
				  QUE [ LIST #qmiddle1,
					LAST #qmiddle2 ] ],
		      LOCAL.CONT.INDEX individual ] > ],
    NON-LOCAL [ SLASH [ LIST #sfirst,
			LAST #slast ],
		REL [ LIST #rfirst,
		      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

basic_three_arg_nonzero := basic_three_arg & basic_nonzero_arg_synsem &
  [ LOCAL [ ARG-S < [ LOCAL.CONT.H-STORE [ LIST #hsmiddle2,
                                           LAST #hslast ] ],
		    [ LOCAL.CONT.H-STORE [ LIST #hsfirst,
                                           LAST #hsmiddle1 ] ],
                    [ LOCAL.CONT.H-STORE [ LIST #hsmiddle1,
                                           LAST #hsmiddle2 ] ] >,
	    CONT.H-STORE [ LIST #hsfirst,
			   LAST #hslast ] ] ].

three_arg := basic_three_arg_nonzero &
  [ LOCAL.CONT.H-CONS <! is-one-of, leq !> ].

three_arg_raising := basic_three_arg & nonzero_arg_synsem &
  [ LOCAL [ ARG-S < synsem, 
                    [ LOCAL.CONT.H-STORE [ LIST #hsfirst,
                                           LAST #hsmiddle ] ],
                    [ LOCAL.CONT.H-STORE [ LIST #hsmiddle,
                                           LAST #hslast ] ] >,
            CONT.H-STORE [ LIST #hsfirst,
                           LAST #hslast ] ] ].

three_arg_obj_raising := basic_three_arg & nonzero_arg_synsem &
  [ LOCAL [ ARG-S < [ LOCAL.CONT.H-STORE [ LIST #hsfirst,
                                           LAST #hsmiddle ] ],
                    synsem, 
                    [ LOCAL.CONT.H-STORE [ LIST #hsmiddle,
                                           LAST #hslast ] ] >,
            CONT.H-STORE [ LIST #hsfirst,
                           LAST #hslast ] ] ].

basic_four_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NON-LOCAL [ SLASH [ LIST #smiddle3,
					  LAST #slast ],
				  REL [ LIST #rmiddle3,
					LAST #rlast ],
				  QUE [ LIST #qmiddle3,
					LAST #qlast ] ],
		      LOCAL.CONT [ INDEX individual,
				   H-STORE [ LIST #hsmiddle3,
					     LAST #hslast ] ] ],
		    [ NON-LOCAL [ SLASH [ LIST #sfirst,
					  LAST #smiddle1 ],
				  REL [ LIST #rfirst,
					LAST #rmiddle1 ],
				  QUE [ LIST #qfirst,
					LAST #qmiddle1 ] ],
		      LOCAL.CONT [ INDEX individual,
				   H-STORE [ LIST #hsfirst,
					     LAST #hsmiddle1 ] ] ],
		    [ NON-LOCAL [ SLASH [ LIST #smiddle1,
					  LAST #smiddle2 ],
				  REL [ LIST #rmiddle1,
					LAST #rmiddle2 ],
				  QUE [ LIST #qmiddle1,
					LAST #qmiddle2 ] ],
		      LOCAL.CONT [ INDEX individual,
				   H-STORE [ LIST #hsmiddle1,
					     LAST #hsmiddle2 ] ] ],
		    [ NON-LOCAL [ SLASH [ LIST #smiddle2,
					  LAST #smiddle3 ],
				  REL [ LIST #rmiddle2,
					LAST #rmiddle3 ],
				  QUE [ LIST #qmiddle2,
					LAST #qmiddle3 ] ],
		      LOCAL.CONT [ INDEX individual,
				   H-STORE [ LIST #hsmiddle2,
					     LAST #hsmiddle3 ] ] ] >,
	    CONT.H-STORE [ LIST #hsfirst,
			   LAST #hslast ] ],
    NON-LOCAL [ SLASH [ LIST #sfirst,
			LAST #slast ],
		REL [ LIST #rfirst,
		      LAST #rlast ],
		QUE [ LIST #qfirst,
		      LAST #qlast ] ] ].

four_arg := basic_four_arg & nonzero_arg_synsem.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBCATEGORIZATIONS -- synsems for verbs, adjectives, prepositions, nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nomod_local := local &
  [ CAT.HEAD.MOD < > ].

nomod_synsem := lex_synsem &
  [ LOCAL.CAT [ HEAD.MOD < >,
		VAL.SUBJ < > ] ].

scopal_mod :< local_min.
intersective_mod :< local_min.
scopal_mod_local := scopal_mod & local.
int_mod_local := intersective_mod & local. 

np_cat := cat &
  [ HEAD nominal & strict_type &
	 [ POSS - ],
    VAL [ SPR *olist*,
	  COMPS *olist* ] ].

s_cat := cat &
  [ HEAD verb,
    VAL [ SUBJ < >,
	  COMPS *olist* ],
    MC + ].

n_or_v_cat := cat &
  [ HEAD n_or_v & strict_type,
    VAL [ SPR < synsem_min >,
	  COMPS *olist* ] ].

vp_cat := n_or_v_cat &
  [ HEAD verb,
    VAL [ SUBJ < synsem_min >,
	  COMPS *olist* ],
    MC na ].

nbar_cat := n_or_v_cat &
  [ HEAD noun &
	 [ POSS -,
	   MOD < > ],
    VAL [ SUBJ < >,
	  SPR < [ OPT - ] > ],
    MC na ].

adverbee_cat := cat &
  [ HEAD adverbee & strict_type ].



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Linking Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Linking types specify the relationship between valence positions and 
;; semantic roles.

linking_type :< lex_synsem.

atrans_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local &
				       [ CONT [ INDEX it-ind,
						KEY.LABEL #label ] ] ] >,
	    CONT.KEY no_role_rel & [ LABEL #label ] ] ].

arg1_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local &
				   [ CONT.INDEX #subjind & non_expl-ind,
				     THROLE arg1 ] ] >,
	    CONT.KEY arg1_rel & [ ARG1 #subjind ] ] ].

unacc_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local & [ CONT.INDEX #subjind,
					     THROLE arg1 ] ] >,
	    CONT.KEY arg3_event_rel & [ ARG3 #subjind ] ] ].

arg13_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
					[ CONT.INDEX #objind & non_expl-ind,
                                          THROLE arg3 ] ], ... >,
	    CONT.KEY arg13_rel & [ ARG3 #objind ] ] ].

trans_lt :< arg13_lt.

arg14_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
				     [ CONT [ KEY verb_aspect_rel,
					      MESSAGE <! [ HANDEL #mhand ] !> ],
				       THROLE arg3 ] ], ... >,
	    CONT.KEY arg14_rel & [ ARG4 #mhand ] ] ].

; "suppose" which makes its KEY same as its complement's KEY
; - wouldn't need this if had defaults

alt_arg14_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local &
				     [ CONT.INDEX #subjind & non_expl-ind,
				       THROLE arg1 ] ] >,
		      COMPS < [ LOCAL local &
				      [ CONT [ KEY verb_aspect_rel,
					       MESSAGE <! [ HANDEL #mhand ] !> ],
					THROLE arg3 ] ], ... > ],
	    CONT.ALTKEY arg14_rel & [ ARG1 #subjind,
				      ARG4 #mhand ] ] ].

; Maybe only for main verb "have" (AAC internal comment moved)
poss_lt := linking_type &         
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local &
				     [ CONT.INDEX #subjind & non_expl-ind,
                                       THROLE arg1 ] ] >,
		      COMPS < [ LOCAL local &
				      [ CONT.INDEX #objind & non_expl-ind,
					THROLE arg3 ] ], ... > ],
	    CONT.LISZT <! arg13_rel & 
			[ ARG1 #subjind,
			  ARG3 #objind ] !> ] ].

expl_obj_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
					[ CONT [ INDEX it-ind,
						 KEY.LABEL #label ] ] ], ... >,
	    CONT.KEY.LABEL #label ] ].

expl_obj_cp_lt := expl_obj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    [ LOCAL local &
				      [ CONT.MESSAGE <! [ HANDEL #mhand ] !> ] ],
			    ... >,
	    CONT.KEY arg14_rel & [ ARG4 #mhand ] ] ].

particle_cp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL local &
				      [ CONT [ KEY verb_aspect_rel,
					       MESSAGE <! [ HANDEL #mhand ] !> ],
					THROLE arg3 ] ], ... >,
	    CONT.KEY arg14_rel & [ ARG4 #mhand ] ] ].  

ditrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
					 [ CONT.INDEX #obj2ind & non_expl-ind,
					   THROLE arg2 ] ], 
			    [ LOCAL local &
					 [ CONT.INDEX #objind & non_expl-ind,
					   THROLE arg3 ] ], ... >,
	    CONT.KEY arg123_rel & [ ARG2 #obj2ind,
				    ARG3 #objind ] ] ].

tritrans_lt := ditrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, *top*, 
			    [ LOCAL local &
				 [ CONT [ KEY event_rel,
					  MESSAGE <! [ HANDEL #mhand ] !> ] ] ],
				... >,
	    CONT.KEY arg1234_rel & [ ARG4 #mhand ] ] ].

prep_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			< [ LOCAL local &
				  [ CONT.KEY prep_rel & independent_rel &
					     [ ARG #index ] ] ],
			  ... >,
	    CONT [ INDEX #index,
		   KEY #key,
		   LISZT <! #key !> ] ] ].

empty_prep_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
					[ CONT [ TOP #top,
						 KEY prep_rel & selected_rel &
						     [ ARG3 #objind ] ],
					  THROLE arg2 ] ], ... >,
	    CONT [ TOP #top,
		   KEY arg13_rel & [ ARG3 #objind ] ] ] ].

; Argument coercion as in "Kim suggests on Friday"
prep_intrans_event_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			 < [ LOCAL local &
				   [ CONT.KEY prep_rel & independent_rel &
					      [ ARG #event ],
				     THROLE arg2 ] ], ... >,
	    CONT [ KEY #key & arg12_rel & [ ARG2 #event ],
		   LISZT <! #key !> ] ] ].

prep_trans_lt := arg13_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
			    [ LOCAL local &
				    [ CAT.HEAD.MOD < synsem_min >,
				      CONT.KEY prep_rel & independent_rel &
						   [ ARG #event ] ] ],
			    ... >,
	    CONT [ KEY #key,
		   INDEX #event,
		   LISZT <! #key !> ] ] ].

empty_prep_trans_lt := arg13_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL local &
				     [ CONT [ TOP #top,
					      KEY prep_rel & selected_rel &
						  [ ARG3 #objind ] ],
				       THROLE arg2 ] ], ... >, 
	    CONT [ TOP #top,
		   KEY arg123_rel & [ ARG2 #objind ] ] ] ].

empty_prep_particle_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL local &
					 [ CONT.KEY prep_rel & selected_rel &
                                                 [ ARG #event ] ] ], ... >,
	    CONT.KEY arg1_rel & [ EVENT #event ] ] ].

empty_prep_particle_trans_lt := arg13_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, synsem, [ LOCAL local &
					      [ CONT [ TOP #top,
						       KEY prep_rel & 
							   selected_rel &
							   [ ARG3 #objind ] ],
						THROLE arg2 ] ], ... >, 
	    CONT [ TOP #top,
		   KEY arg123_rel & [ ARG2 #objind ] ] ] ].

cp_trans_lt := arg13_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
			    [ LOCAL local &
				 [ CONT [ KEY event_rel,
					  MESSAGE <! [ HANDEL #mhand ] !> ] ] ], 
			    ...>,
	    CONT.KEY arg134_rel & [ ARG4 #mhand ] ] ].

; "explain to Kim that ..."
pp_cp_lt := empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*,
			    [ LOCAL local &
				  [ CONT [ KEY event_rel,
					   MESSAGE <! [ HANDEL #mhand ] !> ] ] ],
			    ... >,
	    CONT [ KEY arg134_rel & [ ARG4 #mhand ] ] ] ].

double_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
					[ CONT.KEY prep_rel & independent_rel &
						   [ ARG #event ] ] ], 
				[ LOCAL local &
					[ CONT.KEY prep_rel & independent_rel &
						   [ ARG #event ] ] ], ... >,
	    CONT.INDEX #event ] ].

; ERB (13-12-97) declaring non_expl-ind here is a total hack.  This
; should follow from the type constraints on the role arguments of each
; equi verb.  (I didn't do it -- I just noticed it!)

s_equi_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local &
				   [ CONT.INDEX #index & non_expl-ind,
                                     THROLE arg1 ] ] >,
	    CONT.KEY arg14_rel & [ arg1 #index ] ] ].

equi_prd_lt := linking_type & 
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT [ TOP #tophand,
                                           KEY independent_rel &
					       [ HANDEL #hand,
						 LABEL #label ] ],
            CONT [ TOP #tophand,
                   LISZT <! relation & [ HANDEL #hand ],
			    support_gen_rel & #altkey & 
			    [ HANDEL #hand,
			      LABEL #label,
			      EVENT #event & event ] !>,
		   KEY.ARG4 #event,
		   ALTKEY #altkey ] ] ].

; ERB (14-12-97) Subj_equi verbs now require that their complement have
; a pro_ss subject.  This might be redundant if some other supertye of
; all equi verbs requires hypo_rel on the complement.

; ERB (21-01-98) This pro_ss needs to be constrained to be unslashed.
; I was looking to do it with the macro @cp, but there are several
; problems with that (see notes in templates.tdl near cp).

subj_equi_lt := s_equi_lt &
  [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.INDEX #index ] >,
		    COMPS < [ LOCAL local &
				    [ CAT.VAL.SUBJ < pro_ss &
						     [ LOCAL.CONT.INDEX #index,
						       NON-LOCAL.SLASH 0-dlist]>,
				      THROLE arg3] ] > ] ].

; 'try to leave'
subj_equi_inf_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL local &
				    [ CONT.MESSAGE <! [ HANDEL #hand ] !> ],
	    CONT.KEY.ARG4 #hand ] ].

; 'stay calm'
subj_equi_prd_lt := equi_prd_lt & s_equi_lt &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.INDEX #index  & ref-ind ] >,
		      --KEYCOMP #comp,
		      COMPS < #comp & 
			      [ LOCAL local &
				[ CAT.VAL.SUBJ < pro_ss &
						 [ LOCAL local &
						       [ CONT.INDEX #index ]]>,
				  THROLE arg3] ] > ] ] ].

; ERB (14-12-97) comp's subj is a pro_ss.  This is probably redundant since
; the to_c_prop will say that its subject is a pro_ss.

; ERB (21-01-98) The pro_ss needs to be constrained to be unslashed.

; 'persuade Kim to leave'
obj_equi_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
				    [ CONT.INDEX #index & non_expl-ind,
				      THROLE arg2 ] ],
			    [ LOCAL local &
				[ CAT.VAL.SUBJ < pro_ss &
						 [ LOCAL.CONT.INDEX #index,
						   NON-LOCAL.SLASH 0-dlist ] >,
				  THROLE arg3 ] ] >,
	    CONT.KEY arg134_rel & [ ARG3 #index ] ] ].

; 'persuade Kim to leave'
obj_equi_inf_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL local &
				    [ CONT.MESSAGE <! [ HANDEL #hand ] !> ],
	    CONT.KEY.ARG4 #hand ] ].

pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL local &
				     [ CONT.KEY.ARG3 #arg2,
				       THROLE arg2 ] ],
			     [ LOCAL local &
				     [ CONT.TOP #hand,
				       THROLE arg3 ] ] > ],
	   CONT.KEY arg124_rel & [ ARG2 #arg2,
				   ARG4 #hand ] ] ].

; 'consider Kim wise'

obj_equi_prd_lt := equi_prd_lt & obj_equi_lt &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp,
		      COMPS < [ LOCAL local &
				      [ CONT [ INDEX #index,
					       KEY basic_nom_rel ],
					THROLE arg2 ] ],
			      #comp &
			      [ LOCAL local &
				      [ CAT.VAL.SUBJ
						  < pro_ss &
						    [ LOCAL local &
						      [ CONT.INDEX #index ] ] >,
					THROLE arg3 ] ] > ] ] ].

; 'promise Kim to leave'
anom_equi_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ LOCAL.CONT.INDEX #subjind ] >,
		  COMPS < [ LOCAL local &
				  [ CONT.INDEX #objind & non_expl-ind,
				    THROLE arg2 ] ],
			  [ LOCAL local &
				  [ CAT.VAL.SUBJ < pro_ss &
						   [ LOCAL local &
						     [ CONT.INDEX #subjind ] ] >,
				    CONT.MESSAGE <! [ HANDEL #hand ] !>,
				    THROLE arg3 ] ] > ],
	    CONT.KEY arg134_rel &
		     [ ARG4 #hand,
		       ARG3 #objind ] ] ].

; 'turn out unreliable' (also resultatives like 'turned up drunk')
anom_equi_prd_lt := equi_prd_lt & s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ LOCAL.CONT [ INDEX #index,
				        KEY.HANDEL #chand ] ] >,
		  --KEYCOMP #comp,
		  COMPS < *top*,
			  #comp &
			  [ LOCAL local &
				  [ CAT.VAL.SUBJ < pro_ss &
						   [ LOCAL local &
						      [ CONT.INDEX #index ] ] >,
				    CONT.TOP #chand,
                                    THROLE arg3 ] ] > ] ] ].

; 'turn out to be red'
anom_equi_particle_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ LOCAL.CONT.INDEX #index ] >,
		  COMPS < *top*,
			  [ LOCAL local &
				  [ CAT.VAL.SUBJ < pro_ss &
						   [ LOCAL local &
						     [ CONT.INDEX #index ] ] >,
				    CONT.MESSAGE <! [ HANDEL #hand ] !>,
                                    THROLE arg3 ] ] > ],
	    CONT.KEY.ARG4 #hand ] ].

ssr_lt := linking_type &
  [ LOCAL.CONT.KEY support_abstr_rel ].

basic_ssr_expr_lt := ssr_lt &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.TOP #hand,
	    CONT.KEY.ARG4 #hand ] ].

ssr_expr_lt := basic_ssr_expr_lt &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp,
		      COMPS < [ LOCAL.CONT.KEY.ARG3 #arg4 ], #comp, ... >],
	    CONT.KEY.ARG4 #arg4 ] ].

ssr_prdp_expr_lt := basic_ssr_expr_lt &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp,
		      COMPS < #comp & 
			      [ LOCAL.CONT.KEY [ HANDEL #chand,
						 LABEL #label ] ],
			      [ LOCAL.CONT.KEY _to_rel_s &
					       [ ARG3 #arg2 ] ], 
			      ... > ],
	    CONT [ INDEX #ind,
		   KEY #key & [ ARG2 #arg2 & non_expl-ind ],
		   LISZT <! #key,
			    support_gen_rel &
			    [ HANDEL #chand,
			      LABEL #label,
			      EVENT #ind ] !> ] ] ].

sor_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local &
				     [ CONT.INDEX #index,
				       THROLE arg1 ] ] >,
		      COMPS < synsem & [ LOCAL local &
					       [ THROLE arg2 ] ], 
			      [ LOCAL local &
				      [ CONT.TOP #hand,
					THROLE arg3 ] ] > ],
	    CONT.KEY arg14_rel & [ ARG4 #hand,
				   ARG1 #index ] ] ].

expl_it_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local & [ CONT [ INDEX it-ind,
						      KEY.HANDEL #hand ] ] ] >,
		      COMPS < [ LOCAL local &
				      [ CONT.KEY.ARG3 #arg4 ] ], #comp, ... >,
		      --KEYCOMP #comp & 
			   [ LOCAL local &
				   [ CONT.MESSAGE <! [ HANDEL #hand ] !> ] ] ],
	    CONT.KEY support_arg4_rel &
		[ HANDEL #hand,
		  ARG4 #arg4 ] ] ].

expl_prep_trans_lt := linking_type &
 [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL local &
				    [ CONT [ INDEX it-ind,
					     KEY.LABEL #label ] ] ] >,
		     COMPS < [ LOCAL local &
				     [ CONT.INDEX #arg2,
				       THROLE arg3 ] ],
			     [ LOCAL local &
				     [ CONT [ KEY prep_rel & 
						  [ HANDEL #hand,
						    ARG #index,
						    ARG3 #arg1 ] ],
				       THROLE arg1 ] ], ...> ],
	   CONT [ INDEX #index,
		  KEY arg13_rel & [ HANDEL #hand,
				      LABEL #label,
				      ARG1 #arg1,
				      ARG3 #arg2 ] ] ] ].

expl_pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL local &
				     [ CONT [ INDEX it-ind,
					      KEY.LABEL #label ] ] ],
			     [ LOCAL local &
				     [ CONT.KEY.ARG3 #arg2,
				       THROLE arg2 ] ],
			     [ LOCAL local &
				     [ CONT.TOP #hand,
				       THROLE arg3 ] ] > ],
	   CONT.KEY arg124_rel & [ LABEL #label,
				   ARG2 #arg2,
				   ARG4 #hand ] ] ].

; 'leave it to Kim to find the answer'
expl_pp_inf_oeq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL.COMPS < *top*,
			 [ LOCAL.CONT.KEY.ARG3 #arg3 ],
			 [ LOCAL.CONT.KEY arg1_rel & [ ARG1 #arg3 ] ] > ].

; 'arrange with Kim to meet her'
pp_inf_seq_lt := pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL local &
				  [ CONT.INDEX #arg1 ] ] >,
		   COMPS < *top*,
			   [ LOCAL.CONT.KEY arg1_rel & [ ARG1 #arg1 ] ] > ] ].

; 'arrange it with Kim to meet her'
expl_pp_inf_seq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL local &
				  [ CONT.INDEX #arg1 ] ] >,
		   COMPS < *top*,
			   *top*,
			   [ LOCAL.CONT.KEY arg1_rel & [ ARG1 #arg1 ] ] > ] ].

; suffice
atrans_inf_lt := linking_type &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
				    [ CONT.TOP #hand ] ] >,
	    CONT.KEY arg14_rel & [ ARG4 #hand ] ] ].

particle_NP_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.TOP #top ], 
			    [ LOCAL local &
				    [ CONT.INDEX #index & non_expl-ind,
				      THROLE arg3 ] ] >,
	    CONT [ TOP #top,
		   KEY arg13_rel & [ ARG3 #index ] ] ] ].

NP_particle_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
				    [ CONT.INDEX #index & non_expl-ind,
				      THROLE arg3 ] ], 
			    [ LOCAL.CONT.TOP #top ], ... >,
	    CONT [ TOP #top,
		   KEY arg13_rel & [ ARG3 #index ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Val Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Valence types specify the number and type of subcategorized complements.
  
valence_type :< lex_synsem.

unsat_subst := valence_type &
  [ LOCAL.CAT.VAL.SUBJ < @nomp() > ].

intrans_subst := unsat_subst & one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

unsat_two_arg_subst := unsat_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL local &
					     [ CONT.KEY #ckey ] ], ... >,
	    CONT.COMPKEY #ckey ] ].

two_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

; For verbs that passivize.
trans_subst := unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc(), ... > ].
  
np_trans_subst := trans_subst & two_arg_subst & two_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem > ].
  
; For verbs with NP complement but that don't passivize.
non_trans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc(), ... > ].
  
np_non_trans_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem > ].

cp_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < #comp & @cp($vform=fin) > ] ].
  
prd_intrans_subst := two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < @prd() > ].

prep_intrans_subst := two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < @pp() > ].

unsat_three_arg_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    synsem & [ LOCAL local &
					     [ CONT.KEY #ckey ] ], ... >,
	    CONT.OCOMPKEY #ckey ] ].

basic_three_arg_subst := unsat_three_arg_subst & basic_three_arg_nonzero.

three_arg_subst := basic_three_arg_subst &
  [ LOCAL.CONT.H-CONS <! is-one-of, leq !> ].

three_arg_raising_subst := unsat_three_arg_subst & three_arg_raising.

three_arg_trans_subst := unsat_three_arg_subst & three_arg & trans_subst.

three_arg_trans_raising_subst := unsat_three_arg_subst & three_arg_obj_raising &
				 trans_subst.

three_arg_nontrans_raising_subst := unsat_three_arg_subst & 
				    three_arg_obj_raising &
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc(), ... > ].

prep_trans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc(), @pp() > ].
  
prep_non_trans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc() & lex_synsem, @pp() > ].
  
prd_trans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc(), @prd() > ].

prd_non_trans_subst := three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc(), @prd() > ].

ditrans_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc(), @nomp_acc() &
			               [ LOCAL.CONT.KEY nonpro_rel ] > ].
  
; 'inform Kim that S'
cp_trans_subst := three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < @nomp_acc(),
			    #comp & @cp($vform=fin) > ] ]. 
  
pp_cp_subst := three_arg_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < @pp(),
			    #comp & @cp($vform=fin) > ] ].
  
np_comp_subst := three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc(),
			  [ LOCAL local &
				 [ CAT [ HEAD prep,
					 VAL [ SUBJ < synsem >,
					       COMPS *olist* ] ] ] ] > ].
; 'talk to Kim about Sandy'
double_pp_subst := three_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < @pp(), @pp() > ].
  
inf_or_prp_intrans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < #comp & @vp($vform=inf_or_prp) > ] ].

inf_intrans_subst := inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL local &
				  [ CAT.HEAD.VFORM inf ] ] > ].

for_inf_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < @cp($vform=inf) > ].

inf_trans_subst := three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp, 
		    COMPS < *top*, #comp & @vp($vform=inf) > ] ].

inf_trans_raising_subst := three_arg_trans_raising_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp, 
		    COMPS < *top*, #comp & @vp($vform=inf) > ] ].

prp_intrans_subst := inf_or_prp_intrans_subst & two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL local &
				  [ CAT.HEAD.VFORM prp ] ] > ].

; 'make, let, watch' don't passivize.  Some of these have an apparently
; corresponding passive, but with an ordinary 'to-VP' complement, not vform bse.
bse_nontrans_raising_subst := three_arg_nontrans_raising_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, @vp($vform=bse) > ].

; want (doesn't passivize)
inf_non_trans_subst := three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < *top*, #comp & @vp($vform=inf) > ] ].

pp_inf_subst := unsat_three_arg_subst &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < @pp(),
			    #comp & @vp($vform=inf) > ] ].

; We treat raising as the identification of the CONT attribute of the SUBJ and
; the COMPS.SUBJ, rather than the whole synsem, in part to enable the 
; underspecification of the base/non3sg lex-entry for verbs, where otherwise
; CASE information would clash in examples like "Kim believes Sandy to be ready."

ssr_subst := two_arg_subst &
  [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL local & [ CONT #cont ] ] >,
		    COMPS < [ LOCAL local &
			       [ CAT.VAL [ SUBJ < [ LOCAL.CONT #cont, 
						    NON-LOCAL [ SLASH 0-dlist,
								REL 0-dlist,
								QUE 0-dlist ] ]>,
					   COMPS *olist* ],
				 CONT.MESSAGE <! !> ] ] > ] ].

;;; AAC - added to avoid overspecific glb types

ssr_two_arg_subst := ssr_subst & two_arg.
ssr_two_arg_raising_subst := ssr_subst & two_arg_raising.

ssr_inf_subst := ssr_subst & inf_intrans_subst.

; ERB (13-12-97) SUBJ wasn't updated here to be a list.  Fixed now.

ssr_pp_inf_subst :=  three_arg_raising_subst &
  [ LOCAL.CAT.VAL 
	   [ SUBJ < [ LOCAL.CONT #subj ] >,
	     COMPS < @pp(),
		     [ LOCAL local &
			     [ CAT [ HEAD verbal & strict_type &
					  [ VFORM inf ],
				     VAL [ SUBJ < [ LOCAL.CONT #subj,
						    NON-LOCAL [ SLASH 0-dlist,
								REL 0-dlist,
								QUE 0-dlist ]] >,
						   COMPS *olist* ] ],
					  CONT.MESSAGE <! !> ] ] > ] ].

ssr_prdp_pp_subst :=  three_arg_raising_subst &
  [ LOCAL.CAT.VAL 
              [ SUBJ < [ LOCAL local & [ CONT #subj ] ] >,
		COMPS < [ LOCAL local &
			  [ CAT [ HEAD.PRD +,
				  VAL [ SUBJ < [ LOCAL.CONT #subj,
						 NON-LOCAL [ SLASH 0-dlist,
							     REL 0-dlist,
							     QUE 0-dlist ] ] >,
					SPR *olist*,
					COMPS *olist* ],
				  MC na ] ] ],
			@pp() > ] ].

expl_pp_cp_subst :=  three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < @pp(), @cp() > ].

; Raising synsems have to identify the LOCAL value of the raised synsem with
; that of the VP's subject's synsem, rather than identifying the synsems
; themselves, due to our lexical threading of SLASH: if the raised complement
; is extracted, it will be of type gap, and therefore have a non-empty SLASH,
; but we don't want the lower VP complement's subject to also then have a
; non-empty SLASH.  But cf. note above for subj-subj raising, where maybe we
; even want to restrict the identity to CONT only.
;   Indeed, this seems necessary, since CASE blocks unification for
; 'Kim made him sleep' where our (dual-purpose) 'sleep' requires its subject
; to be [CASE nom] (in order to block the sentence "them sleep"), but when its
; subject is raised to object as with "make", there's a conflict with the
; [CASE acc] on the object of "make".  So here again, we make the raising
; identity hold only for CONT.

sor_inf_subst := inf_trans_raising_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL.CONT #subj,
			    OPT - ], 
			  [ LOCAL local &
				  [ CAT.VAL.SUBJ 
						< [ LOCAL.CONT #subj,
						    NON-LOCAL [ SLASH 0-dlist,
								REL 0-dlist,
								QUE 0-dlist ] ]>,
					CONT.MESSAGE <! !> ],
				OPT - ] > ].

sor_bse_subst := bse_nontrans_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT #subj,
			    OPT - ], 
			  [ LOCAL local &
				  [ CAT.VAL.SUBJ 
					     < [ LOCAL.CONT #subj,
						 NON-LOCAL [ SLASH 0-dlist,
							     REL 0-dlist,
							     QUE 0-dlist ] ] > ],
			    OPT - ] > ].

sor_inf_non_trans_subst := inf_non_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT #subj,
			    OPT - ],
			  [ LOCAL local &
				  [ CAT.VAL.SUBJ 
					     < [ LOCAL.CONT #subj,
						 NON-LOCAL [ SLASH 0-dlist,
							     REL 0-dlist,
							     QUE 0-dlist ] ]>,
					CONT.MESSAGE <! !> ],
				OPT - ] > ].

particle_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS 
           < lex_synsem & [ LOCAL local &
				  [ CAT.HEAD.PRD -,
				    CONT [ H-STORE <! !>,
					   KEY selected_rel &
						   [ HANDEL #hand,
						     LABEL #label ] ] ],
			    NON-LOCAL [ SLASH 0-dlist,
					REL 0-dlist,
					QUE 0-dlist ] ], ... >,
	    CONT.KEY [ HANDEL #hand,
		       LABEL #label ] ] ].

;; DPF (29-Jan-99) Modified particle_NP_subst to exclude pronominal NP objects,
;; to block *Kim looked up it"

particle_NP_subst := particle_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < lex_synsem,
			  @nomp_acc() &
			  [ LOCAL.CONT.KEY nonpro_rel ] > ].

generic_NP_particle_subst := unsat_subst & 
  [ LOCAL [ CAT.VAL.COMPS < @nomp_acc(),
			    lex_synsem &
			    [ LOCAL local &
				    [ CAT [ HEAD.PRD - ],
				      CONT.KEY #ckey & selected_rel &
					               [ LABEL #label ] ],
			      NON-LOCAL [ SLASH 0-dlist,
					  REL 0-dlist,
					  QUE 0-dlist ] ], ... >,
	    CONT [ COMPKEY #ckey,
		   KEY.LABEL #label ] ] ].

NP_particle_subst := generic_NP_particle_subst & trans_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

particle_plus_subst := particle_subst & three_arg_subst.

particle_prd_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, @prd() > ].

; 'turn out to be'
particle_inf_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < *top*, #comp & @vp($vform=inf) > ] ].

particle_pp_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, @pp() > ].

; 'find out that S'
particle_cp_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < *top*, #comp & @cp($vform=fin) > ] ].

;; 'leave it to Kim to schedule the meeting'
unsat_four_arg_subst := unsat_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
			  synsem,
			  synsem, ... > ].

; 'leave it to Kim to find the answer'
expl_pp_inf_subst := unsat_four_arg_subst & trans_subst & four_arg &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < *top*, 
			    @pp(),
			    #comp & @vp($vform=inf) > ] ].

;; AAC - PARTICLE_NP_PP_SUBST: 
;; UNSAT_SUBST is redundant - it is an ancestor of GENERIC_NP_PARTICLE_SUBST 

;; 'put kim through to Sandy'
particle_np_pp_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem, @pp() > ].


;; 'bet Kim a fortune that Sandy would win'
;; DPF (19-Oct-98) Added hack to block extraction from the CP complement, since
;; don't know how to avoid topicalized imperative parse for "Abrams bet Browne
;; Chiang slept with subject of "slept" topicalized.

np_np_cp_subst := unsat_four_arg_subst & trans_subst & four_arg &
  [ LOCAL.CAT.VAL [ --KEYCOMP #comp,
		    COMPS < @nomp_acc(),
			    @nomp_acc(),
			    #comp & @cp($vform=fin) &
			    [ NON-LOCAL.SLASH 0-dlist ] > ] ].

; E.g., "I'm not doing too badly"

adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < lex_synsem & [ LOCAL local &
						 [ CAT.HEAD adv,
						   CONT [ KEY adv_rel &
							      [ HANDEL #hand,
								ARG #event ],
							  MESSAGE <! !> ] ] ] >,
	    CONT.KEY [ HANDEL #hand,
		       EVENT #event ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; VERB SYNSEMS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Verb synsems should inherit from one valence type and one linking type.
;; The type verb_synsem is given a non-empty SPR value so VPs can be modified
;; by PPs, but (hack) the synsem is of type anti_synsem to block unification, to
;; avoid ever picking up an actual specifier.
;;   Added VIT links for the moment, to satisfy VIT requirements for visibility
;; of TENSE and MOOD information.  (Actually, moved VITTENSE specification to
;; the various inflectional affixes in lexrules.tdl, to accommodate the collapse
;; of the base and fin-non3sg verb forms.
;; DPF (8-Jul-98) Added QUE <! !>, REL <! !> to block pied piping in verb
;; phrases (taking advantage of lexical amalgamation of these features, together
;; with our treatment of subject-WH as extraction (where only local features are
;; propagated in SLASH).

verb_synsem := lex_synsem &
  [ LOCAL [ STEMHEAD vstem,
            AGR #agr,
            CAT [ HEAD verb* & [ MOOD #vitmood ],
		  VAL [ SUBJ < synsem & #subj &
			       [ LOCAL local &
				       [ AGR #agr ] ] >,
			SPR < anti_synsem >,
			COMPS #comps ] ],
	    CONT.INDEX.VIT.VITMOOD #vitmood,
	    ARG-S < #subj . #comps > ],
    NON-LOCAL [ QUE <! !> & [ LIST < > ] ,
		REL <! !> & [ LIST < > ] ] ].

atrans_verb := verb_synsem & intrans_subst & atrans_lt.

unerg_verb := verb_synsem & intrans_subst & arg1_subj_lt.
  
unacc_verb := verb_synsem & intrans_subst & unacc_lt.
  
; For at least main verb "have" (e.g, "Kim has some rice")
poss_verb := verb_synsem & two_arg_subst & two_arg & poss_lt &
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc() > ].
  
np_trans_verb := verb_synsem & np_trans_subst & trans_lt.
  
np_non_trans_verb := verb_synsem & np_non_trans_subst & two_arg & trans_lt.

np_non_trans_unacc_verb := verb_synsem & np_non_trans_subst & two_arg & 
			   unacc_lt.

;; come to
;;
prep_intrans_verb := verb_synsem & prep_intrans_subst & two_arg & 
		     prep_intrans_lt.

;; look for
;;
empty_prep_intrans_verb := verb_synsem & prep_intrans_subst & two_arg & 
			   empty_prep_intrans_lt.

;; suggest on Tuesday
;;
prep_intrans_event_verb := verb_synsem & prep_intrans_subst & two_arg & 
			   prep_intrans_event_lt.

;; put, move
;;
prep_trans_verb := verb_synsem & prep_trans_subst & prep_trans_lt.
  
;; 
;;
prep_non_trans_verb := verb_synsem & prep_non_trans_subst & prep_trans_lt.
  
;; remind-of
;;
empty_prep_trans_verb := verb_synsem & prep_trans_subst & empty_prep_trans_lt.

;; get-hold-of
;;
empty_prep_non_trans_verb := verb_synsem & prep_non_trans_subst & 
			     empty_prep_trans_lt.

;; regard Kim as tall
np_comp_verb := verb_synsem & np_comp_subst & obj_equi_lt.

;; strike Kim as tall
np_comp_obj_verb := verb_synsem & np_comp_subst & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.INDEX #index ],
			    [ LOCAL.CONT.INDEX #event ] >,
	    CONT.KEY arg13_rel & [ ARG3 #event,
				   ARG1 #index ] ] ].

to_trans_verb := empty_prep_trans_verb &
  [ LOCAL.CONT.OCOMPKEY _to_rel_s ].
  
ditrans_verb := verb_synsem & ditrans_subst & ditrans_lt.
  
ditrans_only_verb := verb_synsem & ditrans_subst & ditrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ OPT - ] > ].

; 'talk to Kim about Sandy'
double_pp_verb := verb_synsem & double_pp_subst & double_pp_lt.

; Raising verbs which take an infinitival complement restrict it to being
; [ MESSAGE <! !> ], which ensures that the VP will be headed by the 
; non-propositional "to" complementizer, which identifies its handle with
; that of its VP complement.

ssr_verb := verb_synsem & ssr_inf_subst & two_arg_raising & ssr_lt &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.TOP #hand,
	    CONT.KEY.ARG4 #hand ] ].

ssr_prd_verb := verb_synsem & ssr_two_arg_raising_subst & ssr_lt &
  [ LOCAL [ CAT.VAL [ COMPS < @prd() & #comp >,
		      --KEYCOMP #comp & [ LOCAL.CONT.TOP #hand ] ],
	    CONT [ KEY #key & [ ARG4 #hand ],
		   LISZT <! #key !> ] ] ].

ssr_pp_inf_verb := verb_synsem & ssr_pp_inf_subst & ssr_expr_lt.

ssr_prdp_pp_verb := verb_synsem & ssr_prdp_pp_subst & ssr_prdp_expr_lt.

sor_verb := verb_synsem & sor_inf_subst & sor_lt.

sorb_verb := verb_synsem & sor_bse_subst & sor_lt.

sor_non_trans_verb := verb_synsem & sor_inf_non_trans_subst & sor_lt.

subj_equi_prp_verb := verb_synsem & prp_intrans_subst & subj_equi_lt.

subj_equi_prd_verb := verb_synsem & prd_intrans_subst & two_arg & 
		      subj_equi_prd_lt.

; AAC - obj_equi_prd_verb 
; three_arg was redundant - it is an ancestor of PRD_TRANS_SUBST 

obj_equi_prd_verb := verb_synsem & prd_trans_subst & 
		     obj_equi_prd_lt.

obj_equi_non_trans_prd_verb := verb_synsem & prd_non_trans_subst & 
			       obj_equi_prd_lt.

; ERB (07-10-96) I am working with the verb 'know' as a prototype for a verb
; that selects by the semantic type (for now expressed as a feature) of its
; sentential complement rather than by the value of CMP or some such hack.  In
; order to do so, I have changed the types around here.  In particular, I am
; adding a new type cp_prop+ques_intrans_verb that takes a sentential
; complement but doesn't care if its a proposition or a question (for verbs
; like 'know').  A further axis of variation is the VFORM of the complement
; (fin vs. inf).  Since my analysis of 'know' never makes use of the resolved
; subtypes (e.g., cp_prop_intrans_verb) I am not adding to the resolved
; subtypes, and just making the old ones inherit from the finite side of
; things for now.  The future inf_cp_prop_intrans_verb will probably be the
; type of subject equi verbs. A further future modification would involve the
; addition of cp_command_intrans_verb and cp_command+prop_intrans_verb for
; verbs like 'insist'.
;
; DPF (19-Jun-98) This type cannot itself simply add the complement CP's 
; (underspecified) message to its LISZT, since the generation algorithm requires
; that no relation on LISZT will ever get more specialized during parsing.  So 
; we make MESSAGE be list-valued (the empty list for all but complementizers
; and clauses), and have the Head-Complement rule append the values of MESSAGE
; from both of its daughters, since the msg comes from the head if it's a
; complementizer, and from the non-head if the head is a verb.

cp_prop+ques_verb := verb_synsem &
  [ LOCAL [ CAT.VAL [ --KEYCOMP 
			  [ LOCAL local &
				  [ CAT [ HEAD verbal & strict_type &
					       [ INV - ] ],
				    CONT [ TOP #hand,
					   MESSAGE <! prop_ques_rel &
						    [ SOA #hand ] !> ] ] ] ],
	    CONT.LISZT.LIST < relation, ... > ] ].

fin_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CAT.HEAD.VFORM fin ].

;; DPF 4/21/98 - Moved [ COMPS.FIRST.LOCAL.CAT.MC - ] from cp_ques_intrans_verb
;; to cp_intrans_verb, to block spurious parse for e.g. "Kim knows who left"
cp_intrans_verb := fin_cp_prop+ques_verb & cp_intrans_subst & two_arg &
		   arg14_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.MC - ] > ].

cp_prop_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.MESSAGE <! prpstn_rel !> ] > ].

cp_ques_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.MESSAGE <! int_rel !> ] > ].

;; suppose
cp_prop_raise_key_verb := fin_cp_prop+ques_verb & cp_intrans_subst & two_arg &
			  alt_arg14_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT [ KEY #key,
					   MESSAGE <! prpstn_rel !> ] ] >,
	    CONT [ KEY #key & mod_role_rel,
		   ALTKEY #altkey,
		   LISZT.LIST < relation, #altkey, ... > ] ] ].

;; tell Kim that/whether S
np_trans_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt.

;; inform Kim that S
fin_np_trans_cp_verb := np_trans_cp_verb &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CAT.HEAD.VFORM fin ].

;; bet Kim ten cents that S
np_np_cp_verb := fin_cp_prop+ques_verb & np_np_cp_subst & tritrans_lt.

;; explain to Kim that S
pp_cp_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
			  [ LOCAL.CONT.MESSAGE <! prpstn_rel !> ] > ].

;; ask Kim whether S
np_trans_cp_ques_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &

  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CONT.MESSAGE <! int_rel !> ] > ].

;; persuade Kim that S
np_trans_cp_prop_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &

  [ LOCAL.CAT.VAL.COMPS < synsem, 
			  [ LOCAL.CONT.MESSAGE <! prpstn_rel !> ] > ].

subj_equi_verb := cp_prop+ques_verb & inf_intrans_subst & two_arg & subj_equi_inf_lt.

obj_equi_verb := cp_prop+ques_verb & inf_trans_subst & obj_equi_inf_lt.

oeq_pp_inf_verb := verb_synsem & pp_inf_subst & three_arg & obj_equi_inf_lt.

pp_inf_seq_verb := cp_prop+ques_verb & pp_inf_subst & three_arg & pp_inf_seq_lt.

anom_equi_verb := cp_prop+ques_verb & inf_non_trans_subst & anom_equi_lt.

particle_inf_verb := cp_prop+ques_verb & particle_inf_subst & 
		     anom_equi_particle_lt.

particle_cp_verb := fin_cp_prop+ques_verb & particle_cp_subst & 
		    particle_cp_lt.

expl_it_subj_verb := cp_prop+ques_verb & expl_pp_cp_subst & expl_it_subj_lt.

expl_pp_inf_oeq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_oeq_lt.

expl_pp_inf_seq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_seq_lt.

atrans_inf_verb := cp_prop+ques_verb & inf_intrans_subst & two_arg & 
		   atrans_inf_lt.

for_to_verb := verb_synsem & for_inf_intrans_subst & two_arg & trans_lt.

expl_prep_trans_verb := verb_synsem & non_trans_subst & 
			expl_prep_trans_lt & three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < *top*, @pp() > ].

particle_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

particle_NP_verb := verb_synsem & particle_NP_subst & particle_NP_lt.

NP_particle_verb := verb_synsem & NP_particle_subst & NP_particle_lt.

particle_prd_verb := verb_synsem & particle_prd_subst & anom_equi_prd_lt.

particle_pp_verb := verb_synsem & particle_pp_subst & 
		    empty_prep_particle_intrans_lt.

particle_np_pp_verb := verb_synsem & particle_np_pp_subst & empty_prep_particle_trans_lt.

; prefer it if ...
expl_obj_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & expl_obj_cp_lt.

adv_verb := verb_synsem & adv_subst & arg1_subj_lt & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < *top* >,
	    CONT [ LISZT.LIST < #key, ... >,
		   KEY #key ] ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The semantics of a main verb consists of the "main" handel for the sentence
; and a list of relations.  A pointer to the main or head relation in the list
; is kept in the KEY attribute.

main_verb_sans_key := mcna & nonconj & nonmsg &
  [ SYNSEM.LOCAL [ CAT.HEAD verb & [ AUX -*,
				     INV - ],
		   CONT.LISZT.LIST < event_rel, ... > ] ].

main_verb := main_verb_sans_key & topkey & affix_bearing &
  [ SYNSEM.LOCAL.CONT [ LISZT.LIST < #key, ... >,
			KEY #key ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; AUXILIARY VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Auxiliary verbs are subject-to-subject raising verbs which also raise the 
; content of the VP complement, possibly tacking an additional relation on the
; end.  They also raise the context of the VP complement, for now at least to
; propagate tense information.
; AUX verbs are further classified by the type of VP complement they 
; select for.  Also, AUX verbs optionally take a neg (post-head) specifier.

aux_verb := verb_synsem &
  [ LOCAL [ CAT.HEAD.TENSE #vittense,
	    CONT.INDEX.VIT.VITTENSE #vittense ] ].
		
aux_verb_ssr := aux_verb & ssr_subst & basic_two_arg &
  [ LOCAL [ ARG-S < synsem, [ LOCAL.CONT.H-STORE #hstore ] >,
	    CAT.VAL [ --KEYCOMP #comp,
		      COMPS < #comp, ... > ],
	    CONT.H-STORE #hstore ] ].

aux_verb_ssr_two_arg := aux_verb_ssr & basic_two_arg_raising.

aux_verb_word_super := mcna & nonconj & nonmsg & hc-to-phr &
  [ SYNSEM aux_verb_ssr ]. 

aux_verb_word := aux_verb_word_super &
  [ SYNSEM.LOCAL.CAT.HEAD.AUX +* ].

bse_aux_verb_word := aux_verb_word & non_affix_bearing &
  [ SYNSEM.LOCAL local &
		 [ CAT [ VAL [ SUBJ < [ OPT - ] >,
			       COMPS < @vp($vform=bse) &
				       [ LOCAL local &
					       [ CAT.HEAD.PRD - ],
					 OPT - ] > ],
			 HEAD [ VFORM fin,
				MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] > ] ] ] ].

;; ought, going
inf_aux_verb_word := aux_verb_word_super &
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD.AUX -,
			 VAL.COMPS < @vp($vform=inf) & 
				     [ LOCAL.CAT.HEAD.PRD -,
				       OPT - ] > ] ] ].

;; Only for auxiliary "have"
psp_aux_verb_word := aux_verb_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < @vp($vform=psp) & 
				   [ OPT -,
				     LOCAL.CONT.KEY [ HANDEL #hand,
						      LABEL #label ] ] >,
		   CONT.KEY [ HANDEL #hand,
			      LABEL #label ] ] ].

; Only for the copula
prd_aux_verb_word := aux_verb_word &
  [ SYNSEM aux_verb_ssr_two_arg &
	   [ LOCAL.CAT.VAL.COMPS < [ LOCAL local &
					   [ CAT [ HEAD.PRD +,
						   VAL [ SUBJ < synsem >,
							 COMPS *olist*,
							 SPR *olist* ],
						   MC na ],
					     CONT.KEY independent_rel ],
				     OPT - ] > ] ].

raise_cont := word_or_lexrule &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
					   [ CONT [ TOP #hand,
						    KEY.LABEL #label,
						    INDEX #index ] ] ], ... >,
		   CONT [ TOP #hand,
			  INDEX #index,
			  KEY.LABEL #label,
			  LISZT <! !> ] ] ].

add_cont := word_or_lexrule &
  [ SYNSEM.LOCAL.CONT [ LISZT.LIST < relation & #key, ... >,
			KEY #key ] ].

; Real modal verbs are auxiliary verbs which select a base form complement.
; They only exist in finite forms.

generic_modal_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr_two_arg &
	   [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.TOP #hand,
		     CONT [ INDEX #event,
			    KEY [ EVENT #event,
				  ARG4 #hand ] ] ] ],
    ARGS < [ AFFIX no-affix ] , ... > ].

fin_modal_verb_word := generic_modal_verb_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD -,
				VFORM fin ],
			 VAL.SUBJ < @nomp_nom() &
				    [ OPT - ] > ],
		   CONT psoa ] ].

pres_modal_verb_word := fin_modal_verb_word & 
  [ SYNSEM.LOCAL.CAT.HEAD.TENSE present* ].

; Assume for now that all modals have simple present tense semantics,
; ignoring the habitual past readings possible for "would" and "could" -
; these will have to be separate lexical entries.

modal_verb_word := pres_modal_verb_word & bse_aux_verb_word.
pos_modal_verb_word := modal_verb_word & topkey &
  [ SYNSEM.LOCAL [ CAT.HEAD.AUX +*,
		   CONT [ KEY #key,
			  LISZT <! #key !>,
			  H-CONS <! is-one-of, leq !> ] ] ].

will_verb_word := fin_modal_verb_word & bse_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.TENSE future*,
		   CONT [ KEY.LABEL #label,
			  COMPKEY.LABEL #label ] ] ].

pos_will_verb_word := will_verb_word & topkey &
  [ SYNSEM.LOCAL [ CAT.HEAD.AUX +*,
		   CONT [ KEY #key,
			  LISZT <! #key !>,
			  H-CONS <! is-one-of, leq !> ] ] ].


ought_verb_word := pres_modal_verb_word & inf_aux_verb_word.
pos_ought_verb_word := ought_verb_word & topkey &
  [ SYNSEM.LOCAL.CONT [ KEY #key,
			LISZT <! #key !>,
			H-CONS <! is-one-of, leq !> ] ].

past_ought_verb_word := fin_modal_verb_word & inf_aux_verb_word &
  [ SYNSEM.LOCAL [ CAT.HEAD.TENSE past*,
		   CONT [ LISZT <! relation !>,
			  H-CONS <! is-one-of, leq !> ] ] ].

#|
; This is currently disabled due to change in VM semdb
quasimodal_word := inf_aux_verb_word & topkey &
  [ SYNSEM aux_verb_ssr_two_arg &
	   [ LOCAL verb_participle_affix &
		   [ CAT.VAL.COMPS.FIRST.LOCAL.CONT [ TOP #hand,
						      INDEX #event ],
		     CONT [ INDEX #event,
			    KEY #key,
			    LISZT <! #key & 
				   [ EVENT #event,
				     ARG #hand ] !> ] ] ] ]. 
|#

#|
quasimodal_word := inf_aux_verb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < >,
			   VAL.COMPS.FIRST.LOCAL.CONT [ TOP #hand,
							INDEX #event,
							KEY [ HANDEL #khand,
							      LABEL #label ] ] ],
		     CONT [ TOP #hand,
			    INDEX #event,
			    KEY [ HANDEL #khand,
				  LABEL #label ],
			    LISZT <! !>,
			    H-CONS <! !> ] ] ] ]. 
|#

quasimodal_word := generic_modal_verb_word & inf_aux_verb_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < >,
			   VAL [ SUBJ < @nomp_nom() > ] ],
		     CONT [ KEY #key,
			    LISZT <! #key !>,
			    H-CONS <! is-one-of, leq !> ] ] ] ].

contracted_aux_word := word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.NON-LOCAL.SLASH 0-dlist ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modifier synsems
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

modifier_synsem :< lex_synsem.

temp_mod_synsem :< nomod_synsem.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NOUNS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;       TYPE                 ISA                what's it for?
;       nominal_synsem       lex_synsem         all nouns
;       xpro_synsem          nominal_synsem     pro v. non-pro dimension
;       xref_synsem          nominal_synsem     ref v. non-ref dimension
;       pronominal_synsem    xpro_synsem        all pronouns
;       nonpronominal_synsem xpro_synsem        all non-pronominal nouns
;       ref_synsem           xref_synsem        personal pro's & nouns
;       non_ref_synsem       xref_synsem        it, there, wh-pronouns
;       ref_pro_synsem       pronominal_synsem  personal pronouns
;                            & ref_synsem
;       non_ref_pro_synsem   pronominal_synsem  it, there, wh-pronouns
;                            & non_ref_synsem
;       noun_synsem          non_pronominal_synsem all non-pro nouns
;                            & ref_synsem 

; The "default" statement that most nouns identify their AGR and INDEX
; will live on noun_synsem and non_ref_pro_synsem, and then be restated for
; personal pronouns other than my special 'they'.  (All this because I can't
; be bothered now to set up a special default type...) 

basic_nom_synsem := lex_synsem & 
  [ LOCAL [ STEMHEAD nstem,
            CAT.HEAD nominal,
	    CONT nom-obj ] ].

nominal_synsem := basic_nom_synsem &
  [ LOCAL.CAT.HEAD.POSS - ].

xpro_synsem :< nominal_synsem.
xref_synsem :< nominal_synsem.

pronominal_synsem := xpro_synsem &
  [ LOCAL [ CAT [ HEAD noun*,
		  VAL.SUBJ < > ] ] ].

nonpronominal_synsem :< xpro_synsem.

; AAC - added following types for verbal_gerund, poss_clitic etc

nonpro_nomod_synsem := nomod_synsem & nonpronominal_synsem.
nomod_onearg_synsem := nomod_synsem & one_arg.
nomod_zero_arg_synsem := nomod_synsem & zero_arg.
nonpro_nomod_onearg_synsem := nonpro_nomod_synsem & nomod_onearg_synsem.


ref_synsem := xref_synsem &
  [ LOCAL [ CONT [ INDEX #inst & ref-ind,
		   LISZT.LIST < basic_nom_rel & #key & 
				    [ INST #inst ], ... >,
		   KEY #key ] ] ].

non_ref_synsem := xref_synsem  & nomod_synsem & zero_arg &
  [ LOCAL.CAT.VAL [ SPR < >,
		    COMPS < > ] ].

ref_pro_synsem := pronominal_synsem & ref_synsem & nomod_synsem &
  [ LOCAL.CONT.H-CONS <! !> ].

non_ref_pro_synsem := pronominal_synsem & non_ref_synsem &
  [ LOCAL [ AGR #agr,
	    CONT.INDEX #agr ] ].

noun_synsem := nonpronominal_synsem & ref_synsem &
  [ LOCAL [ AGR #agr,
	    CAT.HEAD noun*,
	    CONT.INDEX #agr ] ].

temp_mod_two_arg_synsem := temp_mod_synsem & noun_synsem & two_arg.

;;
;; Common nouns
;;


; The specifier more generally will need to include the H-STORE of its N-bar
; in the list of candidates for its restrictor, in addition to the handle of
; the N-bar itself, but we leave this for later.  It is not clear how we
; lexically specify picking up this H-STORE of the N-Bar, since we are not
; lexically amalgamating the H-STOREs of complements, and even worse, we
; can't do it for modifiers since they are not visible to the noun at all.

common_noun_synsem := noun_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
	    CAT.VAL [ SPR < #spr & synsem &
			    [ LOCAL local &
				    [ CAT [ HEAD det,
					    VAL [ SUBJ < >,
						  SPR *olist*,
						  COMPS *olist* ] ],
				      CONT [ KEY [ BV #index,
						   RESTR #ltop ] ] ],
			      OPT - ] >,
		      COMPS #comps ],
	    CONT [ TOP #ltop,
		   INDEX #index ] ] ].

common_noun_nocomp_synsem := common_noun_synsem & one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

noun_nocomp_synsem := common_noun_nocomp_synsem & nonpro_nomod_onearg_synsem.

noun_nocomp_mod_synsem := common_noun_nocomp_synsem & temp_mod_synsem &
  [ LOCAL.CONT.LISZT <! relation !> ].

common_noun_ppcomp_synsem := common_noun_synsem & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL local &
				    [ CAT [ HEAD prep & [ PRD - ],
					    VAL.COMPS *olist* ],
				      CONT.KEY #ckey & 
					  [ ARG3 #index ] ] ] >,
	    CONT [ KEY.ARG3 #index,
		   COMPKEY #ckey ] ] ].

noun_ppcomp_synsem := common_noun_ppcomp_synsem & nonpro_nomod_synsem &
  [ LOCAL.CONT.KEY diadic_nom_rel ].

temp_noun_ppcomp_synsem := common_noun_ppcomp_synsem & temp_mod_synsem &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL.CONT.KEY _of_rel_s,
				OPT + ] >,
		      SPR < [ OPT - ] > ],
	    CONT [ INDEX.DIVISIBLE -,
		   KEY temp_abstr_rel ] ] ].


; For e.g. "hotel" as in "the hotel Marriott" or "the Marriott hotel Hannover"
common_noun_npcomp_synsem := common_noun_synsem & two_arg & nomod_synsem &
  [ LOCAL [ CAT.VAL.COMPS < @nomp_acc() &
			    [ LOCAL.CONT.KEY.INST #cindex,
			      OPT - ] >,
	    CONT [ INDEX #index,
		   KEY.HANDEL #hand,
		   LISZT <! relation, 
			    unspec_rel &
			    [ HANDEL #hand,
			      HINST #index,
			      NHINST #cindex ] !> ] ] ].
; ERB (14-12-97) It might be cleaner in some sense for pro_ss to have that
; pron_rel as its key and then have this construction and others like it
; take the value of that KEY and put it on their LISZT.  Also, if we
; ever move to lexical amalgamation of relations, the pron_rel should get
; incorporated automatically. ... So I'm going to try to do it that way.

; ERB (14-12-97) We just decided that there shouldn't be a pron_rel here.
; The feature PRONTYPE is enough to distinguish the instance introduced
; by the pro_ss as one that doesn't have to be bound.  This move is supposed
; to make the DRT people happy because that way we don't have to give
; the pronoun a handle nor make it the top-h.

; ERB (21-01-98) The pro_ss should be unslashed.

;; a way to meet

scoping_noun_synsem := common_noun_synsem & nonpro_nomod_synsem & two_arg &
  [ LOCAL [ CAT.VAL.--KEYCOMP [ LOCAL.CONT [ TOP #chand,
					     MESSAGE <! [ HANDEL #mhand,
							  SOA #chand ] !> ] ],
	    CONT.KEY hcomp_nom_rel & [ ARG3 #mhand ] ] ].
		   
common_noun_vpcomp_synsem := scoping_noun_synsem &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp,
		      COMPS < #comp & @vp($vform=inf) & 
			      [ LOCAL [ CAT.VAL.SUBJ 
						< pro_ss &
						  [ LOCAL.CONT.INDEX #inst,
						    NON-LOCAL.SLASH 0-dlist ] >,
					CONT [ MESSAGE <! hypo_rel !> ] ],
				OPT - ] > ],
	    CONT [ TOP-H #toph,
		   LISZT <! relation, 
			  pron_rel &
			  [ HANDEL #toph,
			    INST #inst &
				   [ PRONTYPE zero_pron ] ] !> ] ] ].

common_noun_cpcomp_synsem := scoping_noun_synsem &
  [ LOCAL [ CAT.VAL [ --KEYCOMP #comp,
		      COMPS < #comp & @cp($vform=fin) & 
			      [ LOCAL.CAT.HEAD comp & strict_type,
				OPT - ] > ],
	    CONT.LISZT <! relation !> ] ].

mass_noun_synsem := noun_nocomp_synsem &
  [ LOCAL.CONT [ INDEX [ PNG png & [ PN 3sg* ],
			 DIVISIBLE + ],
		 LISZT <! relation !> ] ].

; One of the relations in LISZT is the support relation nominalize_rel 
; which is a subtype of nom_rel, but also introduces the ARG3 attribute 
; for the handle of the verbal relation.  The other rel is the verbal relation.

deverbal_noun_synsem := common_noun_synsem & nonpro_nomod_synsem &
  [ LOCAL.CONT [ LISZT <! nominalize_rel & [ HANDEL #hand ],
			  relation & #altkey & [ HANDEL #hand ] !>,
		 ALTKEY #altkey ] ].

deverbal_intr_noun_synsem := deverbal_noun_synsem & noun_nocomp_synsem.

deverbal_trans_noun_synsem := deverbal_noun_synsem & noun_ppcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT + ].

deverbal_mass_noun_synsem := deverbal_noun_synsem & nonpro_nomod_onearg_synsem &
  [ LOCAL [ CAT.VAL.COMPS < >,
	    CONT.INDEX [ PNG png & [ PN 3sg* ],
			 DIVISIBLE + ] ] ].

deverbal_mass_noun_ppcomp_synsem := deverbal_noun_synsem & 
				    noun_ppcomp_synsem &
  [ LOCAL.CONT.INDEX [ PNG png & [ PN 3sg* ],
		       DIVISIBLE + ] ].

;; Make adj_noun's be of type pronominal_synsem, to block their appearance
;; as left member of noun-noun compounds.

ref_pro_nomod :< ref_pro_synsem.

adj_noun_synsem := ref_pro_nomod &
  [ LOCAL [ CAT [ VAL.SPR < synsem & [ LOCAL local ],
			    synsem &
			    [ LOCAL local &
				    [ CAT [ HEAD det,
					    VAL [ SUBJ < >,
						  SPR *olist*,
						  COMPS *olist* ] ],
				      CONT.KEY def_rel &
					  [ BV #index,
					    RESTR #hand ] ],
			      OPT - ] > ],
            AGR #index,
	    CONT [ TOP #hand,
		   INDEX #index,
		   KEY nominalize_rel & [ HANDEL #hand,
					  INST #index ],
		   H-STORE <! !> ] ] ].

adj_noun_personal_synsem := adj_noun_synsem &
  [ LOCAL.CONT.INDEX.PNG png & [ PN 3pl* ] ].

adj_noun_abstract_synsem := adj_noun_synsem &
  [ LOCAL [ CAT.VAL.SPR < synsem, synsem & [ LOCAL.CAT.HEAD.POSS - ] >,
	    CONT.INDEX.PNG png & [ PN 3sg* ] ] ].

; PRD feature used as a hack to avoid numerical adj nouns in noun-noun compounds,
; pending a better analysis, and similarly for partitives and dofm words.
; Make these [DIVISIBLE -] to avoid bare NPs headed by these (in spite of
; examples like "Three were left"), to allow "The magnificent seven were heroes"
; while blocking "*Magnificent seven were heroes."  We assume that there is
; also a partitive "three" to get "Three of the books were lost" while blocking
; *The three of the books were lost".

numadj_noun_synsem := noun_nocomp_synsem &
  [ LOCAL [ CAT [ HEAD.PRD +,
		  VAL.SPR < [ LOCAL.CONT.KEY quant_or_wh_rel ] > ],
	    CONT [ INDEX #index & 
			 [ PNG png & [ PN 3pl* ],
			   DIVISIBLE - ],
		   ALTKEY const_rel & #altkey &
			  [ ARG #index ],
		   KEY pron_rel & #key &
			 [ INST.PRONTYPE impers ],
		   LISZT <! #key, #altkey !> ] ] ].


; PRD feature used as a hack to avoid partitives in noun-noun compounds,
; pending a better analysis.
; The handle of the of-NP should probably be an argument of the part_of relation,
; as the value of a feature SET.  But for now we simply identify the handles of
; the part_of and the of_NP.

partitive_noun_synsem := noun_synsem &
  [ LOCAL [ CAT [ VAL [ SUBJ < >,
			SPR  < [ LOCAL local &
				       [ CAT.VAL [ SPR  *olist*,
						   COMPS *olist* ],
					 CONT [ KEY degree_rel,
						ALTKEY [ HANDEL #hand,
							 ARG #index ] ] ],
				 NON-LOCAL [ QUE 0-dlist,
					     REL 0-dlist ],
				 OPT + ] >, 
			COMPS < [ LOCAL local &
					[ CAT [ HEAD prep & 
						     [ PRD - ],
						VAL.COMPS *olist* ],
					  CONT.KEY #ckey & _of_rel_s &
					      [ HANDEL #phand, 
						ARG3 #cind ] ],
				  NON-LOCAL.SLASH 0-dlist,
				  OPT + ] > ],
		  HEAD [ PRD +,
			 MOD < > ] ],
	    CONT [ TOP #phand,
		   INDEX #index,
		   KEY #key,
		   ALTKEY #altkey,
		   LISZT.LIST < part_of_rel & #key & 
				[ HANDEL #phand,
				  INST #index,
				  ARG3 #cind & ref-ind ],
				quant_or_wh_rel & #altkey & 
				[ HANDEL #hand,
				  BV #index,
				  RESTR #phand ], ... >,
		   COMPKEY #ckey ] ] ].

basic_intr_noun_word := hcons_amalg_word & basic_affix_bearing &
  [ SYNSEM common_noun_nocomp_synsem &
	   [ LOCAL.CONT.LISZT <! relation !> ] ].

intr_noun_word := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CONT.KEY quant_or_wh_rel ] >,
		     CONT.KEY non_temp_nom_rel ] ] ].

intr_temp_noun_word := basic_intr_noun_word & affix_bearing &
  [ SYNSEM noun_nocomp_mod_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CONT.KEY quant_or_wh_rel ] >,
		     CONT.KEY temp_abstr_rel ] ] ].

irreg_intr_noun_word := basic_intr_noun_word & affix_bearing &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CONT.KEY quant_or_wh_rel ] >,
		     CONT.KEY basic_nom_rel ] ] ].

temp_noun_ppcomp_word := norm_word & affix_bearing &
  [ SYNSEM temp_noun_ppcomp_synsem &
	   [ LOCAL.CONT.LISZT <! relation !> ] ].

temp_noun_ppcomp_nomod_word := norm_word & affix_bearing &
  [ SYNSEM common_noun_ppcomp_synsem & nomod_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.KEY _of_rel_s ] >,
		     CONT.LISZT <! temp_abstr_rel !> ] ] ].

noun_ppcomp_word := hcons_amalg_word & affix_bearing &
  [ SYNSEM noun_ppcomp_synsem &
	   [ LOCAL [ CAT.VAL.COMPS.FIRST.OPT +,
		     CONT.LISZT <! relation !> ] ] ].

noun_ppof_word := noun_ppcomp_word &
  [ SYNSEM.LOCAL.CONT.COMPKEY _of_rel_s ].

noun_ppin_word := noun_ppcomp_word &
  [ SYNSEM.LOCAL.CONT.COMPKEY _in_rel_s ].

; "way" as in "find a way to do that" -- was used in VM, but analysis changed
; so this type not currently in use.  Its semrel.tdl entry was as follows:
;   _way_rel := hcomp_nom_rel &
;     [ INST.SORT entity ].

noun_vpcomp_word := hcons_amalg_word & affix_bearing &
  [ SYNSEM common_noun_vpcomp_synsem ].

noun_cpcomp_word := hcons_amalg_word & affix_bearing &
  [ SYNSEM common_noun_cpcomp_synsem ].

noun_npcomp_word := hc_word & affix_bearing &
  [ SYNSEM common_noun_npcomp_synsem &
	   [ LOCAL.CAT.HC-LEX + ] ].

numadj_noun_word := hcons_amalg_word & non_affix_bearing &
  [ SYNSEM numadj_noun_synsem ].

deverbal_noun_intr_word := hcons_amalg_word & affix_bearing &
  [ SYNSEM deverbal_intr_noun_synsem ].

; For e.g. "meetings", where the singular form is a gerund, which is of type
; word, but we can't yet do plural affixation on words, only on lexemes.
deverbal_noun_intr_plural_word := hcons_amalg_word & non_affix_bearing &
  [ SYNSEM deverbal_intr_noun_synsem & 
	   [ LOCAL.CONT.INDEX.PNG png & [ PN 3pl* ] ] ].

deverbal_noun_trans_word := hcons_amalg_word & affix_bearing &
  [ SYNSEM deverbal_trans_noun_synsem ].

mass_noun_word := hcons_amalg_word & non_affix_bearing &
  [ SYNSEM mass_noun_synsem ].

deverbal_mass_noun_word := hcons_amalg_word & non_affix_bearing &
  [ SYNSEM deverbal_mass_noun_synsem ].

deverbal_mass_noun_ppcomp_word := hcons_amalg_word & non_affix_bearing &
  [ SYNSEM deverbal_mass_noun_ppcomp_synsem ].

plur_noun_word := hcons_amalg_word & non_affix_bearing &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL.CONT [ INDEX.PNG png & [ PN 3pl* ],
			  LISZT <! relation !> ] ] ].

part_noun_word := que_word &
  [ SYNSEM partitive_noun_synsem &
	   [ LOCAL.CONT.LISZT <! relation, relation !>,
	     NON-LOCAL.QUE 0-dlist ] ].

;;
;; Lexical NPs
;;
;;   (proper names, pronouns, names of weekdays, ...)

np_word := norm_no_affix_word &
  [ SYNSEM ref_synsem &
	 [ LOCAL.CAT.VAL [ SPR < >,
			   SUBJ < >,
			   COMPS < > ] ] ].


; Proper names should formally introduce an additional relation in the liszt 
; for the implied definite quantifier.  The following can be viewed as an 
; abbreviation, to be expanded unambiguously in post-processing of the
; semantics (which is also where e.g. underspecified quantifier scopes get
; fully specified).

np_synsem := noun_synsem & nomod_synsem.

np_sing_word := np_word &
  [ SYNSEM np_synsem &
	   [ LOCAL.CONT [ TOP #top,
			  INDEX.PNG png & [ PN 3sg* ],
			  LISZT <! basic_nom_rel &
				   [ HANDEL #nhand,
				     INST #ind ],
				   def_np_rel &
				   [ HANDEL #dhand,
				     BV #ind,
				     RESTR #nhand ] !>,
			  H-STORE <! #dhand !>,
			  H-CONS <! is-one-of &
				  [ SC-ARG #top,
				    CANDS <! #nhand, #dhand !> ],
				    leq &
				  [ SC-ARG #top,
				    OUTSCPD #nhand ] !> ] ] ].

proper_name_sg := np_sing_word & 
  [ SYNSEM.LOCAL.CONT.KEY named_rel ].

letter_name :< proper_name_sg.

np_adv_word :< np_sing_word.

; Lexical NP plurals - maybe only in British English? ("IBM are hiring again.")
;
np_pl_word := np_word &
  [ SYNSEM np_synsem &
	   [ LOCAL.CONT.INDEX.PNG png & [ PN 3pl* ] ] ].

np_word_no_quant := np_word &
  [ SYNSEM np_synsem &
	   [ LOCAL.CONT [ TOP #hand,
			  INDEX.PNG png & [ PN 3sg* ],
			  KEY #key & [ HANDEL #hand ],
			  LISZT <! #key !>,
			  H-STORE <! !>,
			  H-CONS <! !> ] ] ].

;;; AAC 
;;; ref_pro_synsem & nomod_synsem  had GLB adj_noun_synsem
;;; which isn't compatible with the synsem here
;;; DPF
;;; Have to add vacuous constraint in order to convince TDL to accept this as
;;; a type distinct from NOMOD_SYNSEM&REF_PRO_SYNSEM. 

ref_pro_nomod_not_adjnoun_synsem := ref_pro_nomod &
  [ LOCAL.CONT [ H-STORE <! !>,
		 H-CONS <! !> ] ].

personal_pro := np_word &
  [ SYNSEM ref_pro_nomod_not_adjnoun_synsem &
	   [ LOCAL.CONT [ TOP-H #hand,
			  LISZT <! pron_rel !>,
			  KEY.HANDEL #hand,
			  H-STORE <! !> ] ] ].

reflexive_pro := personal_pro &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE acc,
                   AGR #agr,
		   CONT [ INDEX #agr,
			  KEY refl_pro_rel ] ] ].

reciprocal_pro := np_word &
  [ SYNSEM ref_pro_nomod_not_adjnoun_synsem &
	   [ LOCAL [ CAT.HEAD.CASE acc,
		     AGR #agr,
		     CONT [ TOP-H #hand,
			    INDEX #agr,
			    LISZT <! recip_pro_rel !>,
			    KEY.HANDEL #hand,
			    H-STORE <! !>,
			    H-CONS <! !> ] ] ] ].

; 'yours'
poss_pro_np := norm_no_affix_word &
  [ SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD noun* & 
				[ POSS + ],
                           VAL [ SPR < >,
				 COMPS < > ] ],
                     AGR #index,
		     CONT [ INDEX #index,
			    LISZT <! pron_rel & 
				     [ HANDEL #phand,
				       INST #eind &
					      [ PRONTYPE std_pron ] ],
				     def_np_rel & #key & 
				     [ HANDEL #hand,
				       BV #index,
				       RESTR #phand ],
				     poss_rel & #ckey & 
				     [ HANDEL #hand,
				       POSSR #eind,
				       POSSD #index ] !>,
			    KEY #key,
			    ALTKEY #ckey,
			    H-STORE <! #hand !>,
			    H-CONS <! !> ] ] ] ].

; Expletive pronouns "there" and "it"
expletive_it_word := nontopkey & non_affix_bearing &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL.CONT [ INDEX it-ind,
			  LISZT <! !>,
			  KEY no_rel ] ] ].

expletive_there_word := nontopkey & non_affix_bearing &
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL.CONT [ INDEX there-ind,
			  LISZT <! !>,
			  KEY no_rel ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Free relatives
;
; One crucial property of free relatives is that they have a non-empty QUE
; value whose single list element is an index (rather than the handle which
; is employed for ordinary question WH-words).
; The other is that they encode the constraints for their S/XP sister in the
; free-relative construction, in their SLASH attribute.

free_rel_pro_word := nonconj & non_affix_bearing & mcna & nonrel & nonmsg &
		     hc-to-phr & topkey &
  [ SYNSEM synsem &
	   [ LOCAL [ CAT.VAL [ SPR < >,
			       SUBJ < >,
			       COMPS < > ],
		     AGR ref-ind & [ PNG.PN 3sg ],
		     CONT [ TOP #top,
			    INDEX #ind & ref-ind,
			    KEY #key,
			    LISZT.LIST < free_ever_rel &
					 [ HANDEL #dhand,
					   BV #ind,
					   RESTR #nhand ], 
					 #key &
					 [ HANDEL #nhand,
					   INST #ind ], ... >,
			    H-STORE <! #dhand !>,
			    H-CONS <! is-one-of &
				  [ SC-ARG #top,
				    CANDS <! #nhand, #dhand !> ],
				    leq &
				  [ SC-ARG #top,
				    OUTSCPD #nhand ] !> ],
		     ARG-S < > ],
	     NON-LOCAL [ REL 0-dlist,
			 QUE 1-dlist & <! #ind !>,
			 SLASH 1-dlist ] ] ].


; whatever, whoever
free_rel_pro_np_word := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD noun* &
			      [ MOD < > ],
		     CONT.LISZT <! relation, relation !> ],
	     NON-LOCAL.SLASH <! [ CAT.HEAD noun & [ MOD < > ] ] !> ] ].

; when, where
free_rel_pro_np_adv_word := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD noun* &
			      [ CASE acc,
				MOD < > ],
		     CONT.LISZT <! relation, relation !> ],
	     NON-LOCAL.SLASH <! [ CAT.HEAD prep & [ MOD < synsem > ] ] !> ] ].

; whenever, wherever, when, where
free_rel_pro_pp_word := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD prep* &
			      [ MOD < synsem &
				      [ LOCAL intersective_mod &
					      [ CAT vp_cat ] ] > ],
		     CONT [ LISZT <! relation, relation, #altkey !>,
			    ALTKEY #altkey ] ],
	     NON-LOCAL.SLASH <! [ CAT.HEAD prep & [ MOD < synsem > ] ] !> ] ].

; whichever
free_rel_det_word := nonconj & non_affix_bearing & mcna & nonrel & nonmsg &
		     hc-to-phr &
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD.POSS -,
		     CONT [ LISZT <! free_ever_rel !>,
			    H-STORE <! !> ] ],
	     NON-LOCAL [ QUE 1-dlist &
			     [ LIST < index > ],
			 SLASH <! [ CAT.HEAD noun & [ MOD < > ] ] !> ] ] ].



; ERB (31-10-96) A hack:  I want the wh_interrogs to be able to
; get their hands on the which_rel so they can put it on the PARAMS
; list, but QSTORE isn't working yet.  So I am making the QUE value
; of wh_pro_word, wh_adverb_word, and wh_poss_word be the handle of
; the which_rel, so that this gets passed up in such a way that I can see it.

; DPF (14-01-97) To maintain monotonicity, we don't put the handle of the
; WH-operator in H-STORE, but only in QUE, where wh_interrog phrases know
; to look in order to add the handle to their PARAMS list.

; DPF (4-Sept-97) For the moment, add the handle to H-STORE, to get the current
; VM dialogues working, until we can convince our colleagues of the better
; analysis

; who, what

wh_pro_word := que_word &
  [ SYNSEM ref_pro_nomod &
	 [ LOCAL [ CAT.VAL [ SPR < >,
			     COMPS < > ],
                   AGR #index,
                   CONT [ TOP #hand,
			  INDEX #index & [ PNG png & [ PN 3sg* ] ],
			  LISZT <! [ HANDEL #rhand ],
				   which_rel & [ HANDEL #hand,
						 BV #index,
						 RESTR #rhand ] !>,
			  H-STORE <! #hand !> ] ],
	   NON-LOCAL.QUE 1-dlist &
		         [ LIST < #hand > ] ] ].

rel_pro_word := rel_word & 
  [ SYNSEM ref_pro_synsem &
	 [ LOCAL [ CAT.VAL [ SPR < >,
			     COMPS < > ],
                   AGR #index,
		   CONT [ TOP #hand,
			  LISZT <! [ HANDEL #hand,
				     INST #index ] !>,
			  H-STORE <! !>] ],
	   NON-LOCAL.REL 1-dlist &
		         [ LIST < #index > ] ] ].

generic_pro_word := que_word &
  [ SYNSEM np_synsem &
	   [ LOCAL [ CAT.VAL [ SPR < >,
			       COMPS < > ],
		     CONT [ TOP #dethand,
			    LISZT <! reg_nom_rel, #altkey & quant_rel !>,
			    KEY [ HANDEL #hand,
				  INST #inst & [ PNG png & [ PN 3sg* ] ] ],
			    ALTKEY #altkey & 
				   [ HANDEL #dethand,
				     BV #inst,
				     RESTR #hand ],
			    H-STORE <! #dethand !>,
			    H-CONS <! !> ] ],
	     NON-LOCAL.QUE 0-dlist ] ].

deictic_pro_word := norm_no_affix_word &
  [ SYNSEM ref_pro_synsem &
	   [ LOCAL [ CAT.VAL [ SPR < >,
			       COMPS < > ],
		     CONT [ TOP #dhand,
			    LISZT <! generic_nom_rel, 
				     demonstrative_rel & #altkey &
				     [ HANDEL #dhand,
				       BV #ind,
				       RESTR #hand ] !>,
			    H-STORE <! #dhand !>,
			    KEY [ HANDEL #hand,
				  INST #ind ],
			    ALTKEY #altkey ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsems for Auxiliary verb lexical rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ERB (05-10-97) Making this specific to question auxes.  See notes near sai
; in syntax.tdl.
; DPF (10-Jan-99) Added SUBJ < anti_synsem > which never unifies with real
; synsem, in order to allow adjunct extraction to apply to inverted sentences
; such as "When is Kim happy" but not to non-inverted sentences, since the
; latter results in lots of spurious ambiguity.

sai_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD verb* & [ INV +,
				 AUX +* ],
		  VAL [ SUBJ < anti_synsem >,
			COMPS #comps & < [ NON-LOCAL.SLASH 0-dlist ], ... > ],
		  MC + ],
	    CONT basicmrs &
		[ MESSAGE <! int_rel !> ],
	    ARG-S #comps ] ].


;; For AAC 14-Jan-99 - try with example "Sara sleeps doesn't she" then test
;; unification of the SAILR edge (for doesn't) with the lexical rule TAGLR.

#|
tag_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD verb &
		       [ AUX -,
			 INV -,
			 TENSE #tense,
			 MOD < [ LOCAL intersective_mod &
				       [ CAT s_cat &
					     [ HEAD [ VFORM fin,
						      TENSE #tense ] ],
					 AGR #agr &
					     [ PNG png & [ GEN strict_sort,
							   PN strict_sort ] ],
					 CONT [ TOP #hand,
						INDEX #ind,
						KEY #key &
						    [ LABEL #label ],
						MESSAGE <! #presup & prpstn_rel &
							[ SOA #hand ] !> ] ] ]>],
		  POSTHEAD +,
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < pronominal_synsem &
				[ OPT -,
				  LOCAL [ AGR #tagagr,
					  CONT [ INDEX #agr,
						 KEY.LABEL #label ] ] ] > ],
		  
		  MC na ],
	    AGR #tagagr,
	    CONT [ INDEX #ind,
		   KEY #key,
		   MESSAGE <! ne_rel &
			    [ PARAMS <! !> ] !>,
		   LISZT <! !> ],
	    CTXT.PRESUP <! #presup !> ] ].
|#

tag_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD verb &
		       [ AUX -,
			 INV -,
			 TENSE #tense,
			 MOD < [ LOCAL intersective_mod &
				       [ CAT s_cat &
					     [ HEAD [ VFORM fin,
						      TENSE #tense ] ],
					 AGR #agr &
					     [ PNG png & [ GEN strict_sort,
							   PN strict_sort ] ],
					 CONT [ TOP #hand,
						INDEX #ind,
						KEY #key &
						    [ LABEL #label ],
						MESSAGE <! #presup & prpstn_rel &
							[ SOA #hand ] !> ] ] ]>],
		  POSTHEAD +,
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < pronominal_synsem &
				[ OPT -,
				  LOCAL [ AGR #tagagr,
					  CONT [ INDEX #agr,
						 KEY.LABEL #label ] ] ] > ],
		  
		  MC na ],
	    AGR #tagagr,
	    CONT [ INDEX #ind,
		   KEY #key,
		   MESSAGE <! ne_rel &
			    [ PARAMS <! !> ] !> ],
	    CTXT.PRESUP <! #presup !> ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADJECTIVES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (See prep_synsem definition for discussion of ARG attribute.)

; Predicative adjectives introduce an EVENT attribute in a separate support 
; relation, as do predicative PPs (and perhaps also pred. nominals, someday).

; Assume that if adjectives have a specifier, it will be either a measure-NP,
; as in "two feet tall', 'a week later"; or a degree_adverb like "very".

; Since most adjectives are underspecified for being predicative, we have to be
; sure that when they act as modifiers, the unexpressed subject's SLASH value 
; gets terminated (given lexical SLASH amalgamation).  We can't just make the
; adjective's SUBJ be 'unexpressed' since it must unify with the real subject
; in a raising construction.  So we identify the SLASH of the MOD value with
; that of the SUBJ - only one of the two will be realized syntactically.

; Most but not all adjectives can be modifiers, so the most basic adj_synsem
; type does not introduce the MOD feature, to allow for adjectives like
; "impossible" as in "it is impossible to find Kim".

basic_adj_synsem := lex_synsem &
  [ LOCAL [ STEMHEAD astem,
	    ARG-S < #spr . < #subj . #comps > >,
            CAT [ HEAD adj*,
		  VAL [ SUBJ < #subj & @nomp() &
			       [ LOCAL.THROLE arg1 ] >,
			SPR < synsem & #spr &
			      [ LOCAL local &
				      [ CAT [ VAL [ SPR *olist*,
						    COMPS *olist* ],
					      MC na ],
					CONT [ INDEX #darg,
					       KEY degree_rel &
						   [ HANDEL #ahand ] ] ],
				OPT + ] >,
			COMPS #comps ] ],
	    CONT [ LISZT.LIST < basic_adj_rel & #key &
				[ HANDEL #ahand,
				  DIM #darg ], ... >,
		   KEY #key ] ] ].

;; We assume for now, counterfactually, that all modifying adjectives are
;; intersective.

;; ERB (03-02-98) Maybe should add MOD < [ LOCAL.SPR.OPT ] > - to keep 
;; adjectives from modifying partitives.

;; DPF (16-Feb-98) Made SUBJ.INDEX be 'individual' rather than non_expl-ind,
;; to ensure that it gets discourse-bound if the adjective is used in a fragment.

;; DPF (12-Jul-98) Constrain adjectives to only modify nominals with obligatory
;; specifiers (which distinguishes "common" from "proper" nominals).

modifying_adj_synsem := basic_adj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL intersective_mod &
				     [ CAT nbar_cat,
				       CONT.INDEX #ind & ref-ind ] ] >,
		  VAL.SUBJ < [ LOCAL.CONT.INDEX individual ] > ],
	    CONT [ INDEX #ind,
		   KEY abstr_adj_rel & [ ARG #ind ] ] ] ].

nomod_adj_synsem := basic_adj_synsem &
  [ LOCAL.CAT.HEAD.MOD < > ].

adj_synsem :< modifying_adj_synsem.

nonprd_synsem := modifier_synsem &
  [ LOCAL.CAT.HEAD.PRD - ].

prd_synsem := modifier_synsem &
  [ LOCAL.CAT.HEAD.PRD + ].

intrans_adj_synsem := adj_synsem & two_arg &
  [ LOCAL.CAT [ VAL.COMPS < >,
		POSTHEAD - ] ].

attr_adj_synsem := intrans_adj_synsem & nonprd_synsem.

pred_adj_synsem := adj_synsem & prd_synsem.

intrans_pred_adj_synsem := intrans_adj_synsem & prd_synsem.

;;; We should have a trans_adj_attr_synsem too, for 'easy' and the likes ...

trans_adj_pred_synsem := pred_adj_synsem & three_arg &
  [ LOCAL.CAT.VAL.COMPS < @pp() > ].

; e.g. 'able' - Can't use equi_intrans_lt since it specifies an arg13_rel, 
; which is incompatible with adj_rel.  Also, the subj index of adjectives is 
; bound to the ARG role, not the ARG1 role of equi verbs; the ARG role is used
; to give a uniform treatment of semantics of noun modification for adjectives.

reg_adj_equi_synsem := pred_adj_synsem & inf_intrans_subst & three_arg &
  [ LOCAL [ CAT.VAL 
	     [ SUBJ < [ LOCAL.CONT.INDEX #subjind ] >,
	       COMPS < [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL local &
						   [ CONT.INDEX #subjind ] ] >,
				 CONT.TOP #hand ],
			 OPT + ] > ],
	    CONT.KEY adj_arg4_rel &
		     [ ARG #subjind,
		       ARG4 #hand ] ] ].

scoping_adj_synsem := basic_adj_synsem & prd_synsem &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT [ TOP #hand,
					   MESSAGE <! message &
						      [ HANDEL #top,
							SOA #hand ] !> ],
	    CONT.KEY basic_adj_arg4_rel & [ ARG4 #top ] ] ].

reg_adj_atrans_synsem := nomod_adj_synsem & scoping_adj_synsem & pp_inf_subst & 
			 four_arg &
  [ LOCAL 
    [ CAT.VAL 
	  [ SUBJ < [ LOCAL.CONT [ INDEX it-ind,
				  KEY.LABEL #label ] ] >,
	    COMPS < [ LOCAL.CONT.KEY _for_rel & [ HANDEL #ahand,
						  ARG #ind,
						  ARG3 #expr ],
		      OPT + ],
		    [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.INDEX #sind,
					     NON-LOCAL.SLASH 0-dlist ] >,
		      OPT - ], ...> ],
      CONT [ TOP-H #toph,
	     INDEX #ind,
	     KEY it_adj_arg24_rel &
		   [ HANDEL #ahand,
		     LABEL #label,
		     ARG2 #expr ],
	     LISZT <! relation, 
		      pron_rel &
		      [ HANDEL #toph,
			INST #sind & [ PRONTYPE zero_pron ] ] !> ] ] ].


;; DPF (9-Mar-99) It appears that there are no CP-taking adjectives which 
;; select for a 'like-CP' of the kind some verbs take (e.g. 'It sounds like
;; Kim will leave').  So we constrain the --KEYCOMP to be prop_ques_rel.
;; But there are adjectives (like 'doubtful, unclear, unsure') which can take 
;; a whether-CP, so we introduce a subtype of reg_adj_cp_synsem for those that 
;; only take a 'that-CP', and similarly for expletive-it subject-taking 
;; adjectives.

; 'uncertain': '?Kim is uncertain that Sandy left' 
;              'Kim is uncertain whether Sandy left' 
;              'It is uncertain that Sandy left'
;              'It is uncertain whether Sandy left'
reg_adj_cp_synsem := scoping_adj_synsem & nomod_adj_synsem & cp_intrans_subst & 
		     three_arg &
  [ LOCAL [ CAT.VAL.--KEYCOMP.LOCAL.CONT.MESSAGE <! prop_ques_rel !>,
	    CONT [ KEY adj_arg4_rel,
		   LISZT <! relation !> ] ] ].

; 'unclear' '*Kim is unclear that/whether Sandy left'
;           'It is unclear that Sandy left'
;           'It is unclear whether Sandy left'
reg_adj_atrans_cp_synsem := reg_adj_cp_synsem &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT [ INDEX it-ind,
					  KEY.LABEL #label ] ] >,
	    CONT.KEY.LABEL #label ] ].

; 'afraid'  'Kim is afraid that Sandy left'
;           '*Kim is afraid whether Sandy left'
;           '*It is afraid that/whether Sandy left'
reg_adj_that_cp_synsem := reg_adj_cp_synsem &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CONT.MESSAGE <! prpstn_rel !> ].

; 'obvious' '*Kim is obvious that/whether Sandy left'
;           'It is obvious that Sandy left'
;           '*It is obvious whether Sandy left'
;   but cf. 'It is not obvious whether Sandy left' ***Needs fixing***
reg_adj_atrans_that_cp_synsem := reg_adj_atrans_cp_synsem &
  [ LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CONT.MESSAGE <! prpstn_rel !> ].

adj_word := hcons_amalg_word &
 [ SYNSEM adj_synsem &
	  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.INDEX #ind ] >,
		    CONT [ KEY.ARG #ind,
			   LISZT <! abstr_adj_rel !> ] ] ] ].

reg_adj_word := adj_word & basic_affix_bearing.

; Make these [POSTHEAD -] to prevent them from being postnominal modifiers
reg_intrans_adj := reg_adj_word & 
  [ SYNSEM adj_synsem & modifier_synsem & two_arg &
	   [ LOCAL.CAT [ VAL.COMPS < >,
			 POSTHEAD - ] ] ].

attr_intrans_adj := reg_adj_word &
  [ SYNSEM attr_adj_synsem ].

pred_intrans_adj := reg_intrans_adj & affix_bearing &
  [ SYSNEM pred_adj_synsem ].

intrans_adj_oddsem := norm_no_affix_word &
  [ SYNSEM intrans_adj_synsem ].

;; doctor's appointment
;;; AAC - changed SYNSEM LOCAL CONT LISZT FIRST INST to ARG
compound_adj_word := intrans_adj_oddsem &
  [ SYNSEM attr_adj_synsem &
	 [ LOCAL 
	   [ CAT.HEAD.MOD < [ LOCAL.CONT [ TOP #hand,
					   INDEX #nind ] ] >,
	     CONT [ TOP #hand,
		    LISZT <! relation & [ ARG #aind ],
			     unspec_rel & [ HANDEL #hand,
					    HINST #nind,
					    NHINST #aind ] !> ] ] ] ].

;; {OPT +] is on reg_trans_adj and not on trans_adj_synsem because the 
;; comparison_lr uses trans_adj_synsem and requires OPT -. Same for semantics.

reg_trans_adj := reg_adj_word &
  [ SYNSEM trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.KEY.ARG3 #index ,
				       OPT +] >, 
		     CONT.LISZT <! [ ARG3 #index ] !> ] ] ].

; These 'irregular' types are for multi-word adjectives, which cannot
; be affix-bearing under the current regime.  They should be eliminated
; once we do better with multi-words.

irreg_adj_word := adj_word & non_affix_bearing.

irreg_attr_adj := irreg_adj_word &
  [ SYNSEM attr_adj_synsem &
	  [ LOCAL [ CAT.VAL.SUBJ 
			     < [ LOCAL.CONT [ TOP #hand,
					      INDEX #ind & non_expl-ind ] ] >,
		    CONT.KEY [ HANDEL #hand,
			       ARG #ind ] ] ] ].

irreg_pred_intrans_adj := irreg_adj_word &
  [ SYNSEM intrans_pred_adj_synsem &
	  [ LOCAL [ CAT [ HEAD.PRD +,
			  VAL.SUBJ
			    < [ LOCAL.CONT [ TOP #hand,
					     INDEX #ind & non_expl-ind ] ] > ],
		    CONT.KEY [ HANDEL #hand,
			       ARG #ind ] ] ] ].

irreg_trans_adj := irreg_adj_word &
  [ SYNSEM trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.KEY.ARG #index,
				       OPT + ] >,
		     CONT.LISZT <! [ ARG3 #index ] !> ] ] ].

reg_adj_equi_word := norm_word & affix_bearing &
  [ SYNSEM reg_adj_equi_synsem &
	   [ LOCAL.CONT.LISZT <! abstr_adj_rel !> ] ].

reg_adj_atrans_word := hcons_amalg_word & affix_bearing &
  [ SYNSEM reg_adj_atrans_synsem ].

reg_adj_atrans_cp_word := hcons_amalg_word & affix_bearing &
  [ SYNSEM reg_adj_atrans_cp_synsem ].

reg_adj_atrans_that_cp_word := reg_adj_atrans_cp_word &
  [ SYNSEM reg_adj_atrans_that_cp_synsem ].

reg_adj_cp_word := hcons_amalg_word & affix_bearing &
  [ SYNSEM reg_adj_cp_synsem &
	   [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.INDEX ref-ind & #ind ] >,
		     CONT [ KEY.ARG #ind ] ] ] ].

reg_adj_that_cp_word := reg_adj_cp_word &
  [ SYNSEM reg_adj_that_cp_synsem ].

ordinal_adj_word := reg_intrans_adj & affix_bearing &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRD -,
		   CONT.KEY ord_rel ] ].

; How is Sandy?  How does Tuesday look?
; We adopt the following second-order quantification semantics for these:
;    which (p, property(p), look_seem(proposition_to_property(adj(x),p)))
; where we exploit a type-shifting relation to change the proposition "adj(x)"
; into the associated property "the set of entities of which adj(x) is true",
; so the "which" operator can quantify over that property.

wh_adjective_word := nonconj & non_affix_bearing & mcna & nonslash & nonrel &
		     nonmsg &
  [ SYNSEM lex_synsem &
      [ LOCAL [ STEMHEAD astem,
		ARG-S #subj,
		CAT [ POSTHEAD +,
		      HEAD adj* & [ MOD < > ],
		      VAL [ SUBJ #subj &
				 < @nomp() &
				   [ LOCAL [ CONT [ INDEX #ind,
						    H-STORE [ LIST #hslist,
							      LAST #hslast ] ],
					     THROLE arg1 ] ] >,
			    SPR < >,
			    COMPS < > ] ],
		CONT [ TOP #top,
		       INDEX #ind,
		       LISZT <! adj_rel & [ HANDEL #ahand,
					    ARG #ind ],
			        which_rel & [ HANDEL #whhand,
					      BV #pind,
					      RESTR #hand ],
			        property_rel & [ HANDEL #hand,
						 INST #pind ],
			        prpstn_to_prop_rel & #key &
			        [ HANDEL #prhand,
				  PRPSTN #ahand,
				  PROP #pind ] !>,
		       KEY #key,
		       H-CONS <! is-one-of &
				  [ SC-ARG #top,
				    CANDS [ LIST < #prhand . #hslist >,
					    LAST #hslast ] ],
			         leq &
				  [ SC-ARG #top,
				    OUTSCPD #prhand ] !>,
		       H-STORE [ LIST < #whhand . #hslist >,
				 LAST #hslast ] ] ],
	NON-LOCAL.QUE 1-dlist &
	              [ LIST < #whhand > ] ] ].

; two-hour meeting, two-foot tall
measure_adj_attr_synsem := zero_arg &
  [ LOCAL [ CAT [ HEAD adj* &
		       [ PRD -,
			 MOD < [ LOCAL intersective_mod &
				       [ CAT nbar_cat,
					 CONT.INDEX #ind ] ] > ],
		  VAL [ SUBJ < >,
			SPR < synsem &
			      [ LOCAL local &
				      [ CAT [ VAL [ SPR *olist*,
						    COMPS *olist* ],
					      MC na ],
					CONT [ TOP #top,
					       KEY const_rel & 
						   [ HANDEL #hand,
						     ARG #inst ] ] ],
				OPT - ] >,
			COMPS < > ] ],
		  
	    CONT mrs &
		 [ TOP #top,
		   LISZT <! meas_adj_rel & #key &
			    [ HANDEL #hand,
			      ARG #ind,
			      ARG3 #inst ],
			    nom_rel & #altkey & [ HANDEL #hand,
						  INST #inst ] !>,
		   KEY #key,
		   ALTKEY #altkey ] ] ].

meas_adj_word := norm_no_affix_word &
 [ SYNSEM measure_adj_attr_synsem ].

;; Titles like 'mister', 'professor' which modify proper names

title_synsem := modifier_synsem & zero_arg &
  [ LOCAL [ CAT [ HEAD noun &
		       [ MOD < [ LOCAL intersective_mod &
				       [ CAT np_cat,
					 CONT [ TOP #hand,
						INDEX #ind,
						KEY named_rel & 
						    [ HANDEL #khand ] ] ] ] > ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < > ] ],
	    CONT [ TOP #hand,
		   INDEX #ind,
		   LISZT <! title_rel & #key & [ HANDEL #khand,
						 INST #ind ] !>,
		   KEY #key ] ] ].

title_word := norm_no_affix_word &
  [ SYNSEM title_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].

post_title_word := norm_no_affix_word &
  [ SYNSEM title_synsem &
	   [ LOCAL.CAT.POSTHEAD + ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PREPOSITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Most prepositions can be modifiers.  If they act as a modifier, we'll assume
; they have no subject (leaving for some distinct analysis Carl's "A unicorn
; at the helm, the ship sailed into the horse latitudes."  This lets us use a
; single attribute, ARG, for the index of the phrase modified, or for the
; index of the subject of the PP, in a predicative construction.

; Prepositions also have a distinguished role ARG3 which has as value the
; index of the object of the preposition.  We could introduce distinct role
; names for each preposition (e.g. "ON" for on_rel, "IN" for in-rel) but this
; would complicate the definition of the prep_synsem type, since it needs to
; know the role name to which it assigns the object's index.

; An EVENT attribute is needed for PPs (and other substs used predicatively)
; occurring as complements of the copula as in "the meeting is on Tuesday",
; but on this analysis not postnominally.  This EVENT role is introduced in a
; separate support_rel, supplied by the copula.

; Prepositions, like adjectives and participial verbs, can have either
; predicative or nonpredicative synsems, so each ordinary preposition
; (actually the PP headed by the P) can unify with either a pred. or non-pred.
; constraint, which resolves the underspecification.  One assumption here is 
; that there are no contexts which are underspecified for the PRD feature 
; for PPs.

; N.B. The LISZT value of basic_prep_synsem cannot be a singleton list, since
; adverbs like "when" inherit this synsem, and add additional rels lexically.

; Here we only amalgamate non-local features from the complements, not the
; subject.  This is so we don't get two identical gaps in an example like "Who
; does kim think is under the bed?".  On the other hand, binding theory
; suggests that the subjects of prepositions really are on the ARG-S list.

; DPF (14-Mar-99) Constrained prepositions to not allow pied-piping in
; free relative constructions, where the QUE value is an index rather than
; a handle.

basic_prep_synsem := lex_synsem & 
  [ LOCAL [ CAT.HEAD n_or_p,
	    CONT.LISZT.LIST < norm_relation, ... > ] ].

prep_synsem_unspec_subj := basic_prep_synsem &
  [ LOCAL [ CAT [ HEAD prep*,
		  VAL.COMPS < synsem & 
			      [ LOCAL local &
				      [ CONT [ INDEX #objind,
					       KEY #ckey ] ],
				NON-LOCAL.QUE.LIST *handlelist* ], ... >,
		  POSTHEAD + ],
	    CONT [ LISZT.LIST < #key, ... >,
		   KEY #key & [ ARG3 #objind ],
		   COMPKEY #ckey ] ] ].

; For lexical prepositions taking at least one complement
prep_synsem := prep_synsem_unspec_subj & unsat_two_arg_subst.

; For predicative Ps and PPs like "when", which have a (non-expletive) NP subject

prep_p_synsem := basic_prep_synsem &
  [ LOCAL [ CAT.VAL [ SUBJ < synsem & #subj &
			     [ LOCAL [ CAT np_cat,
				       CONT.INDEX #subjind & event_or_index,
				       THROLE arg1 ],
			       NON-LOCAL [ SLASH 0-dlist,
					   REL 0-dlist,
					   QUE 0-dlist ] ] >, 
		      COMPS #comps ],
	    CONT.KEY.ARG #subjind,
	    ARG-S < #subj . #comps > ] ].

; Ps and PPs that can be modifiers.
; Block PP modification of infinitival "to" - spurious ambiguity.
; Constrain MOD < [ LOCAL.CONT.INDEX > to be non_expl, for fragments like 
; "perhaps in a week"

basic_mod_n_or_vp_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL intersective_mod &
				     [ CAT n_or_v_cat,
				       CONT [ INDEX #ind & non_expl,
					      MESSAGE #msg ] ] ] >,
		  POSTHEAD + ],
	    CONT [ KEY.ARG #ind,
		   INDEX #ind,
		   MESSAGE #msg ] ] ].


mod_n_or_vp_synsem := basic_mod_n_or_vp_synsem &
  [ LOCAL [ CAT.VAL.SPR < synsem & [ LOCAL local &
					   [ CAT [ HEAD adv,
						   VAL [ SPR *olist*,
							 COMPS *olist* ] ],
					     CONT [ TOP #khand,
						    INDEX #darg,
						    KEY degree_rel ] ],
				     NON-LOCAL.QUE 0-dlist,
				     OPT + ] >,
	    CONT.KEY [ HANDEL #khand,
		       DIM #darg ] ] ]. 

prep_p_mod_synsem := prep_p_synsem & mod_n_or_vp_synsem.
prep_p_nonzero_arg := prep_p_mod_synsem & nonzero_arg_synsem &
  [ LOCAL.CONT [ KEY #key,
                 --TOPKEY #key ] ].

prep_prd_or_nonprd_synsem := prep_synsem & prep_p_mod_synsem.

; Strict transitive prepositions which can be either predicative or non-pred:

trans_prep_synsem := prep_prd_or_nonprd_synsem & two_arg &
  [ LOCAL [ CAT.VAL [ SUBJ < [ NON-LOCAL [ SLASH 0-dlist,
					   REL 0-dlist,
					   QUE 0-dlist ] ] > ],
	    CONT.LISZT <! prep_rel !> ] ].

ditrans_prep_synsem := prep_prd_or_nonprd_synsem & three_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < *top*, *top* >,
	    CONT.LISZT <! prep_rel !> ] ].

basic_lex_pp_synsem := prep_p_synsem &
  [ LOCAL [ ARG-S #subj,
	    CAT.VAL [ SUBJ #subj,
		      COMPS < > ] ] ].

lex_pp_synsem := basic_lex_pp_synsem & mod_n_or_vp_synsem &
  [ LOCAL.CAT.HEAD prep* ].

lex_pp_nospec_synsem := basic_lex_pp_synsem & basic_mod_n_or_vp_synsem & 
			one_arg &
  [ LOCAL [ CAT.VAL.SPR < >,
	    CONT [ LISZT <! #key !>,
		   KEY #key ] ] ].

lex_pp_nomod_synsem := prep_p_synsem & one_arg & 
  [ LOCAL [ CAT [ HEAD prep* &
		       [ PRD +,
			 MOD < > ],
		  VAL [ SPR < >,
			COMPS < > ] ],
	    CONT [ INDEX #ind,
		   LISZT <! #key !>,
		   KEY #key & [ ARG #ind ] ] ] ].

lex_pp_one_arg_synsem := lex_pp_synsem & one_arg.

; Ordinary prepositions:

; Moved [ OPT - ] specification to subtypes, to allow "the day before" where
; the complement is missing.
; DPF (9-Mar-99) Made basic_prep_word not inherit from nonmsg, since it has
; its MESSAGE identified with that of its modifiee (via the head_modifier rule)
; and that modifiee will sometimes have a non-empty message, as in
; "Is kim happy in Berlin"

basic_prep_word := msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT.VAL.COMPS < @nomp_acc() > ] ].

prep_word := basic_prep_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.INDEX ref-ind ] > ].

reg_prep_word := prep_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL local &
					 [ CONT.KEY non_temp_nom_rel ],
				   OPT - ] > ].

#|
; Used only for "from", presumably as in "from under the table" - ignore for now.
prep_n_or_p_word := msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS < synsem &
				   [ LOCAL local &
					   [ CAT [ HEAD n_or_p & strict_type,
						   VAL [ SUBJ *olist*,
							 SPR *olist*,
							 COMPS *olist* ] ],
					     CONT.INDEX non_expl-ind,
					     CONJ cnil ],
				     OPT - ] > ] ] ].
|#

; 'from now on', maybe 'from two to four'
ditrans_prep_word := norm_msg_word &
  [ SYNSEM ditrans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS < @nomp_acc() & [ OPT - ], 
				   synsem & [ LOCAL local &
						    [ CAT [ HEAD.PRD -,
							    MC na ] ],
					      NON-LOCAL.QUE.LIST *handlelist* ] >
				 ] ] ].

prep_cp_word := msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
      [ LOCAL [ CAT.VAL.COMPS < @cp($vform=fin) &
				[ LOCAL [ CAT.HEAD.INV -,
					  CONT [ TOP #chand,
						 MESSAGE <! prpstn_rel &
							    [ HANDEL #mhand,
							      SOA #chand ] !> ]],
				  OPT - ] >,
		CONT.KEY.HANDEL #mhand	] ] ].

; Prepositions that don't modify nominals - e.g, 'until'
prep_no_n_mod_word := prep_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ < synsem > ] >,
		       VAL.COMPS < [ OPT - ] > ] ].

; "Case-marking" prepositions, which cannot be modifiers
; and (let's assume) also cannot be modified, so stipulate [ SUBJ < > ].

prep_nosubj_synsem := basic_one_arg &
  [ LOCAL [ ARG-S #comps,
	    CAT [ HEAD prep* & [ PRD -,
				 MOD < > ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS #comps & < synsem & 
					 [ LOCAL local &
						 [ CONT [ TOP #top,
							  INDEX #ind,
							  KEY #ckey &
							      [ HANDEL #chand,
								LABEL #label ],
							  H-STORE #hstore ] ],
					   NON-LOCAL.QUE.LIST *handlelist*,
					   OPT - ] > ] ],
	    CONT [ TOP #top,
		   LISZT <! #key !>,
		   KEY prep_rel & #key &
		       [ HANDEL #chand,
			 ARG3 #ind,
			 LABEL #label ],
		   H-STORE #hstore,
		   H-CONS <! !>,
		   COMPKEY #ckey ] ] ].

; Removed constraint on [COMPS.FIRST.MOD < >] to allow "of the second"
prep_nomod_word := amalg_word &
  [ SYNSEM prep_nosubj_synsem & 
	 [ LOCAL.CAT.VAL.COMPS < @nomp_acc() > ] ].

; nominal "of"
prep_nomod_of_word := prep_nomod_word &
  [ SYNSEM.LOCAL.CONT [ INDEX #ind,
			KEY.ARG3 #ind ] ].

; Lexical PPs

pp_decomp_word := norm_msg_word &
  [ SYNSEM lex_pp_synsem &
	   [ LOCAL.CONT [ TOP #top,
			  INDEX #event,
			  KEY #key,
			  ALTKEY #altkey,
			  LISZT <! [ HANDEL #nhand,
				     INST #ind ],
				 #altkey &
				 [ HANDEL #dhand,
				   BV #ind,
				   RESTR #nhand ],
				 loc_rel & #key &
				 [ HANDEL #lhand,
				   ARG #event,
				   ARG3 #ind ] !>,
			  H-STORE <! #dhand !>,
			  H-CONS <! is-one-of &
				    [ SC-ARG #top,
				      CANDS <! #lhand, #dhand !> ],
				    leq &
				    [ SC-ARG #top,
				      OUTSCPD #lhand ] !> ] ] ].
; 'away'
pp_word := norm_no_affix_word &
  [ SYNSEM lex_pp_one_arg_synsem &
	   [ LOCAL.CONT [ LISZT <! #key !>,
			  KEY #key,
			  H-STORE <! !> ] ] ].

; 'tomorrow'
pp_or_nom_word := norm_msg_word &
  [ SYNSEM lex_pp_nospec_synsem ].

pp_nomod_word := norm_no_affix_word &
  [ SYNSEM lex_pp_nomod_synsem ].

; Prepositions with lexically idiosyncratic complements:

prep_idiom_word := msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ OPT - ], ... > ] ] ].

prep_idiom_pp_word := prep_idiom_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < @pp() > ].

prep_idiom_nomod_word := amalg_word &
  [ SYNSEM prep_nosubj_synsem ].

;; Temporal prepositions:

; Special type for "at" taking hours
;    'at five oclock'
;    'at fifteen to six'

at_prep_word := msg_amalg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS
		       < @nomp_acc() & 
			 [ LOCAL.CONT.KEY hour_rel,
			   OPT - ], ...> ] ] ].

; Prepositions like "before" that take a prep_noun like "now, then".
;   'before now', 'since then'

before_prep_word := norm_msg_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS 
		 < [ LOCAL local &
			   [ CAT [ HEAD n_or_p & [ PRD - ],
				   VAL [ SPR *olist*,
					 COMPS *olist* ],
				   MC na ],
			     CONT.KEY temp_loc_rel ],
		     OPT - ], ... > ] ] ].

; "ten minutes to three" - "to" as head
; Use POSTHEAD to allow "half past three" and "three thirty" but block
;      "?thirty past three" and "*three half"
;; DPF (12-Jul-98) The specifier on hour_prep_words has to be [ OPT + ] in order
;; to block prenominal adjectives from attaching, since they distinguish proper
;; from common nouns by the optionality (or absence) of the specifier.  This 
;; distinction doesn't seem to work well here, but it's the only case, so perhaps
;; the analysis of "ten after three" should be reconsidered.

hour_prep_word := norm_msg_word &
  [ SYNSEM nomod_onearg_synsem &
	 [ LOCAL [ CAT [ HEAD noun* &
			      [ POSS - ],
			 VAL [ SPR < synsem & @nomp_acc() &
				     [ LOCAL [ CAT.POSTHEAD -,
					       CONT [ INDEX #minute,
						      KEY minute_rel ] ],
				       OPT + ] >,
			       COMPS < synsem & @nomp_acc() & 
				       [ LOCAL.CONT 
						    [ INDEX #hour,
						      KEY numbered_hour_rel &
							    #ckey &
							    [ LABEL #label ] ],
					 OPT - ] > ] ],
		   CONT nom-obj &
		       [ INDEX #ind & [ PNG png & [ PN 3sg* ] ],
			 LISZT <! #key !>,
			 KEY #key & hour_prep_rel &
				    [ INST #ind,
				      LABEL #label,
				      MINUTE-IND #minute,
				      HOUR-IND #hour ],
			 COMPKEY #ckey ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADVERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Adverbs modify VPs and APs either pre-head or post-head (or both).
; Sentence-initial adverbials are treated as extractions of post-VP modifiers,
; unless the adverbial is a pre-head modifiier. Otherwise, it would be hard to
; block post-S attachment along with post-VP attachment, which would give 
; spurious ambiguity.

basic_adverb_synsem := zero_arg &
  [ LOCAL [ CAT [ HEAD adv &
		       [ PRD -,
			 MOD < [ LOCAL local_basic &
				       [ CAT.HEAD adverbee & strict_type,
					 CONT [ INDEX #vevent & individual,
						MESSAGE #msg ] ] ] > ],
		  VAL [ SUBJ < >,
			COMPS < > ] ],
	    CONT [ INDEX #vevent,
		   LISZT <! #key !>,
		   KEY #key & abstr_adv_rel,
		   --TOPKEY #key,
		   MESSAGE #msg ] ] ].

basic_scopal_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal_mod &
				   [ CONT.TOP #mhand ] ] >,
	    CONT.KEY.ARG #mhand & handle ] ].

basic_int_adverb_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod &
				   [ CAT adverbee_cat,
				     CONT.INDEX #vevent ] ] >,	
	    CONT [ INDEX #vevent,
		   KEY.ARG #vevent ] ] ].

spec_adverb_synsem := basic_adverb_synsem & 
  [ LOCAL [ CAT.VAL.SPR < synsem & 
			  [ LOCAL local &
				  [ CAT [ HEAD adv, 
					  VAL [ SUBJ < >,
						SPR *olist*,
						COMPS *olist* ],
					  MC na ],
				    CONT [ INDEX #darg,
					   KEY degree_rel &
					       [ HANDEL #hand ] ] ] ] >,
	    CONT.KEY [ HANDEL #hand,
		       DIM #darg ] ] ].

scopal_spec_adverb_synsem := basic_scopal_adverb_synsem & spec_adverb_synsem.
intersect_spec_adverb_synsem := basic_int_adverb_synsem & spec_adverb_synsem.

; VP, PP, AP
scopal_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ VAL [ SUBJ < synsem >,
					     COMPS *olist* ],
				       MC na ] ] > ].
intersect_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ VAL [ SUBJ < synsem >,
					     COMPS *olist* ],
				       MC na ] ] > ].

; VP only
; Block adj modifiee to avoid spurious parse for "almost empty"

scopal_vp_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD v_or_g & strict_type,
				       VAL [ SUBJ < synsem >,
					     COMPS *olist* ],
				       MC na ] ] > ].

intersect_vp_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD v_or_g & strict_type,
				       VAL [ SUBJ < synsem >,
					     COMPS *olist* ],
				       MC na ] ] > ].

intersect_unsatp_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD adverbee & strict_type,
				       VAL [ SUBJ < synsem >,
					     COMPS *olist* ],
				       MC na ] ] > ].

; S or VP (for pre-head scopal adverbs only)
scopal_s_or_vp_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD adverbee & strict_type,
				       VAL.COMPS *olist* ] ] > ].

; S or VP (for pre-head intersective adverbs only) 
intersect_s_or_vp_adverb_synsem := intersect_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD adverbee & strict_type,
				       VAL.COMPS *olist* ] ] > ].

; For adverbs like "maybe" which take no degree specifier
scopal_s_or_vp_adverb_nospec_synsem := basic_scopal_adverb_synsem &
  [ LOCAL.CAT [ VAL.SPR < >,
		HEAD.MOD < [ LOCAL.CAT [ HEAD adverbee & strict_type,
					 VAL.COMPS *olist* ] ] > ] ].

intersect_s_or_vp_adverb_nospec_synsem := basic_int_adverb_synsem &
  [ LOCAL.CAT [ VAL.SPR < >,
		HEAD.MOD < [ LOCAL.CAT [ HEAD adverbee & strict_type,
					 VAL.COMPS *olist* ] ] > ] ].

adverb_word := norm_mod_no_affix_word &
  [ SYNSEM scopal_adverb_synsem & 
	   [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g_or_a & 
						   strict_type ] > ] ].
    
int_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM intersect_adverb_synsem &
	   [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g_or_a & 
						   strict_type ] > ] ].
    
; 'back' of 'back on the table'
int_pp_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM intersect_adverb_synsem &
	   [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD prep & strict_type ] >,
			 POSTHEAD - ] ] ].
    
adv_pre_word := norm_mod_no_affix_word &
  [ SYNSEM scopal_s_or_vp_adverb_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].
    
int_adv_pre_word := norm_mod_no_affix_word & 
  [ SYNSEM intersect_s_or_vp_adverb_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].
    
adv_pre_word_nospec := norm_mod_no_affix_word &
  [ SYNSEM scopal_s_or_vp_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].
    
int_adv_pre_word_nospec := norm_mod_no_affix_word & 
  [ SYNSEM intersect_s_or_vp_adverb_nospec_synsem &
	   [ LOCAL.CAT.POSTHEAD - ] ].
    
adv_post_word := adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

int_adv_post_word := int_adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

vp_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM scopal_vp_adverb_synsem ].
    
int_vp_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM intersect_vp_adverb_synsem ].
    
int_unsatp_adverb_word := norm_mod_no_affix_word &
  [ SYNSEM intersect_unsatp_adverb_synsem ].
    
vp_adv_post_word := vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

int_vp_adv_post_word := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

vp_adv_pre_word := vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ].

int_vp_adv_pre_word := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ].

int_unsatp_adv_pre_word := int_unsatp_adverb_word & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ].

; ERB (31-10-96) See notes near wh_pro_word.
; where, when, how
wh_adverb_word := nonconj & non_affix_bearing & mcna & nonslash & nonrel &
  [ SYNSEM prep_p_nonzero_arg &
      [ LOCAL [ CAT [ POSTHEAD +,
		      VAL.COMPS < >,
		      HEAD prep* &
			       [ PRD bool,
				 MOD < [ LOCAL 
					       [ CAT.HEAD v_or_g_or_a & 
							  strict_type,
						 CONT.H-STORE 
						      [ LIST #hslist,
							LAST #hslast ] ] ] > ] ],
		CONT [ KEY #key,
		       ALTKEY #altkey,
		       LISZT <! #key & [ ARG3 #objind ],
			        which_rel & [ HANDEL #hand,
					      BV #objind,
					      RESTR #restr ],
			        nom_rel & #altkey &
			                  [ HANDEL #restr,
					    INST #objind ] !>,
		       H-STORE [ LIST < #hand . #hslist >,
				 LAST #hslast ] ] ],
	NON-LOCAL.QUE 1-dlist &
	      [ LIST < #hand > ] ] ].
 
rel_adverb_word := rel_word & 
  [ SYNSEM prep_p_nonzero_arg &
      [ LOCAL [ CAT [ HEAD prep*,
		      POSTHEAD +,
		      VAL.COMPS < > ],
		CONT [ KEY #key,
		       ALTKEY #altkey,
		       LISZT <! #key & [ ARG3 #objind ],
			        def_np_rel & [ HANDEL #hand,
					    BV #objind,
					    RESTR #restr ],
			        nom_rel & #altkey &
			                  [ HANDEL #restr,
					    INST #objind ] !>,
		       H-STORE <! #hand !> ] ],
	NON-LOCAL.REL 1-dlist & [ LIST < #objind > ] ] ].


; "on vacation"
pp_idiom_word := norm_no_affix_word &
  [ SYNSEM prep_p_nonzero_arg &
      [ LOCAL [ CAT [ HEAD prep*,
		      VAL.COMPS < > ],
		CONT [ LISZT.LIST < prep_rel & #key, ... > ,
		       KEY #key ] ] ] ].

comparison_spec_word := norm_no_affix_word &
  [ SYNSEM nomod_synsem &
	  [ LOCAL [ CAT [ HEAD adv,
			  VAL [ COMPS < >,
				SPR < > ] ],
		    CONT [ TOP #hand,
			   INDEX #inst,
			   LISZT <! #key &
				    [ HANDEL #hand,
				      C-INST #inst ] !>,
			   KEY #key ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DETERMINERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Determiners must have the KEY relation be the quantifier, since nouns
;; select their determiner in part based on the type of the quantifier rel.
;; The basic determiner synsem has a non-null value for its specifier; this is 
;; to account for cases like "nearly all books, only his book, exactly which
;; book, almost every book".  
;;
;; Quantifiers need to accommodate expressions like
;; 'almost every book'.  One might expect to have the degree_rel of 'almost'
;; take the handle of 'every' as its ARG value, but this may interfere with the
;; treatment of scope via H-STORE, since a quantifier always adds its handle
;; to H-STORE, and this handle interacts with other scope constraints.  So
;; we would have to put the handle of 'almost' in H-STORE as well, but only
;; in case 'almost' is a specifier for determiners, not for e.g.'almost ready'.
;; So we do this by adding separate lexical entries for these det-specs.

basic_det_synsem := nomod_synsem &
  [ LOCAL [ CAT [ HEAD det,
		  VAL [ SPR < [ LOCAL local &
				      [ CONT [ INDEX #darg,
					       KEY degree_rel & 
						   [ HANDEL #khand ] ] ],
				NON-LOCAL [ QUE 0-dlist,
					    REL 0-dlist ],
				OPT + ] >, 
			COMPS < > ] ],
	    CONT nom-obj &
		[ INDEX #index,
		  KEY #key & [ HANDEL #khand,
			       BV #index,
			       DIM #darg ],
		  LISZT.LIST < quant_or_wh_rel & #key, ... >,
		  H-CONS <! !> ],
	    ARG-S < > ] ].

det_synsem := basic_det_synsem &
  [ LOCAL [ CAT.VAL.SPEC < [ LOCAL.CONT.TOP #ntop ] >,
	    CONT [ TOP #ntop,
		   LISZT <! quant_or_wh_rel !>,
		   KEY.HANDEL #hand,
		   H-STORE <! #hand !> ] ] ].

part_det_synsem :< basic_det_synsem.

part_det_synsem_nonwh := part_det_synsem & 
  [ LOCAL [ CAT.VAL.SPEC < [ LOCAL.CONT.TOP #ntop ] >,
	    CONT [ TOP #ntop,
		   KEY.HANDEL #hand,
		   H-STORE <! #hand !> ] ],
    NON-LOCAL.QUE 0-dlist ].

non_part_basic_det_synsem :< basic_det_synsem.
non_part_det_synsem := non_part_basic_det_synsem & det_synsem.

det_word := que_word &
  [ SYNSEM det_synsem & [ LOCAL.CAT.HEAD.POSS - ] ].

det_word_non_part := que_word &
  [ SYNSEM non_part_det_synsem & 
	   [ LOCAL.CAT.HEAD.POSS - ] ].

det_word_sing := det_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV [ PNG png & [ PN 3sg ],
			       DIVISIBLE - ] ].

det_word_mass := det_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV [ PNG png & [ PN 3sg ],
			       DIVISIBLE + ] ].

det_word_plur := det_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.PNG png & [ PN 3pl ] ].

det_word_sg_mass := det_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.PNG png & [ PN 3sg ] ].

pdet_word := que_word &
  [ SYNSEM part_det_synsem_nonwh &
	   [ LOCAL.CONT.LISZT <! quant_or_wh_rel !> ] ].

pdet_word_sing := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV [ PNG png & [ PN 3sg ],
			       DIVISIBLE - ] ].

pdet_word_mass := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV [ PNG png & [ PN 3sg ],
			       DIVISIBLE + ] ].

pdet_word_plur := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.PNG png & [ PN 3pl ] ].

pdet_word_sg_mass := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.PNG png & [ PN 3sg ] ].

; This assumes (falsely) that all plurals are divisible (cf "oats", "clothes")
pdet_word_pl_mass := pdet_word &
  [ SYNSEM.LOCAL.CONT.KEY.BV.DIVISIBLE + ].

pdet_word_wh := que_word &
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD.POSS -,
		     CONT [ LISZT <! quant_or_wh_rel & [ HANDEL #hand ] !>,
			    KEY.HANDEL #khand,
			    H-STORE <! #hand !> ] ],
	     NON-LOCAL.QUE 1-dlist &
		           [ LIST < #khand > ] ] ].

pdet_word_mass_wh := pdet_word_wh &
  [ SYNSEM.LOCAL.CONT.KEY.BV [ PNG png & [ PN 3sg ],
			       DIVISIBLE + ] ].

pdet_word_plur_wh := pdet_word_wh &
  [ SYNSEM.LOCAL.CONT.KEY.BV.PNG png & [ PN 3pl ] ].

pdet_word_one := que_word &
  [ SYNSEM part_det_synsem_nonwh &
	   [ LOCAL [ CAT.VAL.SPEC < [ LOCAL.CONT.KEY.HANDEL #nomhand ] >,
		     CONT.LISZT <! udef_rel &
				   [ BV #ind & 
					[ PNG png & [ PN 3sg ],
					  DIVISIBLE - ] ],
				   const_rel &
				   [ HANDEL #nomhand,
				     ARG #ind,
				     CONST_VALUE "1" ] !> ] ] ].

;; We make the non-quantifier relation generically pron_rel, and have each
;; individual pronoun simply constrain the INST index of that pron_rel.
;;   This type is used for both WH "whose" and relative "whose", so it leaves 
;; both  QUE  and  REL  values unspecified, but supplies all other defaults.

poss_word := nonconj & non_affix_bearing & nonslash & nonmsg & 
	     mcna &
  [ SYNSEM basic_det_synsem &
	   [ LOCAL [ CAT [ HEAD.POSS +,
			   VAL.SPEC < [ LOCAL.CONT.KEY.HANDEL #hand ] > ],
		     CONT nom-obj &
			  [ TOP-H #toph,
			    INDEX #index,
			    LISZT <! quant_or_wh_rel & #key,
				     pron_rel & #altkey & 
				     [ HANDEL #toph,
				       INST #eind &
					      [ PRONTYPE std_pron ] ],
				     poss_rel & [ HANDEL #hand,
						  POSSR #eind,
						  POSSD #index ] !>,
			    KEY #key,
			    ALTKEY #altkey ] ] ] ].

; ERB (31-10-96) See notes near wh_pro_word.

wh_poss_word := poss_word & nonrel &
  [ SYNSEM [ LOCAL.CONT [ KEY which_rel & [ HANDEL #hand ],
			  H-STORE <! #hand !> ],
	     NON-LOCAL.QUE 1-dlist &
			   [ LIST < #hand > ] ] ].

nonwh_poss_word := poss_word & nonque &
  [ SYNSEM non_part_basic_det_synsem &
	   [ LOCAL.CONT [ TOP #hand,
			  KEY def_rel & [ HANDEL #hand ],
			  H-STORE <! #hand !> ] ] ].

rel_poss_word := nonwh_poss_word &
  [ SYNSEM [ LOCAL.CONT.ALTKEY.INST #index,
	     NON-LOCAL.REL 1-dlist &
			   [ LIST < #index > ] ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Possessives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Possessive "'s" takes an NP[-Poss] specifier and projects either an
;; NP[+Poss] phrase (for "the book of Kim's") or a DetP[+Poss] phrase (for
;; "Kim's book").  Either way, the content of the possessive phrase will be a
;; definite possessive quantifier.  The NP[+Poss] things also work pretty well
;; for things like "Kim's is under the desk" if we allow governed NPs to be
;; +Poss.  The tricky thing will be figuring out exactly where `bare
;; possessives' can show up.  Also, we need to add the restriction that the SPR
;; must be non-pronominal.  We cannot simply make the synsem of the SPR be
;; the type nonpronominal, since that NP might be either lexical or phrasal,
;; distinguished by the synsem types lex_synsem and phr_synsem.  So we use
;; the semantic KEY relation to identify nonpronominals.

;; Another question is what do we do with the scope
;; of quantifiers in the possessor?  This entry assumes that they always have
;; narrow scope.  That should be an empirical question, as the saying goes.

poss_clitic := mcna & nonconj & nonmsg & non_affix_bearing &
  [ SYNSEM nomod_synsem &
     [ LOCAL [ ARG-S < #spr >,
	       CAT [ HEAD poss-able &
			  [ POSS + ],
		     VAL [ SPR < #spr & @nomp() &
				 [ LOCAL.CONT [ INDEX #pindex & individual,
						KEY non_temp_nom_rel,
						H-STORE [ LIST #hslist,
							  LAST #hslast ] ],
				   NON-LOCAL [ SLASH #slash,
					       REL #rel,
					       QUE #que ],
				   OPT - ] >,
			   COMPS < > ] ],
	       CONT [ TOP #hand,
		      INDEX #index,
		      LISZT <! #key & def_np_rel & [ HANDEL #hand,
						  BV #index,
						  RESTR #rhand ],
			       #ckey & poss_rel & [ HANDEL #rhand,
						    POSSR #pindex,
						    POSSD #index ] !>,
		      COMPKEY #ckey,
		      KEY #key,
		      H-STORE *diff-list* & [ LIST < #hand . #hslist >,
					      LAST #hslast ],
		      H-CONS <! !> ] ],
       NON-LOCAL [ SLASH #slash,
		   REL #rel,
		   QUE #que ] ] ].

;; The possessive "of" takes an NP[+Poss] complement (e.g., "Kim's", "mine")
;; and modifies an N'[-Poss].  Unfortunately, the way the hierarchy of
;; preposition types is built, there wasn't any type this could inherit from.
;; We could probably rearrange things so this inherits some preposition
;; properties, but right now I'm too lazy.  Also, somehow we'll have to make
;; sure that this doesn't modify a pronoun.  The semantic manipulation here is
;; tricky - keep your eyes on the definite quantifier.  This def_rel provided
;; by the apostrophe-s (for its other life as a determiner), is dropped by the
;; possessive-of, analogous to nouns, verbs, and adjectives dropping the
;; semantics of the prepositions that can mark their complements.  This
;; dropping of the relation is effected by having the possessive-of neglect to
;; grab the handle of the def_rel for its complement, but grab instead the
;; handle (and instance variable) of the NP complement of the apostrophe-s.
;; Then the general semantic pruning mechanism will ignore the def_rel, since
;; its handle will not be a value in any other relation.

poss_of := nonque & nonconj & nonslash & nonrel & mcna & non_affix_bearing &
	   hc-to-phr &
  [ SYNSEM one_arg &
     [ LOCAL 
       [ ARG-S #comps,
	 CAT [ HEAD prep* & 
		    [ PRD -,
		      MOD < [ LOCAL intersective_mod &
				    [ CAT nbar_cat,
				      CONT [ TOP #hand,
					     INDEX #index,
					     MESSAGE #msg ] ] ] > ],
	       VAL [ SUBJ < >,
		     SPR < >,
		     COMPS #comps & < @nomp() & 
				      [ LOCAL [ CAT.HEAD noun &
							 [ POSS + ],
						CONT [ KEY.LABEL #label,
						       ALTKEY [ HANDEL #hand,
								POSSD #index ]]],
					OPT - ] > ],
	       POSTHEAD + ],
	 CONT [ TOP #hand,
		INDEX #index,
		LISZT <! !>,
		KEY no_rel & [ LABEL #label ],
		MESSAGE #msg ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBORDINATING CONJUNCTIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; These are not restricted to modifying only main VPs, since e.g. "if" needs
; to take scope over modals as in "I'd be pleased if we made an appointment."
; This lack of constraint means there will be structural ambiguity for 
; if-clauses, but not spurious - get different scopes of "if" and modals.
; But we restrict them to modifying only finite VPs or imperatives.

; DPF (10-Jan-99) Changed these to modify S rather than VP, since they don't
; appear to survive extraction from embedded clauses, nor do they appear inside
; an extraposed subject relative clause.

; DPF (10-Jan-98) For some reason, can't make the HEAD value prep* - fails to
; unify with strict_type in "Kim sleeps if Sandy sleeps".  Solve later.

subconj_synsem := nonprd_synsem & basic_one_arg & basic_nonzero_arg_synsem &
  [ LOCAL [ ARG-S #comps,
	    CAT [ HEAD prep &
		       [ MOD < [ LOCAL scopal_mod &
				       [ CAT [ HEAD verb & [ VFORM fin ],
					       VAL [ SUBJ *olist*,
						     COMPS *olist* ],
					       MC + ],
					 CONT [ TOP #arg1,
						INDEX #ind,
						MESSAGE #msg ] ] ] > ],
		  VAL [ SUBJ < >,
			COMPS #comps & 
			     < synsem &
			       [ LOCAL [ CAT [ HEAD verb &
						    [ INV -,
						      VFORM fin ],
					       MC +,
					       VAL [ SUBJ < >,
						     COMPS *olist*,
						     SPR *olist* ] ],
					 CONT [ TOP #arg2,
						KEY #ckey, 
						INDEX event,
					       MESSAGE <! prpstn_rel &
							  [ HANDEL #phand,
							    SOA #arg2 ] !> ] ],
				 NON-LOCAL [ SLASH 0-dlist,
					     REL 0-dlist,
					     QUE 0-dlist ],
				 OPT - ] >,
			SPR < > ] ],
	    CONT [ INDEX #ind,
		   KEY #key,
		   COMPKEY #ckey,
		   LISZT <! subord_rel & #key &
			    [ MAIN #arg1,
			      SUBORD #subhand ] !>,
                   H-CONS <! is-one-of, leq,
                             is-one-of &
                             [ SC-ARG #subhand,
                               CANDS <! #phand !> ],
                             leq &
                             [ SC-ARG #subhand,
                               OUTSCPD #phand ] !>,
                   MESSAGE #msg ] ] ].

subconj_word := norm_mod_no_affix_word &
  [ SYNSEM subconj_synsem ].
    
subconj_if_word :< subconj_word.

;  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.MOOD #mood ] >,
;                       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MOOD #mood ] ].

; "in order to"
subconj_inf_synsem := prd_synsem & one_arg &
  [ LOCAL [ CAT [ HEAD prep* &
		       [ MOD < [ LOCAL scopal_mod &
				       [ CAT [ HEAD verb,
					       VAL [ SUBJ < synsem >,
						     COMPS *olist* ],
					       MC na ],
					 CONT [ TOP #arg1,
						INDEX #ind,
						MESSAGE #msg ] ] ] > ],
		  VAL [ SUBJ < >,
			COMPS < @vp($vform=bse) &
				[ LOCAL local &
					[ CAT [ HEAD verb &
						     [ VFORM bse ],
						VAL [ SUBJ < unexpressed >,
						      COMPS *olist*,
						      SPR *olist* ],
						MC na ],
					  CONT [ TOP #arg2,
						 KEY #ckey, 
						 MESSAGE <! !> ] ],
				  NON-LOCAL [ SLASH 0-dlist,
					      REL 0-dlist,
					      QUE 0-dlist ],
				  OPT - ] >,
			SPR < > ] ],
	    CONT [ LISZT <! subord_rel & #key &
			    [ MAIN #arg1,
			      SUBORD #arg2 ] !>,
		   INDEX #ind,
		   KEY #key,
		   COMPKEY #ckey,
		   MESSAGE #msg ] ] ].

subconj_inf_word := norm_mod_no_affix_word &
  [ SYNSEM subconj_inf_synsem ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Coordinating conjunctions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; For efficiency, restrict conjunctions to only coordinate phrases which are
; saturated for COMPS.  This falsely excludes "Kim bought and sold a car".

; DPF (25-Apr-98) Removed COMPS..HEAD subst constraint, to allow 
; "your and my offices"

marker_word := conj_word &
  [ SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD #head,
		     MC #mc,
		     VAL [ SUBJ #subj, 
			   SPR #spr,
			   COMPS < synsem &
				   [ LOCAL local &
					   [ CAT [ HEAD #head,
						   MC #mc,
						   VAL [ SUBJ #subj,
							 SPR #spr,
							 COMPS #comps & 
							      *olist* ] ],
					     CONT [ MESSAGE #msg,
						    H-STORE [ LIST #hslist,
							      LAST #hslast ],
						    KEY #key ] ],
				     OPT - ] 
				   . #comps > ] ],
	       CONT [ MESSAGE #msg,
		      KEY #key,
		      H-STORE [ LIST #hslist,
				LAST #hslast ] ] ] ] ].

; A coordinating conjunction needs to "prime" the CONJ.HANDELS and
; CONJ.INDICES lists, so that the right side of a binary coordination looks
; like an iterated coordination.

coord_word_complex := marker_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT [ TOP #hand,
						    INDEX #ind ],
		   CONJ complex-conj & [ HANDELS <! #hand !>,
					 INDICES <! #ind !> ],
		   CONT [ TOP #top,
			  LISZT <! #altkey & relation &
				 [ HANDEL #chand ] !>,
			  H-CONS <! is-one-of &
				  [ SC-ARG #top,
				    CANDS [ LIST < #chand . #hslist >,
					    LAST #hslast ] ],
				  leq &
				  [ SC-ARG #top,
				    OUTSCPD #chand ] !>,
			  H-STORE [ LIST #hslist,
				    LAST #hslast ],
			  ALTKEY #altkey ] ] ].

coord_word_atomic := marker_word &
  [ SYNSEM.LOCAL [ CONJ atomic-conj,
		   CONT [ LISZT <! !>,
			  H-CONS <! !> ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NEG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; not

; "not" requires its VP complement to be [VFORM non_fin], which is a supersort
; for all non-finite vforms except imp_vform, which is a subsort of bse; the
; other subsort of bse, bse_only, is a subsort of non_fin.  Most verbs with
; base morphology are [VFORM bse], and hence (the VPS they project) can be
; modified by "not", and they can also head imperative clauses, which require
; the head to be [VFORM imp_vform].  Only if modified by "not" will a base
; VP be unable to project an imperative clause; in contrast, "never sleep" is 
; fine as an imperative, since "never" does not further restrict its VP 
; complement leaving it [VFORM bse], which is consistent with the imperative 
; rule.  This fine distinction is due to Rob M.

neg_word := norm_mod_no_affix_word &
  [ SYNSEM nonzero_arg_synsem & 
	 [ LOCAL [ CAT [ HEAD neg &
			      [ MOD < [ LOCAL scopal_mod &
					      [ CAT [ HEAD verbal & strict_type &
							   [ VFORM non_fin ],
						      VAL [ SUBJ < synsem_min >,
							    COMPS *olist* ] ],
						CONT [ TOP #mhand,
						       INDEX #vevent,
						       MESSAGE #msg ] ] ] > ],
			 VAL [ SUBJ < >,
			       COMPS < >,
			       SPR < > ],
			 POSTHEAD - ],
		   CONT [ INDEX #vevent,
			  LISZT <! neg_rel & #key &
				 [ ARG #mhand ] !>,
			  KEY #key,
			  --TOPkey #key,
			  MESSAGE #msg ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; COMPLEMENTIZERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Complementizers except for 'to' are marked [SUBJ < >] which prevents them
; from having PP modifiers.

; ERB (07-10-96) 'whether' clauses are made with the regular hcomp rule, so
; the polar_q_rel must come from 'whether' itself.  This means that whether
; can't identify its KEY with its COMPKEY.  Also, I made complementizer_word
; inherit from msg_word (see comments near that type).  This has the effect of
; making non_affix_bearing be inherited by this type, instead of the lower
; types.

; ERB (14-12-97) to_c_prop needs to be MC + for infinitival relatives
; (see notes near to and non_wh_rel_cl) so this type can't say MC -.
; There is no convenient supertype to all of the MC - ones, so I'm
; just going to put it in on each for now.

; ERB (14-12-97) Complementizer_word can't be nonmod_local because 
; to_c_nonprop is going to have a non-empty mod value.  Again, For
; now I'm scattering this constraint among the lower types as appropriate.

; ERB (13-01-98) In fact, complementizer_word can't even be MC bool,
; because to_c_nonprop has to be MC na in order to head hcomps that
; serve as modifiers, as in "a teacher to talk to Sandy".

; DPF (27-Sept-98) Made KEY be event_rel, since "to" needs to pass up the
; KEY.HANDEL of its complement, in order to get the desired semantics for e.g.
; "Kim is going to lose" where the copula's support_rel identifies its HANDEL
; with that of its complement's KEY.
; DPF (13-Jan-99) Generalized to make KEY be event_rel for all complementizers,
; needed in particular to avoid treating complementizers as particles, which
; are selected by KEY value.

complementizer_word := msg_word & 
  [ SYNSEM.LOCAL local &
		 [ CAT [ HEAD comp &
			      [ POSS -,
				INV - ],
			 VAL.SPR < > ],
		   CONT [ KEY event_rel,
			  LISZT #msglszt,
			  MESSAGE #msglszt ] ] ].

plain_compl_word := complementizer_word &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #subj >,
			     COMPS #comps & 
				  < [ LOCAL local &
					    [ CONT [ TOP #hand,
						     INDEX #ind,
						     KEY #ckey & 
							 [ LABEL #label ] ] ],
				      OPT - ], ... > ],
		   CONT [ TOP #hand,
			  INDEX #ind,
			  KEY.LABEL #label,
			  COMPKEY #ckey ],
		   ARG-S < #subj . #comps > ] ].

; These are the subject-to-object raising complementizers.  We're giving a
; funny three-constituent analysis to CPs: "that [Kim] [walks]" and "for [Kim]
; [to walk]".  One (beneficial) side effect of this is that finite and
; non-finite CPs get a uniform analysis, and we also can do real subject
; extraction without running afoul of the dreaded that-trace filter
; (Perlmutter 1971).  

; We also need another "that", one that combines with an adverbial and an
; S/Adv.  This accounts for why you get preposed modifiers with that clauses
; and not with for/to clauses, and why you don't get the that-t effect when
; you have an adverb in there.  But, that second "that" is going to have to
; bind off a SLASH value, sort of like the tough-movement cases, and that will
; have to wait for lexicalized SLASH passing.

; ERB (14-12-97) See notes at complementizer_word.

two_place_compl_word := complementizer_word & 
  [ SYNSEM basic_two_arg & 
	   [ LOCAL nomod_local &
	   [ ARG-S #comps,
	     CAT [ HEAD [ MOOD #mood,
			  VFORM #vform ],
		   MC -,
		   VAL [ SUBJ < >,
			 COMPS #comps &
			      < synsem & [ NON-LOCAL.SLASH 0-dlist ],
				[ LOCAL local &
					[ CAT [ HEAD verbal &
						     [ MOOD #mood,
						       VFORM #vform ],
						VAL.COMPS *olist* ],
					  CONT [ TOP #hand,
						 KEY #ckey,
						 MESSAGE <! !> ] ],
				  OPT - ] > ] ],
	     CONT [ TOP #hand,
		    KEY #ckey,
		    COMPKEY #ckey,
		    H-STORE <! !>,
		    H-CONS <! !> ] ] ] ].

sor_compl_word := two_place_compl_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < @nomp() & #subj &
				   [ OPT - ],
				   [ LOCAL.CAT.VAL.SUBJ < #subj > ] > ].

that_compl_word := sor_compl_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD [ VFORM fin,
			      AUX - ],
		   CONT.MESSAGE <! prpstn_rel !> ] ].

for_compl_word := sor_compl_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD [ VFORM inf,
			      AUX - ],
		   CONT.MESSAGE <! hypo_rel !> ] ].

like_compl_word := sor_compl_word & 
  [ SYNSEM.LOCAL [ CAT.HEAD [ VFORM fin,
			      AUX - ],
		   CONT.MESSAGE <! _like_c_rel !> ] ].

; ERB (13-01-98) to_compl_word says SUBJ < unexpressed >, but I don't
; how that can be, unless the analysis of raising has changed drastically.
; (With it that way, raising is broken).  So I am getting rid of it.

; ERB (19-01-98) SUBJ < unexpressed > was in there because something
; had to take care of giving that subject a SLASH value.  The solution
; we've opted for is this: the subject of to_c_prop is always PRO, and
; the subject of to_c_nonprop is always raised (that is, all
; infinitival tos except those in raising constructions are to_c_prop).
; So there is no constraint on to_compl_word, but to_c_prop says
; SUBJ < pro_ss > and to_c_nonprop says SUBJ canonical_synsem.

; ERB (03-02-98) KEY should be no_rel.  It used to be identified with
; COMPKEY, but that causes at least one problem: to was able to be the
; SPR of the, since the constrains its choice of SPR by a semantic
; constraint on the KEY.
; DPF (13-Jan-99) This problem should be solved by the above decision to
; make all complementizers have the KEY be of type event_rel.

to_compl_word := plain_compl_word &
  [ SYNSEM basic_two_arg &
	   [ LOCAL [ CAT [ HEAD [ VFORM inf,
				  AUX +,
				  PRD - ],
			   VAL [ SUBJ < [ LOCAL.CONT #cont ] >,
				 COMPS < @vp($vform=bse) &
                                         [ LOCAL [ CAT.VAL.SUBJ 
						        < [ LOCAL.CONT #cont,
							    NON-LOCAL
							    [ SLASH 0-dlist,
								REL 0-dlist,
								QUE 0-dlist ]] >,
						   CONT [ TOP #top,
							  KEY.HANDEL 
							      #khand ] ] ] > ] ],
		     CONT [ TOP #top,
                            KEY.HANDEL #khand,
			    H-CONS <! !> ] ] ] ].

; ERB (14-12-97) Why is the SUBJ here specified as acc?? I'm taking it
; out because that follows now from pro_ss.

; ERB (08-01-98) Presumably that had to do with "for him/*he to sleep..."
; but that's the other to: to_c_nonprop.

; ERB (14-12-97) In order to implement infinitival relatives (I found
; a teacher to talk to Sandy, I found a teacher to talk to), I am
; making to_c_prop MC +.  The reasons for this is that the relevant
; cx (non_wh_rel_cl) needs to be able to take subjh_decl and hcomps
; headed by to_c_prop as its head-dtr, but not an extrasubj phrase.

; ERB (19-01-98) This to has to have a mod value so that it can
; head the infinitival relatives.  Something needs to be said about
; the features mentioned in nomod_local, probably, but I'm not sure
; what yet.  It also needs to be MC na so it can feed extrasubj.

to_compl_prop_word := to_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL intersective_mod &
					      [ CAT nbar_cat ] ] >,
			   VAL.SUBJ < pro_ss >,
			   MC na ],
		     CONT [ MESSAGE <! hypo_rel !>,
			    H-STORE [ LIST #hsfirst,
				      LAST #hslast ] ],
		     ARG-S < [ LOCAL.CONT.H-STORE [ LIST #hsmiddle,
						    LAST #hslast ] ],
			     [ LOCAL.CONT.H-STORE [ LIST #hsfirst,
						    LAST #hsmiddle ] ] > ] ] ].

; ERB (14-12-97) This one will have a non-empty MOD value in order to
; build things like "Kim found a friend to talk to Sandy" where the
; subject of talk has to be bound to friend (unlike in "Kim found a
; friend to talk to" where we're convinced it is discourse bound.)
;
; The semantics are probably not right -- as a place holder in the
; modcont I put a appropriate_rel.  The idea is that "I found a person
; to talk to Sandy" means something like "I found a person who is willing/
; appropriate/suitable to talk to Sandy."  But I don't see how to make
; (something like) the appropriate_rel take the comlement of the to
; as an argument.  There is also the question of whether there should be
; any message associated with this.  One would think not, given that we've
; decided the relevant to is the nonprop one...
;   For now, we're not including this rel.

; ERB (13-01-98) to_compl_nonprop_word must be MC na if it is
; to head hcomps that serve as modifiers as in "a teacher to talk to Sandy".
;
; ERB (19-01-98) All infinitival relatives are now headed by
; to_c_prop.  To_c_nonprop only appears in raising constructions.
; Accordingly, it has no MOD value, and its subject is constrained
; to be canonical_synsem.  I'm not sure the latter constraint is
; actually doing any work for us, but I believe it to be true.
; It can also now inherit from nomod_local.  The MC value might
; could be changed, as well.

to_compl_nonprop_word := to_compl_word & 
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT [ VAL [ SUBJ < canonical_synsem >,
			       COMPS < [ LOCAL local &
					       [ CONT.TOP #hand ] ] > ],
			 MC na ],
		   CONT [ TOP #hand,
			  H-STORE #hstore,
			  MESSAGE <! !> ],
		   ARG-S < synsem, [ LOCAL.CONT.H-STORE #hstore ] > ] ].

;;; DPF (21-Oct-98) Added types for elided "to", since we can't use the lexical
;; rule of auxiliary verbs, since we need to block the NP "the book to", which
;; would be built by that lexical rule, then by the application of subject
;; extraction, and then the infinitival relative rule.

to_compl_elided_word := msg_word &
  [ SYNSEM basic_one_arg &
	   [ LOCAL nomod_local &
		   [ CAT [ HEAD comp &
				[ VFORM inf,
				  INV -,
				  AUX +,
				  PRD - ],
			   VAL [ SUBJ #subj & 
				      < [ LOCAL.CONT [ INDEX #index,
						       H-STORE #hstore ] ] >,
				 SPR < >,
				 COMPS < > ],
			   MC na ],
		     CONT [ LISZT.LIST < ellipsis_rel & #key &
					 [ ROLE #index ], ... >,
			    KEY #key,
			    H-STORE #hstore,
			    H-CONS <! !> ],
		     ARG-S #subj ] ] ].

to_compl_prop_elided_word := to_compl_elided_word & 
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < pro_ss >,
		   CONT [ LISZT <! ellipsis_rel, #msg !>,
			  MESSAGE <! hypo_rel & #msg !> ] ] ].

to_compl_nonprop_elided_word := to_compl_elided_word & 
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < canonical_synsem >,
		   CONT [ LISZT <! ellipsis_rel !>,
			  MESSAGE <! !> ] ] ].

; ERB (08-10-96) Whether was previously a que_word so that things selecting
; for questions could select by QUE values.  This is clearly a hack, and
; further, one that is no longer necessary now that we have semantic selection.
; I have split the old type whether_compl_word into two types: finite and
; nonfinite.  I have also gotten rid of the feature CMP.  
; As for the semantics, whether contributes a polar_q_rel (see notes near
; polar_q_rel in fundamentals.tdl).  Now, according to Rob, things that
; take complements with message-type semantics usually take the handle of
; those complements as the argument in their KEYs.  However, also according
; to Rob, if we did that here, it would imply that "whether Kim left every
; party" has more readings than "Kim left every party", which doesn't seem
; to be true.  Accordingly, whether will identify its handle with the
; handle of its complement, and take the complement's INDEX as the value
; of the ARG in the polar_q_rel.  Now, if whether further identified its
; INDEX with that one, things would be getting pretty twisty, so whether
; will have its own INDEX of type event.

; ERB (24-10-96) MESSAGE now functions like KEY as a pointer to
; a certain rel on the LISZT.  Both wh and yn questions will have an
; int_rel on their LISZT.  This is actually sewn into the LISZT
; by the constructions.  Whether just carries it in its MESSAGE value
; so that it unifies with the right constructions.  In this way, we
; even kind of get Rob's intuition -- whether doesn't, in a sense,
; have a message, because that message isn't on its LISZT.
; Anyway, all of this makes the polar_q_rel irrelevant, so I am removing
; it.  The hcomp_yn_nr construction will make sure the SOA value
; of the int_rel takes the HANDEL of whether's complement.   I don't
; know what to do about whether's HANDEL, KEY, and EVENT now, so I am 
; leaving them unspecified.

; ERB (14-12-97) See notes at complementizer_word.

whether_compl_word := complementizer_word &
  [ SYNSEM.LOCAL nomod_local &
		 [ CAT.MC -,
		   CONT.MESSAGE <! int_rel & [ PARAMS <! !> ] !> ] ].

whether_compl_word_fin := whether_compl_word & sor_compl_word &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin ].

; ERB (08-10-96) In the older version, I had whether_compl_word_inf 
; selecting for something that was just @vp($vform=inf).  I never
; tested for this, but this probably allowed Sandy knew whether whether
; to leave, etc.  One way to get around this is for whether to
; select for something that is MESSAGE <! !>.  In order to do 
; this, I need to build to CPs that are no_rel, but we want this
; anyway (even though I talked Dan out of it at one point).

whether_compl_word_inf := whether_compl_word & plain_compl_word &
  [ SYNSEM ssr_two_arg_raising_subst &
	   [ LOCAL.CAT [ HEAD.VFORM inf,
			 VAL.COMPS < [ LOCAL.CAT [ HEAD comp &
							[ VFORM inf ],
						   VAL [ COMPS *olist*,
							 SPR *olist* ] ] ] > ]]].
	    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Imperative words "don't" and "let's"

; ERB (05-10-97) In order to conflate hcomp_root and hcomp_nc into just one
; hcomp, root_marker_words have to identify their value for mc with that of
; their complement.  (Hcomp_root identified MC for mother and non-head
; daughter.)

root_marker_word := nonque & non_affix_bearing & nonrel & nonconj & hc-to-phr &
  [ SYNSEM synsem &
	 [ LOCAL [ CAT [ HEAD root-marker & [ MOD < >,
					      MOOD #mood ],
			 VAL [ SPR < >,
			       COMPS < synsem &
				       [ LOCAL local &
					       [ CAT [ HEAD.MOOD #mood,
						       VAL.COMPS *olist* ],
						 CTXT #ctxt ],
					 NON-LOCAL [ SLASH 0-dlist,
						     QUE 0-dlist,
						     REL 0-dlist ] ] > ] ],
		   CTXT #ctxt ],
	   NON-LOCAL.SLASH 0-dlist ] ].

lex_imperative := root_marker_word &
  [ SYNSEM.LOCAL 
	   [ CAT [ VAL 
		    [ SUBJ < >,
		      COMPS < [ LOCAL [ CAT [ HEAD verb &
						   [ VFORM bse ],
					      VAL.SUBJ 
						 < synsem &
						   [ LOCAL local &
							   [ CONT.INDEX #inst ],
						     NON-LOCAL [ SLASH 0-dlist,
								 QUE 0-dlist,
								 REL 0-dlist]] >,
					      MC na ],
					CONT.INDEX #ind ],
				OPT - ] > ],
		   MC + ],
	     AGR #inst,
	     CONT [ TOP-H #hand,
		    INDEX #ind,
		    LISZT.LIST < #msg, 
				 pron_rel & [ HANDEL #hand,
					      INST #inst &
						 [ PRONTYPE std_pron ] ], ... >,
		    KEY no_rel,
                    H-CONS <! !>,
		    MESSAGE <! imp_rel & #msg !> ] ] ].

lets_imperative := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.TOP #chand ] >,
		   AGR [ PNG png & [ PN 1pl* ],
			 PRONTYPE std_1pl ],
		   CONT [ TOP #chand,
			  KEY [ HANDEL #khand,
				LABEL #klabel ],
			  LISZT <! relation,
				   pron_rel & [ HANDEL #khand,
						LABEL #klabel ] !> ] ] ].

dont_imperative := lex_imperative &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.TOP #arg ] >,
		   AGR [ PNG png & [ PN 2per ],
			 PRONTYPE std_2 ],
		   CONT [ TOP #neghand,
			  KEY [ HANDEL #khand,
				LABEL #klabel ],
			  LISZT <! relation,
				   pron_rel &
				 [ HANDEL #khand,
				   LABEL #klabel ],
				   neg_rel &
				 [ HANDEL #neghand,
				   ARG #arg ] !> ] ] ].

;; 09-09-97  Added BV and SCOPE attributes temporarily for VM2, since the
;; whq external relation for how_about is like a quantifier, needing four args.
;; Had to change the relation introduced by "how about" to '_which_rel'
;; rather than '_how_about_rel' because of some property of vitADT.  Similar
;; change made to the 'frag-msg' instance in syntax.tdl.
;; 06-Oct-98 DPF - Changed MC value from na to +, to allow "okay, how about kim".

how_about_word := root_marker_word &
  [ SYNSEM.LOCAL [ CAT [ VAL.COMPS 
			 < [ LOCAL [ CAT [ HEAD subst,
					   VAL [ SPR *olist*,
						 COMPS *olist* ] ],
				     CONT [ INDEX #ind,
					    H-STORE [ LIST #hslist,
						      LAST #hslast ] ] ],
			     OPT - ] >,
			 MC + ],
		   CONT [ TOP-H #toph,
			  TOP #top,
			  INDEX #ind & event_or_index,
			  KEY #key,
			  LISZT <! #msg,
				   relation & #key &
					 [ HANDEL #rhand,
					   ARG #ind ] !>,
                          H-CONS <! is-one-of &
                                  [ SC-ARG #top,
                                    CANDS [ LIST < #rhand . #hslist >,
					    LAST #hslast ] ],
                                  leq &
                                  [ SC-ARG #top,
                                    OUTSCPD #rhand ] !>,
                          MESSAGE <! int_rel & #msg &
				   [ HANDEL #toph,
				     SOA #top ] !> ] ] ].

how_about_n_or_p_word := how_about_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD n_or_p,
					   CONT.MESSAGE <! !> ] ] > ].

how_about_v_word := how_about_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
					       MC bool ] ] > ].

; Discourse-related sentential adverbs
;   (e.g. 'then, but')
; DPF 06-Oct-98 - Added MC + to MOD, to block "Kim says but sandy left"
; DPF 15-Oct-98 - Changed HEAD from adv to root-marker, to get "yes, okay"
; DPF 22-Oct-98 - Added MC + to the SYNSEM itself to block the relative clause
;   in "a programmer but he hired".

disc_adv_synsem := canonical_synsem &
  [ LOCAL [ CAT [ HEAD root-marker &
		       [ PRD -,
			 MOD < [ LOCAL scopal_mod &
				       [ CAT [ HEAD v_or_g_or_a & strict_type,
					       VAL.COMPS *olist*,
					       MC na_or_+ ],
					 CONT [ INDEX #ind,
						MESSAGE #msg ],
					 CONJ cnil ] ] > ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < > ] ],
	    CONT [ INDEX event_or_index & #ind,
		   MESSAGE #msg,
		   H-STORE <! !> ],
	    CONJ cnil ],
    NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

;; DPF (29-Jan-99) Constrained lexical disc_adv's to only modify sentences,
;; to block e.g. *Kim is okay happy.

disc_adv_lex_synsem := disc_adv_synsem & lex_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD v_or_g,
				       MC + ] ] > ].

disc_adv_phr_synsem := disc_adv_synsem & phr_synsem.

;; DPF 24-Oct-98 Removed [MC +] from disc_adv_word, since this runs afoul of
;; the carefully balanced constraint on head-modifier structures which requires
;; [MC na], to allow relative clauses as modifiers while preventing ordinary
;; finite clauses from being modifiers.

disc_adv_word := msg_word & topkey &
  [ SYNSEM disc_adv_lex_synsem &
	   [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT [ TOP #top,
						   KEY.HANDEL #khand ] ] >,
		     CONT [ TOP #top,
			    KEY #key & abstr_excl_rel & [ HANDEL #khand ],
			    LISZT <! #key !>,
			    H-CONS <! is-one-of &
				    [ SC-ARG #top,
				      CANDS <! #khand !> ],
				    leq &
				    [ SC-ARG #top,
				      OUTSCPD #khand ] !> ] ] ] ].

disc_adv_saturated_word := disc_adv_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ < > ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Temporal nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Extend to COMPS of temporal nouns the hack blocking extraction of subjects of 
; inverted auxiliaries, which exploits CASE value.
; Block N-N compound of "a two meeting" by stipulating that hour_words are
; PRD +, incompatible with requirement of compound rule.  In contrast, e.g.,
; day_of_week words are unmarked for PRD.
;
; Made CONT.TOP be the handle of the numbered_hour_rel rather than that of
; the implicit def_rel, since hour_words can be modified, as in "two o'clock
; on the sixteenth".  Since the PP unifies its TOP handle with the TOP handle
; of the phrase it modifies, that handle can't be the handle of the quantifier,
; so must be that of the numbered_hour_rel.

; DPF (18-Oct-98) - Removed PRD + from hour_word, so it can combine with its
; minute or am-pm complements and still be a prenominal adjective, as in
; "a ten thirty am meeting"

;; DPF (22-Dec-98) - SYNSEM is typed phr_synsem in order to block "a two meeting"
;; while admitting "a two o'clock meeting" - this works because "two o'clock"
;; combines with "meeting" using the noun-noun compound rule, which requires
;; the left member to have SYNSEM of type lex_synsem.

hour_word := hc_word_no_affix &
  [ SYNSEM phr_synsem &
	 [ LOCAL nomod_local &
		 [ STEMHEAD nstem,
		   CAT [ HEAD noun* & [ POSS - ],
			 VAL [ SUBJ < >,
			       SPR < [ LOCAL local &
					     [ CAT [ HEAD adv,
						     VAL [SPR  *olist*,
							  COMPS *olist* ] ],
					       CONT [ TOP #nhand,
						      INDEX #darg,
						      KEY degree_rel ] ],
				       OPT + ] >,
			       COMPS < @nomp_nom() &
				       [ LOCAL [ CAT.POSTHEAD +,
						 CONT [ KEY minute_rel &
							    [ HANDEL #tophand,
							      LABEL #label,
							      INST #minute ],
							H-STORE 
							    [ LIST #hslist,
							      LAST #hslast ] ] ],
					 NON-LOCAL.SLASH 0-dlist,
					 OPT + ],
				       @nomp_nom() &
				       [ LOCAL [ CAT.POSTHEAD +,
						 CONT.KEY am_pm_rel &
						     [ HANDEL #tophand,
						       LABEL #label,
						       INST #ampm ] ],
					 NON-LOCAL.SLASH 0-dlist,
					 OPT + ] > ],
			 HC-LEX + ],
		   CONT nom-obj &
		       [ TOP #reshand,
			 TOP-H #tophand,
			 INDEX #index,
			 LISZT <! numbered_hour_rel & #key &
				  [ HANDEL #nhand,
				    INST #index,
				    MIN #minute,
				    AM-PM #ampm,
				    LABEL #label,
				    DIM #darg ],
				  def_np_rel &
				  [ HANDEL #dethand,
				    BV #index,
				    RESTR #reshand ] !>,
			 KEY #key,
                         H-CONS <! is-one-of &
                                  [ SC-ARG #reshand,
                                    CANDS <! #nhand, #dethand !> ],
                                  leq &
                                  [ SC-ARG #reshand,
                                    OUTSCPD #nhand ] !>,
			 H-STORE [ LIST < #dethand . #hslist >,
				   LAST #hslast ] ],
		   ARG-S < > ] ] ].

minute_word := np_word_no_quant &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRD +,
		   CONT.KEY minute_rel ] ].

am_pm_word := np_word_no_quant &
  [ SYNSEM.LOCAL [ CAT [ HEAD.PRD +,
			 POSTHEAD + ],
		   CONT.KEY am_pm_rel ] ].

mealtime_word := que_word & nonque &
  [ SYNSEM noun_synsem & nomod_synsem &
	 [ LOCAL [ CAT [ HEAD [ POSS -,
				PRD + ],
			 VAL [ SPR < [ LOCAL local &
					     [ CAT [ HEAD adv,
						     VAL [SPR  *olist*,
							  COMPS *olist* ] ],
					       CONT [ TOP #hand,
						      INDEX #index,
						      KEY degree_rel ] ],
				       OPT + ] >,
			       COMPS *olist* ] ],
		   CONT nom-obj &
		       [ TOP #ltop,
			 INDEX #index,
			 LISZT <! hour_rel & #key &
				  [ HANDEL #nhand,
				    INST #index ],
				  def_np_rel &
				  [ HANDEL #hand,
				    BV #index,
				    RESTR #nhand ] !>,
			 KEY #key,
			 H-CONS <! is-one-of &
				 [ SC-ARG #ltop,
				   CANDS <! #nhand !> ],
				 leq &
				 [ SC-ARG #ltop,
				   OUTSCPD #nhand ] !>,
			 H-STORE <! #hand !> ],
		   ARG-S < > ] ] ].


nomod_one_arg_with_quant := nonzero_arg_synsem & nomod_synsem &
  [ LOCAL [ ARG-S < [ NON-LOCAL [ SLASH #slash,
				  REL #rel,
				  QUE #que ],
		      LOCAL.CONT [ INDEX individual,
				   H-STORE [ LIST #hslist,
					     LAST #hslast ] ] ] >,
	    CONT [ ALTKEY.HANDEL #hand,
		   H-STORE [ LIST < #hand . #hslist >,
			     LAST #hslast ] ] ],
    NON-LOCAL [ SLASH #slash,
		REL #rel,
		QUE #que ] ].


; June, June 1996, June of 1996
month_year_synsem := noun_synsem & nomod_one_arg_with_quant &
  [ LOCAL [ ARG-S #comps,
	    CAT.VAL [ SPR < >,
		      COMPS #comps &
			    < synsem & 
			      [ LOCAL local &
				      [ CAT [ VAL [ SPR *olist*,
						    COMPS *olist* ],
					      MC na ],
					CONT.INDEX #year,
					CONJ cnil ] ] > ],
	    CONT [ INDEX.PNG png & [ PN 3sg*,
				     GEN neut* ],
		   KEY #key & mofy_rel &
			      [ HANDEL #nhand,
				INST #ind,
			        YEAR-IND #year ],
		   ALTKEY #altkey & def_np_rel &
			     [ BV #ind,
			       RESTR #nhand ],
		   LISZT <! #key, #altkey !> ] ],
    NON-LOCAL.SLASH 0-dlist ].

month_of_year_synsem := month_year_synsem &
  [ LOCAL.CAT.VAL.COMPS < @pp() &
			  [ LOCAL.CONT [ KEY _of_rel_s,
					 COMPKEY yofc_rel ],
			    NON-LOCAL.SLASH 0-dlist,
			    OPT + ] > ].

month_no_of_year_synsem := month_year_synsem &
  [ LOCAL.CAT.VAL.COMPS < @nomp_acc() &
			  [ LOCAL.CONT.KEY yofc_rel, 
			    NON-LOCAL.SLASH 0-dlist,
			    OPT - ] > ].

month_word := norm_no_affix_word &
  [ SYNSEM month_of_year_synsem ].

month_year_word := norm_no_affix_word &
  [ SYNSEM month_no_of_year_synsem ].

year_word := np_word_no_quant &
  [ SYNSEM.LOCAL.CONT.KEY yofc_rel ].

; 'the first', 'October first', 'the first of October'
; Need to find way to block '*October first of October'

dom_synsem := temp_noun_ppcomp_synsem &
  [ LOCAL [ CAT [ HEAD.PRD +,
		  VAL [ SPR < [ LOCAL.CONT [ KEY quant_or_wh_rel,
					     ALTKEY mofy_rel &
						 [ INST #inst ] ] ] >,
			COMPS < [ LOCAL.CONT [ KEY _of_rel_s,
					       COMPKEY mofy_rel ],
				  NON-LOCAL.SLASH 0-dlist,
				  OPT + ] > ] ],
	    CONT.LISZT <! dofm_rel &
			  [ INST [ PNG png & [ PN 3sg*,
					       GEN neut* ] ],
			    ARG3 #inst ] !> ] ].


day_of_month_word := norm_word & non_affix_bearing &
  [ SYNSEM dom_synsem ].

; 'Tuesday (the first (of October))', 'Tuesday (October first)'

day_of_week_word := norm_no_affix_word &
  [ SYNSEM nomod_one_arg_with_quant &
	   [ LOCAL [ ARG-S #comps,
                     CAT [ HEAD noun*,
			   VAL [ SPR < >,
				 COMPS #comps &
                                     < [ LOCAL local &
					       [ CAT [ VAL [ SUBJ < >,
							     COMPS *olist*,
							     SPR *olist* ],
						       MC na ],
						 CONT [ INDEX #ind,
							KEY dofm_rel ] ],
					 NON-LOCAL.SLASH 0-dlist,
					 OPT + ] > ] ],
                     AGR #ind,
		     CONT [ INDEX #ind,
			    KEY dofw_rel & #key &
				[ HANDEL #nhand,
				  INST #ind &
				       [ PNG png & [ PN 3sg*,
						     GEN neut* ] ] ],
			    ALTKEY #altkey &
				   def_np_rel &
				     [ BV #ind,
				       RESTR #nhand ],
			    LISZT <! #key, #altkey !> ] ] ] ].

; 'morning' of 'each morning', 'Tuesday morning'
day_part_word := norm_no_affix_word &
  [ SYNSEM temp_mod_two_arg_synsem &
	   [ LOCAL [ ARG-S < #spr . #comps >,
                     CAT [ HEAD noun*,
			   VAL 
			    [ SPR < synsem & #spr &
				  [ LOCAL local &
					  [ CAT [ HEAD det,
						  VAL [ SUBJ < >,
							COMPS *olist* ] ],
					    CONT [ KEY quant_or_wh_rel &
						       [ BV #ind,
							 RESTR #hand ],
						   ALTKEY dofw_rel &
						       [ INST #dinst ] ] ],
				    OPT - ] >,
			      COMPS #comps &
                                    < [ LOCAL [ CAT.VAL.COMPS < >,
						CONT [ INDEX #dinst,
						       KEY _of_rel_s &
							     [ ARG #ind ],
						       COMPKEY dofm_rel ] ],
					NON-LOCAL.SLASH 0-dlist ] > ] ],
		     AGR #ind,
                     CONT [ TOP #hand,
			    INDEX #ind,
			    KEY #key & day_part_rel &
				[ INST #ind ],
			    LISZT <! #key !> ] ] ] ].

holiday_word := np_sing_word &
  [ SYNSEM.LOCAL.CONT.KEY holiday_rel ].

; 'Advent', 'summer'
season_word := np_sing_word &
  [ SYNSEM.LOCAL.CONT.KEY season_rel ].

; "the morning" etc.

def_day_part_word := norm_no_affix_word &
  [ SYNSEM nomod_onearg_synsem &
	   [ LOCAL [ ARG-S < #spr >,
		     CAT [ HEAD noun*,
			   VAL 
			    [ SPR < synsem & #spr &
				  [ LOCAL local &
					  [ CAT [ HEAD det,
						  VAL [ SUBJ < >,
							COMPS *olist* ] ],
					    CONT [ KEY def_np_rel &
						       [ BV #inst,
							 RESTR #hand ],
						   LISZT <! relation !> ] ],
				    OPT - ] >,
			      COMPS < > ],
			   POSTHEAD + ],
		     AGR #inst,
                     CONT [ TOP #hand,
			    INDEX #inst,
			    KEY def_day_part_rel & #key &
				[ INST #inst ],
			    LISZT <! #key !> ] ] ] ].

; "next week", "last month"
next_last_temp_word := norm_no_affix_word &
  [ SYNSEM temp_mod_synsem &
	   [ LOCAL [ CAT [ HEAD noun* &
				[ POSS - ],
			   VAL [ SPR < [ LOCAL.CONT.KEY degree_rel ] >,
				 COMPS < > ],
			   POSTHEAD + ],
                     AGR #inst,
                     CONT [ TOP #nhand,
			    INDEX #inst,
			    KEY temp_abstr_rel & #key &
				[ INST #inst ],
			    ALTKEY #altkey,
			    LISZT <! #key,
				     def_np_rel &
				     [ HANDEL #hand,
				       BV #inst,
				       RESTR #nhand ],
				     next_prev_rel & #altkey &
				     [ HANDEL #nhand,
				       ARG #inst ] !>,
                            H-CONS <! !>,
			    H-STORE <! #hand !> ] ] ] ].

; today, tomorrow
relative_day_word := np_sing_word &
  [ SYNSEM.LOCAL.CONT.KEY reg_nom_rel ].



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Degree specifiers for adjectives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 'very, really, much, a lot, almost'
; Treated as measure phrases, selected as specifiers by adjectives.
; These words do not specify empty HSTORE, since they can get assigned a
; nonempty value when they serve as specifiers of determiners.  All other
; heads taking these as specifiers must specify an empty HSTORE, given our
; treatment of this attribute as a difference list.


basic_degree_spec_word := que_word &
  [ SYNSEM nomod_synsem &
	  [ LOCAL [ CAT [ HEAD adv,
			  VAL [ COMPS < >,
				SPR < [ LOCAL local &
					      [ CAT [ HEAD adv,
						      VAL [ SPR *olist*,
							    COMPS *olist* ] ],
						CONT [ TOP #hand,
						       INDEX #ind,
						       KEY degree_rel &
							   [ HANDEL #khand ] ] ],
					NON-LOCAL.QUE 0-dlist,
					OPT + ] > ] ],
		    CONT [ TOP #hand,
			   INDEX #ind,
			   LISZT.LIST < degree_rel & #key &
					[ HANDEL #khand,
					  DARG #ind & deg-ind ], ... >,
			   KEY #key ] ] ] ].

degree_spec_word := basic_degree_spec_word & nonque & topkey &
  [ SYNSEM nomod_synsem &
           [ LOCAL.CONT [ TOP #hand,
			  KEY.HANDEL #hand,
			  LISZT <! relation !>,
			  H-CONS <! !> ] ] ].

; "how tall"
wh_deg_spec_word := basic_degree_spec_word & 
  [ SYNSEM [ LOCAL.CONT [ KEY.HANDEL #dhand,
			  LISZT <! relation,
				   which_rel & [ HANDEL #hand,
						 RESTR #dhand ] !> ],
	     NON-LOCAL.QUE 1-dlist &
			   [ LIST < #hand > ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Numbers

; For numerals
num_synsem := zero_arg &
	      [ LOCAL [ CAT.HEAD.ORDINAL #ord,
			CONT [ KEY integer_rel & #key &
				      [ I-ORD #ord ],
			       LISZT.LIST < #key, ... >  ] ] ].

int_adj_synsem := lex_synsem & 
  [ LOCAL [ CAT [ HEAD intadj &
		       [ PRD -,
			 MOD < [ LOCAL intersective_mod &
				       [ CAT nbar_cat,
					 CONT.INDEX #index ] ] > ],
		  POSTHEAD - ],
	    CONT [ INDEX #index,
		   KEY integer_rel &
		       [ ARG #index ] ] ] ].

norm_num_synsem := num_synsem & int_adj_synsem &
  [ LOCAL.CAT.HC-LEX + ].

norm_num_word := nontopkey & non_affix_bearing &
  [ SYNSEM norm_num_synsem ].

;; some norm_card-words must remain unspecified for ORDINAL
norm_card_word :< norm_num_word.

;; those cardinals that take no complements may be safely specified as 
;; -ORDINAL, and as plural (since they're normal)

card_only_word:= norm_card_word &
  [ SYNSEM [LOCAL [CAT.HEAD.ORDINAL -,
		   CONT.INDEX.PNG png & [ PN 3pl ] ] ] ].

; should be POSTHEAD -
; These are adjectives only

ord_word := norm_num_word & lex_entry &
  [ SYNSEM.LOCAL.CAT [HEAD.ORDINAL +,
		      VAL.COMPS < > ] ].


;;  Specifiers and modifiers will agree with heads on the value
;; of the head feature ORDINAL -- this allows propagation
;; of such a feature from complements, where (on the current account)
;; the ORDINAL feature gets a value from the lexicon.

;; distribution of ORDINAL:
;;   ordinal lex_entries are ORDINAL +
;;   complement_free lex_entries are ORDINAL -
;;   all lex_entries for "one" are ORDINAL - 
;;   other lex_entries are unspecified for ORDINAL
;; Since (the HEAD feature of) the determiner "one" is outside this 
;; hierarchy, it can't appear as a specifier or complement.


;; The sorts below refer only to lexical entries, so there's presumably no
;; harm in making conventions about the order of the RELs on their LISZTs
;; No particular order is assumed for any phrase containing these entries.

;; It will be hard to do optional complements here and get the LISZTs to
;; come out right.  Another problem with optional complementation is that
;; entries with complements must be -ORD, while their complement-taking
;; counterparts must be underspecified for ORD 
;;   (cf. "twenty" vs. "twenty one" vs. "twenty first")


complement_free_number := norm_num_word & topkey &
			  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

complemented_number := norm_num_word &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD.ORDINAL #ord,
		    VAL.COMPS < [ OPT -,
				  LOCAL [ CAT [ VAL [ SPR *olist*,
						      COMPS < >],
						HEAD intadj & 
						    [ ORDINAL #ord ] ],
					  CONT [ INDEX.PNG #num,
						 KEY.ARG #arg ] ],
				  NON-LOCAL.SLASH 0-dlist ] > ],
	      CONT [ INDEX.PNG #num,
		     LISZT.LIST < relation, plus_rel & #pkey, ... >,
		     KEY.ARG #arg,
		     --TOPKEY #pkey ] ] ] ].
		   

; Non-identity stipulated for handle of SPR and handle of CONT in order to
; prevent the regular head-spec rule (non-head-compositional) from applying.
; Need head-compositional since the handle of the phrase "two hundred" must
; be the handle of the times_rel from the head "hundred" (which contains as
; arguments the other two handles).

specified_number := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < synsem &
			       [ OPT -,
				 LOCAL [ CAT [HEAD intadj & 
						   [ ORDINAL - ],
					      VAL [ COMPS < >,
						    SPR *olist* ] ] ] ] >].
				 
unspecified_num := norm_num_word &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < [ LOCAL local &
					   [ CAT [ HEAD adv,
						   VAL [ SPR  *olist*,
							 COMPS *olist* ] ],
					     CONT [ INDEX #darg,
						    KEY degree_rel &
							[ HANDEL #khand ] ] ],
				     OPT + ] > ],
		   CONT [ KEY [ HANDEL #khand,
				DIM #darg ] ] ] ].


unspecified_num_without_complements := complement_free_number & unspecified_num &
  [ SYNSEM.LOCAL.CONT.LISZT <! const_rel !> ].

unspecified_num_with_complements := complemented_number & unspecified_num &
  [ SYNSEM.LOCAL 
     [ CAT.VAL.COMPS < [ LOCAL.CONT.KEY const_rel & 
					[ HANDEL #chandle ] ] >,
       CONT.LISZT <! const_rel &
		   [ HANDEL #khandle,
		     ARG #arg ],
		   [ ARG #arg,
		     TERM1  #khandle,
		     TERM2  #chandle] !> ] ].

specified_num_without_complements := complement_free_number & specified_number &
  [ SYNSEM.LOCAL 
	[ CAT.VAL.SPR < [ LOCAL.CONT.TOP #shandle ] >,
	  CONT.LISZT <! const_rel & [ HANDEL #khandle],
		        times_rel & [ FACTOR1  #shandle,
				      FACTOR2  #khandle] !> ] ].

specified_num_with_complements := complemented_number & specified_number & 
  [ SYNSEM.LOCAL 
    [ CAT 
       [ VAL [ SPR < [ LOCAL.CONT.TOP #shandle ] >,
	       COMPS < [ LOCAL.CONT.TOP #chandle ] > ] ],
      CONT.LISZT <! [ HANDEL #khandle],
		    [ TERM1  #thandle,
		      TERM2  #chandle],
		    times_rel & [ HANDEL #thandle,
				  FACTOR1 #shandle,
				  FACTOR2 #khandle] !> ] ].

;; the constraints appropriate for all lexical entries for "one"

one_word := nontopkey & non_affix_bearing &
  [ SYNSEM.LOCAL [ CAT [ HEAD intsort & 
			      [ ORDINAL -,
				PRD - ],
			 VAL [ SPR < >,
			       COMPS < >] ],
		   CONT.LISZT <! const_rel & 
			       [ CONST_VALUE "1" ] !> ] ].
			   
