;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  Copyright Daniel Flickinger 1994-1999
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;
;;;  syntax.tdl
;;;
;;;  The grammar rules for English
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$



;;
;;  Phrase structure schemata
;;

; Headed phrases must obey the Head Feature Principle and the Revised Marking
; Principle.  They do not all obey the NLFP with respect to QUE, but it
; appears that all CLAUSE phrases account for QUE on mother and non-head-dtr.
; Hence moved the QUE coreference to NON-CLAUSE.  Headed phrases also identify
; the value of AGR on mother and head daughter, unlike e.g. the coordination 
; schemata which identify HEAD but not AGR.  

headed_phrase := phrase & 
  [ ROOT -,
    SYNSEM.LOCAL [ CAT [ HEAD head & #head,
                         HC-LEX #hclex ],
                   AGR #agr,
		   CONJ #conj,
		   KEYS.KEY #key ],
    HEAD-DTR.SYNSEM.LOCAL local &
		 [ CAT [ HEAD #head,
                         HC-LEX #hclex ],
                   AGR #agr,
		   CONJ #conj,
		   KEYS.KEY #key ] ].

non_headed_phrase := phrase &
  [ ROOT - ].

; Most but not all phrases have SYNSEM phr_synsem; head_complement constructions
; have their SYNSEM type determined by the head-dtr.

phrasal := phrase &
  [ SYNSEM phr_synsem ].

; Head/nexus phrases pass up the REL and QUE values of the head daughter
; (which has amalgamated the REL and QUE values of its arguments a la Ivan's
; relative clause paper) to the mother.  

head_nexus_rel_phrase := headed_phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ].

head_nexus_que_phrase := headed_phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head_nexus_phrase := head_nexus_rel_phrase & head_nexus_que_phrase.

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to that of the head daughter, which has already amalgamated
; the SLASH values of its arguments.  See discussion of head_nexus_phrase for
; treatment of REL and QUE.

head_valence_phrase := head_nexus_phrase &
  [ SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash ].

; All phrases are either unary or binary.

basic_unary_phrase := phrase &
  [ STEM #stem,
    SYNSEM.LOCAL.CONT [ LISZT *diff-list* &
			      [ LIST #first,
				LAST #last ],
			H-CONS *diff-list* &
			      [ LIST #scfirst,
				LAST #sclast ] ],
    C-CONT [ LISZT [ LIST #middle,
		     LAST #last ],
	     H-CONS [ LIST #scmiddle,
		      LAST #sclast ] ],
    ARGS < sign & [ STEM #stem,
                    SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle ] ] ],
                    ROOT - ] > ].

unary_phrase := basic_unary_phrase &
  [ INFLECTED +,
    POSSCL #posscl,
    ARGS < [ INFLECTED +,
             POSSCL #posscl,
             ROBUST #robust ] >,
    ROBUST #robust ].

; DPF 12-Oct-01 - [POSSCL -] forces possessive clitic to the right periphery
; of any phrase (oe's fine idea for implementing the right-periphery constraint
; presented with LP constraints in Gazdar, Flickinger, Daeleman 198?).

basic_binary_phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ LISZT *diff-list* &
			      [ LIST #first,
				LAST #last ],
			H-CONS *diff-list* &
			      [ LIST #scfirst,
				LAST #sclast ] ],
    C-CONT [ LISZT *diff-list* & 
		   [ LIST #middle2,
		     LAST #last ],
	     H-CONS *diff-list* &
		   [ LIST #scmiddle2,
		     LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle1 ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle1 ] ] ],
                    ROOT -,
                    POSSCL - ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #middle1,
						  LAST #middle2 ],
					  H-CONS *diff-list* &
						[ LIST #scmiddle1,
						  LAST #scmiddle2 ] ] ],
                    ROOT -,
                    POSSCL #posscl ] >,
    POSSCL #posscl ].

binary_phrase := basic_binary_phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED +,
             ROBUST #robust ],
           [ INFLECTED +,
             ROBUST #robust ] >,
    ROBUST #robust ].

basic_binary_headed_phrase := headed_phrase & basic_binary_phrase &
  [ NON-HEAD-DTR sign ].

binary_headed_phrase := basic_binary_headed_phrase & binary_phrase.

binary_rule_left_to_right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary_rule_right_to_left := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head_only := unary_phrase & headed_phrase &
  [ HEAD-DTR #head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head > ].

head_initial := binary_headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil_or_numconj ],
    ARGS < #head, #non-head > ].

basic_head_final := basic_binary_headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #non-head, #head > ].

head_final := basic_head_final & binary_headed_phrase.

; C-CONT is the semantic contribution of the phrase itself.  The handle and
; index of the phrase come from the handle and index of C-CONT (which are
; possibly but not necessarily identified with the handle and index of one of
; the daughters).  The liszt of the phrase is the append of the liszt of
; C-CONT and the liszts of the daughters.

head_compositional := headed_phrase &
  [ C-CONT [ TOP #hand,
	     INDEX #index,
             E-INDEX #event ],
    HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
                                 INDEX #index,
                                 E-INDEX #event ] ].

non_clause := head_nexus_phrase &
  [ SYNSEM.LOCAL [ CAT.MC na,
		   KEYS.MESSAGE 0-dlist ] ].



; ERB (05-10-97) The immediate subtypes of clause are now rel_cl and
; non_rel_clause.  The latter groups together decl, imp, and (wh_)interrog,
; which are similar in that they can't serve as modifiers and have empty REL
; values.  That type used to be (misleadingly) named msg_clause.  The
; remaining constraint (MESSAGE message) has been moved to the type clause
; where it belongs.

; We will need to loosen this to allow nominal clauses (i.e., ACC-ing gerunds)

clause := phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD v_or_g,
			   VAL.COMPS *olist* ],
		     CONJ cnil ],
	     NON-LOCAL.QUE 0-dlist ] ].

mc_phrase := phrase &
  [ SYNSEM [ LOCAL.CAT.MC +,
	     NON-LOCAL [ SLASH 0-dlist,
			 QUE 0-dlist ] ] ].

; The [MC bool] constraint lives here rather than on clause because we want
; to treat relative clauses as clauses, but we need to distinguish them as the
; only clauses which can serve as modifiers.  That is, on the one hand we need
; to distinguish relative clauses from ordinary finite subj_head declaratives, 
; where both have a non-empty MOD value, but only the former can appear in a
; head-modifier phrase; and on the other hand we need to distinguish
; extracted-subject finite clauses from ordinary finite S/NP clauses, since 
; only the latter can be the dtr in a thatless-relative construction.  So the
; head-adjunct rule for nouns says the adjunct must be [MC na], and the 
; thatless_rel rule says the dtr must be [MC +].

non_rel_phrase := head_nexus_rel_phrase &
  [ SYNSEM [ LOCAL.KEYS.MESSAGE 1-dlist &
			  <! message & #msg &
				   [ HANDEL #mhand,
				     SOA #soahand ] !>,
	     NON-LOCAL.REL 0-dlist ],
    HEAD-DTR.SYNSEM [ LOCAL.CONT [ TOP #hdhand,
				   INDEX #ind ],
		      NON-LOCAL [ QUE 0-dlist,
				  REL 0-dlist ] ],
    C-CONT [ TOP #mhand,
	     INDEX #ind,
	     LISZT.LIST < #msg, ... >,
	     H-CONS.LIST < qeq &
                           [ SC-ARG #soahand,
                             OUTSCPD #hdhand ], ... > ] ].

non_rel_clause := non_rel_phrase & clause.

; DPF 26-Jan-01 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.

decl_phrase := non_rel_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD.INV -*,
			 MC bool ],
		   KEYS.MESSAGE 1-dlist &
				<! prpstn_rel !> ],
    C-CONT [ LISZT <! relation !>,
             H-CONS <! qeq !> ] ].

decl := decl_phrase & clause.

; Added [SYNSEM..SPR < >] on imp to preserve intended constraints on modifiers
; which only attach to VP and N-bar.
; DPF 13-May-00 - Added [DTR..SUBJ..CASE acc] to prevent ordinary finite
; verbs from serving as heads, now that we want to be able to later conjoin
; imperatives and finite clauses.
; DPF 13-May-00 - Added [DTR..CONT.INDEX ref-ind] to prevent expl-there.
; DPF 22-Feb-01 - Removed above-mentioned [SPR < >], since we've decided to 
; allow sentence-initial PP-modifiers for WH-questions (see 11-Dec-00 below),
; and we still want to be able to coordinate imperatives and WH-questions, as
; in "Give me that book and what is its title?"
; DPF 20-Oct-01 - Replaced SUBJ < > with *olist* since we were blocking e.g.
; 'Tell me your bank's name and where is it?", and made the HEAD-DTR's SUBJ
; be unexpressed_reg so this cannot have as input an inverted phrase.
; Also replaced INV - with -* for the same example.
; 

imp := non_rel_clause & head_valence_phrase & head_only &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ INV -*,
				VFORM imp_vform*,
				TAM [ TENSE present*,
				      ASPECT no_aspect* ] ],
			 VAL [ SUBJ *olist* & < anti_synsem >,
			       SPR *olist*,
			       COMPS < > ],
			 MC + ],
		   KEYS.MESSAGE 1-dlist &
		       <! imp_rel !> ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verb,
				    MC na,
				    VAL [ SUBJ < unexpressed_reg &
					       [ LOCAL [ CAT.HEAD.CASE acc,
                                                         CONT.INDEX #inst &
                                                         ref-ind & 
							 [ PNG.PN 2per ] ] ] >,
                                          COMPS *olist* ] ] ] ],
    C-CONT [ LISZT <! relation,
                    def_rel & [ RESTR #rhand,
                                BV #inst ],
                    pron_rel & [ HANDEL #prohand,
				 INST #inst & full_ref-ind &
				      [ PRONTYPE zero_pron ] ] !>,
             H-CONS <! qeq, qeq & [ SC-ARG #rhand,
                                    OUTSCPD #prohand ] !> ] ].

; ERB (05-10-97) There is no longer a subtype of interrog for polar questions,
; as a result of streamlining the hcomp family (subordinate polar questions
; didn't inherit from the old ynq type anyway).  So interrog and its sole
; subtype wh_interrog could be collapsed into each other, but it seems clearer
; to have the separate.  I don't know what the effect of losing the constraint
; on SLASH in matrix polar questions will be.

interrog := non_rel_clause & 
  [ SYNSEM [ LOCAL.KEYS.MESSAGE 1-dlist &
				<! int_rel !>,
	     NON-LOCAL.SLASH 0-dlist ],
    C-CONT [ LISZT <! relation !>,
             H-CONS <! qeq !> ] ].

; Restrict NON-HEAD-DTR to be [HEAD subst] to avoid trying non-partitive
; determiner "whose" as filler in filler-head-wh rules.  Assume all
; wh-interrog phrases are [MOOD ind_or_mod_subj].
; DPF 29-Aug-00 - But the above [ HEAD subst ] blocked "How often did kim win",
; so removed it. 

wh_interrog := interrog & binary_headed_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD verbal &
			      [ TAM.MOOD ind_or_mod_subj & strict_sort ] ],
		   KEYS.MESSAGE 1-dlist &
		       <! [ PARAMS <! #que & handle !> ] !> ],
    NON-HEAD-DTR.SYNSEM [ NON-LOCAL.QUE 1-dlist &
					[ LIST < #que & handle > ] ] ].

; This type has subtypes for filler_head.  If we assumed only
; finite subj_head phrases, and explicitly made the relevant filler_head
; phrases be finite (which we do), we wouldn't have to stipulate VFORM here.

wh_interrog_fin := wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD verb & [ VFORM fin* ],
		       VAL.SUBJ *olist*,
		       MC bool ] ].

; DPF (28-Apr-99) Need this construction to get simple yes-no questions like
; "Did Kim fall", while keeping the phrase "did Kim devour" with an empty
; MESSAGE so it can be the head of "What did Kim devour", where this filler-head
; rule introduces the interrogative message.
; DPF 26-Jan-01 - Made HEAD.INV be +* to allow coord of inv and non-inv Ss.
; DPF 13-May-01 - Added [HEAD-DTR..VFORM fin] - was missing.
; DPF 12-Apr-02 - Made SYNSEM..SUBJ re-entrant with HEAD-DTR..SUBJ

yesno_phrase := interrog & head_valence_phrase & head_only &
  [ SYNSEM.LOCAL [ CAT [ HEAD.INV +*,
			 VAL [ SUBJ #subj,
			       SPR #spr,
			       COMPS < > ],
			 MC + ],
                   KEYS.MESSAGE <! #msg !> ],
    C-CONT [ TOP #top,
             LISZT <! #msg &
                      [ HANDEL #top,
                        SOA #soahand ] !>,
             H-CONS <! qeq &
                     [ SC-ARG #soahand,
                       OUTSCPD #dtrhand ] !> ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb & [ VFORM fin ],
				  MC na,
				  VAL [ SUBJ #subj & < anti_synsem >,
                                        SPR #spr & *olist*,
					COMPS *olist* ] ],
                            CONT [ TOP #dtrhand,
                                   INDEX.E.TENSE real_tense ] ] ].


; Since MOD is a head feature, and projections of finite verbs can be relative
; clauses, we introduce the [MOD nbar] property directly on finite verbs, rather
; than in the rel_cl phrase type as before.  Then we have to be sure that finite
; VPs do not appear as postnominal modifiers, and likewise for declarative S's.
; The former is blocked because the head-adjunct rule requires that the adjunct 
; be [SUBJ *olist*].  The latter we block by requiring that the adjunct in a 
; head-adjunct phrase be [MC na], while making declarative head_subj phrases 
; be [MC bool].  Thus relative clauses must also be [MC na].

; DPF 27-May-99 - Avoid making rel_cl a headed_phrase, so it can be marked as
; [PRD +] even though its 'head' daughter is necessarily {PRD -].  Will be
; easier with defaults.

; DPF 15-Apr-00 - Removed REL 0-dlist from rel_cl, so we can distinguish
; relative clauses from other clauses; e.g., to avoid allowing "I am out on t"
; as a (non-strict) root.  

rel_cl := clause &
  [ ROOT -,
    SYNSEM [ LOCAL [ CAT [ HEAD verb &
			      [ VFORM fin_or_inf,
				INV -,
				PRD +,
				TAM.MOOD ind_or_mod_subj & strict_sort,
				MOD < [ LOCAL intersective_mod &
					      [ CONT.INDEX #ind ] ] > ],
			   POSTHEAD +,
			   MC na ],
		     CONT.INDEX #ind,
		     KEYS.MESSAGE 0-dlist,
		     CONJ cnil ] ] ].

; We prevent PP adjunct extraction from feeding thatless_rel rule by requiring
; that the gap be [ MOD < > ], to block "the man kim slept walks." To handle
; "I remember the time Kim fell" maybe we can make the words "time" and
; "place" take an S/PP complement, not treat them as thatless_rels.  Also, 
; to block "*Sandy likes the man walks" and "*Sandy likes the man who thinks 
; went home", we require the S/NP to be [ MC + ], which excludes subject
; extraction for that daughter.

; The dtr is required to be [MC +] in order to block subject-extracted S/NPs
; from being admitted as relative clauses.  This constraint would be removed
; for those dialects which accept examples like "There's a man wants to talk to
; you waiting outside."

; ERB (14-12-97) I am trying to get the non-finite ones to work and to
; have only one type that will make both "The man Kim likes" and "The
; man to talk to" (but not "The man to talk to Sandy".)  The new
; constraints are: on the head-dtr HEAD verb, VFORM fin_or_inf, and
; SUBJ list(pro).  I also need to make to_c_prop HEAD verb and 
; MC +.  The latter is because we want to require MC + of the head-dtr
; to exclude subject extraction as above, adn to exclude that-declaratives
; from being the head-dtr of this cx.  (To avoid a really ugly second
; parse for "The man that Kim likes.")

; ERB (14-12-97) to_c_prop doesn't have to be a verb.  non_wh_rel_cl
; can just say HEAD verbal -- that-decls will be ruled out because they
; are MC -.  To_c_prop has to be MC + anyway because we need the
; MC + on the head-dtr in order to bar subj extractions from this
; cx.

; ERB (19-01-98) MC + moved to appropriate subtype.  See notes below.

; ERB (19-01-98) Part of what's keeping to_c_prop from serving directly
; as a modifier without first building a non_wh_rel is that hadj requires
; SUBJ *olist* and pro_ss is OPT -.  This means that non_wh_rel_cl can't
; copy up the SUBJ requirement.  I don't know what exactly the constraints
; are on the other valence features, so I am just copying them up for now.
; (Previously all of VAL was identified.)
; DPF (21-Apr-98) Make SYNSEM.COMPS be < > on mother and *olist* on daughter.

; DPF (26-05-98) Added [MOD < [ NON-LOCAL.QUE 0-dlist] >] to the mother, to 
; block thatless relatives modifying WH-partitives, as in the unwanted NP 
; "how many books are t"

; DPF (06-Sept-98) Added reg_nom_rel constraint on MOD < [ LOCAL.KEYS.KEY ] >, 
; to avoid infinitival relatives modifying temporal nouns as in "we should 
; meet next week to celebrate".  
; DPF (27-Jan-99) Updated this to non_temp_nom_rel.
; DPF 09-Jan-00 - Added HEAD-DTR..MODIFIED notmod_or_rmod to block 
; adverb-initial relative clauses as in "The book apparently Sandy bought is 
; new"
; DPF 17-Mar-01 - Moved [ MOD..KEY non_temp_nom_rel ] to inf_non_wh_rel_cl rule
; only, since we want phrases like "the day he arrived".
; DPF 20-Mar-01 - Added MOD..MODIFIED notmod_or_lmod to prevent thatless-rels
; from modifying already-modified nominals, especially with a full relative
; clause: *the book that I bought you have is long"
; DPF 26-Mar-01 - But this is too strong, also blocking "the city in Germany I 
; wanted to visit was Berlin".  So instead make reference to new PERIPH value.
; DPF 11-Sept-01 - Added [MOD..SPR synsem] to block e.g. 'there to be arriving'

non_wh_rel_cl := unary_phrase & rel_cl &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				  TAM #tam,
				  AUX #aux,
				  INV #inv,
				  MOD #mod &
				      < [ LOCAL [ KEYS.KEY #mkey,
                                                  CAT.VAL.SPR < synsem >,
						  CONT.INDEX #ind ],
					  NON-LOCAL.QUE 0-dlist,
                                          MODIFIED.PERIPH na_or_- ] > ],
			   VAL [ SUBJ < >,
				 SPR #spr,
				 COMPS < > ] ],
		     KEYS.KEY #key ],
	     NON-LOCAL [ SLASH 0-dlist,
                         REL 1-dlist ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verbal &
					 [ VFORM #vform,
					   TAM #tam,
					   AUX #aux,
					   INV #inv,
					   MOD #mod ],
				    VAL [ SPR #spr,
                                          COMPS *olist* ] ],
			      CONT.TOP #top,
			      CONJ cnil,
			      KEYS [ KEY #key,
                                     MESSAGE 1-dlist ] ],
		      NON-LOCAL [ SLASH 1-dlist &
					[ LIST < [ CAT [ HEAD noun &
							      [ PRD -,
								MOD < > ],   
							 VAL.COMPS < > ],
						   AGR #ind,
						   CONT.INDEX #ind,
						   KEYS.KEY #mkey ] > ],
				  QUE 0-dlist,
				  REL 0-dlist ],
		      MODIFIED notmod_or_rmod & strict_sort ] ] >,
    C-CONT.TOP #top ].


; ERB (19-01-98) As much as it hurts, I don't think it is possible
; to avoid differentiating a inf and fin non_wh_rel_cl.  The facts of
; (Standard American) English seem to be that finite non-wh relatives
; do not allow extraction of the highest subject, but non-finite ones
; do:
;
; (1) Kim likes the book Sandy bought.
; (2) *Kim likes the person buys books.
; (3) Kim found a book to buy for Sandy.
; (4) Kim found a person to buy Sandy a book.
;
; A simple hack involving case won't work, because embedded subjects
; can be extracted in the finite case:
;
; (5) Sandy likes the program Kim thinks works.
;
; Another tack is to treat (3) and (4) above differently, where
; the to in (3) is to_c_prop and the to in (4) is to_c_nonprop.
; The motivation for this is that the former allows a discourse
; PRO interpretation, while the latter doesn't, so it is tempting
; to says that the latter doesn't involve PRO at all.  The idea is
; that to_c_prop builds a non_wh_rel which can then serve as a 
; modifier, while to_c_nonprop has a MOD value to start off with,
; and can be a modifier directly once it builds a hcomp.  To_c_nonprop
; would bind the index of its MOD value to that of its subject.
;
; However, this is unsatisfactory for several reasons.  First, the
; ones like (4), built with to_c_nonprop, have no message for the
; relative.  Second, since MOD is a head feature now, to_c_prop must
; also be MOD < nbar > .  Once this is true, there is no obvious way to
; keep it from serving directly as a modifier without building a
; non_wh_rel. Finally, we run into problems with lexical SLASH
; amalgamation.  Something has to be said about the subject value of
; to_c_nonprop, otherwise it runs the risk of having a non-terminated
; SLASH value.  However, on the one hand, to_c_nonprop is the to of
; raising constructions, so sometimes its SUBJ must be able to be
; canonical_synsem, and on the other, on this analysis, it can also
; head modifiers in which its SUBJ goes unexpressed.  To take care
; of the latter, something must be said in the lexical entry, but
; unexpressed is not compatible with canonical_synsem.
;
; The only other possibility I can see is to let the subject extraction
; apply lower, as in to [like Sandy] in [a person to like Sandy], but
; this requires letting subject extraction apply to base forms, which
; would most likely be a royal mess.
;
; In sum, given the facts of SAE and the rest of the grammar as
; it is, (3) and (4) must be built with the same to.  In (3) there
; is an extracted complement and in (4) there is an extracted 
; subject.  In the case of infinitival non_wh_rels, the grammar
; doesn't care.  In the case of finite ones, it does.

fin_non_wh_rel_cl := non_wh_rel_cl &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD verb &
                                       [ VFORM fin,
                                         MOD < [ LOCAL.CAT nbar_cat ] > ],
                                    VAL.SUBJ < anti_synsem >,
                                    MC + ],
                              CONT.INDEX.E.TENSE real_tense ] ] >,
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ] ].

inf_non_wh_rel_cl := non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.KEYS.KEY non_temp_nom_rel ] >,
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD comp & [ VFORM inf ],
                                  VAL.SUBJ *prolist* ],
			    KEYS.MESSAGE 1-dlist ] ] >,
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ] ].

; The version of the Non-local Feature Principle here assumes that there will
; only be one value on the SLASH list.  To handle multiple gaps, we'll need
; more general set-manipulation functions.  This version also doesn't use a
; distinction between INHERITED and TO-BIND non-local features.  Instead, it
; treats non-local features like valence features.

; ERB (17-10-96) in order to get "Kim knows who to ask" under the current
; hacks (i.e., no PRO), I need a head_filler_phrase that takes something like
; "to ask" (i.e., VFORM in, SUBJ nomp) as its head.  So I am making a
; separate parallel type that will only be inherited by the embedded wh
; nonfinite questions.

; N.B. Since all head_filler constructions inherit from type clause, which
; inherits from head_compositional, this type does not (though it could,
; redundantly).

; Added [ SUBJ *prolist* ] constraint to NON-HEAD-DTR, to ensure termination
; of the QUE and REL attributes now that we're doing lexical threading, and
; PPs (among others) wouldn't otherwise know if they were QUE empty or not.
;
; (DPF 23-Aug-98) But if we make thie SUBJ *prolist*, then we can't get 
; extraction of raising predicates, as in "how does Kim look", since the
; subject of the "how" adjective is identified with that of "look".  Hence
; we move this constraint to the extracted-adjunct rule, since it seems to
; hold true for adjuncts, but not for complements.
; DPF 23-Sept-99 - Made mother be POSTHEAD +, to avoid clauses as prenominal
; modifiers.
; DPF 11-Dec-00 - Removed SPR <> from mother, to allow sentence-initial PP
; modifiers for WH-questions.

basic_head_filler_phrase := basic_binary_phrase & phrasal &
  [ INFLECTED +,
    SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < >,
                                 SPR < anti_synsem > ],
			   POSTHEAD + ],
		     CONJ cnil ],
	     NON-LOCAL.SLASH 0-dlist ],
    ARGS < [ INFLECTED +,
             SYNSEM [ LOCAL #slash & local &
			    [ CAT.VAL [ SUBJ *prolist*,
					COMPS *olist*,
					SPR *olist* ],
			      CTXT.ACTIVATED + ],
		      NON-LOCAL.SLASH 0-dlist ] ],
	   [ INFLECTED +,
             SYNSEM [ LOCAL.CAT [ HEAD verbal & strict_type,
				  VAL.COMPS *olist* ],
		      NON-LOCAL [ SLASH 1-dlist &
					[ LIST [ FIRST #slash,
						 REST < > & #last ],
					  LAST #last ],
				  QUE 0-dlist,
				  REL 0-dlist ] ] ] > ].


head_filler_phrase := basic_head_filler_phrase & basic_head_final &
		      head_nexus_que_phrase.

basic_head_filler_phrase_fin := head_filler_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ *olist* & < anti_synsem >,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ VFORM fin*,
                                              TAM.TENSE real_tense ],
				VAL.SUBJ *olist* ] ].

head_filler_phrase_fin := basic_head_filler_phrase_fin & head_final.

; Was hypo_rel
head_filler_phrase_inf := head_filler_phrase & head_final &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD verbal & [ VFORM inf ],
			    KEYS.MESSAGE 1-dlist &
				     <! prpstn_rel !> ] ].

; N.B. Since all head_subj_phrase constructions inherit from type clause,
; which inherits from head_compositional, this type does not (though it could,
; redundantly).
;
; 1-May-96 (DPF) Restricted head to be verb only, to block spurious parses
; where NP modifed by PP was also analyzed as its subject.
; 12-Jun-96 (RPM) Allow verbal gerunds to head head/subj phrases.
; DPF (28-Apr-99) Added INV - to head-dtr, since most auxiliary verbs are
; underspecified for INV.
;  
; DPF 27-May-99 - Constrained subj to be unslashed, in order to block, e.g.
; "the consultant that kim hired slept fell".
; DPF 23-Sept-99 - Made mother be POSTHEAD +, to avoid clauses as prenominal
; modifiers.
; DPF 26-Jan-01 - Changed HEAD.INV + to HEAD.INV +* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.
; DPF 2-Feb-01 - Changed SPR of mother to *olist*, to allow coordination with
; head-filler phrases which are [ SPR < anti_synsem > ].
; DPF 20-Oct-01 - Changed SUBJ of mother to *olist*, to allow coordination with
; imperatives which are SUBJ *olist* so they can coordinate with interrogs.

head_subj_phrase := head_valence_phrase & head_final &
  [ SYNSEM.LOCAL [ CAT [ HEAD v_or_g & strict_type &
			      [ VFORM fin*,
				PRD -,
                                TAM basic_ind_or_mod_subj_tam ],
			 POSTHEAD +,
			 VAL [ SUBJ *olist* & < anti_synsem >,
			       COMPS < >,
                               SPR #spr ] ],
                   KEYS.ALTKEY #altkey,
		   CONJ cnil ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < #synsem >,
                                        SPR #spr,
                                        COMPS *olist* ],
                                  MC na ],
                            KEYS.ALTKEY #altkey ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical_synsem &
		 [ LOCAL [ CAT [ HEAD subst & [ POSS - ],
				 VAL [ SUBJ *olist*,
				       COMPS *olist*,
				       SPR *olist* ] ] ],
		   NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
			       REL 0-dlist,
			       QUE 0-dlist ] ] ].

; A head/comps phrase is a phrase that combines a head with something selected
; for by the COMPS feature.  Head/comps phrases come in two denominations:
; head/comp phrases and head/marker phrases.  A head/comp phrases is like the
; usual VP rule, and its head (and therefore the whole phrase) must be CONJ
; cnil.  A head/comp phrase is unmarked for MC, but will inherit a MC
; specification from its head daughter.  Head/marker phrases takes the place
; of the P&S94 head/marker rule.  The head must be lexical (i.e., of type
; "word") and CONJ non-cnil. 
;
; DPF 10-Aug-99 - Moved the propagation of ALTKEY from head_marker-phrase up to
; head_comp_or_marker_phrase.

head_comp_or_marker_phrase := head_valence_phrase & head_compositional &
			      head_initial &
  [ SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ MC #mc,
			   VAL [ SUBJ #subj,
				 COMPS #comps,
				 SPR #spr ] ],
		     KEYS [ ALTKEY #altkey,
			    MESSAGE #hmsg ] ] ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ MC #mc,
				  VAL [ SUBJ #subj,
					COMPS < #synsem . #comps >,
					SPR #spr ] ],
                            KEYS [ ALTKEY #altkey,
				   MESSAGE #hmsg ] ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical_synsem,
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ] ].

; ERB (03-10-96) hcomp_nc is no longer marked as non-clause because some of them
; are "clauses" in the sense of having a message (e.g., "Kim wants [to leave]").
; This is actually in need of revision: we are probably going to need to 
; distinguish between to-headed hcomp_ncs which are selected by equi predicates 
; or otherwise have PRO subjects and whether-headed hcomp_ncs on the one hand, 
; and all other instances on the other with a restriction equivalent to SUBJ 
; list(PRO) in order to block "To rain is difficult" etc.  I think this should 
; be possible without resorting to anything like VFORM whether to identify cases
; -- see Ivan's interrogatives paper.

; ERB (05-10-97) In order for one single hcomp rule to build things like "how
; about on Friday", the restriction HEAD subst needs to be removed from this
; rule, or else root-marker needs to inherit from subst.  I am opting for the
; former.

; DPF (25-Aug-98) The head_comp_phrase is not marked POSTHEAD + since we want to
; build "twenty-one" using this rule, but still allow it to serve as a
; prenominal modifier  as in "twenty-one books".  So instead we use the PRED
; feature to distinguish prenominal from postnominal modifiers, and conspire to
; make all PRED - entries have an empty COMPS list.  

head_comp_phrase := head_comp_or_marker_phrase &
  [ SYNSEM [ LOCAL [ CAT.POSTHEAD #ph,
		     CONJ cnil ],
	     LEX #lex ],
    HEAD-DTR [ SYNSEM.LOCAL.CAT [ POSTHEAD #ph,
                                  HC-LEX #lex ] ] ].

head_marker_phrase := head_comp_or_marker_phrase &
  [ SYNSEM [ LOCAL [ CAT.HC-LEX #hclex,
                     CONJ strict-conj ],
	     NON-LOCAL #nonlocal,
	     LEX #lex ],
    HEAD-DTR word_or_lexrule & [ SYNSEM.LOCAL.CONT.TOP #ctop ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HC-LEX #hclex,
                          NON-LOCAL #nonlocal,
                          LEX #lex ],
    C-CONT.TOP #ctop ].

;; DPF 10-Oct-00 - HEAD-DTR.KEYS.ALTKEY needs fixing

head_marker_phrase_event := head_marker_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.KEYS.ALTKEY.R-HANDEL #rhand,
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CONT.TOP #rhand,
                                  KEYS.KEY event_or_degree_or_no_rel ] ] ].
    
head_marker_phrase_nom := head_marker_phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.KEYS.KEY non_event_rel ].

; Skip an optional complement as long as there is still another obligatory
; complement on the list (here assumed to be the second complement, since it's
; hard and perhaps unnecessary to allow the obligatory one to appear in an
; arbitrary position).
; DPF (27-Apr-99) Note that this formulation unfortunately does not get
; "Kim bet Abrams won" with the first two optional complements missing, since
; the rule forces the complement after the omitted one to be expressed.
; DPF 7-Apr-01 - Added MC reentrant with head-dtr's MC value.
; DPF 7-Apr-01 - Removed POSTHEAD + since it prevented pre_S if-clauses.
; DPF 22-May-01 - Instead, pass up POSTHEAD from dtr to mother.
; DPF 18-Dec-01 - Moved ALTKEY identity from this type to the non-noun 
; subtypes, to allow noun-opt-comp to override, in order to prevent n-n-cmpnd
; from feeding that rule, while allowing that rule to feed n-n-cmpnd.
; 

basic_head_opt_comp_phrase := head_valence_phrase & basic_unary_phrase & 
                              head_compositional &
  [ INFLECTED #infl,
    POSSCL #posscl,
    SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
                                 SPEC #spec ],
                           HC-LEX #lex,
                           MC #mc,
                           POSTHEAD #ph ],
                     CONJ cnil,
		     KEYS.MESSAGE #msg ],
             MODIFIED #mod ],
    HEAD-DTR #head & 
           [ INFLECTED #infl,
             POSSCL #posscl,
             SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
					  SPR #spr,
                                          SPEC #spec ],
                                    MC #mc,
                                    HC-LEX #lex,
                                    POSTHEAD #ph ],
                              KEYS.MESSAGE #msg ],
                      MODIFIED #mod ],
             ROBUST #robust ],
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ],
    ARGS < #head >,
    ROBUST #robust ].

non_noun_head_opt_comp_phrase := basic_head_opt_comp_phrase &
  [ SYNSEM.LOCAL.KEYS.ALTKEY #altkey,
    HEAD-DTR.SYNSEM.LOCAL.KEYS.ALTKEY #altkey ].

head_opt_comp_phrase := non_noun_head_opt_comp_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    HEAD-DTR [ INFLECTED +,
               SYNSEM.LOCAL [ CAT.VAL.COMPS 
                                     < unexpressed & [ OPT + ]
                                       . #comps & < expressed_synsem, ... > >,
                              KEYS.KEY event_rel ] ] ].

head_opt_two_comp_phrase := non_noun_head_opt_comp_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    HEAD-DTR [ INFLECTED +,
               SYNSEM.LOCAL [ CAT.VAL.COMPS 
                                < unexpressed & [ OPT + ]
                                  . < unexpressed & [ OPT + ]
                                      . #comps & < expressed_synsem, ... > > >,
                              KEYS.KEY event_rel ] ] ].

; DPF 21-Mar-01 - Removed SPR..KEY quant_or_wh_rel since this blocked pumping
; for partitives, as in "very little arrived"
; Changed HEAD from noun to n_or_p for "worth"
; DPF 18-Dec-01 - Added HEAD-DTR..ALTKEY relation to block noun-noun-compound dtr, to avoid
; spurious ambig for e.g. "book cover"

noun_opt_comp_phrase := basic_head_opt_comp_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS #comps,
             LEX #lex ],
    HEAD-DTR [ SYNSEM [ LOCAL [ CAT 
                                    [ HEAD n_or_p & strict_type,
                                      VAL.COMPS 
                                           < [ OPT +,
                                               NON-LOCAL [ SLASH 0-dlist,
                                                           QUE 0-dlist,
                                                           REL 0-dlist ] ] . #comps >],
                                KEYS.ALTKEY relation ],
                        LEX #lex ] ] ].

; ERB (19-01-98) If to_c_prop can undergo subject extraction (see notes
; near non_wh_rel) then this can't require HEAD v_or_p.  That constraint
; will be moved to extracted_comp_phrase.  Extrasubj will say 
; HEAD verbal.
; DPF 10-Jun-99 Changed SYNSEM..MOOD from indicative to ind_or_mod_subj, since
; we weren't getting "Abrams would have hired Browne"

extracted_arg_phrase := head_valence_phrase & head_only &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.TAM.MOOD ind_or_mod_subj,
			   HC-LEX - ],
		     CONJ cnil ],
	     LEX - ],
    HEAD-DTR.SYNSEM.LOCAL.CONJ cnil ].

; DPF (28-Apr-99) Added identity of MESSAGE for mother and head-dtr, since it
; wasn't being propagated.

; *** We still need special extraction rules for fronting CPs and VPs.

extracted_comp_phrase := extracted_arg_phrase & head_compositional &
  [ SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
				 COMPS #comps ],
			   MC #mc ],
		     KEYS.MESSAGE #msg ],
	     LEX #lex ],
    HEAD-DTR [ SYNSEM 
	       [ LOCAL [ CAT [ HEAD v_or_g_or_p & strict_type,
			       VAL [ SUBJ #subj,
				     SPR #spr,
				     COMPS < gap &
					     [ LOCAL local &
						     [ CAT.HEAD mobile ],
					       NON-LOCAL.SLASH #slash ]
					     . #comps > ],
			       MC #mc,
			       HC-LEX #lex ],
			 KEYS.MESSAGE #msg ],
		 NON-LOCAL.SLASH #slash ] ],
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ] ].

; Assume only finite clauses have explicit subjects that can be extracted, and
; restrict these to indicative verbs (not subjunctives). 

; ERB (19-01-98) We are assuming that there is subject extraction
; in "just the teacher [to talk to Sandy]" so the VFORM must be 
; loosened here.  See notes near non_wh_rel.  Also, HEAD verbal.
; What's to block whether from undergoing subject extraction?
; (cf. *Sandy Kim knows whether to elect Clinton president.)
; DPF (27-Apr-98) Made HEAD-DTR..HEAD be strict_type to block non-verbal heads
; from unifying (e.g. "red")
; DPF (1-Apr-99) Made mother be SPR < > to block spurious modification by PPs.

extracted_subj_phrase := extracted_arg_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM ind_or_mod_subj_tam,
                       VAL [ SUBJ < >,
                             SPR < >,
			     COMPS < > ],
		       MC - ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verbal & strict_type &
					 [ VFORM fin_or_inf,
					   MOD < synsem_min > ],
				    VAL [ SUBJ < gap &
						 [ LOCAL #local & local &
						    [ CONT.INDEX ref-ind ] ] >,
					  COMPS *olist* ],
				    MC na ],
		      NON-LOCAL.SLASH.LIST < #local > ] ].

extracted_subj_phrase_fin := extracted_subj_phrase & decl &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.VFORM fin*,
                                  VAL.SUBJ < [ LOCAL.CAT.HEAD.CASE nom ] > ],
			    KEYS.MESSAGE 0-dlist ] ].

extracted_subj_phrase_inf := extracted_subj_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.VFORM inf,
			    CONT.TOP #top,
			    KEYS.MESSAGE 1-dlist ],
    C-CONT [ TOP #top,
	     LISZT <! !>,
	     H-CONS <! !> ] ].


; For specifiers of nouns (det and non-det), adjectives and prepositions.
; Also for specifiers of determiners, as in "almost all".  Needs to be modified
; to also allow "exactly which books".
; DPF 3-Oct-99 - Added rentrancy for hd-dtr's HEAD value and the SPEC..HEAD of
; the non-hd-dtr, to allow e.g. the degree-specifier "that" to appear with
; adverbees but not PPs.
; DPF 10-Feb-01 - Changed mother's ALTKEY to come from head-dtr rather than
; nonhead-dtr, in order to get right semantics for "Kim 's" of "Kim's book".
; Couldn't find the reason (if any) why we were getting it from the nonhead.
; DPF 16-Oct-01 - The reason we need it from the head is compositional 
; numerals, where the ALTKEY of the head contains the 'highest' rel (often 
; times_rel or plus_rel).
; DPF 13-May-01 - Changed HEAD-DTR..COMPS < > back to *olist*, since adj's
; cannot always discharge their optional complement (especially since that
; would mean the pred-copula would have to require its complement to be
; COMPS < >, which means VP's would have to always discharge theirs, which
; would eliminate the utility of the *olist* in general.
; DPF 17-Dec-01 - Made POSTHEAD of mother be determined by specifier dtr,
; in order to get contrast of "*every book very old was sold" and "every book
; less than six months old was sold"

head_spec_phrase := head_valence_phrase & basic_head_final & non_clause & 
                    phrasal &
  [ INFLECTED +,
    SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 COMPS #spcomps,
				 SPR #spr,
				 SPEC #spec ],
			   POSTHEAD #ph ],
		     KEYS.ALTKEY #altkey ],
	     MODIFIED #modif ],
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ LOCAL [ CAT [ HEAD #head,
				    VAL [ SUBJ #subj,
					  COMPS *olist* & #comps,
					  SPR < #synsem & 
						 canonical_synsem . #spr >,
					  SPEC #spec ],
				    MC na ],
			      CONT [ TOP #htop,
				     INDEX #ind,
                                     E-INDEX #event ],
			      CONJ cnil,
			      KEYS [ KEY #key,
                                     ALTKEY #altkey ] ],
		      MODIFIED #hmodif ],
               ROBUST #robust ],
    NON-HEAD-DTR [ SYNSEM #synsem &
	 [ LOCAL [ CAT [ MC na,
                         VAL [ SPEC < [ LOCAL [ CAT [ HEAD #head,
                                                      VAL.COMPS #comps ],
                                                KEYS.KEY #key,
                                                CONT [ TOP #htop,
                                                       INDEX #ind ] ],
                                        MODIFIED #hmodif ] >,
                               COMPS #spcomps ],
                         POSTHEAD #ph ],
                   CONT.TOP #top ],
           MODIFIED #modif ],
                   ROBUST #robust ],
    C-CONT [ TOP #top,
             INDEX #ind,
             E-INDEX #event,
             LISZT <! !>,
	     H-CONS <! !> ],
    ROBUST #robust ].

; The SYNSEM value of the head of a head/modifier phrase is token-identical to
; the MOD value of the adjunct daughter.  Additionally, the adjunct daughter
; must be complement-saturated.  The SLASH value is not set in the basic
; schema, but rather in each of the subtypes: in head_mod_phrase_simple the
; SLASH value is passed up from both daughters, but in the
; extracted_adj_phrase the SLASH value of the mother is effectively the
; adjunct that would have modified the head.
; 
; DPF (6-Sept-98) Constrained HEAD-DTR to have empty QUE as well as REL, to 
; block adverbs modifying "how", "where", etc.  
; DPF (4-Mar-99) But this unfortunately also blocks "which consultant who fell"
; since making "consultant" be QUE empty means via lexical threading that its
; specifier must also be QUE empty.  So we would have to find some other way of
; blocking modifiers of "where" etc, but perhaps the generalization is wrong
; anyway; consider "right where", "exactly when" "just how".

; DPF 25-Aug-99 - Removed CONJ cnil from HEAD-DTR, to allow "oh, and your name"
; DPF 6-Apr-01 - Mysteriously, it seems that we have not been copying up ALTKEY
; from head-dtr to mother for head-mod phrases.  It showed up in failure to 
; notice that "first seven" had a non-empty ALTKEY, which was intended to 
; block this as left member of n-n-compound.

;; DPF 10-Feb-01 - Removed REL 0-dlist from head-dtr, since (a) head-nexus 
;; phrases pass the REL value from the head dtr to the mother; and (b) this 
;; was blocking e.g. "the chair whose first three legs fell off arrived" 
;; where the adj-N construction forces REL 0-dlist rather than passing up the 
;; spr's REL.

head_mod_phrase := head_nexus_phrase &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SUBJ #subj,
                               SPR #spr,
                               COMPS < > ],
                     KEYS.ALTKEY #altkey ],
	     MODIFIED hasmod ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT.VAL [ SUBJ #subj,
                                        SPR #spr,
                                        COMPS *olist* ],
                              CONT.E-INDEX #event,
                              KEYS.ALTKEY #altkey ] ],
    C-CONT.E-INDEX #event ].

; Added restriction on adjunct's specifier to prevent unsaturated nouns
; (like 'afternoon') from serving as modifiers before they pick up their
; specifiers.

; head_mod_phrase_simple takes the MESSAGE value from its non-head dtr's 
; MESSAGE.  Most modifiers identify their message with their
; modifiee's message, but tags don't.  (Modifiers cannot simply identify their
; own message with that of their modifiee, since some signs (like "not")
; can be either a modifier or an argument, and hence need a message value 
; independent of that of their modifiee.

; SLASH of mother is append of SLASH lists for the two daughters.  In principle
; this allows distinct slash values on the two daughters, without enforcing
; parasitic gaps.  So we restrict the LIST.REST value of SLASH on the mother to
; be the empty list -- a hack which works in PAGE since not strictly typed, but 
; what we really want to say is that SLASH on the mother is either a singleton 
; list, or the empty list.

;; 15-Jun-98 Removed this hack, since it doesn't work in the LKB, and is wrong
;; anyway, failing to generalize to e.g. head-complement structures, which
;; present the same problem of distinct SLASH values coming from each of the
;; two daughters.

;; Removed identification of hddtr's MESSAGE with mother's - wrong for tags,
;; at least.  Should be handled independently by each modifier.

;; DPF 26-Feb-99 - Added [ KEY independent_rel] to NON-HEAD-DTR to distinguish
;; modifier phrases from verb-particle constructions, where the particle's
;; KEY is specialized to a subtype of 'selected_rel'.

;; DPF 7-Apr-99 - Moved C-CONT.INDEX to the scopal and intersective variants,
;; since intersectives take their index from the head-dtr, while scopals take
;; it from the non-head-dtr.  The crucial case for intersectives is for
;; participial modifiers of nouns, like "manager interviewing Browne" where
;; the index of the modifier is an event variable.

;; DPF 7-Jun-99 - Removed REL 0-dlist from nonhead, to allow slashed finite
;; rels to keep the REL value on their mother, so it can be distinguished from
;; ordinary clauses.

;; DPF 8-May-00 - MC of the mother is now determined by the modifier dtr, not
;; the head-dtr, in order to make discourse adverbs like "yes" produce MC +
;; phrases. 

;; DPF 10-Feb-01 - Removed REL 0-dlist from mother, since (a) head-nexus 
;; phrases get the REL value from the head dtr; and (b) this was blocking e.g.
;; "the chair whose first three legs fell off arrived" where the adj-N
;; construction forces REL 0-dlist rather than passing up the spr's REL.

basic_head_mod_phrase_simple := head_mod_phrase & binary_headed_phrase &
  [ SYNSEM [ LOCAL [ CAT.MC #mc,
                     KEYS.MESSAGE #msg ],
	     NON-LOCAL [ SLASH *diff-list* &
			       [ LIST #first,
				 LAST #last ] ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                    VAL #val,
                                    POSTHEAD #ph,
                                    HC-LEX #hclex,
                                    MC #hmc ],
                              AGR #agr,
			      CONT [ INDEX #hind,
                                     E-INDEX #eind ],
			      CONJ #conj,
			      KEYS [ KEY #key,
                                     ALTKEY #altkey,
				     MESSAGE #hmsg ] ],
                      NON-LOCAL #nonloc &
			     [ SLASH *diff-list* &
	                              [ LIST #middle,
					LAST #last ] ],
                      MODIFIED #modif ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD head & strict_type &
					     [ MOD < [ LOCAL local & 
						       [ CAT [ HEAD #head,
                                                               VAL #val,
                                                               POSTHEAD #ph,
                                                               HC-LEX #hclex,
                                                               MC #hmc ],
							 AGR #agr,
							 CONT [ INDEX #hind,
                                                                E-INDEX #eind ],
							 CONJ #conj,
							 KEYS 
                                                          [ KEY #key,
                                                            ALTKEY #altkey,
							    MESSAGE #hmsg ] ],
						       NON-LOCAL #nonloc,
                                                       MODIFIED #modif ] > ],
					VAL [ COMPS *olist*,
					      SPR *olist* ],
                                        MC #mc ],
				  CONJ cnil,
				  KEYS [ KEY independent_rel,
					 MESSAGE #msg ] ],
			  NON-LOCAL [ SLASH *diff-list* &
					    [ LIST #first,
					      LAST #middle ],
				      QUE 0-dlist & [ LIST *null* ] ] ],
    C-CONT.LISZT <! !> ].

head_mod_phrase_simple := basic_head_mod_phrase_simple &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.TOP #htop,
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.TOP #htop ] >,
                                CONT.TOP #hand ],
    C-CONT.TOP #hand ].

;; DPF (12-Jul-98) Changed POSTHEAD on mother from that of head-dtr to simply -
;; since want to prevent this rule from feeding head-adj rule.
;; DPF (25-Sept-98) Since we're no longer treating all head-complement phrases
;; as POSTHEAD -, we have to strengthen the constraint on the non-head-dtr's 
;; COMPS value to be truly the empty list, not just *olist*.

adj_head_phrase := basic_head_mod_phrase_simple & head_final &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
	     MODIFIED lmod* & [ PERIPH #periph ],
             LEX #lex ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
                      LEX #lex ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD.PRD -,
				      VAL.COMPS < > ],
			  NON-LOCAL [ SLASH 0-dlist,
				      REL 0-dlist ],
                          MODIFIED.PERIPH #periph ] ].

; ERB (07-11-96) Non-head dtr is QUE 0-dlist to rule out "*Leaving when do you
; think would bother Sandy?" or "*Your house where did the government foreclose
; on?"  Not on higher type because "How long a book did you write?"

head_adj_phrase := basic_head_mod_phrase_simple & head_initial & phrasal &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD +,
	     MODIFIED rmod* ],
    HEAD-DTR.SYNSEM.MODIFIED notmod_or_rmod,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD +,
			  NON-LOCAL.QUE 0-dlist ] ].

; DPF (07-17-98) Split head_adj_phrase and adj_head_phrase into two each,
; one for intersective modifiers and one for scopal modifiers, in order to
; get desired results for recursive modification as in "apparently difficult
; problem" (cf. Kasper '98).  This split is also used in generation, where
; we delay construction of intersective modification, but not scopal.

scopal_mod_phrase := head_mod_phrase_simple &
  [ NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal_mod ] >,
				CONT.INDEX #index ],
    C-CONT [ INDEX #index,
	     H-CONS <! !> ] ].

isect_mod_phrase := head_mod_phrase_simple &
  [ HEAD-DTR.SYNSEM.LOCAL [ CONT [ TOP #hand,
				   INDEX #index ],
			    KEYS.MESSAGE 0-dlist ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
				CONT.TOP #hand ],
    C-CONT [ INDEX #index,
	     H-CONS <! !> ] ].

adj_head_scop_phrase := adj_head_phrase & scopal_mod_phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD - ].
head_adj_scop_phrase := head_adj_phrase & scopal_mod_phrase &
  [ NON-HEAD-DTR.SYNSEM.NON-LOCAL.REL 0-dlist ].
adj_head_int_phrase := adj_head_phrase & isect_mod_phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.TAM.TENSE no_tense,
                                    POSTHEAD - ] ].
head_adj_int_phrase := head_adj_phrase & isect_mod_phrase.

; For "On Tuesday who won" where need S-initial PP rather than extracted PP.

;; DPF 10-Oct-00 - HEAD-DTR.KEYS.KEY needs fixing

adj_head_int_ques_phrase := adj_head_phrase & phrasal &
  [ HEAD-DTR.SYNSEM.LOCAL [ CONT [ TOP #top,
                                   INDEX #index ],
                            KEYS [ KEY.HANDEL #hand,
				   MESSAGE <! int_rel !> ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD prep &
                                       [ TAM.TENSE no_tense,
                                         MOD < [ LOCAL intersective_mod ] > ],
                                        POSTHEAD - ],
                                  CONT.TOP #hand ] ],
    C-CONT [ TOP #top,
             INDEX #index,
	     H-CONS <! !> ] ].

; Further split the head_adj_int_phrase in order to enforce one aspect of the 
; Complex-NP constraint prohibiting extraction from nominal adjuncts.
;
; DPF (27-May-99) Moreover, the nom_adj rule constrains the NON-HEAD-DTR to be 
; PRD +, in order to prevent finite VPs from serving as modifiers.  This was 
; being blocked earlier by pretending that all post-head modifiers had to have
; SUBJ *olist*, but this meant making predicative participles not specify an
; OPT value on their SUBJ - dubious generalization, and besides, it made it
; difficult to get the parse-node labels right, since passive verbs looked
; like S's.
;
; DPF 3-June-99 -- Further constrained nom_adj rule to make the modifier be
; phrasal, to block "Kim met the consultant hired." It's too strong a
; constraint, but we'll revisit the question if we move to making post-nominal
; modifiers attach at NP rather than N.  Among the disadvantages is the fact
; that we can't do "Get him something nice". (But see opt comp for generic-pro)
; DPF 9-Sept-99 - Added [PRD -] to head-dtr to avoid modifiers of e.g. 
; minute-word. 
; - 20-Nov-99: But this also blocked "the eleventh any time after three"
; DPF 15-Apr-00 - Removed [NON-HEAD-DTR..SLASH 0-dlist] since now have
; relative clauses have non-empty REL value.  This means we have to split the 
; nn_adj rule into two, one for relative clauses which are REL 1-dlist and the
; other for reduced relatives which are REL 0-dlist - otherwise we would get 
; "*Kim bought a book by whom?".
; DPF 26-Mar-01 - Added [HEAD-DTR..PERIPH na_or_-] to block e.g. attachment of
; post-nom modifiers to bare proper names and numerals.

n_adj_int_phrase := head_adj_phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD noun*,
                                  VAL.COMPS < > ],
                      MODIFIED.PERIPH na_or_- ],
    NON-HEAD-DTR.SYNSEM phr_synsem & [ LOCAL.CAT [ HEAD.PRD +,
                                                   MC na ],
				       NON-LOCAL.SLASH 0-dlist ] ].

; DPF 26-Mar-01 - Added [SPR..KEY impl_or_expl_quant_rel] to provide basis
; for blocking application of proper_np (non-branching) rule, to avoid e.g.
; "*I saw Abrams I had hired" - cf. "I saw the Abrams I had hired"
; Also added SYNSEM..PERIPH + to provide basis for blocking addition of a
; thatless-rel to the right of a full relative clause.

n_adj_relcl_phrase := n_adj_int_phrase & isect_mod_phrase &
  [ SYNSEM.MODIFIED #modif,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT s_cat_fin_or_inf_unspec,
                          MODIFIED #modif ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR 
                           < [ LOCAL.KEYS.KEY i_or_e_quant_or_deg_rel ] > ].

; DPF 10-Oct-00 - HEAD-DTR.KEYS.KEY needs fixing

n_adj_redrel_phrase := n_adj_int_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL [ CONT [ TOP #htop,
                                   INDEX #index ],
                            KEYS.KEY.HANDEL #hand ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [LOCAL intersective_mod]>,
                                             TAM.TENSE no_tense ],
                                        VAL.SUBJ < unexpressed > ],
                                  CONT.TOP #hand ],
                          NON-LOCAL.REL 0-dlist ],
    C-CONT [ TOP #htop,
             INDEX #index,
	     H-CONS <! !> ] ].

n_adj_redrel_nontemp := n_adj_redrel_phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.KEYS [ KEY nontemp_rel,
                                     ALTKEY nontemp_or_conj_rel ] ].

; Changed ALTKEY from temp_rel to temp_abstr_rel, to allow e.g.
; 'The appointment Tuesday was cancelled'

n_adj_redrel_temp := n_adj_redrel_phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.KEYS [ KEY temp_loc_abstr_rel,
                                     ALTKEY temp_abstr_or_conj_rel ] ].

h_adj_int_phrase := head_adj_int_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adverbee,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD.TAM.TENSE no_tense,
                          NON-LOCAL.REL 0-dlist ] ].

; DPF 15-Nov-01 Split h_adj_int_phrase (for non-nominal heads) into two, one 
; for verbal adjuncts and one for the rest, in order to be able to dis-prefer
; VP modifiers of VPs.

h_adj_i_uns_phrase := h_adj_int_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.KEYS.KEY nonaux_event_rel,
    ARGS.REST.FIRST.SYNSEM.NON-LOCAL.SLASH 0-dlist ].

h_adj_i_uns_aux_phrase := h_adj_int_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.KEYS.KEY aux_event_rel,
    ARGS.REST.FIRST.SYNSEM.NON-LOCAL.SLASH 0-dlist ].


h_v_uns_phrase := h_adj_i_uns_phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb* ].

h_nonv_uns_phrase := h_adj_i_uns_phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD a_or_p_or_adv ].

; DPF 11-May-01 - Split adj_head_int_phrase into two: one for nominal head-dtrs
; and one for non-nominals, parallel to head_adj_phrase split.  Needed at least
; to prevent pre-head adjectives from modifying partitives, to get contrast in
; "any angry at Sally left"  vs "*angry any left" 
; DPF 13-May-01 - Changed SPR..KEY from impl_or_expl_quant_rel to quant_rel in
; order to get "Mr Smith" as adj_n construction which then undergoes proper_np
; rule.
; DPF 13-Mar-02 - HEAD-DTR..PERIPH na_or_- was presumably here to prevent
; adjectives from modifying numerically-modified nouns, as in "*the tall five
; consultants".  But this desire conflicts with that of constraining thatless
; relatives to not follow full relatives - also effected by PERIPH feature.
; So remove constraint here, and expect (statistical?) adjective-ordering
; constraints to get the order of "five" and "tall" right.  Someday.

adj_n_int_phrase := adj_head_int_phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD noun_or_nomger,
                                  VAL [ SPR < [ LOCAL.KEYS.KEY quant_rel ] >,
                                        COMPS < > ] ] ] ].

adj_h_int_phrase := adj_head_int_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adverbee,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD.TAM.TENSE no_tense,
                          NON-LOCAL.REL 0-dlist ] ].

; For now, restrict adjunct extraction to posthead modifiers of VPs (and the
; special case of inverted auxiliary-headed Ss, which still have a non-empty 
; but never realized SUBJ - see discussion of sai_synsem in lextypes.tdl). 
; This will still produce two parses for "Tuesday Kim might dance", but the 
; alternatives (e.g., blocking modification of all auxiliaries except the 
; copula) seem even less attractive.  Also block extraction of adjuncts out of
; subjunctive-verb-headed phrases.

; ERB (12-11-96) This is the exception; the reason I couldn't put the MESSAGE
; stuff on head_mod_phrase.

; DPF (23-Aug-98) Given our splitting up of the head-modifier type into 
; separate subtypes for intersective and scopal modification, we have to do
; the same for extracted adjuncts as well.
; DPF (09-Jan-99) But it is not clear that we ever need to extract scopal
; modifiers, since the ones that are post-head (maybe always adverbs) also seem
; to be available as modifiers of S, and not restricted to POSTHEAD +.  So we'll
; try doing without the scopal variant.
;
; DPF 19-Oct-99 - We used to make the value of SLASH's MOD feature be the
; whole SYNSEM of the HEAD, but this interacted badly with coordination
; of two extracted_adj phrases: it resulted in the CONT features of the
; two conjoined phrases being identified, since coordination enforces
; across-the-board identity of SLASH.  This resulted in circular LISZT
; values, which are undesirable.  So now we identify the values of the
; relevant LOCAL features in SLASH..MOD and in HEAD-DTR, avoiding false
; identity of the LISZT values.  Test case: "Kim arises and arises".
; DPF 2-Feb-01 - Eliminated HEAD-DTR..MOOD strict_sort since it blocked
; "On tuesday Kim arrived and would stay"
; DPF 30-May-01 - Identify MC of head-dtr and extracted adjunct, to avoid
; spurious ambiguity for "For whom does she work"
; DPF 15-Oct-01 - Replaced HEAD-DTR..HEAD..TENSE real_tense with KEY relation,
; since former blocked extraction of adjuncts from complements of e.g. modals,
; and the latter works as intended to block extraction from no_copula VPs.
; DPF 12-Apr-02 - Added HEAD-DTR..SUBJ..INDEX ref-ind to prevent adjunct
; extraction from there-copula sentences - spurious chart ambiguity.

basic_extracted_adj_phrase := head_mod_phrase & head_only & phrasal &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >,
                                  VAL.SUBJ < synsem_min &
                                               [ LOCAL.CONT.INDEX ref-ind,
                                                 NON-LOCAL.SLASH 0-dlist ] > ],
                            KEYS.KEY relation ] ].

extracted_adj_phrase := basic_extracted_adj_phrase &
  [ SYNSEM [ LOCAL [ CAT [ POSTHEAD #ph,
			   MC #mc ],
		     KEYS [ KEY #modkey,
                            MESSAGE #msg ] ],
	     NON-LOCAL.SLASH 1-dlist &
		   [ LIST < [ CAT [ POSTHEAD +,
				    HEAD mobile &
                                        [ TAM.TENSE no_tense,
                                          MOD < [ LOCAL [ CAT [ HEAD #head,
                                                                 VAL #val,
                                                                 POSTHEAD #ph,
                                                                 HC-LEX #hclex,
                                                                 MC #mc ],
                                                           CONT [ TOP #htop,
                                                                INDEX #hind ],
                                                           CONJ #conj,
                                                           KEYS.KEY #modkey,
                                                           CTXT #ctxt ] ] > ],
				    VAL [ SUBJ *prolist*,
                                          COMPS *olist*,
					  SPR *olist* ] ],
			      CONT.TOP #hand,
			      KEYS [ KEY independent_rel,
				     MESSAGE #msg ] ] > ] ],
    HEAD-DTR.SYNSEM canonical_synsem &
	   [ LOCAL local_basic &
		   [ CAT [ HEAD #head & verb &
				[ TAM.MOOD ind_or_mod_subj ],
                           VAL #val,
			   POSTHEAD #ph,
                           HC-LEX #hclex,
                           MC #mc ],
                     CONT [ TOP #htop,
                            INDEX #hind ],
                     CONJ #conj,
                     CTXT #ctxt ],
             NON-LOCAL.SLASH 0-dlist,
	     MODIFIED notmod ],
    C-CONT [ TOP #hand,
	     H-CONS <! !> ] ].

; DPF (1-May-99) Removed identity of SLASH..KEY.HANDEL and HEAD-DTR..KEY.HANDEL
; since this should be redundant for most cases, and is wrong for free relatives
; like "where Kim slept" since in this construction the KEY of the free-rel and
; the KEY of its sister's SLASH must be identified in order to allow "where Kim
; put the book" while blocking "where kim relied".  But this identity means we
; can't have the HANDEL of that SLASH..KEY be the same as the HANDEL of the
; head of this extracted-adj phrase, because that would mean that the HANDEL of
; the ex-adj head's KEY ("slept" in "where she slept" would be wrongly identified
; with the HANDEL of the KEY for "where" (which is 'place_rel').
; DPF 2-Oct-01 - Added to mother [SLASH..INDEX.SORT entity] to make this rule
; be complementary to the extradj_t rule, which is restricted to SORT time.

extracted_adj_int_phrase := extracted_adj_phrase &
  [ SYNSEM.NON-LOCAL.SLASH 1-dlist &
			   <! local &
                            [ CAT.HEAD.MOD < [ LOCAL intersective_mod &
                                                       [ CONT [ INDEX #index,
                                                                E-INDEX #eind ]]]>,
                              CONT [ TOP #hand,
                                     INDEX #index & [ SORT entity ] ] ] !>,
    HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
                                 INDEX individual & #index,
                                 E-INDEX #eind ],
    C-CONT [ INDEX #index,
             LISZT <! !> ] ].

; DPF 14-Jul-01 - Identified MESSAGE of mother with that of head-dtr as well
; as already specified SLASH..MOD..MESSAGE, in order to prevent PPS for
; sentence-initial modification from modifying VPs.  This is only okay as long
; as we continue to not extract scopal modifiers.
; DPF 25-Sep-01 - Removed SLASH unexpr_local since it blocks any filler - how
; was that supposed to work, anyway??
; DPF 2-Oct-01 -  Replaced [VFORM fin] on head-dtr with [VFORM fin_or_bse], to
; allow low attachment of "when can kim arrive"

extracted_adj_temp_phrase := basic_extracted_adj_phrase &
  [ SYNSEM [ LOCAL [ CAT [ POSTHEAD #ph,
                           MC #mc ],
                     KEYS.MESSAGE #msg ],
	     NON-LOCAL.SLASH 1-dlist &
                 <! [ CAT nomp_cat & [ HEAD noun ],
                      CONT [ TOP #hand,
                             INDEX #ind & [ SORT time ] ],
                      KEYS.KEY modable_rel & [ LABEL #label ] ] !> ],
    HEAD-DTR.SYNSEM canonical_synsem &
	   [ LOCAL local_basic &
		   [ CAT [ HEAD verb & [ VFORM fin_or_bse,
                                         TAM.MOOD ind_or_mod_subj ],
                           POSTHEAD #ph,
                           MC #mc ],
                     CONT [ TOP #hand,
                            INDEX #event ],
                     KEYS.MESSAGE #msg ],
             NON-LOCAL.SLASH 0-dlist,
	     MODIFIED notmod ],
    C-CONT [ TOP #hand,
             INDEX #event,
             LISZT <! unspec_loc_rel &
                    [ HANDEL #hand,
                      EVENT.E.TENSE no_tense,
                      LABEL #label,
                      ARG #event & event_or_index,
                      ARG3 #ind ] !>,
	     H-CONS <! !> ] ].


#|
extracted_adj_scop_phrase := extracted_adj_phrase &
  [ SYNSEM.NON-LOCAL.SLASH 1-dlist &
			   <! [ CAT.HEAD.MOD < [ LOCAL scopal_mod ] > ] !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.INDEX individual & #index,
    C-CONT.INDEX #index ].
|#

;;
;; Bare plural and mass NPs, distinguished by the INDEX feature [ DIVISIBLE + ]
;;
; DPF 9-Sept-99 - Changed head-dtr's SPR to be canonical_synsem rather than
; non_canonical.  Don't know why it was that way, but it was allowing e.g. the
; proper noun 'Tuesday' to undergo this rule.
; DPF 17-Mar-01 - Since the choice of bare-np rule is determined by the value
; of DIVISIBLE on the dtr, this needs to be a strict sort; but a bare-np must
; be able to conjoin with another NP of a different DIVISIBLE value, so we
; make these not be headed phrases (which identify AGR on mother and head-dtr).
; DPF 6-Apr-01 - Given that we now pump all optional nominal complements, this
; rule now requires the n-bar dtr to also be COMPS < >.
; DPF 22-May-01 - Instead of making mother nonpronominal_synsem (which 
; incorrectly claims all bare NPs are [LEX +]), make mother's KEY nonpro_rel.
; Then make LEX value propagate from dtr to mother.
; DPF 25-Sep-01 - From 17-Mar: Having broken link for AGR of dtr and mother,

; DPF 10-Oct-00 - ARGS.KEYS.KEY needs fixing
; DPF 20-Nov-01 - Moved identification of MODIFIED down to the non-proper-name
; subtypes, in order to allow "My friend Mister Abrams" as an appositive.
; DPF 25-Nov-01 - Changed dtr's HEAD from noun to noun_or_nomger to allow e.g.
; "Processing of requests is important"

generic_bare_np_phrase := unary_phrase &
  [ SYNSEM synsem &
           [ LOCAL [ CAT [ HEAD #head,
                           HC-LEX #hclex,
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < > ],
                           MC na ],
                     AGR ref-ind &
                         [ PNG #png ],
                     CONJ #conj,
		     KEYS [ KEY #key & nonpro_rel,
                            MESSAGE #msg & 0-dlist,
                            ALTKEY implicit_quant_rel ] ],
             NON-LOCAL #nonloc,
             LEX #lex ],
    ARGS < [ SYNSEM 
             [ LOCAL [ CAT [ HEAD #head & noun_or_nomger,
                             HC-LEX #hclex,
                             VAL [ SUBJ *olist*,
                                   COMPS < >,
                                   SPR < canonical_synsem &
                                         [ OPT -,
                                           LOCAL local &
                                               [ KEYS.KEY #quant ],
                                           NON-LOCAL [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ] ],
                       AGR.PNG #png,
                       CONJ #conj & cnil,
                       CONT [ INDEX #index,
                              E-INDEX #event ],
                       KEYS [ KEY #key & basic_nom_rel & [ HANDEL #nhand ],
                              MESSAGE #msg ] ],
               NON-LOCAL #nonloc & [ SLASH 0-dlist ],
               LEX #lex ] ] >,
    C-CONT [ INDEX #index,
             E-INDEX #event,
             LISZT <! #quant &
                    [ BV #index,
                      RESTR #rhand ] !>,
             H-CONS <! qeq &
		     [ SC-ARG #rhand,
		       OUTSCPD #nhand ] !> ] ].

bare_np_phrase := generic_bare_np_phrase &
  [ SYNSEM [ LOCAL.AGR.DIVISIBLE +*,
             MODIFIED #modif ],
    ARGS < [ SYNSEM [ LOCAL [ AGR.DIVISIBLE +,
                              CAT.VAL.SPR < [ LOCAL.KEYS.KEY udef_rel ] > ],
                      MODIFIED #modif ] ] > ].

; DPF 23-Nov-01 - Added SPR..KEY udef_rel to block num_noun as input.
bare_np_sg_phrase_robust := generic_bare_np_phrase &
  [ SYNSEM [ LOCAL.AGR.DIVISIBLE -*,
             MODIFIED #modif ],
    ARGS < [ SYNSEM [ LOCAL [ AGR.DIVISIBLE -,
                              CAT.VAL.SPR < [ LOCAL.KEYS.KEY udef_rel ] >,
                              KEYS.ALTKEY no_rel ],
                      MODIFIED #modif ],
             POSSCL - ] >,
    ROBUST + ].

; DPF 8-Mar-01 - Removed [MODIFIED notmod_or_lmod] from head-dtr, since it
; prevented "Tuesday at five" as an NP.
; DPF 17-Mar-01 - But then put it back, since we have to block e.g.
; "*I met Abrams you hired".  So will look for another analysis of above.
; DPF 25-Mar-01 - Removed it again, in favor of constraint on SPR in full relcl
; rule which blocks it from feeding this rule.
; DPF 24-Jun-01 - Removed ARGS..DIVISIBLE - since need to identify AGR of
; dtr and mother to get semantics right, and need mother to be DIVISIBLE -*,
; and don't know what that constraint was blocking anyway.
; DPF 10-Apr-02 - Changed ALTKEY from basic_nom_rel to implicit_nom_rel so
; these can appear in np-n compounds like "Kim Browne"

proper_np_phrase := generic_bare_np_phrase &
  [ SYNSEM.LOCAL.AGR #agr & [ DIVISIBLE -* ],
    ARGS < [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ LOCAL.KEYS.KEY def_np_rel ] >,
                              AGR #agr,
                              KEYS [ KEY abstr_named_np_rel,
                                     ALTKEY implicit_quant_rel ] ] ] ] > ].
                      
;; Verbal gerunds with no (possessive) specifier.
;; DPF 12-May-00 Block extraction from gerund NPs.
;; DPF 07-Jan-01 Allow "Me hiring Sandy impressed Kim" as well as "Hiring 
;; Sandy impressed Kim" by removing constraint that head-dtr be SPR < >,
;; but then block spurious analysis for "My hiring Sandy impressed Kim"
;; by requiring the head-dtr to be ALTKEY no_rel (the head-spr rule makes
;; the mother's ALTKEY the quant_rel).  Also, block spurious analysis for
;; "me hiring Sandy impressed kim" (failing to undergo this rule and hence
;; leaving an unbound variable for the gerund_rel), by making this rule's
;; output be MESSAGE 0-dlist, and (in lextypes.tdl and auxverbs.tdl) 
;; requiring that subjects (only ever of finite verbs) be MESSAGE 0-dlist.
;; This means sentential subjects will have to undergo a non-branching
;; rule to make nominative NPs, but this is at least defensible, since we
;; need to get the nominative case from somewhere, to prevent them from
;; appearing as, say, objects of prepositions.
;; DPF 19-Feb-01 - We're getting spurious ambiguity for "Kim prefers sleeping"
;; where both the verbal gerund and the nominal gerund produce an NP.  So let's
;; try blocking the lexical verbal gerunds by making HEAD-DTR a phrase.
;; DPF 23-Apr-01 - But while we are avoiding nominal gerunds of intransitives,
;; we'll undo this block.
;; DPF 30-May-01 - Removed head-dtr's non-empty SUBJ requirement, since we
;; still need to supply a quantifier in the ACC subj constructions like
;; "I resent you leaving early".

bare_vger_phrase := head_only & head_valence_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < >,
				 SPR < >,
                                 COMPS < > ],
			   MC na ],
		     KEYS [ MESSAGE 0-dlist,
			    ALTKEY #altkey ] ] ],
    HEAD-DTR 
         [ SYNSEM 
	   [ LOCAL [ CAT [ HEAD gerund,
			   VAL.COMPS *olist* ],
		     CONJ cnil,
		     CONT [ TOP #hand,
			    INDEX #index & [ DIVISIBLE + ],
                            E-INDEX #event ],
		     KEYS [ KEY gerund_rel,
			    ALTKEY no_rel ] ] ] ],
    C-CONT [ INDEX #index,
             E-INDEX #event,
	     LISZT <! udef_rel & #altkey &
		    [ BV #index,
		      RESTR #rhand ] !>,
	     H-CONS <! qeq &
		     [ SC-ARG #rhand,
		       OUTSCPD #hand ] !> ] ].


; 'That Kim slept bothers sandy"
; 'Whether (or not) Kim slept is not clear to Sandy"

basic_np_cp_phrase := unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MOD < > ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
                           MC na ],
                     AGR.PNG.PN 3sg,
                     CONJ cnil,
                     KEYS [ MESSAGE #msg,
                            KEY #key,
                            ALTKEY #altkey ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
                                           INV -,
                                           TAM.MOOD ind_or_mod_subj ],
                                    VAL.COMPS *olist*,
                                    MC - ],
                              CONJ cnil,
                              CONT.TOP #chand,
                              KEYS.MESSAGE #msg & <! prop_ques_rel !> ],
                      NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ] >,
    C-CONT [ INDEX #index,
	     LISZT <! udef_rel & #altkey &
		    [ BV #index,
		      RESTR #rhand ],
                      nominalize_rel & #key &
                    [ HANDEL #nhand,
                      INST #index,
                      ARG4 #chand ] !>,
             H-CONS <! qeq &
		     [ SC-ARG #rhand,
		       OUTSCPD #nhand ] !> ] ].

np_cp_phrase := basic_np_cp_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD comp & [ CASE #case ] ] > ].

;; DPF 11-Apr-02 -- Why is this rule needed, again?  It produces spurious
;; parses, as in "He thought about what she said."
#|
np_cp_wh_phrase := basic_np_cp_phrase &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD verb,
                            KEYS.MESSAGE <! int_rel !> ] ] > ].
|#

;; 
;; Noun-noun compounds
;;

; Make left member be [ COMPS < > ] to avoid spurious ambiguity since we have
; separate lexical entries to handle optional nominal complements.
; DPF (22-Oct-98) Can't do the above, since it's not true for most nouns, and
; also won't work for "two fifteen meeting" where the am_pm argument is not
; expressed, but can't be discharged by the optcomp rule.

; DPF (4-Mar-99) - Removed the gratuitous some_rel, which was wrong for
; proper name left members of N-N compounds, and also wrong for hour words like
; "a one o'clock meeting" since "one o'clock" already supplied a def_rel of
; its own.
; Added [ ALTKEY no_rel ] to non-head-dtr to block partitives, deverbal nouns,
; and other unwanted NPs with complex lexical semantics.
; DPF 09-Jan-00 - Also added [ ALTKEY no_rel ] to head-dtr, to block adj-nouns
; from compounds, as in "*Devito five" (ignoring for now "the Jackson five").
; 23-Oct-00 - Dropped NONHEAD-DTR's [AGR 3sg] constraint in order to allow
; "auto and mortgage loans", as well as "systems analyst" - the constraint is
; not really AGR 3sg, but perhaps something like lexeme vs. inflected word,
; where the lexeme might be conjoined, or even lexically marked as if it were
; plural, but still not [INFLECTED +].
; DPF 18-Aug-01 - Instead of that failed [AGR 3sg] constraint, made the non-hd
; be [INDEX 3sg], since conjoined nominals do not constrain the INDEX value.
; This lets us get 'auto and mortgage loans' while still blocking 'cats hairs'
; 23-Oct-00 - Changed NONHEAD-DTR's constraint, removing 'pronominal_synsem'
; and instead making the KEY be nonpro_rel, in order to allow conjoined 
; lexical NPs such as "auto and mortgage loans", where the synsem of the phrase
; will not be a subtype of nonpronominal_synsem.
; 17-Nov-00 - Removed 0-dlist specification for head-dtr and mother for
; QUE and REL, since this blocked e.g. "Which state office did he seek"
; DPF 1-Mar-01 - Changed COMPS *olist* to < > on non-head, now that we are 
; pumping nouns with complements.
; DPF 5-Apr-01 - Moved [PERIPH -] from here to the noun-noun subtype, to 
; continue to block "towel rusty rack" but allow "1998 annual report".

basic_n_n_cmpnd_phr := basic_head_final &
  [ INFLECTED +,
    SYNSEM [ LOCAL [ CAT [ VAL #valence,
			   MC #mc ],
		     KEYS.MESSAGE #msg ],
	     NON-LOCAL [ SLASH #slash,
			 QUE #que,
			 REL #rel ] ],
    HEAD-DTR 
     [ INFLECTED +,
       SYNSEM synsem &
	   [ LOCAL [ CAT [ VAL #valence,
			   MC #mc ],
		     CONT [ TOP #top,
			    INDEX #hind & ref-ind,
                            E-INDEX #e-ind ],
		     KEYS [ MESSAGE #msg,
			    KEY nonpro_rel ],
		     CONJ cnil ],
	     NON-LOCAL [ SLASH #slash,
			 QUE #que,
			 REL #rel ],
             MODIFIED notmod_or_lmod ],
       ROBUST #robust ],
    NON-HEAD-DTR 
     [ INFLECTED +,
       SYNSEM 
	   [ LOCAL [ CAT.VAL [ COMPS < >, 
                               SPR *unexplist* ],
		     CONT.INDEX #modind & ref-ind & [ PNG.PN 3sg ],
                     KEYS.KEY nonpro_rel ],
             NON-LOCAL [ SLASH 0-dlist,
			 QUE 0-dlist,
			 REL 0-dlist ] ],
                   ROBUST - ],
    C-CONT [ TOP #top,
	     INDEX #hind,
             E-INDEX #e-ind,
	     LISZT.LIST < unspec_rel & [ HANDEL #top,
					 HINST #hind,
					 NHINST #modind ], ... > ],
    ROBUST #robust ].

n_n_cmpnd_phr := basic_n_n_cmpnd_phr &
  [ SYNSEM lex_synsem &
	   [ LOCAL.CAT.HEAD.MOD < > ],
    HEAD-DTR.SYNSEM 
	   [ LOCAL.CAT [ HEAD noun*,
                         VAL.SPR < synsem & 
                                   [ OPT -,
                                     LOCAL.KEYS.KEY quant_rel ] > ] ] ].

; DPF 22-Mar-01 - It seems we need LEX + on non-head-dtr to block "an exactly 
; seven appointment", since we want "a seven o'clock appointment".  But why did
; we move LEX + down from the n_n_cmpnd_phr in the first place?
; DPF 6-Apr-01 - Added PERIPH na_or_- to head-dtr to block "Browne five 
; dollars" while still allowing "1998 annual report".
; DPF 17-Apr-01 - Added PERIPH na to mother to block NNN-cmpnd for "a reason 
; Kim left"

np_n_cmpnd_phr := n_n_cmpnd_phr &
  [ SYNSEM.MODIFIED.PERIPH na,
    HEAD-DTR.SYNSEM lex_synsem &
                           [ LEX +,
                             MODIFIED.PERIPH na_or_-,
                             LOCAL.KEYS.ALTKEY no_rel ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT.VAL.SPR *unexpnull*,
                                  KEYS [ KEY abstr_named_rel,
                                         ALTKEY implicit_quant_rel ] ],
                          LEX + ],
    C-CONT [ LISZT <! unspec_rel !>,
             H-CONS <! !> ] ].

; 'A two o'clock appointment" - hour-noun's specifier is degree phrase, as in
; 'exactly two o'clock', but block '*an exactly two o'clock appointment'
np_n_cmpnd_phr_2 := n_n_cmpnd_phr &
  [ HEAD-DTR.SYNSEM lex_synsem &
                    [ LEX +,
                      LOCAL.KEYS.ALTKEY no_rel ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT.VAL.SPR *unexpcons* &
                                              < [ OPT + ] >,
                                  KEYS.ALTKEY no_rel ],
                          LEX + ],
    C-CONT [ LISZT <! unspec_rel !>,
	     H-CONS <! !> ] ].

; For "Jim Smith"
; DPF 10-Apr-02 - Changed HEAD-DTR..KEY from named_np_rel to abstr_named_np_rel
; to allow number names, as in "Toshiba 2000" of "Toshiba 2000 laptop".  Also
; removed LEX + from HEAD-DTR for same reason.

np_name_cmpnd_phr := n_n_cmpnd_phr &
  [ SYNSEM [ MODIFIED.PERIPH na,
             LOCAL.KEYS.ALTKEY #altkey ],
    HEAD-DTR.SYNSEM [ LOCAL.KEYS.KEY abstr_named_np_rel,
                      MODIFIED.PERIPH + ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT.VAL.SPR *unexpnull*,
                                  KEYS [ KEY named_np_rel,
                                         ALTKEY #altkey &
                                                implicit_quant_rel ] ],
                          MODIFIED.PERIPH +,
                          LEX + ],
    C-CONT [ LISZT <! unspec_rel !>,
             H-CONS <! !> ] ].

; DPF 24-Sept-01 - Made PERIPH of mother be same as PERIPH of non-hd, to block
; e.g. "*The table important consultant chair arrives".
; DPF 18-Dec-01 - Added ALTKEY no_rel to prevent n_n_compounds from feeing n-optcomp, to
; block spurious ambig for e.g. "book cover"

noun_n_cmpnd_phr := n_n_cmpnd_phr &
  [ SYNSEM [ MODIFIED.PERIPH #periph,
             LOCAL.KEYS.ALTKEY #altkey ],
    HEAD-DTR.SYNSEM lex_synsem & [ MODIFIED.PERIPH -,
                                   LOCAL.KEYS.ALTKEY no_rel & #altkey,
                                   LEX + ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD noun* & [ PRD - ],
                                        VAL.SPR *unexpcons* &
                                             < [ OPT - ] > ],
                                  KEYS.ALTKEY no_rel,
                                  CONT [ TOP #ntop,
                                         INDEX #nind ] ],
                          LEX +,
                          MODIFIED.PERIPH #periph ],
    C-CONT [ LISZT <! unspec_rel, udef_rel & [ BV #nind,
					       RESTR #rhand ] !>,
	     H-CONS <! qeq & [ SC-ARG #rhand,
			       OUTSCPD #ntop ] !> ] ].

; for "account number 222"
noun_title_cmpnd_phr := basic_n_n_cmpnd_phr &
  [ SYNSEM phr_synsem &
           [ LOCAL.CAT.HEAD.MOD #mod ],
    HEAD-DTR.SYNSEM lex_synsem & 
                    [ LOCAL [ CAT [ HEAD adv &
                                         [ MOD #mod & 
                                               < synsem &
                                                 [ LOCAL.CAT nbar_cat ] > ],
                                    VAL.SPR < > ],
                              KEYS.ALTKEY no_rel ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD noun* & [ PRD - ],
                                        VAL.SPR *unexpcons* &
                                             < [ OPT - ] > ],
                                  KEYS.ALTKEY no_rel,
                                  CONT [ TOP #ntop,
                                         INDEX #nind ] ],
                          LEX + ],
    C-CONT [ LISZT <! unspec_rel, udef_rel & [ BV #nind,
					       RESTR #rhand ] !>,
	     H-CONS <! qeq & [ SC-ARG #rhand,
			       OUTSCPD #ntop ] !> ] ].

;; Appositives
;; For now, restrict this to temporal nouns and proper names, since it's an 
;; overly enthusiastic rule.  So only get "Tuesday the tenth" and "Jim Smith"
;; (well, and also "Jim the tenth", but then it's only a hack anyway).
;; Use CASE feature hack on non-head to avoid unwanted "minor" NPs like 
;; minute_word as appositives: "seven thirty"
;; DPF 10-May-00 - In fact, restrict to only proper names, since the date
;; guys already come in via the temp_mod rule.
;; DPF 11-Sept-01 - Restrict head-dtr to be reg_nom_rel (not basic_nom_rel)
;; to exclude deictic pronouns as in "that Kim", and further restrict to
;; explicit_quant_rel so we can allow nonhead-dtr to include numbers as in
;; "the number five" but not "Abrams five".  This means we'll get as an
;; appositive "my friend Kim" but not "Kim my friend".  It means we also
;; block this analysis for "Lee Browne" - probably right.
;; DPF 12-Sept-01 - Restrict head-dtr to be PRD + to rule out free-relatives
;; DPF 18-Oct-01 - Removed [MODIFIED notmod] from HEAD-DTR, since it blocks
;; 'my old friend kim'

;; DPF 10-Oct-00 - HEAD-DTR.KEYS.KEY needs fixing

appos_phr := head_initial &
  [ SYNSEM phr_synsem &
	   [ LOCAL.CAT [ HEAD.PRD #prd,
                         VAL #valence ],
	     NON-LOCAL [ SLASH 0-dlist,
			 QUE 0-dlist,
			 REL 0-dlist ] ],
    HEAD-DTR.SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ HEAD noun & [ PRD #prd & + ],
			   VAL #valence &
			       [ SPR *olist*,
				 COMPS < > ] ],
		     CONT [ TOP #top,
			    INDEX #hind & ref-ind ],
		     KEYS [ KEY reg_nom_rel & [ HANDEL #hand ],
                            ALTKEY explicit_quant_rel ],
		     AGR.PNG.PN #agr,
		     CONJ cnil ],
	     NON-LOCAL [ SLASH 0-dlist,
			 QUE 0-dlist,
			 REL 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ HEAD noun &
                                [ CASE nom ],
			   VAL [ SPR *olist*,
				 COMPS < > ] ],
		     CONT [ TOP #top,
			    INDEX #modind & ref-ind ],
		     KEYS [ KEY apposition_rel,
                            ALTKEY non_conj_rel ],
		     AGR.PNG.PN #agr ],
	     NON-LOCAL [ SLASH 0-dlist,
			 QUE 0-dlist,
			 REL 0-dlist ],
             MODIFIED notmod ],
    C-CONT [ TOP #top,
	     INDEX #hind,
	     LISZT <! unspec_rel & [ HANDEL #hand,
                                     HINST #hind,
                                     NHINST #modind ] !>,
             H-CONS <! !> ] ].

;;
;; Temporal NP modifiers
;;

; DPF 11-Jun-99 - Added SUBJ..OPT - to prevent these temporal NPs from filling
; ordinary NP argument positions.
;
; DPF 26-Jul-99 - Changed [HEAD noun] to [HEAD prep] to avoid double parse
; for "Thursday the fourth" where "the fourth" attaches after "Thursday"
; is itself a temp_mod phrase.
; DPF 9-Sept-99 - Added PRD - to mother, to block temp-mods as complements of
; copula.
; DPF 30-Sept-99 - But this blocks all post-nominal modification with temporal
; NPs, sigh.  Besides, the most natural reading of "The meeting is Tuesday" is
; with the temp-mod reading rather than the identity one.
; DPF 2-Sept-00 - Removed SPR, to avoid spurious analysis for "my mornings 
; look pretty booked tuesdays".  Don't recall why we wanted a SPR on these
; phrases.
; DPF 4-Apr-01 - Added PRD from dtr to prevent e.g. relpro "that" from being 
; the complement of copula, as in "the book that Kim is", while allowing "here
; are the books", which requires temp_mod extraction from locative inversion.
; DPF 17-Jul-01 - Replaced SPR, since we want "leave right now", where the 
; nominal "now" gets pumped to a modifier, and can (only) then take a degree 
; specifier.  It seems the ambiguity of 2-Sept-00 is not spurious, just
; unlikely.
; DPF 25-Sep-01 - Added reentrancy of AGR and SUBJ's INDEX, to get no-copula
; constructions like "Kim in Berlin becoming impatient"
; DPF 2-Apr-02 - Made SUBJ be expressed_synsem rather than synsem, to prevent
; these phrases from appearing as complements of when_subord_prd.

temp_mod_phrase := unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD modnp* &
				[ MOD < [ LOCAL intersective_mod &
					  [ CAT n_or_v_cat & [ MC #mc ],
                                            CONJ cnil,
					    CONT.INDEX #ind,
					    KEYS.MESSAGE 0-dlist ],
                                          NON-LOCAL.REL 0-dlist ] >,
                                  PRD #prd,
                                  TAM #tam ],
			   POSTHEAD +,
			   VAL [ SUBJ < expressed_synsem &
					[ LOCAL [ CAT nomp_cat_min,
						  CONJ cnil,
						  CONT.INDEX #ind ],
					  NON-LOCAL [ SLASH 0-dlist,
						      REL 0-dlist,
						      QUE 0-dlist ],
					  OPT - ] >,
                                 SPR < [ LOCAL local_min &
                                               [ CAT [ HEAD adv,
                                                       VAL.SPR *olist* ],
                                                 CONT.TOP #khand,
                                                 KEYS.KEY degree_rel &
                                                     [ DARG #darg ] ],
                                         NON-LOCAL.QUE 0-dlist,
                                         OPT + ] >,
                                 COMPS #comps ],
			   MC #mc ],
		     CONT.INDEX #ind,
		     CONJ cnil,
                     AGR #ind,
		     KEYS [ KEY unspec_loc_rel & #key & 
				      [ HANDEL #khand,
                                        EVENT #event & [ E #tam ],
                                        LABEL #label,
					ARG #ind & event_or_index,
					ARG3 #index,
                                        DIM #darg ],
                            ALTKEY #argkey,
			    MESSAGE 0-dlist ] ],
	     NON-LOCAL #nonloc & [ REL 0-dlist ] ],
    ROOT -,
    ARGS < [ INFLECTED +,
             SYNSEM [ LOCAL [ CAT [ HEAD noun & [ PRD #prd ],
				    VAL [ SPR *olist*,
					  COMPS #comps & < > ] ],
			      CONT.INDEX #index,
			      CONJ cnil,
			      KEYS.KEY modable_rel & #argkey &
                                  [ LABEL #label ] ],
		      NON-LOCAL #nonloc,
		      MODIFIED hasmod ] ] >,
    C-CONT [ TOP #khand,
             E-INDEX #event,
	     LISZT <! #key !>,
	     H-CONS <! !> ] ].

; DPF 24-Apr-01 - In order to rank "where, when" high as PPs, separate WH from
; non-WH.
temp_mod_nonwh_phrase := temp_mod_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < anti_synsem >,
    ARGS < [ SYNSEM.NON-LOCAL [ SLASH 0-dlist,
                                QUE 0-dlist ] ] > ].

temp_mod_wh_phrase := temp_mod_phrase &
  [ ARGS < [ SYNSEM.NON-LOCAL.QUE 1-dlist ] > ].

; DPF 5-Feb-01 - Restrict mother's SPEC..HEAD value to adj for now, to block
; silly analysis for e.g. "There are a bookcase in the office."
; DPF 22-Apr-01 - Added MODIFIED identification of mother and left daughter to
; distinguish "an inch" from "one inch" as in "I need one inch nails" but not
; "*I need a inch nails".  Corresponds here roughly to left stress.
; DPF 8-Jan-02 - Removed above constraint on SPEC, since this also blocked
; "Kim arrived two days before Sandy".  Instead, prevent most PPs from taking
; measure-NP specifiers.
; DPF 11-Feb-02 - Made INDEX.SORT of phrase be that of right dtr to enable
; blocking of meas-NP analysis of "a laptop" in "Can you get me a laptop before
; Christmas"
; DPF 2-Apr-02 - Changed SPEC..HEAD from a_or_p_or_adv to a_or_p since we don't
; want "ten times competently".  Will need to do something for comparative
; adverbs like "faster" as in "ten times faster".

basic_measure_np_phrase := basic_binary_phrase &
  [ INFLECTED #bool,
    SYNSEM phr_degree_spec_synsem &
           [ LOCAL [ CAT [ HEAD.PRD #prd,
                           VAL.SPEC < synsem &
                                      [ LOCAL [ CAT.HEAD a_or_p & 
                                                         [ PRD #bool ] ] ] > ],
                     CONJ cnil,
                     KEYS.KEY #key,
                     AGR #agr ],
             NON-LOCAL [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ],
             MODIFIED #modif ],
    ROOT -,
    DTR1 [ INFLECTED +,
           SYNSEM [ LOCAL [ CAT [ HEAD intadj & [ PRD #prd ],
                                  VAL [ SPR *olist*,
                                        COMPS < >,
                                        SPEC *olist* ] ],
                            CONT.INDEX #index,
                            KEYS [ KEY const_rel & [ EVENT.E.TENSE no_tense ],
                                   ALTKEY.HANDEL #nhand ],
                            CONJ cnil ],
                    MODIFIED #modif ],
           ROBUST #robust ],
    DTR2 [ INFLECTED #bool,
           SYNSEM lex_synsem &
                     [ LOCAL [ CAT [ HEAD noun,
                                     VAL [ SUBJ < >,
                                           SPR < canonical_synsem &
                                                 [ OPT -,
                                                   LOCAL local &
                                                       [ KEYS.KEY #quant ],
                                                   NON-LOCAL 
                                                       [ SLASH 0-dlist,
                                                         REL 0-dlist,
                                                         QUE 0-dlist ] ] > ] ],
                               CONJ cnil,
                               CONT [ TOP #nhand,
                                      INDEX #index & [ PNG.PN strict_pernum ]],
                               AGR #agr,
                               KEYS [ KEY nonpro_rel,
                                      ALTKEY no_rel,
                                      MESSAGE 0-dlist ] ],
                       NON-LOCAL.SLASH 0-dlist ],
           ROBUST #robust ],
    C-CONT [ LISZT <! #key & deg_rel & [ DIM #index ],
                      udef_rel & #quant &
                      [ BV #index,
                        RESTR #rhand ] !>,
             H-CONS <! qeq &
                     [ SC-ARG #rhand,
                       OUTSCPD #nhand ] !> ],
    ROBUST #robust ].

; DPF 16-May-01 - Cannot have [DTR2..COMPS < >] (as desired to avoid spurious
; parse for "he is ten pounds heavier" where "pound" takes optional pp-of),
; since cannot discharge that optional complement if the noun is uninflected,
; as in "the ten pound heavier guy".  So allow spurious analysis for now.
; DPF 25-Aug-01 - Make DTR2 be COMPS < > to avoid spurious ambiguity for e.g.
; "Kim is two inches tall"

measure_np_phrase := basic_measure_np_phrase &
  [ DTR1 #dtr1,
    DTR2 #dtr2 &
         [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ],
    ARGS < #dtr1, #dtr2 > ].

; For $ 100 (100 dollars) where the head precedes the integer.  
; DPF 16-May-01 - Suggests that the rule for measure_nps should be a 
; non-branching rule.  Especially given the difficulty of pp-of nouns noted 
; just above. But would have to allow "sixty" and "dollar" to combine in
; general, then block most of the time - sigh.  Leave for now.

measure_np_symbol_phrase := basic_measure_np_phrase &
  [ DTR1 #dtr1,
    DTR2 #dtr2 & [ SYNSEM common_noun_numcomp_synsem ],
    ARGS < #dtr2, #dtr1 > ].


; DPF 5-Apr-01 - For "two hundred is enough"
; DPF 13-May-01 - Added [SYNSEM..PERIPH +] to prevent these numbers from
; being modified.
; DPF 31-Oct-01 - But this blocks "order 123 for a chair was cancelled."
; DPF 22-May-01 - Added [LEX -] to prevent these from appearing as left members
; of noun-noun compounds as in "sixty books".

; DPF 10-Oct-00 - ARGS.KEYS.KEY needs fixing

num_noun_phrase := unary_phrase & phrasal &
 [ SYNSEM [ LOCAL [ CAT nbar_cat & 
                        [ HEAD.MOD < >,
                          VAL.SPR < [ LOCAL.KEYS.KEY def_np_rel,
                                      OPT - ] > ],
                    CONT nom-obj &
                        [ TOP #nhand,
                          INDEX #index,
                          H-CONS <! !> ],
                    CONJ cnil,
                    AGR #index & [ PNG.PN 3sg* ],
                    KEYS [ KEY #altkey & named_num_rel & 
                               [ HANDEL #nhand,
                                 INST #index ] ] ],
            NON-LOCAL #nonlocal,
            LEX - ],
   ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD intadj & [ MOD < synsem > ],
                                   VAL.COMPS < > ],
                             CONJ cnil,
                             KEYS [ KEY integer_rel,
                                    ALTKEY #altkey ] ],
                     NON-LOCAL #nonlocal ] ] >,
   C-CONT [ LISZT <! !> ] ].


; Convert "three foot" of "three foot long" to that of "three foot rope"
; adj_synsem_lex_or_phrase &
; DPF 16-May-01 - [ARGS..SPEC..PRD -] to prevent "three years old child"

; DPF 10-Oct-00 ARGS.KEYS.KEY needs fixing

meas_np_adj_phrase := basic_unary_phrase & phrasal &
  [ INFLECTED +,
    POSSCL #posscl,
    SYNSEM adj_synsem_phr &
           [ LOCAL [ CONT [ TOP #hand,
                            INDEX #inst ],
                     KEYS.KEY #key & unspec_adj_rel &
                          [ HANDEL #hand,
                            ARG #inst,
                            DIM #dim ] ],
             NON-LOCAL #nonlocal ],
    ARGS < [ INFLECTED -,
             POSSCL #posscl,
             SYNSEM phr_degree_spec_synsem &
                    [ LOCAL [ CAT [ HEAD.PRD -,
                                    VAL.SPEC < [ LOCAL.CAT.HEAD.PRD - ] > ],
                              KEYS.KEY [ HANDEL #hand,
                                         DARG #dim ] ],
                      NON-LOCAL #nonlocal,
                      MODIFIED.PERIPH na_or_+ ],
             ROBUST #robust ] >,
    C-CONT [ LISZT <! #key !>,
             H-CONS <! !> ],
    ROBUST #robust ].


; DPF 12-Mar-99 - Can't simply identify HEAD of HEAD-DTR with SLASH..HEAD of 
; NON-HEAD-DTR, since these two HEAD values themselves include MOD, which 
; includes SUBJ values, which include CONT, and since the free relative
; combines with an S (not a VP), that SUBJ.CONT of the S/NP is now identified
; with the semantics of the S/NP's subject, but now it's not possible to
; use the free_rel phrase as a VP modifier, because it will eventually want to
; unify that same MOD.SUBJ.CONT with that of the subject of the VP that the
; free_rel modifies, but the LISZT value of that attribute is already bound to 
; the earlier subject's LISZT.
;   So we have each free-rel lexical entry specify the relevant constraints on
; the SLASH of its sister in this construction.
;   The QUE value of the free relatives is a singleton list containing an index
; instead of a handle - this distinguishes free relatives from question words,
; and makes available this index for interpretation at the top of the phrase,
; which may be desirable if there is indeed ambiguity in the meaning of
; examples like "I'll interview whoever's frog wins this race."  (We're not
; doing anything with that index just now, beyond checking for its presence.)
; DPF (1-May-99) Removed identification of HEAD-DTR..KEY and NHD-DTR..SLASH..KEY
; since the slash's KEY is already identified with the main verb's KEY in the
; non-head dtr, for independent reasons.  Don't know what work this was supposed
; to do, anyway.
;
; DPF 10-Jun-99 - Added SUBJ *olist* to head-dtr, to prevent e.g. "one to three".
; DPF 24-Mar-01 - Removed [MODIFIED notmod] from mother, since free-rels need
; to be able to undergo temp_mod_phrase.

; DPF 8-Nov-01 - Made non-hd-dtr be either infinitival or finite in
; order to get "advise me on where to go" as well as "advise me on where I 
; should go"

; DPF 10-Oct-00 - HEAD-DTR.KEYS.KEY needs fixing

free_rel_phrase := head_initial & head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ HEAD n_or_p & strict_type,
			   MC na,
			   VAL [ SUBJ < >,
				 COMPS < >,
				 SPR < > ],
			   POSTHEAD + ],
                     CONJ cnil,
		     KEYS.MESSAGE 0-dlist ],
	     NON-LOCAL [ SLASH 0-dlist,
			 QUE 0-dlist,
			 REL 0-dlist ] ],
    HEAD-DTR.SYNSEM [ LOCAL local_min &
			    [ CAT.VAL [ COMPS < >,
					SPR *olist*,
                                        SUBJ *olist* ],
                              CONT.E-INDEX #ind,
			      KEYS [ KEY #key & relation & [ HANDEL #hand ],
                                     ALTKEY #altkey ] ],
                      NON-LOCAL [ QUE 1-dlist & <! ref-ind !>,
				  SLASH 1-dlist &
				      <! local_min & #loc !> ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal &
					     [ VFORM fin_or_inf,
					       INV - ],
					VAL [ SPR *olist*,
					      COMPS *olist* ] ],
				  CONT.TOP #hand,
				  KEYS.MESSAGE 1-dlist ],
			  NON-LOCAL [ SLASH 1-dlist &
					    <! #loc &
					       [ CAT.VAL [ COMPS *olist*,
							   SPR *olist* ],
                                                 CONT.INDEX #ind,
						 KEYS [ KEY #key,
                                                        ALTKEY #altkey ] ] !>,
                                      QUE 0-dlist,
				      REL 0-dlist ] ],
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ] ].

free_rel_inf_phrase := free_rel_phrase &
  [ NON-HEAD-DTR.SYNSEm.LOCAL.CAT [ HEAD comp & [ VFORM inf ],
                                    VAL.SUBJ < synsem & 
                                               [ NON-LOCAL.SLASH 0-dlist ]>]].

free_rel_fin_phrase := free_rel_phrase &
  [ NON-HEAD-DTR.SYNSEm.LOCAL.CAT [ HEAD verb & [ VFORM fin ],
                                    VAL.SUBJ *olist* ] ].

; For "two hundred twenty remain"
partitive_num_phrase := unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD partn &
                                [ MOD < >,
                                  POSS - ],
			   VAL [ SUBJ < >,
                                 SPR < synsem &
                                       [ LOCAL local_min &
                                               [ CAT.VAL [ SPR  *olist*,
                                                           COMPS *olist* ],
                                                 CONT.TOP #hand,
                                                 KEYS.KEY degree_rel &
                                                         [ DARG #darg ] ],
                                         NON-LOCAL [ QUE 0-dlist,
                                                     REL 0-dlist ],
                                         OPT + ] >,
                                 COMPS < synsem &
                                         [ LOCAL local_min &
                                           [ CAT [ HEAD prep & 
                                                     [ PRD -,
                                                       TAM.TENSE no_tense ],
                                                   VAL.COMPS *olist* ],
                                             CONT [ TOP #nhand,
                                                    INDEX #index ],
                                             KEYS.KEY _of_rel &
                                               [ ARG3 #arg3 ] ],
                                           NON-LOCAL.SLASH 0-dlist,
                                           OPT + ] > ] ],
                     CONT nom-obj,
                     CONJ cnil,
                     AGR #index,
		     KEYS [ KEY #key & part_of_rel & 
                                [ HANDEL #nhand,
                                  INST #index,
                                  ARG3 #arg3 & non_expl-ind ],
                            ALTKEY #altkey & def_explicit_rel &
                                [ BV #index,
                                  RESTR #phand,
                                  DIM #darg],
                            MESSAGE <! !> ] ],
             NON-LOCAL #nonloc & [ REL 0-dlist ] ],
    ROOT -,
    ARGS < [ INFLECTED +,
             SYNSEM basic_norm_num_synsem &
                       [ LOCAL [ CAT.VAL [ SPR *olist*,
                                           SUBJ < >,
                                           COMPS < > ],
                                 CONJ cnil,
                                 CONT.INDEX #index,
                                 KEYS [ ALTKEY.HANDEL #nhand,
                                        KEY.EVENT.E.TENSE no_tense ],
                                 AGR #index ],
                         NON-LOCAL #nonloc ],
             ROBUST #robust ] >,
    C-CONT [ TOP #hand,
             INDEX #index,
	     LISZT <! #key, #altkey !>,
	     H-CONS <! qeq & [ SC-ARG #phand,
                               OUTSCPD #nhand ] !> ],
    ROBUST #robust ].

possessed_np_phrase := basic_unary_phrase & phrasal &
 [ INFLECTED +,
   POSSCL -,
   SYNSEM [ LOCAL [ CAT [ HEAD det & [ POSS +,
                                       MOD < > ],
                          VAL [ SUBJ < >,
                                SPR < >,
                                COMPS < >,
                                SPEC < [ LOCAL.CONT [ TOP #phand,
                                                      INDEX #index ] ] > ] ],
                    CONJ cnil,
                    KEYS [ KEY #key,
                           ALTKEY #altkey ] ],
            NON-LOCAL #nonlocal ],
   ARGS < [ INFLECTED +,
            POSSCL +,
            SYNSEM [ LOCAL [ CAT nomp_cat_min,
                             CONT.INDEX #pindex & individual,
                             KEYS.KEY nonpro_rel,
                             CONJ cnil ],
                     NON-LOCAL #nonlocal ],
            ROBUST #robust ] >,
   C-CONT [ INDEX #index,
            LISZT <! #key & def_rel & [ BV #index,
                                        RESTR #rhand ],
                   #altkey & poss_rel & [ HANDEL #phand,
                                          ARG3 #pindex,
                                          ARG #index ] !>,
            H-CONS <! qeq & [ SC-ARG #rhand,
                              OUTSCPD #phand ] !> ],
   ROBUST #robust ].

; For "the book's is red"
partitive_np_phrase := basic_unary_phrase & phrasal &
 [ INFLECTED +,
   SYNSEM [ LOCAL [ CAT [ HEAD partn &
                               [ MOD < >,
                                 POSS - ],
                          VAL [ SPR < >,
                                SUBJ < >,
                                COMPS < > ] ],
                    KEYS [ KEY #key & generic_nom_rel,
                           ALTKEY #argkey ],
                    AGR #agr,
                    CONT nom-obj & [ INDEX #agr ] ],
            NON-LOCAL #nonloc ],
   ARGS < [ INFLECTED +,
            SYNSEM phr_synsem & 
                  [ LOCAL [ CAT [ HEAD det & [ POSS + ],
                                  VAL [ SPR < >,
                                        COMPS < >,
                                        SPEC < [ LOCAL.CONT 
                                                      [ TOP #phand,
                                                        INDEX #index ] ] > ] ],
                            KEYS [ KEY #argkey,
                                   ALTKEY poss_rel ] ],
                    NON-LOCAL #nonloc ],
            POSSCL #posscl,
            ROBUST - ] >,
   C-CONT [ INDEX #index,
            LISZT <! #key & [ HANDEL #phand,
                              INST #index ] !>,
            H-CONS <! !> ],
   POSSCL #posscl ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Coordinate structures
;;
; To enable coordination of categories that are similar but not identical, we
; introduce intermediate types for some attribute values, including those for
; HEAD, AUX, and AGR.  Lexical items and the phrases they project will have
; these intermediate types as values, while signs that select for a given
; type will usually specify values for the above features using their most
; specific types.  For example, a preposition will be [ HEAD prep* ] but a
; verb which subcategorizes for a PP will specify that its complement must be
; [ HEAD prep ], assuming that HEAD values are of type 'head' organized in a
; type hierarchy as follows (simplified for exposition):
; 	
; 		head
;            /   |   \
; 	verb*  prep*  noun*
;         /  \  /  |  \  /  \
;      verb  v+p  prep p+n   noun
; 
; Most heads will select for a specific value for HEAD, but the copula "be"
; leaves the HEAD value underspecified, requiring only that its complement be
; [ PRD + ], so it will happily take as complement the conjoined phrase
; "in Paris and shopping", where the value of HEAD for this phrase is the
; unification of 'verb*' and 'prep*", namely 'v+p'.  This assumes that the
; constituent coordination schema simply requires that the CAT values of both
; conjuncts unify.
; 
; In a similar manner, the conjunction of two verb phrases, one headed by a
; main verb and one by an auxiliary, will work as long as no other constraints
; are imposed on the attribute AUX for this conjoined phrase.  Here the feature
; AUX is boolean-valued, with the following sort hierarchy for this value type:
; 
; 		bool
; 	 	/   \
;             +*     -*
; 	     /  \   /  \
;  	    +  +_and_-  -
; 
; Then in the sentence "Kim sings and has danced" the VP is [ AUX +_and_- ],
; and since declarative clauses impose no constraint on the value for AUX, the
; sentence is correctly admitted. In contrast, the auxiliary verb "do" requires
; its complement to be [ AUX - ], and since the sort '-' does not unify with
; the sort '+_and_-', the following example is correctly ruled out: 
; "*Kim did sing and have danced".
; 
; Elaborations:
; 
; 1. Since some heads only partially constrain their complements, as with
; "consider" which accepts either an AP or an NP complement, we enrich the
; above hierarchies to include a notion of 'strict' or most specific values,
; so "consider" can restrict its complement to be [ HEAD a_or_n & strict_type ]
; assuming the following more elaborate (though again partial) hierarchy:
; 
;                        head
;              	       /  |   			    
; 		      /   |    strict_type
; 	             /  a_or_n   / /  | 
;                   /       / \_/ /   | 
;                  /       /   /\/    |
;                 prep*   adj*/ /noun*|
;                 |  _\__/_|_/\/  /\  |
;                 | /  \/  |  /\ /  \ |
;                prep p+a  adj a+n  noun
; 
; Here the only consistent values for the complement of "consider" are 'adj'
; or 'noun'.  Of course this isn't quite right, since we thereby exclude the
; coordination "consider Kim a friend and reliable".  What we would need is a
; way of specifying for the complement of "consider" all and only the most
; specific values subsumed by 'a_or_n'.  But at present if a head needs to
; impose partial constraint on an attribute, we cannot also get the kind of
; non-identical coordination we showed for the copula.  Leave for future work.
; 
; 2. We also undergenerate coordination of non-identical phrases in those cases
; where more than one sign imposes constraints on a single attribute.  For
; example, both determiners and verbs can constrain the AGR value of a noun
; phrase, but as soon as one of them does, we are left with a "strict" value,
; which precludes coordination with a non-identical value.  Thus we currently
; get the following incorrect pattern of grammaticality assignments:
; 
; 	a.  Abrams and the consultant
; 	b.  Abrams and the consultants
; 	c.  Abrams and this consultant
; 	d. *Abrams and these consultants
; 
; Example (b) is okay because the determiner "the" does not constrain the AGR
; value of the noun it specifies, so the NP "the consultants" will still be
; (nonstrict) [AGR 3pl*], and hence the conjoined "Abrams and the consultants"
; unifies [AGR 3sg*] and [AGR 3pl*] to give [AGR 3sg+3pl] (assuming a hierarchy
; for AGR analogous to those above for 'head' and 'bool').  Example (d) fails
; because "these" constrains its noun to be (strict) [AGR 3pl], and thus the NP
; "these consultants" will also be [AGR 3pl], and will not coordinate with
; "Abrams" because their CAT values will not unify.
;   We set the KEY of the mother to be that of the right-hand daughter, rather
; arbitrarily, but the KEY needs to be set, since many lexical types select
; an argument based on the KEY value.
;   We also need to set the type of the index on the mother, to match the types
; of the indices on the daughters.  It looks like this will force us to make the
; kind of index a feature, not just a type, but for now we wrongly make the
; index be that of the right-hand daughter.  This does not break subject-verb
; agreement for plural NPs, since we only change INDEX in this hack, not AGR.
;   And we have to make sure that the SCOPE attributes of two conjoined 
; quantified phrases are identified, but not clear how to do this.
;   DPF (27-Apr-99) Both conjuncts have KEY constrained to independent_rel, since
; they may be relations underspecified for use as particles - by doing this, we
; exclude coordination of particles themselves, but this is probably okay.
;   DPF (1-May-99) At present we overgenerate with conjoined propositions because
; we cannot identify the MESSAGE values of the two conjuncts - that would wrongly
; make the SOA values of those two messages be identified. Hence we accept e.g.
; "*I wonder who left and that Sandy arrived".  As long as MESSAGE values are
; typed relations, there doesn't seem to be a way out of this awkwardness.
;   DPF (1-May-99) In the long run, we cannot simply identify the whole local 
; values of SLASH for the two conjuncts, since this would mean that the handles 
; of the two extracted elements would be wrongly identified - wrong at least for
; ordinary complements, which identify their TOP handle with that of their head,
; meaning that in "the book Kim saw and Sandy liked" the handles for "saw" and 
; "liked" would be identified, which is bad since these handles each fill a SOA 
; role in distinct messages.  

; DPF 20-Nov-99 - Made all coord_phr's be LEX - in order to avoid, among other
; things, coordinate structures as right members of noun-noun compounds, as in
; 'the seventeenth, twentieth, or twenty-third'.
; DPF 20-Jun-00 - Made LEX match on both conjuncts, to avoid e.g. "Kim [ had
; Sandy and would ] arise" (with causative "have")  
; DPF 28-Aug-00 - But this will block "Kim and the cat arrived", so removed it.
; DPF 3-Feb-01 - Moved [ CONJ complex-conj ] on right dtr to subtypes, in order
; to let us treat run-on sentences as coordination.
; DPF 22-Mar-01 - Moved AGR.DIVISIBLE reentrancy down to NP coordination, since
; want to allow non-like AGR.DIVISIBLE values for sentence coordination, as in
; "I arrived and consultants left."

basic_coord_phr := binary_phrase & non_headed_phrase & 
  [ SYNSEM [ LOCAL [ CAT #cat,
                     AGR [ DIVISIBLE -*,
                           PNG #png ] ],
             NON-LOCAL #non-local,
	     LEX #lex,
	     MODIFIED #modif ],
    LCONJ-DTR sign & #left &
		[ INFLECTED +,
                  SYNSEM [ LOCAL [ CAT #cat,
				   CONT.INDEX individual,
				   KEYS.KEY independent_rel ],
			   NON-LOCAL #non-local,
			   MODIFIED #modif,
                           LEX #lex ] ],
    RCONJ-DTR phrase & #right &
		[ INFLECTED +,
                  SYNSEM [ LOCAL [ CAT #cat,
				   CONT.INDEX individual,
				   AGR.PNG #png,
                                   KEYS.KEY independent_rel ],
                           NON-LOCAL #non-local,
			   MODIFIED #modif,
                           LEX #lex ] ],
    ARGS < #left, #right > ].

coord_phr := basic_coord_phr &
  [ SYNSEM.LOCAL.KEYS [ KEY #key,
                        MESSAGE #msg ],
    LCONJ-DTR.SYNSEM.LOCAL.KEYS [ KEY #key,
                                  MESSAGE #msg ] ].

; ROOT_GAP_CLAUSE is for elliptical constructions consisting only of an adverb
; and some NP which would be an argument in the elided verb phrase modified by 
; the adverb.  Examples: "not Kim", "maybe Sandy"
; (Note "*Sandy bothered not Kim" but "Who did Sandy bother?  Not Kim.")
;
; Let's see if we can restrict this rule to only admit scopal adverb for MOD-DTR>
; DPF 9-Jun-99 - Changed SYNSEM.HEAD to be 'root-marker' rather than 'verbal'
; since we don't want "so anytime before" as a head-mod phrase.
;
; DPF 27-Jul-99 - Changed MOD-DTR's SUBJ to be unconstrained, since e.g.
; "perhaps" is now an S-modifier, and we need "perhaps on Tuesday".

; DPF 15-Apr-00 - Changed CONJ on nonmod-dtr from cnil to now identified
; with SYNSEM's CONJ, to allow "oh and Sandy".

; Was hypo_rel in C-CONT
root_gap_clause := binary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD no_head &
				[ MOD < > ],
			   VAL [ SUBJ *olist*,
				 SPR *olist*,
				 COMPS *olist* ],
                           HC-LEX -,
			   MC + ],
		     CONT.INDEX event_or_index,
		     CONJ #conj,
		     KEYS [ KEY #key,
			    MESSAGE 1-dlist ] ],
	     NON-LOCAL [ SLASH #slash,
                         REL #rel,
                         QUE 0-dlist ],
	     MODIFIED hasmod ],
    MOD-DTR sign &
      [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL 
                                             [ CAT [ HEAD verb,
                                                     VAL.COMPS *olist* ],
                                               CONT.TOP #mtop ] ] >,
                               VAL.COMPS < >,
                               MC na ],
			 CONT [ TOP #modhand,
				INDEX #mindex ],
			 CONJ cnil,
			 KEYS [ KEY arg_rel & #key,
				MESSAGE 0-dlist ] ],
		 NON-LOCAL [ SLASH 0-dlist,
			     REL 0-dlist,
			     QUE 0-dlist ] ] ],
    NONMOD-DTR sign &
	   [ SYNSEM [ LOCAL [ CAT [ HEAD strict_type & subst &
					 [ PRD - ],
				    MC na,
				    VAL [ SPR *olist*,
					  COMPS *olist* ] ],
                              CONT [ TOP #mtop,
                                     INDEX ref-ind & #ind ],
                              CONJ #conj ],
		      NON-LOCAL [ SLASH 0-dlist & #slash,
                                  REL 0-dlist & #rel ] ] ],
    C-CONT [ TOP #mhand,
	     INDEX #mindex,
	     LISZT <! arg13_rel & [ HANDEL #mtop,
                                    ARG3 #ind ], 
                      prpstn_rel & [ HANDEL #mhand,
                                  SOA #soa ] !>,
	     H-CONS <! qeq & [ SC-ARG #soa,
                               OUTSCPD #modhand ] !> ] ].

root_gap_scopal := root_gap_clause &
  [ MOD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal_mod ] >,
                           KEYS.KEY.ARG #arg ],
    C-CONT.LISZT.LIST.FIRST.HANDEL #arg ].

root_gap_intersect := root_gap_clause &
  [ MOD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
                           KEYS.KEY [ HANDEL #hand,
                                      ARG #arg,
                                      EVENT.E.TENSE no_tense ] ],
    C-CONT.LISZT.LIST.FIRST [ HANDEL #hand,
                              EVENT #arg ] ].

; [SPR..no_rel] prevented attachment of modifiers to no_cop phrases, but
; this incorrectly blocks "rain possible today".
; ARGS..SPR *olist* blocks e.g. "ago" as nocop_vp
; DPF 10-Sep-01 - Changed KEY to be no_rel, to block nocop_vp as root phrase.
; DPF 13-Sep-01 - Removed ROBUST - from dtr, since want "message received"

no_copula_be_phrase := basic_unary_phrase & phrasal &
  [ INFLECTED +,
    SYNSEM [ LOCAL [ CAT [ HEAD verb & [ PRD -,
                                         INV -,
                                         VFORM fin ],
                           VAL [ SUBJ < synsem &
                                        [ LOCAL [ CAT nomp_cat_min &
                                                      [ HEAD.CASE nom ],
                                                  KEYS.MESSAGE 0-dlist ] ] >,
                                 SPR < anti_synsem >,
                                 COMPS < > ],
                           MC na ],
                     CONT [ INDEX #ncind & [ E.TENSE no_tense ],
                            E-INDEX #ncind ],
                     CONJ cnil,
                     KEYS [ KEY no_rel,
                            MESSAGE #msg ] ],
             NON-LOCAL #nonloc & [ SLASH 0-dlist & [ LIST < > ],
                                   REL 0-dlist,
                                   QUE 0-dlist ] ],
    ARGS < [ INFLECTED +,
             SYNSEM [ LOCAL [ CAT [ VAL [ COMPS *olist*,
                                          SPR *olist* ],
                                    MC na ],
                              CONJ cnil,
                              KEYS.MESSAGE #msg  ],
                      NON-LOCAL #nonloc ],
             POSSCL #posscl & - ] >,
    C-CONT [ INDEX.E.TENSE no_tense,
             H-CONS <! !> ],
    POSSCL #posscl ].

no_copula_prd_phrase := no_copula_be_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD no_head,
                                                  MC na_or_- ] ] >,
                         VAL.SUBJ < [ LOCAL #loc,
                                      NON-LOCAL #nonloc ] > ],
                   AGR #agr ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD [ PRD +,
                                         MOD < [ LOCAL.KEYS.KEY event_rel ] >],
                                  VAL.SUBJ < [ LOCAL #loc,
                                               NON-LOCAL #nonloc ] > ],
                            CONT [ TOP #hand,
                                   INDEX non_expl,
                                   E-INDEX event ],
                            AGR #agr,
                            KEYS.KEY.EVENT #event ],
             ROBUST #robust ] >,
    C-CONT [ TOP #hand,
             INDEX #event,
             LISZT <! !> ],
    ROBUST #robust ].

; DPF 21-Nov-01 - Added ROBUST - to dtr, to block bare-sing-nps.

no_copula_id_phrase := no_copula_be_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MOD < anti_synsem >,
                                TAM #tam ],
                         VAL.SUBJ < [ LOCAL [ CAT nomp_cat_min,
                                              CONT.INDEX #id1ind,
                                              AGR #agr ] ] > ],
                   CONT.INDEX.E #tam,
                   AGR #agr ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun,
                                  VAL [ SUBJ < >,
                                        SPR < >,
                                        COMPS < > ] ],
                            CONT.INDEX #id2ind,
                            KEYS [ KEY nonpro_rel,
                                   ALTKEY non_conj_rel ] ],
             ROBUST - ] >,
    C-CONT [ TOP #hand,
             INDEX #event,
             LISZT <! _cop_id_rel &
                    [ HANDEL #hand,
                      EVENT #event & [ E.TENSE no_tense ],
                      ARG1 #id1ind,
                      ARG3 #id2ind ] !> ] ].

; DPF 25-Sept-01 - Changed SPR *olist* to < >, to prevent e.g. PPs from
; attaching to no_cop S rather than to the no_cop VP.

no_copula_nosubj_phrase := non_rel_clause & head_valence_phrase & head_only &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
                           MC + ],
                     KEYS [ KEY #key,
                            MESSAGE 1-dlist &
                                <! prpstn_rel !> ] ],
             NON-LOCAL #nonloc ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verb &
                                         [ MOD < [ LOCAL.CAT.HEAD no_head ] >,
                                           PRD -,
                                           VFORM fin,
                                           TAM.TENSE no_tense ],
                                    VAL [ SUBJ < synsem & [ OPT + ] >,
                                          COMPS < > ],
                                    MC na ],
                              CONJ cnil,
                              KEYS.KEY #key ],
                      NON-LOCAL #nonloc & [ SLASH 0-dlist,
                                            REL 0-dlist,
                                            QUE 0-dlist ] ],
    C-CONT [ LISZT <! relation !>,
             H-CONS <! qeq !> ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Proto-instance types

subjh_rule_decl := binary_rule_right_to_left & head_subj_phrase & decl &
  [ SYNSEM.LOCAL.CAT.MC bool ].

hcomp_rule := binary_rule_left_to_right & head_comp_phrase.

hoptcomp_rule := rule & head_opt_comp_phrase.
hopt2comp_rule := rule & head_opt_two_comp_phrase.
noptcomp_rule := rule & noun_opt_comp_phrase.

hmark_event_rule := binary_rule_left_to_right & head_marker_phrase_event.
hmark_nom_rule := binary_rule_left_to_right & head_marker_phrase_nom.

extracomp_rule := rule & extracted_comp_phrase.

extrasubj_fin_rule := rule & extracted_subj_phrase_fin.
extrasubj_inf_rule := rule & extracted_subj_phrase_inf.

hspec_rule := binary_rule_right_to_left & head_spec_phrase.

adjh_s_rule := binary_rule_left_to_right & adj_head_scop_phrase.
;;adjh_i_rule := binary_rule_left_to_right & adj_head_int_phrase.
adjn_i_rule := binary_rule_left_to_right & adj_n_int_phrase.
adjh_i_rule := binary_rule_left_to_right & adj_h_int_phrase.
adjh_i_ques_rule := binary_rule_left_to_right & adj_head_int_ques_phrase.

hadj_s_rule := binary_rule_right_to_left & head_adj_scop_phrase.
hadj_i_relcl_rule := binary_rule_right_to_left & n_adj_relcl_phrase.
hadj_i_redrel_nontemp_rule := binary_rule_right_to_left & n_adj_redrel_nontemp.
hadj_i_redrel_temp_rule := binary_rule_right_to_left & n_adj_redrel_temp.

hadj_i_h_rule := binary_rule_right_to_left & h_adj_int_phrase.
hadj_i_uns_aux_rule := binary_rule_right_to_left & h_adj_i_uns_aux_phrase.
hadj_v_uns_rule := binary_rule_right_to_left & h_v_uns_phrase.
hadj_nonv_uns_rule := binary_rule_right_to_left & h_nonv_uns_phrase.

extradj_i_rule := rule & extracted_adj_int_phrase.
extradj_temp_rule := rule & extracted_adj_temp_phrase.

;; extradj_s_rule := rule & extracted_adj_scop_phrase.


fin_non_wh_rel_rule := rule & fin_non_wh_rel_cl.

inf_non_wh_rel_rule := rule & inf_non_wh_rel_cl.

; ERB (19-01-98) The single non_wh_rel_rule dream didn't come true.
; non_wh_rel_rule := rule & non_wh_rel_cl.

bare_np_rule := rule & bare_np_phrase.
proper_np_rule := rule & proper_np_phrase.
bare_np_sg_rule_robust := rule & bare_np_sg_phrase_robust.

bare_vger_rule := rule & bare_vger_phrase.

np_n_cmpnd_rule := binary_rule_right_to_left & np_n_cmpnd_phr.
np_n_cmpnd_rule_2 := binary_rule_right_to_left & np_n_cmpnd_phr_2.
np_name_cmpnd_rule := binary_rule_right_to_left & np_name_cmpnd_phr.
noun_n_cmpnd_rule := binary_rule_right_to_left & noun_n_cmpnd_phr.
noun_title_cmpnd_rule := binary_rule_right_to_left & noun_title_cmpnd_phr.
appos_rule := binary_rule_right_to_left & appos_phr.
temp_mod_nonwh_rule := rule & temp_mod_nonwh_phrase .
temp_mod_wh_rule := rule & temp_mod_wh_phrase.
measure_np_rule := rule & measure_np_phrase.
measure_np_symbol_rule := rule & measure_np_symbol_phrase.
num_noun_rule := rule & num_noun_phrase.
meas_np_adj_rule := rule & meas_np_adj_phrase.
np_cp_rule := rule & np_cp_phrase.
;;np_cp_wh_rule := rule & np_cp_wh_phrase.

;; DPF 22-Dec-98 - Modified filler_head_rule_non_wh to require head to be 
;; VFORM fin, in order to block "*Kim hire".  The VFORM used to be fin_or_imp,
;; to allow an extraction analysis of "On Monday hire Kim", but this also
;; allowed a spurious second analysis for "On Monday tell Kim that Sandy left".
;; So a new construction for left dislocation is needed for "On Monday hire Kim",
;; one which would also admit "As for that book, who did it offend?" where a
;; (double) extraction analysis would otherwise be required.

;; DPF 29-Jan-99 - Constrained nonhead_dtr to be HEAD n_or_p, in order to block
;; Yoda examples like "Happy you will be" or "Making a mess you are".  More
;; generally these should simply be dispreferred, but we'll block them for now.
;
; DPF 10-Jun-99 - Note that filler_head_rule_non_wh does not currently inherit 
; from non_rel_clause, but perhaps should.
; 
; DPF 10-Jun-99 - Removed mc_phrase parent from filler_head_rule_non_wh, since
; topicalized constructions can be embedded, as in "Kim thinks on Tuesday we
; should be in Berlin"
; -- DPF 24-Mar-01 - But this is too weak: we still need to block "*I'm sure 
; bananas he likes" - cf. examples with "bet".  So put back mc_phrase, and
; wait for more inspiration about allowing S-initial adjuncts for embedded S's.
; DPF 2-Feb-01 - Generalized HEAD value of nonhead_dtr to include adverbs as
; well as n_or_p, to get "Quietly kim left"
; DPF 2-Apr-01 - Removed INV - from head-dtr to allow "here are my questions"
; DPF 13-May-01 - Added [HEAD-DTR..MODIFIED notmod_or_rmod] to prevent root
; exclamatives like "oh" from modifying the head of the head-filler.
; DPF 25-Sep-01 - From 2-Apr-01: But this overgenerates too much, so putting
; it back in (cf "*There is Kim Sandy")
; DPF 12-Apr-02 - Apparently INV - was put back on head-dtr (see 2-Apr-01) --
; this blocks non-wh PP-fronting for yes-no questions, as in "On Tuesday did
; Kim arrive".  Maybe right not to treat these as unbounded dependencies.

filler_head_rule_non_wh := binary_rule_left_to_right & 
                           basic_head_filler_phrase_fin &
                           head_compositional & mc_phrase &
  [ INFLECTED +,
    SYNSEM.LOCAL.KEYS.MESSAGE #msg,
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ LOCAL [ CAT [ HEAD verbal & strict_type & [ INV - ],
                                      MC + ],
                                KEYS.MESSAGE 1-dlist & #msg ],
                        MODIFIED notmod_or_rmod ],
               ROBUST #robust ],
    NON-HEAD-DTR [ INFLECTED +,
                   SYNSEM [ LOCAL [ CAT.HEAD n_or_p_or_adv & strict_type,
                                    KEYS.MESSAGE 0-dlist ],
                            NON-LOCAL [ QUE 0-dlist,
                                        REL 0-dlist ] ],
                   ROBUST - ],
    C-CONT [ LISZT <! !>,
	     H-CONS <! !> ],
    ROBUST #robust ].
  
; DPF 20-Oct-01 - Changed HEAD.INV + to HEAD.INV +* (and same for AUX) to 
; allow for coordination of inverted and non-inverted sentences.

filler_head_rule_wh_root := binary_rule_left_to_right & 
			    head_filler_phrase_fin & wh_interrog_fin & 
                            mc_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD [ INV +*,
                            AUX +* ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC na ].

;; DPF (21-Apr-98) To block use of fill_head_wh_subj in "Kim knows who Sandy saw"
;; added constraint that filler must be [CASE NOM].
; DPF 15-Oct-01 - Removed [AUX -]: was wrong.
 
filler_head_rule_wh_subj := binary_rule_left_to_right & 
			    head_filler_phrase_fin & wh_interrog_fin & 
			    mc_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.INV -,
    HEAD-DTR.SYNSEM.LOCAL [ CAT.VAL.SUBJ < >,
			    KEYS.MESSAGE 1-dlist ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ CASE nom ] ].

;; DPF (21-Apr-98) Removed constraint making HEAD-DTR [MC -], since this was
;; blocking "Abrams knows who Kim saw."

filler_head_rule_wh_nr_fin := binary_rule_left_to_right & 
			      head_filler_phrase_fin & wh_interrog_fin &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
		       MC - ],
    HEAD-DTR.SYNSEM.LOCAL.KEYS.MESSAGE 1-dlist ].

; DPF 13-Nov-99 - Restricted SUBJ on mother to be 'unexpressed' to prevent
; the subject-extraction rule from applying.
; DPF 13-Nov-99 - Changed [MC na] to [MC -] since e.g. "know" wants an MC -
; complement, as in "kim knows who to hire".
; DPF 26-Mar-01 - Added to head-dtr: SUBJ..SLASH 0-dlist to avoid wrong
; subj-extraction parse for "Kim knew who to approach".

filler_head_rule_wh_nr_inf := binary_rule_left_to_right & 
			      head_filler_phrase_inf & wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
		       VAL.SUBJ < unexpressed >,
		       MC - ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < pro_ss & [ NON-LOCAL.SLASH 0-dlist]>].

; DPF 25-Nov-01 - Added SYNSEM..PERIPH + to enable blocking of thatless-rel
; attaching after WH-relative

filler_head_rule_rel := binary_rule_left_to_right & rel_cl & 
			basic_head_filler_phrase & 
  [ INFLECTED +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				  TAM #tam,
				  AUX #aux,
				  INV #inv,
				  MOD #mod & < [ LOCAL [ KEYS.KEY.HANDEL #rhand,
                                                         CONT.INDEX #ind ] ] > ],
			   VAL.SUBJ *olist* & #subj ],
		     KEYS.KEY #key ],
	     NON-LOCAL.REL 1-dlist,
             MODIFIED.PERIPH + ],
    ARGS < [ INFLECTED +,
             SYNSEM [ LOCAL.CONJ cnil,
		      NON-LOCAL [ QUE 0-dlist,
				  REL 1-dlist &
				      [ LIST < [ TOP #rhand,
                                                 INDEX #ind ] > ] ] ],
             ROBUST #robust ],
	   [ INFLECTED +,
             SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VFORM #vform & fin,
						  TAM #tam,
						  AUX #aux,
						  INV #inv,
						  MOD #mod ],
				    VAL.SUBJ #subj,
				    MC - ],
			      CONJ cnil,
			      KEYS [ KEY #key,
				     MESSAGE 1-dlist &
					 <! [ HANDEL #mhand ] !> ] ],
		      NON-LOCAL [ QUE 0-dlist,
				  REL 0-dlist ] ],
             ROBUST #robust ] >,
    C-CONT [ TOP #mhand,
	     LISZT <! !>,
	     H-CONS <! !> ],
    ROBUST #robust ].

; ERB (05-10-96) This no longer inherits from mc_phrase because it also
; serves to make nonroot phrases, such as the bracketed phrase in: "On Tuesday
; [plan to meet Kim]".

imperative_rule := rule & imp.

yesno_rule := rule & yesno_phrase.

; The top_coord_rule is for building the top of a (potential iterated)
; coordinate structure and the mid_coord_rule is for building intermediate
; parts of an iterated coordinate structure.  The mid_coord_rule (and the
; head/marker schema) collect the handels and indices of the conjuncts under
; the CONJ feature and passes them (with the lexically specified coordination
; relation) up from the right conjunct.  The top_coord_rule uses handels and
; liszts from the CONJ value to build the values for an n-ary coordination 
; relation.  We could skip all this feature passing if we weren't limited by 
; performance considerations to binary trees.  That is, we could build 
; coordinate structures like:					  
;       						  
;       						  
;      coord_phrase					  
;             +-			          -+	  
;             | conj_rel  		           |	  
;      LISZT  | C-HANDELS  [h1], [h2], ..., [hn]   |	  
;             | C-INDICES  [i1], [i2], ..., [in]   |	  
;             +-    		                  -+	  
;             /             /                \ 	 	  
;            /  	   /    	      \  	  
;           /   	  /     	       \ 	  
;          /    	 /      		\ 	  
;         /     	/       		 \ 	  
;      phrase        phrase    	       	       phrase	  
;      TOP   [h1]    TOP   [h2] ...            TOP   [hn]
;      INDEX [i1]    INDEX [i2]                INDEX [in]
;        |             |                	 |  
;        |             |                         |  
;       Kim          Sandy       ...            Lee 
;       			     
; then we could eliminate the features HANDELS and INDICES.  These
; feature are just for bookkeeping.  The feature LEFT, on the other hand, is
; essential to the analysis.  The LEFT value is a list of (up to) two
; elements.  The first element is the required CONJ value of the left conjunct
; in a top_coord_phrase and the second element is the CONJ value of the left
; conjunct in a mid_coord_phrase.  For example, a LEFT value of < either, or >
; permits a coordinate structure like "either Kim or Sandy or Chris or Lee".
                                  
;; DPF 10-Oct-00 - RCONJ..KEYS.ALTKEY needs fixing

top_coord_rule := binary_rule_right_to_left & coord_phr &
  [ ROOT -,
    SYNSEM.LOCAL [ CONT [ INDEX #ind,
                          E-INDEX #event ],
                   CONJ cnil,
                   KEYS.ALTKEY #altkey ],
    LCONJ-DTR.SYNSEM.LOCAL local &
                             [ CONJ conj & #left,
                               CONT.E-INDEX #lind ],
    RCONJ-DTR.SYNSEM.LOCAL local &
                             [ CONT [ TOP #ctop,
                                      INDEX #ind,
                                      E-INDEX #event ],
                               CONJ complex-conj & [ CHEAD.LEFT <#left, ...> ],
                               KEYS.ALTKEY #altkey &
                                    [ L-INDEX #lind ] ],
    C-CONT [ TOP #ctop,
	     INDEX #ind & conj-ind,
	     LISZT <! !>,
	     H-CONS <! !> ] ].

;; DPF 10-Oct-00 - RCONJ..KEYS.ALTKEY needs fixing

mid_coord_rule := binary_rule_right_to_left & coord_phr &
  [ ROOT -,
    SYNSEM.LOCAL [ CONJ phr-conj &
		      [ CHEAD #chead ],
		   KEYS.ALTKEY #altkey ],
    LCONJ-DTR.SYNSEM.LOCAL [ CONJ conj & #left,
                             CONT.E-INDEX #lind ],
    RCONJ-DTR.SYNSEM.LOCAL [ CONT [ TOP #ctop,
                                    INDEX #ind ],
                             KEYS.ALTKEY.L-INDEX #lind,
                             CONJ complex-conj & 
                                  [ CHEAD #chead & 
                                          [ LEFT < *top*, #left > ] ] ],
    C-CONT [ TOP #ctop,
	     INDEX #cind & conj-ind,
	     LISZT <! basic_conj_rel & #altkey &
		      [ C-ARG #cind & non_expl,
			R-INDEX #ind ] !>,
	     H-CONS <! !> ] ].

; Coordination of non-nominal phrases (S's and VPs)
;; DPF 25-Feb-01 - Changed division of labor with these two rules, so the first now
;; conjoins all phrases with event index values, while the second conjoins nominal
;; phrases.

;; DPF 10-Oct-00 - RCONJ..KEYS.ALTKEY needs fixing
;; DPF 21-Aug-01 - Added E-INDEX.E.TENSE real_tense to both dtrs in order to
;; block conjunction of no-copula VPs (want the no-cop after conjunction).

top_coord_event_rule := top_coord_rule &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS *olist*,
                   CONT.INDEX conj_event ],
    LCONJ-DTR.SYNSEM.LOCAL [ CONT.TOP #lhand,
                             CAT.VAL.SPR < [ LOCAL.KEYS.KEY relation ] >,
                             KEYS.KEY event_or_degree_or_no_rel ],
    RCONJ-DTR.SYNSEM.LOCAL.KEYS [ KEY event_or_degree_or_no_rel,
                                  ALTKEY.L-HANDEL #lhand ] ].

mid_coord_event_rule := mid_coord_rule &
  [ SYNSEM.LOCAL.CONT.INDEX conj_event,
    LCONJ-DTR.SYNSEM.LOCAL [ CONT.TOP #lhand,
                             KEYS.KEY event_rel ],
    RCONJ-DTR.SYNSEM.LOCAL.KEYS [ KEY event_rel,
                                  ALTKEY.L-HANDEL #chand ],
    C-CONT.LISZT <! [ HANDEL #chand,
		      R-HANDEL #lhand ] !> ].

; Coordination of all nominals

#|
nom_coord_rule := coord_phr &
  [ SYNSEM synsem &
           [ LOCAL.KEYS [ KEY nom_rel,
                          MESSAGE 0-dlist ] ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                             AGR.DIVISIBLE #div ],
    RCONJ-DTR.SYNSEM.LOCAL.AGR.DIVISIBLE #div ].
|#

nom_coord_rule := coord_phr &
  [ SYNSEM synsem &
           [ LOCAL [ CONT.E-INDEX ref-ind,
                     KEYS.MESSAGE 0-dlist ] ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD n_or_a & strict_type,
                                   VAL.COMPS < > ],
                             CONT.INDEX ref-ind,
                             KEYS.MESSAGE 0-dlist,
                             AGR.DIVISIBLE #div ],
    RCONJ-DTR.SYNSEM.LOCAL [ CONT.INDEX ref-ind,
                             KEYS.MESSAGE 0-dlist,
                             AGR.DIVISIBLE #div ] ].

#|
top_coord_nom_rule := top_coord_rule & nom_coord_rule &
  [ LCONJ-DTR.SYNSEM.LOCAL.KEYS.KEY non_event_rel,
    RCONJ-DTR.SYNSEM.LOCAL.KEYS.KEY non_event_rel ].
|#

top_coord_nom_rule := top_coord_rule & nom_coord_rule.

mid_coord_nom_rule := mid_coord_rule & nom_coord_rule &
  [ LCONJ-DTR.SYNSEM.LOCAL.KEYS.KEY basic_nom_rel,
    RCONJ-DTR.SYNSEM.LOCAL.KEYS.KEY basic_nom_rel,
    C-CONT.INDEX.PNG.PN non1sg ].

; Make mother [ROBUST +]

run_on_s_coord_rule := binary_rule_right_to_left & basic_coord_phr &
  [ SYNSEM.LOCAL [ CAT [ HEAD verbal,
                         VAL.SPR *olist* ],
                   CONT.INDEX.E.TENSE no_tense,
                   CONJ cnil,
                   KEYS [ KEY no_rel,
                          MESSAGE 0-dlist ] ],
    LCONJ-DTR.SYNSEM [ LOCAL local & 
                             [ CAT [ MC +,
                                     HEAD.TAM.MOOD ind_or_mod_subj ],
                               CONT.TOP #lhand,
                               CONJ cnil,
                               KEYS.MESSAGE 1-dlist ],
                       NON-LOCAL.SLASH 0-dlist & [ LIST < > ] ],
    RCONJ-DTR.SYNSEM [ LOCAL local & [ CONT.TOP #rhand,
                                       CONJ cnil,
                                       KEYS.MESSAGE 1-dlist ],
                       NON-LOCAL.SLASH 0-dlist & [ LIST < > ] ],
    C-CONT [ TOP #ctop,
	     INDEX #ind,
	     LISZT <! conj_rel & [ HANDEL #ctop,
                                   C-ARG #ind,
                                   L-HANDEL #lhand,
                                   R-HANDEL #rhand ] !>,
             H-CONS <! !> ],
    ROBUST + ].

; DPF 27-Jul-99 - Removed NONMOD-DTR..HEAD restriction (was n_or_a), since
; we want "perhaps in Berlin" with this rule.
root_gap_rule_premod := binary_rule_left_to_right & root_gap_scopal &
  [ MOD-DTR #left &
	    [ SYNSEM.LOCAL.CAT.POSTHEAD - ],
    NONMOD-DTR #right,
    ARGS < #left, #right > ].

root_gap_rule_postmod_scopal := binary_rule_right_to_left & root_gap_scopal &
  [ MOD-DTR #right &
	    [ SYNSEM.LOCAL.CAT.POSTHEAD + ],
    NONMOD-DTR #left,
    ARGS < #left, #right > ].

root_gap_rule_postmod_intersect := binary_rule_right_to_left & 
                                   root_gap_intersect &
  [ MOD-DTR #right &
	    [ SYNSEM.LOCAL.CAT.POSTHEAD + ],
    NONMOD-DTR #left,
    ARGS < #left, #right > ].

no_copula_prd_vp_rule := no_copula_prd_phrase & rule.

no_copula_id_vp_rule := no_copula_id_phrase & rule.

no_copula_nosubj_rule := no_copula_nosubj_phrase & rule.

free_rel_inf_rule := binary_rule_left_to_right & free_rel_inf_phrase.

free_rel_fin_rule := binary_rule_left_to_right & free_rel_fin_phrase.

partitive_num_rule := partitive_num_phrase & rule.

possessed_np_rule := possessed_np_phrase & rule.

partitive_np_rule := partitive_np_phrase & rule.
