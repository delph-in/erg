;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  syntax.tdl
;;;
;;;  The grammar rules for English
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;  Last revised: Dan Flickinger, 20-Oct-97
;;;
;;;  $Id$

;;
;;  Phrase structure schemata
;;

; Headed phrases must obey the Head Feature Principle and the Revised Marking
; Principle.  They do not all obey the NLFP with respect to QUE, but it
; appears that all CLAUSE phrases account for QUE on mother and non-head-dtr.
; Hence moved the QUE coreference to NON-CLAUSE.  Headed phrases also identify
; the value of AGR on mother and head daughter, unlike e.g. the coordination
; schemata which identify HEAD but not AGR.

headed_phrase := phrase & 
  [ ROOT -,
    SYNSEM.LOCAL [ CAT.HEAD head & #head,
                   AGR #agr,
		   CONJ #conj,
		   CONT.KEY #key ],
    HEAD-DTR.SYNSEM.LOCAL local &
		 [ CAT.HEAD #head,
                   AGR #agr,
		   CONJ #conj,
		   CONT.KEY #key ] ].

non_headed_phrase := phrase &
  [ ROOT - ].

; Most but not all phrases have SYNSEM phr_synsem; head_complement constructions
; have their SYNSEM type determined by the head-dtr.

phrasal := phrase &
  [ SYNSEM phr_synsem ].

; Head/nexus phrases pass up the REL and QUE values of the head daughter
; (which has amalgamated the REL and QUE values of its arguments a la Ivan's
; relative clause paper) to the mother.  

head_nexus_rel_phrase := headed_phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ].

head_nexus_que_phrase := headed_phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head_nexus_econt_phrase := headed_phrase &
  [ C-CONT.H-CONS <! !> ].

head_nexus_nonrel := head_nexus_que_phrase & head_nexus_econt_phrase.
head_nexus_nonque := head_nexus_rel_phrase & head_nexus_econt_phrase.
head_nexus_nonecont := head_nexus_rel_phrase & head_nexus_que_phrase.
head_nexus_phrase := head_nexus_rel_phrase & head_nexus_que_phrase &
		     head_nexus_econt_phrase.

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to that of the head daughter, which has already amalgamated
; the SLASH values of its arguments.  See discussion of head_nexus_phrase for
; treatment of REL and QUE.

head_valence_phrase := head_nexus_phrase &
  [ SYNSEM [ LOCAL.CONT.H-STORE #hstore,
	     NON-LOCAL.SLASH #slash ],
    HEAD-DTR.SYNSEM [ LOCAL.CONT.H-STORE #hstore,
		      NON-LOCAL.SLASH #slash ],
    C-CONT.H-CONS <! !> ].

; All phrases are either unary or binary.

unary_phrase := phrase &
  [ INFLECTED +,
    SYNSEM.LOCAL.CONT [ LISZT *diff-list* &
			      [ LIST #first,
				LAST #last ],
			H-CONS *diff-list* &
			      [ LIST #scfirst,
				LAST #sclast ],
			WGLISZT #wgliszt,
			TOP-H #top & handle ],
    C-CONT [ LISZT [ LIST #middle,
		     LAST #last ],
	     H-CONS [ LIST #scmiddle,
		      LAST #sclast ] ],
    ARGS < sign & [ INFLECTED +,
                    SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle ],
					  WGLISZT #wgliszt,
					  TOP-H #top ] ],
		    ROOT - ] > ].

binary_phrase := phrase &
  [ INFLECTED +,
    SYNSEM.LOCAL.CONT [ LISZT *diff-list* &
			      [ LIST #first,
				LAST #last ],
			H-CONS *diff-list* &
			      [ LIST #scfirst,
				LAST #sclast ],
			WGLISZT *diff-list* &
			      [ LIST #wgfirst,
				LAST #wglast ],
			TOP-H #top & handle ],
    C-CONT [ LISZT *diff-list* & 
		   [ LIST #middle2,
		     LAST #last ],
	     H-CONS *diff-list* &
		   [ LIST #scmiddle2,
		     LAST #sclast ] ],
    ARGS < sign & [ INFLECTED +,
		    ROOT -,
                    SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle1 ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle1 ],
					  WGLISZT *diff-list* &
						[ LIST #wgfirst,
						  LAST #wgmiddle ],
					  TOP-H #top ] ] ],
	   sign & [ INFLECTED +,
		    ROOT -,
                    SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #middle1,
						  LAST #middle2 ],
					  H-CONS *diff-list* &
						[ LIST #scmiddle1,
						  LAST #scmiddle2 ],
					  WGLISZT *diff-list* &
						[ LIST #wgmiddle,
						  LAST #wglast ],
					  TOP-H #top ] ] ] > ].

binary_headed_phrase := headed_phrase & binary_phrase &
  [ NON-HEAD-DTR sign ].

binary_rule_left_to_right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary_rule_right_to_left := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head_only := unary_phrase & headed_phrase &
  [ HEAD-DTR #head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head > ].

head_initial := binary_headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head, #non-head > ].

head_final := binary_headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #non-head, #head > ].

; C-CONT is the semantic contribution of the phrase itself.  The handle and
; index of the phrase come from the handle and index of C-CONT (which are
; possibly but not necessarily identified with the handle and index of one of
; the daughters).  The liszt of the phrase is the append of the liszt of
; C-CONT and the liszts of the daughters.

head_compositional := headed_phrase &
  [ C-CONT [ TOP #hand,
	     INDEX #index,
	     H-CONS <! !>,
	     H-STORE <! !> ],
    HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
				 INDEX #index ] ].

nonhead_compositional := binary_headed_phrase &
  [ C-CONT [ TOP #hand,
	     INDEX #index,
	     LISZT <! !>,
	     H-STORE <! !> ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
				     INDEX #index ] ].


non_clause := head_nexus_phrase &
  [ SYNSEM.LOCAL [ CAT.MC na,
		   CONT.MESSAGE <! !> ] ].

; ERB (05-10-97) The immediate subtypes of clause are now rel_cl and
; non_rel_clause.  The latter groups together decl, imp, and (wh_)interrog,
; which are similar in that they can't serve as modifiers and have empty REL
; values.  That type used to be (misleadingly) named msg_clause.  The
; remaining constraint (MESSAGE message) has been moved to the type clause
; where it belongs.

; We will need to loosen this to allow nominal clauses (i.e., ACC-ing gerunds)

clause :=  headed_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verbal,
			   VAL.COMPS *olist* ],
		     CONJ cnil ],
	     NON-LOCAL[ QUE 0-dlist,
			 REL 0-dlist ] ],
    HEAD-DTR.SYNSEM.NON-LOCAL [ QUE 0-dlist,
				REL 0-dlist ] ].

mc_phrase := phrase &
  [ SYNSEM [ LOCAL.CAT.MC +,
	     NON-LOCAL [ SLASH 0-dlist,
			 QUE 0-dlist ] ] ].

nonroot := phrase &
  [ SYNSEM.LOCAL.CAT.MC - ].

; ERB (03-10-96) hcomp_nc is no longer a subtype of this because some of them
; are "clauses" in the sense of having a message (e.g., "Kim wants [to leave]").
; This is actually in need of revision: we are probably going to need to 
; distinguish between to-headed hcomp_ncs which are selected by equi predicates 
; or otherwise have PRO subjects and whether-headed hcomp_ncs on the one hand, 
; and all other instances on the other with a restriction equivalent to SUBJ 
; list(PRO) in order to block "To rain is difficult" etc.  I think this should 
; be possible without resorting to anything like VFORM whether to identify cases
; -- see Ivan's interrogatives paper.

; The [MC bool] constraint lives here rather than on clause because we want
; to treat relative clauses as clauses, but we need to distinguish them as the
; only clauses which can serve as modifiers.  That is, on the one hand we need
; to distinguish relative clauses from ordinary finite subj_head declaratives, 
; where both have a non-empty MOD value, but only the former can appear in a
; head-modifier phrase; and on the other hand we need to distinguish
; extracted-subject finite clauses from ordinary finite S/NP clauses, since 
; only the latter can be the dtr in a thatless-relative construction.  So the
; head-adjunct rule says the adjunct must be [MC na], and the thatless_rel
; rule says the dtr must be [MC +].

non_rel_clause := head_nexus_nonque & clause & head_compositional &
  [ SYNSEM.LOCAL [ CAT.MC bool,
		   CONT.MESSAGE <! message !> ] ].

decl := non_rel_clause & 
  [ SYNSEM.LOCAL [ CAT.HEAD.INV -,
		   CONT.MESSAGE <! prpstn_rel !> ],
    C-CONT.LISZT <! !> ].

; Added [SYNSEM..SPR < >] on imp to preserve intended constraints on modifiers
; which only attach to VP and N-bar.
imp := non_rel_clause & head_valence_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ INV -,
				VFORM imp_vform,
				TENSE present ],
			 VAL [ SUBJ < >,
			       SPR < >,
			       COMPS < > ],
			 MC + ],
		   CONT [ MESSAGE <! imp_rel !>,
			  TOP-H #hand & handle ] ],
    C-CONT.LISZT <! pron_rel & [ HANDEL #hand,
				 INST #inst & full_ref-ind &
				      [ PRONTYPE std_2 ] ] !>,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb,
				  MC na,
				  VAL [ SUBJ < unexpressed &
						 [ LOCAL.CONT.INDEX #inst &
							    [ PNG.PN 2per ] ] >,
					    COMPS *olist* ] ] ] ].

; ERB (05-10-97) There is no longer a subtype of interrog for polar questions,
; as a result of streamlining the hcomp family (subordinate polar questions
; didn't inherit from the old ynq type anyway).  So interrog and its sole
; subtype wh_interrog could be collapsed into each other, but it seems clearer
; to have the separate.  I don't know what the effect of losing the constraint
; on SLASH in matrix polar questions will be.

interrog := non_rel_clause & 
  [ SYNSEM [ LOCAL.CONT.MESSAGE <! int_rel !>,
	     NON-LOCAL.SLASH 0-dlist ],
    C-CONT.LISZT <! !> ].

; Restrict NON-HEAD-DTR to be [HEAD subst] to avoid trying non-partitive
; determiner "whose" as filler in filler-head-wh rules.  Assume all
; wh-interrog phrases are [MOOD ind_or_mod_subj].


;  AAC - inherit from binary_headed_phrase because of NON-HEAD-DTR

wh_interrog := interrog & binary_headed_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD verbal &
			      [ MOOD ind_or_mod_subj & strict_sort ] ],
		   CONT.MESSAGE <! [ PARAMS <! #que & handle !> ] !> ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD subst,
			  NON-LOCAL.QUE 1-dlist &
					[ LIST < #que > ] ] ].

; This type has subtypes for subj_head and filler_head.  If we assumed only
; finite subj_head phrases, and explicitly made the relevant filler_head
; phrases be finite (which we do), we wouldn't have to stipulate VFORM here.

wh_interrog_fin := wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin,
		       VAL.SUBJ *olist* ] ].

; Since MOD is a head feature, and projections of finite verbs can be relative
; clauses, we introduce the [MOD nbar] property directly on finite verbs, rather
; than in the rel_cl phrase type as before.  Then we have to be sure that finite
; VPs do not appear as postnominal modifiers, and likewise for declarative S's.
; The former is blocked because the head-adjunct rule requires that the adjunct 
; be [SUBJ *olist*].  The latter we block by requiring that the adjunct in a 
; head-adjunct phrase be [MC na], while making declarative head_subj phrases 
; be [MC bool].  Thus relative clauses must also be [MC na].

rel_cl := clause & head_nexus_nonrel &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin_or_inf,
				  INV -,
				  MOOD ind_or_mod_subj & strict_sort,
				  MOD < [ LOCAL intersective_mod &
						[ CONT.INDEX #ind ] ] > ],
			   POSTHEAD +,
			   MC na ],
		     CONT [ TOP #hand,
			    INDEX #ind,
			    MESSAGE <! !>,
			    H-STORE #hstore ] ],
	     NON-LOCAL.QUE 0-dlist ],
    HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
				 H-STORE #hstore ],
    C-CONT.LISZT <! hypo_rel !> ].

; We prevent PP adjunct extraction from feeding thatless_rel rule by requiring
; that the gap be [ MOD < > ], to block "the man kim slept walks." To handle
; "I remember the time Kim fell" maybe we can make the words "time" and
; "place" take an S/PP complement, not treat them as thatless_rels.  Also, 
; to block "*Sandy likes the man walks" and "*Sandy likes the man who thinks 
; went home", we require the S/NP to be [ MC + ], which excludes subject
; extraction for that daughter.

; The dtr is required to be [MC +] in order to block subject-extracted S/NPs
; from being admitted as relative clauses.  This constraint would be removed
; for those dialects which accept examples like "There's a man wants to talk to
; you waiting outside."

; ERB (14-12-97) I am trying to get the non-finite ones to work and to
; have only one type that will make both "The man Kim likes" and "The
; man to talk to" (but not "The man to talk to Sandy".)  The new
; constraints are: on the head-dtr HEAD verb, VFORM fin_or_inf, and
; SUBJ list(pro).  I also need to make to_c_prop HEAD verb and 
; MC +.  The latter is because we want to require MC + of the head-dtr
; to exclude subject extraction as above, adn to exclude that-declaratives
; from being the head-dtr of this cx.  (To avoid a really ugly second
; parse for "The man that Kim likes.")

; ERB (14-12-97) to_c_prop doesn't have to be a verb.  non_wh_rel_cl
; can just say HEAD verbal -- that-decls will be ruled out because they
; are MC -.  To_c_prop has to be MC + anyway because we need the
; MC + on the head-dtr in order to bar subj extractions from this
; cx.

; ERB (19-01-98) MC + moved to appropriate subtype.  See notes below.

; ERB (19-01-98) Part of what's keeping to_c_prop from serving directly
; as a modifier without first building a non_wh_rel is that hadj requires
; SUBJ *olist* and pro_ss is OPT -.  This means that non_wh_rel_cl can't
; copy up the SUBJ requirement.  I don't know what exactly the constraints
; are on the other valence features, so I am just copying them up for now.
; (Previously all of VAL was identified.)
; DPF (21-Apr-98) Make SYNSEM.COMPS be < > on mother and *olist* on daughter.

; DPF (26-05-98) Added [MOD < [ NON-LOCAL.QUE 0-dlist] >] to the mother, to 
; block thatless relatives modifying WH-partitives, as in the unwanted NP 
; "how many books are t"

; DPF (06-Sept-98) Added reg_nom_rel constraint on MOD < [ LOCAL.CONT.KEY ] >, 
; to avoid infinitival relatives modifying temporal nouns as in "we should meet 
; next week to celebrate".

non_wh_rel_cl := head_only & rel_cl &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CONT [ INDEX #ind,
						     KEY #key & reg_nom_rel ],
					NON-LOCAL.QUE 0-dlist ] >,
			   VAL [ SUBJ < >,
				 SPR #spr,
				 COMPS < > ] ] ],
	     NON-LOCAL.SLASH 0-dlist ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal &
					 [ VFORM fin_or_inf ],
				    VAL [ SUBJ *prolist*,
                                          SPR #spr,
                                          COMPS *olist* ] ] ],
		      NON-LOCAL.SLASH 1-dlist &
			    [ LIST < [ CAT [ HEAD noun &
						  [ PRD -,
						    MOD < > ],   
					     VAL [ SPR *olist*,
						       COMPS < > ] ],
				       AGR #ind,
				       CONT [ INDEX #ind,
					      KEY #key ] ] > ] ],
    C-CONT.MESSAGE <! propositional_rel !> ].


; ERB (19-01-98) As much as it hurts, I don't think it is possible
; to avoid differentiating a inf and fin non_wh_rel_cl.  The facts of
; (Standard American) English seem to be that finite non-wh relatives
; do not allow extraction of the highest subject, but non-finite ones
; do:
;
; (1) Kim likes the book Sandy bought.
; (2) *Kim likes the person buys books.
; (3) Kim found a book to buy for Sandy.
; (4) Kim found a person to buy Sandy a book.
;
; A simple hack involving case won't work, because embedded subjects
; can be extracted in the finite case:
;
; (5) Sandy likes the program Kim thinks works.
;
; Another tack is to treat (3) and (4) above differently, where
; the to in (3) is to_c_prop and the to in (4) is to_c_nonprop.
; The motivation for this is that the former allows a discourse
; PRO interpretation, while the latter doesn't, so it is tempting
; to says that the latter doesn't involve PRO at all.  The idea is
; that to_c_prop builds a non_wh_rel which can then serve as a 
; modifier, while to_c_nonprop has a MOD value to start off with,
; and can be a modifier directly once it builds a hcomp.  To_c_nonprop
; would bind the index of its MOD value to that of its subject.
;
; However, this is unsatisfactory for several reasons.  First, the
; ones like (4), built with to_c_nonprop, have no message for the
; relative.  Second, since MOD is a head feature now, to_c_prop must
; also be MOD < nbar > .  Once this is true, there is no obvious way to
; keep it from serving directly as a modifier without building a
; non_wh_rel. Finally, we run into problems with lexical SLASH
; amalgamation.  Something has to be said about the subject value of
; to_c_nonprop, otherwise it runs the risk of having a non-terminated
; SLASH value.  However, on the one hand, to_c_nonprop is the to of
; raising constructions, so sometimes its SUBJ must be able to be
; canonical_synsem, and on the other, on this analysis, it can also
; head modifiers in which its SUBJ goes unexpressed.  To take care
; of the latter, something must be said in the lexical entry, but
; unexpressed is not compatible with canonical_synsem.
;
; The only other possibility I can see is to let the subject extraction
; apply lower, as in to [like Sandy] in [a person to like Sandy], but
; this requires letting subject extraction apply to base forms, which
; would most likely be a royal mess.
;
; In sum, given the facts of SAE and the rest of the grammar as
; it is, (3) and (4) must be built with the same to.  In (3) there
; is an extracted complement and in (4) there is an extracted 
; subject.  In the case of infinitival non_wh_rels, the grammar
; doesn't care.  In the case of finite ones, it does.


fin_non_wh_rel_cl := non_wh_rel_cl &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb &
				     [ VFORM fin,
				       MOD < [ LOCAL.CAT nbar_cat ] > ],
				MC + ] ].

inf_non_wh_rel_cl := non_wh_rel_cl &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD comp &
				     [ VFORM inf ] ] ].


; The version of the Non-local Feature Principle here assumes that there will
; only be one value on the SLASH list.  To handle multiple gaps, we'll need
; more general set-manipulation functions.  This version also doesn't use a
; distinction between INHERITED and TO-BIND non-local features.  Instead, it
; treats non-local features like valence features.

; ERB (17-10-96) in order to get "Kim knows who to ask" under the current
; hacks (i.e., no PRO), I need a head_filler_phrase that takes something like
; "to ask" (i.e., VFORM in, SUBJ @nomp()) as its head.  So I am making a
; separate parallel type that will only be inherited by the embedded wh
; nonfinite questions.

; N.B. Since all head_filler constructions inherit from type clause, which
; inherits from head_compositional, this type does not (though it could,
; redundantly).

; Added [ SUBJ *prolist* ] constraint to NON-HEAD-DTR, to ensure termination
; of the QUE and REL attributes now that we're doing lexical threading, and
; PPs (among others) wouldn't otherwise know if they were QUE empty or not.
;
; (DPF 23-Aug-98) But if we make thie SUBJ *prolist*, then we can't get 
; extraction of raising predicates, as in "how does Kim look", since the
; subject of the "how" adjective is identified with that of "look".  Hence
; we move this constraint to the extracted=adjunct rule, since it seems to
; hold true for adjuncts, but not for complements.

head_filler_phrase := head_final & head_nexus_phrase & 
  [ SYNSEM [ LOCAL [ CAT.VAL [ SUBJ #subj,
			       COMPS < >,
			       SPR < > ],
		     CONT.H-STORE #hstore,
		     CONJ cnil ],
	     NON-LOCAL.SLASH 0-dlist ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal,
				    VAL [ SUBJ #subj,
                                          COMPS *olist* ] ],
			      CONT.H-STORE #hstore ],
		      NON-LOCAL [ SLASH 1-dlist &
					[ LIST < #slash > ],
				  QUE 0-dlist,
				  REL 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL #slash & local &
				[ CAT.VAL [ COMPS *olist*,
					    SPR *olist* ],
				  CTXT.ACTIVATED + ],
			  NON-LOCAL.SLASH 0-dlist ] ].

head_filler_phrase_fin := head_filler_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ *olist*,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ VFORM fin ] ].

head_filler_phrase_inf := head_filler_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD verbal & [ VFORM inf ],
			    CONT.MESSAGE <! hypo_rel !> ] ].

; 1-May-96 (DPF) Restricted head to be verb only, to block spurious parses
; where NP modifed by PP was also analyzed as its subject.
; 12-Jun-96 (RPM) Allow verbal gerunds to head head/subj phrases.

; N.B. Since all head_subj_phrase constructions inherit from type clause,
; which inherits from head_compositional, this type does not (though it could,
; redundantly).

head_subj_phrase := head_valence_phrase & head_final &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb & [ VFORM fin ],
			 VAL [ SUBJ < >,
			       COMPS < >,
			       SPR < > ] ],
		   CONJ cnil ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL [ SUBJ < #synsem >,
				      COMPS *olist* ],
				MC na ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical_synsem &
		 [ LOCAL [ CAT [ HEAD subst,
				 VAL [ SUBJ < >,
				       COMPS *olist*,
				       SPR *olist* ] ],
			   CONT.MESSAGE <! !> ],
		   NON-LOCAL [ REL 0-dlist,
			       QUE 0-dlist ] ] ].
 
; A head/comps phrase is a phrase that combines a head with something selected
; for by the COMPS feature.  Head/comps phrases come in two denominations:
; head/comp phrases and head/marker phrases.  A head/comp phrases is like the
; usual VP rule, and its head (and therefore the whole phrase) must be CONJ
; cnil.  A head/comp phrase is unmarked for MC, but will inherit a MC
; specification from its head daughter.  Head/marker phrases takes the place
; of the P&S94 head/marker rule.  The head must be lexical (i.e., of type
; "word") and CONJ non-cnil. 

head_comp_or_marker_phrase := head_valence_phrase & head_compositional & 
			      head_initial &
  [ SYNSEM.LOCAL [ CAT [ MC #mc,
			 VAL [ SUBJ #subj,
			       COMPS #comps,
			       SPR #spr ] ],
		   CONT.MESSAGE #hmsg ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ MC #mc,
				  VAL [ SUBJ #subj,
					COMPS < #synsem . #comps >,
					SPR #spr ] ],
			    CONT.MESSAGE #hmsg ],
    NON-HEAD-DTR.SYNSEM #synsem ].

; ERB (05-10-97) In order for one single hcomp rule to build things like "how
; about on Friday", the restriction HEAD subst needs to be removed from this
; rule, or else root-marker needs to inherit from subst.  I am opting for the
; former.

; This type also appends the MESSAGE value from the non-head-dtr, since
; clausal complements must contribute their message, as in "Kim says Sandy won",
; but where that same declarative clause must not contribute the prpstn message
; when it is in a "whether" clause, as in "Kim wonders whether Sandy won".

; DPF (25-Aug-98) The head_comp_phrase is not marked POSTHEAD + since we want to
; build "twenty-one" using this rule, but still allow it to serve as a
; prenominal modifier  as in "twenty-one books".  So instead we use the PRED
; feature to distinguish prenominal from postnominal modifiers, and conspire to
; make all PRED - entries have an empty COMPS list.  

head_comp_phrase := head_comp_or_marker_phrase &
  [ SYNSEM canonical_synsem &
	   [ LOCAL [ CAT.POSTHEAD #ph,
		     CONJ cnil ],
	     LEX #lex ],
    HEAD-DTR [ SYNSEM.LOCAL.CAT [ POSTHEAD #ph,
				  HC-LEX #lex ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.MESSAGE #msg,
    C-CONT.LISZT #msg ].

head_marker_phrase := head_comp_or_marker_phrase &
  [ SYNSEM canonical_synsem &
	   [ LOCAL.CONJ strict-conj,
	     NON-LOCAL #nonlocal,
	     LEX #lex ],
    HEAD-DTR word,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HC-LEX #lex,
			  NON-LOCAL #nonlocal ],
    C-CONT.LISZT <! !> ].

; Skip an optional complement as long as there is still another obligatory
; complement on the list (here assumed to be the second complement, since it's
; hard and perhaps unnecessary to allow the obligatory one to appear in an
; arbitrary position).

head_opt_comp_phrase := head_valence_phrase & head_only & head_compositional &
  [ SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 COMPS #comps,
				 SPR #spr ],
			   POSTHEAD + ],
		     CONT.MESSAGE #msg ],
	     LEX #lex ],
    HEAD-DTR [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ #subj,
					  COMPS < unexpressed & [ OPT + ]
						  . #comps & < expressed_synsem, 
							       ... > >,
					  SPR #spr ],
				    HC-LEX #lex ],
			      CONT.MESSAGE #msg ] ],
    C-CONT.LISZT <! !> ].


; ERB (19-01-98) If to_c_prop can undergo subject extraction (see notes
; near non_wh_rel) then this can't require HEAD v_or_p.  That constraint
; will be moved to extracted_comp_phrase.  Extrasubj will say 
; HEAD verbal.

extracted_arg_phrase := head_only & head_compositional & 
			head_valence_phrase & 
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOOD indicative,
			 VAL.SPR #spr ],
		   CONJ cnil ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR #spr,
			    CONJ cnil ],
    C-CONT.LISZT <! !> ].

; To block extraction of subjects of inverted auxiliaries, introduce (hack)
; restriction to accusative case on the extracted complement. This restriction
; is irrelevant (and probably unwanted) if the complement is not an NP, but we
; avoid using an awkward disjunction this way.  We also block extraction of
; complements out of subjunctive-verb-headed phrases.

; *** We still need special extraction rules for fronting CPs and VPs.

; AAC - EXTRACTED_COMP_PHRASE: HEAD_NEXUS_PHRASE is redundant - 
; it is an ancestor of EXTRACTED_ARG_PHRASE 

; DPF 03-Jul-98: Eliminated unification of the gap's MESSAGE with the C-CONT's
; MESSAGE (which one might expect by analogy with the head-complement rule)
; because this causes a cyclic structure in conjoined extractions, which unify
; their NON-LOCAL values (e.g., in "Sandy, Kim hired and fired").  Doesn't seem
; to matter much, since we're not eager to allow extraction of CPs anyway.

extracted_comp_phrase := extracted_arg_phrase & 
  [ SYNSEM canonical_synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
			       COMPS #comps ],
			 MC #mc ],
	     LEX #lex ],
    HEAD-DTR [ SYNSEM 
	       [ LOCAL.CAT [ HEAD v_or_p,
			     VAL [ SUBJ #subj,
				   COMPS < gap &
					   [ LOCAL local &
						   [ CAT.HEAD mobile ],
					     NON-LOCAL.SLASH #slash ]
					   . #comps > ],
			     MC #mc,
			     HC-LEX #lex ],
		 NON-LOCAL.SLASH #slash ] ],
    C-CONT.LISZT <! !> ].


; Assume only finite clauses have explicit subjects that can be extracted, and
; restrict these to indicative verbs (not subjunctives). 

; ERB (19-01-98) We are assuming that there is subject extraction
; in "just the teacher [to talk to Sandy]" so the VFORM must be 
; loosened here.  See notes near non_wh_rel.  Also, HEAD verbal.
; What's to block whether from undergoing subject extraction?
; (cf. *Sandy Kim knows whether to elect Clinton president.)
; DPF (27-Apr-98) Made HEAD-DTR..HEAD be strict_type to block non-verbal heads
; from unifying (e.g. "red")

extracted_subj_phrase := extracted_arg_phrase &
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ < >,
			     COMPS < > ],
		       MC - ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verbal & strict_type &
				       [ VFORM fin_or_inf,
					 MOD < synsem_min > ],
				  VAL [ SUBJ < gap &
						   [ LOCAL #local & local &
						       [ CONT.INDEX ref-ind ] ]>,
					    COMPS *olist* ],
				  MC na ],
		      NON-LOCAL.SLASH.LIST < #local > ] ].


; For specifiers of nouns (det and non-det), adjectives and prepositions.
; Also for specifiers of determiners, as in "almost all".  Needs to be modified
; to also allow "exactly which books".

head_spec_phrase := head_valence_phrase & head_final & non_clause & phrasal &
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ #subj,
			     COMPS < >,
			     SPR #spr,
			     SPEC #spec ],
		       POSTHEAD #ph ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ VAL [ SUBJ #subj,
					COMPS *olist*,
					SPR < #synsem & canonical_synsem . #spr>,
					SPEC #spec ],
				  POSTHEAD #ph,
				  MC na ],
			    CONT [ TOP #top,
				   KEY #key ],
			    CONJ cnil ],
    NON-HEAD-DTR.SYNSEM #synsem &
		        [ LOCAL.CAT [ MC na,
				      VAL.SPEC < [ LOCAL.CONT [ TOP #top,
								KEY #key ] ] > ],
			  NON-LOCAL.SLASH 0-dlist ] ]. 

; The noncompositional head_spec is for making non-number phrases: 
;  - determiner + noun NPs  "the book"
;  - NP + poss phrases      "the manager 's"

head_spec_noncompos := head_spec_phrase & nonhead_compositional &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
				     KEY non_number_rel ],
    C-CONT [ TOP #hand,
	     LISZT <! !>,
	     H-CONS <! !>,
	     H-STORE <! !> ] ].


; Among others, the compositional head_spec is used for number expressions 
; like "two hundred", and for degree phrases like "less than four" and
; "very tall"

head_spec_compos := head_spec_phrase & head_compositional &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.KEY number_or_degree_rel,
    C-CONT.LISZT <! !> ].

; The SYNSEM value of the head of a head/modifier phrase is token-identical to
; the MOD value of the adjunct daughter.  Additionally, the adjunct daughter
; must be complement-saturated.  The SLASH value is not set in the basic
; schema, but rather in each of the subtypes: in head_mod_phrase_simple the
; SLASH value is passed up from both daughters, but in the
; extracted_adj_phrase the SLASH value of the mother is effectively the
; adjunct that would have modified the head.
; 
; DPF (6-Sept-98) Constrained HEAD-DTR to have empty QUE as well as REL, to 
; block adverbs modifying "how", "where", etc.  

head_mod_phrase := head_nexus_nonecont & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
				 COMPS < > ],
			   MC #mc ],
		     CONT.KEY #hkey ],
	     MODIFIED hasmod ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
					  SPR #spr,
					  COMPS *olist* ],
				    MC #mc ],
			      CONT.KEY #hkey,
			      CONJ cnil ],
		      NON-LOCAL [ REL 0-dlist,
				  QUE 0-dlist ] ],
    C-CONT [ LISZT <! !>,
	     H-CONS <! !>,
	     H-STORE <! !> ] ].

; Added restriction on adjunct's specifier to prevent unsaturated nouns
; (like 'afternoon') from serving as modifiers before they pick up their
; specifiers.

; head_mod_phrase_simple takes the MESSAGE value from its non-head dtr's 
; MESSAGE.  Most modifiers identify their message with their
; modifiee's message, but tags don't.  (Modifiers cannot simply identify their
; own message with that of their modifiee, since some signs (like "not")
; can be either a modifier or an argument, and hence need a message value 
; independent of that of their modifiee.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DPF 16-Jul-98 - Reconsider this paragraph...
; head_mod_phrase_simple cannot inherit from nonhead_compositional, since some
; adjuncts (e.g. relative clauses) specify a value for TOP and/or INDEX on
; the mother which is distinct from their own (this is the purpose of the
; ECONT attribute).  Thus it is true that the nonhead daughter determines
; the TOP and INDEX of the mother, but they are not necessarily simply the
; nonhead's own.  It is assumed here that every adjunct (sign with non-empty
; MOD value) will also specify in its ECONT attribute values for TOP,
; INDEX, and LISZT.
; Also, head_mod phrases cannot identify the mother's ECONT with the head
; daughter's, since the modifier may itself be modified, and that can affect
; the handle and index of the resulting phrase.  Cf. Kasper's example of
; "an apparently unsolvable problem", where the handle of the modifier phrase
; will depend on whether there is an adverb modifying the adjective or not.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; SLASH of mother is append of SLASH lists for the two daughters.  In principle
; this allows distinct slash values on the two daughters, without enforcing
; parasitic gaps.  So we restrict the LIST.REST value of SLASH on the mother to
; be the empty list -- a hack which works in PAGE since not strictly typed, but 
; what we really want to say is that SLASH on the mother is either a singleton 
; list, or the empty list.
;; 15-Jun-98 Removed this hack, since it doesn't work in the LKB, and is wrong
;; anyway, failing to generalize to e.g. head-complement structures, which
;; present the same problem of distinct SLASH values coming from each of the
;; two daughters.

; Removed identification of hddtr's MESSAGE with mother's - wrong for tags,
; at least.  Should be handled independently by each modifier.

head_mod_phrase_simple := head_mod_phrase & binary_headed_phrase &
  [ SYNSEM [ LOCAL.CONT [ MESSAGE #msg,
			  H-STORE [ LIST #hsfirst,
				    LAST #hslast ] ],
	     NON-LOCAL [ SLASH *diff-list* &
			       [ LIST #first,
				 LAST #last ],
			 REL 0-dlist ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT #localcat,
			      AGR #agr,
			      CONT [ TOP #htop,
				     INDEX #hind,
				     KEY #key,
				     H-STORE [ LIST #hsmiddle,
					       LAST #hslast ],
				     MESSAGE #hmsg ] ],
		      NON-LOCAL.SLASH *diff-list* &
	                              [ LIST #first,
					LAST #middle ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD head & strict_type &
					     [ MOD < [ LOCAL local & 
						       [ CAT #localcat,
							 AGR #agr,
							 CONT 
							  [ TOP #htop,
							    INDEX #hind,
							    KEY #key,
							    MESSAGE #hmsg ]]] >],
					VAL [ SUBJ *olist*,
					      COMPS *olist*,
					      SPR *olist* ],
					MC na ],
				  CONT [ TOP #hand,
					 INDEX #index,
					 MESSAGE #msg,
					 H-STORE [ LIST #hsfirst,
						   LAST #hsmiddle ] ],
				  CONJ cnil ],
			  NON-LOCAL [ SLASH *diff-list* &
					    [ LIST #middle,
					      LAST #last ],
				      QUE 0-dlist,
				      REL 0-dlist ] ],
    C-CONT [ TOP #hand,
	     INDEX #index ] ].


;; For now, block extraction from head, to avoid extra phrase being built for 
;; "maybe kim sleeps" with adjunct extraction.
;; DPF (12-Jul-98) Changed POSTHEAD on mother from that of head-dtr to simply -, 
;; since want to prevent this rule from feeding head-adj rule.
;; DPF (25-Sept-98) Since we're no longer treating all head-complement phrases as
;; POSTHEAD -, we have to strengthen the constraint on the non-head-dtr's COMPS value
;; to be truly the empty list, not just *olist*.

adj_head_phrase := head_mod_phrase_simple & head_final &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
	     MODIFIED lmod* ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
		      NON-LOCAL.SLASH 0-dlist ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD.PRD -,
				      VAL.COMPS < >,
				      POSTHEAD - ],
			  NON-LOCAL.SLASH 0-dlist ] ].

; ERB (07-11-96) Non-head dtr is QUE 0-dlist to rule out "*Leaving when do you
; think would bother Sandy?" or "*Your house where did the government forclose
; on?"  Not on higher type because "How long a book did you write?"

head_adj_phrase := head_mod_phrase_simple & head_initial &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD +,
	     MODIFIED rmod* ],
    HEAD-DTR.SYNSEM.MODIFIED rmod,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD +,
			  NON-LOCAL.QUE 0-dlist ] ].

; DPF (07-17-98) Split head_adj_phrase and adj_head_phrase into two each,
; one for intersective modifiers and one for scopal modifiers, in order to
; get desired results for recursive modification as in "apparently difficult
; problem" (cf. Kasper '98).

adj_head_scop_phrase := adj_head_phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL scopal_mod ] > ].

head_adj_scop_phrase := head_adj_phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL scopal_mod ] > ].

adj_head_int_phrase := adj_head_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.TOP #hand,
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
				CONT.TOP #hand ] ].

head_adj_int_phrase := head_adj_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.TOP #hand,
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
				CONT.TOP #hand ] ].


;; Further split the head_adj_int_phrase in order to enforce one aspect of the 
; Complex-NP constraint prohibiting extraction from nominal adjuncts.

n_adj_int_phrase := head_adj_int_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH 0-dlist ].

h_adj_int_phrase := head_adj_int_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adverbee ].


; For now, restrict adjunct extraction to posthead modifiers of VPs (and the
; special case of inverted auxiliary-headed Ss, which still have a non-empty but
; never realized SUBJ - see discussion of sai_synsem in lextypes.tdl). This will
; still produce two parses for "Tuesday Kim might dance", but the alternatives
; (e.g., blocking modification of all auxiliaries except the copula) seem even
; less attractive.  Also block extraction of adjuncts out of
; subjunctive-verb-headed phrases.

; ERB (12-11-96) This is the exception; the reason I couldn't put the MESSAGE
; stuff on head_mod_phrase.

; DPF (23-Aug-98) Given our splitting up of the head-modifier type into 
; separate subtypes for intersective and scopal modification, we have to do
; the same for extracted adjuncts as well.
; DPF (09-Jan-99) But it is not clear that we ever need to extract scopal
; modifiers, since the ones that are post-head (maybe always adverbs) also seem
; to be available as modifiers of S, and not restricted to POSTHEAD +.  So we'll
; try doing without this rule.

extracted_adj_phrase := head_mod_phrase & head_only & 
  [ SYNSEM [ LOCAL [ CAT [ POSTHEAD #ph,
			   MC #mc ],
		     CONT [ MESSAGE #msg,
			    H-STORE #hstore ] ],
	     NON-LOCAL.SLASH 1-dlist &
		   [ LIST < local &
			    [ CAT [ POSTHEAD +,
				    HEAD.MOD < #mod >,
				    VAL [ SUBJ *prolist*,
                                          COMPS *olist*,
					  SPR *olist* ] ],
			      CONT [ TOP #hand,
				     INDEX individual & #index,
				     H-STORE #hstore,
				     MESSAGE #msg ] ] > ] ],
    C-CONT [ TOP #hand,
	     INDEX #index ],
    HEAD-DTR.SYNSEM canonical_synsem & #mod &
	   [ LOCAL local_basic &
		   [ CAT [ HEAD verb &
				[ MOOD ind_or_mod_subj & 
				       strict_sort ],
			   VAL.SUBJ < synsem_min >,
			   POSTHEAD #ph,
			   MC #mc ] ],
	     NON-LOCAL.SLASH.LIST < >,
	     MODIFIED notmod ] ].

extracted_adj_int_phrase := extracted_adj_phrase &
  [ SYNSEM.NON-LOCAL.SLASH <! [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
                                CONT [ TOP #hand,
				       KEY.HANDEL #khand ] ] !>,
    HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
				 KEY.HANDEL #khand ] ].

#|
extracted_adj_scop_phrase := extracted_adj_phrase &
  [ SYNSEM.NON-LOCAL.SLASH <! [ CAT.HEAD.MOD < [ LOCAL scopal_mod ] > ] !> ].
|#

;;
;; Bare plural and mass NPs, distinguished by the INDEX feature [ DIVISIBLE + ]
;;

bare_np_phrase := head_only & non_clause & phrasal &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SUBJ < >,
			       COMPS < >,
			       SPR < > ],
		     CONT [ MESSAGE #msg,
			    H-STORE #hstore ] ],
	     NON-LOCAL.SLASH #slash ],
    HEAD-DTR.SYNSEM [ LOCAL 
		      [ CAT [ HEAD noun,
			      VAL [ SUBJ < >,
				    COMPS *olist*,
				    SPR < non_canonical &
					  [ OPT -,
					    LOCAL local &
						[ CONT [ KEY #quant &
							     [ RESTR #arg  ],
							 H-STORE <! #hand !> ] ],
					    NON-LOCAL [ SLASH 0-dlist,
							REL 0-dlist,
							QUE 0-dlist ] ] > ] ],
			CONJ cnil,
			CONT [ TOP #top,
			       INDEX #index & [ DIVISIBLE + ],
			       KEY basic_nom_rel,
			       MESSAGE #msg,
			       H-STORE #hstore ] ],
		      NON-LOCAL.SLASH #slash ],
    C-CONT [ TOP #top, 
             INDEX #index,
	     LISZT <! udef_rel & #quant &
		    [ HANDEL #hand,
		      BV #index,
		      RESTR #arg ] !>,
	     H-CONS <! !> ] ].

;; 
;; Noun-noun compounds
;;

; Make left member be [ COMPS < > ] to avoid spurious ambiguity since we have
; separate lexical entries to handle optional nominal complements.
; DPF (22-Oct-98) Can't do the above, since it's not true for most nouns, and
; also won't work for "two fifteen meeting" where the am_pm argument is not
; expressed, but can't be discharged by the optcomp rule.

n_n_cmpnd_phr := head_final &
  [ SYNSEM lex_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < >,
			   VAL #valence,
			   MC #mc ],
		     CONT [ MESSAGE #msg,
			    H-STORE #hstore ] ],
	     NON-LOCAL [ SLASH #slash,
			 QUE 0-dlist,
			 REL 0-dlist ] ],
    HEAD-DTR.SYNSEM nonpronominal_synsem &
	   [ LOCAL [ CAT [ HEAD noun*,
			   VAL #valence &
			       [ SPR < synsem & [ OPT - ] > ],
			   MC #mc ],
		     CONT [ MESSAGE #msg,
			    INDEX #hind & ref-ind,
			    KEY.HANDEL #khhand,
			    H-STORE #hstore ],
		     CONJ cnil ],
	     NON-LOCAL [ SLASH #slash,
			 QUE 0-dlist,
			 REL 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM nonpronominal_synsem &
	   [ LOCAL [ CAT [ HEAD noun* & [ PRD - ],
			   VAL [ COMPS *olist*,
				 SPR *unexplist* ] ],
		     AGR.PNG.PN 3sg,
		     CONT [ INDEX #modind & ref-ind,
			    KEY nom_rel &
				  [ HANDEL #khand ] ] ],
	     NON-LOCAL [ SLASH 0-dlist,
			 QUE 0-dlist,
			 REL 0-dlist ] ],
    C-CONT [ LISZT <! unspec_rel & [ HANDEL #uhand,
				     HINST #hind,
				     NHINST #modind ],
		      some_rel & [ HANDEL #khhand,
				   BV #modind,
				   RESTR #khand,
				   SCOPE #schand ] !>,
	     H-CONS <! is-one-of & [ SC-ARG #schand,
				     CANDS <! #uhand !> ],
		       leq & [ SC-ARG #schand,
			       OUTSCPD #uhand ] !> ] ].

;;
;; Temporal NP modifiers
;;

temp_mod_phrase := unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun &
				[ MOD < [ LOCAL intersective_mod &
					  [ CAT vp_cat,
					    CONT.INDEX #ind ] ] > ],
			   POSTHEAD +,
			   VAL [ SUBJ < @nomp() &
					[ LOCAL [ CONT.INDEX #ind,
						  THROLE arg1 ],
					  NON-LOCAL [ SLASH 0-dlist,
						      REL 0-dlist,
						      QUE 0-dlist ] ] >,
				 SPR #spr,
				 COMPS #comps ],
			   MC na ],
		     CONT [ INDEX #ind,
			    KEY loc_rel & #key & 
				  [ HANDEL #khand,
				    ARG #ind & event_or_index,
				    ARG3 #index ],
			    H-STORE #hstore,
			    MESSAGE <! !> ],
		     CONJ cnil ],
	     NON-LOCAL #nonloc ],
    ROOT -,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD noun,
				    VAL [ SPR #spr & < >,
					  COMPS #comps & *olist* ] ],
			      CONT [ KEY modable_rel,
				     INDEX #index,
				     H-STORE #hstore &
					 [ LIST #hslist,
					   LAST #hslast ] ],
			      CONJ cnil ],
		      NON-LOCAL #nonloc ] ] >,
    C-CONT [ TOP #top,
	     LISZT <! #key !>,
	     H-CONS <! is-one-of &
		     [ SC-ARG #top,
		       CANDS [ LIST < #khand . #hslist >,
			       LAST #hslast ] ],
		       leq &
		       [ SC-ARG #top,
			 OUTSCPD #khand ] !> ] ].


;;
;; Vocative modifiers
;;

#|
vocative_phrase := unary_phrase &
  [ SYNSEM disc_adv_phr_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT [ VAL [ SUBJ < >,
							    SPR *olist* ],
						      MC + ],
						CONT.TOP #top ] ] >,
			   MC na ],
		     CONT.KEY #key ],
	     NON-LOCAL #nonloc &
		   [ SLASH 0-dlist,
		     REL 0-dlist,
		     QUE 0-dlist ] ],
    ROOT -,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD noun,
				    VAL [ SPR < >,
					  COMPS *olist* ] ],
			      CONT.KEY #key & named_rel,
			      CONJ cnil ],
		      NON-LOCAL #nonloc ] ] >,
    C-CONT [ TOP #top,
	     LISZT <! !>,
	     H-CONS <! !> ] ].
|#

vocative_phrase := unary_phrase &
  [ SYNSEM disc_adv_phr_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT s_cat,
						CONT [ TOP #top,
						       INDEX #event ],
						CONJ cnil ],
					NON-LOCAL.SLASH 0-dlist ] >,
			   MC na ],
		     CONT.KEY #key ],
	     NON-LOCAL #nonloc &
		   [ SLASH 0-dlist,
		     REL 0-dlist,
		     QUE 0-dlist ] ],
    ROOT -,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD noun,
				    VAL [ SPR < >,
					  COMPS *olist* ] ],
			      CONT [ INDEX #ind,
				     KEY named_rel ],
			      CONJ cnil ],
		      NON-LOCAL #nonloc ] ] >,
    C-CONT [ TOP #top,
	     LISZT <! #key & unspec_mod_rel & 
		      [ ARG #event,
			ARG3 #ind ] !>,
	     H-CONS <! !> ] ].

;;
;; Coordinate structures
;;
; To enable coordination of categories that are similar but not identical, we
; introduce intermediate types for some attribute values, including those for
; HEAD, AUX, and AGR.  Lexical items and the phrases they project will have
; these intermediate types as values, while signs that select for a given
; type will usually specify values for the above features using their most
; specific types.  For example, a preposition will be [ HEAD prep* ] but a
; verb which subcategorizes for a PP will specify that its complement must be
; [ HEAD prep ], assuming that HEAD values are of type 'head' organized in a
; type hierarchy as follows (simplified for exposition):
; 	
; 		head
;            /   |   \
; 	verb*  prep*  noun*
;         /  \  /  |  \  /  \
;      verb  v+p  prep p+n   noun
; 
; Most heads will select for a specific value for HEAD, but the copula "be"
; leaves the HEAD value underspecified, requiring only that its complement be
; [ PRD + ], so it will happily take as complement the conjoined phrase
; "in Paris and shopping", where the value of HEAD for this phrase is the
; unification of 'verb*' and 'prep*", namely 'v+p'.  This assumes that the
; constituent coordination schema simply requires that the CAT values of both
; conjuncts unify.
; 
; In a similar manner, the conjunction of two verb phrases, one headed by a
; main verb and one by an auxiliary, will work as long as no other constraints
; are imposed on the attribute AUX for this conjoined phrase.  Here the feature
; AUX is boolean-valued, with the following sort hierarchy for this value type:
; 
; 		bool
; 	 	/   \
;             +*     -*
; 	     /  \   /  \
;  	    +  +_and_-  -
; 
; Then in the sentence "Kim sings and has danced" the VP is [ AUX +_and_- ],
; and since declarative clauses impose no constraint on the value for AUX, the
; sentence is correctly admitted. In contrast, the auxiliary verb "do" requires
; its complement to be [ AUX - ], and since the sort '-' does not unify with
; the sort '+_and_-', the following example is correctly ruled out: 
; "*Kim did sing and have danced".
; 
; Elaborations:
; 
; 1. Since some heads only partially constrain their complements, as with
; "consider" which accepts either an AP or an NP complement, we enrich the
; above hierarchies to include a notion of 'strict' or most specific values,
; so "consider" can restrict its complement to be [ HEAD a_or_n & strict_type ]
; assuming the following more elaborate (though again partial) hierarchy:
; 
;                        head
;              	       /  |   			    
; 		      /   |    strict_type
; 	             /  a_or_n   / /  | 
;                   /       / \_/ /   | 
;                  /       /   /\/    |
;                 prep*   adj*/ /noun*|
;                 |  _\__/_|_/\/  /\  |
;                 | /  \/  |  /\ /  \ |
;                prep p+a  adj a+n  noun
; 
; Here the only consistent values for the complement of "consider" are 'adj'
; or 'noun'.  Of course this isn't quite right, since we thereby exclude the
; coordination "consider Kim a friend and reliable".  What we would need is a
; way of specifying for the complement of "consider" all and only the most
; specific values subsumed by 'a_or_n'.  But at present if a head needs to
; impose partial constraint on an attribute, we cannot also get the kind of
; non-identical coordination we showed for the copula.  Leave for future work.
; 
; 2. We also undergenerate coordination of non-identical phrases in those cases
; where more than one sign imposes constraints on a single attribute.  For
; example, both determiners and verbs can constrain the AGR value of a noun
; phrase, but as soon as one of them does, we are left with a "strict" value,
; which precludes coordination with a non-identical value.  Thus we currently
; get the following incorrect pattern of grammaticality assignments:
; 
; 	a.  Abrams and the consultant
; 	b.  Abrams and the consultants
; 	c.  Abrams and this consultant
; 	d. *Abrams and these consultants
; 
; Example (b) is okay because the determiner "the" does not constrain the AGR
; value of the noun it specifies, so the NP "the consultants" will still be
; (nonstrict) [AGR 3pl*], and hence the conjoined "Abrams and the consultants"
; unifies [AGR 3sg*] and [AGR 3pl*] to give [AGR 3sg+3pl] (assuming a hierarchy
; for AGR analogous to those above for 'head' and 'bool').  Example (d) fails
; because "these" constrains its noun to be (strict) [AGR 3pl], and thus the NP
; "these consultants" will also be [AGR 3pl], and will not coordinate with
; "Abrams" because their CAT values will not unify.
;   We set the KEY of the mother to be that of the right-hand daughter, rather
; arbitrarily, but the KEY needs to be set, since many lexical types select
; an argument based on the KEY value.
;   We also need to set the type of the index on the mother, to match the types
; of the indices on the daughters.  It looks like this will force us to make the
; kind of index a feature, not just a type, but for now we wrongly make the
; index be that of the right-hand daughter.  This does not break subject-verb
; agreement for plural NPs, since we only change INDEX in this hack, not AGR.
;   And we have to make sure that the SCOPE attributes of two conjoined 
; quantified phrases are identified, but not clear how to do this.

coord_phr := binary_phrase & non_headed_phrase & 
  [ SYNSEM [ LOCAL [ CAT #cat,
 		     CONT [ INDEX #ind,
 			    MESSAGE #msg,
			    KEY #key,
			    H-STORE #hstore ],
		     AGR #agr ],
             NON-LOCAL #non-local ],
    LCONJ-DTR sign & #left &
		[ SYNSEM [ LOCAL [ CAT #cat,
				   CONT [ INDEX individual,
                                          MESSAGE #msg,
					  H-STORE #hstore ] ],
                           NON-LOCAL #non-local ] ],
    RCONJ-DTR sign & #right &
		[ SYNSEM phr_synsem &
			 [ LOCAL [ CAT #cat,
				   CONT [ INDEX individual & #ind,
					  KEY #key,
                                          MESSAGE #msg ],
                                   AGR #agr ],
			   NON-LOCAL #non-local ] ],
    C-CONT [ H-CONS <! !>,
	     H-STORE <! !> ],
    ARGS < #left, #right > ].

; ROOT_GAP_CLAUSE is for elliptical constructions consisting only of an adverb
; and some NP which would be an argument in the elided verb phrase modified by 
; the adverb.  Examples: "not Kim", "maybe Sandy"
; (Note "*Sandy bothered not Kim" but "Who did Sandy bother?  Not Kim.")
;
; Let's see if we can restrict this rule to only admit scopal adverb for MOD-DTR>

root_gap_clause := binary_phrase & non_headed_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verbal &
				[ MOD < >,
				  MOOD ind_or_mod_subj ],
			   VAL [ SUBJ *olist*,
				 SPR *olist*,
				 COMPS *olist* ],
			   MC + ],
		     CONT [ INDEX event_or_index,
			    KEY #key,
			    MESSAGE <! message !>,
			    H-STORE [ LIST #hslist,
				      LAST #hslast ] ],
		     CONJ cnil ],
	     NON-LOCAL #nloc & [ SLASH 0-dlist,
				 REL 0-dlist,
				 QUE 0-dlist ],
	     MODIFIED hasmod ],
    MOD-DTR sign &
      [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL scopal_mod &
						  [ CAT [ HEAD verb,
							  VAL.COMPS *olist* ],
						    CONT.INDEX #event ] ] >,
			       VAL.COMPS < >,
			       MC na ],
			 CONT [ TOP #hand,
				KEY.ARG #arghand ],
			 CONJ cnil ],
		 NON-LOCAL #nloc ] ],
    NONMOD-DTR sign &
	   [ SYNSEM [ LOCAL [ CAT [ HEAD n_or_p & strict_type,
				    MC na,
				    VAL [ SPR *olist*,
					  COMPS *olist* ] ],
                              CONT [ KEY #key,
				     H-STORE [ LIST #hslist,
					       LAST #hslast ] ] ],
		      NON-LOCAL #nloc ] ],
    C-CONT [ TOP #hand,
	     LISZT <! abstr_e_rel &
		      [ HANDEL #aehand,
			EVENT #event & event ] !>,
	     H-CONS <! is-one-of &
		     [ SC-ARG #arghand,
		       CANDS [ LIST < #aehand . #hslist >,
			       LAST #hslast ] ],
		       leq &
		       [ SC-ARG #arghand,
			 OUTSCPD #aehand ] !>,
	     H-STORE <! !> ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Proto-instance types

subjh_rule_decl := binary_rule_right_to_left & head_subj_phrase & decl &
  [ SYNSEM.LOCAL.CAT.MC bool ].

hcomp_rule := binary_rule_left_to_right & head_comp_phrase.

hoptcomp_rule := rule & head_opt_comp_phrase.

hmark_rule := binary_rule_left_to_right & head_marker_phrase.

extracomp_rule := rule & extracted_comp_phrase.

extrasubj_rule := rule & extracted_subj_phrase & decl & nonroot.

hspec_nc_rule := binary_rule_right_to_left & head_spec_noncompos.

hspec_c_rule := binary_rule_right_to_left & head_spec_compos.

adjh_s_rule := binary_rule_left_to_right & adj_head_scop_phrase.
adjh_i_rule := binary_rule_left_to_right & adj_head_int_phrase.

hadj_s_rule := binary_rule_right_to_left & head_adj_scop_phrase.
hadj_i_n_rule := binary_rule_right_to_left & n_adj_int_phrase.
hadj_i_h_rule := binary_rule_right_to_left & h_adj_int_phrase.

extradj_i_rule := rule & extracted_adj_int_phrase.
#|
extradj_s_rule := rule & extracted_adj_scop_phrase.
|#

fin_non_wh_rel_rule := rule & fin_non_wh_rel_cl.

inf_non_wh_rel_rule := rule & inf_non_wh_rel_cl.

; ERB (19-01-98) The single non_wh_rel_rule dream didn't come true.
; non_wh_rel_rule := rule & non_wh_rel_cl.

bare_np_rule := rule & bare_np_phrase.

n_n_cmpnd_rule := binary_rule_right_to_left & n_n_cmpnd_phr.

temp_mod_rule := rule & temp_mod_phrase.

vocative_rule := rule & vocative_phrase.

;; DPF 22-Dec-98 - Modified filler_head_rule_non_wh to require head to be 
;; VFORM fin, in order to block "*Kim hire".  The VFORM used to be fin_or_imp,
;; to allow an extraction analysis of "On Monday hire Kim", but this also
;; allowed a spurious second analysis for "On Monday tell Kim that Sandy left".
;; So a new construction for left dislocation is needed for "On Monday hire Kim",
;; one which would also admit "As for that book, who did it offend?" where a
;; (double) extraction analysis would otherwise be required.

filler_head_rule_non_wh := binary_rule_left_to_right & non_rel_clause &
                           head_filler_phrase_fin & mc_phrase & 
  [ SYNSEM.LOCAL.CONT.MESSAGE #msg,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verbal & strict_type &
				       [ INV - ],
  				  MC + ],
			    CONT.MESSAGE #msg ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD subst,
			  NON-LOCAL [ QUE 0-dlist,
				      REL 0-dlist ] ],
    C-CONT.LISZT <! !> ].
  
filler_head_rule_wh_root := binary_rule_left_to_right & 
			    head_filler_phrase_fin & wh_interrog_fin & 
                            mc_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.INV + ].

;; DPF (21-Apr-98) To block use of fill_head_wh_subj in "Kim knows who Sandy saw"
;; added constraint that filler must be [CASE NOM].

filler_head_rule_wh_subj := binary_rule_left_to_right & 
			    head_filler_phrase_fin & wh_interrog_fin & 
			    mc_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.INV -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ CASE nom ] ].

; AAC - SYNSEM missing from HEAD-DTR path in filler_head-rule_wh_nr-fin
;; DPF (21-Apr-98) Removed constraint making HEAD-DTR [MC -], since this was
;; blocking "Abrams knows who Kim saw."

filler_head_rule_wh_nr_fin := binary_rule_left_to_right & 
			      head_filler_phrase_fin & wh_interrog_fin &
                              nonroot & 
  [ SYNSEM.LOCAL.CAT.HEAD.INV - ].

filler_head_rule_wh_nr_inf := binary_rule_left_to_right & 
			      head_filler_phrase_inf & wh_interrog & nonroot & 
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
		       VAL.SUBJ < synsem >,
		       MC - ] ].

filler_head_rule_rel := binary_rule_left_to_right & rel_cl & 
			head_filler_phrase_fin &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.INDEX #ind ] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ QUE 0-dlist,
				    REL 1-dlist &
					[ LIST < #ind > ] ],
    C-CONT.MESSAGE <! propositional_rel !> ].


; ERB (05-10-96) This no longer inherits from mc_phrase because it also
; serves to make nonroot phrases, such as the bracketed phrase in: "On Tuesday
; [plan to meet Kim]".

imperative_rule := rule & head_only & imp.

; The top_coord_rule is for building the top of a (potential iterated)
; coordinate structure and the mid_coord_rule is for building intermediate
; parts of an iterated coordinate structure.  The mid_coord_rule (and the
; head/marker schema) collect the handels and indices of the conjuncts under
; the CONJ feature and passes them (with the lexically specified coordination
; relation) up from the right conjunct.  The top_coord_rule uses handels and
; liszts from the CONJ value to build the values for an n-ary coordination 
; relation.  We could skip all this feature passing if we weren't limited by 
; performance considerations to binary trees.  That is, we could build 
; coordinate structures like:					  
;       						  
;       						  
;      coord_phrase					  
;             +-			          -+	  
;             | conj_rel  		           |	  
;      LISZT  | C-HANDELS  [h1], [h2], ..., [hn]   |	  
;             | C-INDICES  [i1], [i2], ..., [in]   |	  
;             +-    		                  -+	  
;             /             /                \ 	 	  
;            /  	   /    	      \  	  
;           /   	  /     	       \ 	  
;          /    	 /      		\ 	  
;         /     	/       		 \ 	  
;      phrase        phrase    	       	       phrase	  
;      TOP   [h1]    TOP   [h2] ...            TOP   [hn]
;      INDEX [i1]    INDEX [i2]                INDEX [in]
;        |             |                	 |  
;        |             |                         |  
;       Kim          Sandy       ...            Lee 
;       			     
; then we could eliminate the features HANDELS and INDICES.  These
; feature are just for bookkeeping.  The feature LEFT, on the other hand, is
; essential to the analysis.  The LEFT value is a list of (up to) two
; elements.  The first element is the required CONJ value of the left conjunct
; in a top_coord_phrase and the second element is the CONJ value of the left
; conjunct in a mid_coord_phrase.  For example, a LEFT value of < either, or >
; permits a coordinate structure like "either Kim or Sandy or Chris or Lee".
                                  
top_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM.LOCAL.CONJ cnil,
    C-CONT [ TOP #top,
	     INDEX #ind & event_or_index,
	     LISZT <! !> ],
    LCONJ-DTR.SYNSEM.LOCAL local &
		      [ CONJ conj & #left,
			     CONT [ TOP #lhand,
				    INDEX #lind ] ],
    RCONJ-DTR.SYNSEM.LOCAL local &
		      [ CONT [ TOP #top,
			       ALTKEY [ C-ARG #ind,
					C-HANDELS *diff-list* &
					      [ LIST < #lhand . #hands >,
						LAST #hlast ],
					C-INDICES *diff-list* &
					      [ LIST < #lind . #inds >,
						LAST #ilast ] ] ],
			CONJ complex-conj &
				  [ CHEAD [ LEFT <#left, ...> ], 
				    HANDELS *diff-list* &
					    [ LIST #hands,
					      LAST #hlast ],
				    INDICES *diff-list* &
					    [ LIST #inds,
					      LAST #ilast ] ] ] ].

mid_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM.LOCAL [ CONJ complex-conj &
		      [ CHEAD #chead,
			HANDELS *diff-list* &
			        [ LIST < #lhand . #hands >,
				  LAST #hlast ],
			INDICES *diff-list* &
			        [ LIST < #lind . #inds >,
				  LAST #ilast ] ],
		   CONT.ALTKEY #altkey ],
    C-CONT [ INDEX.PNG.PN non1sg,
	     LISZT <! !> ],
    LCONJ-DTR.SYNSEM.LOCAL [ CONJ conj & #left,
			     CONT [ TOP #lhand,
				    INDEX #lind ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CONJ complex-conj &
				  [ CHEAD #chead & 
					  [ LEFT < *top*, #left > ],
				    HANDELS *diff-list* &
					    [ LIST #hands,
					      LAST #hlast ],
				    INDICES *diff-list* &
					    [ LIST #inds,
					      LAST #ilast ] ],
			     CONT.ALTKEY #altkey ] ].

root_gap_rule_premod := binary_rule_left_to_right & root_gap_clause &
  [ MOD-DTR #left &
	    [ SYNSEM.LOCAL.CAT.POSTHEAD - ],
    NONMOD-DTR #right &
	    [ SYNSEM.LOCAL.CAT.HEAD n_or_a ],
    ARGS < #left, #right > ].

root_gap_rule_postmod := binary_rule_right_to_left & root_gap_clause &
  [ MOD-DTR #right &
	    [ SYNSEM.LOCAL.CAT.POSTHEAD + ],
    NONMOD-DTR #left,
    ARGS < #left, #right > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Unary rules that define admissible outputs for the parser.

root_phrase := phrasal & rule &
  [ INFLECTED +,
    ROOT +,
    SYNSEM.LOCAL [ CAT #cat,
		   CONT [ LISZT *diff-list* &
				[ LIST #first,
				  LAST #last ],
			  KEY #key,
			  H-STORE #hstore,
			  H-CONS *diff-list* &
				[ LIST #scfirst,
				  LAST #sclast ],
			  WGLISZT #wgliszt,
			  TOP-H #top & handle ] ],
    C-CONT [ LISZT [ LIST #middle,
		     LAST #last ],
	     H-CONS [ LIST #scmiddle,
		      LAST #sclast ] ],
    ARGS < sign & [ INFLECTED +,
		    ROOT -,
                    SYNSEM.LOCAL local &
				 [ CAT #cat,
				   CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle ],
					  KEY #key,
					  H-STORE #hstore,
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle ],
					  WGLISZT #wgliszt,
					  TOP-H #top ] ] ] > ].


root_clause := root_phrase &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
				        [ MOOD ind_or_mod_subj & strict_sort],
				    VAL [ SUBJ *olist*,
					  SPR *olist*,
					  COMPS *olist* ],
				    MC + ],
			      CONT [ MESSAGE <! message & #msg & 
					      [ HANDEL #mhand,
						SOA #hand ] !>,
                                     INDEX #index,
				     TOP #hand,
				     TOP-H #mhand & handle ],
			      CONJ cnil ],
		      NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
				  REL 0-dlist & [ LIST < > ],
				  QUE 0-dlist & [ LIST < > ] ] ] ] >,
    C-CONT [ LISZT <! #msg !>,
             INDEX #index,
	     H-CONS <! !>,
	     MESSAGE <! #msg !> ] ].

frag := root_phrase &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD.VFORM inf_or_prp,
				    MC na,
				    VAL [ SUBJ *unexplist*,
					  SPR *olist*,
					  COMPS *olist* ] ],
			      CONT [ TOP-H #mhand & handle,
				     TOP #top,
				     MESSAGE <! !>,
				     INDEX #index ],
			      CONJ cnil ],
		      NON-LOCAL [ REL 0-dlist & [ LIST < > ],
				  SLASH 0-dlist & [ LIST < > ] ] ] ] >,
    C-CONT [ TOP #top,
	     LISZT <! message &
		      [ HANDEL #mhand,
			SOA #top ],
		      abstr_e_rel &
		      [ EVENT event ] !>,
             INDEX #index & event_or_index ] ].

frag_nomod := frag &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < > ] >,
    C-CONT.H-CONS <! !> ].

frag_mod_int := frag &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
			    CONT.TOP #modhand ] ] >,
    C-CONT [ LISZT <! message,
		      abstr_e_rel &
		      [ HANDEL #ehand ] !>,
	     H-CONS <! is-one-of &
		     [ SC-ARG #modhand,
		       CANDS <! #ehand !> ],
		       leq & 
		       [ SC-ARG #modhand,
			 OUTSCPD #ehand ] !> ] ].

frag_subord_cl := root_phrase &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD prep & [ PRD - ],
				    VAL [ SPR *olist*,
					  COMPS *olist* ] ],
		     CONT [ KEY subord_rel &
				[ MAIN #hand ],
			    TOP #shand,
			    TOP-H #mhand & handle,
                            INDEX #index,
			    MESSAGE <! !> ],
		     CONJ cnil ],
	     NON-LOCAL [ REL 0-dlist & [ LIST < > ],
			 SLASH 0-dlist & [ LIST < > ] ] ] ] >,
    C-CONT [ LISZT <! message &
		      [ HANDEL #mhand,
			SOA #shand ],
		      abstr_e_rel &
		      [ HANDEL #ahand,
			EVENT event ] !>,
             INDEX #index,
	     H-CONS <! is-one-of &
		       [ SC-ARG #hand,
			 CANDS <! #ahand !> ],
		       leq &
		       [ SC-ARG #hand,
			 OUTSCPD #ahand ] !> ] ].

; In VIT representation, don't want 'abstr_rel' if the only element in the
; turn is an exclamative (or a sequence of them).

frag_excl := root_phrase &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD root-marker,
				    MC + ],
			      CONT [ TOP #hand,
				     TOP-H #mhand & handle,
				     KEY excl_rel,
                                     INDEX #index,
				     MESSAGE <! !> ],
			      CONJ cnil ],
		      NON-LOCAL [ REL 0-dlist & [ LIST < > ],
				  SLASH 0-dlist & [ LIST < > ] ] ] ]>,
    C-CONT [ LISZT <! message &
		      [ HANDEL #mhand,
			SOA #hand ] !>,
             INDEX #index & event_or_index,
	     H-CONS <! !> ] ].

frag_msg := root_phrase &
  [ ARGS < [ SYNSEM lex_synsem &
		    [ LOCAL [ CAT [ HEAD root-marker,
				    VAL [ SPR *olist*,
					  COMPS *olist* ] ],
			      CONT [ MESSAGE <! relation & #msg &
					      [ SOA #mhand ] !>,
				     TOP #mhand,
				     KEY arg_rel &
					     [ ARG #index ] ],
			      CONJ cnil ],
		      NON-LOCAL [ REL 0-dlist & [ LIST < > ],
				  SLASH 0-dlist & [ LIST < > ] ] ] ] >,
    C-CONT [ LISZT <! #msg,
		      abstr_e_rel &
		      [ EVENT #event & event ],
		      abstr_rel &
		      [ EVENT event,
			ARG3 #index ] !>,
             MESSAGE <! #msg !>,
	     INDEX #event,
	     H-CONS <! !> ] ].

; Restrict to third singular subjectless finite non-auxiliary VPs.

frag_fin := root_phrase &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
					 [ AUX -,
					   VFORM fin,
					   TENSE present,
					   MOOD ind_or_mod_subj ],
				    MC na,
				    VAL [ SUBJ < unexpressed &
						 [ LOCAL.CONT.INDEX #inst &
						      [ PRONTYPE std_3 ] ] >,
					  SPR *olist*,
					  COMPS *olist* ] ],
			      AGR.PNG.PN 3sg,
			      CONT [ TOP #hand,
				     TOP-H #mhand & handle,
                                     INDEX #index,
				     MESSAGE <! !> ],
			      CONJ cnil ],
		      NON-LOCAL [ REL 0-dlist & [ LIST < > ],
				  SLASH 0-dlist & [ LIST < > ] ] ] ] >,
    C-CONT [ LISZT <! prpstn_rel &
		      [ HANDEL #mhand,
			SOA #hand ],
		      pron_rel &
		      [ HANDEL #mhand,
			INST #inst &
			       [ PRONTYPE std_pron ] ] !>,
             INDEX #index,
	     MESSAGE <! !>,
	     H-CONS <! !> ] ].

; Generalized ARG to be not only n_or_p, but subst, in order to allow, e.g.,
; "And I guess we should meet."

frag_coord := root_phrase &
  [ ARGS < phrase &
	   [ SYNSEM [ LOCAL [ CAT.HEAD subst,
			      CONJ complex-conj &
				       [ CHEAD.LEFT < cnil, ... >,
					 HANDELS #hands & 1-dlist,
					 INDICES #inds ],
			      CONT [ TOP-H #chand & handle,
				     TOP #chand,
				     INDEX #ind & event_or_index,
				     LISZT.LIST.FIRST [ C-ARG #ind,
							C-HANDELS #hands,
							C-INDICES #inds ] ] ],
		      NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
				  REL 0-dlist & [ LIST < > ],
				  QUE 0-dlist & [ LIST < > ] ] ] ] >,
    C-CONT [ TOP #chand,
	     LISZT <! !>,
             INDEX #ind,
	     MESSAGE <! !>,
	     H-CONS <! !> ] ].
