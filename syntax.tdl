;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2005
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see erg/licence.txt for conditions
;;;
;;;  syntax.tdl
;;;
;;;  The grammar rules for English
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;
;;;  $Id$



;;
;;  Phrase structure schemata
;;

; Headed phrases must obey the Head Feature Principle and the Revised Marking
; Principle.  They do not all obey the NLFP with respect to QUE, but it
; appears that all CLAUSE phrases account for QUE on mother and non-head-dtr.
; Hence moved the QUE coreference to NON-CLAUSE.  Headed phrases also identify
; the value of AGR on mother and head daughter, unlike e.g. the coordination 
; schemata which identify HEAD but not AGR.  

headed_phrase := phrase & 
  [ SYNSEM.LOCAL [ CAT [ HEAD head & #head,
                         HC-LEX #hclex ],
                   AGR #agr,
                   CONT.MSG.PSV #psv,
		   CONJ #conj ],
    HD-DTR.SYNSEM.LOCAL local &
		 [ CAT [ HEAD #head,
                         HC-LEX #hclex ],
                   AGR #agr,
                   CONT.MSG.PSV #psv,
		   CONJ #conj ] ].

non_headed_phrase := phrase.

; Most but not all phrases have SYNSEM phr_synsem; head_complement constructions
; have their SYNSEM type determined by the head-dtr.

phrasal := phrase &
  [ SYNSEM phr_synsem ].

; Head/nexus phrases pass up the REL and QUE values of the head daughter
; (which has amalgamated the REL and QUE values of its arguments a la Ivan's
; relative clause paper) to the mother.  

head_nexus_rel_phrase := headed_phrase &
  [ SYNSEM.NONLOC.REL #rel,
    HD-DTR.SYNSEM.NONLOC.REL #rel ].

head_nexus_que_phrase := headed_phrase &
  [ SYNSEM.NONLOC.QUE #que,
    HD-DTR.SYNSEM.NONLOC.QUE #que ].

head_nexus_phrase := head_nexus_rel_phrase & head_nexus_que_phrase.

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to that of the head daughter, which has already amalgamated
; the SLASH values of its arguments.  See discussion of head_nexus_phrase for
; treatment of REL and QUE.

head_valence_phrase := head_nexus_phrase &
  [ SYNSEM.NONLOC.SLASH #slash,
    HD-DTR.SYNSEM.NONLOC.SLASH #slash ].

; All phrases are either unary or binary.

basic_unary_phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS *diff-list* &
			      [ LIST #first,
				LAST #last ],
                        HCONS *diff-list* &
			      [ LIST #scfirst,
				LAST #sclast ] ],
    C-CONT [ RELS [ LIST #first,
                    LAST #middle ],
	     HCONS [ LIST #scfirst,
                     LAST #scmiddle ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS *diff-list* &
						[ LIST #middle,
						  LAST #last ],
					  HCONS *diff-list* &
						[ LIST #scmiddle,
						  LAST #sclast ] ] ],
                    IDIOM #idiom,
                    GENRE #genre ] >,
    IDIOM #idiom,
    GENRE #genre ].

norm_unary_phrase := basic_unary_phrase &
  [ SYNSEM.PUNCT #punct,
    ARGS < [ SYNSEM.PUNCT #punct ] > ].

unary_phrase := norm_unary_phrase &
  [ INFLECTD +,
    ARGS < [ INFLECTD +,
             POSSCL #posscl ] >,
    POSSCL #posscl ].

; DPF 12-Oct-01 - [POSSCL -] forces possessive clitic to the right periphery
; of any phrase (oe's fine idea for implementing the right-periphery constraint
; presented with LP constraints in Gazdar, Flickinger, Daeleman 198?).

basic_binary_phrase := phrase &
  [ SYNSEM [ LOCAL.CONT [ RELS *diff-list* &
			      [ LIST #first,
				LAST #last ],
                          HCONS *diff-list* &
			      [ LIST #scfirst,
				LAST #sclast ] ] ],
    C-CONT [ RELS *diff-list* & 
		   [ LIST #first,
		     LAST #middle1 ],
	     HCONS *diff-list* &
		   [ LIST #scfirst,
		     LAST #scmiddle1 ] ],
    ARGS < sign & [ SYNSEM [ LOCAL local &
                                   [ CONT [ RELS *diff-list* &
                                                 [ LIST #middle1,
                                                   LAST #middle2 ],
                                            HCONS *diff-list* &
                                                 [ LIST #scmiddle1,
                                                   LAST #scmiddle2 ] ] ] ],
                    POSSCL -,
                    IDIOM #idiom,
                    GENRE #genre ],
	   sign & [ SYNSEM [ LOCAL local &
                                   [ CONT [ RELS *diff-list* &
						[ LIST #middle2,
						  LAST #last ],
                                            HCONS *diff-list* &
						[ LIST #scmiddle2,
						  LAST #sclast ] ] ] ],
                    POSSCL #posscl,
                    IDIOM #idiom,
                    GENRE #genre ] >,
    POSSCL #posscl,
    IDIOM #idiom,
    GENRE #genre ].

binary_punct_phrase := basic_binary_phrase &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT #rpunct,
                   PAIRED #paired ],
    ARGS < [ SYNSEM.PUNCT.LPUNCT #lpunct ],
           [ SYNSEM.PUNCT [ RPUNCT #rpunct,
                            PAIRED #paired ] ] > ].

binary_phrase := binary_punct_phrase &
  [ INFLECTD +,
    ARGS < [ INFLECTD + ],
           [ INFLECTD + ] > ].

basic_binary_headed_phrase := headed_phrase & basic_binary_phrase &
  [ NH-DTR sign ].

binary_headed_phrase := basic_binary_headed_phrase & binary_phrase.

binary_rule_left_to_right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary_rule_right_to_left := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

basic_ternary_phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS *diff-list* &
			      [ LIST #first,
				LAST #last ],
			HCONS *diff-list* &
			      [ LIST #scfirst,
				LAST #sclast ] ],
    C-CONT [ RELS *diff-list* & 
		   [ LIST #middle3,
		     LAST #last ],
	     HCONS *diff-list* &
		   [ LIST #scmiddle3,
		     LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS *diff-list* &
						[ LIST #first,
						  LAST #middle1 ],
					  HCONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle1 ] ] ],
                    POSSCL -,
                    IDIOM #idiom ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS *diff-list* &
						[ LIST #middle1,
						  LAST #middle2 ],
					  HCONS *diff-list* &
						[ LIST #scmiddle1,
						  LAST #scmiddle2 ] ] ],
                    POSSCL #posscl,
                    IDIOM #idiom ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS *diff-list* &
						[ LIST #middle2,
						  LAST #middle3 ],
					  HCONS *diff-list* &
						[ LIST #scmiddle2,
						  LAST #scmiddle3 ] ] ],
                    POSSCL #posscl,
                    IDIOM #idiom ] >,
    POSSCL #posscl,
    IDIOM #idiom ].

ternary_phrase := basic_ternary_phrase &
  [ INFLECTD +,
    ARGS < [ INFLECTD +,
             GENRE #genre ],
           [ INFLECTD +,
             GENRE #genre ],
           [ INFLECTD +,
             GENRE #genre ] >,
    GENRE #genre ].

ternary_rule_left_to_right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] , [ KEY-ARG bool ] > ].

head_only := unary_phrase & headed_phrase &
  [ HD-DTR #head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head > ].

head_initial := basic_binary_headed_phrase &
  [ HD-DTR #head,
    NH-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil_or_numconj ],
    ARGS < #head, #non-head > ].

head_initial_infl := head_initial & binary_headed_phrase.

head_final := basic_binary_headed_phrase &
  [ SYNSEM.PUNCT.PAIRED #paired,
    HD-DTR #head & [ SYNSEM.PUNCT.PAIRED #paired ],
    NH-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #non-head, #head > ].

head_final_infl := head_final & binary_headed_phrase.

; C-CONT is the semantic contribution of the phrase itself.  The handle and
; index of the phrase come from the handle and index of C-CONT (which are
; possibly but not necessarily identified with the handle and index of one of
; the daughters).  The liszt of the phrase is the append of the liszt of
; C-CONT and the liszts of the daughters.

head_compositional := headed_phrase &
  [ C-CONT.HOOK #hook,
    HD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ].

nonhead_compositional := basic_binary_headed_phrase &
  [ C-CONT.HOOK #hook,
    NH-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ].

non_clause := head_nexus_phrase &
  [ SYNSEM.LOCAL [ CAT.MC na,
                   CONT.MSG no_msg ] ].

; ERB (05-10-97) The immediate subtypes of clause are now rel_cl and
; non_rel_clause.  The latter groups together decl, imp, and (wh_)interrog,
; which are similar in that they can't serve as modifiers and have empty REL
; values.  That type used to be (misleadingly) named msg_clause.  The
; remaining constraint (MSG message) has been moved to the type clause
; where it belongs.

clause := phrasal &
  [ SYNSEM.LOCAL [ CAT [ HEAD v_or_g_or_dadv,
                         VAL.COMPS < > ],
                   CONJ cnil ] ].

; DPF 12-Nov-03 - Renamed this from mc_phrase to mc_fillhead_phrase since
; they're the only ones inheriting from it, and it's a good place to add
; the following constraint:
; DPF 12-Nov-03 - Experimentally, make the XARG of this type be the XARG
; of the head-dtr, in order to support "on Tuesday who arrived" where the
; PP should share the handle of the VP (as if it had been extracted).
; DPF 24-oct-05 - But while the XARG for wh-subj phrases is the right handle,
; it's not for non-subj wh-phrases, so we push this constraint down to the
; two subtypes, adjusting appropriately

mc_fillhead_phrase := headed_phrase &
  [ SYNSEM [ LOCAL [ CAT.MC +,
                     CONT.MSG.PRED #pred ],
	     NONLOC [ SLASH 0-dlist,
			 QUE 0-dlist ],
             PUNCT.RPUNCT.MSGPRED #pred ] ].

; The [MC bool] constraint lives here rather than on clause because we want
; to treat relative clauses as clauses, but we need to distinguish them as the
; only clauses which can serve as modifiers.  That is, on the one hand we need
; to distinguish relative clauses from ordinary finite subj_head declaratives, 
; where both have a non-empty MOD value, but only the former can appear in a
; head-modifier phrase; and on the other hand we need to distinguish
; extracted-subject finite clauses from ordinary finite S/NP clauses, since 
; only the latter can be the dtr in a thatless-relative construction.  So the
; head-adjunct rule for nouns says the adjunct must be [MC na], and the 
; thatless_rel rule says the dtr must be [MC +].
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 26-Mar-03 - Removed reentrancy with HD-DTR..LTOP
; DPF 27-May-03 - Added reentrancy of HD-DTR's E-INDEX and C-CONT's, at least
; for coordination of S's where we want to attend to precedence relations of
; the coordinated events, which conjunctions pick up from E-INDEX not INDEX.

non_rel_phrase := head_nexus_rel_phrase &
  [ SYNSEM [ LOCAL.CONT.MSG message & #msg &
                            [ LBL #mhand,
                              ARG0 #ind ],
             NONLOC.REL 0-dlist ],
    HD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX #ind,
                    NONLOC.REL 0-dlist ],
    C-CONT [ HOOK [ LTOP #mhand,
                    INDEX #ind ],
	     RELS.LIST < #msg, ... > ] ].

non_rel_clause := non_rel_phrase & clause.

; DPF 26-Jan-01 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.
; DPF 28-Nov-02 - HOOK comes only from C-CONT

decl_phrase := non_rel_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD verb_or_frag &
                            [ VFORM fin,
                              INV -,
                              PRD -,
                              TAM basic_ind_or_mod_subj_tam ],
                       MC bool ],
    HD-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #hdtop,
                                    INDEX #hdind ],
    C-CONT [ RELS <! [ MARG #marg,
                       ARG0 #hdind ] !>,
             HCONS <! qeq & [ HARG #marg,
                              LARG #hdtop ] !> ] ].

; Added [SYNSEM..SPR < >] on imp to preserve intended constraints on modifiers
; which only attach to VP and N-bar.
; DPF 13-May-00 - Added [DTR..SUBJ..CASE acc] to prevent ordinary finite
; verbs from serving as heads, now that we want to be able to later conjoin
; imperatives and finite clauses.
; DPF 13-May-00 - Added [DTR..CONT.HOOK.INDEX ref-ind] to prevent expl-there.
; DPF 22-Feb-01 - Removed above-mentioned [SPR < >], since we've decided to 
; allow sentence-initial PP-modifiers for WH-questions (see 11-Dec-00 below),
; and we still want to be able to coordinate imperatives and WH-questions, as
; in "Give me that book and what is its title?"
; DPF 20-Oct-01 - Replaced SUBJ < > with *olist* since we were blocking e.g.
; 'Tell me your bank's name and where is it?", and made the HD-DTR's SUBJ
; be unexpressed_reg so this cannot have as input an inverted phrase.
; Also replaced INV - with -* for the same example.
; DPF 28-Nov-02 - HOOK comes only from C-CONT 

basic_imp_phrase := non_rel_clause & head_valence_phrase & head_only &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ INV -,
				VFORM imp_vform,
				TAM [ TENSE present,
				      ASPECT no_aspect,
                                      MOOD indicative ] ],
			 VAL [ SUBJ *olist* & < anti_synsem_min >,
			       SPR *olist*,
			       COMPS < > ],
			 MC bool ],
                   CONT.MSG.PRED basic_imp_m_rel ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verb,
                                  MC na,
                                  VAL [ SUBJ < unexpressed_reg &
                                               [ LOCAL.CAT.HEAD.CASE acc,
                                                 --SIND #inst & ref-ind & 
                                                           [ PNG.PN 2per ] ] >,
                                        COMPS < > ] ],
                            CONT.HOOK [ LTOP #hdtop,
                                        INDEX #hdind ] ],
                    NONLOC.QUE 0-dlist,
                    PUNCT.RPUNCT.MSGPRED basic_imp_m_rel & #pred ],
    C-CONT [ RELS <! [ PRED #pred,
                       ARG0 #hdind,
                       MARG #marg ],
                    [ PRED pronoun_q_rel,
                      RSTR #rhand,
                      ARG0 #inst ],
                    [ LBL #prohand,
                      PRED pron_rel,
                      ARG0 #inst & full_ref-ind &
                          [ PRONTYPE zero_pron,
                            SORT entity ] ] !>,
             HCONS <! qeq & [ HARG #marg,
                              LARG #hdtop ],
                      qeq & [ HARG #rhand,
                              LARG #prohand ] !> ] ].

imp_phrase := basic_imp_phrase &
  [ SYNSEM [ LOCAL.CAT.MC +,
             NONLOC.SLASH 0-dlist ] ].
                          
imp_slash_phrase := basic_imp_phrase &
  [ SYNSEM [ LOCAL.CAT.MC -,
             NONLOC.SLASH 1-dlist ] ].

; ERB (05-10-97) There is no longer a subtype of interrog for polar questions,
; as a result of streamlining the hcomp family (subordinate polar questions
; didn't inherit from the old ynq type anyway).  So interrog and its sole
; subtype wh_interrog could be collapsed into each other, but it seems clearer
; to have them separate.  I don't know what the effect of losing the constraint
; on SLASH in matrix polar questions will be.
; DPF 28-Nov-02 - HOOK comes only from C-CONT

interrog := non_rel_clause & 
  [ SYNSEM [ LOCAL.CONT.MSG.PRED basic_int_m_rel,
	     NONLOC.SLASH 0-dlist ] ].

; Restrict NH-DTR to be [HEAD subst] to avoid trying non-partitive
; determiner "whose" as filler in filler-head-wh rules.  Assume all
; wh-interrog phrases are [MOOD ind_or_mod_subj].
; DPF 29-Aug-00 - But the above [ HEAD subst ] blocked "How often did kim win",
; so removed it. 
; DPF 20-sept-04 - Removed NH-DTR..RPUNCT no_punct since we want to allow e.g.
; "Which consultant, if hired, would work?" where the first comma attaches to
; the WH-NP.
; DPF 22-jul-05 - Changed NH-DTR..RPUNCT from rbc_or_pair... to 
; comma_or_rbc_or_pair... so the above example will still work.

wh_interrog := interrog & binary_headed_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD verbal &
			      [ TAM.MOOD strict_ind_or_mod_subj ] ],
                   CONT.MSG message & [ PARAMS <! #que & param !> ] ],
    NH-DTR.SYNSEM [ NONLOC.QUE 1-dlist & [ LIST < #que > ],
                    PUNCT [ RPUNCT comma_or_rbc_or_pair_or_no_punct,
                            PNCTPR ppair ] ] ].

; This type has subtypes for filler_head.  If we assumed only
; finite subj_head phrases, and explicitly made the relevant filler_head
; phrases be finite (which we do), we wouldn't have to stipulate VFORM here.

wh_interrog_fin := wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD verb & [ VFORM fin ],
		       VAL.SUBJ *olist*,
		       MC bool ] ].

; DPF (28-Apr-99) Need this construction to get simple yes-no questions like
; "Did Kim fall", while keeping the phrase "did Kim devour" with an empty
; MSG so it can be the head of "What did Kim devour", where this filler-head
; rule introduces the interrogative message.
; DPF 26-Jan-01 - Made HEAD.INV be +* to allow coord of inv and non-inv Ss.
; DPF 13-May-01 - Added [HD-DTR..VFORM fin] - was missing.
; DPF 12-Apr-02 - Made SYNSEM..SUBJ re-entrant with HD-DTR..SUBJ
; DPF 14-Feb-05 - Experimentally, make the XARG of this type be 
; the LTOP of the head-dtr, in order to support "on Tuesday, did kim arrive?"
; where the PP should share the handle of the VP (as if it had been extracted).
; DPF 14-mar-05 - Make yesno not be a unary headed phrase in order to have it 
; not be AUX +, so can still have PP-modifiers.  This means having to duplicate
; the relevant links usually supplied by head_only_phrase.

yesno_phrase := interrog & unary_phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ INV +,
                                         VFORM fin,
                                         MOD < anti_synsem_min > ],
                           VAL [ SUBJ #subj,
                                 SPR #spr,
                                 COMPS < > ],
                           MC + ],
                     CONJ #conj & cnil,
                     AGR #agr,
                     CONT [ HOOK.XARG #hdtop,
                            MSG [ PRED #pred,
                                  PARAMS 0-dlist ] ] ],
             NONLOC [ SLASH #slash,
                      REL #rel,
                      QUE 0-dlist ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ INV +,
                                                  VFORM fin ],
                                    MC na,
                                    VAL [ SUBJ #subj & < anti_synsem_min >,
                                          SPR #spr & *olist*,
                                          COMPS < > ] ],
                              AGR #agr,
                              CONJ #conj,
                              CONT [ HOOK [ LTOP #hdtop,
                                            INDEX #index &
                                                 [ E.TENSE real_tense ] ],
                                     MSG.PSV #psv ] ],
                      NONLOC [ SLASH #slash,
                               REL #rel & 0-dlist ],
                      PUNCT.RPUNCT.MSGPRED basic_int_m_rel & #pred ] ] >,
    C-CONT [ HOOK.INDEX #index,
             RELS <! [ MARG #lbl,
                       TPC #tpc,
                       PSV #psv ],
                     message & [ LBL #lbl,
                                 PRED prpstn_m_rel,
                                 ARG0 #index,
                                 MARG #marg,
                                 TPC #tpc,
                                 PSV #psv ] !>,
             HCONS <! qeq &
                    [ HARG #marg,
                      LARG #hdtop ] !> ] ].



; Since MOD is a head feature, and projections of finite verbs can be relative
; clauses, we introduce the [MOD nbar] property directly on finite verbs, 
; rather than in the rel_cl phrase type as before.  Then we have to be sure 
; that finite VPs do not appear as postnominal modifiers, and likewise for 
; declarative S's.  The former is blocked because the head-adjunct rule 
; requires that the adjunct be [SUBJ *olist*].  The latter we block by 
; requiring that the adjunct in a head-adjunct phrase be [MC na], while making 
; declarative head_subj phrases be [MC bool].  Thus relative clauses must also 
; be [MC na].
;
; DPF 27-May-99 - Avoid making rel_cl a headed_phrase, so it can be marked as
; [PRD +] even though its 'head' daughter is necessarily {PRD -].  Will be
; easier with defaults.
; DPF 15-Apr-00 - Removed REL 0-dlist from rel_cl, so we can distinguish
; relative clauses from other clauses; e.g., to avoid allowing "I am out on t"
; as a (non-strict) root.  
; DPF 22-May-02 - Added MOD..SPR..ALTKEY explicit_quant_or_udef_noagr_q_rel
; to prevent relative clauses from modifying NP-adv's like "there" as in 
; "there to be a bookcase" while still allowing e.g. "someone to fix the sink"
; DPF 30-May-02 - But this also blocks noun-noun-compound heads, since they
; are ALTKEY no_rel as a separate hack (see n_n_compound notes).  So undo this
; constraint, and figure out something else for "there to be a bookcase".
; DPF 27-Nov-02 - Added MOD..KEY basic_nom_rel to exclude measure-NPs from
; being modified by rel clauses.
; DPF 28-Nov-02 - HOOK comes only from C-CONT: INDEX from MOD, LTOP from HDTR.
; DFP 15-Nov-03 - Removed PRD + default, since we now want to distinguish 
; non_wh_inf_subj relative clauses (which can appear as complements of 'be') 
; from the rest, ; so now make most relative clause types PRD -, and only the 
; above type PRD +.  Also removed PRD + constraint on n_adj_int_phrase's 
; non-hd dtr, in pursuit of same goal.
; Since these are only restrictive relatives, prevent comma separating them
; from head noun.
; DPF 8-apr-05 - Replaced MOD..CAT nbar_cat_min with basic_nbar_cat, not
; restricting SPR to < synsem > because we want to allow "here where Abrams
; works" but still block "from happy here".  That is, prenom adjs impose a
; stronger constraint on their modifiee than postnom modifiers, so can't use
; the same CAT value for both.

basic_rel_cl := sign &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD verb &
                         [ VFORM fin_or_inf,
                           INV -,
                           TAM.MOOD strict_ind_or_mod_subj,
                           MOD < synsem &
                                 [ LOCAL intersective_mod &
                                         [ CAT basic_nbar_cat ],
                                   PUNCT.RPUNCT comma_or_rbc_or_pair_or_no_punct ] >],
                    POSTHD +,
                    MC na ],
              CONT.MSG no_msg,
              CONJ cnil ],
      ROOT - ] ].

rel_cl := basic_rel_cl & clause &
  [ SYNSEM.NONLOC [ QUE 0-dlist,
                    REL 0-dlist ] ].

; We prevent PP adjunct extraction from feeding thatless_rel rule by requiring
; that the gap be [ MOD < > ], to block "the man kim slept walks." To handle
; "I remember the time Kim fell" maybe we can make the words "time" and
; "place" take an S/PP complement, not treat them as thatless_rels.  Also, 
; to block "*Sandy likes the man walks" and "*Sandy likes the man who thinks 
; went home", we require the S/NP to be [ MC + ], which excludes subject
; extraction for that daughter.

; The dtr is required to be [MC +] in order to block subject-extracted S/NPs
; from being admitted as relative clauses.  This constraint would be removed
; for those dialects which accept examples like "There's a man wants to talk to
; you waiting outside."

; ERB (14-12-97) I am trying to get the non-finite ones to work and to
; have only one type that will make both "The man Kim likes" and "The
; man to talk to" (but not "The man to talk to Sandy".)  The new
; constraints are: on the head-dtr HEAD verb, VFORM fin_or_inf, and
; SUBJ list(pro).  I also need to make to_c_prop HEAD verb and 
; MC +.  The latter is because we want to require MC + of the head-dtr
; to exclude subject extraction as above, adn to exclude that-declaratives
; from being the head-dtr of this cx.  (To avoid a really ugly second
; parse for "The man that Kim likes.")

; ERB (14-12-97) to_c_prop doesn't have to be a verb.  non_wh_rel_cl
; can just say HEAD verbal -- that-decls will be ruled out because they
; are MC -.  To_c_prop has to be MC + anyway because we need the
; MC + on the head-dtr in order to bar subj extractions from this
; cx.

; ERB (19-01-98) MC + moved to appropriate subtype.  See notes below.

; ERB (19-01-98) Part of what's keeping to_c_prop from serving directly
; as a modifier without first building a non_wh_rel is that hadj requires
; SUBJ *olist* and pro_ss is OPT -.  This means that non_wh_rel_cl can't
; copy up the SUBJ requirement.  I don't know what exactly the constraints
; are on the other valence features, so I am just copying them up for now.
; (Previously all of VAL was identified.)
; DPF (21-Apr-98) Make SYNSEM.COMPS be < > on mother and *olist* on daughter.

; DPF (26-05-98) Added [MOD < [ NONLOC.QUE 0-dlist] >] to the mother, to 
; block thatless relatives modifying WH-partitives, as in the unwanted NP 
; "how many books are t"

; DPF (06-Sept-98) Added reg_nom_rel constraint on MOD..KEY
; to avoid infinitival relatives modifying temporal nouns as in "we should 
; meet next week to celebrate".  
; DPF (27-Jan-99) Updated this to non_temp_nom_rel.
; DPF 09-Jan-00 - Added HD-DTR..MODIFD notmod_or_rmod to block 
; adverb-initial relative clauses as in "The book apparently Sandy bought is 
; new"
; DPF 17-Mar-01 - Moved [ MOD..KEY non_temp_nom_rel ] to inf_non_wh_rel_cl rule
; only, since we want phrases like "the day he arrived".
; DPF 20-Mar-01 - Added MOD..MODIFD notmod_or_lmod to prevent thatless-rels
; from modifying already-modified nominals, especially with a full relative
; clause: *the book that I bought you have is long"
; DPF 26-Mar-01 - But this is too strong, also blocking "the city in Germany I 
; wanted to visit was Berlin".  So instead use RPERIPH feature.
; DPF 11-Sept-01 - Added [MOD..SPR synsem] to block e.g. 'there to be arriving'
; DPF 24-Apr-03 - Also removed MOD..KEY non_temp_nom_rel from inf_non_wh_rel_cl
; since it prevents e.g. 'a good time to meet would be tomorrow'  We'll see 
; what it was blocking.

; (ERB 2003-08-08) Add a type for instrument infinitival relatives,
; like "the Fedex number to return my package.  These are similar
; to ordinary infinitival relatives, except that we need to hallucinate
; a SLASH value and a _with_p_rel, and make the index of the SLASH
; be the ARG2 of the _with_p_rel.  Since non_wh_rel_cl introduces
; a SLASH value, the new type can't inherit from it directly.  Add
; a supertype basic_non_wh_rel_cl that has the rest of the constraints
; from non_wh_rel_cl.  Hmmm... it seems that there might be no need
; for that slash value, as non_wh_rel_cl just takes the KEY and INDEX
; and zeros it out.  I have no idea what we'd put in for that KEY, and
; the INDEX can be identified with the ARG2 of the_with_p_rel.

; (ERB 2003-08-11) Move constraint on HOOK.LTOP down to daughters,
; since I'm having the instr_inf_non_wh_rel_cl introduce the prpstn_m_rel.

basic_non_wh_rel_cl := unary_phrase & rel_cl &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				  TAM #tam,
				  AUX #aux,
				  INV #inv,
				  MOD < [ NONLOC.QUE 0-dlist,
                                          MODIFD.RPERIPH na_or_- ] >,
                                  KEYS.KEY #key ],
			   VAL [ SUBJ < >,
				 SPR < >,
				 COMPS < > ] ] ],
             NONLOC.SLASH 0-dlist ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verbal &
					 [ VFORM #vform,
					   TAM #tam,
					   AUX #aux,
					   INV #inv,
                                           KEYS.KEY #key ],
				    VAL.COMPS < > ],
			      CONJ cnil ],
                      NONLOC [ QUE 0-dlist,
                               REL 0-dlist ],
		      MODIFD notmod_or_rmod,
                      PUNCT.LPUNCT no_punct ] ] > ].

; DPF 05-sept-05 - Added identity of MOD..SPR..ALTKEY and SLASH..SPR..ALTKEY 
; to make visible properties that block e.g. 'six cabins have been' where 
; 'have been' underwent npadv extraction (extradj-t)

non_wh_rel_cl := basic_non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD 
     [ MOD < [ LOCAL.CAT [ HEAD.KEYS.KEY #mkey,
                           VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.ALTKEY #akey ] >],
               --SIND #ind ] > ],
    C-CONT.HOOK.XARG #ind,
    ARGS < [ SYNSEM 
            [ LOCAL.CONT.MSG message & [ PRED prpstn_m_rel ],
              NONLOC.SLASH 1-dlist &
              [ LIST < [ CAT [ HEAD noun &
                                    [ PRD -,
                                      MOD < >,
                                      KEYS.KEY #mkey ],
                              VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.ALTKEY #akey]>,
                                    COMPS < > ] ],
                         AGR #ind,
                         CONT.HOOK.INDEX #ind ] > ] ] ] > ].

; ERB (19-01-98) As much as it hurts, I don't think it is possible
; to avoid differentiating a inf and fin non_wh_rel_cl.  The facts of
; (Standard American) English seem to be that finite non-wh relatives
; do not allow extraction of the highest subject, but non-finite ones
; do:
;
; (1) Kim likes the book Sandy bought.
; (2) *Kim likes the person buys books.
; (3) Kim found a book to buy for Sandy.
; (4) Kim found a person to buy Sandy a book.
;
; A simple hack involving case won't work, because embedded subjects
; can be extracted in the finite case:
;
; (5) Sandy likes the program Kim thinks works.
;
; Another tack is to treat (3) and (4) above differently, where
; the to in (3) is to_c_prop and the to in (4) is to_c_nonprop.
; The motivation for this is that the former allows a discourse
; PRO interpretation, while the latter doesn't, so it is tempting
; to says that the latter doesn't involve PRO at all.  The idea is
; that to_c_prop builds a non_wh_rel which can then serve as a 
; modifier, while to_c_nonprop has a MOD value to start off with,
; and can be a modifier directly once it builds a hcomp.  To_c_nonprop
; would bind the index of its MOD value to that of its subject.
;
; However, this is unsatisfactory for several reasons.  First, the
; ones like (4), built with to_c_nonprop, have no message for the
; relative.  Second, since MOD is a head feature now, to_c_prop must
; also be MOD < nbar > .  Once this is true, there is no obvious way to
; keep it from serving directly as a modifier without building a
; non_wh_rel. Finally, we run into problems with lexical SLASH
; amalgamation.  Something has to be said about the subject value of
; to_c_nonprop, otherwise it runs the risk of having a non-terminated
; SLASH value.  However, on the one hand, to_c_nonprop is the to of
; raising constructions, so sometimes its SUBJ must be able to be
; canonical_synsem, and on the other, on this analysis, it can also
; head modifiers in which its SUBJ goes unexpressed.  To take care
; of the latter, something must be said in the lexical entry, but
; unexpressed is not compatible with canonical_synsem.
;
; The only other possibility I can see is to let the subject extraction
; apply lower, as in to [like Sandy] in [a person to like Sandy], but
; this requires letting subject extraction apply to base forms, which
; would most likely be a royal mess.
;
; In sum, given the facts of SAE and the rest of the grammar as
; it is, (3) and (4) must be built with the same to.  In (3) there
; is an extracted complement and in (4) there is an extracted 
; subject.  In the case of infinitival non_wh_rels, the grammar
; doesn't care.  In the case of finite ones, it does.
;
; DPF 10-dec-03 - Restricted MOD nbar-synsem to QUE 0-dlist, to block in-situ
; wh-modifiers preceding thatless relatives like 'a friend of whom I approved' 
; DPF 13-nov-05 - Added ALT2KEY no_rel to prevent these from appearing in 
; comparatives/equatives, as in "kim arrives as soon as browne arrives."

fin_non_wh_rel_cl := non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD 
                 [ PRD -,
                   MOD < [ LOCAL.CAT.HEAD.KEYS [ KEY nonpro_or_refl_or_num_rel,
                                                 ALT2KEY norm_rel ],
                           PUNCT.RPUNCT no_punct ] >,
                   KEYS.ALT2KEY no_rel ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD verb &
                                       [ VFORM fin,
                                         MOD < [ LOCAL.CAT nbar_cat_min,
                                                 NONLOC.QUE 0-dlist ] > ],
                                  VAL.SUBJ < anti_synsem_min >,
                                  MC - ],
                            CONT.HOOK [ LTOP #ltop,
                                        INDEX.E.TENSE real_tense ] ] ] >,
    C-CONT [ HOOK.LTOP #ltop,
             RELS <! !>,
	     HCONS <! !> ] ].

basic_inf_non_wh_rel_cl := non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.KEYS.KEY nonpro_rel ] >,
    ARGS < [ SYNSEM.LOCAL [ CAT.HEAD comp & [ VFORM inf ],
                            CONT.MSG message ] ] >,
    C-CONT.HCONS <! !> ].

inf_non_wh_rel_cl := basic_inf_non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD -,
    ARGS < [ SYNSEM.LOCAL [ CAT.VAL.SUBJ *procons*,
                            CONT.HOOK.LTOP #ltop ] ] >,
    C-CONT [ HOOK.LTOP #ltop,
             RELS <! !> ] ].

; DPF 26-Nov-03 - Added MODIFD notmod_or_rmod to enable blocking of spurious
; analysis for purposive "kim is probably to remain"

inf_non_wh_subj_rel_cl := basic_inf_non_wh_rel_cl &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT.VAL.SUBJ < unexpressed >,
                              CONT.HOOK.LTOP #vpltop ],
                      MODIFD notmod_or_rmod ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event ],
             RELS <! arg1_relation &
                     [ LBL #ltop,
                       PRED expected_event_rel,
                       ARG0 #event,
                       ARG1 #vpltop ] !> ] ].

; (ERB 2003-08-08) Type for instrumental infinitival relative clauses.
; See notes at basic_non_wh_rel_cl above.  Consider adding a type
; to capture similarities between constraints on this type and 
; inf_non_wh_rel_cl.

; (ERB 2003-08-08) Switch to nonprop to phrases so that I can still
; get at the handle for the verb relation within the clause (which
; should be the ARG1 of the with_p_rel).  The other options (using
; to_c_prop_le) were to cheat and get that handle through the KEY
; (illegal per the alegbra) or to introduce a slash value on the
; VP (?), which raises the problem of keeping those VP/NPs out of
; every other context.  
;
; This requires also switching from *prolist* to < synsem > as
; the constraint on the SUBJ of the daughter.  Maybe need to
; constrain NONLOC values of this synsem?  -- that seemed
; to reduce supurious ambiguity some.
;
; Indeed, I need to make it < unexpressed > in order to constrain
; the NONLOC values properly and keep the elided 'to' out of this
; construction.
; DPF 8-jun-04 - Added ARGS..KEY nonaux_event_rel to exclude elided "to", as
; in "the tenth to the eleventh"

instr_inf_non_wh_rel_cl := basic_non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD -,
                            MOD < [ --SIND #index ] > ],
    ARGS < [ SYNSEM phr_synsem &
                    [ LOCAL [ CAT [ HEAD comp & [ VFORM inf,
                                                  KEYS.KEY nonaux_event_rel ],
				    VAL.SUBJ < unexpressed_reg > ],
			      CONT [ HOOK [ LTOP #handle,
                                            INDEX #event,
                                            XARG #xarg ],
                                     MSG no_msg ] ],
                      NONLOC.SLASH 0-dlist ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    XARG #xarg ],
             RELS <! message & 
		   [ LBL #ltop,
                     PRED prpstn_m_rel,
                     ARG0 #pind,
		     MARG #marg ],
                   prep_relation &
		   [ LBL #handle,
                     PRED with_p_rel,
                     ARG0 #pind,
		     ARG1 #event,
		     ARG2 #index ] !>,
	     HCONS <! qeq &
		    [ HARG #marg,
		      LARG #handle ] !> ] ].

; DPF 2-Jul-02 - Added MOD..RPERIPH - to block analysis of "Abrams hired"
; while allowing "anyone hired"
; DPF 25-aug-04 - Removed ARGS..MODIFD notmod_or_rmod since this blocked e.g.
; 'the consultants recently hired by Abrams'
; DPF 3-mar-05 - Added [LEX -] to prevent 'dog chased'.  Now treat
; 'anyone hired' like 'anyone angry' and live with the resulting spurious
; ambiguity of 'anyone angry at Kim'

red_rel_cl := unary_phrase & basic_rel_cl &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [ MODIFD.RPERIPH -,
                                          LOCAL.CAT.HEAD.KEYS.KEY nonpro_rel,
                                          --SIND #ind ] >,
                                  PRD -,
                                  KEYS.KEY #key ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ] ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      REL 1-dlist,
                      QUE 0-dlist ],
             LEX #lex ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verbal &
					 [ VFORM non_fin,
					   PRD +,
                                           KEYS.KEY #key ],
                                    VAL [ SUBJ < unexpressed_reg >,
                                          COMPS < > ] ],
			      CONT [ HOOK [ LTOP #vpltop,
                                            INDEX #vpind &
                                                 [ E [ TENSE no_tense,
                                                       ASPECT.PERF - ] ],
                                            XARG #ind ],
                                     MSG no_msg & [ PSV #psv ] ],
			      CONJ cnil ],
                      NONLOC [ SLASH 0-dlist,
                               QUE 0-dlist,
                               REL 0-dlist ],
                      LEX #lex,
                      PUNCT.LPUNCT pair_or_no_punct ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    XARG #ind ],
             RELS <! message &
                     [ LBL #ltop,
                       PRED prpstn_m_rel,
                       ARG0 #vpind,
                       MARG #marg,
                       PSV #psv ] !>,
             HCONS <! qeq & [ HARG #marg,
                              LARG #vpltop ] !> ] ].

; DPF 26-jun-03 - Added rule for making participial phrases into virtual
; subordinate phrases, as in "kim arrived devouring chocolate' analogous to 
; "Kim arrived while devouring chocolate"
; For now, exclude passives using VFORM: too much annoying ambiguity for 
; too little value.
; DPF 10-dec-03 - Tried restricting the  mother to POSTHD +, but this loses
; 'looking at Abrams, kim smiled" - would like to disallow pre-VP modification,
; but not yet clear how to do that.
; DPF 22-apr-04 - Corrected handle-linking to get the right semantics
; (making "kim arrived singing" analogous to "Kim arrived while singing").
; This rule should be generalized to include at least depictive adjectives
; and maybe also passive participles if we can find an argument that we need
; both analyses for e.g. "kim arose assisted by her nurse" - but cf. "Kim
; arose unassisted (by her nurse)" which suggests "assisted" may be adjectival,
; so maybe we don't have to open the door to also let in passives here.
; DPF 18-jul-04 - Added MOD..MSG message to reduce ambiguity, as in
; 'Kim is interviewing'
; DPF 27-jul-04 - Try allowing passives, but require that these phrases be
; preceded by a comma to reduce ambiguity.
; DPF 20-aug-04 - Generalize this rule to allow depictive adjectives as well,
; as in "Kim left, angry at Sandy", but split into two, in order to enforce
; comma separation from modified phrase.
; DPF 30-sept-04 - Since we want "Having arrived, Kim arose." but still want
; to block "*Kim is having arrived", we can't require the dtr to be PRD +,
; so here we compromise, and allow sentence-initial "having..." but not (yet)
; sentence-final, since it isn't clear how to exclude non-predicative adjs.
; DPF 7-mar-05 - Removed identification of MOD..AGR and ARGS..CONT.XARG, which 
; was motivation by e.g. "Seeing Kim, we left", but is incompatible with 
; expletive main clauses, like "Given his record, it was obvious that he would 
; be convicted."
; DPF 12-mar-05 - Constrained XARG of dtr to be non_expl-ind, to exclude 
; expletive it-taking phrases, such as "Kim arrived, possible that Abrams 
; arose"
; DPF 29-mar-05 - Re 18-jul-04, this blocks e.g. "After measuring the height
; using a ruler, we emerged", so let's try removing this hack to see if we
; can live with the added (necessary) ambiguity.
; DPF 27-sept-05 - Try making SPR empty for these phrases, to avoid ambiguity
; for e.g. "just laughing" where was attaching to mother as well as daughter.

subconj_prdp_phr := unary_phrase &
  [ SYNSEM basic_subconj_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ MODIFD.LPERIPH na_or_- ] >,
                                  KEYS.ALT2KEY no_rel ],
                           VAL [ COMPS < >,
                                 SPR < > ] ],
                     CONJ #conj ],
             NONLOC [ SLASH 0-dlist,
                      REL 0-dlist,
                      QUE 0-dlist ],
             LEX #lex ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD v_or_a & 
                                         [ TAM.TENSE no_tense,
                                           MOD < [ LOCAL intersective_mod ] >],
                                    VAL [ SUBJ *olist*,
                                          SPR *olist*,
                                          COMPS < > ],
                                    MC na,
                                    POSTHD + ],
                              CONT [ HOOK [ LTOP #vpltop,
                                            INDEX #vpind,
                                            XARG non_expl-ind ],
                                     MSG no_msg & [ PSV #psv ] ],
			      CONJ cnil & #conj ],
		      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                               QUE 0-dlist,
                               REL 0-dlist ],
                      LEX #lex ] ] >,
    C-CONT [ RELS.LIST < relation &
                         [ PRED subord_rel,
                           SUBORD #cltop ], 
                         message & 
                         [ LBL #cltop,
                           PRED prpstn_m_rel,
                           ARG0 #vpind,
                           MARG #marg,
                           PSV #psv ], ... >,
             HCONS <! qeq & [ HARG #marg,
                              LARG #vpltop ] !> ] ].

; DPF 23-aug-04 - Further divide the s-initial variant to require a comma for
; the adjectival ones, though not for the verbal ones, to avoid unwanted
; analysis for "happy dogs bark" but allow "arriving in Paris we smiled",
; and further to exclude pre-VP modification.  And further exclude extraction,
; to avoid unwanted analysis for 
; "the women [SBCNJ evaluated [S/NP their own staffs]]".

subconj_prdp_init_phr := subconj_prdp_phr &
  [ SYNSEM [ LOCAL.CAT [ POSTHD -,
                         HEAD.MOD < [ LOCAL [ CAT.VAL.SUBJ *olist*,
                                              CONT.MSG.PSV #psv ],
                                      MODIFD notmod_or_rmod,
                                      NONLOC.SLASH 0-dlist,
                                      PUNCT.RPUNCT.MSGPRED #pred ] > ],
             PUNCT [ LPUNCT pair_or_no_punct,
                     RPUNCT comma_or_pair_or_no_punct ] ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #ind ],
             RELS <! [ LBL #sltop ],
                     relation,
                     message &
                     [ LBL #ltop,
                       PRED message_m_rel & #pred,
                       ARG0 #ind,
                       MARG #sltop,
                       PSV #psv ] !> ] ].
                         
subconj_prdp_a_init_phr := subconj_prdp_init_phr &
  [ SYNSEM [ LOCAL.CAT.POSTHD -,
             PUNCT.RPUNCT comma_punct ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adj &
                                   [ PRD + ] ] > ].

subconj_prdp_v_init_phr := subconj_prdp_init_phr &
  [ SYNSEM [ LOCAL.CAT.POSTHD -,
             PUNCT.RPUNCT comma_or_no_punct ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD verb &
                                   [ VFORM pas_or_prp ] ] > ].

; Avoid spurious reading for "Kim is arriving" by requiring the modified
; phrase to be ALTKEY non_ellipt_rel, excluding elided auxiliaries.  Separate
; variant includes elided VPs if modified is RPUNCT comma_or_pair_punct.
; DPF 29-mar-05 - Also restrict final passives to preceding comma,
; Also try restricting these final guys to VP-modifying only.

subconj_prdp_final_phr := subconj_prdp_phr &
  [ SYNSEM.LOCAL.CAT [ POSTHD +,
                       HEAD.MOD <[ LOCAL.CAT [ HEAD.KEYS.ALTKEY non_ellipt_rel,
                                               VAL.SUBJ *synlist* ] ] > ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.PRD + ] >,
    C-CONT [ HOOK.LTOP #ltop,
             RELS <! [ LBL #ltop ], relation !> ] ].

subconj_prdp_prp_phr := subconj_prdp_final_phr &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.VFORM prp,
                      PUNCT.LPUNCT no_punct ] ] > ].

subconj_prdp_pas_lex_phr := subconj_prdp_final_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_punct ] >,
    ARGS < [ SYNSEM lex_synsem &
                    [ LOCAL.CAT.HEAD.VFORM pas ] ] > ].

subconj_prdp_pas_phr := subconj_prdp_final_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ NONLOC.SLASH 0-dlist ] >,
    ARGS < [ SYNSEM phr_synsem &
                    [ LOCAL.CAT.HEAD.VFORM pas ] ] > ].

subconj_prdp_pas_sl_phr := subconj_prdp_final_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ NONLOC.SLASH 1-dlist,
                                  PUNCT.RPUNCT comma_or_pair_punct ] >,
    ARGS < [ SYNSEM phr_synsem &
                    [ LOCAL.CAT.HEAD.VFORM pas ] ] > ].

subconj_prdp_adj_phr := subconj_prdp_final_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PUNCT.RPUNCT comma_or_no_punct ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD adj,
                      PUNCT.LPUNCT no_punct ] ] > ].

subconj_prdp_ellip_phr := subconj_prdp_phr &
  [ SYNSEM.LOCAL.CAT [ POSTHD +,
                       HEAD.MOD < [ LOCAL.CAT.HEAD.KEYS.ALTKEY ellipsis_rel,
                                    PUNCT.RPUNCT comma_or_pair_punct &
                                                 [ MSGPRED #pred ] ] > ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #ind ],
             RELS <! [ LBL #sltop ],
                     relation,
                     message &
                     [ LBL #ltop,
                       PRED message_m_rel & #pred,
                       ARG0 #ind,
                       MARG #sltop ] !> ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.PRD + ] > ].

; The version of the Non-local Feature Principle here assumes that there will
; only be one value on the SLASH list.  To handle multiple gaps, we'll need
; more general set-manipulation functions.  This version also doesn't use a
; distinction between INHERITED and TO-BIND non-local features.  Instead, it
; treats non-local features like valence features.

; ERB (17-10-96) in order to get "Kim knows who to ask" under the current
; hacks (i.e., no PRO), I need a head_filler_phrase that takes something like
; "to ask" (i.e., VFORM in, SUBJ nomp) as its head.  So I am making a
; separate parallel type that will only be inherited by the embedded wh
; nonfinite questions.

; N.B. Since all head_filler constructions inherit from type clause, which
; inherits from head_compositional, this type does not (though it could,
; redundantly).

; Added [ SUBJ *prolist* ] constraint to NH-DTR, to ensure termination
; of the QUE and REL attributes now that we're doing lexical threading, and
; PPs (among others) wouldn't otherwise know if they were QUE empty or not.
;
; (DPF 23-Aug-98) But if we make the SUBJ *prolist*, then we can't get 
; extraction of raising predicates, as in "how does Kim look", since the
; subject of the "how" adjective is identified with that of "look".  Hence
; we move this constraint to the extracted-adjunct rule, since it seems to
; hold true for adjuncts, but not for complements.
; DPF 23-Sept-99 - Made mother be POSTHD +, to avoid clauses as prenominal
; modifiers.
; DPF 11-Dec-00 - Removed SPR <> from mother, to allow sentence-initial PP
; modifiers for WH-questions.
; DPF 03-nov-03 - Moved SPR < anti_synsem > to head_filler_phrase so it does
; not hold for relative clause head-filler phrases, to block analysis for e.g.
; 'when we arrive in Berlin' as RELS+PP.
; DPF 18-jun-04 - Replaced parent basic_binary_phrase with binary_phrase to
; get PUNCT attributes inherited.  This predicts the INFLECTD features that
; were stipulated, but also adds propagation of GENRE, which might cause
; surprises.
; DPF 21-jul-04 - Moved HD-DTR.QUE 0-dlist from this type to the non-fin and
; non-wh subtypes, in order to allow in-situ WH phrases in combination with
; WH phrases, as in "who hired whom", and to allow ?-punctuation (which also
; introduces a non-empty QUE in order to trigger subjh-q with interrogative
; semantics for "Abrams hired Browne?").

basic_head_filler_phrase := binary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ VAL.COMPS < >,
			   POSTHD + ],
		     CONJ cnil ],
	     NONLOC.SLASH 0-dlist,
             PUNCT.PNCTPR #ppair ],
    ARGS < [ SYNSEM [ LOCAL #slash & local &
			    [ CAT.VAL [ SUBJ *antisyn_or_prolist*,
					COMPS < >,
					SPR *olist* ],
			      CTXT.ACTIVATED + ],
		      NONLOC.SLASH 0-dlist ] ],
           [ SYNSEM [ LOCAL [ CAT [ HEAD verbal,
                                    VAL.COMPS < > ],
                              CONT.HOOK.INDEX.--TPC + ],
		      NONLOC [ SLASH 1-dlist &
					[ LIST [ FIRST #slash,
						 REST < > & #last ],
					  LAST #last ],
                               REL 0-dlist ],
                      PUNCT [ LPUNCT no_punct,
                              PNCTPR #ppair ] ] ] > ].

; DPF 21-jul-04 - Removed parent head_nexus_que_phrase since this didn't allow
; multiple-wh clauses like "who hired whom", and it wrongly implied that there
; would be filler-head constructions where the mother still had a non-empty
; QUE value.

head_filler_phrase := basic_head_filler_phrase & head_final &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < anti_synsem_min >,
             NONLOC.QUE 0-dlist ] ].

basic_head_filler_phrase_fin := head_filler_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ *olist* & < anti_synsem_min >,
    HD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ VFORM fin_or_imp,
                                              TAM.TENSE real_tense ],
				VAL.SUBJ *olist* ] ].

head_filler_phrase_fin := basic_head_filler_phrase_fin & head_final_infl &
  [ NH-DTR.SYNSEM.PUNCT.RPUNCT comma_or_rbc_or_pair_or_no_punct,
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM fin ].

head_filler_phrase_inf := head_filler_phrase & head_final_infl &
  [ HD-DTR.SYNSEM [ LOCAL [ CAT.HEAD verbal & [ VFORM inf ],
                            CONT.MSG message & [ PRED propositional_m_rel ] ],
                    NONLOC.QUE 0-dlist ],
    NH-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct ].

; N.B. Since all head_subj_phrase constructions inherit from type clause,
; which inherits from head_compositional, this type does not (though it could,
; redundantly).
;
; 1-May-96 (DPF) Restricted head to be verb only, to block spurious parses
; where NP modifed by PP was also analyzed as its subject.
; 12-Jun-96 (RPM) Allow verbal gerunds to head head/subj phrases.
; DPF (28-Apr-99) Added INV - to head-dtr, since most auxiliary verbs are
; underspecified for INV.
; DPF 27-May-99 - Constrained subj to be unslashed, in order to block, e.g.
; "the consultant that kim hired slept fell".
; DPF 23-Sept-99 - Made mother be POSTHD +, to avoid clauses as prenominal
; modifiers.
; DPF 26-Jan-01 - Changed HEAD.INV + to HEAD.INV +* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.
; DPF 2-Feb-01 - Changed SPR of mother to *olist*, to allow coordination with
; head-filler phrases which are [ SPR < anti_synsem > ].
; DPF 20-Oct-01 - Changed SUBJ of mother to *olist*, to allow coordination with
; imperatives which are SUBJ *olist* so they can coordinate with interrogs.
; DPF 18-Nov-04 - Removed NH-DTR..SLASH.LIST < > since this was unnecessary
; (see 27-May-99), and blocked "People who think we arrive arise".
; DPF 10-may-05 - We won't block comma-marked subjects at present, since in
; informal text genres, they sometimes occur (as in the first two examples in
; Rondane :).  Maybe consider for an example of genre-specific constraints,
; excluding such marking in edited text.

head_subj_phrase := head_nexus_rel_phrase & head_final_infl &
  [ SYNSEM [ LOCAL [ CAT.VAL [ COMPS < >,
                               SPR #spr,
                               SPEC #spec ],
                     CONJ cnil ],
             PUNCT.PNCTPR #ppair ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ < #synsem >,
                                      SPR #spr,
                                      COMPS < >,
                                      SPEC #spec ],
                                MC na ],
                    PUNCT [ LPUNCT pair_or_no_punct,
                            PNCTPR #ppair ] ],
    NH-DTR.SYNSEM #synsem & canonical_synsem &
		 [ LOCAL [ CAT [ HEAD subst,
				 VAL [ SUBJ *olist_or_prolist*,
				       COMPS < >,
				       SPR *olist* ] ] ],
        	   NONLOC [ SLASH 0-dlist,
                            REL 0-dlist ],
                   PUNCT [ LPUNCT pair_or_no_punct,
                           RPUNCT comma_or_rbc_or_pair_or_no_punct,
                           PNCTPR ppair ] ] ].

; A head/comps phrase is a phrase that combines a head with something selected
; for by the COMPS feature.  Head/comps phrases come in two denominations:
; head/comp phrases and head/marker phrases.  A head/comp phrases is like the
; usual VP rule, and its head (and therefore the whole phrase) must be CONJ
; cnil.  A head/comp phrase is unmarked for MC, but will inherit a MC
; specification from its head daughter.  Head/marker phrases takes the place
; of the P&S94 head/marker rule.  The head must be lexical (i.e., of type
; "word") and CONJ non-cnil. 
;
; DPF 10-Aug-99 - Moved the propagation of ALTKEY from head_marker-phrase up to
; head_comp_or_marker_phrase.
; DPF 2-Jun-02 - Added HS-LEX -* (see discussion of HS-LEX): needed to distinguish
; "*the children very angry arrived" from "the children very angry at kim arrived"
; DPF 23-Apr-03 - Added propagation of MODIFD value from head to mother,
; reminded by spurious ambiguity for "thirty twenty-two chairs arrive"
; DPF 13-Oct-03 - Removed HS-LEX - from mother, since it prevented coordination
; of adjectives, which are HS-LEX +

head_comp_or_marker_phrase := head_valence_phrase & head_compositional &
                              basic_binary_headed_phrase &
  [ SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ MC #mc,
			   VAL [ SUBJ #subj,
				 COMPS #comps,
				 SPR #spr,
                                 SPEC #spec ] ],
                     CONT.MSG #hmsg ],
             MODIFD #modif,
             PUNCT.PNCTPR #ppair ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD subst_or_func,
                                  MC #mc,
                                  VAL [ SUBJ #subj,
                                        COMPS < #synsem . #comps >,
                                        SPR #spr,
                                        SPEC #spec ] ],
                            CONT.MSG #hmsg ],
                    MODIFD #modif ],
    NH-DTR.SYNSEM #synsem & canonical_synsem &
           [ PUNCT.PNCTPR #ppair ] ].

; ERB (03-10-96) hcomp_nc is no longer marked as non-clause because some of them
; are "clauses" in the sense of having a message (e.g., "Kim wants [to leave]").
; This is actually in need of revision: we are probably going to need to 
; distinguish between to-headed hcomp_ncs which are selected by equi predicates 
; or otherwise have PRO subjects and whether-headed hcomp_ncs on the one hand, 
; and all other instances on the other with a restriction equivalent to SUBJ 
; list(PRO) in order to block "To rain is difficult" etc.  I think this should 
; be possible without resorting to anything like VFORM whether to identify cases
; -- see Ivan's interrogatives paper.

; ERB (05-10-97) In order for one single hcomp rule to build things like "how
; about on Friday", the restriction HEAD subst needs to be removed from this
; rule, or else root-marker needs to inherit from subst.  I am opting for the
; former.

; DPF (25-Aug-98) The head_comp_phrase is not marked POSTHD + since we want to
; build "twenty-one" using this rule, but still allow it to serve as a
; prenominal modifier  as in "twenty-one books".  So instead we use the PRED
; feature to distinguish prenominal from postnominal modifiers, and conspire to
; make all PRED - entries have an empty COMPS list.  
; DPF 01-Feb-03 - Generalized CONJ value to cnil_or_numconj, to allow this
; rule to build "and three" as in "two hundred and three".
; DPF 10-dec-03 - But now the hmarkatom rule is taking care of these guys.
; DPF 10-jul-04 - Tried making complement LPUNCT no_punct to avoid 
; 'Kim hired, Abrams'. But this fails for "January 1st, 1984".  So remove, 
; and expect heads to declare the expected LPUNCT value for their complements.
; DPF 17-jul-04 - Let's try making the head LPUNCT no_punct, to avoid e.g.
; 'Kim, hired, Sandy.'
; DPF 25-aug-04 - Can't have [HD-DTR..RPUNCT no_punct] since for two-compl
; verbs, the first complement might contain an appositive ending in a comma,
; as in "Kim sent [Abrams, the manager,] to Browne.  So it seems that we
; have to live with ambiguity of "Kim sent Abrams, the manager."
; DPF 7-mar-05 - Changed parent type from head_initial_infl to head_initial
; since we want "the Berlin - Paris route" where "Berin - Paris" is built
; compositionally but is still compatible with [INFL -].  Keep nonhd-dtr as
; INFLECTD +.
; DPF 31-mar-05 - Re 25-aug-04, tried changing appos rule to underspecify 
; RPUNCT value, so this HCOMP rule can return to excluding a comma-marked head,
; which should help with spurious ambiguity.  But if appos rule drops the
; information from its RPUNCT, no longer no if it was marked with final comma,
; or clause_punct, etc - unacceptable, so we'll just live with generating
; 'Kim handed Abrams, the book.'

head_comp_phrase := head_comp_or_marker_phrase & head_initial &
                    binary_punct_phrase &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT.POSTHD #ph,
		     CONJ cnil ],
	     LEX #lex ],
    HD-DTR [ INFLECTD #infl,
             SYNSEM [ LOCAL.CAT [ POSTHD #ph,
                                  HC-LEX #lex ],
                      PUNCT [ LPUNCT hyphen_or_pair_or_no_punct,
                              RPUNCT comma_or_rbc_or_colon_or_pair_or_no_punct,
                              PNCTPR ppair ] ] ],
    NH-DTR.INFLECTD +,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

; DPF 18-jun-04 - For now, stipulate propagation of PUNCT, since this type
; doesn't inherit from binary_phrase (due to INFLECTD?).  But maybe can make
; this a binary_phrase?
; DPF 24-may-05 - We put the PAIRED value of the nh-dtr into 'storage' in the
; head-marker phrase's PNCTPR attribute, which is not used during the
; construction of the coordinate phrase.  Then the top-coord rule 'retrieves'
; this value from its right conjunct's PNCTPR and makes it once again the
; value of PAIRED on the full conjoined phrase.  Affected example:
; only want the nadj_rc rule (and not the nadj_rc_pr rule) to build the rel
; clause in 'Devito manages a programmer Abrams interviewed and Browne hired.'
; DPF 22-jul-05 - This move creates a little problem for the odd lexical
; entry "etc." which acts syntactically like a head-marker phrase.  But then
; "etc.?" should undergo the qmark infl rule, leaving it with a non-empty
; PAIRED value, and then it won't conjoin properly because that PAIRED value
; should be 'stored' in PNCTPR.  For now, add lexical entry for "etc.?"

basic_head_marker_phrase := head_comp_or_marker_phrase &
  [ SYNSEM [ LOCAL [ CAT [ HC-LEX #hclex,
                           HS-LEX #hslex ] ],
	     NONLOC #nonlocal,
	     LEX #lex,
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct,
                     PAIRED #paired,
                     PNCTPR #nhpaired ] ],
    HD-DTR word_or_lexrule &
           [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                            RPUNCT hyphen_sgl_or_rbc_or_no_punct,
                            PAIRED #paired ] ],
    NH-DTR.SYNSEM [ LOCAL.CAT [ HC-LEX #hclex,
                                HS-LEX #hslex ],
                    NONLOC #nonlocal,
                    LEX #lex,
                    PUNCT [ RPUNCT #rpunct,
                            PAIRED #nhpaired ] ] ].

head_marker_phrase := basic_head_marker_phrase &
  [ SYNSEM.LOCAL.CONJ real-conj & 
                      [ CREL #rel ],
    HD-DTR.SYNSEM.LOCAL.CONJ.CREL #rel ].

head_marker_phrase_event := head_marker_phrase & head_initial &
  [ INFLECTD +,
    SYNSEM.LOCAL [ CONT.HOOK.INDEX conj_event,
                   CAT.POSTHD #ph ],
    HD-DTR [ SYNSEM.LOCAL [ CAT [ HEAD subst_or_adv,
                                  VAL.COMPS < [ ROOT #root ], ... > ],
                            CONJ.CREL [ R-HNDL #rhand,
                                        R-INDEX #ind ],
                            CONJ complex-conj ],
             INFLECTD + ],
    NH-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD subst_or_adv &
                                       [ KEYS.KEY event_or_degree_or_no_rel ],
                                    POSTHD #ph ],
                              CONT.HOOK [ LTOP #rhand,
                                          INDEX #ind ] ],
                      ROOT #root ],
             INFLECTD + ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].
    
; DPF 13-oct-05 - While two-part phrasally headed phrases typically conjoin 
; with a comma-marked left conjunct, lexically-headed phrases do not, so 
; use the same CPUNCT constraint as for nominal phrases to restrict commas
; to informal ones for simple lexical coordination.
; DPF 31-oct-05 - VP and S coordination may allow informal commas after the 
; conjunction as in "Kim arrived and, Sandy arose", especially with 'dangling'
; conjuncts as in "Or, you can stay."

head_marker_phrase_e_phr := head_marker_phrase_event &
  [ NH-DTR.SYNSEM.LOCAL.CAT.POSTHD + ].

head_marker_phrase_a_lex := head_marker_phrase_event &
  [ SYNSEM.LOCAL.CONJ.CPUNCT ppair,
    HD-DTR.SYNSEM.PUNCT.RPUNCT hyphen_sgl_or_no_punct,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD adj,
                              POSTHD - ] ].

; DPF 6-Dec-02 - Added ident. of HD-DTR..KEY.R-INDEX with NHD..INDEX
; here in the construction since nouns can no longer identify their E-INDEX
; with their INDEX (which was wrong anyway, since the E-INDEX should be of
; type event).  A related re-entrancy appears for the left daughter in the
; nom_coord_rule definition.
; DPF 10-may-05 - Added CPUNCT ppair on mother to block comma-marked
; left conjunct in simple two-part nominal coordination: 
; '*Abrams, and Browne arrived'. This constraint is ignored in any
; multi-part coordination.
; DPF 30-jul-05 - But as noted elsewhere, this also prevents coordination
; of longer NPs.  So we let those in using informal_comma_punct.
; DPF 29-sept-05 - To allow "The friendliness and helpfulness of Norwegians
; is apparent", we don't identify AGR.PNG with HOOK.INDEX.PNG on this basic
; type, but only for NPs.  Thus we'll allow "the dog and cat is barking.",
; which is undesirable, but then we'll also get "my friend and confidante is
; here." which we also want.

basic_head_marker_phrase_nom := head_marker_phrase & head_initial &
  [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.ALT2KEY #alt2key,
                   CONT.HOOK.INDEX conj_non_expl-ind,
                   CONJ.CPUNCT ppair,
                   AGR [ PNG #png,
                         DIV #div ] ],
    HD-DTR.SYNSEM [ LOCAL [ AGR [ PNG #png,
                                  DIV #div ],
                            CONJ complex-conj & [ CREL.R-INDEX #ind ] ],
                    PUNCT.RPUNCT hyphen_sgl_or_no_punct ],
    NH-DTR.SYNSEM.LOCAL [ CAT.HEAD supnoun &
                                   [ KEYS.ALT2KEY #alt2key ],
                          CONT.HOOK.INDEX #ind & ref-ind ] ].

; DPF 26-aug-04 - Generalized NH-DTR.HEAD from noun to noun_or_nomger to
; get e.g. "His singing and dress were unusual".  Restrict nbar coord to
; HOOK.INDEX 3per, since we're not enforcing full PNG constraint (see
; above.

head_marker_phrase_nbar := basic_head_marker_phrase_nom &
  [ INFLECTD #infl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PN 3per,
    HD-DTR [ INFLECTD + ],
    NH-DTR [ INFLECTD #infl,
             SYNSEM.LOCAL [ CAT [ HEAD noun_or_nomger,
                                  VAL.SPR < synsem & 
                                            [ LOCAL.CAT.HEAD det &
                                             [ KEYS.KEY quant_or_wh_rel ]] > ],
                            CONT.HOOK [ LTOP #ltop,
                                        INDEX #ind ] ] ],
    C-CONT [ RELS <! [ PRED udef_q_rel,
                       ARG0 #ind,
                       RSTR #rstr ] !>,
	     HCONS <! qeq & [ HARG #rstr,
                              LARG #ltop ] !> ] ].

head_marker_phrase_nom := basic_head_marker_phrase_nom &
  [ INFLECTD +,
    SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG #png,
                   AGR.PNG #png ],
    NH-DTR.SYNSEM.LOCAL.CAT.VAL.SPR *olist*,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ],
    ARGS < [ INFLECTD + ],
           [ INFLECTD + ] > ].

; For 'both', 'neither', etc.
head_marker_phrase_atomic := basic_head_marker_phrase & head_initial_infl &
  [ HD-DTR.SYNSEM [ LOCAL.CONJ atomic-conj,
                    PUNCT.RPUNCT hyphen_sgl_or_no_punct ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

; Skip an optional complement as long as there is still another obligatory
; complement on the list (here assumed to be the second complement, since it's
; hard and perhaps unnecessary to allow the obligatory one to appear in an
; arbitrary position).
; DPF (27-Apr-99) Note that this formulation unfortunately does not get
; "Kim bet Abrams won" with the first two optional complements missing, since
; the rule forces the complement after the omitted one to be expressed.
; DPF 7-Apr-01 - Added MC reentrant with head-dtr's MC value.
; DPF 7-Apr-01 - Removed POSTHD + since it prevented pre_S if-clauses.
; DPF 22-May-01 - Instead, pass up POSTHD from dtr to mother.
; DPF 18-Dec-01 - Moved ALTKEY identity from this type to the non-noun 
; subtypes, to allow noun-opt-comp to override, in order to prevent n-n-cmpnd
; from feeding that rule, while allowing that rule to feed n-n-cmpnd.
; DPF 2-June-2 - Moved ALTKEY identity back since have better mechanism for
; blocking the above feeding relationship for compounds.

basic_head_opt_comp_phrase := head_valence_phrase & norm_unary_phrase & 
                              head_compositional &
  [ INFLECTD #infl,
    POSSCL #posscl,
    SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
                                 SPEC #spec ],
                           MC #mc,
                           POSTHD #ph,
                           HS-LEX #hslex ],
                     CONJ cnil,
                     CONT.MSG #msg ],
             MODIFD #mod ],
    HD-DTR #head & 
           [ INFLECTD #infl,
             POSSCL #posscl,
             SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
					  SPR #spr,
                                          SPEC #spec ],
                                    MC #mc,
                                    POSTHD #ph,
                                    HS-LEX #hslex ],
                              CONT.MSG #msg ],
                      MODIFD #mod,
                      PUNCT.LPUNCT pair_or_no_punct ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ],
    ARGS < #head > ].

head_opt_comp_phrase := basic_head_opt_comp_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS #comps,
             LEX #lex ],
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL.CAT [ HEAD.KEYS.KEY event_rel,
                                  VAL.COMPS 
                                      < unexpressed & [ OPT + ] . #comps > ],
                      LEX #lex ] ] ].

; DPF 21-Mar-01 - Removed SPR..KEY quant_or_wh_rel since this blocked pumping
; for partitives, as in "very little arrived"
; Changed HEAD from noun to n_or_p for "worth"
; DPF 3-Jun-02 - Constraint of lex_synsem on dtr prevents noun-noun-cmpnds
; from undergoing this rule, to avoid spurious ambiguity for e.g. "book cover",
; forcing noptcomp to apply before compounding.  Identify ALTKEY of mother and
; dtr to block e.g. "*the almost all books arrive" (and then move this identity
; back up to parent opt_comp phrase type).
; DPF 9-Oct-02 - Added re-entrancy of LEX on mother and dtr in order to allow
; n_hour_le's to be unmarked for synsem type, but propagate their (unusual)
; [LEX -*] specification to block "an eleven meeting" but still allow "an 
; eleven pm meeting".

noun_opt_comp_phrase := basic_head_opt_comp_phrase &
  [ SYNSEM basic_lex_synsem &
           [ LOCAL.CAT.VAL.COMPS #comps,
             LEX #lex ],
    HD-DTR [ SYNSEM basic_lex_synsem &
                  [ LOCAL.CAT 
                          [ HEAD n_or_p,
                            VAL.COMPS 
                                 < [ OPT +,
                                     NONLOC 
                                         [ SLASH 0-dlist,
                                           QUE 0-dlist,
                                           REL 0-dlist ] ] . #comps > ],
                    LEX #lex ] ] ].

; ERB (19-01-98) If to_c_prop can undergo subject extraction (see notes
; near non_wh_rel) then this can't require HEAD v_or_p.  That constraint
; will be moved to extracted_comp_phrase.  Extrasubj will say 
; HEAD verbal.
; DPF 10-Jun-99 Changed SYNSEM..MOOD from indicative to ind_or_mod_subj, since
; we weren't getting "Abrams would have hired Browne"
; DPF 26-Nov-03 - Identified MODIFD value of mother and daughter, to preserve
; e.g. whether a VP has been pre-modified so we can still block "probably to
; remain" as the spurious analysis of purposive infinitival in "Kim is 
; probably to win"

extracted_arg_phrase := head_valence_phrase & head_only &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.TAM.MOOD ind_or_mod_subj,
			   HC-LEX - ],
                     CONT.HOOK.INDEX.--TPC +,
		     CONJ cnil ],
	     LEX -,
             MODIFD #modif ],
    HD-DTR.SYNSEM [ LOCAL.CONJ cnil,
                    MODIFD #modif ] ].

; DPF (28-Apr-99) Added identity of MSG for mother and head-dtr, since it
; wasn't being propagated.

; *** We still need special extraction rules for fronting CPs and VPs.

extracted_comp_phrase := extracted_arg_phrase & head_compositional &
  [ SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
				 COMPS #comps ],
			   MC #mc ],
                     CONT.MSG #msg ],
	     LEX #lex ],
    HD-DTR [ SYNSEM 
	       [ LOCAL [ CAT [ HEAD v_or_g_or_p,
			       VAL [ SUBJ #subj,
				     SPR #spr,
				     COMPS < gap &
					     [ LOCAL [ CAT.HEAD mobile,
                                                       CONT.HOOK.INDEX #ind ],
                                               --SIND #ind & non_expl,
					       NONLOC.SLASH #slash ]
					     . #comps > ],
			       MC #mc,
			       HC-LEX #lex ],
                         CONT.MSG #msg ],
		 NONLOC.SLASH #slash ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

; Assume only finite clauses have explicit subjects that can be extracted, and
; restrict these to indicative verbs (not subjunctives). 

; ERB (19-01-98) We are assuming that there is subject extraction
; in "just the teacher [to talk to Sandy]" so the VFORM must be 
; loosened here.  See notes near non_wh_rel.  Also, HEAD verbal.
; What's to block whether from undergoing subject extraction?
; (cf. *Sandy Kim knows whether to elect Clinton president.)
; DPF (27-Apr-98) Made HD-DTR..HEAD be strict_type to block non-verbal heads
; from unifying (e.g. "red")
; DPF (1-Apr-99) Made mother be SPR < > to block spurious modification by PPs.
; DPF 27-sept-04 - Re: 19-01-98, this relaxation of VFORM incorrectly predicts
; that e.g. '*Kim, it is possible to arrive' is well-formed, analogous to
; 'Kim, it is possible to hire.'  So constrain the infinitival subtype here
; to only produce phrase type that will be used for relative clauses, by
; requiring that the SUBJ be < unexpressed & OPT - >.
; DPF 12-nov-05 - Re: 1-Apr-99, changed this to SPR < anti_synsem_min > since
; we do want to allow pre-modification of these phrases, at least in relative
; clauses, and anyway the usual head_adj_int rule requires the head to be
; MSG no_msg, so we no longer need the SPR < > constraint for this.

extracted_subj_phrase := extracted_arg_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM ind_or_mod_subj_tam,
                       VAL [ SPR < anti_synsem_min >,
                             COMPS < > ],
                       MC - ],
    HD-DTR.SYNSEM 
             [ LOCAL.CAT [ HEAD verbal & [ VFORM fin_or_inf ],
                           VAL [ SUBJ < gap &
                                        [ LOCAL #local &
                                                [ CONT.HOOK.INDEX #ind ],
                                          --SIND #ind & ref-ind ] >,
                                 COMPS < > ],
                           MC na ],
               NONLOC.SLASH.LIST < #local > ] ].

; DPF 28-Nov-02 - HOOK comes only from C-CONT in decl, since it introduces
; a message.
; DPF 12-Nov-03 - Experimentally, make the XARG of this phrase be the LTOP
; of the head-dtr, in order to support "on Tuesday who arrived" where the
; PP should share the handle of the VP (as if it had been extracted).

#|
extracted_subj_phrase_fin := extracted_subj_phrase & decl_phrase &
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < >,
                   CONT [ HOOK.XARG #ltop,
                          MSG [ PRED prop-or-ques_m_rel,
                                TPC #xarg ] ] ],
    HD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.VFORM fin,
                                VAL.SUBJ < [ LOCAL.CAT.HEAD.CASE nom ] > ],
                          CONT [ HOOK [ LTOP #ltop,
                                        XARG #xarg ],
                                 MSG no_msg ] ] ].
|#
extracted_subj_phrase_fin := extracted_subj_phrase & decl_phrase &
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < >,
                   CONT [ HOOK.XARG #ltop,
                          MSG.PRED prop-or-ques_m_rel ] ],
    HD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.VFORM fin,
                                VAL.SUBJ < [ LOCAL.CAT.HEAD.CASE nom ] > ],
                          CONT [ HOOK.LTOP #ltop,
                                 MSG no_msg ] ] ].

extracted_subj_phrase_inf := extracted_subj_phrase & head_compositional &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < unexpressed & [ OPT - ] >,
    HD-DTR.SYNSEM.LOCAL [ CAT.HEAD.VFORM inf,
                          CONT [ HOOK.XARG #xarg,
                                 MSG message & [ TPC #xarg ] ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].


; For specifiers of nouns (det and non-det), adjectives and prepositions.
; Also for specifiers of determiners, as in "almost all".  Needs to be modified
; to also allow "exactly which books".
; DPF 3-Oct-99 - Added rentrancy for hd-dtr's HEAD value and the SPEC..HEAD of
; the non-hd-dtr, to allow e.g. the degree-specifier "that" to appear with
; adverbees but not PPs.
; DPF 10-Feb-01 - Changed mother's ALTKEY to come from head-dtr rather than
; nonhead-dtr, in order to get right semantics for "Kim 's" of "Kim's book".
; Couldn't find the reason (if any) why we were getting it from the nonhead.
; DPF 16-Oct-01 - The reason we need it from the head is compositional 
; numerals, where the ALTKEY of the head contains the 'highest' rel (often 
; times_rel or plus_rel).
; DPF 13-May-01 - Changed HD-DTR..COMPS < > back to *olist*, since adj's
; cannot always discharge their optional complement (especially since that
; would mean the pred-copula would have to require its complement to be
; COMPS < >, which means VP's would have to always discharge theirs, which
; would eliminate the utility of the *olist* in general.
; DPF 17-Dec-01 - Made POSTHD of mother be determined by specifier dtr,
; in order to get contrast of "*every book very old was sold" and "every book
; less than six months old was sold"
; DPF 2-Jun-02 - Removed parent "phrasal" since the LEX feature of head-spec
; phrases is now determined by the feature HS-LEX of head-dtr, analogous to
; HC-LEX feature.  See introduction of HS-LEX in fundamentals.tdl.
; DPF 24-Apr-03 - Why is head-dtr [MC na]?  This prevents e.g. "I went just to
; see kim".  Also blocks "I arrived two weeks after kim left".  Remove, and
; see what happens.
; DPF 26-aug-04 - FIX? make NH-DTR be INFLECTD +?  No, can't, since need this
; rule for "ten foot high (wall)"  But make it so for head_spec_phrase.
; DPF 7-mar-05 - Changed from INFLECTD + on mother and head-dtr to simply
; identifying INFL, since we want "the Berlin - Paris route" where
; "Berin - Paris" is built compositionally but is still compatible with 
; [INFL -].  But make the head_spec_phrase still be hd-dtr INFLECTD +.

basic_head_spec_phrase := head_valence_phrase & head_final & 
                          binary_punct_phrase &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
                                 COMPS #spcomps,
                                 SPR #spr ],
                           MC na,
                           POSTHD #ph ],
                     CONT.MSG #msg ],
	     MODIFD #modif,
             LEX #lex,
             PUNCT.PNCTPR #ppair ],
    HD-DTR [ INFLECTD #infl,
             SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                      VAL [ SUBJ #subj,
                                            COMPS < > & #comps,
                                            SPR < #synsem & 
                                                canonical_synsem . #spr > ],
                                      HS-LEX #lex,
                                      POSTHD #hdph ],
                                CONT [ HOOK #hdhook,
                                       MSG #msg ],
                                CONJ cnil ],
                      MODIFD #hmodif,
                      PHON #phon,
                      --SIND #semind,
                      PUNCT [ LPUNCT pair_or_no_punct,
                              PNCTPR #ppair ] ] ],
    NH-DTR [ SYNSEM #synsem &
                   [ LOCAL [ CAT [ VAL 
                                   [ SPEC < [ LOCAL [ CAT [ HEAD #head,
                                                            VAL.COMPS #comps,
                                                            POSTHD #hdph ],
                                                      CONT.HOOK #hdhook ],
                                              MODIFD #hmodif,
                                              PHON #phon,
                                              --SIND #semind ] >,
                                     COMPS #spcomps ],
                                   POSTHD #ph ] ],
                     MODIFD #modif,
                     PUNCT [ LPUNCT pair_or_no_punct,
                             RPUNCT pair_or_no_punct ] ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

; DPF 15-Sept-03 - Added NH-DTR.MOD < > to exclude numbers

head_spec_phrase := basic_head_spec_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC #spec,
    HD-DTR [ INFLECTD +,
             SYNSEM.LOCAL.CAT.VAL [ COMPS < >,
                                    SPEC #spec ] ],
    NH-DTR [ INFLECTD +,
             SYNSEM.LOCAL 
                     [ CAT [ HEAD.MOD < >,
                             VAL.SPEC < synsem &
                                        [ LOCAL.CAT.HEAD noun_or_gerundive ] >,
                             MC na ],                                   
                       CONT.HOOK #hook & [ INDEX individual_min,
                                           XARG handle ] ] ],
    C-CONT.HOOK #hook ].

; For numbers and degree specifiers, and also for x_to_y adjectives, as in
; 'the mid to upper nineties'
head_spec_hc_phrase := basic_head_spec_phrase & head_compositional &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC #spec,
    HD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC #spec,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY compos_spec_rel ].

; The SYNSEM value of the head of a head/modifier phrase is token-identical to
; the MOD value of the adjunct daughter.  Additionally, the adjunct daughter
; must be complement-saturated.  The SLASH value is not set in the basic
; schema, but rather in each of the subtypes: in head_mod_phrase_simple the
; SLASH value is passed up from both daughters, but in the
; extracted_adj_phrase the SLASH value of the mother is effectively the
; adjunct that would have modified the head.
; 
; DPF (6-Sept-98) Constrained HD-DTR to have empty QUE as well as REL, to 
; block adverbs modifying "how", "where", etc.  
; DPF (4-Mar-99) But this unfortunately also blocks "which consultant who fell"
; since making "consultant" be QUE empty means via lexical threading that its
; specifier must also be QUE empty.  So we would have to find some other way of
; blocking modifiers of "where" etc, but perhaps the generalization is wrong
; anyway; consider "right where", "exactly when" "just how".

; DPF 25-Aug-99 - Removed CONJ cnil from HD-DTR, to allow "oh, and your name"
; DPF 6-Apr-01 - Mysteriously, it seems that we have not been copying up ALTKEY
; from head-dtr to mother for head-mod phrases.  It showed up in failure to 
; notice that "first seven" had a non-empty ALTKEY, which was intended to 
; block this as left member of n-n-compound.

;; DPF 10-Feb-01 - Removed REL 0-dlist from head-dtr, since (a) head-nexus 
;; phrases pass the REL value from the head dtr to the mother; and (b) this 
;; was blocking e.g. "the chair whose first three legs fell off arrived" 
;; where the adj-N construction forces REL 0-dlist rather than passing up the 
;; spr's REL.
; DPF 2-Jun-02 - Added HS-LEX - (see discussion of HS-LEX) - needed if want to 
; distinguish "*the children singing are famous" from "the children singing in
; Berlin are famous" - may not be desirable.
; DPF 30-Apr-03 - The reentrancy of E-INDEX in head-dtr and C-CONT is dubious
; at best, and gives rise to the odd result that in "Kim sleeps in Berlin"
; both the ARG0 and the ARG1 attributes of the _in_rel are identified.  This
; looks like a possible violation at least in spirit of the semantic algebra,
; so why is it here?  More research is needed.
; DPF 25-Jun-03 - Restored [CONJ cnil] on mother (cf 25-Aug-99), since don't
; want "and Browne hired" as a head-adj constituent.
; DPF 09-may-04 - Removed HD-DTR..KEY independent_rel since it prevents e.g.
; 'Kim relies you know on Sandy'
; DPF 14-mar-05 - Added identity of POSTHD on hd-dtr and mother, to block
; e.g. adj "in" from subconj_prdp as in "kim arrived [in [on Tuesday]]"

head_mod_phrase := head_nexus_rel_phrase &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
                                 SPR #spr ],
                           POSTHD #ph,
                           HS-LEX - ],
                     CONJ cnil ],
             MODIFD hasmod ],
    HD-DTR.SYNSEM.LOCAL.CAT [ VAL [ SUBJ #subj,
                                    SPR #spr ],
                              POSTHD #ph ] ].

; Added restriction on adjunct's specifier to prevent unsaturated nouns
; (like 'afternoon') from serving as modifiers before they pick up their
; specifiers.

; head_mod_phrase_simple takes the MSG value from its non-head dtr's 
; MSG.  Most modifiers identify their message with their
; modifiee's message, but tags don't.  (Modifiers cannot simply identify their
; own message with that of their modifiee, since some signs (like "not")
; can be either a modifier or an argument, and hence need a message value 
; independent of that of their modifiee.

; SLASH of mother is append of SLASH lists for the two daughters.  In principle
; this allows distinct slash values on the two daughters, without enforcing
; parasitic gaps.  So we restrict the LIST.REST value of SLASH on the mother to
; be the empty list -- a hack which works in PAGE since not strictly typed, but 
; what we really want to say is that SLASH on the mother is either a singleton 
; list, or the empty list.

;; 15-Jun-98 Removed this hack, since it doesn't work in the LKB, and is wrong
;; anyway, failing to generalize to e.g. head-complement structures, which
;; present the same problem of distinct SLASH values coming from each of the
;; two daughters.

;; Removed identification of hddtr's MSG with mother's - wrong for tags,
;; at least.  Should be handled independently by each modifier.

;; DPF 26-Feb-99 - Added [ KEY independent_rel] to NH-DTR to distinguish
;; modifier phrases from verb-particle constructions, where the particle's
;; KEY is specialized to a subtype of 'selected_rel'.

;; DPF 7-Apr-99 - Moved C-CONT..INDEX to the scopal and intersective variants,
;; since intersectives take their index from the head-dtr, while scopals take
;; it from the non-head-dtr.  The crucial case for intersectives is for
;; participial modifiers of nouns, like "manager interviewing Browne" where
;; the index of the modifier is an event variable.

;; DPF 7-Jun-99 - Removed REL 0-dlist from nonhead, to allow slashed finite
;; rels to keep the REL value on their mother, so it can be distinguished from
;; ordinary clauses.

;; DPF 8-May-00 - MC of the mother is now determined by the modifier dtr, not
;; the head-dtr, in order to make discourse adverbs like "yes" produce MC +
;; phrases. 

;; DPF 10-Feb-01 - Removed REL 0-dlist from mother, since (a) head-nexus 
;; phrases get the REL value from the head dtr; and (b) this was blocking e.g.
;; "the chair whose first three legs fell off arrived" where the adj-N
;; construction forces REL 0-dlist rather than passing up the spr's REL.
; DPF 3-Jul-02 - Added re-entrancy of HD-DTR..LEX and NH-DTR..MOD..LEX
; to enable modifiers to constrain the lex/phr distinction of the modifiee.
; DPF 26-Apr-03 - Added identification of XARG for head-dtr and non-hd-dtr for
; scopal modifier rules, which was already done for the (non-nominal)
; intersective modifier rules - the adj_n_int_phrase cannot make this identity
; since nouns declare the XARG value to be 'nothing'.
; DPF 03-nov-03 - Changed MC propagation back to coming from head-dtr, since
; want to be able to attach modifiers (which might be MC na) to main clauses,
; as in "Kim laughed, especially because sandy stayed".

basic_head_mod_phrase_simple := head_mod_phrase & basic_binary_headed_phrase &
                                binary_punct_phrase &
  [ SYNSEM [ LOCAL [ CAT.MC #mc,
                     CONT.MSG #msg ],
             ROOT #root ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                  VAL #val,
                                  POSTHD #ph,
                                  HC-LEX #hclex,
                                  MC #mc ],
                              AGR #agr,
			      CONT [ HOOK #hook,
                                     MSG #hmsg ],
			      CONJ #conj ],
                    NONLOC #nonloc,
                    MODIFD #modif,
                    --SIND #semind,
                    ROOT #root,
                    LEX #lex,
                    PUNCT.RPUNCT #rpunct ],
    NH-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD head &
					     [ MOD < synsem &
                                                     [ LOCAL local & 
						       [ CAT [ HEAD #head,
                                                               VAL #val,
                                                               POSTHD #ph,
                                                               HC-LEX #hclex,
                                                               MC #mc ],
							 AGR #agr,
							 CONT [ HOOK #hook,
                                                                MSG #hmsg ],
							 CONJ #conj ],
                                                       NONLOC #nonloc,
                                                       MODIFD #modif,
                                                       --SIND #semind,
                                                       ROOT #root,
                                                       LEX #lex,
                                                       PUNCT.RPUNCT #rpunct]>],
                                    VAL.SPR *olist* ],
                              CONJ cnil,
                              CONT.MSG #msg ] ] ],
    C-CONT.RELS <! !> ].


head_mod_phrase_simple := basic_head_mod_phrase_simple &
  [ C-CONT.HCONS <! !> ].


;; DPF (12-Jul-98) Changed POSTHD on mother from that of head-dtr to simply -
;; since want to prevent this rule from feeding head-adj rule.
;; DPF (25-Sept-98) Since we're no longer treating all head-complement phrases
;; as POSTHD -, we have to strengthen the constraint on the non-head-dtr's 
;; COMPS value to be truly the empty list, not just *olist*.

adj_head_phrase := basic_head_mod_phrase_simple & head_final &
  [ SYNSEM [ LOCAL.CAT.POSTHD #ph,
	     NONLOC [ SLASH #slash,
                      QUE *diff-list* &
                            [ LIST #qfirst,
                              LAST #qlast ] ],
	     MODIFD lmod & [ LPERIPH #periph ],
             LEX #lex,
             PUNCT.PNCTPR #ppair ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ POSTHD #ph,
                                VAL.COMPS < > ],
                    NONLOC [ SLASH #slash,
                             QUE *diff-list* &
                                   [ LIST #qmiddle,
                                     LAST #qlast ] ],
                    LEX #lex,
                    PUNCT [ LPUNCT pair_or_no_punct,
                            PNCTPR #ppair ] ],
    NH-DTR.SYNSEM [ NONLOC [ SLASH 0-dlist & [ LIST < > ],
                             REL 0-dlist & [ LIST < > ],
                             QUE *diff-list* &
                                   [ LIST #qfirst,
                                     LAST #qmiddle ] ],
                    MODIFD.LPERIPH #periph,
                    PUNCT 
                     [ LPUNCT pair_or_no_punct,
                       RPUNCT comma_or_rbc_or_hyphen_or_pair_or_no_punct ] ] ].

; ERB (07-11-96) Non-head dtr is QUE 0-dlist to rule out "*Leaving when do you
; think would bother Sandy?" or "*Your house where did the government foreclose
; on?"  Not on higher type because "How long a book did you write?"
; DPF 09-dec-03 Removed QUE 0-dlist since we now want in-situ WH-phrases like
; "you are leaving when".  The above examples with in-situ WH with inversion
; are being blocked now as desired - details on how?
; DPF 04-may-04 Changed COMPS < > to COMPS #comps from head-dtr, since we want 
; to allow modification of lexical heads (e.g. for "would + rather (not)")
; DPF 12-mar-05 Removed SYNSEM..POSTHD + since no longer used to constrain
; interaction of pre- and post-head modifiers, and since it gets in the way of
; treatment of fragments such as "well, actually, Abrams" where want to build
; "well, actually" as phrase.

head_adj_phrase := basic_head_mod_phrase_simple & head_initial_infl & phrasal &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS #comps,
	     NONLOC [ SLASH *diff-list* &
			       [ LIST #first,
				 LAST #last ],
                      QUE *diff-list* &
                            [ LIST #qfirst,
                              LAST #qlast ] ],
             MODIFD rmod & [ LPERIPH #periph ] ],
    HD-DTR.SYNSEM [ LOCAL [ CAT.VAL.COMPS #comps,
                            CONT.HOOK.INDEX.--TPC #tpc ],
                    NONLOC [ SLASH *diff-list* &
                                   [ LIST #middle,
                                     LAST #last ],
                             QUE *diff-list* &
                                   [ LIST #qmiddle,
                                     LAST #qlast ] ],
                    MODIFD notmod_or_rmod & [ LPERIPH #periph ],
                    PUNCT.RPUNCT comma_or_rbc_or_pair_or_no_punct ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ POSTHD +,
                                  VAL.COMPS < > ],
                            CONT.HOOK.INDEX.--TPC #tpc ],
                    NONLOC [ SLASH *diff-list* &
                                   [ LIST #first,
                                     LAST #middle ],
                             QUE *diff-list* &
                                   [ LIST #qfirst,
                                     LAST #qmiddle ] ] ] ].

; DPF (07-17-98) Split head_adj_phrase and adj_head_phrase into two each,
; one for intersective modifiers and one for scopal modifiers, in order to
; get desired results for recursive modification as in "apparently difficult
; problem" (cf. Kasper '98).  This split is also used in generation, where
; we delay construction of intersective modification, but not scopal.

scopal_mod_phrase := head_mod_phrase_simple & nonhead_compositional &
  [ HD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NH-DTR.SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL scopal_mod &
                                                  [ CONT.HOOK.XARG #xarg ] ] >,
                                VAL.COMPS < > ],
                          CONT.HOOK #hook & [ XARG #xarg ] ],
    C-CONT.HOOK #hook ].

isect_mod_phrase := head_mod_phrase_simple & head_compositional &
  [ HD-DTR.SYNSEM.LOCAL.CONT [ HOOK.LTOP #hand,
                               MSG no_msg ],
    NH-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
                          CONT.HOOK.LTOP #hand ] ].

basic_adj_head_scop_phrase := adj_head_phrase & scopal_mod_phrase & 
                              head_final_infl &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.PRD -,
                              POSTHD - ] ].
    
adj_head_scop_phrase := basic_adj_head_scop_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CONT.MSG message,
    NH-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct ].

; For non_sentential heads - to avoid '*Kim before Abrams arrived arose'
adj_head_scop_xp_phrase := basic_adj_head_scop_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CONT.MSG no_msg,
    NH-DTR.SYNSEM [ LEX +,
                    PUNCT.RPUNCT rbc_or_pair_or_no_punct ] ].

; The paired variant - see comment 7-may-05 for n_adj_relcl_phrase.
adj_head_scop_prpnct_phrase := adj_head_scop_xp_phrase &
  [ SYNSEM.PUNCT.PAIRED #paired,
    NH-DTR.SYNSEM.PUNCT [ PNCTPR #pnctpr,
                          PAIRED #paired ],
    HD-DTR.SYNSEM.PUNCT [ PAIRED #pnctpr,
                          PNCTPR #paired ] ].

; Non-paired variant - propagate comma or clause-punct onward
adj_head_scop_nopair_phrase := adj_head_scop_xp_phrase &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    HD-DTR.SYNSEM.PUNCT [ RPUNCT comma_or_clause,
                          PNCTPR #ppair ] ].

head_adj_scop_phrase := head_adj_phrase & scopal_mod_phrase &
  [ NH-DTR.SYNSEM [ LOCAL.CONT.MSG.PRED #msgpred,
                    NONLOC.REL 0-dlist,
                    PUNCT.RPUNCT.MSGPRED #msgpred ],
    HD-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct ].

; The paired variant - see comment 7-may-05 for n_adj_relcl_phrase.
head_adj_scop_prpnct := head_adj_scop_phrase &
  [ SYNSEM.PUNCT.PAIRED #paired,
    HD-DTR.SYNSEM.PUNCT [ PNCTPR #pnctpr,
                          PAIRED #paired ],
    NH-DTR.SYNSEM.PUNCT [ PAIRED #pnctpr,
                          PNCTPR #paired ] ].

; Non-paired variant - propagate comma or clause-punct onward
head_adj_scop_nopair := head_adj_scop_phrase &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    HD-DTR.SYNSEM.PUNCT.RPUNCT pair_or_no_punct,
    NH-DTR.SYNSEM.PUNCT [ RPUNCT comma_or_clause,
                          PNCTPR #ppair ] ].

; DPF 29-Nov-02 - Removed NH-DTR..TENSE no_tense, since the adjunct
; now provides the HOOK for the mother, including E-INDEX, which must be
; unified with the head-dtr's E-INDEX.
; DPF 26-May-03 - But that spurious re-entrancy with the head-dtr's index has
; now been removed, so we can re-introduce this constraint on TENSE, crucial
; for the generator, since the heuristics will introduce lots of spurious
; auxiliaries if there is an event variable unconstrained for TENSE.

adj_head_int_phrase := adj_head_phrase & isect_mod_phrase &
  [ NH-DTR.SYNSEM.LOCAL [ CAT [ HEAD.PRD -,
                                POSTHD - ],
                          CONT.HOOK.INDEX.E.TENSE no_tense ] ].

; DPF 19-Oct-02 - Try making the non-head dtr PRD +, to make VP-modifying
; PPs PRD + in order to avoid spurious ambiguity for 'a foot in front of ...'
; DPF 29-Nov-02 - Removed NH-DTR..HEAD..TENSE no_tense, since the adjunct
; now provides the HOOK for the mother, including E-INDEX, which must be
; unified with the head-dtr's E-INDEX.
; DPF 26-May-03 - But that spurious re-entrancy with the head-dtr's index has
; now been removed, so we can re-introduce this constraint on TENSE, crucial
; for the generator, since the heuristics will introduce lots of spurious
; auxiliaries if there is an event variable unconstrained for TENSE.
; DPF 24-aug-04 - Try making the hd-dtr [REL 0-dlist] to avoid spurious
; parse for e.g. 'abrams has an office [[browne showed] to chiang]'
; DPF 26-aug-04 - Tempted to generalize HD-DTR..KEY from event_rel to 
; event_or_degree_or_no_rel (ignoring degree_rel here), to allow no_cop VPs
; to be post-modified, as in "down again and to the lodge.", but this will
; surely lead to lots of additional edges with little coverage benefit.

head_adj_int_phrase := head_adj_phrase & isect_mod_phrase &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    HD-DTR.SYNSEM [ LOCAL.CAT [ HEAD adverbee & 
                                     [ KEYS.KEY event_rel ],
                                VAL.COMPS < > ],
                    NONLOC.REL 0-dlist,
                    PUNCT.RPUNCT rbc_or_pair_or_no_punct ],
    NH-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.E.TENSE no_tense,
                    NONLOC.REL 0-dlist,
                    PUNCT.PNCTPR #ppair ] ].

; For "On Tuesday who won" where need S-initial PP rather than extracted PP.
; DPF 29-Nov-02 - Removed NH-DTR..HEAD..TENSE no_tense, since the adjunct
; now provides the HOOK for the mother, including E-INDEX, which must be
; unified with the head-dtr's E-INDEX.
; DPF 26-May-03 - But that spurious re-entrancy with the head-dtr's index has
; now been removed, so we can re-introduce this constraint on TENSE, crucial
; for the generator, since the heuristics will introduce lots of spurious
; auxiliaries if there is an event variable unconstrained for TENSE.
; DPF 25-sept-04 - Changed NH-DTR..HEAD from prep to prep_or_modnp to also
; allow "tomorrow, can you come?"
; DPF 31-oct-05 - Constrained this rule to main clauses, to avoid spurious
; analyses in subordinate clauses like "we arise since today he arrives."

adj_head_int_ques_phrase := head_mod_phrase_simple & binary_headed_phrase &
                            binary_rule_right_to_left &
  [ SYNSEM [ LOCAL.CAT [ VAL.COMPS < >,
                         MC + ],
             NONLOC #nonloc & non-local_none,
	     MODIFD lmod & [ LPERIPH #periph ],
             PUNCT.PNCTPR #ppair ],
    HD-DTR #hdtr &
         [ SYNSEM [ LOCAL [ CAT [ HEAD verbal,
                                  VAL.COMPS < > ],
                            CONT [ HOOK #hook & [ XARG #hand ],
                                   MSG message & [ PRED basic_int_m_rel ] ] ],
                    NONLOC #nonloc,
                    MODIFD notmod_or_rmod,
                    PUNCT [ LPUNCT pair_or_no_punct,
                            PNCTPR #ppair ] ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD prep_or_modnp &
                                       [ MOD < [ LOCAL intersective_mod ] >,
                                         TAM [ TENSE no_tense,
                                               ASPECT no_aspect ] ],
                                        VAL.COMPS < > ],
                              CONT.HOOK.LTOP #hand,
                              CONJ cnil,
                              CTXT.ACTIVATED + ],
                      NONLOC #nonloc,
                      MODIFD.LPERIPH #periph,
                      PUNCT [ LPUNCT pair_or_no_punct,
                              RPUNCT comma_or_pair_or_no_punct ] ] ],
           #hdtr >,
    C-CONT.HOOK #hook ].

; For "the team which in 1924 won the title"
adj_head_rel_phrase := adj_head_phrase & head_mod_phrase_simple & 
                       head_compositional & head_final_infl &
  [ SYNSEM.LOCAL [ CAT #cat,
                   CONT.HOOK #hook ],
    HD-DTR.SYNSEM.LOCAL [ CAT #cat & [ HEAD verb & [ VFORM fin ],
                                       VAL [ SUBJ < >,
                                             COMPS < > ] ],
                          CONT.HOOK #hook & [ LTOP #ltop,
                                              INDEX #index ] ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD prep_or_modnp &
                                       [ TAM [ TENSE no_tense,
                                               ASPECT no_aspect ],
                                         MOD < [ LOCAL intersective_mod ] > ],
                                  VAL.COMPS < > ],
                            CONT.HOOK [ LTOP #ltop,
                                        INDEX.E.TENSE no_tense,
                                        XARG #index ] ],
                    PUNCT.RPUNCT hyphen_or_pair_or_no_punct ] ].

; Further split the head_adj_int_phrase in order to enforce one aspect of the 
; Complex-NP constraint prohibiting extraction from nominal adjuncts.
;
; DPF (27-May-99) Moreover, the nom_adj rule constrains the NH-DTR to be 
; PRD +, in order to prevent finite VPs from serving as modifiers.  This was 
; being blocked earlier by pretending that all post-head modifiers had to have
; SUBJ *olist*, but this meant making predicative participles not specify an
; OPT value on their SUBJ - dubious generalization, and besides, it made it
; difficult to get the parse-node labels right, since passive verbs looked
; like S's.
;
; DPF 3-June-99 -- Further constrained nom_adj rule to make the modifier be
; phrasal, to block "Kim met the consultant hired." It's too strong a
; constraint, but we'll revisit the question if we move to making post-nominal
; modifiers attach at NP rather than N.  Among the disadvantages is the fact
; that we can't do "Get him something nice". (But see opt comp for generic-pro)
; DPF 9-Sept-99 - Added [PRD -] to head-dtr to avoid modifiers of e.g. 
; minute-word. 
; - 20-Nov-99: But this also blocked "the eleventh any time after three"
; DPF 15-Apr-00 - Removed [NH-DTR..SLASH 0-dlist] since now have
; relative clauses have non-empty REL value.  This means we have to split the 
; nn_adj rule into two, one for relative clauses which are REL 1-dlist and the
; other for reduced relatives which are REL 0-dlist - otherwise we would get 
; "*Kim bought a book by whom?".
; DPF 26-Mar-01 - Added [HD-DTR..RPERIPH na_or_-] to block e.g. attachment of
; post-nom modifiers to bare proper names and numerals.
; DPF 2-Jun-02 - Added NH-DTR.LEX - to exclude "the children angry"
; DPF 2-Jul-02 - (from 26-Mar-01) But attachment of post-nom modifiers to 
; proper names is possible, as in "Abrams from New York just called".  So
; removed this constraint, and leave for later how to block "Abrams by Browne
; arrived"
; DPF 3-Jul-02 - Try adding HD-DTR..ALT2KEY no_rel to exclude modification
; of np-adverbs like "here".
; DPF 13-Oct-02 - But why block this?  We want "here in Paris is nice" and
; "I'll arrive later that morning".  So remove it, and wait for motivation.
; DPF 23-aug-04 - Moved NH-DTR..LEX - from n_adj_int_phrase to n_adj_redrel_cl
; in order to allow postnominal participles like "the people hired were good"
; while still blocking e.g. "*the people happy were good"
; DPF 25-aug-04 - Change HD-DTR.LPUNCT from pair_or_no_punct to 
; comma_or_pair_or_no_punct to allow non-restrictive relatives and reduced
; relatives for now.
; DPF 06-apr-05 - Try constraining HD-DTR..RPUNCT to pair_or_no_punct, to
; exclude spurious reading for "Kim sent [a letter, then] a card."
; DPF 04-may-05 - Constrain NH-DTR to QUE 0-dlist to block NP analysis of
; "the time when".
; DPF 13-nov-05 - Changed HD-DTR..RPUNCT from rbc_or_pair_or_no_punct to
; comma_or_rbc_or_pair_or_no_punct, to allow 

n_adj_int_phrase := head_adj_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC #spec ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ HEAD supnoun,
                                VAL [ COMPS < >,
                                      SPEC #spec ] ],
                    PUNCT [ LPUNCT pair_or_no_punct,
                            RPUNCT comma_or_rbc_or_pair_or_no_punct ] ],
    NH-DTR.SYNSEM [ LOCAL.CAT.MC na,
                    NONLOC [ SLASH 0-dlist,
                             QUE 0-dlist ],
                    PUNCT.LPUNCT pair_or_no_punct ] ].

; DPF 26-Mar-01 - Added [SPR..KEY impl_or_expl_q_rel] to provide basis
; for blocking application of proper_np (non-branching) rule, to avoid e.g.
; "*I saw Abrams I had hired" - cf. "I saw the Abrams I had hired"
; Also added SYNSEM..RPERIPH + to provide basis for blocking addition of a
; thatless-rel to the right of a full relative clause.
; DPF 19-Oct-02 - Added HD-DTR..ALT2KEY no_rel to block full relatives 
; modifying np_adverbs like "here, there", and singular deictics as in 
; "*that he bought yesterday arrived" (cf "those he bought yesterday arrived")
; DPF 10-jul-04 - Can't make NH-DTR be LPUNCT no_punct as one might think for
; restrictive relatives (in contrast to non-restrictives which must be
; comma-delimited), because of pied-piping examples like "I bought five
; books, all of which were new" where the comma is optionally present even
; on the restrictive reading.
; DPF 4-mar-05 - Re 19-Oct-02: This ALT2KEY hack interacts badly with the
; appositive rule, where we want to prevent deictic pronouns from appearing,
; and use ALT2KEY to block.  Anyway, cf. "That which one writes is admired."
; So try non_number_rel as value instead, including deictics but still
; excluding "here, there".
; DPF 7-may-05 - With the current treatment of punctuation pairing, we need
; two versions of this rule (and similarly for appositives): one which 
; requires the PNCTPR value to match on both daughters, thus satisfying the
; pairing requirements and freeing the PNCTPR value on the mother; and one
; where the left daughter has no punct, so the PNCTPR value propagates.  Same
; for head_adj_scop_phrase.
;
n_adj_relcl_phrase := n_adj_int_phrase & isect_mod_phrase &
  [ SYNSEM.MODIFD #modif,
    NH-DTR.SYNSEM [ LOCAL.CAT [ HEAD verbal & [ TAM basic_ind_or_mod_subj_tam &
                                                    [ TENSE real_tense ],
                                                VFORM fin_or_inf ],
                                VAL [ SUBJ *olist_or_prolist*,
                                      COMPS < > ] ],
                    MODIFD #modif ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ VAL.SPR < [ LOCAL.CAT.HEAD.KEYS 
                                           [ KEY i_or_e_quant_or_deg_rel ] ] >,
                                HEAD.KEYS.ALT2KEY non_number_rel ],
                    NONLOC.REL 0-dlist ] ].

; The paired variant, where both daughters match in right punctuation
n_adj_relcl_prpnct := n_adj_relcl_phrase &
  [ SYNSEM.PUNCT.PAIRED #paired,
    HD-DTR.SYNSEM.PUNCT [ PNCTPR #pnctpr,
                          PAIRED #paired,
                          RPUNCT comma_or_pair_or_no_punct ],
    NH-DTR.SYNSEM.PUNCT [ PAIRED #pnctpr,
                          PNCTPR #paired ] ].

; The non-paired variant with comma
n_adj_relcl_nopair := n_adj_relcl_phrase &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    HD-DTR.SYNSEM.PUNCT.RPUNCT rbc_or_pair_or_no_punct,
    NH-DTR.SYNSEM.PUNCT [ RPUNCT comma_or_clause,
                          PNCTPR #ppair ] ].

; DPF 27-Nov-02 - Added MOD..KEY basic_nom_rel to exclude measure-NPs from
; being modified by rel clauses.
; DPF 31-oct-03 - Tried adding ALTKEY norm_non_conj_rel to prevent modification
; of internval NPs like spurious (?) reading of  "berlin to Paris in June".
; DPF 25-aug-04 - Constrained NH-DTR..LPUNCT to pair_or_no_punct, to avoid
; spurious ambiguity for "the chair, in Berlin, arrives."
; DPF 28-sept-04 - Changed HEAD value of NH-DTR from a_or_p to a_or_p_or_adv
; since verbal gerunds still need to take post-head modifiers, as in
; 'eating quickly is not recommended'
; DPF 12-mar-05 - Re 25-aug-04: This blocks eg "Here, above Berlin, we arrive"
; so accept ambig and relax to comma_or_pair_or_no_punct.

n_adj_redrel_phrase := n_adj_int_phrase & head_compositional &
  [ HD-DTR.SYNSEM.LOCAL [ CAT.HEAD.KEYS.ALTKEY norm_non_conj_rel,
                          CONT.HOOK.LTOP #hand ],
    NH-DTR.SYNSEM 
       [ LOCAL [ CAT [ HEAD a_or_p_or_adv &
                            [ MOD < [ LOCAL intersective_mod ] >,
                              TAM #tam & [ TENSE untensed,
                                           ASPECT no_aspect ] ],
                       VAL.SUBJ *olist* ],
                 CONT.HOOK [ LTOP #hand,
                             INDEX.E #tam ] ],
         NONLOC.REL 0-dlist,
         PUNCT.LPUNCT comma_or_hyphen_or_pair_or_no_punct,
         LEX - ],
    C-CONT.HCONS <! !> ].

; The paired variant, where both daughters match in right punctuation
n_adj_redrel_prpnct := n_adj_redrel_phrase &
  [ SYNSEM.PUNCT.PAIRED #paired,
    HD-DTR.SYNSEM.PUNCT [ PNCTPR #pnctpr,
                          PAIRED #paired,
                          RPUNCT comma_or_pair_or_no_punct ],
    NH-DTR.SYNSEM.PUNCT [ PAIRED #pnctpr,
                          PNCTPR #paired ] ].

; The non-paired variant with comma
n_adj_redrel_nopair := n_adj_redrel_phrase &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    HD-DTR.SYNSEM.PUNCT.RPUNCT pair_or_no_punct,
    NH-DTR.SYNSEM.PUNCT [ RPUNCT hyphen_or_comma_or_colon_or_clause,
                          PNCTPR #ppair ] ].

; For generator, distinguish constructions where adjunct contains a gap from
; those where it does not.

h_adj_unsl_phrase := head_adj_int_phrase &
  [ ARGS.REST.FIRST.SYNSEM.NONLOC.SLASH 0-dlist ].

; DPF 10-dec-03 - Restrict this rule to exclude elided auxiliary heads, to
; avoid "Berlin, the road is, to"
h_adj_sl_phrase := head_adj_int_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.ALTKEY role_rel,
    ARGS.REST.FIRST.SYNSEM.NONLOC.SLASH 1-dlist ].

; DPF 11-May-01 - Split adj_head_int_phrase into two: one for nominal head-dtrs
; and one for non-nominals, parallel to head_adj_phrase split.  Needed at least
; to prevent pre-head adjectives from modifying partitives, to get contrast in
; "any angry at Sally left"  vs "*angry any left" 
; DPF 13-May-01 - Changed SPR..KEY from impl_or_expl_q_rel to quant_rel in
; order to get "Mr Smith" as adj_n construction which then undergoes proper_np
; rule.
; DPF 13-Mar-02 - HD-DTR..LPERIPH na_or_- prevents adjectives from modifying
; numerically-modified nouns, as in "*the tall five consultants".
; DPF 28-Apr-03 - But this constraint prevents "the next five consultants",so
; remove constraint here, and expect (statistical?) adjective-ordering
; constraints to get the order of "five" and "tall" right.  Someday.
; DPF 16-dec-03 - Made NHD be [LEX +] to prevent eg "the older than Kim chair"
; since "older" is [LEX +] but "older than Kim" is [LEX -].
; DPF 24-apr-04 - Made COMPS of mother be *obllist* to avoid spurious ambiguity
; for e.g. "easy problem" since we could otherwise discharge the optional
; complement of "easy" first with head_opt_comp, or after this rule applies,
; using n_opt_comp.
; For now, rule out comma-separated prenominal adjectives, since out for
; one adjective, pretty bad for two, and not clear how to allow for three 
; or more (if that's the right generalization).
; But this is clearly wrong, for e.g. "we expect warm, sunny days', so remove,
; and someday work out how to block comma on rightmost adjective.

adj_n_int_phrase := adj_head_int_phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS #comps & *obllist*,
                           SPEC #spec ],
    HD-DTR [ SYNSEM.LOCAL.CAT [ HEAD nom_or_ttl,
                                VAL [ SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                               quant_rel ] >,
                                      SPEC #spec,
                                      COMPS < > ] ],
             INFLECTD #infl ],
    NH-DTR [ SYNSEM [ LOCAL [ CAT.VAL [ SUBJ *synlist*,
                                        COMPS #comps ],
                              CONT.HOOK.INDEX event & [ E.TENSE no_tense ] ],
                      LEX + ],
             INFLECTD + ],
    INFLECTD #infl ].

; DPF 29-aug-04 - Also allow "tenth-century" with optional hyphen when the
; head noun is [INFLECTD -]
; DPF 11-mar-05 - More interested in avoiding "*The tall, chair arrived", so
; instead splitting this rule for latter purpose.  And anyway, the hyphen
; constraint was wrong, since we also want "the tenth-century church arose",
; so allow hyphen for adj-n case.

adj_n_phrase := adj_n_int_phrase &
  [ HD-DTR.SYNSEM.MODIFD notmod_or_rmod,
    NH-DTR.SYNSEM.PUNCT.RPUNCT hyphen_or_pair_or_no_punct ].

adj_adjn_phrase := adj_n_int_phrase &
  [ HD-DTR.SYNSEM.MODIFD lmod,
    NH-DTR.SYNSEM.PUNCT.RPUNCT rbc_or_hyphen_or_pair_or_no_punct ].

; DPF 29-Nov-02 - Removed NH-DTR..HEAD..TENSE no_tense, since the adjunct
; now provides the HOOK for the mother, including E-INDEX, which must be
; unified with the head-dtr's E-INDEX.
; DPF 26-May-03 - But that spurious re-entrancy with the head-dtr's index has
; now been removed, so we can re-introduce this constraint on TENSE, crucial
; for the generator, since the heuristics will introduce lots of spurious
; auxiliaries if there is an event variable unconstrained for TENSE.
; DPF 21-may-05 - Add similar split to get comma distribution right for
; 'Kim quietly left' '*Kim quietly, left' 'Kim quietly, carefully left' 

basic_adj_h_int_phrase := adj_head_int_phrase & head_final_infl &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    HD-DTR.SYNSEM.LOCAL [ CAT.HEAD adverbee,
                          CONT.HOOK.XARG #xarg ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.TAM [ TENSE no_tense,
                                             ASPECT no_aspect ],
                                  VAL.COMPS < > ],
                            CONT.HOOK.XARG #xarg ],
                    NONLOC.REL 0-dlist,
                    PUNCT.RPUNCT rbc_or_hyphen_or_pair_or_no_punct ] ].

adj_h_int_phrase := basic_adj_h_int_phrase &
  [ HD-DTR.SYNSEM.MODIFD notmod_or_rmod ].

adj_adjh_int_phrase := basic_adj_h_int_phrase &
  [ HD-DTR.SYNSEM.MODIFD lmod ].

; For now, restrict adjunct extraction to posthead modifiers of VPs (and the
; special case of inverted auxiliary-headed Ss, which still have a non-empty 
; but never realized SUBJ - see discussion of sai_synsem in lextypes.tdl). 
; This will still produce two parses for "Tuesday Kim might dance", but the 
; alternatives (e.g., blocking modification of all auxiliaries except the 
; copula) seem even less attractive.  Also block extraction of adjuncts out of
; subjunctive-verb-headed phrases.

; ERB (12-11-96) This is the exception; the reason I couldn't put the MSG
; stuff on head_mod_phrase.

; DPF (23-Aug-98) Given our splitting up of the head-modifier type into 
; separate subtypes for intersective and scopal modification, we have to do
; the same for extracted adjuncts as well.
; DPF (09-Jan-99) But it is not clear that we ever need to extract scopal
; modifiers, since the ones that are post-head (maybe always adverbs) also seem
; to be available as modifiers of S, and not restricted to POSTHD +.  So 
; we'll try doing without the scopal variant.
;
; DPF 19-Oct-99 - We used to make the value of SLASH's MOD feature be the
; whole SYNSEM of the HEAD, but this interacted badly with coordination
; of two extracted_adj phrases: it resulted in the CONT features of the
; two conjoined phrases being identified, since coordination enforces
; across-the-board identity of SLASH.  This resulted in circular RELS
; values, which are undesirable.  So now we identify the values of the
; relevant LOCAL features in SLASH..MOD and in HD-DTR, avoiding false
; identity of the RELS values.  Test case: "Kim arises and arises".
; DPF 2-Feb-01 - Eliminated HD-DTR..MOOD strict_sort since it blocked
; "On tuesday Kim arrived and would stay"
; DPF 30-May-01 - Identify MC of head-dtr and extracted adjunct, to avoid
; spurious ambiguity for "For whom does she work"
; DPF 15-Oct-01 - Replaced HD-DTR..HEAD..TENSE real_tense with KEY relation,
; since former blocked extraction of adjuncts from complements of e.g. modals,
; and the latter works as intended to block extraction from no_copula VPs.
; DPF 12-Apr-02 - Added HD-DTR..SUBJ..INDEX non_expl-ind to prevent adjunct
; extraction from there-copula sentences - spurious chart ambiguity.
; DPF 28-Nov-02 - HOOK comes only from C-CONT (linked here to SLASH values)
; DPF 14-Oct-03 - But can't prevent adjunct extraction from there-copula
; sentences: "In winter there is snow". So removed non_expl constraint.

basic_extracted_adj_phrase := head_mod_phrase & head_only & phrasal &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
                     CONT.HOOK.INDEX.--TPC + ],
             NONLOC [ QUE #que,
                      REL 0-dlist ],
             MODIFD rmod ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ HEAD.KEYS.KEY norm_rel,
                                VAL.COMPS < > ],
                    NONLOC [ QUE #que,
                             REL 0-dlist ] ] ].

extracted_adj_int_phrase := basic_extracted_adj_phrase & head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY #modkey,
                           POSTHD #ph,
			   MC #mc ],
                     CONT.MSG #msg ],
	     NONLOC.SLASH 1-dlist &
		   [ LIST < [ CAT [ POSTHD +,
				    HEAD mobile &
                                        [ MOD < [ LOCAL intersective_mod &
                                                  [ CAT [ HEAD #head &
                                                          [ KEYS.KEY #modkey ],
                                                          VAL #val,
                                                          POSTHD #ph,
                                                          HC-LEX #hclex,
                                                          MC #mc ],
                                                    CONT.HOOK 
                                                        [ LTOP #hand,
                                                          INDEX #hind ],
                                                    CONJ #conj,
                                                    CTXT #ctxt ],
                                                  --SIND #hind ] >,
                                          TAM [ TENSE no_tense,
                                               ASPECT no_aspect ],
                                          KEYS.KEY independent_rel ],
                                    VAL [ SUBJ *prolist*,
                                          COMPS < >,
					  SPR *olist* ] ],
			      CONT [ HOOK [ LTOP #hand,
                                            XARG #hind ],
                                     MSG #msg ] ] > ] ],
    HD-DTR.SYNSEM canonical_synsem &
	   [ LOCAL local_basic &
		   [ CAT [ HEAD #head & v_or_a_or_p &
				[ TAM.MOOD ind_or_mod_subj,
                                  MOD < anti_synsem > ],
                           VAL #val,
			   POSTHD #ph & +,
                           HC-LEX #hclex,
                           MC #mc ],
                     CONT.HOOK [ LTOP #hand,
                                 INDEX #hind & individual ],
                     CONJ #conj,
                     CTXT #ctxt ],
             NONLOC.SLASH 0-dlist,
	     MODIFD notmod ],
    C-CONT [ HOOK.LTOP #hand,
             RELS <! !>,
	     HCONS <! !> ] ].

; DPF (1-May-99) Removed identity of SLASH..KEY.LBL and HD-DTR..KEY.LBL since
; this should be redundant for most cases, and is wrong for free relatives
; like "where Kim slept" since in this construction the KEY of the free-rel and
; the KEY of its sister's SLASH must be identified in order to allow "where Kim
; put the book" while blocking "where kim relied".  But this identity means we
; can't have the LBL of that SLASH..KEY be the same as the LBL of the
; head of this extracted-adj phrase, because that would mean that the LBL of
; the ex-adj head's KEY ("slept" in "where she slept" would be wrongly 
; identified with the LBL of the KEY for "where" (which is 'place_rel').
; DPF 2-Oct-01 - Added to mother [SLASH..INDEX.SORT entity] to make this rule
; be complementary to the extradj_t rule, which is restricted to SORT time.
; DPF 28-Apr-03 - The drawback of this (2-Oct-01) is that it blocks a
; combination of temporal and nontemporal modifiers, as in "why don't we hire
; kim now".
; DPF 13-mar-05 - Tried adding SPR *anti_list* to avoid spurious ambiguity for
; extracted adjuncts of adjective phrases.  Also added POSTHD + to avoid
; spurious extraction from attributive adjectives.
; DPF 28-mar-05 - Added SUBJ *synlist* to distinguish extr_vp from extr_s
; (since MSG no_msg doesn't work for "where is Kim the king", since msg is 
; added (too late) by yesno rule).

extracted_adj_int_vp_phrase := extracted_adj_int_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD.AUX -,
                         VAL.SUBJ *synlist*,
                         POSTHD + ],
                   CONT [ HOOK.XARG individual,
                          MSG no_msg ] ] ].

extracted_adj_int_s_phrase := extracted_adj_int_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ INV +,
                                            MOD *anti_list* ],
                              VAL.SUBJ < anti_synsem_min > ] ].


; DPF 14-Jul-01 - Identified MSG of mother with that of head-dtr as well
; as already specified SLASH..MOD..MSG, in order to prevent PPS for
; sentence-initial modification from modifying VPs.  This is only okay as long
; as we continue to not extract scopal modifiers.
; DPF 25-Sep-01 - Removed SLASH unexpr_local since it blocks any filler - how
; was that supposed to work, anyway??
; DPF 2-Oct-01 -  Replaced [VFORM fin] on head-dtr with [VFORM fin_or_bse], to
; allow low attachment of "when can kim arrive"
; DPF 28-Apr-03 - Tried to restrict this to VP dtr, not S, to avoid spurious 
; ambiguity for "the day I arrive".  But then we get no parse for e.g.
; "when was Kim ready" since this rule has to apply to the S.  So leave the
; spuriosity for now.
; DPF 14-Oct-03 - Changed SLASH value from NP to Nbar so this should only be
; used for relative clauses like "the day I arrived", not for "Yesterday Kim
; arrived", since the latter is handled by extraction of the unary PP.  Now
; also restrict dtr to VP, since 28-Apr-03 objection now overcome.
; DPF 5-sept-05 - Added SLASH..SPR..ALTKEY no_rel to block analyses like for
; 'six cabins have been built' where 'have been' undergoes this extracted-T
; rule, and 'six' is day-of-month.

extracted_adj_npadv_phrase := basic_extracted_adj_phrase & head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ POSTHD #ph,
                           MC #mc ],
                     CONT.MSG #msg ],
	     NONLOC.SLASH 1-dlist &
                 <! local &
                    [ CAT nbar_cat_min & 
                          [ HEAD.KEYS.KEY modable_rel,
                            VAL.SPR < [ LOCAL.CAT.HEAD det &
                                               [ KEYS.ALTKEY no_rel ] ] > ],
                      CONT.HOOK.INDEX #ind & [ SORT location ] ] !> ],
    HD-DTR.SYNSEM canonical_synsem &
	   [ LOCAL local_basic &
		   [ CAT [ HEAD verb & [ VFORM fin_or_bse,
                                         TAM.MOOD ind_or_mod_subj,
                                         MOD *anti_list* ],
                           VAL.SUBJ < synsem & [ LOCAL.CAT.HEAD nominal,
                                                 --SIND non_expl-ind,
                                                 NONLOC.SLASH 0-dlist  ] >,
                           POSTHD #ph,
                           MC #mc ],
                     CONT [ HOOK [ LTOP #hand,
                                   INDEX #event ],
                            MSG #msg ] ],
             NONLOC.SLASH 0-dlist,
	     MODIFD notmod ],
    C-CONT [ RELS <! prep_relation &
                     [ LBL #hand,
                       PRED unspec_loc_rel,
                       ARG0.E [ TENSE no_tense,
                                ASPECT no_aspect ],
                       ARG1 #event & event_or_index,
                       ARG2 #ind ] !>,
	     HCONS <! !> ] ].

;;
;; Bare plural and mass NPs, distinguished by the INDEX feature [ DIV + ]
;;
; DPF 9-Sept-99 - Changed head-dtr's SPR to be canonical_synsem rather than
; non_canonical.  Don't know why it was that way, but it was allowing e.g. the
; proper noun 'Tuesday' to undergo this rule.
; DPF 17-Mar-01 - Since the choice of bare-np rule is determined by the value
; of DIV on the dtr, this needs to be a strict sort; but a bare-np must
; be able to conjoin with another NP of a different DIV value, so we
; make these not be headed phrases (which identify AGR on mother and head-dtr).
; DPF 6-Apr-01 - Given that we now pump all optional nominal complements, this
; rule now requires the n-bar dtr to also be COMPS < >.
; DPF 22-May-01 - Instead of making mother nonpronominal_synsem (which 
; incorrectly claims all bare NPs are [LEX +]), make mother's KEY nonpro_rel.
; Then make LEX value propagate from dtr to mother.
; DPF 25-Sep-01 - From 17-Mar: Having broken link for AGR of dtr and mother,

; DPF 20-Nov-01 - Moved identification of MODIFD down to the non-proper-name
; subtypes, in order to allow "My friend Mister Abrams" as an appositive.
; DPF 25-Nov-01 - Changed dtr's HEAD from noun to noun_or_nomger to allow e.g.
; "Processing of requests is important"
; DPF 19-Oct-02 - Moved ALTKEY to subtypes, to allow num-nps to differ.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 23-oct-03 - Added LPERIPH na_or_+ to dtr to enable blocking of bare-np
; for e.g. "miles an hour" as in "*Kim ran miles an hour".
; DPF 03-dec-03 - But this also blocks "I have time" - not true that the
; candidates for bare-np are same as those for npadv rule.  So undo this
; constraint.  Anyway, above bad example is probably duu to measure-NP that
; should (somehow) be blocked for same reason as "*this string is foot long".
; DPF 14-dec-03 - Removed [ SLASH 0-dlist ] from dtr, since it prevented
; "who did you have pictures of"

generic_bare_np_phrase := norm_unary_phrase &
  [ SYNSEM synsem &
           [ LOCAL [ CAT [ HEAD #head,
                           HC-LEX #hclex,
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < > ],
                           MC na ],
                     AGR ref-ind &
                         [ PNG #png ],
                     CONJ #conj,
                     CONT.MSG #msg & no_msg ],
             LEX #lex,
             NONLOC #nonloc ],
    ARGS < [ SYNSEM 
             [ LOCAL [ CAT [ HEAD #head & noun_or_nomger,
                             HC-LEX #hclex,
                             VAL [ SUBJ *olist*,
                                   COMPS < >,
                                   SPR < [ OPT -,
                                           NONLOC [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ] ],
                       AGR.PNG #png,
                       CONJ #conj & cnil,
                       CONT [ HOOK [ LTOP #nhand,
                                     INDEX #index ],
                              MSG #msg ] ],
               LEX #lex,
               NONLOC #nonloc,
               PUNCT.LPUNCT pair_or_no_punct ],
             POSSCL #posscl ] >,
    C-CONT [ HOOK [ INDEX #index,
                    XARG #nhand ],
             RELS <! [ PRED quant_rel,
                       ARG0 #index,
                       RSTR #rhand ] !>,
             HCONS <! qeq &
		     [ HARG #rhand,
		       LARG #nhand ] !> ],
    POSSCL #posscl ].

; DPF 21-sept-04 - Changed ARGS..SPR canonical_synsem to unexpressed_reg
; in order to prevent bare-nps where the determiner is obligatory, as in
; 'those five chairs' to avoid spurious ambiguity with the determiner 'five'

norm_bare_np_phrase := generic_bare_np_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.KEYS.KEY nonpro_rel,
                       VAL.SPEC < anti_synsem_min > ],
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.SPR < unexpressed_reg > ] > ].

; DPF 19-Oct-02 - Changed SPR..KEY from udef_q_rel to abstr_def_or_udef_q_rel
; to also allow "afternoons" using (necessarily) the 'afternoon' with an
; optional PP-of and a usually obligatory definite determiner (to get the
; contrast between "on the afternoon of the fifth" but "in the afternoon"

bare_np_phrase := norm_bare_np_phrase &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT.HEAD.KEYS.ALTKEY implicit_q_rel,
                     AGR.DIV + ],
             MODIFD #modif ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ AGR.DIV +,
                              CAT.VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                abstr_def_or_udef_q_rel ] > ],
                      MODIFD #modif ] ] >,
    C-CONT.RELS <! [ PRED udef_q_rel ] !> ].

; DPF 23-Nov-01 - Added SPR..KEY udef_q_rel to block num_noun as input.
; DPF 2-Jun-02 - Added ARGS..KEY non_temp_nom_rel to exclude temporal nouns.

bare_np_sg_phrase_robust := norm_bare_np_phrase &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT.HEAD.KEYS.ALTKEY implicit_q_rel,
                     AGR.DIV - ],
             MODIFD #modif ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY non_temp_nom_rel,
                                    VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                            udef_q_rel ] > ],
                              AGR.DIV - ],
                      MODIFD #modif ],
             POSSCL - ] >,
    C-CONT.RELS <! [ PRED udef_q_rel ] !>,
    GENRE robust ].

; DPF 8-Mar-01 - Removed [MODIFD notmod_or_lmod] from head-dtr, since it
; prevented "Tuesday at five" as an NP.
; DPF 17-Mar-01 - But then put it back, since we have to block e.g.
; "*I met Abrams you hired".  So will look for another analysis of above.
; DPF 25-Mar-01 - Removed it again, in favor of constraint on SPR in full relcl
; rule which blocks it from feeding this rule.
; DPF 24-Jun-01 - Removed ARGS..DIV - since need to identify AGR of
; dtr and mother to get semantics right, and need mother to be DIV -*,
; and don't know what that constraint was blocking anyway.
; DPF 10-Apr-02 - Changed ALTKEY from basic_nom_rel to implicit_q_rel so
; these can appear in np-n compounds like "Kim Browne"
; DPF 27-Oct-02 - Re: 24-Jun-01 - Well, it blocked the spurious analysis of 
; plural proper names like in "on Fridays", where the bare-plural rule already
; supplies the desired analysis.  This is another case where our use of
; overspecification for coordination goes wrong, since we want the daughter to
; be really [DIV -] (alternatively, really [PN 3sg]) but we want the
; mother to be able to coordinate with unlikes, and yet we need the AGR
; reentrancy (really the INDEX reentrancy) for the semantics.
; DPF 8-May-03 - Added identity of MODIFD on mother and daughter (like most
; of the other bare_np_phrase types, here to avoid "afternoon Monday" as a
; temporal modifier.
; DPF 5-Sep-03 - Added ARGS..INDEX nonconj_ref-ind to prevent conjoined n-bars 
; like 'Kim and Sandy' to avoid spurious ambiguity.

proper_np_phrase := norm_bare_np_phrase &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT.HEAD.PRD #infl,
                     AGR #agr & [ DIV - ] ],
             MODIFD #modif ],
    ARGS < [ INFLECTD #infl,
             SYNSEM 
             [ LOCAL [ CAT [ HEAD.KEYS [ KEY abstr_named_np_rel,
                                         ALTKEY proper_q_rel ],
                             VAL.SPR < [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                   proper_q_rel ] > ],
                       CONT.HOOK.INDEX nonconj_ref-ind,
                       AGR #agr ],
               MODIFD #modif ] ] >,
    C-CONT.RELS <! [ PRED proper_q_rel ] !> ].
                      
; DPF 22-May-02 - Split proper_np_phrase into two, one for non-numbers and
; one for numbers, so we can constrain the latter to be unmodified, in order
; to block "*Toshiba 2000 is here" but allow "I visited sunny Pittsburgh"
; DPF 30-May-02 - But this also blocked "order (number) fifty".  So instead
; only require [MODIFD.LPERIPH -], since titles don't affect LPERIPH, but
; adjectives and n-n-compounds do.
; DPF 19-Oct-02 - Added ALTKEY never_unify_rel to prevent these guys from
; appearing in np_n_cmpnds.
; DPF 4-Feb-02 - Changed this never_unify_rel to number_q_rel to still keep
; them out of np_n_cmpnds, but allow them in measure phrases.
; DPF 25-May-03 - Since num-nouns now LPERIPH + again, remove constraint from
; ARGS, and see what has to be done to avoid overgeneration of "Toshiba 2000"

num_np_phrase := generic_bare_np_phrase &
  [ INFLECTD bool,
    SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.ALTKEY number_q_rel,
                           VAL.SPEC < anti_synsem_min > ],
                     AGR #agr & [ DIV - ] ],
             MODIFD #mod ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY named_num_rel,
                                    VAL.SPR < canonical_synsem &
                                            [ LOCAL.CAT.HEAD.KEYS.KEY 
                                                           number_q_rel ] > ],
                              AGR #agr ],
                      MODIFD #mod ] ] >,
    C-CONT.RELS <! [ PRED number_q_rel ] !> ].

; For determinerless-PPs of three subtypes
; DPF 13-nov-05 - Try making these SPEC < >, so they won't combine with
; e.g. identity copula.

detlesspp_np_phrase := generic_bare_np_phrase &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT [ HEAD.KEYS [ KEY nonpro_rel,
                                   ALTKEY implicit_q_rel ],
                       VAL.SPEC < > ],
    ARGS < [ INFLECTD +,
             SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY bare_nom_rel ] >,
    C-CONT.RELS <! [ PRED idiom_q_rel ] !> ].

; 'at eye level'
detlesspp_np_nmod_phrase := detlesspp_np_phrase &
  [ ARGS < [ SYNSEM lex_phr_synsem &
                    [ LOCAL.CAT.HEAD.KEYS.KEY bare_n_nmod_rel,
                      MODIFD.LPERIPH na ] ] > ].
; 'at close range'
detlesspp_np_jmod_phrase := detlesspp_np_phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY bare_n_jmod_rel,
                      MODIFD lmod & [ LPERIPH bool ] ] ] > ].

; 'within range' (optional modifier not present)
; 'on top', 'of course' (no modifier allowed)
detlesspp_np_nomod_phrase := detlesspp_np_phrase &
  [ ARGS < [ SYNSEM basic_lex_synsem &
                    [ LOCAL.CAT.HEAD.KEYS.KEY bare_nom_rel,
                      MODIFD notmod & [ LPERIPH + ] ] ] > ].


; Verbal gerunds with no (possessive) specifier.
; DPF 12-May-00 Block extraction from gerund NPs.
; DPF 07-Jan-01 Allow "Me hiring Sandy impressed Kim" as well as "Hiring 
; Sandy impressed Kim" by removing constraint that head-dtr be SPR < >,
; but then block spurious analysis for "My hiring Sandy impressed Kim"
; by requiring the head-dtr to be ALTKEY no_rel (the head-spr rule makes
; the mother's ALTKEY the quant_rel).  Also, block spurious analysis for
; "me hiring Sandy impressed kim" (failing to undergo this rule and hence
; leaving an unbound variable for the gerund_rel), by making this rule's
; output be MSG no_msg, and (in lextypes.tdl and auxverbs.tdl) 
; requiring that subjects (only ever of finite verbs) be MSG no_msg.
; This means sentential subjects will have to undergo a non-branching
; rule to make nominative NPs, but this is at least defensible, since we
; need to get the nominative case from somewhere, to prevent them from
; appearing as, say, objects of prepositions.
; DPF 19-Feb-01 - We're getting spurious ambiguity for "Kim prefers sleeping"
; where both the verbal gerund and the nominal gerund produce an NP.  So let's
; try blocking the lexical verbal gerunds by making HD-DTR a phrase.
; DPF 23-Apr-01 - But while we are avoiding nominal gerunds of intransitives,
; we'll undo this block.
; DPF 30-May-01 - Removed head-dtr's non-empty SUBJ requirement, since we
; still need to supply a quantifier in the ACC subj constructions like
; "I resent you leaving early".
; DPF 22-May-02 - Made HD-DTR..COMPS < > rather than *olist*, to avoid
; spurious parse for e.g. "Abrams is interviewing" where noptcomp applies.
; DPF 28-Nov-02 - HOOK comes only from C-CONT

bare_vger_phrase := head_only & head_valence_phrase & phrasal &
  [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < >,
                               SPR < >,
                               COMPS < > ],
                         MC na ],
                   CONT.MSG no_msg ],
    HD-DTR 
         [ SYNSEM phr_synsem &
	   [ LOCAL [ CAT [ HEAD gerund & [ KEYS.KEY gerund_rel ],
                           VAL [ SPR < unexpressed_reg >,
                                 COMPS < > ],
                           MC na_or_- ],
		     CONJ cnil,
		     CONT.HOOK [ LTOP #hand,
                                 INDEX #index & [ DIV + ] ] ] ] ],
    C-CONT [ HOOK.INDEX #index,
	     RELS <! [ PRED udef_q_rel,
                       ARG0 #index,
                       RSTR #rhand ] !>,
	     HCONS <! qeq &
		     [ HARG #rhand,
		       LARG #hand ] !> ] ].

; 'Whether (or not) Kim slept is not clear to Sandy"
; 'To sleep pleases Kim."
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 24-aug-04 - Moved ARGS..MODIFD notmod_or_rmod up to basic type
; to prevent both WH and non-WH S's with pre-modifiers from being NPs, 
; to exclude spurious analysis of 
; "it was [known to be true [that Abrams hired Browne]]".

basic_np_cp_phrase := unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & 
                                [ MOD < >,
                                  KEYS [ KEY nominalize_rel,
                                         ALTKEY udef_q_rel ] ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < >,
                                 SPEC < anti_synsem_min > ],
                           MC na ],
                     AGR.PNG.PN 3sg,
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin_or_inf,
                                           INV -,
                                           TAM.MOOD ind_or_mod_subj ],
                                    VAL.COMPS < >,
                                    MC - ],
                              CONJ cnil,
                              CONT.HOOK [ LTOP #chand,
                                          INDEX non_conj_event,
                                          XARG non_expl-ind ] ],
                      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                                  QUE 0-dlist,
                                  REL 0-dlist ],
                      MODIFD notmod_or_rmod,
                      LEX - ] ] >,
    C-CONT [ HOOK.INDEX #index & [ PNG.PN 3sg ],
	     RELS <! [ PRED udef_q_rel,
                       ARG0 #index,
                       RSTR #rhand ],
                      nominalize_relation &
                    [ LBL #nhand,
                      ARG0 #index,
                      ARG1 #chand ] !>,
             HCONS <! qeq &
		     [ HARG #rhand,
		       LARG #nhand ] !> ] ].

;; DPF 11-Apr-02 -- Why is this rule needed, again?  It produces spurious
;; parses, as in "He thought about what she said."
;; DPF 06-May-04 - The above example would only get a free relative reading,
;; which is not the only one, as evidenced by "He thought about who she hired"
;; where there is no free-relative "who", and which we don't get without the
;; np_cp-wh rule.  We make it CASE obliq to avoid spurious parses for verbal
;; complements as in "he knew who arrived"

np_cp_wh_phrase := basic_np_cp_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE obliq,
                   CONT.MSG no_msg ],
    ARGS < [ SYNSEM.LOCAL [ CAT.HEAD verbal,
                            CONT.MSG message &
                                     [ PRED int_m_rel ] ] ] > ].

;; Non-WH CP subjects, which often alternate with expletive-it subject, where
;; the alternation could be analyzed as it-extraposition.  Here we assume that
;; any predicate with an expletive-it subject and a CP complement also has
;; a subcat without the CP and with an ordinary NP subject.  So we take an
;; ordinary finite VP and convert it via non-branching (syntactic) rule to a 
;; VP that wants a non-WH CP subject and adjusts its semantic linking so it 
;; takes the LTOP of that subject (rather than the INDEX) as its XARG.
;
; 'That Kim slept bothers sandy"

cp_subj_phrase := head_only & phrasal &
  [ SYNSEM [ LOCAL [ CAT.VAL 
                      [ SUBJ < expressed_synsem &
                               [ LOCAL [ CAT [ HEAD comp & 
                                                    [ VFORM fin_or_inf,
                                                      KEYS.KEY non_ellipt_rel],
                                               VAL [ SUBJ *prolist*,
                                                     COMPS < > ] ],
                                         CONT [ HOOK.LTOP #sltop,
                                                MSG.PRED prop-or-ques_m_rel ]],
                                 NONLOC non-local_none &
                                        [ SLASH.LIST < > ] ] >,
                        SPR #spr,
                        COMPS < >,
                        SPEC < > ],
                     AGR.PNG.PN 3sg,
                     CONT.MSG #msg,
                     CONJ cnil ],
             NONLOC #nonloc & non-local_none & [ SLASH.LIST < > ],
             MODIFD [ LPERIPH +,
                      RPERIPH + ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & 
                                         [ VFORM fin ],
                                    VAL [ SUBJ < synsem &
                                                 [ LOCAL.CAT.HEAD noun ] >,
                                          SPR #spr,
                                          COMPS < > ] ],
                              CONJ cnil,
                              CONT [ HOOK [ LTOP #ltop,
                                            INDEX #index,
                                            XARG #sltop & basic_non_expl ],
                                     MSG #msg ] ],
                      NONLOC #nonloc ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #index,
                    XARG #sltop ],
             RELS <! !>,
             HCONS <! !> ] ].

;; 
;; Noun-noun compounds
;;

; Make left member be [ COMPS < > ] to avoid spurious ambiguity since we have
; separate lexical entries to handle optional nominal complements.
; DPF (22-Oct-98) Can't do the above, since it's not true for most nouns, and
; also won't work for "two fifteen meeting" where the am_pm argument is not
; expressed, but can't be discharged by the optcomp rule.

; DPF (4-Mar-99) - Removed the gratuitous some_rel, which was wrong for
; proper name left members of N-N compounds, and also wrong for hour words like
; "a one o'clock meeting" since "one o'clock" already supplied a 
; def_implicit_q_rel of its own.
; Added [ ALTKEY no_rel ] to non-head-dtr to block partitives, deverbal nouns,
; and other unwanted NPs with complex lexical semantics.
; DPF 09-Jan-00 - Also added [ ALTKEY no_rel ] to head-dtr, to block adj-nouns
; from compounds, as in "*Devito five" (ignoring for now "the Jackson five").
; 23-Oct-00 - Dropped NONHD-DTR's [AGR 3sg] constraint in order to allow
; "auto and mortgage loans", as well as "systems analyst" - the constraint is
; not really AGR 3sg, but perhaps something like lexeme vs. inflected word,
; where the lexeme might be conjoined, or even lexically marked as if it were
; plural, but still not [INFLECTD +].
; DPF 18-Aug-01 - Instead of that failed [AGR 3sg] constraint, made the non-hd
; be [INDEX 3sg], since conjoined nominals do not constrain the INDEX value.
; This lets us get 'auto and mortgage loans' while still blocking 'cats hairs'
; 23-Oct-00 - Changed NONHD-DTR's constraint, removing 'pronominal_synsem'
; and instead making the KEY be nonpro_rel, in order to allow conjoined 
; lexical NPs such as "auto and mortgage loans", where the synsem of the phrase
; will not be a subtype of nonpronominal_synsem.
; 17-Nov-00 - Removed 0-dlist specification for head-dtr and mother for
; QUE and REL, since this blocked e.g. "Which state office did he seek"
; DPF 1-Mar-01 - Changed COMPS < > to < > on non-head, now that we are 
; pumping nouns with complements.
; DPF 5-Apr-01 - Moved [LPERIPH -] from here to the noun-noun subtype, to 
; continue to block "towel rusty rack" but allow "1998 annual report".
; DPF 12-mar-05 - Added MODIFD notmod to avoid spurious ambiguity of
; prenom adjective attachment.
; DPF 14-nov-05 - Added MODIFD notmod_or_lmod to nonhd-dtr as well.

basic_n_n_cmpnd_phr := head_final & head_compositional & binary_punct_phrase &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT [ VAL #valence,
			   MC #mc ],
                     CONT.MSG #msg ],
	     NONLOC [ SLASH #slash,
                      QUE #que,
                      REL #rel ],
             MODIFD notmod,
             PUNCT.PNCTPR #ppair ],
    HD-DTR 
     [ INFLECTD #infl,
       SYNSEM synsem &
	   [ LOCAL [ CAT [ HEAD.KEYS.KEY nonpro_rel,
                           VAL #valence,
			   MC #mc ],
		     CONT.MSG #msg,
                     CONJ cnil ],
	     NONLOC [ SLASH #slash,
                      QUE #que,
                      REL #rel ],
             MODIFD notmod_or_lmod,
             PUNCT [ LPUNCT no_punct,
                     PNCTPR #ppair ] ] ],
    NH-DTR 
     [ SYNSEM 
	   [ LOCAL [ CAT [ HEAD.KEYS.KEY nonpro_or_mnp_rel,
                           VAL.COMPS < > ],
		     CONT.HOOK.INDEX ref-ind ],
             NONLOC [ SLASH 0-dlist & [ LIST < > ],
                      QUE 0-dlist,
                      REL 0-dlist ],
             MODIFD notmod_or_lmod ] ] ].

norm_n_n_cmpnd_phr := basic_n_n_cmpnd_phr &
  [ HD-DTR.SYNSEM [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                      INDEX #hind ] ],
    NH-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX #modind,
                    PUNCT [ LPUNCT pair_or_no_punct,
                            RPUNCT hyphen_or_pair_or_no_punct ] ],
    C-CONT.RELS.LIST < prep_notense_relation &
                       [ LBL #ltop,
                         PRED compound_rel,
                         ARG1 #hind,
                         ARG2 #modind ], ... > ].

; DPF 13-nov-05 - Changed mother's LEX from + to bool, to allow these to
; conjoin with phrasal nbars.  Not clear what effects ...
;
n_n_cmpnd_phr := norm_n_n_cmpnd_phr &
  [ SYNSEM lex_phr_synsem &
	   [ LOCAL.CAT.HEAD.MOD < >,
             LEX bool ],
    HD-DTR.SYNSEM 
	   [ LOCAL.CAT [ HEAD supnoun,
                         VAL.SPR < synsem & 
                                   [ OPT -,
                                     LOCAL.CAT.HEAD.KEYS.KEY quant_rel ] >]]].

; DPF 22-Mar-01 - It seems we need LEX + on non-head-dtr to block "an exactly 
; seven appointment", since we want "a seven o'clock appointment".  But why did
; we move LEX + down from the n_n_cmpnd_phr in the first place?
; DPF 6-Apr-01 - Added LPERIPH na_or_- to head-dtr to block "Browne five 
; dollars" while still allowing "1998 annual report".
; DPF 17-Apr-01 - Added LPERIPH na to mother to block NNN-cmpnd for "a reason 
; Kim left"
; DPF 5-Sep-03 - Changed HD-DTR..ALTKEY no_rel to def_or_udef_q_rel
; since ALTKEY now inherits from head-dtr to mother, but we still want to
; block proper names, numbers, etc as head dtrs.
; DPF 5-Sep-03 - And changed NH-DTR..ALTKEY to proper_q_rel.
; DPF 25-Nov-03 - Changed NHD's LEX from + to na_or_+ to allow conjoined
; proper names while still blocking "an exactly seven appointment"
; DPF 10-dec-03 - Since numerals are now LPERIPH na (to block spurious parse
; for "two hundred three chairs" while allowing "two hundred big chairs"),
; make head-dtr be LPERIPH bool, to still block "Browne five chairs" but get
; "IBM annual report"
; Also added PRD - to NHD to prevent measure phrases here in currency "usd 10"
; DPF 10-dec-03 - Tried adding HD-DTR..ALTKEY def_or_udef_q_rel to prevent 
; proper names, to avoid spurious analysis for e.g. "Kim Abrams".  But this
; conflicts with the no_rel constraint on NHD for N-N-cmpnd rule, blocking one
; analysis for "CSLI department manager".  So try restricting H-DTR..KEY to
; nom_nbar_rel.

np_n_cmpnd_phr := n_n_cmpnd_phr &
  [ SYNSEM.MODIFD.LPERIPH bool,
    HD-DTR.SYNSEM abstr_lex_synsem &
                      [ LEX +,
                        LOCAL.CAT.HEAD.KEYS.KEY nom_nbar_rel,
                        MODIFD.LPERIPH bool ],
    NH-DTR [ INFLECTD -,
             SYNSEM [ LOCAL [ CAT [ HEAD noun &
                                   [ KEYS [ KEY deg_or_named_rel,
                                            ALTKEY meas_np_or_proper_q_rel ],
                                     PRD - ],
                                    VAL [ SPR *anti_list*,
                                          SUBJ < > ] ],
                              CONT.HOOK.LTOP #lbl ],
                      LEX na_or_+,
                      MODIFD.LPERIPH + ] ],
    C-CONT [ RELS <! relation & [ LBL #lbl ] !>,
             HCONS <! !> ] ].

; 'A two o'clock appointment" - hour-noun's specifier is degree phrase, as in
; 'exactly two o'clock', but block '*an exactly two o'clock appointment'
; DPF 2-Jun-02 - Check this rule and the above, since unwanted phrase is 
; currently parsing.

np_n_cmpnd_phr_2 := n_n_cmpnd_phr &
  [ HD-DTR.SYNSEM abstr_lex_synsem &
                      [ LEX +,
                        MODIFD.LPERIPH na_or_- ],
    NH-DTR [ INFLECTD +,
                   SYNSEM basic_lex_synsem &
                    [ LOCAL [ CAT [ HEAD.KEYS.KEY numbered_hour_rel,
                                    VAL [ SPR < [ OPT +,
                                                  NONLOC non-local_none ] >,
                                          SUBJ < > ] ],
                              CONT.HOOK.INDEX.PNG.PN 3sg ],
                      LEX + ] ],
    C-CONT [ RELS <! relation !>,
	     HCONS <! !> ] ].

; For "Jim Smith"
; DPF 10-Apr-02 - Changed HD-DTR..KEY from named_np_rel to abstr_named_np_rel
; to allow number names, as in "Toshiba 3000" of "Toshiba 3000 laptop".  Also
; removed LEX + from HD-DTR for same reason.
; DPF 14-feb-04 - Removed MODIFD lmod since want these in appositive
; constructions.  

basic_np_name_cmpnd_phr := basic_n_n_cmpnd_phr &
  [ SYNSEM lex_phr_synsem & [ MODIFD.LPERIPH +,
                              LOCAL.CAT.HEAD.MOD < > ],
    HD-DTR.SYNSEM 
           [ LOCAL [ CAT [ HEAD noun &
                                [ KEYS.KEY named_np_or_num_rel ],
                           VAL.SPR < synsem & 
                                     [ OPT -,
                                       LOCAL.CAT.HEAD.KEYS.KEY quant_rel ] > ],
                     CONT.HOOK [ LTOP #ltop,
				 INDEX #ind ] ],
	     MODIFD notmod & [ LPERIPH + ] ],
    NH-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD noun &
                                         [ KEYS [ KEY named_np_rel,
                                                  ALTKEY proper_q_rel ] ],
                                    VAL.SPR < [ NONLOC non-local_none ] > ],
                              CONT.HOOK [ LTOP #nhltop,
                                          INDEX #nhind ] ],
                      MODIFD.LPERIPH +,
                      LEX +,
                      PUNCT.LPUNCT no_punct ] ],
    C-CONT [ RELS <! prep_notense_relation & 
		     [ LBL #ltop,
		       PRED compound_name_rel,
		       ARG1 #nhind,
		       ARG2 #ind ], 
                     [ PRED udef_q_rel,
                       ARG0 #nhind,
                       RSTR #rhand ] !>,
	     HCONS <! qeq & [ HARG #rhand,
                              LARG #nhltop ] !> ] ].

np_name_cmpnd_phr := basic_np_name_cmpnd_phr &
  [ NH-DTR.SYNSEM.PUNCT [ LPUNCT no_punct,
                          RPUNCT no_punct ] ].

np_city_state_phr := basic_np_name_cmpnd_phr &
  [ NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.KEYS.KEY named_city_rel,
                    PUNCT.RPUNCT comma_punct ] ].

; DPF 24-Sept-01 - Made LPERIPH of mother be same as LPERIPH of non-hd, to 
; block e.g. "*The table important consultant chair arrives".
; DPF 2-Jul-02 - Go back to making NH-DTR..ALTKEY be no_rel to block
; spurious compound analysis for v-gerund for "hiring Sandy", and let's see
; why we wanted to remove it in the first place.
; DPF 9-Oct-02 - Removed [OPT -] from NH-DTR..VAL.SPR, since it prevented
; compounds like "three pm meeting", and it's not clear what it was needed for.
; DPF 08-May-03 - Identified MODIFD of mother and non-hd-dtr (see 24-Sept-01)
; to preserve notmod or lmod status of the left member (not just the PERIPH
; value).
; DPF 05-Sep-03 - Replaced NH-DTR..ALTKEY no_rel with 
; def_or_udef_q_rel, since no_rel not needed to block verbal gerunds
; anymore, but still want to prevent proper names, while also getting second
; parse for "CSLI department manager".
; DPF 10-dec-03 - But this doesn't block proper names, since their ALTKEY
; only gets specialized to proper_q_rel when made an NP.  So go back to no_rel.
; DPF 10-dec-03 - Made LPERIPH of NHD be bool to exclude possibly spurious 
; analysis for "the ten foot chair".  But this would make the rule not 
; right-recursive, preventing the less likely analysis of "the tobacco garden 
; dog".  So drop constraint on NHD..LPERIPH, and live with the ambiguity.
; DPF 14-dec-03 - Wonder about motivation for 08-May-03 change, since this
; now prevents Adj-N-N from being modified by a PP, as in "big league baseball
; in Pittsburgh".  FIX.
; DPF 29-aug-04 - Re: 08-May-03, but this blocks PP-modification of compounds
; where the non-head happens to be modified, as in "tenth century church in
; Paris".  So return to only identifying the LPERIPH values (see 24-Sept-01),
; and insist that compounds are still notmod
; DPF 22-sept-04 - Changed NH-DTR..SPR *unexpcons* to just *cons* since we
; want e.g. 'nineteenth century farmhouse' where numadj+noun now requires
; the SPR to be expressed to avoid spurious ambiguity for 'five chairs'.
; DPF 09-may-05 - Since we want to constrain appositives to treat indefinites
; separately, we need ALTKEY for nouns to be contentful, reflecting their
; specifier's KEY.  But we still want to exclude proper names (and verbal
; gerunds?), so drop ALTKEY no_rel and instead use KEY nom_nbar_rel.
; DPF 05-oct-05 - Tried adding ALT2KEY no_rel to HD-DTR as well, to
; prevent non-compounding nouns from being heads as well as non-heads, as in
; "*the book next" analogous to blocking the unwanted reading for "next book".
; But this alas also blocks det-less noun compounds like 'sea level, where
; we don't want 'level' as left member, but do as head.  So instead make
; type for nouns like 'next' which can't be heads or non-heads.

noun_n_cmpnd_phr := n_n_cmpnd_phr &
  [ SYNSEM.MODIFD.LPERIPH #lperiph,
    HD-DTR.SYNSEM abstr_lex_synsem & 
                    [ MODIFD.LPERIPH na,
                      LEX + ],
    NH-DTR 
       [ INFLECTD -,
         SYNSEM abstr_lex_synsem &
                   [ LOCAL [ CAT [ HEAD noun_or_nomger & 
                                        [ PRD -,
                                          KEYS [ KEY nbar_or_nger_rel,
                                                 ALT2KEY no_rel ] ],
                                   VAL.SPR < [ NONLOC non-local_none ] > ],
                             CONT.HOOK [ LTOP #nltop,
                                         INDEX #nind ] ],
                     LEX +,
                     MODIFD.LPERIPH #lperiph ] ],
    C-CONT [ RELS <! prep_notense_relation &
                     [ PRED compound_rel ], 
                     [ PRED udef_q_rel,
                       ARG0 #nind,
                       RSTR #rhand ] !>,
	     HCONS <! qeq & [ HARG #rhand,
                              LARG #nltop ] !> ] ].

; for "[identification number] 222"

noun_title_cmpnd_phr := norm_n_n_cmpnd_phr &
  [ SYNSEM abstr_lex_synsem &
           [ LOCAL.CAT.HEAD.MOD #mod ],
    HD-DTR.SYNSEM abstr_lex_synsem & 
                    [ LOCAL.CAT [ HEAD ttl &
                                    [ MOD #mod & 
                                          < synsem &
                                            [ LOCAL.CAT nbar_cat_min ] > ] ],
                      LEX + ],
    NH-DTR [ INFLECTD +,
             SYNSEM abstr_lex_synsem &
                       [ LOCAL [ CAT [ HEAD noun & 
                                            [ PRD -,
                                              KEYS.ALT2KEY no_rel ],
                                       VAL.SPR *cons* &
                                            < [ OPT -,
                                                NONLOC non-local_none ] > ],
                                 CONT.HOOK [ LTOP #nltop,
                                             INDEX #nind  & [ PNG.PN 3sg ] ] ],
                         LEX + ] ],
    C-CONT [ RELS <! prep_notense_relation &
                     [ PRED compound_rel ], 
                     [ PRED udef_q_rel,
                       ARG0 #nind,
                       RSTR #rhand ] !>,
	     HCONS <! qeq & [ HARG #rhand,
                              LARG #nltop ] !> ] ].

;; Appositives
;; For now, restrict this to temporal nouns and proper names, since it's an 
;; overly enthusiastic rule.  So only get "Tuesday the tenth" and "Jim Smith"
;; (well, and also "Jim the tenth", but then it's only a hack anyway).
;; Use CASE feature hack on non-head to avoid unwanted "minor" NPs like 
;; minute_word as appositives: "seven thirty"
;; DPF 10-May-00 - In fact, restrict to only proper names, since the date
;; guys already come in via the npadv_mod rule.
;; DPF 11-Sept-01 - Restrict head-dtr to be reg_nom_rel (not basic_nom_rel)
;; to exclude deictic pronouns as in "that Kim", and further restrict to
;; explicit_q_rel so we can allow nonhead-dtr to include numbers as in
;; "the number five" but not "Abrams five".  This means we'll get as an
;; appositive "my friend Kim" but not "Kim my friend".  It means we also
;; block this analysis for "Lee Browne" - probably right.
;; DPF 12-Sept-01 - Restrict head-dtr to be PRD + to rule out free-relatives
;; DPF 18-Oct-01 - Removed [MODIFD notmod] from HD-DTR, since it blocks
;; 'my old friend kim'
;; DPF 4-Dec-02 - Made AGR..PN be strict_sort on the two dtrs, to exclude
;; as appositives e.g. "Kim and Sandy the book", even though this also rightly
;; will force another analysis to be constructed someday for 
;; "the brothers Grimm".
;; DPF 5-Sep-03 - Changed HD-DTR..ALTKEY from explicit_q_rel to quant_rel
;; to allow proper names which now have ALTKEY proper_q_rel.  Use SORT 
;; unification now to block "Abrams five" while allowing "the number five".
;; DPF 13-Nov-03 - Generalized to allow definite NPs as right dtrs, and
;; prevented recursion by use of LPERIPH.  [ALT2KEY no_rel] prevents np_adv's
;; like in "the chair here" or "here the chair"
;; DPF 27-jan-04 - Made MODIFD on non-hd dtr be notmod_or_rmod to prevent 
;; appositive analysis for "Kim interviewed Sandy".
;; But this blocks "my order # 12345", so undo, and instead make the
;; attr_adj_verb lexical rule restrict its MOD.KEYS.KEY value to block the
;; construction of "interviewed Sandy" in the first place, though this may
;; be too strong.
;; DPF 03-may-04 - Changed NHD..KEY from nonpro_rel to nonpro_or_num_rel,
;; to allow "Abrams, number five, arrived".  Still blocking "*Abrams five"
;; because the simple num-noun "five" is LPERIPH na.
;; DPF 16-jun-04 - Removed HD-DTR..LPERIPH bool since it blocks
;; "two people (Kim and Sandy)" since "two people" must be [LPERIPH na].
;; Not sure what overgeneration will result, but we'll see.
;; DPF 16-jul-04 - Added RPERIPH constraints on HD-DTR and mother to block
;; left recursion.
;; DPF 18-jul-04 - Made two subtypes of appos, one as before for proper
;; names and definite NPs ('Kim the doctor", "my brother Sandy") which allows
;; but does not require separating commas, and the other for indefinites
;; ("Kim, a manager, arrives') where commas are obligatory (to avoid a lot
;; of unwanted ambiguity as in 'We sent Kim a book').
;; DPF 20-aug-04 - Try changing HD-DTR..KEY from reg_nom_rel to
;; nonpro_or_num_rel, to admit "highway 55, the new road"
;; DPF 25-aug-04 - Restrict both dtrs to MSG no_msg, to exclude NPs derived
;; from S's or inf-VPs. 
;; DPF 26-sept-04 - Let's try requiring number agreement for the two dtrs,
;; to rule out spurious analysis for "another two of the chairs".
;; DPF 18-Nov-04 - Removed HD-DTR..PRD -, since this now excludes proper NPs
;; DPF 22-apr-05 - Try ruling out bare plurals as heads, to avoid spurious
;; ambiguity for "we sent two [consultants, Abrams and Browne]"

basic_appos_phr := head_initial_infl & head_compositional &
  [ SYNSEM phr_synsem &
	   [ LOCAL.CAT [ VAL #valence ],
	     NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             MODIFD [ LPERIPH na,
                      RPERIPH na ],
             PUNCT.LPUNCT no_punct ],
    HD-DTR.SYNSEM canonical_synsem &
	     [ LOCAL [ CAT [ HEAD noun & 
                                [ KEYS [ KEY nonpro_or_num_rel,
                                         ALT2KEY no_rel ] ],
                             VAL #valence &
                                  [ SPR *olist*,
                                    SUBJ < >,
                                    COMPS < > ] ],
                       CONT [ HOOK [ INDEX #hind & ref-ind &
                                           [ SORT #sort ],
                                     XARG #ltop ],
                              MSG no_msg ],
                       CONJ cnil,
                       AGR.PNG #png ],
               NONLOC [ SLASH 0-dlist,
                        QUE 0-dlist,
                        REL 0-dlist ],
               MODIFD.RPERIPH bool,
               PUNCT.RPUNCT comma_or_pair_or_no_punct ],
    NH-DTR.SYNSEM canonical_synsem &
  	     [ LOCAL [ CAT [ HEAD noun &
                                [ KEYS [ KEY nonpro_or_refl_or_num_rel,
                                         ALTKEY appos-able_rel,
                                         ALT2KEY no_rel ] ],
                             VAL [ SUBJ < >,
                                   SPR *olist*,
                                   COMPS < > ] ],
                       CONT [ HOOK.INDEX #modind &
                                         [ SORT #sort ],
                              MSG no_msg ],
                       AGR.PNG #png ],
               NONLOC [ SLASH 0-dlist & [ LIST < > ],
                        QUE 0-dlist,
                        REL 0-dlist ],
               MODIFD.RPERIPH bool ],
    C-CONT [ RELS <! prep_notense_relation &
                     [ LBL #ltop,
                       PRED appos_rel,
                       ARG1 #hind,
                       ARG2 #modind ] !>,
             HCONS <! !> ] ].

; For these two subtypes, see comment 7-may-05 for n_adj_relcl_phrase
appos_phr_nopair := basic_appos_phr &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    HD-DTR.SYNSEM [ LOCAL.CAT.HEAD.KEYS.ALTKEY explicit_or_proper_q_rel,
                    PUNCT.RPUNCT no_punct ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.KEYS.ALTKEY def_or_proper_q_rel,
                    PUNCT [ RPUNCT comma_or_clause,
                            PNCTPR #ppair ] ] ].

appos_phr_prpnct := basic_appos_phr &
  [ SYNSEM.PUNCT.PAIRED #paired,
    HD-DTR.SYNSEM.PUNCT [ PNCTPR #pnctpr,
                          PAIRED #paired ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.KEYS.ALTKEY def_or_meas_rel,
                    PUNCT [ PAIRED #pnctpr,
                            PNCTPR #paired ] ] ].

appos_indef_phr := basic_appos_phr &
  [ HD-DTR.SYNSEM.PUNCT [ RPUNCT comma_punct,
                          PNCTPR #ppair ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.KEYS.ALTKEY indef_or_meas_rel,
                    PUNCT [ RPUNCT comma_or_clause,
                            PNCTPR #ppair ] ] ].

;;
;; Adverbial-NP modifiers
;;

; DPF 11-Jun-99 - Added SUBJ..OPT - to prevent these temporal NPs from filling
; ordinary NP argument positions.
;
; DPF 26-Jul-99 - Changed [HEAD noun] to [HEAD prep] to avoid double parse
; for "Thursday the fourth" where "the fourth" attaches after "Thursday"
; is itself an npadv_mod phrase.
; DPF 9-Sept-99 - Added PRD - to mother, to block temp-mods as complements of
; copula.
; DPF 30-Sept-99 - But this blocks all post-nominal modification with temporal
; NPs, sigh.  Besides, the most natural reading of "The meeting is Tuesday" is
; with the temp-mod reading rather than the identity one.
; DPF 2-Sept-00 - Removed SPR, to avoid spurious analysis for "my mornings 
; look pretty booked tuesdays".  Don't recall why we wanted a SPR on these
; phrases.
; DPF 4-Apr-01 - Added PRD from dtr to prevent e.g. relpro "that" from being 
; the complement of copula, as in "the book that Kim is", while allowing "here
; are the books", which requires npadv_mod extraction from locative inversion.
; DPF 17-Jul-01 - Replaced SPR, since we want "leave right now", where the 
; nominal "now" gets pumped to a modifier, and can (only) then take a degree 
; specifier.  It seems the ambiguity of 2-Sept-00 is not spurious, just
; unlikely.
; DPF 25-Sep-01 - Added reentrancy of AGR and SUBJ's INDEX, to get no-copula
; constructions like "Kim in Berlin becoming impatient"
; DPF 2-Apr-02 - Made SUBJ be expressed_synsem rather than synsem, to prevent
; these phrases from appearing as complements of when_subord_prd.
; DPF 30-May-02 - But this also blocks "someone there".  So remove this
; constraint, and instead restrict the when_subord_prd complement to be
; non-temporal.
; DPF 9-May-02 - Identified INDEX.SORT of dtr and of mother, to avoid letting
; temporal NPs be fillers for ordinary adjunct extraction, which was giving
; us a spurious parse for e.g. "when did kim arrive"
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 2-May-03 - Try replacing dtr's [MODIFD hasmod] with [MODIFD lmod] to
; block "*KIm fell time that I did" but allow "Kim fell two times".  This
; seems to force us to have two lexical entries for "the", one which is notmod
; (as is its head sister), and one for modified nominals, where "the" stamps
; [MODIFD lmod] whether the nominal is right-modified or left-modified, so
; we still get "Kim arrived the week Sandy left".
; DPF 13-May-02 - Added SLASH <! !> to prevent spurious ambiguity for "Kim
; arrived when(ever) Sandy left". 
; DPF 27-May-03 - Re 2-May-03: But those two "the" entries have the effect of
; preventing us from using the intersective modification efficiency improvement
; for generation, since "the consultant" uses a different "the" than "the tall
; consultant", which means the generator's second-pass adjunction algorithm
; will fail to enrich "the consultant" to "the tall consultant".  Since that
; two-pass strategy depends on the phrase without modifiers being the "same"
; as the phrase with modifiers (at least using the same lexical entries), it
; seems to drive us back to just one entry for "the" which preserves the
; MODIFD value of its SPEC.  And then this rule requires that its dtr go back
; to just [MODIFD hasmod].  Not too troubling for this particular case, since
; the above example with "time" was playing on an ambiguity between the count
; and the mass senses, which we are treating as underspecification, perhaps
; wrongly.
; DPF 06-Jun-03 - Changed the identity of SORT on dtr and mother's INDEX, since
; this excluded temporal modifiers of non-temporal nouns ("meetings Tuesday"),
; and seemed counter-intuitive.  Rather we want the SORT of the dtr to 
; constrain the ARG0 of the derived "PP" itself (its E-INDEX), not what the PP 
; modifies.
; DPF 09-Jun-03 - Made dtr be MODIFD.LPERIPH bool to exclude "Kim arrived
; times I left"
; DPF 22-Jul-03 - Might think to make SPR's KEY be much_deg_rel rather than 
; simply degree_rel to avoid spurious ambig for "right now", given two entries
; "right" for 'very' and 'much' type degree specifiers.  But this blocks "too
; late" where "too" is not much-deg subtype.  
; DPF 16-oct-03 - Changed LPERIPH from bool to na_or_+ to be consistent with
; revised treatment of number adjectives
; DPF 30-oct-03 - Mysteriously, MOD was not restricted to non-empty SPR, which
; meant spurious parses attaching to both Nbar and NP (and VP and S).  Changed,
; but how unnoticed till now?  Also, --SIND on SUBJ was not co-indexed. Fixed
; DPF 01-may-04 - Continuing the pendulum swing of 2-Sept-00 and 17-Jul-01,
; removed SPR again, since we get "right now" as an NP, and have just added
; an analysis for "too late" and "too long" where these gradable NPs take
; "too", "very", etc. before pumping to PP.
; DPF 25-sept-04 - Removed SYNSEM..MOD..MSG no_msg, since we want to allow
; e.g. 'tomorrow, can you come' using adj_i_ques rule.  Rather, make MSG
; value same as that of MOD, like ordinary prepositions.
; DPF 12-nov-05 - Added MOD..ALT2KEY norm_rel to prevent these from 
; modifying lexical NP-adverbials as in e.g. "here there"
; DPF 05-dec-05 - Re: 25-sep-01 - Not clear what that comment meant, but
; removed AGR reentrancy since this was preventing e.g. "Here lies Kim"
; where the AGR ends up not being of type 'index'

npadv_mod_phrase := basic_unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD modnp &
				[ MOD < [ LOCAL intersective_mod &
					  [ CAT [ HEAD subst & 
                                                     [ AUX -,
                                                       KEYS.ALT2KEY norm_rel ],
                                                  VAL [ SPR < synsem_min >,
                                                        COMPS < > ],
                                                  MC #mc ],
                                            CONT [ HOOK.LTOP #ltop,
                                                   MSG #msg ],
                                            CONJ cnil ],
                                          NONLOC.REL 0-dlist,
                                          --SIND #ind & non_expl ] >,
                                  TAM #tam,
                                  KEYS [ KEY unspec_loc_rel,
                                         ALTKEY #argkey ],
                                  PRD #prd ],
                           POSTHD +,
			   VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS #comps ],
			   MC #mc ],
		     CONT [ HOOK [ LTOP #ltop,
                                   XARG #ind,
                                   INDEX [ SORT #sort ] ],
			    MSG #msg ],
                     CONJ cnil,
                     CTXT #ctxt ],
             NONLOC #nonloc & [ REL 0-dlist,
                                SLASH 0-dlist ],
             ROOT -,
             PUNCT #punct ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD noun & 
                                         [ KEYS.KEY modable_rel & #argkey,
                                           PRD #prd ],
                                    VAL [ SPR *olist*,
                                          SUBJ < >,
					  COMPS #comps & < > ] ],
			      CONT.HOOK.INDEX #index & [ SORT #sort ],
			      CONJ cnil,
                              CTXT #ctxt ],
                      NONLOC #nonloc,
		      MODIFD hasmod & [ LPERIPH na_or_+ ],
                      PUNCT #punct ],
             POSSCL #posscl ] >,
    C-CONT [ HOOK [ LTOP #khand,
                    INDEX #arg0 ],
	     RELS <! prep_relation &
                     [ LBL #khand,
                       PRED unspec_loc_rel,
                       ARG0 #arg0 & [ E #tam ],
                       ARG1 #ind & event_or_index,
                       ARG2 #index ] !>,
	     HCONS <! !> ],
    INFLECTD +,
    POSSCL #posscl ].

; DPF 5-Feb-01 - Restrict mother's SPEC..HEAD value to adj for now, to block
; silly analysis for e.g. "There are a bookcase in the office."
; DPF 22-Apr-01 - Added MODIFD identification of mother and left daughter to
; distinguish "an inch" from "one inch" as in "I need one inch nails" but not
; "*I need a inch nails".  Corresponds here roughly to left stress.
; DPF 8-Jan-02 - Removed above constraint on SPEC, since this also blocked
; "Kim arrived two days before Sandy".  Instead, prevent most PPs from taking
; measure-NP specifiers.
; DPF 11-Feb-02 - Made INDEX.SORT of phrase be that of right dtr to enable
; blocking of meas-NP analysis of "a laptop" in "Can you get me a laptop before
; Christmas"
; DPF 2-Apr-02 - Changed SPEC..HEAD from a_or_adv to a_or_p since we don't
; want "ten times competently".  Will need to do something for comparative
; adverbs like "faster" as in "ten times faster".
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 17-Jul-03 - Changed C-CONT.RELS deg_rel to much_or_very_deg_rel, since 
; we want MNP specifiers for comparatives as well, but still exclude them for
; e.g. subordinating conjunctions.
; DPF 10-dec-03 - Made DTR1 be COMPS < > to avoid spurious measure-NP for e.g.
; "thirty foot" - possible now that we've changed analysis for currency as in
; "usd 10"
; DPF 6-jun-04 - Changed SPEC..HEAD from a_or_p to n_or_p_or_a to also allow
; e.g. "ten weeks early"
; DPF 23-aug-04 - Considered extended it further to n_or_p_or_a_or_adv, to 
; allow "ten miles further on" where "further" is treated as a degree-spec,
; but this creates massive spurious ambiguity with constituents for e.g. 
; "peaks approximately".  And probably there's another analysis for 
; "further into the woods", at least one where that "further" is still a noun.

basic_measure_np_phrase := phrase &
  [ INFLECTD #infl,
    SYNSEM phr_degree_spec_synsem &
           [ LOCAL [ CAT [ HEAD.KEYS [ KEY much_or_very_deg_rel,
                                       ALTKEY #key ],
                           VAL [ SPEC < synsem &
                                       [ LOCAL [ CAT.HEAD n_or_p_or_a,
                                                 CONT.HOOK.LTOP #sltop ] ] > ] ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             ROOT - ],
    DTR1 [ INFLECTD #infl,
           SYNSEM basic_lex_synsem &
                  [ LOCAL [ CAT [ HEAD noun &
                                       [ KEYS.KEY #key & nonpro_rel ],
                                  VAL [ SUBJ < >,
                                        SPR < canonical_synsem &
                                              [ OPT -,
                                                LOCAL local &
                                                 [ CAT.HEAD.KEYS.KEY 
                                                               udef_q_rel ],
                                                NONLOC 
                                                    [ SLASH 0-dlist,
                                                      REL 0-dlist,
                                                      QUE 0-dlist ] ] >,
                                        COMPS < > ] ],
                            CONJ cnil,
                            CONT [ HOOK [ LTOP #nhand,
                                          INDEX #nindex & 
                                               [ PNG.PN pernum ] ],
                                   MSG no_msg ] ],
                    NONLOC.SLASH 0-dlist,
                    MODIFD.LPERIPH bool ] ],
    C-CONT [ HOOK [ INDEX #nindex,
                    XARG #argind ],
             RELS.LIST < arg12_relation & [ PRED measure_rel,
                                            LBL #sltop,
                                            ARG0.E [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                            ARG1 #argind,
                                            ARG2 #nindex ],
                         [ PRED udef_q_rel,
                           ARG0 #nindex,
                           RSTR #rhand ], ... >,
             HCONS.LIST < qeq &
                          [ HARG #rhand,
                            LARG #nhand ], ... > ] ].

; For "days ago", "miles high"
; DPF 15-Nov-03 - Made bare-MNPs HEAD adv to prevent "*days arrive(s)" etc.
; DPF 26-aug-04 - Restrict dtr to be KEY abstr_meas_nom_rel to exclude
; spurious edges for ordinary plural nouns.
; DPF 21-dec-05 - Re 15-Nov-03: This prevented "We arrive in hours", so
; instead make HEAD noun, but CASE obliq.

bare_measure_np_phrase := norm_unary_phrase & basic_measure_np_phrase &
  [ INFLECTD +,
    SYNSEM.LOCAL [ CAT [ HEAD noun & [ CASE obliq ],
                         VAL [ SPR < anti_synsem_min >,
                               COMPS < > ] ],
                   AGR #agr ],
    DTR1 #dtr1 & [ INFLECTD +,
		   SYNSEM [ LOCAL [ CAT.HEAD.KEYS.KEY abstr_meas_nom_rel,
                                    AGR #agr & [ PNG.PN 3pl ] ],
                            MODIFD notmod,
                            LEX + ] ],
    C-CONT [ RELS <! relation, relation !>,
             HCONS <! qeq !> ],
    ARGS < #dtr1 > ].

; DPF 12-Apr-03 - Added CARDINAL + to DTR2 to block e.g. 'first day' as meas-NP
; DPF 27-jul-04 - Removed DTR2..SPR *olist* to get 'the million dollar view'
; DPF 20-aug-04 - Removed MODIFD notmod, since this prevents "ten miles east"
; from being an npadv, since the hspec rule takes its MODIFD value from the
; non-hd dtr.  Don't know what this constraint was ruling out - we'll see.
; DPF 19-nov-04 - Considered making mother be MODIFD lmod, in order to avoid 
; seemingly spurious ; attachment of posthead modifiers to measure-NP, as in 
; "ten dollars that Kim hired".  (The current analysis of "ten miles east" has 
; "ten miles" as a specifier of "east".)  But this constraint would block e.g.
; "ten miles on artificial snow is hard work", so we live with the ambiguity.

binary_measure_np_phrase := binary_punct_phrase & basic_measure_np_phrase &
  [ INFLECTD #bool1,
    SYNSEM.LOCAL [ CAT [ HEAD noun & [ PRD #bool ],
                         VAL [ COMPS #comps,
                               SPEC < [ LOCAL.CAT.HEAD.PRD #bool1 ] > ] ],
                   AGR.PNG.PN 3sg ],
    DTR2 [ INFLECTD +,
           SYNSEM [ LOCAL [ CAT [ HEAD intadj & 
                                   [ PRD #bool,
                                     CARDINAL +,
                                     KEYS.KEY const_rel,
                                     MOD < [ PHON.ONSET #onset,
                                             LOCAL [ CAT.HEAD.KEYS.KEY #key,
                                                     AGR #agr ] ] > ],
                                  VAL.COMPS #comps & *phrlist* ],
                            CONT.HOOK [ LTOP #nhand,
                                        INDEX.E [ TENSE no_tense,
                                                  ASPECT no_aspect ],
                                        XARG #index ],
                            CONJ cnil ],
                    LEX + ] ],
    DTR1 [ INFLECTD #bool1,
           SYNSEM [ LOCAL [ CAT.HEAD.KEYS.KEY #key,
                            CONT.HOOK [ LTOP #nhand,
                                        INDEX #index ],
                            AGR #agr ],
                    PHON.ONSET #onset ] ],
    C-CONT [ RELS <! relation,
                     relation !>,
             HCONS <! qeq !> ] ].

; DPF 16-May-01 - Cannot have [DTR1..COMPS < >] (as desired to avoid spurious
; parse for "he is ten pounds heavier" where "pound" takes optional pp-of),
; since cannot discharge that optional complement if the noun is uninflected,
; as in "the ten pound heavier guy".  So allow spurious analysis for now.

measure_np_phrase := binary_measure_np_phrase &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    DTR1 #dtr1 & [ SYNSEM.PUNCT.PNCTPR #ppair ],
    DTR2 #dtr2 &
         [ SYNSEM.PUNCT.RPUNCT hyphen_sgl_or_no_punct ],
    ARGS < #dtr2, #dtr1 > ].

; For $ 100 (100 dollars) where the head precedes the integer.  
; DPF 16-May-01 - Suggests that the rule for measure_nps should be a 
; non-branching rule.  Especially given the difficulty of pp-of nouns noted 
; just above. But would have to allow "sixty" and "dollar" to combine in
; general, then block most of the time - sigh.  Leave for now.

measure_np_symbol_phrase := binary_measure_np_phrase & 
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    DTR1 #dtr1 & [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mnp_symb_rel ],
    DTR2 #dtr2 & [ SYNSEM.PUNCT.PNCTPR #ppair ],
    ARGS < #dtr1, #dtr2 > ].

; DPF 5-Apr-01 - For "two hundred is enough"
; DPF 13-May-01 - Added [SYNSEM..LPERIPH +] to prevent these numbers from
; being modified.
; DPF 31-Oct-01 - But this blocks "order 123 for a chair was cancelled."
; DPF 22-May-01 - Added [LEX -] to prevent these from appearing as left members
; of noun-noun compounds as in "sixty books".
; DPF 29-May-02 - Removed MOD < synsem > from ARGS.FIRST, so "one" can also
; undergo this rule.
; DPF 31-May-02 - Added [ARGS..FIRST..HEAD.PRD -] to block "a/an"
; DPF 19-Oct-02 - Want to preserve LEX value on mother from dtr, so change
; from 22-May-01 and instead make mother be ALTKEY never_unify_rel, to still 
; prevent n-n-cmpnd participation.  Also make sign not phrasal.
; DPF 28-Nov-02 - HOOK comes only from C-CONT, since rule further specifies
; key integer relation to named_num_rel.
; DPF 01-Feb-03 - Required daughter's SPR to be saturated, to block e.g.
; "*hundred arrives".
; DPF 23-May-03 - Returned to issue from 31-Oct-01, and put back constraint
; preventing modification - getting too many spurious parses for "ten to three"
; and that purported counterexample is presumably non-restrictive modification
; of some kind (cf oddness of NP without title: "123 for a chair").
; DPF 5-Sep-03 - Changed ALTKEY never_unify_rel to number_q_rel so it will
; still undergo num_np rule.
; DPF 5-Sep-03 - Added CARDINAL + to prevent num. "third" from becoming a noun.
; DPF 16-oct-03 - Added SORT number to mother, to prevent "Abrams five" compnd.
; DPF 03-may-04 - But this SORT constraint prevented e.g. "that box is number
; five" and "my candidate, number five, lost".  So instead make use of the
; nonpro_rel constraint on heads of N-N-compounds, and make named_num_rel not
; be a subtype of nonpro_rel.
; DPF 03-may-04 - Changed SPR number_q_rel to def_or_proper_q_rel (and same
; for HEAD..ALTKEY) to also allow "My (number) five arrived" 
; DPF 03-may-04 - Changed LPERIPH from + to na in order to prevent simple
; num-nouns from appearing as appositives ("*Abrams five"), while allowing
; modified numbers there ("Abrams, number five, arrived")

num_noun_phrase := unary_phrase &
  [ SYNSEM [ LOCAL [ CAT nbar_cat & 
                         [ HEAD [ MOD < >,
                                  KEYS [ KEY #altkey & named_num_rel,
                                         ALTKEY def_or_proper_q_rel ] ],
                           VAL [ SPR < [ LOCAL [ CAT.HEAD.KEYS.KEY 
                                                     def_or_proper_q_rel,
                                                 AGR.PNG.PN 3sg ],
                                         OPT - ] >,
                                 SPEC < anti_synsem_min > ] ],
                     CONT nom-obj &
                         [ HOOK [ LTOP #nhand,
                                  INDEX #index & [ SORT entity ] ],
                           HCONS <! !> ],
                     CONJ cnil,
                     AGR.PNG.PN 3sg ],
             NONLOC #nonlocal,
             LEX #lex,
             MODIFD lmod & [ LPERIPH na ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD intadj & 
                                         [ PRD -,
                                           CARDINAL +,
                                           KEYS [ KEY integer_rel,
                                                  ALTKEY #altkey ] ],
                                    VAL [ SPR *anti_list*,
                                          COMPS < > ] ],
                              CONJ cnil,
                              CONT.HOOK [ LTOP #nhand,
                                          INDEX #index & [ PNG.PN 3pl ] ] ],
                      NONLOC #nonlocal,
                      LEX #lex ] ] >,
    C-CONT.RELS <! !> ].

; DPF 19-Oct-02 - Restricted dtrs to be LEX + to avoid spurious ambiguity
; for e.g. "two thirty to five".  Also made mother LEX + to allow recursion,
; removing phrasal parent as well, 
; and made mother ALTKEY number_q_rel to still prevent these guys in 
; n-n-compnds.
; DPF 28-Nov-02 - HOOK comes only from C-CONT

num_noun_sequence_phrase := binary_phrase &
 [ SYNSEM [ LOCAL [ CAT nomp_cat & 
                        [ HEAD noun & 
                               [ MOD < >,
                                 KEYS [ KEY num_seq_nom_rel,
                                        ALTKEY number_q_rel ] ] ],
                    CONT nom-obj &
                        [ HOOK [ LTOP #hand,
                                 INDEX #index & [ SORT #sort ] ],
                          HCONS <! !> ],
                    CONJ cnil,
                    AGR #index & [ PNG.PN 3sg ] ],
            NONLOC #nonlocal,
            LEX +,
            PUNCT.PNCTPR #ppair ],
   ARGS < [ SYNSEM [ LOCAL [ CAT nomp_cat &
                                 [ HEAD.KEYS.KEY named_num_or_seq_rel ],
                             CONJ cnil,
                             CONT.HOOK.INDEX #index1 ],
                     NONLOC #nonlocal,
                     PUNCT.RPUNCT no_punct,
                     LEX + ] ],
          [ SYNSEM [ LOCAL [ CAT nomp_cat &
                                 [ HEAD.KEYS.KEY named_num_rel ],
                             CONJ cnil,
                             CONT.HOOK.INDEX #index2 & [ SORT #sort ] ],
                     NONLOC #nonlocal,
                     PUNCT [ RPUNCT clause_or_no_punct,
                             PNCTPR #ppair ],
                     LEX + ] ] >,
   C-CONT.RELS <! [ LBL #hand,
                    PRED num_seq_rel,
                    ARG0 #index,
                    L-INDEX #index1,
                    R-INDEX #index2 ] !> ].


; DPF 12-Mar-99 - Can't simply identify HEAD of HD-DTR with SLASH..HEAD of 
; NH-DTR, since these two HEAD values themselves include MOD, which 
; includes SUBJ values, which include CONT, and since the free relative
; combines with an S (not a VP), that SUBJ.CONT of the S/NP is now identified
; with the semantics of the S/NP's subject, but now it's not possible to
; use the free_rel phrase as a VP modifier, because it will eventually want to
; unify that same MOD.SUBJ.CONT with that of the subject of the VP that the
; free_rel modifies, but the RELS value of that attribute is already bound to 
; the earlier subject's RELS.
;   So we have each free-rel lexical entry specify the relevant constraints on
; the SLASH of its sister in this construction.
;   The QUE value of the free relatives is a singleton list containing an index
; instead of a handle - this distinguishes free relatives from question words,
; and makes available this index for interpretation at the ltop of the phrase,
; which may be desirable if there is indeed ambiguity in the meaning of
; examples like "I'll interview whoever's frog wins this race."  (We're not
; doing anything with that index just now, beyond checking for its presence.)
; DPF (1-May-99) Removed identification of HD-DTR..KEY and NHD-DTR..SLASH..KEY
; since the slash's KEY is already identified with the main verb's KEY in the
; non-head dtr, for independent reasons.  Don't know what work this was supposed
; to do, anyway.
;
; DPF 10-Jun-99 - Added SUBJ *olist* to head-dtr, to prevent e.g. "one to three".
; DPF 24-Mar-01 - Removed [MODIFD notmod] from mother, since free-rels need
; to be able to undergo npadv_mod_phrase.

; DPF 8-Nov-01 - Made non-hd-dtr be either infinitival or finite in
; order to get "advise me on where to go" as well as "advise me on where I 
; should go"

free_rel_phrase := head_initial_infl & head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ HEAD n_or_p,
			   MC na,
			   VAL [ SUBJ < >,
				 COMPS < >,
				 SPR < > ],
			   POSTHD + ],
                     CONJ cnil,
                     CONT.MSG no_msg ],
	     NONLOC [ SLASH 0-dlist,
			 QUE 0-dlist,
			 REL 0-dlist ],
             LEX -,
             PUNCT.PNCTPR #ppair ],
    HD-DTR.SYNSEM [ LOCAL local_min &
			    [ CAT [ HEAD.KEYS [ KEY #key & independent_rel,
                                                ALTKEY #altkey ],
                                    VAL [ COMPS < >,
                                          SPR *olist*,
                                          SUBJ *olist* ] ],
                              CONT.HOOK [ INDEX #ind,
                                          XARG #hand ] ],
                    NONLOC [ QUE 1-dlist & <! ref-ind !>,
                             SLASH 1-dlist &
                                 <! local_min & #loc !> ],
                    PUNCT.RPUNCT no_punct ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal & [ VFORM fin_or_inf,
                                                  INV - ],
                                  VAL [ SPR *olist*,
                                        COMPS < > ],
                                  MC - ],
                            CONT [ HOOK.LTOP #hand,
                                   MSG message & [ TPC #ind ] ] ],
                    NONLOC [ SLASH 1-dlist &
                                   <! #loc &
                                    [ CAT [ HEAD.KEYS [ KEY #key,
                                                        ALTKEY #altkey ],
                                            VAL [ COMPS < >,
                                                  SPR *olist* ] ] ] !>,
                             QUE 0-dlist,
                             REL 0-dlist ],
                    PUNCT.PNCTPR #ppair ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

free_rel_inf_phrase := free_rel_phrase &
  [ NH-DTR.SYNSEm.LOCAL.CAT [ HEAD comp & [ VFORM inf ],
                                    VAL.SUBJ < synsem & 
                                               [ NONLOC.SLASH 0-dlist ]>]].

free_rel_fin_phrase := free_rel_phrase &
  [ NH-DTR.SYNSEm.LOCAL.CAT [ HEAD verb & [ VFORM fin ],
                                    VAL.SUBJ *olist* ] ].

; For "two hundred twenty remain"
; DPF 31-May-02 - Added [ARGS..FIRST..HEAD.PRD -] to block "a/an"
; DPF 3-Jul-02 - Added [ARGS..INDEX..PN 3pl] to block "one", since already
; get determiner-partitive for "one".
; DPF 19-Oct-02 - Made SPR be LEX + to avoid getting complex measure-NPs
; as specifiers.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 01-Feb-03 - Since we now require the COMPS list to be empty for all NPs,
; and we also constrain the noptcomp rule to apply only to lexical heads (to
; get the interaction with noun-noun compounds right), we have to have two
; rules for partitive numbers, one for no-complement ones as in "three arrive"
; and one for those with of-PP complement, as in "three of them arrive".  This
; is in fact parallel to what we've decided to do for ordinary partitives, so
; no real surprise.
; DPF 13-May-03 - From 3-Jul-02, undid this since now using this rule instead
; for "one" partitive.
; DPF 05-Dec-03 - Added [SORT entity] to prevent spurious parses for 'from ten
; o'clock to eleven'.
; DPF 10-dec-03 - ARGS..SPEC *synlist* excludes ordinary NPs which have
; SPEC < anti_synsem > to distinguish them from measure NPS.  So this rule
; applies to numerals ('ten', 'forty-two') and measure NPs: 'ten miles of road'
; DPF 20-sept-04 - Removed SPR..QUE 0-dlist from mother, since we need e.g.
; "which one (of the students) arrived?"
; DPF 7-mar-05 - Removed ARGS..MOD < [ LOCAL.AGR #index ] > since this
; prevented meas-NPs from undergoing it.  Maybe redundant anyway?
; DPF 14-mar-05 - Added LPERIPH na to prevent these from being modified by 
; pre-head cardinal adjectives, as in spurious "The twenty seven arrive"
; DPF 14-apr-05 - Added MODFID notmod to dtr, to prevent "*three in paris of
; the chairs".

basic_partitive_num_phrase := unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD partn &
                                [ MOD < >,
                                  POSS - ],
                           VAL [ SUBJ < >,
                                 SPR < synsem &
                                       [ LOCAL local_min &
                                               [ CAT.VAL [ SPR  *olist*,
                                                           COMPS < > ],
                                                 AGR #index ],
                                         NONLOC [ REL 0-dlist,
                                                  QUE #que ],
                                         LEX + ] > ],
                           HC-LEX - ],
                     CONT nom-obj & [ MSG no_msg ],
                     CONJ cnil,
                     AGR #agr ],
             NONLOC.QUE #que,
             MODIFD.LPERIPH na,
             ROOT - ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD adj_partitive &
                                         [ PRD -,
                                           MOD < synsem &
                                                 [ LOCAL.AGR #agr ] > ],
                                    VAL [ SUBJ < >,
                                          COMPS < > ] ],
                              CONJ cnil,
                              CONT.HOOK [ LTOP #nhand,
                                          XARG #index  ] ],
                      MODIFD notmod,
                      PUNCT.LPUNCT no_punct ] ] >,
    C-CONT [ HOOK.INDEX #index & [ SORT entity ],
	     RELS.LIST < [ LBL #nhand,
                           ARG0 #index ], ... > ] ].

; DPF 9-apr-05 - Try making SPR..KEY be just_only_deg_rel rather than
; just_only_degree_rel, excluding 'very' and its ilk: "*very five of the 
; chairs"
partitive_np_num_phrase := basic_partitive_num_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.KEYS.ALTKEY def_explicit_q_rel,
                       VAL.SPR < [ LOCAL [ CAT.HEAD adv &
                                             [ KEYS.KEY just_only_deg_rel ],
                                           CONT.HOOK.LTOP #hand ],
                                   NONLOC.QUE 0-dlist ] > ],
    ARGS < [ SYNSEM.LOCAL.CAT [ HEAD intadj,
                                VAL [ SPEC *synlist*,
                                      SPR *anti_list* ] ] ] >,
    C-CONT [ RELS <! [ LBL #nhand,
                       ARG0 #index & ref-ind ],
                     [ LBL #hand,
                       PRED udef_q_rel,
                       ARG0 #index,
                       RSTR #phand ] !>,
	     HCONS <! qeq & [ HARG #phand,
                              LARG #nhand ] !> ] ].

; DPF 03-may-04 - Changed generic_entity_rel to num_nocmpnd_rel to prevent
; these in N-N-cmpnds or appositives
basic_partitive_num_nocomp_phrase := basic_partitive_num_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
             NONLOC [ SLASH #slash,
                      REL 0-dlist ] ],
    ARGS < [ SYNSEM [ NONLOC [ SLASH #slash,
                               QUE 0-dlist,
                               REL 0-dlist ],
                      PUNCT.RPUNCT comma_or_clause_or_no_punct ] ] >,
    C-CONT.RELS.LIST.FIRST.PRED generic_entity_rel ].

basic_partitive_num_ppof_phrase := basic_partitive_num_phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD.KEYS.KEY part_of_rel,
                         VAL.COMPS < synsem &
                                 [ LOCAL local_min &
                                         [ CAT [ HEAD prep & 
                                                  [ PRD -,
                                                    TAM [ TENSE nontense,
                                                          ASPECT no_aspect ],
                                                    KEYS.KEY 
                                                        _of_p_sel_rel ],
                                                 VAL.COMPS < > ],
                                           CONT.HOOK.INDEX #arg ],
                                   NONLOC #nonloc &
                                         [ SLASH 0-dlist,
                                           QUE 0-dlist ],
                                   OPT - ] > ],
             NONLOC #nonloc ],
    C-CONT.RELS.LIST.FIRST reg_diadic_nom_relation &
                           [ PRED part_of_rel,
                             ARG1 #arg & non_expl-ind ] ].

partitive_num_nocomp_phrase := partitive_np_num_phrase &
                               basic_partitive_num_nocomp_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY num_nocmpnd_rel ].

partitive_num_ppof_phrase := partitive_np_num_phrase &
                             basic_partitive_num_ppof_phrase.

; Added variant of this rule for "the first (of the papers) was long" and
; "those two were good", where the conversion from adj to noun produces
; a common noun (still requiring a determiner), rather than an NP.
; DPF 26-aug-04 - Restrict ordinals to being DIV -, so they only appear
; with a determiner, to block "*I hired seventh (of the applicants)"

partitive_intadj_phrase := basic_partitive_num_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD.KEYS.ALTKEY explicit_q_rel,
                         VAL.SPR < expressed_synsem &
                                 [ LOCAL.CAT.HEAD det,
                                   OPT - ] > ],
                   CONT.HOOK.INDEX.PNG #png,
                   AGR #agr & [ PNG #png ] ],
    ARGS < [ SYNSEM.LOCAL.CAT [ HEAD intadj_or_superl & 
                                     [ MOD < [ LOCAL.AGR #agr ] > ],
                                VAL [ SPEC < anti_synsem_min >,
                                      SPR *anti_list* ] ] ] >,
    C-CONT [ HOOK.LTOP #nhand,
             RELS <! [ LBL #nhand ] !>,
	     HCONS <! !> ] ].

partitive_intadj_nocomp_phrase := partitive_intadj_phrase &
                                  basic_partitive_num_nocomp_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS [ KEY part_nc_rel,
                                 ALTKEY quant_or_wh_rel ] ].

partitive_intadj_ppof_phrase := partitive_intadj_phrase &
                                basic_partitive_num_ppof_phrase.

; For 'five chairs arrived' where 'five' is a determiner which can optionally
; take a degree specifier as in 'exactly five chairs arrived', contrasted
; with adjectival 'five' as in 'those five chairs arrived': '*those exactly
; five chairs arrived'.

num_det_phrase := unary_phrase &
  [ SYNSEM basic_det_synsem &
           [ LOCAL [ CAT [ HEAD.KEYS [ KEY num_q_rel,
                                       ALTKEY dofw_or_poss_q_rel ],
                           VAL [ SPEC < [ LOCAL [ CONT.HOOK.LTOP #nhand,
                                                  AGR.PNG.PN #pn ] ] >,
                                 COMPS < > ] ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ] ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD intadj & 
                                         [ CARDINAL +,
                                           PRD -,
                                           MOD < synsem &
                                                 [ LOCAL.AGR.PNG.PN #pn ] > ],
                                    VAL.COMPS < > ],
                              CONJ cnil,
                              CONT.HOOK [ LTOP #nhand,
                                          INDEX event & [ E.TENSE no_tense ],
                                          XARG #index  ] ],
                      NONLOC [ SLASH 0-dlist,
                               QUE 0-dlist,
                               REL 0-dlist ],
                      PUNCT.LPUNCT no_punct ] ] >,
    C-CONT [ HOOK.INDEX #index,
	     RELS <! [ PRED udef_q_rel,
                       ARG0 #index,
                       RSTR #rstr ] !>,
             HCONS <! qeq & [ HARG #rstr,
                              LARG #nhand ] !> ] ].


; DPF 11-Oct-02 - It seems that this rule is only used for robust parsing
; where a word like "covers" has to be analyzed as a possessive.  So let's
; make it ROBUST + (11-may-05: Now GENRE robust).
; DPF 28-Nov-02 - HOOK comes only from C-CONT

possessed_np_phrase := norm_unary_phrase & phrasal &
 [ INFLECTD +,
   POSSCL -,
   SYNSEM [ LOCAL [ CAT [ HEAD det & [ POSS +,
                                       MOD < >,
                                       KEYS [ KEY def_implicit_q_rel,
                                              ALTKEY poss_rel ] ],
                          VAL [ SUBJ < >,
                                SPR < >,
                                COMPS < >,
                                SPEC < [ LOCAL.CONT.HOOK [ LTOP #phand,
                                                           INDEX #index ]]>] ],
                    CONJ cnil ],
            NONLOC #nonlocal ],
   ARGS < [ INFLECTD +,
            POSSCL +,
            SYNSEM [ LOCAL [ CAT nomp_cat_min &
                                 [ HEAD.KEYS.KEY nonpro_rel ],
                             CONT.HOOK.INDEX #pindex & individual,
                             CONJ cnil ],
                     NONLOC #nonlocal ] ] >,
   C-CONT [ HOOK.INDEX #index,
            RELS <! [ PRED def_implicit_q_rel,
                      ARG0 #index,
                      RSTR #rhand ],
                    [ LBL #phand,
                      PRED poss_rel,
                      ARG2 #pindex,
                      ARG1 #index ] !>,
            HCONS <! qeq & [ HARG #rhand,
                             LARG #phand ] !> ],
   GENRE robust ].

; For "the book's is red"

partitive_np_phrase := norm_unary_phrase & phrasal &
 [ INFLECTD +,
   SYNSEM [ LOCAL [ CAT [ HEAD partn &
                               [ MOD < >,
                                 POSS -,
                                 KEYS [ KEY basic_pron_rel,
                                        ALTKEY #argkey ] ],
                          VAL [ SPR < >,
                                SUBJ < >,
                                COMPS < > ] ],
                    AGR #agr,
                    CONJ #conj & cnil,
                    CONT nom-obj & [ HOOK #hook & [ INDEX #agr ] ] ],
            NONLOC #nonloc ],
   ARGS < [ INFLECTD +,
            SYNSEM phr_synsem & 
                  [ LOCAL [ CAT [ HEAD det & [ POSS +,
                                               KEYS [ KEY #argkey &
                                                          explicit_q_rel,
                                                      ALTKEY poss_rel ] ],
                                  VAL [ SPR < >,
                                        COMPS < >,
                                        SPEC < [ LOCAL.CONT.HOOK #hook &
                                                      [ LTOP #phand,
                                                        INDEX #index ] ] > ] ],
                            CONJ #conj ],
                    NONLOC #nonloc ],
            POSSCL #posscl ] >,
   C-CONT [ HOOK.INDEX #index,
            RELS <! [ LBL #phand,
                      PRED generic_entity_rel,
                      ARG0 #index ] !>,
            HCONS <! !> ],
   POSSCL #posscl ].


; Vocatives
vocative_np_phrase := norm_unary_phrase & phrasal &
 [ INFLECTD +,
   SYNSEM disc_adv_phr_synsem &
            [ LOCAL [ CAT [ HEAD [ PRD -,
                                   MOD < [ LOCAL scopal_mod &
                                            [ CAT [ HEAD adverbee &
                                                      [ TAM.TENSE real_tense ],
                                                    VAL.SUBJ *olist* ],
                                              CONT [ HOOK [ LTOP #ltop,
                                                            INDEX #index,
                                                            XARG #xarg ],
                                                     MSG #msg ] ] ] >,
                                   KEYS.KEY abstr_excl_rel ],
                            MC + ],
                      CONT.MSG #msg,
                      CONJ #conj ],
              NONLOC #nonloc ],
   ARGS < [ INFLECTD +,
            SYNSEM [ LOCAL [ CAT [ HEAD noun & 
                                        [ KEYS [ KEY named_rel,
                                                 ALTKEY proper_q_rel ] ],
                                   VAL [ SPR < >,
                                         COMPS < >,
                                         SPEC < anti_synsem_min > ] ],
                             CONT.HOOK.INDEX #argind,
                             CONJ #conj ],
                     NONLOC #nonloc,
                     PUNCT [ LPUNCT no_punct,
                             RPUNCT hyphen_or_comma_or_clause ] ] ] >,
   C-CONT [ HOOK [ LTOP #ltop,
                   INDEX #index ],
            RELS <! [ LBL #xarg,
                      PRED addressee_rel,
                      ARG1 #argind,
                      ARG2 #index ] !>,
            HCONS <! !> ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Coordinate structures
;;
;   We set the KEY of the mother to be that of the right-hand daughter, rather
; arbitrarily, but the KEY needs to be set, since many lexical types select
; an argument based on the KEY value.
;   We also need to set the type of the index on the mother, to match the types
; of the indices on the daughters.  It looks like this will force us to make 
; the kind of index a feature, not just a type, but for now we wrongly make the
; index be that of the right-hand daughter.  This does not break subject-verb
; agreement for plural NPs, since we only change INDEX in this hack, not AGR.
;   And we have to make sure that the BODY attributes of two conjoined 
; quantified phrases are identified, but not clear how to do this.
; DPF (27-Apr-99) Both conjuncts have KEY constrained to independent_rel, since
; they may be relations underspecified for use as particles - by doing this, we
; exclude coordination of particles themselves, but this is probably okay.
; DPF (1-May-99) At present we overgenerate with conjoined propositions because
; we cannot identify the MSG values of the two conjuncts - that would wrongly
; make the MARG values of those two messages be identified. Hence we accept eg.
; "*I wonder who left and that Sandy arrived".  As long as MSG values are
; typed relations, there doesn't seem to be a way out of this awkwardness.
; DPF (1-May-99) In the long run, we cannot simply identify the whole local 
; values of SLASH for the two conjuncts, since this would mean that the handles
; of the two extracted elements would be wrongly identified - wrong at least 
; for ordinary complements, which identify their LTOP handle with that of their
; head, meaning that in "the book Kim saw and Sandy liked" the handles for 
; "saw" and "liked" would be identified, which is bad since these handles each 
; fill a MARG role in distinct messages.  
; DPF 20-Nov-99 - Made all coord_phr's be LEX - in order to avoid, among other
; things, coordinate structures as right members of noun-noun compounds, as in
; 'the seventeenth, twentieth, or twenty-third'.
; DPF 20-Jun-00 - Made LEX match on both conjuncts, to avoid e.g. "Kim [ had
; Sandy and would ] arise" (with causative "have")  
; DPF 28-Aug-00 - But this will block "Kim and the cat arrived", so removed it.
; DPF 3-Feb-01 - Moved [ CONJ complex-conj ] on right dtr to subtypes, in order
; to let us treat run-on sentences as coordination.
; DPF 22-Mar-01 - Moved AGR.DIV reentrancy down to NP coordination, since
; want to allow non-like AGR.DIV values for sentence coordination, as in
; "I arrived and consultants left."

basic_coord_phr := basic_binary_phrase & non_headed_phrase & 
  [ INFLECTD #infl,
    SYNSEM [ LOCAL.CAT.VAL [ SUBJ #subj,
                             COMPS #comps,
                             SPEC #spec ],
             NONLOC #non-local,
             PUNCT.PNCTPR #ppair ],
    LCONJ-DTR sign & #left &
           [ INFLECTD #infl,
             SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY independent_rel,
                                    VAL [ SUBJ #subj,
                                          COMPS #comps,
                                          SPEC #spec ] ],
                              CONT.HOOK.INDEX individual ],
                      NONLOC #non-local ] ],
    RCONJ-DTR #right &
           [ INFLECTD #infl,
             SYNSEM [ LOCAL [ CAT.VAL [ SUBJ #subj,
                                        COMPS #comps,
                                        SPEC #spec ],
                              CONT.HOOK.INDEX individual ],
                      NONLOC #non-local,
                      PUNCT.PNCTPR #ppair ] ],
    ARGS < #left, #right > ].

coord_phr := basic_coord_phr &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD #mod,
                   CONT.MSG #msg ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD #mod,
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD #mod,
                             CONT.MSG #msg,
                             CONJ complex-conj ] ].

; DPF 10-mar-05 - Pushed [LEX -] down to dtrs, since need to allow
; at least non-finite verbs to be able coordinate as LEX + since the
; passives can be attributive adjectives: "The admired and hated politicians"
norm_coord_phr := coord_phr &
  [ INFLECTD +,
    SYNSEM.LOCAL.AGR.PNG #png,
    RCONJ-DTR.SYNSEM.LOCAL.AGR.PNG #png,
    ARGS < [ INFLECTD + ],
           [ INFLECTD + ] > ].

; [SPR..no_rel] prevented attachment of modifiers to no_cop phrases, but
; this incorrectly blocks "rain possible today".
; ARGS..SPR *olist* blocks e.g. "ago" as nocop_vp
; DPF 10-Sep-01 - Changed KEY to be no_rel, to block nocop_vp as root phrase.
; DPF 13-Sep-01 - Removed ROBUST - from dtr, since want "message received"
; DPF 25-aug-04 - Changed SYNSEM..SUBJ..CASE from nom to acc, since want
; 'with me in Paris', not '*with I in Paris'.

no_copula_be_phrase := norm_unary_phrase & phrasal &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD frag & [ PRD -,
                                         INV -,
                                         KEYS [ KEY no_rel,
                                                ALTKEY #key ],
                                         TAM #tam ],
                           VAL [ SUBJ < synsem &
                                        [ LOCAL [ CAT nomp_cat_min &
                                                      [ HEAD.CASE acc,
                                                        VAL.SPR < > ],
                                                  CONT [ HOOK.INDEX #ind,
                                                         MSG no_msg ] ] ] >,
                                 SPR < anti_synsem_min >,
                                 COMPS < > ],
                           MC na ],
                     CONT [ HOOK [ INDEX.E #tam & [ TENSE no_tense ],
                                   XARG #ind & ref-ind ],
                            MSG #msg ],
                     CONJ cnil ],
             NONLOC #nonloc & [ SLASH 0-dlist & [ LIST < > ],
                                   REL 0-dlist,
                                   QUE 0-dlist ] ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY #key,
                                    VAL [ COMPS < >,
                                          SPR *olist* ],
                                    MC na ],
                              CONJ cnil,
                              CONT.MSG #msg ],
                      NONLOC #nonloc ],
             POSSCL #posscl & - ] >,
    C-CONT [ HOOK.INDEX.E.TENSE no_tense,
             HCONS <! !> ],
    POSSCL #posscl ].

; DPF 28-Nov-02 - HOOK comes only from C-CONT

no_copula_prd_phrase := no_copula_be_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < >,
                   CONT.HOOK.XARG #xarg,
                   AGR #agr ],
    ARGS < [ SYNSEM.LOCAL 
                    [ CAT.HEAD v_or_a_or_p &
                          [ PRD +,
                            MOD < [ LOCAL intersective_mod &
                                          [ CAT.HEAD.KEYS.KEY event_rel ] ]> ],
                      CONT.HOOK [ LTOP #hand,
                                  INDEX non_expl,
                                  XARG #xarg ],
                      AGR #agr ] ] >,
    C-CONT [ HOOK.LTOP #hand,
             RELS <! !> ] ].

; DPF 21-Nov-01 - Added ROBUST - to dtr, to block bare-sing-nps.
; DPF 28-Nov-02 - HOOK comes only from C-CONT

no_copula_id_phrase := no_copula_be_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MOD < >,
                                TAM #tam ],
                         VAL.SUBJ < [ LOCAL [ CAT nomp_cat_min,
                                              AGR #agr ],
                                      --SIND #id1ind ] > ],
                   CONT.HOOK.INDEX.E #tam,
                   AGR #agr ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun &
                                       [ KEYS [ KEY nonpro_rel,
                                                ALTKEY non_conj_rel ] ],
                                  VAL [ SUBJ < >,
                                        SPR < >,
                                        COMPS < > ] ],
                            CONT.HOOK.INDEX #id2ind ],
             GENRE edited ] >,
    C-CONT [ HOOK [ LTOP #hand,
                    INDEX #event ],
             RELS <! arg12_relation &
                     [ LBL #hand,
                       PRED _be_v_id_rel,
                       ARG0 #event & [ E.TENSE no_tense ],
                       ARG1 #id1ind,
                       ARG2 #id2ind ] !> ] ].

; DPF 25-Sept-01 - Changed SPR *olist* to < >, to prevent e.g. PPs from
; attaching to no_cop S rather than to the no_cop VP.
; DPF 28-Nov-02 - HOOK comes only from C-CONT

no_copula_nosubj_phrase := non_rel_clause & head_valence_phrase & head_only &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY #key,
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
                           MC + ],
                     CONT.MSG.PRED prpstn_m_rel ],
             NONLOC #nonloc ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verb &
                                         [ MOD < >,
                                           PRD -,
                                           VFORM fin,
                                           TAM.TENSE no_tense,
                                           KEYS.KEY #key ],
                                    VAL [ SUBJ < synsem & [ OPT + ] >,
                                          COMPS < > ],
                                    MC na ],
                              CONT.HOOK.LTOP #hdtop,
                              CONJ cnil ],
                      NONLOC #nonloc & [ SLASH 0-dlist,
                                            REL 0-dlist,
                                            QUE 0-dlist ] ],
    C-CONT [ RELS <! [ MARG #marg ] !>,
             HCONS <! qeq & [ HARG #marg,
                              LARG #hdtop ] !> ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Proto-instance types
; DPF 12-Nov-03 - Experimentally, make the XARG of this phrase be the LTOP
; of the head-dtr, in order to support "on Tuesday who arrived" where the
; PP should share the handle of the VP (as if it had been extracted).
; DPF 30-aug-04 - Split subj_rule_decl into MC+ and MC- in order to enforce
; unification of msg from punctuation mark on main clause phrases only, to
; get "Kim arrived?" but not "*I wonder Kim arrived?"

subjh_rule_decl := binary_rule_right_to_left & head_subj_phrase & decl_phrase &
                   head_valence_phrase &
  [ SYNSEM.LOCAL [ CAT [ MC bool,
                         VAL.SUBJ < anti_synsem_min >,
                         POSTHD + ],
                   CONT.HOOK.XARG #ltop ],
    HD-DTR.SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
                    NONLOC.QUE 0-dlist ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.POSS -,
                    NONLOC.QUE 0-dlist ] ].

subjh_mc_rule := subjh_rule_decl &
  [ SYNSEM [ LOCAL [ CAT.MC +,
                     CONT.MSG [ PRED #pred & prop-or-ques_m_rel ] ],
             PUNCT.RPUNCT.MSGPRED #pred ] ].

; Constrain nh-dtr to be HEAD n_or_v to exclude locative inversion in
; non-main clauses
subjh_nonmc_rule := subjh_rule_decl &
  [ SYNSEM.LOCAL [ CAT.MC -,
                   CONT.MSG.PRED prop-or-ques_m_rel ],
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD n_or_v ].

subjh_rule_wh_insitu := binary_rule_right_to_left & head_subj_phrase & 
                        clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD v_or_g &
                                [ VFORM fin,
                                  INV -,
                                  PRD -,
                                  TAM basic_ind_or_mod_subj_tam ],
                           MC +,
                           VAL.SUBJ *olist* & < anti_synsem_min >,
                           POSTHD + ],
                     CONT [ HOOK.XARG #ltop,
                            MSG message & #msg & 
                                      [ PRED #pred,
                                        PARAMS <! #que & param !> ] ] ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             PUNCT.RPUNCT.MSGPRED #pred ],
    HD-DTR.SYNSEM [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                      INDEX #ind ],
                      NONLOC [ QUE 1-dlist & [ LIST < #que > ],
                               REL 0-dlist,
                               SLASH 0-dlist ] ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.POSS -,
                    NONLOC.QUE 0-dlist ],
    C-CONT [ HOOK [ LTOP #mhand,
                    INDEX #ind ],
             RELS <! #msg & [ LBL #mhand,
                              PRED basic_int_m_rel,
                              ARG0 #ind,
                              MARG #lbl,
                              PSV #psv,
                              TPC #tpc ],
                     message & [ LBL #lbl,
                                 PRED prpstn_m_rel,
                                 ARG0 #ind,
                                 MARG #marg,
                                 PSV #psv,
                                 TPC #tpc ] !>,
             HCONS <! qeq & [ HARG #marg,
                              LARG #ltop ] !> ] ].

hcomp_rule := binary_rule_left_to_right & head_comp_phrase.

hoptcomp_rule := rule & head_opt_comp_phrase.
noptcomp_rule := rule & noun_opt_comp_phrase.

hmark_e_phr_rule := binary_rule_left_to_right & head_marker_phrase_e_phr.
hmark_a_lex_rule := binary_rule_left_to_right & head_marker_phrase_a_lex.
hmark_nom_rule := binary_rule_left_to_right & head_marker_phrase_nom.
hmark_nbar_rule := binary_rule_left_to_right & head_marker_phrase_nbar.
hmark_atomic_rule := binary_rule_left_to_right & head_marker_phrase_atomic.

extracomp_rule := rule & extracted_comp_phrase.

extrasubj_fin_rule := rule & extracted_subj_phrase_fin.
extrasubj_inf_rule := rule & extracted_subj_phrase_inf.

hspec_rule := binary_rule_right_to_left & head_spec_phrase.
hspec_hc_rule := binary_rule_right_to_left & head_spec_hc_phrase.

adjh_s_rule := binary_rule_left_to_right & adj_head_scop_phrase.
;adjh_s_xp_rule := binary_rule_left_to_right & adj_head_scop_xp_phrase.
adjh_s_prpnct_rule := binary_rule_left_to_right & adj_head_scop_prpnct_phrase.
adjh_s_nopair_rule := binary_rule_left_to_right & adj_head_scop_nopair_phrase.
;adjn_i_rule := binary_rule_left_to_right & adj_n_infl_phrase.
;adjn_ni_rule := binary_rule_left_to_right & adj_n_noninfl_phrase.
adj_n_rule := binary_rule_left_to_right & adj_n_phrase.
adj_adjn_rule := binary_rule_left_to_right & adj_adjn_phrase.
adjh_i_rule := binary_rule_left_to_right & adj_h_int_phrase.
adj_adjh_i_rule := binary_rule_left_to_right & adj_adjh_int_phrase.
adjh_i_ques_rule := binary_rule_left_to_right & adj_head_int_ques_phrase.
adjh_i_rel_rule := binary_rule_left_to_right & adj_head_rel_phrase.

hadj_s_prpnct_rule := binary_rule_right_to_left & head_adj_scop_prpnct.
hadj_s_nopair_rule := binary_rule_right_to_left & head_adj_scop_nopair.
hadj_i_relcl_pr_rule := binary_rule_right_to_left & n_adj_relcl_prpnct.
hadj_i_relcl_npr_rule := binary_rule_right_to_left & n_adj_relcl_nopair.
hadj_i_redrel_pr_rule := binary_rule_right_to_left & n_adj_redrel_prpnct.
hadj_i_redrel_npr_rule := binary_rule_right_to_left & n_adj_redrel_nopair.

hadj_i_unsl_rule := binary_rule_right_to_left & h_adj_unsl_phrase.
hadj_i_sl_rule := binary_rule_right_to_left & h_adj_sl_phrase.

extradj_i_vp_rule := rule & extracted_adj_int_vp_phrase.
extradj_i_s_rule := rule & extracted_adj_int_s_phrase.

extradj_npadv_rule := rule & extracted_adj_npadv_phrase.

fin_non_wh_rel_rule := rule & fin_non_wh_rel_cl.

inf_non_wh_rel_rule := rule & inf_non_wh_rel_cl.
inf_non_wh_subj_rel_rule := rule & inf_non_wh_subj_rel_cl.

instr_inf_non_wh_rel_rule := rule & instr_inf_non_wh_rel_cl.

red_rel_cl_rule := rule & red_rel_cl.

subconj_prdp_prp_rule := rule & subconj_prdp_prp_phr.
subconj_prdp_pas_rule := rule & subconj_prdp_pas_phr.
subconj_prdp_pas_sl_rule := rule & subconj_prdp_pas_sl_phr.
subconj_prdp_pas_lex_rule := rule & subconj_prdp_pas_lex_phr.
subconj_prdp_adj_rule := rule & subconj_prdp_adj_phr.
subconj_prdp_ellip_rule := rule & subconj_prdp_ellip_phr.
subconj_prdp_a_init_rule := rule & subconj_prdp_a_init_phr.
subconj_prdp_v_init_rule := rule & subconj_prdp_v_init_phr.

; ERB (19-01-98) The single non_wh_rel_rule dream didn't come true.
; non_wh_rel_rule := rule & non_wh_rel_cl.

bare_np_rule := rule & bare_np_phrase.
proper_np_rule := rule & proper_np_phrase.
num_np_rule := rule & num_np_phrase.
bare_np_sg_rule_robust := rule & bare_np_sg_phrase_robust.

detlesspp_np_nmod_rule := rule & detlesspp_np_nmod_phrase.
detlesspp_np_jmod_rule := rule & detlesspp_np_jmod_phrase.
detlesspp_np_nomod_rule := rule & detlesspp_np_nomod_phrase.

bare_vger_rule := rule & bare_vger_phrase.

np_n_cmpnd_rule := binary_rule_right_to_left & np_n_cmpnd_phr.
np_n_cmpnd_rule_2 := binary_rule_right_to_left & np_n_cmpnd_phr_2.
np_name_cmpnd_rule := binary_rule_right_to_left & np_name_cmpnd_phr.
np_city_state_rule := binary_rule_right_to_left & np_city_state_phr.
noun_n_cmpnd_rule := binary_rule_right_to_left & noun_n_cmpnd_phr.
noun_title_cmpnd_rule := binary_rule_right_to_left & noun_title_cmpnd_phr.
appos_prpnct_rule := binary_rule_right_to_left & appos_phr_prpnct.
appos_nopair_rule := binary_rule_right_to_left & appos_phr_nopair.
appos_indef_rule := binary_rule_right_to_left & appos_indef_phr.
npadv_mod_rule := rule & npadv_mod_phrase.
measure_np_rule := binary_rule_right_to_left & measure_np_phrase.
measure_np_symbol_rule := binary_rule_left_to_right & measure_np_symbol_phrase.
bare_measure_np_rule := rule & bare_measure_np_phrase.
num_noun_rule := rule & num_noun_phrase.
num_noun_seq_rule := rule & num_noun_sequence_phrase.
;np_cp_rule := rule & np_cp_phrase.
np_cp_wh_rule := rule & np_cp_wh_phrase.
cp_subj_rule := rule & cp_subj_phrase.

;; DPF 22-Dec-98 - Modified filler_head_rule_non_wh to require head to be 
;; VFORM fin, in order to block "*Kim hire".  The VFORM used to be fin_or_imp,
;; to allow an extraction analysis of "On Monday hire Kim", but this also
;; allowed a spurious second analysis for "On Monday tell Kim that Sandy left".
;; So a new construction for left dislocation is needed for "On Monday hire Kim",
;; one which would also admit "As for that book, who did it offend?" where a
;; (double) extraction analysis would otherwise be required.

;; DPF 29-Jan-99 - Constrained nonhead_dtr to be HEAD n_or_p, in order to block
;; Yoda examples like "Happy you will be" or "Making a mess you are".  More
;; generally these should simply be dispreferred, but we'll block them for now.
;
; DPF 10-Jun-99 - Note that filler_head_rule_non_wh does not currently inherit 
; from non_rel_clause, but perhaps should.
; 
; DPF 10-Jun-99 - Removed mc_fillhead_phrase from filler_head_rule_non_wh since
; topicalized constructions can be embedded, as in "Kim thinks on Tuesday we
; should be in Berlin"
; -- DPF 24-Mar-01 - But this is too weak: we still need to block "*I'm sure 
; bananas he likes" - cf. examples with "bet".  So put back mc_fillhead_phrase,
; and wait for more inspiration about allowing S-init adjuncts for embedded S's
; DPF 2-Feb-01 - Generalized HEAD value of nonhead_dtr to include adverbs as
; well as n_or_p, to get "Quietly kim left"
; DPF 2-Apr-01 - Removed INV - from head-dtr to allow "here are my questions"
; DPF 13-May-01 - Added [HD-DTR..MODIFD notmod_or_rmod] to prevent root
; exclamatives like "oh" from modifying the head of the head-filler.
; DPF 25-Sep-01 - From 2-Apr-01: But this overgenerates too much, so putting
; it back in (cf "*There is Kim Sandy")
; DPF 12-Apr-02 - Apparently INV - was put back on head-dtr (see 2-Apr-01) --
; this blocks non-wh PP-fronting for yes-no questions, as in "On Tuesday did
; Kim arrive".  Maybe right not to treat these as unbounded dependencies -
; note lack of ambiguity for "tomorrow can you ask Sandy to call me?"
; DPF 1-Jun-02 -Added HD-DTR..MSG.PRED prop-or-ques_m_rel to exclude imperatives
; since sometime between 22-Dec-98 and now (see above) the VFORM constraint was
; removed, but we still want to block "*kim hire".
; DPF 13-Oct-03 - But blocking "Kim hire" also prevents us from getting PPs
; fronted for imperatives, as with "On Sunday, buy two books".  It also blocks
; "Books about elephants, buy only on Sundays" which seems fine.  So removed
; this constraint, and expect punctuation to catch "*Kim hire" since we want
; a comma after fronted phrase for imperatives.
; DPF 26-Nov-03 - Further constrained head-dtr's MODIFD (see 13-May-01) to
; exclude rmod, to avoid spurious parse for "Kim we hired, singing".
; DPF 21-aug-04 - Try relaxing hd-dtr's MODIFD value to notmod_or_lmod, to
; allow e.g. "on Tuesday, if you wish, leave early"
; DPF 27-aug-04 - Removed parent mc_fillhead_phrase to allow these as
; subordinate clauses, as in "since on Tuesday they'll leave"
; DPF 8-apr-05 - Removed NH-DTR..MSG no_msg to get "Kim arrived, Abrams said."
; DPF 05-sept-05 - Tried making NH-DTR..RPUNCT include clause_punct, to
; allow "Who arrived? asked Kim."  But this means unwanted overgeneration
; like "Kim. we hired" and "Kim? we hired".  So we'll have to find another
; analysis for this stripped down clause-fronting - note that if the 
; fronted sentence is quoted, all is well with the existing pair_punct
; constraint on the non-hd dtr.
; DPF 9-oct-05 - The nonhd-dtr was marked [CASE non_obliq] as a hack to
; prevent lexical PPs from fronting (see 25-mar-05 in lextypes.tdl)
; but this prevents us from getting "Here Kim slept" now that we want "here" 
; to be [CASE obliq] in order to prevent these as direct objects as in "here 
; kim plunged into the lake". So we'll look for another way to block the
; unwanted parse for "on the first kim arrived" if indeed we should.

filler_head_rule_non_wh := binary_rule_right_to_left & 
                           basic_head_filler_phrase_fin &
                           head_compositional &
  [ INFLECTD +,
    SYNSEM [ LOCAL.CONT [ HOOK.XARG #xarg,
                          MSG #msg ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist ] ],
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD verbal & [ INV - ],
                                    VAL.SUBJ *anti_cons*,
                                    MC - ],
                              CONT [ HOOK.XARG #xarg,
                                     MSG #msg & [ TPC #nhind,
                                                  PRED #pred ] ] ],
                      NONLOC [ SLASH <! [ CAT.MC #mc,
                                          CONT.HOOK.LTOP #nhltop ] !>,
                               QUE 0-dlist ],
                      MODIFD notmod_or_lmod,
                      PUNCT.RPUNCT.MSGPRED #pred ] ],
    NH-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD n_or_p_or_v_or_adv,
                                    MC #mc ],
                              CONT.HOOK [ LTOP #nhltop,
                                          INDEX #nhind ] ],
                      NONLOC [ QUE 0-dlist,
                               REL 0-dlist ],
                      PUNCT.RPUNCT comma_or_pair_or_no_punct ] ],

    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

; DPF 20-Oct-01 - Changed HEAD.INV + to HEAD.INV +* (and same for AUX) to 
; allow for coordination of inverted and non-inverted sentences.

filler_head_rule_wh_root := binary_rule_left_to_right & 
			    head_filler_phrase_fin & wh_interrog_fin & 
                            mc_fillhead_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.INV +,
                   CONT.HOOK.XARG #hdtop ],
    HD-DTR.SYNSEM.LOCAL [ CAT.MC na,
                          CONT.HOOK [ LTOP #hdtop,
                                      INDEX #index ] ],
    NH-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX #tpc,
                    PUNCT.RPUNCT comma_or_pair_or_no_punct ],
    C-CONT [ RELS <! [ MARG #lbl,
                       TPC #tpc,
                       PSV #psv ],
                     message & [ LBL #lbl,
                                 PRED prpstn_m_rel,
                                 ARG0 #index,
                                 MARG #marg,
                                 TPC #tpc,
                                 PSV #psv ] !>,
             HCONS <! qeq & [ HARG #marg,
                              LARG #hdtop ] !> ] ].

; DPF (21-Apr-98) To block use of fill_head_wh_subj in "Kim knows who Sandy 
; saw" added constraint that filler must be [CASE NOM].
; DPF 15-Oct-01 - Removed [AUX -]: was wrong.
; DPF 15-May-02 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination 
; of inverted and non-inverted sentences.
; DPF 31-May-02 - Added restriction on head-dtr for MSG.PRED prop-or-ques_m_rel 
; to block imperative S-comp, as in "*I know which manager hire"
; DPF 24-jun-05 - Further restricted the head-dtr's MSG to always be
; prpstn_m_rel.
 
filler_head_rule_wh_subj := binary_rule_left_to_right & 
			    head_filler_phrase_fin & wh_interrog_fin & 
			    mc_fillhead_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.INV -,
                   CONT.HOOK.XARG #xarg ],
    HD-DTR.SYNSEM.LOCAL [ CAT.VAL.SUBJ < >,
                          CONT [ HOOK.XARG #xarg,
                                 MSG [ LBL #lbl,
                                       PRED prpstn_m_rel,
                                       TPC #tpc,
                                       PSV #psv ] ] ],
    NH-DTR.SYNSEM.LOCAL [ CAT.HEAD noun & [ CASE nom ],
                          CONT.HOOK.INDEX #tpc ],
    C-CONT [ RELS <! [ MARG #lbl,
                       TPC #tpc,
                       PSV #psv ] !>,
             HCONS <! !> ] ].

; DPF (21-Apr-98) Removed constraint making HD-DTR [MC -], since this was
; blocking "Abrams knows who Kim saw."
; DPF 31-May-02 - Added restriction on head-dtr for MSG.PRED prop-or-ques_m_rel
; to block imperative S-comp, as in "*I know which manager hire"
; DPF 24-jun-05 - Further restricted the head-dtr's MSG to always be
; prpstn_m_rel.

filler_head_rule_wh_nr_fin := binary_rule_left_to_right & 
			      head_filler_phrase_fin & wh_interrog_fin &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL [ CAT.MC -,
                          CONT [ HOOK.LTOP #hdtop,
                                 MSG [ PRED prpstn_m_rel,
                                       TPC #tpc,
                                       PARAMS 0-dlist ] ] ],
    NH-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX #tpc,
                    PUNCT.RPUNCT comma_or_pair_or_no_punct ],
    C-CONT [ RELS <! [ MARG #hdtop,
                       TPC #tpc ] !>,
             HCONS <! !> ] ].

; DPF 13-Nov-99 - Restricted SUBJ on mother to be 'unexpressed' to prevent
; the subject-extraction rule from applying.
; DPF 13-Nov-99 - Changed [MC na] to [MC -] since e.g. "know" wants an MC -
; complement, as in "kim knows who to hire".
; DPF 26-Mar-01 - Added to head-dtr: SUBJ..SLASH 0-dlist to avoid wrong
; subj-extraction parse for "Kim knew who to approach".

filler_head_rule_wh_nr_inf := binary_rule_left_to_right & 
			      head_filler_phrase_inf & wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
		       VAL.SUBJ < unexpressed >,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL [ CAT.VAL.SUBJ < pro_ss & 
                                           [ NONLOC.SLASH 0-dlist ] >,
                          CONT [ HOOK.LTOP #hdtop,
                                 MSG.TPC #tpc ] ],
    NH-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #tpc,
    C-CONT [ RELS <! [ MARG #marg,
                       TPC #tpc ] !>,
             HCONS <! qeq &
                      [ HARG #marg,
                        LARG #hdtop ] !> ] ].

; DPF 25-Nov-01 - Added SYNSEM..RPERIPH + to enable blocking of thatless-rel
; attaching after WH-relative
; DPF 8-Jul-02 - Changec C-CONT.HOOK.LTOP to be re-entrant with head-dtr's 
; LTOP rather than with its MSG..LBL, since the latter does the wrong thing
; at least for coordinated relative clauses as in "The programmar Abrams
; interviewed and Browne hired arrived".
; DPF 19-dec-03 - Added propagation of ALT2KEY constraint from nbar-filler 
; "that" for "the place that Kim bought the book" - modable_rel preserved, 
; to get same effect as with actual gap in simple that-less rel construction.
; This is just a hack, but the right solution is elusive.

filler_head_rule_rel := binary_rule_left_to_right & rel_cl & 
			basic_head_filler_phrase & 
  [ INFLECTD +,
    SYNSEM [ LOCAL.CAT [ HEAD [ VFORM #vform,
                                TAM #tam,
                                AUX #aux,
                                INV #inv,
                                PRD -,
                                MOD < [ LOCAL [ CAT.HEAD.KEYS.KEY #modkey,
                                                CONT.HOOK [ LTOP #rhand,
							    XARG #rhand ] ],
                                        --SIND #ind ] >,
                                KEYS.KEY #key ],
                         VAL [ SUBJ *olist_or_prolist* & #subj,
                               SPR < > ] ],
             MODIFD.RPERIPH + ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT.HEAD.KEYS.ALT2KEY #modkey,
                              CONJ cnil ],
		      NONLOC [ QUE 0-dlist,
                               REL 1-dlist &
                                   [ LIST < [ LTOP #rhand,
                                              INDEX #ind,
                                              XARG #rhand ] > ] ],
                      PUNCT.RPUNCT no_punct ] ],
	   [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD verbal & [ VFORM #vform & fin_or_inf,
                                                    TAM #tam,
                                                    AUX #aux,
                                                    INV #inv,
                                                    KEYS.KEY #key ],
				    VAL.SUBJ #subj,
				    MC - ],
                              CONT [ HOOK.LTOP #ltop,
                                     MSG message & [ PRED prpstn_m_rel ] ],
			      CONJ cnil ],
                      NONLOC [ QUE 0-dlist,
                               REL 0-dlist ] ] ] >,
    C-CONT [ HOOK.LTOP #ltop,
	     RELS <! !>,
	     HCONS <! !> ] ].

; ERB (05-10-96) This no longer inherits from (old) mc_phrase because it also
; serves to make nonroot phrases, such as the bracketed phrase in: "On Tuesday
; [plan to meet Kim]".

imperative_mc_rule := rule & imp_phrase.
imperative_slash_rule := rule & imp_slash_phrase.

yesno_rule := rule & yesno_phrase.

; The top_coord_rule is for building the ltop of a (potential iterated)
; coordinate structure and the mid_coord_rule is for building intermediate
; parts of an iterated coordinate structure.  The mid_coord_rule (and the
; head/marker schema) collect the handels and indices of the conjuncts under
; the CONJ feature and passes them (with the lexically specified coordination
; relation) up from the right conjunct.  The top_coord_rule uses handels and
; liszts from the CONJ value to build the values for an n-ary coordination 
; relation.  We could skip all this feature passing if we weren't limited by 
; performance considerations to binary trees.  That is, we could build 
; coordinate structures like:					  
;       						  
;       						  
;      coord_phrase					  
;             +-			          -+	  
;             | conj_rel  		           |	  
;      RELS  | C-HNDLS  [h1], [h2], ..., [hn]   |	  
;             | C-INDICES  [i1], [i2], ..., [in]   |	  
;             +-    		                  -+	  
;             /             /                \ 	 	  
;            /  	   /    	      \  	  
;           /   	  /     	       \ 	  
;          /    	 /      		\ 	  
;         /     	/       		 \ 	  
;      phrase        phrase    	       	       phrase	  
;      LTOP   [h1]    LTOP   [h2] ...            LTOP   [hn]
;      INDEX [i1]    INDEX [i2]                INDEX [in]
;        |             |                	 |  
;        |             |                         |  
;       Kim          Sandy       ...            Lee 
;       			     
; then we could eliminate the features HNDLS and INDICES.  These
; feature are just for bookkeeping.  The feature LEFT, on the other hand, is
; essential to the analysis.  The LEFT value is a list of (up to) two
; elements.  The first element is the required CONJ value of the left conjunct
; in a top_coord_phrase and the second element is the CONJ value of the left
; conjunct in a mid_coord_phrase.  For example, a LEFT value of < either, or >
; permits a coordinate structure like "either Kim or Sandy or Chris or Lee".

; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 6-Jun-03 - Tried making the KEY of mother be that of left dtr rather than
; right dtr, given that neither is right in principle.  Want to get "an hour
; and a half" to still be temporal-noun.  But this fails because the KEY of
; "either Monday" is a conj_rel (in "either Monday or Tuesday") while the KEY
; of "Monday" is a day_rel (in "Monday or Tuesday").  So only the right dtr
; consistently puts the right conjunct's KEY in one place: the ALTKEY of
; "and Tuesday".  So let's consider making "a half" unspecified for SORT.

basic_top_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM [ LOCAL [ CONT.HOOK.INDEX #ind,
                     CONJ cnil ],
             PUNCT [ LPUNCT #lpunct,
                     PAIRED #rpnctpr,
                     RPUNCT #rpunct ] ],
    LCONJ-DTR.SYNSEM [ LOCAL local & [ CONJ conj & #left ],
                       PUNCT [ LPUNCT #lpunct,
                               RPUNCT comma_or_rbc_or_pair_or_no_punct,
                               PNCTPR #pnctpr ] ],
    RCONJ-DTR.SYNSEM [ LOCAL local &
                       [ CONT.HOOK.INDEX #ind,
                         CONJ complex-conj & 
                              [ CHEAD.LEFT <#left, ...>,
                                CPUNCT #pnctpr ] ],
                       PUNCT [ LPUNCT pair_or_no_punct,
                               RPUNCT #rpunct,
                               PAIRED #pnctpr,
                               PNCTPR #rpnctpr ] ],
    C-CONT.HOOK.INDEX #ind & conj-ind ].

top_coord_rule := basic_top_coord_rule &
  [ RCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #cltop,
    C-CONT.HOOK.LTOP #cltop ].

; DPF 28-Nov-02 - HOOK comes only from C-CONT
; Require RCONJ-DTR..LPUNCT comma_punct to rule out "Kim arose arrived and
; laughed" but allow both "Kim arose, arrived and laughed" and also
; "Kim arose, arrived, and laughed"  This assumes that conj_words do not 
; lexically constrain LPUNCT, unlike most words.  So in the base case (the
; first time this rule applies in a series of mid-conj's), the left dtr is
; optionally marked with a comma (RPUNCT comma_or_no_punct), but since the
; mother is [LPUNCT no_punct, RPUNCT comma_punct], the only way this rule
; can reapply is if the phrase picks up a left comma in order to match the
; requirement on the right dtr's LPUNCT.  (This arrangement looks like it
; would in principle accept a double comma on the left dtr in a recursively
; applied structure, as in "Abrams, Browne,, Chiang, and Devito", but the
; preprocessor doesn't admit the two successive commas, so we can live with
; this flaw for now.)
;   [ abrams [, [ browne [ and Chiang ]]]]
;   [ abrams [, [ [ browne ,] [ and Chiang ]]]]]
;   [ devito [, [ abrams [, [ [ browne ,] [ and Chiang ]]]]]
; This means that we get a spurious analysis for complex conjunctions where the
; conjoined phrase ends in a comma or period, since that licenses a left comma
; on the final conjunct: [arise [, smile [, [and [ go .]]]]].  FIX?? later.

; DPF 10-may-05 - Use new feature PUNCT.PAIRED to enable constraint on presence
; of commas in three (or more) part coordination, ensuring that if the 
; next-to-last conjunct is comma-marked, all leftward conjuncts are too,
; while if the next-to-last conjunct is not comma-marked, the next one
; doesn't have to be either, but can be.  The way it works is that the 
; affixation rule for comma punctuation stamps [PAIRED no-ppair], while
; a non-punctuated sign is underspecified for PAIRED.  This mid_coord_rule 
; type propagates that PAIRED property up from its left dtr, so it's still 
; visible on the mid-coordinated phrase.  Then the top_coord_rule requires 
; that its left dtr unifies its PUNCT.PNCTPR value with the PAIRED value of 
; its right dtr.  The effect is that if the next-to-last conjunct is unmarked, 
; it will not restrict the PNCTPR value of the top conjunct, but if the 
; next-to-last is comma-marked, it imposes a constraint (eventually) on the 
; top conjunct's PNCTPR value, forcing it to be a comma.

mid_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM [ LOCAL.CONJ phr-conj &
                        [ CHEAD #chead,
                          CREL basic_conj_relation &
                                [ LBL #ltop,
                                  PRED implicit_conj_rel,
                                  ARG0 #cind & non_expl,
                                  R-INDEX #ind ] ],
             PUNCT [ LPUNCT no_punct,
                     RPUNCT #rpunct,
                     PAIRED #paired,
                     PNCTPR #rpnctpr],
             ROOT - ],
    LCONJ-DTR.SYNSEM [ LOCAL.CONJ conj & #left,
                       PUNCT [ LPUNCT no_punct,
                               RPUNCT comma_or_no_punct,
                               PNCTPR #pnctpr,
                               PAIRED #paired ] ],
    RCONJ-DTR.SYNSEM [ LOCAL [ CONT.HOOK.INDEX #ind,
                               CONJ complex-conj & 
                                    [ CHEAD #chead & 
                                            [ LEFT < *top*, #left > ] ] ],
                       PUNCT [ LPUNCT no_punct,
                               RPUNCT #rpunct,
                               PAIRED #pnctpr,
                               PNCTPR #rpnctpr ] ],
    C-CONT.HOOK [ LTOP #ltop,
                  INDEX #cind & conj-ind ] ].

; Coordination of non-nominal phrases (S's and VPs)
;; DPF 25-Feb-01 - Changed division of labor with these two rules, so the first now
;; conjoins all phrases with event index values, while the second conjoins nominal
;; phrases.

;; DPF 21-Aug-01 - Added E-INDEX.E.TENSE real_tense to both dtrs in order to
;; block conjunction of no-copula VPs (want the no-cop after conjunction).

event_coord_rule := coord_phr &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX conj_event & [ E #tam ],
    LCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #lhand,
                                       INDEX #lind ],
    RCONJ-DTR.SYNSEM.LOCAL [ CONT.HOOK.INDEX conj_event,
                             CONJ.CREL [ L-HNDL #lhand,
                                         L-INDEX #lind,
                                         R-INDEX.E #tam ] ] ].

basic_top_coord_event_rule := basic_top_coord_rule & event_coord_rule &
  [ LCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event_or_deg-ind,
    C-CONT.HCONS <! !> ].

top_coord_event_rule := basic_top_coord_event_rule & top_coord_rule &
  [ C-CONT.RELS <! !> ].

mid_coord_event_rule := mid_coord_rule & event_coord_rule &
  [ SYNSEM.LOCAL.CONJ.CREL #rel,
    RCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    C-CONT [ RELS <! #rel & [ R-HNDL #ltop ] !>,
             HCONS <! !> ] ].

verbal_coord_phr := norm_coord_phr &
  [ SYNSEM [ LEX -,
             LOCAL.CAT [ HEAD verbal & [ PRD #prd ],
                         VAL.SPR #spr,
                         MC #mc ] ],
    LCONJ-DTR.SYNSEM [ LOCAL.CAT [ HEAD verbal & [ PRD #prd ],
                                   VAL.SPR #spr,
                                   MC #mc ],
                       PUNCT.RPUNCT comma_or_pair_or_no_punct ],
    RCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD verbal & [ PRD #prd ],
                                 VAL.SPR #spr,
                                 MC #mc ] ].

; DPF 13-nov-05 - Removed HEAD verb on mother and daughters, since this
; prevented coordination of infinitival VPs: "Kim tried to sing and to dance"
v_coord_phr := verbal_coord_phr &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                KEYS #keys ],
                         VAL.SUBJ < synsem > ],
                   CONT.HOOK.XARG #xarg ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform ],
                                   VAL.SUBJ < synsem > ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.E basic_ind_or_mod_subj_tam ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
                                          KEYS #keys ],
                                   VAL.SUBJ < synsem > ],
                             CONT.HOOK.XARG #xarg,
                             CONJ.CREL.R-INDEX.E basic_ind_or_mod_subj_tam ] ].

v_coord_phr_fin := v_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM fin,
                            TAM ind_or_mod_subj_tam &
                                  [ ASPECT [ PERF #perf,
                                             PROGR #progr ] ] ],
   LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ VFORM fin,
                                     TAM ind_or_mod_subj_tam &
                                           [ ASPECT [ PERF #perf,
                                                      PROGR #progr ] ] ],
   RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ VFORM fin,
                                     TAM ind_or_mod_subj_tam ] ].

v_coord_phr_nonfin := v_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM non_fin,
                            TAM #tam ],
   LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ VFORM non_fin,
                                     TAM #tam ],
   RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ VFORM non_fin,
                                     TAM #tam ] ].

v_coord_fin_top_phr := v_coord_phr_fin & basic_top_coord_event_rule &
                       top_coord_rule &
  [ C-CONT.RELS <! !> ].
v_coord_fin_mid_phr := v_coord_phr_fin & mid_coord_event_rule.
v_coord_nonfin_top_phr := v_coord_phr_nonfin & basic_top_coord_event_rule &
                          top_coord_rule &
  [ C-CONT.RELS <! !> ].
v_coord_nonfin_mid_phr := v_coord_phr_nonfin & mid_coord_event_rule.

s_coord_phr := verbal_coord_phr &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.VFORM fin_or_imp,
                           VAL [ SUBJ *olist*,
                                 COMPS < > ] ],
                     CONT.MSG message ],
             ROOT #root ],
    LCONJ-DTR.SYNSEM [ LOCAL.CONT.MSG message,
                       ROOT #root ],
    RCONJ-DTR.SYNSEM phr_synsem &
                     [ LOCAL.CONT.MSG message,
                       ROOT #root ] ].

; Exclude S-coord from NP-CP rule unless complementizer present.
basic_s_coord_top_phr := s_coord_phr & basic_top_coord_event_rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
    RCONJ-DTR.SYNSEM.LOCAL.CONT [ HOOK [ LTOP #conjltop,
                                         INDEX #ind ],
                                  MSG.PRED #pred ],
    C-CONT [ HOOK.LTOP #lbl,
             RELS <! message & [ LBL #lbl,
                                 PRED #pred,
                                 ARG0 #ind,
                                 MARG #conjltop ] !> ] ].

s_coord_top_phr := basic_s_coord_top_phr &
  [ LCONJ-DTR.SYNSEM.LOCAL.CONT.MSG.PRED prop_imp_m_rel ].
    
; This variant requires that if the first conjunct is a question,
; the second must be as well.  Needed to avoid leaving the first
; conjunct spuriously underspecified for its message (which then would
; do damage to efficiency in generation, since would then add interrogative
; alternatives even when not wanted.

s_coord_int_top_phr := basic_s_coord_top_phr &
  [ LCONJ-DTR.SYNSEM.LOCAL.CONT.MSG.PRED int_m_rel,
    RCONJ-DTR.SYNSEM.LOCAL.CONT.MSG.PRED int_m_rel ].

s_coord_mid_phr := s_coord_phr & mid_coord_event_rule.

; DPF 21-dec-05 - Removed SPR..KEY much_deg_rel, since this prevented
; coordination of subordinating preps as in 'we arise to arrive and to fall'
p_coord_phr := norm_coord_phr &
  [ SYNSEM [ LEX -,
             LOCAL [ CAT [ HEAD prep & [ PRD #prd,
                                         KEYS #keys,
                                         MOD #mod,
                                         TAM #tam,
                                         CASE #case ],
                           VAL [ SPR < [ LOCAL local_min &
                                           [ CAT [ HEAD adv,
                                                   VAL [ SPR *olist*,
                                                         COMPS < > ] ],
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #ind ] ],
                                         NONLOC.QUE 0-dlist ] >,
                                 COMPS < > ],
                           POSTHD + ],
                     CONT.HOOK [ LTOP #ltop,
                                 INDEX #ind,
                                 XARG #xarg ] ] ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD prep_or_modnp & 
                                      [ PRD #prd,
                                        KEYS #keys,
                                        MOD #mod,
                                        TAM #tam,
                                        CASE #case ],
                             CONT.HOOK.XARG #xarg ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD prep_or_modnp & 
                                      [ PRD #prd,
                                        MOD #mod,
                                        TAM #tam,
                                        CASE #case ],
                             CONT.HOOK.XARG #xarg ] ].

p_coord_top_phr := p_coord_phr & top_coord_event_rule.
    
p_coord_mid_phr := p_coord_phr & mid_coord_event_rule.

; DPF - 23-aug-04 - For now, disallow specifiers on conjoined APs, since it's
; hard to match them correctly as long as we are not using unary rule to
; discharge the SPR first.  This means stamping QUE 0-dlist on mother, since
; we can't propagate constraints from the dtrs' specifiers (since we don't
; know if they've been picked up).  So we lose e.g. "how big and wide is it?"

adj_coord_phr := coord_phr &
  [ SYNSEM [ LOCAL [ CAT [ HEAD #head & adj_or_intadj,
                           VAL [ SPR < >,
                                 COMPS < > ],
                           POSTHD #ph ],
                     CONT.HOOK.XARG #xarg ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist ] ],
    LCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                     POSTHD #ph ],
                               CONT.HOOK.XARG #xarg ],
                       NONLOC.SLASH 0-dlist ],
    RCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                     POSTHD #ph ],
                               CONT.HOOK.XARG #xarg ],
                       NONLOC.SLASH 0-dlist ] ].

; Attributive APs are LEX + (unusual for coordinate structures):
;  "*The angry at Kim and sad child"
;  "*The angry and taller child than Kim"
adj_attr_coord_phr := adj_coord_phr &
  [ INFLECTD +,
    SYNSEM [ LEX + & #lex,
             LOCAL.CAT [ HEAD.PRD -,
                         POSTHD - ] ],
    LCONJ-DTR [ SYNSEM.LEX #lex,
                INFLECTD + ],
    RCONJ-DTR [ SYNSEM.LEX #lex,
                INFLECTD + ] ].

; Predicative APs may have LEX + or - conjuncts, but preserve LEX value of
; (say) right conjunct, to avoid e.g. "the child angry and loud cried."
adj_pred_coord_phr := adj_coord_phr & norm_coord_phr &
  [ SYNSEM [ LEX #lex,
             LOCAL.CAT [ HEAD.PRD +,
                         POSTHD + ] ],
    RCONJ-DTR.SYNSEM.LEX #lex ].

adj_attr_coord_top_phr := adj_attr_coord_phr & top_coord_event_rule.
adj_attr_coord_mid_phr := adj_attr_coord_phr & mid_coord_event_rule.
adj_pred_coord_top_phr := adj_pred_coord_phr & top_coord_event_rule &
  [ LCONJ-DTR.SYNSEM.PUNCT.RPUNCT comma_or_no_punct ].
adj_pred_coord_mid_phr := adj_pred_coord_phr & mid_coord_event_rule.


; Coordination of all nominals
; DPF 4-Jun-03 - Added identification of SORT values for left and right and
; mother - see if this can fly.  We want to block e.g. the spurious parse for
; "the ninth and tenth kim danced" where the temp-np rule erroneously applied.
; DPF 26-aug-04 - But this excludes coordination of nouns and nominal gerunds,
; as in "His singing and dress were unusual", so push down to NP-coord only.

nom_coord_rule := coord_phr &
  [ SYNSEM synsem &
           [ LOCAL [ CAT.HEAD noun & [ CASE #case,
                                       MOD < >,
                                       KEYS #keys,
                                       PRD #prd ],
                     CONT [ HOOK.INDEX conj_non_expl-ind,
                            MSG no_msg ] ] ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD supnoun & [ CASE #case,
                                                    KEYS #keys,
                                                    PRD #prd ],
                                   VAL.COMPS < > ],
                             CONT [ HOOK.INDEX non_expl_or_conj-ind & #ind,
                                    MSG no_msg ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD supnoun & [ CASE #case,
                                                  PRD #prd ],
                             CONT [ HOOK.INDEX non_expl_or_conj-ind,
                                    MSG no_msg ],
                             CONJ.CREL conj_relation &
                                       [ L-INDEX #ind ] ] ].

np_coord_rule := nom_coord_rule &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < >,
                     CONT.HOOK.INDEX [ PNG #png,
                                       SORT #sort ],
                     AGR [ PNG #png,
                           DIV #div ] ],
             LEX na ],
    LCONJ-DTR [ SYNSEM.LOCAL.CAT.VAL.SPR *olist*,
                INFLECTD + ],
    RCONJ-DTR [ SYNSEM.LOCAL [ CAT.VAL.SPR *olist*,
                               CONJ.CREL [ L-INDEX.SORT #sort,
                                           R-INDEX.SORT #sort ],
                               AGR [ PNG #png,
                                     DIV #div ] ],
                INFLECTD + ],
    C-CONT [ RELS.LIST.FIRST [ PRED udef_q_rel ],
             HCONS <! !> ] ].

; DPF 16-jul-04 - Can't make the left dtr RPUNCT no_punct, even though this
; would nicely block "*Kim, and Sandy arrive", because it also blocked the
; acceptable coordination of longer NPs, as in "the chair next to the
; table by the window, and the stool by the door are new."
; We'll leave the strong constraint on nbar-coord until forced to give it up.

np_coord_top_rule := top_coord_rule & np_coord_rule &
  [ C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #ind ],
             RELS <! [ ARG0 #ind,
                       RSTR #ltop ] !> ] ].

np_coord_mid_rule := mid_coord_rule & np_coord_rule &
  [ SYNSEM.LOCAL.CONJ.CREL #rel,
    RCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #ltop,
                                       INDEX #ind ],
    C-CONT.RELS <! [ ARG0 #ind,
                     RSTR #ltop ], #rel !> ].

; Exclude proper name nbar coord for now at least.
; DPF 26-aug-04 - Generalized dtrs' HEAD from noun to noun_or_nomger
; DPF 25-feb-05 - Added unif of ALT2KEY on mother and dtrs to preserve
; non-compoundability as in "*[paper and other] garbage"
; DPF 13-mar-05 - Added MODIFD notmod to mother, to capture apparent and
; interesting fact that coordination of nbars results in a phrase that can 
; again take either a posthead or prehead modifier: '[cats and small dogs] 
; in Paris' and 'small [cats in boxes and large dogs]'.
; DPF 2-apr-05 - But this addition overconstrains the rule, disallowing e.g.
; 'the tenth and eleventh I am out of town'.  So leave underspecified.
; DPF 14-nov-05 - Removed identification of LEX on dtrs and mother, since
; want to coordinate e.g. "garden with dogs and flower garden".  This could
; raise nice puzzle, since want to allow "flower and vegetable garden"
; but block "*flower and vegetable with leaves garden".  Happily, making
; non-head in compounds be non-inflected blocks the latter, since head-mod
; rule (for "vegetable with leaves" requires inflected dtrs).  So for now
; identify LEX of mother with right dtr - maybe unnecessary. FIX?  But to
; avoid too much ambiguity, for now still require #lex identity for 
; mid-coord rule.
; DPF 14-nov-05 - Re 2-apr-05: The adj_adjh rule needs to have some MODIFD
; value for its modifiee, so leaving value unconstrained is unsatisfactory.
; Here try propagating the value from the left dtr, arbitrarily.

nbar_coord_rule := nom_coord_rule &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.ALT2KEY #alt2key,
                           VAL.SPR < synsem &
                                     [ LOCAL local_min &
                                             [ CAT [ HEAD det,
                                                     VAL [ SUBJ < >,
                                                           SPR *olist* ] ],
                                               AGR.DIV - ],
                                       NONLOC #nonloc,
                                       LEX +,
                                       OPT - ] > ] ],
             MODIFD #modif,
             LEX #lex ],
    LCONJ-DTR [ INFLECTD #infl,
                SYNSEM [ LOCAL [ CAT [ HEAD noun_or_nomger & 
                                            [ KEYS [ KEY gen_nom_nbar_rel,
                                                     ALT2KEY #alt2key ] ],
                                       VAL.SPR < synsem & 
                                                 [ OPT -,
                                                   NONLOC #nonloc ] > ],
                                 CONT.HOOK [ LTOP #lhndl,
                                             INDEX #lind ] ],
                         MODIFD #modif ] ],
    RCONJ-DTR [ INFLECTD #infl,
                SYNSEM [ LOCAL [ CAT [ HEAD noun_or_nomger & 
                                          [ KEYS [ KEY gen_nom_nbar_rel,
                                                   ALT2KEY #alt2key ] ],
                                       VAL.SPR < synsem & 
                                                 [ OPT -,
                                                   NONLOC #nonloc ] > ] ],
                         LEX #lex ] ],
    C-CONT [ RELS.LIST.FIRST [ PRED udef_q_rel,
                               ARG0 #lind,
                               RSTR #lrstr ],
             HCONS <! qeq & [ HARG #lrstr,
                              LARG #lhndl ] !> ] ].

nbar_coord_symmet_rule := nbar_coord_rule &
  [ SYNSEM.LOCAL.AGR.PNG #png,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.AGR.PNG #spng ] >,
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR.PNG #spng ] >,
                             AGR.PNG #png ] ].

; DPF 11-oct-05 - If there is a [DIV -] dtr, then mother must also be [DIV -],
; to block "*car and money are necessary".  Need two subtypes of symmetric
; coord rule to capture this.

nbar_coord_top_1_rule := top_coord_rule & nbar_coord_symmet_rule &
  [ SYNSEM.LOCAL.AGR.DIV #div,
    LCONJ-DTR.SYNSEM.LOCAL.AGR.DIV +,
    RCONJ-DTR.SYNSEM.LOCAL.AGR.DIV #div,
    C-CONT.RELS <! relation !> ].

; Require both dtrs to be INFLECTD + to avoid spurious ambiguity for N-N
; compounds with a conjoined left dtr: "summer and winter routes"
nbar_coord_top_2_rule := top_coord_rule & nbar_coord_symmet_rule &
  [ INFLECTD +,
    SYNSEM.LOCAL.AGR.DIV -,
    LCONJ-DTR [ INFLECTD +,
                SYNSEM.LOCAL.AGR.DIV - ],
    RCONJ-DTR.INFLECTD +,
    C-CONT.RELS <! relation !> ].

nbar_coord_mid_rule := mid_coord_rule & nbar_coord_symmet_rule &
  [ SYNSEM.LOCAL.CONJ.CREL #rel,
    LCONJ-DTR.SYNSEM [ LOCAL.CAT.HEAD.KEYS.ALTKEY impl_or_expl_q_rel,
                       LEX #lex ],
    RCONJ-DTR.SYNSEM [ LOCAL.CAT.HEAD.KEYS.ALTKEY impl_or_expl_q_rel,
                       LEX #lex ],
    C-CONT.RELS <! relation, #rel !> ].

; For coord of singular and plural nbar: "husband and children", with
; AGR value to block both "*this husband and children" and "*these husband
; and children" but allow "my husband and children"
; DPF 2-Mar-05 - Removed ALTKEY explicit_q_rel because it prevented
; 'without husband and children'.

nbar_coord_asym_rule := nbar_coord_rule &
  [ INFLECTD +,
    SYNSEM.LOCAL.AGR [ PNG.PN 3sg,
                       DIV - ],
    LCONJ-DTR [ INFLECTD +,
                SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3sg,
                                                         DIV - ] ] > ],
    RCONJ-DTR [ INFLECTD +,
                SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.AGR.PNG.PN 3pl ] > ] ].

nbar_coord_asym_2_rule := nbar_coord_rule &
  [ INFLECTD +,
    SYNSEM.LOCAL [ CAT.HEAD.KEYS.ALTKEY explicit_q_rel,
                   AGR [ PNG.PN 3pl,
                         DIV + ] ],
    LCONJ-DTR [ INFLECTD +,
                SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.AGR.PNG.PN 3pl ] > ],
    RCONJ-DTR [ INFLECTD +,
                SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3sg,
                                                         DIV - ] ] > ] ].

nbar_coord_asym_top_rule := top_coord_rule & nbar_coord_asym_rule &
  [ C-CONT.RELS <! relation !> ].

nbar_coord_asym_top_2_rule := top_coord_rule & nbar_coord_asym_2_rule &
  [ C-CONT.RELS <! relation !> ].

; For now, exclude mid-coord variants
#|
nbar_coord_asym_mid_rule := mid_coord_rule & nbar_coord_asym_rule &
  [ LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.ALTKEY impl_or_expl_q_rel,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.ALTKEY impl_or_expl_q_rel ].

nbar_coord_asym_mid_2_rule := mid_coord_rule & nbar_coord_asym_2_rule &
  [ LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.ALTKEY impl_or_expl_q_rel,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.ALTKEY impl_or_expl_q_rel ].
|#

; For now, only conjoin lexical adverbs
; Consider collapsing this with p_coord_phr type
adv_coord_phr := norm_coord_phr &
  [ SYNSEM [ LEX -,
             LOCAL [ CAT [ HEAD adv & [ PRD #prd,
                                        KEYS #keys,
                                        MOD #mod,
                                        TAM #tam ],
                           VAL [ SPR < [ LOCAL local_min &
                                           [ CAT [ HEAD adv &
                                                    [ KEYS.KEY much_deg_rel ],
                                                   VAL [ SPR *olist*,
                                                         COMPS < > ] ],
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #ind ] ],
                                         NONLOC.QUE 0-dlist ] >,
                                 COMPS < > ],
                           POSTHD #ph ],
                     CONT.HOOK [ LTOP #ltop,
                                 INDEX #ind,
                                 XARG #xarg ] ] ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD adv & [ PRD #prd,
                                               KEYS #keys,
                                               MOD #mod,
                                               TAM #tam ],
                             CONT.HOOK.XARG #xarg ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD adv & [ PRD #prd,
                                                MOD #mod,
                                                TAM #tam ],
                                   POSTHD #ph ],
                             CONT.HOOK.XARG #xarg ] ].

adv_coord_top_phr := adv_coord_phr & top_coord_event_rule.
    
adv_coord_mid_phr := adv_coord_phr & mid_coord_event_rule.


; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 27-Nov-04 - Removed SPR *anti-list* from left dtr, to allow N-bars
; like "act of kindness; assistance"
; DPF 27-Nov-04 - Added LPERIPH + as hack to prevent these from being
; modified by subconj_prdp phrases, as in "coming next after the ninety-ninth"
; DPF 14-aug-05 - Limit to run-ons where message is same on both conjuncts,
; to avoid underspecification of message on left dtr which leads to unwanted
; triggering for generation
; DPF 03-sep-05 - But this doesn't work so well with fragments.  So just
; restrict left conjunct to prop_imp_m_rel, and ignore for now run-ons with a
; left interrogative -- annoying in treebanking, but manageable.

#|
run_on_coord_rule := binary_rule_right_to_left & basic_coord_phr &
  [ INFLECTD +,
    SYNSEM [ LEX -,
             LOCAL [ CAT [ HEAD conj-s & [ MOD < >,
                                           KEYS [ KEY discourse_rel,
                                                  ALTKEY no_rel ] ],
                           VAL [ SUBJ *anti_list*,
                                 SPR *anti_list*,
                                 COMPS < > ],
                           MC + ],
                     CONT.MSG #msg,
                     AGR.PNG #png,
                     CONJ cnil ],
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct ],
             MODIFD.LPERIPH + ],
    LCONJ-DTR [ INFLECTD +,
                SYNSEM [ LOCAL local & 
                             [ CAT [ HEAD verb_or_frag &
                                          [ TAM.MOOD ind_or_mod_subj,
                                            KEYS [ KEY norm_rel,
                                                   ALTKEY norm_rel ] ],
                                     VAL [ SUBJ *anti_list*,
                                           COMPS < > ],
                                     MC + ],
                               CONT [ HOOK [ LTOP #lhand,
                                             INDEX #lind ],
                                      MSG message & [ PRED prop_imp_m_rel ] ],
                               CONJ cnil_or_lexconj & 
                                     [ CHEAD.LEFT.FIRST cnil ] ],
                         NONLOC.SLASH 0-dlist & [ LIST < > ],
                         PUNCT [ LPUNCT #lpunct,
                                 RPUNCT clause_or_semicol ] ] ],
    RCONJ-DTR [ INFLECTD +,
                SYNSEM [ LOCAL local & 
                               [ CAT [ HEAD verb_or_frag &
                                            [ KEYS [ KEY norm_rel,
                                                     ALTKEY norm_rel ] ],
                                       VAL [ SUBJ *anti_list*,
                                             COMPS < > ],
                                       MC + ],
                                 CONT [ HOOK [ LTOP #rhand,
                                               INDEX #rind ],
                                        MSG #msg & message ],
                                 AGR.PNG #png,
                                 CONJ cnil_or_lexconj & 
                                     [ CHEAD.LEFT.FIRST cnil ] ],
                         NONLOC.SLASH 0-dlist & [ LIST < > ],
                         MODIFD.LPERIPH -,
                         PUNCT [ LPUNCT lparen_or_no_punct,
                                 RPUNCT #rpunct ] ] ],
    C-CONT [ HOOK [ LTOP #cltop,
                    INDEX #ind ],
	     RELS <! conj_relation & [ PRED implicit_conj_rel,
                                       LBL #cltop,
                                       ARG0 #ind,
                                       L-HNDL #lhand,
                                       L-INDEX #lind,
                                       R-HNDL #rhand,
                                       R-INDEX #rind ] !>,
             HCONS <! !> ] ].
|#

basic_run_on_rule := binary_rule_right_to_left & basic_binary_phrase &
  [ INFLECTD +,
    SYNSEM [ LEX -,
             LOCAL [ CAT [ HEAD conj-s & [ MOD < >,
                                           KEYS [ KEY discourse_rel,
                                                  ALTKEY no_rel ] ],
                           VAL [ SUBJ *anti_list*,
                                 SPR *anti_list*,
                                 COMPS < > ],
                           MC + ],
                     AGR.PNG #png,
                     CONJ cnil ],
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct ],
             MODIFD.LPERIPH + ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL local & 
                            [ CAT [ VAL [ SUBJ *anti_list*,
                                          COMPS < > ] ],
                              CONT [ HOOK [ LTOP #lhand,
                                            INDEX #lind ] ],
                              CONJ cnil_or_lexconj & 
                                  [ CHEAD.LEFT.FIRST cnil ] ],
                      NONLOC.SLASH 0-dlist & [ LIST < > ],
                      PUNCT [ LPUNCT #lpunct ] ] ],
           [ INFLECTD +,
             SYNSEM [ LOCAL local & 
                            [ CAT [ VAL [ SUBJ *anti_list*,
                                          COMPS < > ] ],
                              AGR.PNG #png,
                              CONJ cnil_or_lexconj & 
                                  [ CHEAD.LEFT.FIRST cnil ] ],
                      NONLOC.SLASH 0-dlist & [ LIST < > ],
                      MODIFD.LPERIPH -,
                      PUNCT [ LPUNCT lparen_or_no_punct,
                              RPUNCT #rpunct ] ] ] >,
    C-CONT [ HOOK [ LTOP #cltop,
                    INDEX #ind ],
	     RELS.LIST < conj_relation & 
                         [ PRED implicit_conj_rel,
                           LBL #cltop,
                           ARG0 #ind,
                           L-HNDL #lhand,
                           L-INDEX #lind ], ... > ] ].

run_on_coord_rule := basic_run_on_rule & basic_coord_phr &
 [ SYNSEM.LOCAL.CONT.MSG #msg,
   LCONJ-DTR #lconj &
             [ SYNSEM [ LOCAL [ CAT [ HEAD verb_or_frag &
                                          [ TAM.MOOD ind_or_mod_subj,
                                            KEYS [ KEY norm_rel,
                                                   ALTKEY norm_rel ] ],
                                      MC + ],
                                CONT.MSG message & [ PRED prop_imp_m_rel ] ],
                        PUNCT.RPUNCT clause_or_semicol ] ],
   RCONJ-DTR #rconj &
             [ SYNSEM [ LOCAL [ CAT [ HEAD verb_or_frag &
                                           [ KEYS [ KEY norm_rel,
                                                    ALTKEY norm_rel ] ],
                                      MC + ],
                                CONT [ HOOK [ LTOP #rhand,
                                            INDEX #rind ],
                                       MSG #msg & message ] ] ] ],
   C-CONT [ RELS <! [ R-HNDL #rhand,
                      R-INDEX #rind ] !>,
            HCONS <! !> ],
   ARGS < #lconj, #rconj > ].

run_on_np_rule := basic_run_on_rule & non_headed_phrase &
 [ SYNSEM [ LOCAL.CONT.MSG #msg,
            NONLOC #nonloc ],
   ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD frag & [ KEYS.KEY norm_rel ],
                             CONT.MSG message & #msg & 
                                 [ PRED prop_imp_m_rel ] ],
                     NONLOC #nonloc,
                     PUNCT.RPUNCT rbcomma_punct ] ],
          [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ KEYS.KEY norm_rel ],
                                   VAL.SPR < > ],
                             CONT.HOOK.INDEX #nind ],
                     NONLOC #nonloc ] ] >,
   C-CONT [ RELS <! [ R-HNDL #rhand,
                      R-INDEX #rind ],
                    [ PRED unknown_rel,
                      LBL #ulbl,
                      ARG0 #rind,
                      ARG #nind ] !>,
            HCONS <! qeq & [ HARG #rhand, LARG #ulbl ] !> ],
   GENRE informal ].

no_copula_prd_vp_rule := no_copula_prd_phrase & rule.

no_copula_id_vp_rule := no_copula_id_phrase & rule.

no_copula_nosubj_rule := no_copula_nosubj_phrase & rule.

free_rel_inf_rule := binary_rule_left_to_right & free_rel_inf_phrase.

free_rel_fin_rule := binary_rule_left_to_right & free_rel_fin_phrase.

partitive_num_nocomp_rule := partitive_num_nocomp_phrase & rule.

partitive_num_ppof_rule := partitive_num_ppof_phrase & rule.

partitive_intadj_nocomp_rule := partitive_intadj_nocomp_phrase & rule.

partitive_intadj_ppof_rule := partitive_intadj_ppof_phrase & rule.

possessed_np_rule := possessed_np_phrase & rule.

partitive_np_rule := partitive_np_phrase & rule.

vocative_np_rule := vocative_np_phrase & rule &
  [ SYNSEM [ LOCAL.CAT [ POSTHD +,
                         HEAD.MOD < [ PUNCT.RPUNCT comma_punct ] > ],
             MODIFD.RPERIPH - ],
    ARGS < [ SYNSEM.MODIFD.RPERIPH na_or_+ ] > ].

vocative_np_lmod_rule := vocative_np_phrase & rule &
  [ SYNSEM [ LOCAL.CAT [ POSTHD -,
                         HEAD.MOD < [ MODIFD.LPERIPH - ] > ],
             MODIFD.LPERIPH + ],
    ARGS < [ SYNSEM.PUNCT.RPUNCT comma_punct ] > ].

num_det_rule := num_det_phrase & rule.

; DPF 14-aug-05 - Made frags be MC + (rather than na_or_+) to prevent non-MC
; modifiers (like 'not') from modifying fragments.

basic_frag_rule := phrase & rule &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD frag & [ KEYS.KEY unknown_rel ],
                           VAL [ SUBJ < anti_synsem_min >,
                                 COMPS < > ],
                           MC + ],
                     CONJ cnil_or_lexconj & 
                         [ CHEAD.LEFT.FIRST cnil ],
                     CONT.MSG #msg & [ MARG #marg ] ],
             NONLOC [ SLASH 0-dlist & [ LIST < > ],
                      REL 0-dlist,
                      QUE 0-dlist ] ],
    C-CONT [ HOOK.LTOP #lbl,
             RELS.LIST < #msg &
                         [ LBL #lbl,
                           PRED prop-or-ques_m_rel ], ... >,
             HCONS.LIST < qeq & [ HARG #marg ], ... > ] ].


norm_frag_rule := basic_frag_rule &
  [ C-CONT [ HOOK.INDEX #arg0,
             RELS.LIST < relation & [ ARG0 #arg0 ],
                         unknown_relation & [ ARG0 #arg0 ], ... > ] ].

basic_unary_frag_rule := norm_frag_rule & norm_unary_phrase &
  [ SYNSEM.LOCAL.CONT.MSG.PRED #pred,
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
                              CONJ cnil_or_lexconj & 
                                [ CHEAD.LEFT.FIRST cnil ] ],
                      NONLOC.REL 0-dlist,
                      PUNCT.RPUNCT.MSGPRED #pred ] ] > ].

unary_frag_rule := basic_unary_frag_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    ARGS < [ SYNSEM.NONLOC.SLASH 0-dlist & [ LIST < > ] ] >,
    C-CONT [ RELS <! relation, [ LBL #ulbl ] !>,
             HCONS.LIST < [ LARG #ulbl ], ... > ] ].

frag_nom_rule := basic_unary_frag_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD supnoun &
                                         [ CASE acc ],
                                    VAL [ SUBJ *olist*,
                                          SPR #spr ] ],
                              CONT [ HOOK.INDEX #ind,
                                     MSG no_msg ] ],
                      NONLOC.SLASH 0-dlist & [ LIST < > ] ],
             POSSCL - ] >,
    C-CONT [ RELS.LIST.REST.FIRST [ LBL #ulbl,
                                    ARG #ind ],
             HCONS.LIST < [ LARG #ulbl ], ... > ] ].

frag_np_rule := frag_nom_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR *olist*,
    C-CONT [ RELS <! relation, relation !>,
             HCONS <! qeq !> ] ].

frag_nbar_rule := frag_nom_rule &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < unexpressed &
                                 [ OPT - ] >,
                   CONT.HOOK.INDEX.DIV - ],
    ARGS < [ SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY nbar_or_dofm_rel,
                            CONT.HOOK [ LTOP #nhand,
                                        INDEX #index & [ DIV - ] ] ] ] >,
    C-CONT [ RELS <! relation, relation, [ PRED udef_q_rel,
                                           ARG0 #index,
                                           RSTR #rhand ] !>,
             HCONS <! qeq, qeq & [ HARG #rhand,
                                   LARG #nhand ] !> ] ].

frag_pp_ind_rule := unary_frag_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD prep & 
                                     [ MOD < synsem &
                                             [ LOCAL intersective_mod ] >,
                                       KEYS.KEY independent_rel ],
                                  VAL.SPR *synlist* ],
                            CONT.HOOK [ LTOP #klbl,
                                        INDEX #arg ] ] ] >,
    C-CONT [ RELS.LIST.REST.FIRST [ LBL #klbl,
                                    ARG0 #arg ],
             HCONS <! qeq !> ] ].

; DPF 05-Dec-03 - Try excluding expletive-it subject adjectives, to prevent eg
; spurious analysis for 'okay I will stay'
; DPF 10-apr-05 - But this also blocks "Impossible to know" and
; "how convenient that Kim left!" so live with the above ambiguity
; DPF 21-dec-05 - Removed [PRD +] since it blocked coord of adj and passive VP
frag_adj_rule := unary_frag_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD adj,
                                  VAL.COMPS < > ],
                            CONT.HOOK.INDEX #ind ] ] >,
    C-CONT [ RELS.LIST.REST.FIRST.ARG0 #ind,
             HCONS <! qeq !> ] ].

frag_adv_rule := unary_frag_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD basic_adv &
                                     [ MOD < synsem &
                                             [ LOCAL scopal_mod &
                                                [ CONT [ HOOK.LTOP #klbl,
                                                         MSG no_msg ] ] ] > ],
                                  POSTHD - ],
                            CONT.MSG no_msg ] ] >,
    C-CONT [ RELS.LIST.REST.FIRST.LBL #klbl,
             HCONS <! qeq !> ] ].

frag_int_adv_rule := unary_frag_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD adv &
                                     [ MOD < synsem &
                                             [ LOCAL intersective_mod &
                                                [ CAT.HEAD adverbee,
                                                  CONT [ HOOK.LTOP #klbl,
                                                         MSG no_msg ] ] ] > ]],
                            CONT.MSG no_msg ] ] >,
    C-CONT [ RELS.LIST.REST.FIRST.LBL #klbl,
             HCONS <! qeq !> ] ].

; For conditionals, among others
frag_sent_adv_rule := basic_unary_frag_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD prep &
                                     [ MOD < synsem &
                                             [ LOCAL scopal_mod &
                                                [ CONT [ HOOK.LTOP #klbl,
                                                         MSG message ] ] ] > ],
                                    POSTHD - ],
                              CONT [ HOOK.LTOP #ltop,
                                     MSG message ] ],
                      NONLOC.SLASH 0-dlist & [ LIST < > ] ] ] >,
    C-CONT [ RELS <! relation, [ LBL #klbl ] !>,
             HCONS <! qeq & [ LARG #ltop ] !> ] ].


; DPF 23-aug-04 - Added DTRA..ALT2KEY norm_rel to enable blocking of phrases
; that cannot be fragments, such as the derived subconj_prdp 'hiking' as in
; 'hiking in Aurland'

binary_frag_rule := norm_frag_rule & binary_punct_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    DTRA [ INFLECTD +,
           SYNSEM [ LOCAL [ CAT [ HEAD [ MOD 
                                      < synsem &
                                        [ LOCAL [ CAT.HEAD adverbee &
                                                      [ KEYS.KEY norm_rel ],
                                                  CONT.HOOK [ LTOP #ulbl,
                                                              INDEX #uind ]]]>,
                                         KEYS [ KEY independent_rel,
                                                ALT2KEY norm_rel ] ],
                                  VAL [ SUBJ *olist*,
                                        COMPS < > ] ],
                            CONT [ HOOK.LTOP #mlbl,
                                   MSG.PRED #pred ],
                            CONJ cnil_or_lexconj & 
                                [ CHEAD.LEFT.FIRST cnil ] ],
                    NONLOC [ SLASH 0-dlist & [ LIST < > ],
                             REL 0-dlist,
                             QUE 0-dlist ] ] ],
    DTRB [ INFLECTD +,
           SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY independent_rel,
                                  VAL [ COMPS < >,
                                        SPR *olist* ] ],
                            CONJ cnil_or_lexconj & 
                                [ CHEAD.LEFT.FIRST cnil ] ],
                    NONLOC [ SLASH 0-dlist & [ LIST < > ],
                             REL 0-dlist ] ],
           KEY-ARG + ],
    ARGS < sign, [ SYNSEM.PUNCT.RPUNCT.MSGPRED #pred ] >,
    C-CONT [ RELS <! relation , [LBL #ulbl,
                                 ARG0 #uind ] !>,
             HCONS.LIST < qeq & [ LARG #mlbl ], ... > ] ].

binary_left_frag_rule := binary_frag_rule &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    DTRA #dtr1 &
         [ SYNSEM.PUNCT.RPUNCT comma_or_clause_or_no_punct ],
    DTRB #dtr2 & [ SYNSEM.PUNCT.PNCTPR #ppair ],
    ARGS < #dtr1, #dtr2 > ].

; DPF 25-apr-04 - Added POSTHD - to modifier, like for frag_l_mod_pp_rule.
frag_l_mod_np_rule := binary_left_frag_rule &
  [ ARGS < sign & [ SYNSEM.LOCAL.CAT.POSTHD - ],
           [ SYNSEM.LOCAL [ CAT.HEAD noun & [ CASE acc ],
                            CONT [ HOOK.INDEX #ind,
                                   MSG no_msg ] ],
             POSSCL - ] >,
    C-CONT [ RELS.LIST.REST.FIRST.ARG #ind,
             HCONS <! qeq !> ] ].

frag_l_mod_pp_rule := binary_left_frag_rule &
  [ ARGS < sign & [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL scopal_mod ] >,
                                         POSTHD - ],
                                   CONT.MSG no_msg ] ],
           [ SYNSEM.LOCAL [ CAT.HEAD prep & 
                                [ MOD < synsem &
                                        [ LOCAL intersective_mod,
                                          --SIND #kev ] >,
                                  KEYS.KEY independent_rel ],
                            CONT.HOOK.LTOP #klbl ] ] >,
    C-CONT [ RELS.LIST.REST.FIRST [ LBL #klbl,
                                    ARG0 #kev ],
             HCONS <! qeq !> ] ].

frag_l_mod_adv_rule := binary_left_frag_rule &
  [ ARGS < sign & [ SYNSEM.LOCAL [ CAT [ HEAD p_or_adv_or_dadv &
                                              [ MOD < [ LOCAL scopal_mod ] > ],
                                         POSTHD - ],
                                   CONT.MSG no_msg ] ],
           [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < synsem &
                                           [ LOCAL scopal_mod &
                                                  [ CONT.HOOK.LTOP #klbl ] ] >,
                                  POSTHD - ],
                            CONT.MSG no_msg ] ] >,
    C-CONT [ RELS.LIST.REST.FIRST.LBL #klbl,
             HCONS <! qeq !> ] ].

frag_l_mod_vp_rule := binary_left_frag_rule &
  [ ARGS < sign & [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL scopal_mod ] >,
                                         POSTHD - ],
                                   CONT.MSG no_msg ] ],
           [ SYNSEM [ LOCAL [ CAT [ HEAD verbal & 
                                         [ INV -,
                                           KEYS.KEY norm_rel,
                                           VFORM non_bse ],
                                    MC na_or_-,
                                    VAL [ SUBJ < unexpressed_reg &
                                                 [ LOCAL.CAT.HEAD noun ] >,
                                          COMPS < > ] ],
                              CONT.HOOK.INDEX #event ],
                      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                               REL 0-dlist,
                               QUE 0-dlist ],
                      PUNCT.LPUNCT no_punct ] ] >,
    C-CONT [ RELS.LIST.REST.FIRST.ARG #event,
             HCONS <! qeq !> ] ].

; DPF 05-dec-03 - Try restricting left dtr to non-WH, also to avoid spurious 
; parses for e.g 'what is a good time to meet'
binary_right_frag_rule := binary_frag_rule &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    DTRA #dtr1 & [ SYNSEM [ LOCAL.CAT [ HEAD p_or_adv_or_dadv,
                                        POSTHD + ],
                            PUNCT.PNCTPR #ppair ] ],
    DTRB #dtr2 &
         [ SYNSEM [ NONLOC.QUE 0-dlist,
                    PUNCT.RPUNCT comma_or_clause_or_no_punct ] ],
    ARGS < #dtr2, #dtr1 > ].

frag_r_mod_np_rule := binary_right_frag_rule &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD noun &
                                       [ CASE acc,
                                         KEYS.ALTKEY non_freerel_q_rel ],
                              CONT [ HOOK.INDEX #ind,
                                     MSG no_msg ] ],
                      PUNCT.RPUNCT #rpunct ],
             POSSCL - ],
           sign & [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal_mod,
                                                    PUNCT.RPUNCT #rpunct ] >,
                                   CONT.MSG no_msg ] ] >,
    C-CONT [ RELS.LIST.REST.FIRST.ARG #ind,
             HCONS <! qeq !> ] ].

frag_r_mod_int_pp_rule := binary_right_frag_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD p_or_adv &
                                     [ MOD < synsem &
                                             [ LOCAL intersective_mod,
                                               --SIND #kev ] >,
                                       KEYS.KEY independent_rel ],
                                  VAL.SPR < synsem > ],
                            CONT.HOOK.LTOP #klbl ] ],
           sign & [ SYNSEM.LOCAL.CAT.HEAD.MOD 
                                  < [ LOCAL intersective_mod,
                                      --SIND #kev ] > ] >,
    C-CONT [ RELS.LIST.REST.FIRST [ LBL #klbl,
                                    ARG0 #kev ],
             HCONS <! qeq !> ] ].

frag_r_mod_scop_pp_rule := binary_right_frag_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD p_or_adv &
                                     [ MOD < synsem &
                                             [ LOCAL intersective_mod,
                                               --SIND #kev ] >,
                                       KEYS.KEY independent_rel ],
                            CONT.HOOK.LTOP #klbl ] ],
           sign & [ SYNSEM.LOCAL [ CAT.HEAD.MOD 
                                  < [ LOCAL scopal_mod &
                                            [ CONT.HOOK.LTOP #klbl ],
                                      --SIND #kev ] >,
                                   CONT.MSG no_msg ] ] >,
    C-CONT [ RELS.LIST.REST.FIRST.ARG0 #kev,
             HCONS <! qeq !> ] ].

frag_r_mod_ap_rule := binary_right_frag_rule &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD adj & [ PRD + ],
                              CONT [ HOOK.INDEX #ind,
                                     MSG no_msg ] ],
                      NONLOC.QUE 0-dlist ],
             POSSCL - ],
           sign >,
    C-CONT [ RELS.LIST.REST.FIRST.ARG #ind,
             HCONS <! qeq !> ] ].

; DPF 21-aug-04 - Added nonempty SYNSEM..ALTKEY to prevent these from 
; appearing in run_on_s rule.

basic_frag_verbal_rule := basic_frag_rule & unary_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.KEYS.ALTKEY no_rel,
                       VAL.SPR < > ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD verbal & 
                                         [ INV - ],
                                    VAL.COMPS < >,
                                    MC na_or_- ],
                              CONT [ HOOK [ LTOP #ltop,
                                            INDEX #event ],
                                     MSG [ TPC #tpc,
                                           PSV #psv ] ] ],
                      NONLOC [ REL 0-dlist,
                               QUE 0-dlist ] ] ] >,
    C-CONT [ HOOK.INDEX #event,
             RELS <! relation & [ ARG0 #event,
                                  TPC #tpc,
                                  PSV #psv ] !>,
             HCONS <! [ LARG #ltop ] !> ] ].

frag_verbal_rule := basic_frag_verbal_rule &
  [ ARGS < [ SYNSEM.NONLOC.SLASH 0-dlist & [ LIST < > ] ] > ].

frag_vp_rule := frag_verbal_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD [ KEYS.KEY norm_rel,
                                       VFORM non_bse,
                                       MOD *cons* ],
                                VAL.SUBJ < synsem &
                                           [ LOCAL.CAT.HEAD noun,
                                             --SIND non_expl-ind ] > ] ] > ].

#|
frag_nocop_s_rule := frag_verbal_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin,
                                       TAM.TENSE no_tense,
                                       KEYS.ALTKEY nonaux_v_rel ],
                                VAL.SUBJ < anti_synsem_min > ] ] > ].
|#
; "To devour or consume" - used in dictionary defs
frag_vp_slash_rule := basic_frag_verbal_rule &
  [ ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD [ KEYS.KEY norm_rel,
                                         VFORM non_fin ],
                                  VAL.SUBJ < nongappro &
                                             [ OPT + ] > ],
                      NONLOC.SLASH 1-dlist & 
                                <! [ CAT.HEAD noun & 
                                         [ KEYS.KEY reg_nom_rel,
                                           MOD < > ] ] !> ] ] > ].

; Also used in dictionary definitions
frag_pp_slash_rule := basic_unary_frag_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD prep & 
                                     [ MOD < synsem &
                                             [ LOCAL intersective_mod ] >,
                                       KEYS.KEY independent_rel ],
                                    VAL.SPR *synlist* ],
                              CONT.HOOK [ LTOP #klbl,
                                          INDEX #arg ] ],
                      NONLOC.SLASH 1-dlist ] ] >,
    C-CONT [ RELS <! relation, [ LBL #klbl,
                                 ARG0 #arg ] !>,
             HCONS <! qeq & [ LARG #klbl ] !> ] ].


frag_dadv_rule := basic_frag_rule & norm_unary_phrase &
  [ SYNSEM.LOCAL.CAT [ VAL.SPR < >,
                       POSTHD - ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD root-marker,
                                  POSTHD - ],
                            CONT.HOOK [ LTOP #ltop,
                                        INDEX #ind ] ] ] >,
    C-CONT [ HOOK.INDEX #ind,
             RELS <! relation & [ ARG0 #ind ] !>,
             HCONS <! [ LARG #ltop ] !> ] ].

punct_marker_phrase := head_nexus_rel_phrase & basic_binary_headed_phrase &
  [ SYNSEM [ LOCAL [ CAT #cat,
                     CONT #cont,
                     AGR #agr,
                     CONJ #conj ],
             MODIFD #modif ],
    NH-DTR.SYNSEM.LOCAL [ CAT [ HEAD punct_hd,
                                VAL.COMPS < #synsem > ],
                          CONJ cnil ],
    HD-DTR [ INFLECTD +,
             SYNSEM #synsem & [ LOCAL [ CAT #cat,
                                        CONT #cont,
                                        AGR #agr,
                                        CONJ #conj ],
                                MODIFD #modif ] ],
    INFLECTD + ].

punct_marker_hfinal_rule := punct_marker_phrase & head_final &
                            binary_rule_left_to_right & head_valence_phrase &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT #rpunct,
                   PNCTPR #ppair ],
    NH-DTR.SYNSEM.PUNCT.LPUNCT #lpunct & punct_mark,
    HD-DTR.SYNSEM.PUNCT [ RPUNCT #rpunct,
                          PNCTPR #ppair ] ].

; Making mother be SYNSEM lex_punct_synsem prevents spurious application of
; derivational rules that are constrained by synsem type.  Assumes that
; right punctuation will attempt to attach to each derivational stage of
; a lexical entry - maybe not pretty, but can't be helped since PUNCT has
; to be inside SYNSEM, so can't identify synsems of hd-dtr and mother.
; DPF 19-sept-04 - Removed parent word_or_lexrule since this causes infinite
; recursion in generation with e.g. period, and it's not clear why we wanted
; recursion here anyway.

#|
punct_marker_hinit_rule := punct_marker_phrase & head_initial &
                           binary_rule_right_to_left &
  [ SYNSEM lex_punct_synsem &
           [ PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct,
                     PNCTPR #ppair ],
             NONLOC [ SLASH #slash,
                      QUE #que ] ],
    HD-DTR word_or_lexrule & 
           [ SYNSEM [ PUNCT.LPUNCT #lpunct,
                      NONLOC.SLASH #slash,
                      LEX + ] ],
    NH-DTR.SYNSEM [ PUNCT [ LPUNCT no_punct,
                            RPUNCT #rpunct,
                            PNCTPR #ppair ],
                    NONLOC.QUE #que ] ].
|#

punct_marker_hinit_rule := punct_marker_phrase & head_initial &
                           binary_rule_right_to_left &
  [ SYNSEM synsem &
           [ PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct,
                     PNCTPR #ppair ],
             NONLOC [ SLASH #slash,
                      QUE #que ] ],
    HD-DTR word_or_lexrule & 
           [ SYNSEM [ PUNCT.LPUNCT #lpunct,
                      NONLOC.SLASH #slash,
                      LEX + ] ],
    NH-DTR.SYNSEM [ PUNCT [ LPUNCT no_punct,
                            RPUNCT #rpunct,
                            PNCTPR #ppair ],
                    NONLOC.QUE #que ] ].

; DPF 11-oct-05 - This rule should ideally check for the presence of a
; matching right paren on the nh-dtr, but this can't simply be the value
; of RPUNCT, since we might have e.g. "The boss (Abrams), who arrived..."
; or "Kim hired the guy (Abrams); we approved."  More generally, we need
; to keep track of a paren being in the punctuation cluster, and presumably
; also for other right paired elements like quotes.  For now, we'll
; over-generate.

paren_float_rule := head_initial & head_compositional & 
                    binary_rule_right_to_left &
  [ INFLECTD +,
    SYNSEM phr_synsem &
	   [ LOCAL.CAT [ VAL #valence ],
	     NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             MODIFD [ LPERIPH na,
                      RPERIPH + ],
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT no_punct,
                     PAIRED #paired ] ],
    HD-DTR [ INFLECTD +,
             SYNSEM canonical_synsem &
	     [ LOCAL [ CAT [ HEAD noun,
                             VAL #valence &
                                  [ SPR < synsem >,
                                    COMPS < > ] ],
                       CONT [ HOOK [ LTOP #ltop,
                                     INDEX #hdind & ref-ind ],
                              MSG no_msg ],
                       CONJ cnil_or_lexconj ],
               NONLOC [ SLASH 0-dlist,
                        QUE 0-dlist,
                        REL 0-dlist ],
               MODIFD.RPERIPH bool,
               PUNCT [ LPUNCT #lpunct,
                       RPUNCT no_punct ] ] ],
    NH-DTR [ INFLECTD +,
             SYNSEM canonical_synsem &
  	     [ NONLOC [ SLASH 0-dlist & [ LIST < > ],
                        QUE 0-dlist,
                        REL 0-dlist ],
               PUNCT [ LPUNCT lparen_punct,
                       PAIRED #paired ] ] ],
    C-CONT.RELS.LIST < [ LBL #ltop,
                         PRED parenthetical_rel,
                         ARG1 #hdind ], ... > ].

; "Abrams (I mean it) arrived"
paren_float_s_rule := paren_float_rule &
  [ NH-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb,
                                VAL [ SUBJ *anti_list*,
                                      SPR *cons*,
                                      COMPS < > ],
                                MC + ],
                          CONT.HOOK.LTOP #nhtop ],
    C-CONT [ RELS <! [ ARG2 #nhtop ] !>,
             HCONS <! !> ] ].

; "We visited Turlidfossen (waterfall)."
paren_float_nbar_rule := paren_float_rule &
  [ NH-DTR.SYNSEM.LOCAL [ CAT nbar_cat &
                              [ VAL.SPEC *anti_list* ],
                          CONT.HOOK [ LTOP #nhtop,
                                      INDEX #nhind ] ],
    C-CONT [ RELS <! [ ARG2 #nhind ],
                     [ PRED udef_q_rel,
                       ARG0 #nhind,
                       RSTR #rhand ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhtop ] !> ] ].

; Combine lexical complementizer with its first complement, and supply the
; message EP.
basic_complementizer_rule := binary_phrase & non_headed_phrase & 
                             binary_rule_left_to_right &
  [ SYNSEM [ LOCAL [ CAT [ HEAD comp & [ VFORM #vform, AUX #aux, INV #inv, 
                                         PRD #prd, TAM #tam, CASE #case, 
                                         POSS -, KEYS #keys, MOD #mod ],
                           VAL [ SUBJ #subj, SPR #spr, SPEC #spec,
                                 COMPS #comps ],
                           MC #mc,
                           POSTHD #ph ],
                     CONT.MSG #msg,
                     CONJ #conj,
                     AGR #agr ],
             NONLOC #nonloc,
             PUNCT.PNCTPR #pnctpr ],
    ARGS < sign &
           [ SYNSEM [ LOCAL [ CAT [ HEAD lexcomp & 
                                         [ VFORM #vform, AUX #aux, INV #inv, 
                                           PRD #prd, TAM #tam, CASE #case, 
                                           KEYS #keys, MOD #mod ],
                                    VAL [ SUBJ #subj, SPR #spr, SPEC #spec,
                                          COMPS < #comp1 . #comps > ],
                                    MC #mc,
                                    POSTHD #ph ],
                              CONT [ HOOK #hook,
                                     MSG #msg ],
                              CONJ #conj & cnil,
                              AGR #agr ],
                      NONLOC #nonloc,
                      PUNCT [ RPUNCT comma_or_rbc_or_pair_or_no_punct,
                              PNCTPR ppair ] ] ],
           sign & [ SYNSEM #comp1 & [ PUNCT.PNCTPR #pnctpr ] ] >,
    C-CONT [ HOOK #hook,
             RELS.LIST < message & #msg, ... >,
             HCONS <! !> ] ].
                    
complementizer_rule := basic_complementizer_rule &
  [ C-CONT.RELS <! [ PRED prpstn_or_like_m_rel ] !> ].

complementizer_int_rule := basic_complementizer_rule &
  [ ARGS.FIRST.SYNSEM.LOCAL.CONT [ HOOK.INDEX #arg0,
                                   HCONS.LIST.FIRST.HARG #marg ],
    C-CONT [ RELS <! [ PRED int_m_rel,
                       ARG0 #arg0,
                       MARG #lbl ],
                     [ LBL #lbl,
                       PRED prpstn_m_rel,
                       ARG0 #arg0,
                       MARG #marg ] !> ] ].
