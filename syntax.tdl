;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  syntax.tdl
;;;
;;;  The grammar rules for English
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;  Last revised: Dan Flickinger, 24-Feb-97

;;
;;  Phrase structure schemata
;;

; Headed phrases must obey the Head Feature Principle and the Revised Marking
; Principle.  They do not all obey the NLFP with respect to QUE, but it
; appears that all CLAUSE phrases account for QUE on mother and non-head-dtr.
; Hence moved the QUE coreference to NON-CLAUSE.  Headed phrases also identify
; the value of AGR on mother and head daughter, unlike e.g. the coordination
; schemata which identify HEAD but not AGR.

non_headed_phrase :< phrase.

headed_phrase := phrase & 
  [ SYNSEM.LOCAL [ CAT [ HEAD head & #head,
			 AGR #agr ],
		   CONJ #conj,
		   CONT [ KEY #key,
			  ALTKEY #altkey,
			  COMPKEY #ckey,
			  OCOMPKEY #ockey ] ],
    HEAD-DTR.SYNSEM.LOCAL local &
		 [ CAT [ HEAD #head,
			 AGR #agr ],
		   CONJ #conj,
		   CONT [ KEY #key,
			  ALTKEY #altkey,
			  COMPKEY #ckey,
			  OCOMPKEY #ockey ] ] ].

; In Ivan's relative clause paper, the node's non-local values are identified
; with those of its head, but we haven't yet made the move to have the lexical
; head collect the non-local values of its sisters.  So we add a second type
; head_nexus_prime_phrase which identifies the node's QUE value with that of
; its non-head daughter, and the REL value analogous to SLASH: if either
; daughter has non-empty REL, that value is identified with the mother's REL.
; Then head_filler_phrase and head_subject phrase are of type
; head_nexus_phrase while the other head_valence_phrases are of type
; head_nexus_prime_phrase.  These two should be collapsed once we make the
; lexicalist move a la Ivan.

head_nexus_phrase := headed_phrase &
  [ SYNSEM [ LOCAL.CONT.MODCONT #mcont,
	     NON-LOCAL [ REL #rel,
			 QUE #que ] ],
    HEAD-DTR.SYNSEM.NON-LOCAL [ REL #rel,
				QUE #que ],
    C-CONT [ MODCONT #mcont,
	     H-CONS <! !> ] ].


head_nexus_prime_phrase := headed_phrase &
  [ SYNSEM.NON-LOCAL [ QUE #que,
		       REL *diff-list* &
			   [ LIST #first,
			     LAST #last ] ],
    HEAD-DTR.SYNSEM.NON-LOCAL [ QUE *e-dlist*,
				REL *diff-list* &
				    [ LIST #first,
				      LAST #middle ] ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ QUE #que,
				    REL *diff-list* &
					[ LIST #middle,
					  LAST #last ] ],
    C-CONT.H-CONS <! !> ].

; All phrases are either unary or binary.

unary_phrase := phrase &
  [ SYNSEM.LOCAL [ CONT [ LISZT *diff-list* &
				[ LIST #first,
				  LAST #last ],
			  H-STORE *diff-list* &
				[ LIST #hsfirst,
				  LAST #hslast ],
			  H-CONS *diff-list* &
				[ LIST #scfirst,
				  LAST #sclast ],
			  TOP-H #top ],
		   CTXT.C-INDS #c-inds ],
    C-CONT [ LISZT [ LIST #middle,
		     LAST #last ],
	     H-STORE [ LIST #hsmiddle,
		       LAST #hslast ],
	     H-CONS [ LIST #scmiddle,
		      LAST #sclast ]],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle ],
					  H-STORE *diff-list* &
						[ LIST #hsfirst,
						  LAST #hsmiddle ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle ],
					  TOP-H #top ],
				   CTXT.C-INDS #c-inds ] ] > ].

binary_phrase := sign &
  [ SYNSEM.LOCAL [ CONT [ LISZT *diff-list* &
				[ LIST #first,
				  LAST #last ],
			  H-STORE *diff-list* &
				[ LIST #hsfirst,
				   LAST #hslast ],
			  H-CONS *diff-list* &
				[ LIST #scfirst,
				  LAST #sclast ],
			  TOP-H #top ],
		   CTXT.C-INDS #c-inds ],
    C-CONT [ LISZT *diff-list* & 
		   [ LIST #middle1,
		     LAST #middle2 ],
	     H-STORE *diff-list* &
		   [ LIST #hsmiddle2,
		      LAST #hslast ],
	     H-CONS *diff-list* &
		   [ LIST #scmiddle2,
		     LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle1 ],
					  H-STORE *diff-list* &
						[ LIST #hsfirst,
						  LAST #hsmiddle1 ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle1 ],
					  TOP-H #top ],
				   CTXT.C-INDS #c-inds ] ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #middle2,
						  LAST #last ],
					  H-STORE *diff-list* &
						[ LIST #hsmiddle1,
						   LAST #hsmiddle2 ],
					  H-CONS *diff-list* &
						[ LIST #scmiddle1,
						  LAST #scmiddle2 ],
					  TOP-H #top ],
				   CTXT.C-INDS #c-inds ] ] > ].

binary_rule_right_to_left := rule &
  [ ARGS < [ ] , [ KEY-ARG + ] > ].

; Extracted_adj_phrase is not head_nexus_phrase, since like other modifier
; phrases, it makes the C-CONT's value be its non-head-dtr's MODCONT value.
; So make it basic_head_only, and leave the rest of the non-branching rules
; as ordinary head_only.

basic_head_only := unary_phrase &
  [ HEAD-DTR #head,
    ARGS < #head > ].

head_only := basic_head_only & head_nexus_phrase.

head_initial := binary_phrase & headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head, #non-head > ].

head_final := binary_phrase & headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #non-head, #head > ].

; C-CONT is the semantic contribution of the phrase itself.  The handle and
; index of the phrase come from the handle and index of C-CONT (which are
; possibly but not necessarily identified with the handle and index of one of
; the daughters).  The liszt of the phrase is the append of the liszt of
; C-CONT and the liszts of the daughters.

head_compositional := headed_phrase &
  [ C-CONT [ HANDEL #hand,
	     INDEX #index,
	     H-CONS <! !>,
	     H-STORE <! !>,
	     MODCONT #modcont ],
    HEAD-DTR.SYNSEM.LOCAL.CONT [ HANDEL #hand,
				 INDEX #index,
				 MODCONT #modcont ] ].

nonhead_compositional := headed_phrase &
  [ C-CONT [ HANDEL #hand,
	     INDEX #index,
	     LISZT <! !>,
	     H-STORE <! !> ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT [ HANDEL #hand,
				     INDEX #index ] ].

;;
;; Root phrases
;;

; DPF (01-14-96) Removed restriction on HEAD-DTR saying [QUE <! !>], in order
; to allow the head_comp rule to admit "which of the books" with partitive
; "which".  May be too permissive.
;   Identify ROOT value of mother with that of the head-daughter.

rqip := phrase &
  [ SYNSEM [ LOCAL.CAT.ROOT #root,
             NON-LOCAL [ QUE *diff-list* &
			     [ LIST #first,
			       LAST #last ],
			 REL #rel ] ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.ROOT #root,
		      NON-LOCAL [ QUE *diff-list* &
				      [ LIST #first,
					LAST #middle ],
				  REL *e-dlist* ] ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ QUE *diff-list* &
					[ LIST #middle,
					  LAST #last ],
				    REL #rel ] ].

; Restrict to [ ROOT na ]
non_clause := rqip &
  [ SYNSEM.LOCAL [ CAT.ROOT na,
		   CONT.MESSAGE no_rel ] ].

; We need to loosen this to allow nominal clauses (i.e., ACC-ing gerunds)
; ERB (24-10-96) And clauses headed by complementizers!!  Changed
; HEAD verb to HEAD verbal.

clause := phrase & head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verbal,
			   VALENCE.COMPS *olist*,
			   ROOT bool ],
		     CONJ cnil ],
	     NON-LOCAL [ QUE *e-dlist*,
			 REL *e-dlist* ] ],
    HEAD-DTR.SYNSEM.NON-LOCAL [ QUE *e-dlist*,
				REL *e-dlist* ] ].

root_phrase := phrase &
  [ SYNSEM [ LOCAL.CAT.ROOT +,
	     NON-LOCAL [ SLASH *e-dlist* & [ LAST *null* ],
			 QUE *e-dlist* ] ] ].

nonroot := phrase &
  [ SYNSEM.LOCAL.CAT.ROOT - ].

; ERB (03-10-96) hcomp_nc is no longer a subtype of this because 
; some of them are "clauses" in the sense of having a message other
; than no_rel (e.g., "Kim wants [to leave]").  This is actually
; in need of revision:  we are probably going to need to distinguish
; between to-headed hcomp_ncs which are selected by equi predicates
; or otherwise have PRO subjects and whether-headed hcomp_ncs on
; the one hand, and all other instances on the other with a restriction
; equivalent to SUBJ list(PRO) in order to block "To rain is difficult"
; etc.  I think this should be possible without resorting to anything
; like VFORM whether to identify cases -- see Ivan's interrogatives
; paper.

msg_clause := clause &
  [ SYNSEM.LOCAL [ CAT.MOD no-mod,
		   CONT.MESSAGE message ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.INDEX #index,    
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.REL *e-dlist*,
    C-CONT.INDEX #index ].

; ERB (24-10-96) This type said HEAD.VFORM fin, but I want it to
; license 'to leave' in 'Kim knows to leave', so it has to allow
; inf as well.  I don't see why we would need it to be restricted
; to VFORM fin for the other subtypes anyway.

decl := msg_clause & headed_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.INV -,
		   CONT.MESSAGE propositional_rel ],
    C-CONT.LISZT <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE *e-dlist* ].

; ERB (07-11-96) Making the old imp_rel into a subtype of message.

imp := msg_clause & root_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ INV -,
				VFORM imp_vform ],
			 VALENCE [ SUBJ none,
				   COMPS < > ] ],
		   CONT [ MESSAGE imp_rel,
			  TOP-H #hand ] ],
    C-CONT.LISZT <! pron_rel & [ HANDEL #hand,
				 INST #inst &
				      [ PRONTYPE std_pron ] ] !>,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb,
				  ROOT na,
				  VALENCE [ SUBJ synsem &
					    [ LOCAL local &
						    [ CONT.INDEX #inst &
							     [ PNG 2per ] ] ],
					    COMPS *olist* ] ] ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE *e-dlist* ].

; ERB (28-10-96) Implementing the idea that MESSAGE works like
; KEY.  Interrog will sew the int_rel into the LISZT.  Check out
; wh-interrog for the cool stuff that it does with the PARAMS value,
; and other subtypes for what happens with SOA.
; Leaving out the HANDLE and INDEX values of C-CONT for now...

interrog := msg_clause & 
  [ SYNSEM [ LOCAL.CONT.MESSAGE int_rel,
	     NON-LOCAL [ SLASH *e-dlist* & [ LAST *null* ] ] ],
    C-CONT.LISZT <! !> ].

; ERB (17-10-96) I am adding a type for embedded polar questions 
; in order to preserve hcomp_nc as truly non-clause.  That type will
; inherit from this type, along with the matrix ynq (hcomp_rule_ynq_root).
; The only thing currently in this type that looks like it will be
; incompatible with the embedded questions is VFORM fin, so I am
; moving this to hcomp_rule_ynq_root.

; ERB (14-11-96) For this to be a supertype to hcomp_yn_nr, it can't
; be SUBJ none -- Kim knows whether to leave.

ynq := interrog & 
  [ NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE *e-dlist* ].

; ERB (24-10-96) HEAD verb -> HEAD verbal
; I may need to be more specific and say HEAD verb on some subtype,
; but I don't know...

; ERB (28-10-96) I am trying to make the which_rel of the non-head-dtr
; be on the params list of the int_rel, so I am taking the QUE value (the
; handle of the which_rel) and putting it on the PARAMS list.  

; Restrict NON-HEAD-DTR to be [HEAD subst] to avoid trying non-partitive
; determiner "whose" as filler in filler-head-wh rules.

; Assume all wh-interrog phrases are [MOOD ind_or_mod_subj].

wh_interrog := interrog & headed_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD verbal &
			      [ MOOD ind_or_mod_subj ],
			 MOD no-mod ],
		   CONT.MESSAGE.PARAMS <! #que & handle !> ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD subst,
			  NON-LOCAL.QUE *diff-list* &
		                      [ LIST *cons* &
					     [ FIRST #que,
					       REST #last & *null* ],
					LAST #last ] ] ].

; This type has subtypes for subj_head and filler_head.  If we assumed only
; finite subj_head phrases, and explicitly made the relevant filler_head
; phrases be finite (which we do), we wouldn't have to stipulate VFORM here.

wh_interrog_fin := wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin,
		       VALENCE.SUBJ none ] ].

; ERB (03-10-96) I am hoping that we won't need a relative_mes
; as some special subtype of no_rel.  Any problematic cases
; should be able to be handled with MOD no-mod in the appropriate
; position, so I am making this MESSAGE no_rel.

rel_cl := clause & nonroot &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin_or_inf,
				  MOOD indicative,
				  INV - ],
			   MOD @nbar() &
				[ CONT [ HANDEL #hand,
					 INDEX #ind ] ] ],
		     CONT [ MESSAGE hypo_rel,
			    MODCONT [ HANDEL #hand,
				      INDEX #ind,
				      LISZT <! !> ] ] ],
	     NON-LOCAL.QUE *e-dlist* ],
    C-CONT.LISZT <! !> ].

; We prevent PP adjunct extraction from feeding thatless_rel rule by requiring
; that the gap be [ MOD no-mod ], to block "the man kim slept walks." To handle
; "I remember the time Kim fell" maybe we can make the words "time" and
; "place" take an S/PP complement, not treat them as thatless_rels.  Also, 
; to block "*Sandy likes the man walks" and "*Sandy likes the man who thinks 
; went home", we require the S/NP to be [ ROOT + ], which excludes subject
; extraction for that daughter.

thatless_rel_phrase := unary_phrase & rel_cl & 
  [ SYNSEM [ LOCAL.CAT [ MOD.CONT.INDEX #ind,
			 POSTHEAD +,
			 VALENCE #valence ],
	     NON-LOCAL.SLASH *e-dlist* ],
    HEAD-DTR #head & 
	     [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
                                           [ VFORM fin ],
				      VALENCE #valence & [ SUBJ none ],
				      ROOT + ],
				CONT.MESSAGE propositional_rel ],
			NON-LOCAL.SLASH *diff-list* &
			                [ LIST *cons* &
					  [ FIRST 
					    [ CAT [ HEAD noun &
							 [ PRD - ],   
						    VALENCE [ SPR *olist*,
							      COMPS *olist* ],
						    MOD no-mod ],
					      CONT.INDEX #ind ],
					    REST #last & *null* ],
					  LAST #last ] ] ],
    ARGS < #head > ].

; The version of the Non-local Feature Principle here assumes that there will
; only be one value on the SLASH list.  To handle multiple gaps, we'll need
; more general set-manipulation functions.  This version also doesn't use a
; distinction between INHERITED and TO-BIND non-local features.  Instead, it
; treats non-local features like valence features.
;   The head_filler_phrase_fin employs one distributed disjunction to express 
; the following feature dependency:
;     Finite fillers must be saturated, but base-vform fillers are imperatives
;     and must still be lacking a subject.  
; Imperatives occur as heads only for adjunct extraction (as in 
; "On Tuesday, meet Kim"), so we add a hack to block complement extraction for
; imperatives: the filler must have a non-null MOD value (this isn't fully 
; adequate, since some phrases that can be complements have non-null MOD).
; NB: Sentence-initial adjuncts are always treated as extracted from VP.

; ERB (17-10-96) in order to get "Kim knows who to ask" under the current
; hacks (i.e., no PRO), I need a head_filler_phrase that takes something
; like "to ask" (i.e., VFORM in, SUBJ @nomp()) as its head.  So I am
; making a separate parallel type that will only be inherited by the
; embedded wh nonfinite questions.

; N.B. Since all head_filler constructions inherit from type clause, which 
; inherits from head_compositional, this type does not (though it could, 
; redundantly).

head_filler_phrase := head_final &
  [ SYNSEM [ LOCAL [ CAT.VALENCE [ COMPS < >,
				   SPR < > ],
		     CONJ cnil ],
	     NON-LOCAL.SLASH *e-dlist* ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal,
				    VALENCE.COMPS *olist* ] ],
		      NON-LOCAL [ SLASH *diff-list* &
					[ LIST *cons* &
					       [ FIRST #slash,
						 REST #last & *null* ],
					  LAST #last ],
				  QUE *e-dlist*,
				  REL *e-dlist* ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL #slash & local &
				[ CAT.VALENCE [ COMPS *olist*,
						SPR *olist* ],
				  CTXT.ACTIVATED + ],
			  NON-LOCAL.SLASH *e-dlist* ] ].

head_filler_phrase_fin := head_filler_phrase &
  [ SYNSEM.LOCAL.CAT.VALENCE.SUBJ none,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

head_filler_phrase_inf := head_filler_phrase &
  [ SYNSEM.LOCAL.CAT.VALENCE.SUBJ #subj,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.VFORM inf,
				  VALENCE.SUBJ #subj ],
			    CONT.MESSAGE hypo_rel ] ].

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to the union of those values on the daughters.  This partial
; version of the Non-local Feature Principle makes the simplifying assumption
; that the SLASH list will never have more than one element.  See discussion
; of head_nexus_phrase for treatment of REL and QUE.

head_valence_phrase := headed_phrase &
  [ SYNSEM [ LOCAL.CONT.MODCONT #mcont,
	     NON-LOCAL.SLASH *diff-list* &
				[ LIST #first,
				  LAST #last ] ],
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH *diff-list* &
                       	            [ LIST #first,
				      LAST #middle ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH *diff-list* &
	                                [ LIST #middle,
					  LAST #last ],
    C-CONT [ MODCONT #mcont,
	     H-CONS <! !> ] ].

; 1-May-96 (DPF) Restricted head to be verb only, to block spurious parses
; where NP modifed by PP was also analyzed as its subject.
; 12-Jun-96 (RPM) Allow verbal gerunds to head head/subj phrases.

; N.B. Since all head_subj_phrase constructions inherit from type clause, 
; which inherits from head_compositional, this type does not (though it could, 
; redundantly).  

head_subj_phrase := head_valence_phrase & head_final & head_nexus_phrase &
  [ SYNSEM.LOCAL [ CAT.VALENCE [ SUBJ none,
				 COMPS < >,
				 SPR < > ],
		   CONJ cnil ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #synsem,
					  COMPS *olist* ],
				ROOT na ],
    NON-HEAD-DTR.SYNSEM #synsem & synsem &
		 [ LOCAL [ CAT [ HEAD subst,
				 VALENCE [ SUBJ none,
					   COMPS *olist*,
					   SPR *olist* ] ],
			   CONT.MESSAGE no_rel ] ] ].

; A head/comps phrase is a phrase that combines a head with something selected
; for by the COMPS feature.  Head/comps phrases come in two denominations:
; head/comp phrases and head/marker phrases.  A head/comp phrases is like the
; usual VP rule, and its head (and therefore the whole phrase) must be CONJ
; cnil.  A head/comp phrase is unmarked for ROOT, but will inherit a ROOT
; specification from a clause type.  A head/marker phrases takes the place of
; the P&S94 head/marker rule.  The head must be lexical (i.e., of type "word"
; and CONJ non-cnil. A head/marker phrase passes up the rootitude of the 
; non-head daughter, to allow coordination of either root or non-root clauses.

head_comp_or_marker_phrase := head_valence_phrase & head_initial &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #subj,
				 COMPS #comps,
				 SPR #spr ],
		       MOD #mod ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #subj,
					  COMPS < #synsem . #comps >,
					  SPR #spr ],
				MOD #mod ],
    NON-HEAD-DTR.SYNSEM #synsem ].

; ERB (17-10-96) head_comp_phrase now identifies the MESSAGE of the
; head with the MESSAGE of the mother.  Because I'm not messing with
; coordination yet, I am putting this constraint on head_comp_phrase
; and not head_comp_or_marker_phrase.

head_comp_phrase := head_comp_or_marker_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD subst,
			 ROOT #root,
			 POSTHEAD + ],
		   CONJ cnil,
		   CONT.MESSAGE #mes ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.ROOT #root,
			    CONT.MESSAGE #mes ] ].

; Skip an optional complement as long as there is still another complement 
; on the list.  The only trick here is to make sure the MODCONT.LISZT of the
; optional complement is the empty list, since the head may have wanted to
; pick up its MODCONT.LISZT as a meaning-bearing PP complement, for example.

head_opt_comp_phrase := head_only & head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ VALENCE [ SUBJ #subj,
				     COMPS #comps,
				     SPR #spr ],
			   MOD #mod,
			   POSTHEAD + ],
		     CONT.MODCONT #mcont ],
	     NON-LOCAL.SLASH #slash ],
    HEAD-DTR.SYNSEM 
	   [ LOCAL.CAT [ VALENCE 
			  [ SUBJ #subj,
			    COMPS *cons* &
				 [ FIRST synsem & 
					 [ OPT +,
					   LOCAL.CONT.MODCONT.LISZT <! !> ],
				   REST #comps & 
					 < synsem, ... > ],
			    SPR #spr ],
			 MOD #mod ],
	     NON-LOCAL.SLASH #slash ],		      
    C-CONT.MODCONT #mcont ].

head_marker_phrase := head_comp_or_marker_phrase &
  [ SYNSEM [ LOCAL.CONJ strict-conj,
	     NON-LOCAL #nonlocal ],
    HEAD-DTR word,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nonlocal ].

; To block extraction of subjects of inverted auxiliaries, introduce (hack)
; restriction to accusative case on the extracted complement. This restriction
; is irrelevant (and probably unwanted) if the complement is not an NP, but we
; avoid using an awkward disjunction this way.
; Also block extraction of complements out of subjunctive-verb-headed phrases.

extracted_comp_phrase := head_only & head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ VALENCE [ SUBJ #subj,
				     COMPS #comps,
				     SPR #spr ],
			   MOD #mod ],
		     CONJ cnil ],
	     NON-LOCAL.SLASH *diff-list* &
		             [ LIST *cons* &
				    [ FIRST #comp,
				      REST #last & *null* ],
			       LAST #last ] ],
    HEAD-DTR.SYNSEM 
	   [ LOCAL.CAT [ HEAD v_or_p &
			      [ MOOD indicative ],
			 VALENCE [ SUBJ #subj,
				   COMPS < phr_synsem &
					   [ LOCAL #comp & local &
						   [ CAT [ HEAD subst & 
							    [ CASE acc ] ] ] ]
					   . #comps >,
				   SPR #spr ],
			 MOD #mod,
			 ROOT na ],
	     NON-LOCAL.SLASH *e-dlist* ],
    C-CONT.LISZT <! !> ].

; Subject extraction rule
; Assume only finite clauses have explicit subjects that can be extracted,
; and restrict these to indicative verbs (not subjunctives).

extracted_subj_phrase := head_only & head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ VALENCE [ SUBJ none,
				     COMPS < >,
				     SPR < > ],
			   MOD #mod,
			   ROOT - ],
		     CONJ cnil ],
	     NON-LOCAL.SLASH *diff-list* &
		             [ LIST *cons* &
				    [ FIRST #subj,
				      REST #last & *null* ],
			       LAST #last ] ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb &
				       [ VFORM fin,
					 MOOD indicative ],
				  VALENCE [ SUBJ synsem & 
						 [ LOCAL #subj & local ],
					    COMPS *olist* ],
				  MOD #mod,
				  ROOT na ],
		      NON-LOCAL.SLASH *e-dlist* ] ].

;; RPM (May 2, 1996) - Eliminated SPEC feature 
;; We were only using the SPEC feature for two things.  First, the SPEC
;; feature let a determiner reach into the content of the N' it specified and
;; plug its HANDEL and INDEX into the RESTR and BV of the quantifier.  But,
;; the noun can just as easily reach into the content of the specifier (via
;; the SPR) feature, so that's no reason.  Second, some quantifiers will only
;; specify certain kinds of N'.  But, all these requirements can be stated as
;; constraints on the quantifier's BV (which gets identifed with the noun's
;; INDEX by the noun's lexical entry (see definition of common_noun_synsem in
;; lextypes.tdl).   

; For specifiers of nouns (det and non-det), adjectives and prepositions.
; Also for specifiers of determiners, as in "almost all".  Needs to be modified
; to also allow "exactly which books".

head_spec_phrase := head_valence_phrase & head_final &
		    head_nexus_prime_phrase & non_clause &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #subj,
				 COMPS < >,
				 SPR #spr ],
		       MOD #mod,
		       POSTHEAD #ph ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ VALENCE [ SUBJ #subj,
					    COMPS *olist*,
					    SPR < #synsem & synsem . #spr > ],
				  MOD #mod,
				  POSTHEAD #ph,
				  ROOT na ],
			    CONT.H-STORE #hstore,
			    CONJ cnil ],
    NON-HEAD-DTR.SYNSEM #synsem &
		        [ LOCAL [ CAT.ROOT na,
				  CONT.--HH-STORE #hstore ],
			  NON-LOCAL.SLASH *e-dlist* ] ].

; The noncompositional head_spec is for making non-number phrases:
;  - determiner + noun NPs  "the book"
;  - NP + poss phrases      "the manager 's"
;  - adv + adj APs          "very tall"

head_spec_noncompos := head_spec_phrase & nonhead_compositional &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT [ HANDEL #hand,
				     KEY non_number_rel,
				     MODCONT #mcont ],
    C-CONT [ HANDEL #hand,
	     MODCONT #mcont,
	     LISZT <! !>,
	     H-CONS <! !>,
	     H-STORE <! !> ] ].

; Among others, the compositional head_spec is used for number expressions 
; like "two hundred".

head_spec_compos := head_spec_phrase & head_compositional &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.KEY number_rel,
    C-CONT.LISZT <! !> ].

; The SYNSEM value of the head of a head/modifier phrase is token-identical
; to the MOD value of the adjunct daughter.  Additionally, the adjunct
; daughter must be complement-saturated.  The SLASH value is not set in the
; basic schema, but rather in each of the subtypes: in head_mod_phrase_simple
; the SLASH value is passed up from the head, but in the extracted_adj_phrase,
; the SLASH value of the mother is effectively the adjunct that would have
; modified the head.

head_mod_phrase := headed_phrase &
  [ SYNSEM.LOCAL [ CAT [ VALENCE [ SUBJ #subj,
				   SPR #spr,
				   COMPS < > ],
			 MOD #mod,
			 POSTHEAD #ph,
			 ROOT #root ],
		   CONT.KEY #hkey ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ VALENCE [ SUBJ #subj,
					      SPR #spr,
					      COMPS *olist* ],
				    MOD #mod,
				    POSTHEAD #ph,
				    ROOT #root ],
			      CONT.KEY #hkey,
			      CONJ cnil ],
		      NON-LOCAL [ QUE *e-dlist*,
				  REL *e-dlist* ] ],
    C-CONT.H-STORE <! !> ].

; Added restriction on adjunct's specifier to prevent unsaturated nouns
; (like 'afternoon') from serving as modifiers before they pick up their
; specifiers.
; head_mod_phrase_simple takes the MESSAGE value from its non-head dtr's 
; MODCONT.MESSAGE.  Most modifiers identify their MODCONT's message with their
; modifiee's message, but tags don't.  (Modifiers cannot simply identify their
; own message with that of their modifiee, since some signs (like "not")
; can be either a modifier or an argument, and hence need a message value 
; independent of that of their modifiee.

;;; The following paragraph is perhaps false.
;;; But true for PPs whose CONT.H is not same as MCONT.H, which should be
;;; mother's CONT.H.

; head_mod_phrase_simple cannot inherit from nonhead_compositional, since some
; adjuncts (e.g. relative clauses) specify a value for HANDEL and/or INDEX on
; the mother which is distinct from their own (this is the purpose of the
; MODCONT attribute).  Thus it is true that the nonhead daughter determines
; the HANDEL and INDEX of the mother, but they are not necessarily simply the
; nonhead's own.  It is assumed here that every adjunct (sign with non-empty
; MOD value) will also specify in its MODCONT attribute values for HANDEL,
; INDEX, and LISZT.

; Also, head_mod phrases cannot identify the mother's MODCONT with the head
; daughter's, since the modifier may itself be modified, and that can affect
; the handle and index of the resulting phrase.  Cf. Kasper's example of
; "an apparently unsolvable problem", where the handle of the modifier phrase
; will depend on whether there is an adverb modifying the adjective or not.

; SLASH of mother is append of SLASH lists for the two daughters.  In principle
; this allows distinct slash values on the two daughters, without enforcing
; parasitic gaps.  Worry about this later.

;; Changed SSM.MC.IND to be HD.MC.IND, along with H.  Needed for "perhaps in
;; Berlin"

;; Removed identification of hddtr's MESSAGE with mother's - wrong for tags,
;; at least.  Should be handled independently by each modifier.

head_mod_phrase_simple := head_mod_phrase &
  [ SYNSEM [ LOCAL [ CONT [ HANDEL #hand,
			    MODCONT [ HANDEL #mchand,
				      LISZT #hliszt,
				      KEY.HANDEL #mchand ],
			    MESSAGE #mes ] ],
	     NON-LOCAL [ SLASH *diff-list* &
			       [ LIST #first,
				 LAST #last ],
			 QUE *e-dlist*,
			 REL *e-dlist* ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT #localcat,
			      CONT [ MODCONT [ HANDEL #mchand,
					       KEY.HANDEL #hdhand,
					       INDEX #hmcind,
					       LISZT #hliszt ],
				     INDEX #hind,
				     MESSAGE #hmsg,
				     H-STORE #hstore ] ],
		      NON-LOCAL.SLASH *diff-list* &
	                              [ LIST #first,
					LAST #middle ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ MOD local & 
					    [ CAT #localcat,
					      CONT [ HANDEL #hdhand,
						     INDEX #hind,
						     H-STORE #hstore,
						     MESSAGE #hmsg,
						     MODCONT [HANDEL #mchand,
							      INDEX #hmcind]]],
					VALENCE.SPR *olist* ],
				  CONT.MODCONT #mcont &
				               [ HANDEL #hand,
						 KEY.HANDEL #hand,
						 MESSAGE #mes ] ],
			  NON-LOCAL [ SLASH *diff-list* &
					    [ LIST #middle,
					      LAST #last ],
				      QUE *e-dlist*,
				      REL *e-dlist* ] ],
    C-CONT #mcont ].



adj_head_phrase := head_mod_phrase_simple & head_final &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.PRD -,
				    POSTHEAD - ] ].

; ERB (07-11-96) Non-head dtr is QUE <! !> to rule out "*Leaving when do you
; think would bother Sandy?" or "*Your house where did the government forclose
; on?"  Not on higher type because "How long a book did you write?"

head_adj_phrase := head_mod_phrase_simple & head_initial &
  [ SYNSEM.LOCAL.CAT.POSTHEAD +,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ POSTHEAD +,
				      VALENCE.COMPS *olist* ],
			  NON-LOCAL.QUE *e-dlist* ] ].

; For now, restrict adjunct extraction to posthead modifiers of VPs.  This
; will produce two parses for "Tuesday Kim might dance", but the alternatives
; (e.g., blocking modification of all auxiliaries except the copula) seem even
; less attractive.  Also block extraction of adjuncts out of
; subjunctive-verb-headed phrases.

; ERB (12-11-96) This is the exception; the reason I couldn't put the
; MESSAGE stuff on head_mod_phrase.

extracted_adj_phrase := head_mod_phrase & basic_head_only & 
  [ SYNSEM [ LOCAL.CONT.MESSAGE #mes,
	     NON-LOCAL.SLASH *diff-list* &
			     [ LIST *cons* &
				    [ FIRST local &
					    [ CAT [ POSTHEAD +,
						    MOD #local,
						    VALENCE [ COMPS *olist*,
							      SPR *olist* ] ],
					      CONT.MODCONT #mcont & 
						  [ MESSAGE #mes ] ],
				      REST #last & *null* ],
	                       LAST #last ] ],
    C-CONT #mcont,
    HEAD-DTR.SYNSEM synsem & [ LOCAL #local & local &
				     [ CAT [ HEAD verb &
						  [ MOOD indicative ],
					     VALENCE.SUBJ synsem ] ],
			       NON-LOCAL.SLASH *e-dlist* ] ].
;;
;; Bare plural and mass NPs, distinguished by the INDEX feature [ DIVISIBLE + ]
;;

bare_np_phrase := head_only &
  [ SYNSEM [ LOCAL [ CAT [ VALENCE [ SUBJ none,
				     COMPS < >,
				     SPR < > ],
			   MOD #mod ],
		     CONT.MESSAGE #mes ],
	     NON-LOCAL.SLASH #slash ],
    HEAD-DTR.SYNSEM 
	   [ LOCAL [ CAT [ HEAD noun,
			   VALENCE 
				[ SUBJ none,
				  COMPS *olist*,
				  SPR < synsem & 
					[ OPT -,
					  LOCAL local &
					      [ CONT.KEY #quant &
							 [ RESTR #arg ] ]] > ],
			   MOD #mod ],
		     CONJ cnil,
		     CONT [ INDEX #index & [ DIVISIBLE + ],
			    KEY basic_nom_rel,
			    MESSAGE #mes,
			    MODCONT #mcont ] ],
	     NON-LOCAL.SLASH #slash ],
    C-CONT [ HANDEL #hand,
	     INDEX #index,
	     LISZT <! udef_rel & #quant &
		      [ HANDEL #hand,
			BV #index,
			RESTR #arg ] !>,
	     H-STORE <! #hand !>,
	     MODCONT #mcont ] ].

;; 
;; Noun-noun compounds
;;

;; Make left member be [ COMPS < > ] to avoid spurious ambiguity since we
;; have separate lexical entries to handle optional nominal complements.
;; Also, restrict left member to have ordinary quant_rel determiner.

;; Would like to make this sign simply inherit from head_final, but want
;; LHS to be of type  word  not of type  phrase  so this sign inherits instead
;; from binary_phrase (which is of type sign, not type phrase), and duplicates
;; the relevant information from headed_phrase, head_final, and 
;; head_compositional.

n_n_cmpnd_phr := binary_phrase & word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD head & #head,
			   VALENCE #valence,
			   MOD no-mod,
			   ROOT #root ],
		     CONJ cnil,
		     CONT mrs & [ HANDEL #hand,
				  MESSAGE #mes,
				  INDEX #hind,
				  KEY #key,
				  MODCONT #mcont ] ],

	     NON-LOCAL [ SLASH #slash,
			 QUE *e-dlist*,
			 REL *e-dlist* ] ],
    HEAD-DTR #head-dtr & word & 
	   [ SYNSEM common_noun_synsem &
		    [ LOCAL [ CAT [ HEAD #head,
				    VALENCE #valence,
				    ROOT #root ],
			      CONT [ HANDEL #hand,
				     MESSAGE #mes,
				     INDEX #hind,
				     KEY #key,
				     MODCONT #mcont ],
			      CONJ cnil ],
		      NON-LOCAL [ SLASH #slash,
				  QUE *e-dlist*,
				  REL *e-dlist* ] ] ],
    NON-HEAD-DTR word & #non-head-dtr & 
	   [ SYNSEM noun_synsem &
		    [ LOCAL [ CAT [ VALENCE.COMPS *olist*,
				    AGR.PNG 3sg ],
			      CONT [ INDEX #modind,
				     KEY reg_nom_rel ],
			      CONJ cnil ],
		      NON-LOCAL [ SLASH *e-dlist*,
				  QUE *e-dlist*,
				  REL *e-dlist* ] ] ],
    C-CONT [ HANDEL #hand,
	     INDEX #hind,
	     LISZT <! unspec_rel & [ HANDEL #hand,
				     HINST #hind,
				     NHINST #modind ] !>,
	     H-CONS <! !>,
	     H-STORE <! !>,
	     MODCONT #mcont ],
    ARGS < #non-head-dtr, #head-dtr > ].

;;
;; Coordinate structures
;;

; Ideally, the CAT value of the mother should be the least upper bound of the
; CAT values of the daughters.  The TDL formalism doesn't make this easy to
; say, so we used to just identify them.  But, that means we can't parse 
; ordinary examples like "Kim eats and can walk."  So we've adopted an uneasy
; compromise which specifies each of the attributes in CAT which must be
; unified on mother and both daughters, and leaves the others underspecified.
; Unfortunately, since not all of the features in HEAD unify, we can't unify
; HEAD itself on mother and daughters, so we can't ensure that both daughters
; have the same HEAD type, short of inferring the type from the appropriate
; features (not doable in TDL).  So we unify the HEAD value of the mother
; with that of the right conjunct - not a great solution, but better than
; none.


coord_phr := binary_phrase & non_headed_phrase & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   VALENCE #val,
			   POSTHEAD #ph,
			   MOD #mod,
			   ROOT #root ],
		     CONT [ HANDEL #hand,
			    INDEX #ind,
			    MODCONT [ HANDEL #hand,
				      INDEX #ind,
				      LISZT <! !> ] ] ],
	     NON-LOCAL #non-local ],
    LCONJ-DTR sign & #left &
		[ SYNSEM [ LOCAL.CAT [ HEAD [ VFORM #vf,
					      POSS #poss,
					      PRD #prd,
					      CASE #case,
					      MOOD #mood ],
				       VALENCE #val,
				       POSTHEAD #ph,
				       MOD #mod,
				       ROOT #root ],
			   NON-LOCAL #non-local ] ],
    RCONJ-DTR sign & #right &
		[ SYNSEM phr_synsem &
			 [ LOCAL.CAT [ HEAD #head &
					    [ VFORM #vf,
					      POSS #poss,
					      PRD #prd,
					      CASE #case,
					      MOOD #mood ],
				       VALENCE #val,
				       POSTHEAD #ph,
				       MOD #mod,
				       ROOT #root ],
			   NON-LOCAL #non-local ] ],
    C-CONT [ H-CONS <! !>,
	     H-STORE <! !> ],
    ARGS < #left, #right > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Proto-instance types

subjh_rule_decl := binary_rule_right_to_left & head_subj_phrase & decl &
  [ SYNSEM.LOCAL [ CAT.HEAD verb & [ VFORM fin ],
		   CONT.MESSAGE prpstn_rel ] ].

subjh_rule_wh := rule & head_subj_phrase & wh_interrog_fin & root_phrase.

hcomp_rule_ynq_root := rule & head_comp_or_marker_phrase & root_phrase & ynq &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb &
			      [ INV +,
				VFORM fin ],
			 VALENCE.SUBJ none ],
		   CONJ cnil ] ].

; This rule is for embedded CPs ("that Kim left", "for Kim to leave", and
; "whether Kim left").  Also for controlled to-VPs, which must be [ROOT -].
;
; The rule wasn't working properly for "that Kim left", and now seems
; redundant if the regular head-comp rule simply passes up the ROOT value
; of its head, where complementizers are unique among words in having a 
; [ROOT -] value.
#|
hcomp_rule_nonroot := rule & head_comp_phrase & msg_clause & nonroot &
  [ SYNSEM.LOCAL [ CAT.HEAD comp &
			    [ INV - ],
		   CONJ cnil ],
    C-CONT.LISZT <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE *e-dlist* ].
|#

hcomp_rule_nc := rule & head_comp_phrase & rqip & head_compositional &
  [ C-CONT.LISZT <! !> ].

hoptcomp_rule_nc := rule & head_opt_comp_phrase & rqip &
  [ C-CONT.LISZT <! !> ].

hmark_rule := rule & head_marker_phrase & head_compositional &
  [ C-CONT.LISZT <! !> ].

extracomp_rule := rule & extracted_comp_phrase & non_clause.

extrasubj_rule := rule & extracted_subj_phrase & decl & nonroot.

hspec_nc_rule := binary_rule_right_to_left & head_spec_noncompos.

hspec_c_rule := binary_rule_right_to_left & head_spec_compos.

hadj_rule := binary_rule_right_to_left & head_adj_phrase.

adjh_rule := rule & adj_head_phrase.

extradj_rule := rule & extracted_adj_phrase & non_clause.

thatless_rel_rule := rule & thatless_rel_phrase.

bare_np_rule := rule & bare_np_phrase & non_clause.

n_n_cmpnd_rule := binary_rule_right_to_left & n_n_cmpnd_phr.

; We want to make sure that the head daughter is ROOT +, to block a
; topicalization parse for "Kim walks".  That also rules out plain declarative
; embedded head/filler constructions, which are pretty marginal anyway.

filler_head_rule_decl := binary_rule_right_to_left & head_filler_phrase_fin & 
                         decl & root_phrase & head_nexus_phrase &
  [ SYNSEM.LOCAL.CONT.MESSAGE #mes,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.VFORM fin,
				  VALENCE.SUBJ none,
				  ROOT + ],
			    CONT.MESSAGE #mes & prpstn_rel ] ].

filler_head_rule_imp := binary_rule_right_to_left & head_filler_phrase_fin & 
                        imp & head_nexus_phrase &
  [ SYNSEM.LOCAL.CONT.MESSAGE #mes,
    HEAD-DTR.SYNSEM.LOCAL.CONT.MESSAGE #mes,
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.MOD local,
				CONT.MESSAGE no_rel ] ].

filler_head_rule_wh_root := rule & head_filler_phrase_fin & wh_interrog_fin & 
                            root_phrase & head_nexus_phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.INV +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VALENCE.SUBJ none ].


filler_head_rule_wh_nr_fin := rule & head_filler_phrase_fin & wh_interrog_fin &
                              nonroot & head_nexus_phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.INV - ].

filler_head_rule_wh_nr_inf := rule & head_filler_phrase_inf & wh_interrog &
                              nonroot & binary_rule_right_to_left &
			      head_nexus_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
		       VALENCE.SUBJ synsem ] ].

filler_head_rule_rel := rule & rel_cl & head_filler_phrase_fin &
  [ SYNSEM [ LOCAL.CAT.MOD.CONT.INDEX #ind,
	     NON-LOCAL.SLASH *e-dlist* ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.VFORM fin,
				  VALENCE.SUBJ none ],
			    CONT.MESSAGE propositional_rel ], 
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.REL *diff-list* &
	                              [ LIST *cons* & 
					     [ FIRST #ind,
					       REST #last & *null* ],
					LAST #last ],
    C-CONT.H-CONS <! !> ].

imperative_rule := rule & head_only & imp &
  [ SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR.SYNSEM.NON-LOCAL #nonloc ].

; The HCOMP_ROOT_RULE is for constructions like "how about on Friday".

hcomp_root_rule := rule & head_valence_phrase & head_initial &
                   head_compositional & head_nexus_phrase &
  [ SYNSEM [ LOCAL [ CAT [ VALENCE [ SUBJ none,
				     SPR < >,
				     COMPS #comps ],
			   MOD #mod,
			   ROOT #root ],
		     CONT.MESSAGE #mes,
		     CONJ cnil ],
	     NON-LOCAL [ SLASH *e-dlist* & [ LAST *null* ],
			 QUE *e-dlist*,
			 REL *e-dlist* ] ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD root-marker,
				  VALENCE [ SUBJ #subj,
					    COMPS < #synsem . #comps > ],
				  MOD #mod,
				  ROOT na ],
			    CONT.MESSAGE #mes ],
    NON-HEAD-DTR.SYNSEM #synsem & synsem & 
		   [ LOCAL.CAT [ VALENCE.SUBJ #subj,
				 ROOT #root ] ],
    C-CONT.LISZT <! !> ].


; The top_coord_rule is for building the top of a (potential iterated)
; coordinate structure and the mid_coord_rule is for building intermediate
; parts of an iterated coordinate structure.  The mid_coord_rule (and the
; head/marker schema) collect the handels and indices of the conjuncts under
; the CONJ feature and passes them (with the lexically specified coordination
; relation) up from the right conjunct.  The top_coord_rule uses handels and
; liszts from the CONJ value to build an n-ary coordination relation.  We
; could skip all this feature passing if we weren't limited by performance
; considerations to binary trees.  That is, we could build coordinate
; structures like:					  
;       						  
;       						  
;      coord_phrase					  
;             +-			        -+	  
;             | conj_rel		         |	  
;      LISZT  | HANDELS  [h1], [h2], ..., [hn]   |	  
;             | INDICES  [i1], [i2], ..., [in]   |	  
;             +-    		                -+	  
;             /             /                \ 	 	  
;            /  	   /    	      \  	  
;           /   	  /     	       \ 	  
;          /    	 /      		\ 	  
;         /     	/       		 \ 	  
;      phrase        phrase    	       	       phrase	  
;      HANDEL [h1]   HANDEL [h2] ...           HANDEL [hn]
;      INDEX  [i1]   INDEX  [i2]               INDEX  [in]
;        |             |                	 |  
;        |             |                         |  
;       Kim          Sandy       ...            Lee 
;       			     
; then we could eliminate the features HANDELS, INDICES, and REL.  These
; feature are just for bookkeeping.  The feature LEFT, on the other hand, is
; essential to the analysis.  The LEFT value is a list of (up to) two
; elements.  The first element is the required CONJ value of the left conjunct
; in a top_coord_phrase and the second element is the CONJ value of the left
; conjunct in a mid_coord_phrase.  For example, a LEFT value of < either, or >
; permits a coordinate structure like "either Kim or Sandy or Chris or Lee".
                                  
; For now, stamp [AGR non1sg] on mother, to avoid singular verb agreement with
; conjoined subject NPs.

top_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM.LOCAL [ CAT.AGR.PNG non1sg,
		   CONJ cnil ],
    C-CONT [ HANDEL #hand,
	     INDEX #ind,
	     LISZT <! #rel & 
		      [ HANDEL #hand,
			C-ARG #ind,
			HANDELS *diff-list* &
			       [ LIST < #lhand . #hands >,
				  LAST #hlast ],
			INDICES *diff-list* &
			       [ LIST < #lind . #inds >,
				 LAST #ilast ] ] !> ],
    LCONJ-DTR.SYNSEM.LOCAL local &
		      [ CONJ conj & #left,
			     CONT [ HANDEL #lhand,
				    INDEX #lind ] ],
    RCONJ-DTR.SYNSEM.LOCAL local &
		      [ CONJ complex-conj &
				  [ CHEAD [ LEFT <#left, ...>,
					    RELTN #rel ], 
				    HANDELS *diff-list* &
					    [ LIST #hands,
					      LAST #hlast ],
				    INDICES *diff-list* &
					    [ LIST #inds,
					      LAST #ilast ] ] ] ].

mid_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM.LOCAL.CONJ complex-conj &
		      [ CHEAD #chead,
			HANDELS *diff-list* &
			        [ LIST < #lhand . #hands >,
				  LAST #hlast ],
			INDICES *diff-list* &
			        [ LIST < #lind . #inds >,
				  LAST #ilast ] ],
    C-CONT [ INDEX.PNG non1sg,
	     LISZT <! !> ],
    LCONJ-DTR.SYNSEM.LOCAL [ CONJ conj & #left,
			     CONT [ HANDEL #lhand,
				    INDEX #lind ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CONJ complex-conj &
				  [ CHEAD #chead & 
					  [ LEFT < *top*, #left > ],
				    HANDELS *diff-list* &
					    [ LIST #hands,
					      LAST #hlast ],
				    INDICES *diff-list* &
					    [ LIST #inds,
					      LAST #ilast ] ] ] ].

; ERB (31-07-96) lexical rules can't feed each other, apparently,
; so I am making tag (and eventually imp_aux and maybe sai) into
; unary branching phrasal rules. 
; ERB (12-03-97) Updating tag_phrase_rule to handle everyone ... they.
; I have to specify AGR on the mother because this doesn't inherit from
; verb_synsem.

tag_phrase_rule := rule & phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
				[ AUX #aux,
				  TENSE #tense,
				  INV - ],
			   AGR #tagagr,
			   POSTHEAD +,
			   VALENCE [ SUBJ none,
				     SPR < >,
				     COMPS < #subj & pronominal_synsem &
					     [ OPT -,
					       LOCAL [ CAT [ HEAD.CASE nom,
							     AGR #tagagr],
						       CONT.INDEX #agr ]]>],
			   MOD [ CAT [ HEAD verb & 
					    [ VFORM fin,
					      TENSE #tense ],
				       AGR #agr,
				       VALENCE [ SUBJ none,
						 COMPS *olist* ],
				       ROOT + ],
				 CONT [ HANDEL #hand,
					INDEX #ind,
					KEY #key,
					MESSAGE #presup & prpstn_rel &
					       [ SOA #hand ] ] ],
			   ROOT na ],
		     CONT [ KEY #key,
			    MESSAGE #msg & ne_rel &
				           [ PARAMS <! !> ],
			    LISZT <! !>,
			    MODCONT [ HANDEL #hand,
				      INDEX #ind,
				      MESSAGE #msg ] ],
		     CTXT.PRESUP <! #presup !>,
		     CONJ #conj ],
	     NON-LOCAL.SLASH #slash ],
    HEAD-DTR #dtr &
	   [ SYNSEM sai_synsem &
		    [ LOCAL [ CAT [ HEAD [ AUX #aux,
					   TENSE #tense,
					   MOOD indicative ],
				    VALENCE [ SUBJ none,
					      COMPS.FIRST #subj ] ],
			      CONT.KEY #key,
			      CONJ #conj ],
		      NON-LOCAL.SLASH #slash ] ],
    ARGS < #dtr > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Constructions

:begin :instance.

; The instances ROOT and FRAG are needed by the parser to know which phrase 
; types to accept as successful parses of the full input string.  They should 
; be the only instances of phrase that fail to assign some other status 
; (e.g. 'rule or 'lex-entry), so they alone get to be of status 'root-node 
; (assigned on type sign), which is what the parser requires.  This is obscure,
; but seems to work.

; ERB (13-11-96) Nifty trick: all clauses have a MESSAGE value, but only those
; that are actually functioning as the root of the sentence get to put that
; MESSAGE into the semantics.  All root clauses will therefore have an RLISZT
; consisting of their MESSAGE appended to their C-CONT.LISZT.  Similarly, 
; ROOT also introduces an RH-CONS which adds the relevant scope constraint to 
; the H-CONS attribute of the clause itself.

root := phrase & 
  [ SYNSEM [ LOCAL [ CAT [ ROOT +,
			   HEAD.MOOD ind_or_mod_subj,
			   VALENCE [ SUBJ none,
				     SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE message & #mes & 
				    [ HANDEL #mhand,
				      SOA #soa ],
			    LISZT *diff-list* &
				    [ LIST #list,
				      LAST #last ],
			    H-CONS *diff-list* &
				    [ LIST #sclist,
				      LAST #sclast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist ],
			    TOP-H #mhand,
			    RLISZT *diff-list* &
				    [ LIST < #mes . #list >,
				      LAST #last ],
			    RH-CONS *diff-list* &
				    [ LIST 
				    < is-one-of &
				    [ SC-ARG #soa,
				      CANDS < #hand . #hslist > ] . #sclist >,
				     LAST #sclast ] ],
		     CONJ cnil ],
	     NON-LOCAL [ SLASH *e-dlist*,
			 QUE *e-dlist* ] ],
    C-CONT.HANDEL #hand ].

;; MODCONT's HANDEL cannot be identified with C-CONT's HANDEL, given examples
;; like "perhaps in Berlin", where the MODCONT.HANDEL is that of "in", but
;; the C-CONT.HANDEL must be that of "perhaps" which takes scope over "in".

frag := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ PRD +,
				  INV -,
				  VFORM non_fin],
			   ROOT na,
			   VALENCE [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ RLISZT *diff-list* &
				    [ LIST < message &
					     [ HANDEL #mhand,
					       SOA #soa ]
					     . < abstr_rel &
						 [ HANDEL #hand,
						   EVENT event ] . #first > >,
				      LAST #last ],
			    LISZT [ LIST #middle,
				    LAST #last ],
			    TOP-H #mhand,
			    RH-CONS *diff-list* &
				   [ LIST < is-one-of &
					    [ SC-ARG #soa,
					      CANDS < #hand . #hslist > ] 
					    . #hconslist >,
				     LAST #hconslast ],
			    H-CONS [ LIST #hconslist,
				     LAST #hconslast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist ],
			    MODCONT.LISZT [ LIST #first,
					    LASt #middle ],
			    MESSAGE no_rel ] ],
	     NON-LOCAL [ REL *e-dlist*,
			 SLASH *e-dlist* ] ] ].

frag-msg := sign &
  [ SYNSEM [ LOCAL [ CAT [ ROOT na,
			   VALENCE [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE relation & #msg &
				    [ HANDEL #mhand,
				      RESTR #hand ],
			    TOP-H #mhand,
			    RLISZT *diff-list* &
				    [ LIST < #msg . < abstr_rel &
					              [ HANDEL #hand,
							ARG #arg & individual] 
						      . < abstr_rel &
							  [ HANDEL handle,
							    INST #index,
							    ARG3 #arg ]
							  . #first > > >,
				      LAST #last ],
			    LISZT *diff-list* &
				    [ LIST #middle,
				      LAST #last ],
			    RH-CONS #hclist,
			    H-CONS #hclist,
			    MODCONT [ HANDEL #hand,
				      INDEX #index,
				      LISZT [ LIST #first,
					      LASt #middle ] ] ] ],
	     NON-LOCAL [ REL *e-dlist*,
			 SLASH *e-dlist* ] ],
    C-CONT.HANDEL #mhand ].

subjh_d := subjh_rule_decl &
  [ RULE-NAME 'subjh_d ].

subjh_wh := subjh_rule_wh &
  [ RULE-NAME 'subjh_wh ].

hcomp_nc := hcomp_rule_nc &
  [ RULE-NAME 'hcomp_nc ].

hcomp_yn_root := hcomp_rule_ynq_root &
  [ RULE-NAME 'hcomp_yn_root ].

;hcomp_nr := hcomp_rule_nonroot &
;  [ RULE-NAME 'hcomp_nr ].

hoptcomp := hoptcomp_rule_nc &
  [ RULE-NAME 'hoptcomp ].

hmark := hmark_rule &
  [ RULE-NAME 'hmark ].

extracomp := extracomp_rule &
  [ RULE-NAME 'extracomp ].

extrasubj := extrasubj_rule &
  [ RULE-NAME 'extrasubj ].

hspec_nc := hspec_nc_rule &
  [ RULE-NAME 'hspec_nc ].

hspec_c := hspec_c_rule &
  [ RULE-NAME 'hspec_c ].

hadj := hadj_rule &
  [ RULE-NAME 'hadj ].

adjh := adjh_rule &
  [ RULE-NAME 'adjh ].

extradj := extradj_rule &
  [ RULE-NAME 'extradj ].

thatless_r := thatless_rel_rule &
  [ RULE-NAME 'thatless_r ].

bare_np := bare_np_rule &
  [ RULE-NAME 'bare_np ].

n_n_cmpnd := n_n_cmpnd_rule &
  [ RULE-NAME 'n_n_cmpnd ].

fillhead_d := filler_head_rule_decl &
  [ RULE-NAME 'fillhead_d ].

fillhead_imp:= filler_head_rule_imp &
  [ RULE-NAME 'fillhead_imp ].

fillhead_wh_r := filler_head_rule_wh_root &
  [ RULE-NAME 'fillhead_wh_r ].

fillhead_wh_nr_f := filler_head_rule_wh_nr_fin &
  [ RULE-NAME 'fillhead_wh_nr_f ].

fillhead_wh_nr_i := filler_head_rule_wh_nr_inf &
  [ RULE-NAME 'fillhead_wh_nr_i ].

fillhead_rel := filler_head_rule_rel &
  [ RULE-NAME 'fillhead_rel ].

top_coord := top_coord_rule &
       [ RULE-NAME 'top_coord ].

mid_coord := mid_coord_rule &
       [ RULE-NAME 'mid_coord ].

imper := imperative_rule &
       [ RULE-NAME 'imper ].

hcomp_root := hcomp_root_rule &
       [ RULE-NAME 'hcomp_root ].

tag := tag_phrase_rule &
  [ RULE-NAME 'tag ].

:end :instance.
