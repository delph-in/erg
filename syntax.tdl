;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  syntax.tdl
;;;
;;;  The grammar rules for English
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;  Last revised: Dan Flickinger, 20-Oct-97
;;;
;;;  $Id$

;;
;;  Phrase structure schemata
;;

; Headed phrases must obey the Head Feature Principle and the Revised Marking
; Principle.  They do not all obey the NLFP with respect to QUE, but it
; appears that all CLAUSE phrases account for QUE on mother and non-head-dtr.
; Hence moved the QUE coreference to NON-CLAUSE.  Headed phrases also identify
; the value of AGR on mother and head daughter, unlike e.g. the coordination
; schemata which identify HEAD but not AGR.

non_headed_phrase :< phrase.

headed_phrase := phrase & 
  [ SYNSEM.LOCAL [ CAT.HEAD head & #head,
                   AGR #agr,
		   CONJ #conj,
		   CONT [ KEY #key,
			  ALTKEY #altkey,
			  COMPKEY #ckey,
			  OCOMPKEY #ockey ] ],
    HEAD-DTR.SYNSEM.LOCAL local &
		 [ CAT.HEAD #head,
                   AGR #agr,
		   CONJ #conj,
		   CONT [ KEY #key,
			  ALTKEY #altkey,
			  COMPKEY #ckey,
			  OCOMPKEY #ockey ] ] ].

; Head/nexus phrases pass up the REL and QUE values of the head daughter
; (which has amalgamated the REL and QUE values of its arguments a la Ivan's
; relative clause paper) to the mother.  

head_nexus_rel_phrase := headed_phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ].

head_nexus_que_phrase := headed_phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head_nexus_modcont_phrase := headed_phrase &
  [ SYNSEM.LOCAL.MODCONT #modcont,
    C-CONT [ MODCONT #modcont,
	     H-CONS <! !> ] ].

head_nexus_nonrel := head_nexus_que_phrase & head_nexus_modcont_phrase.
head_nexus_nonque := head_nexus_rel_phrase & head_nexus_modcont_phrase.
head_nexus_nonmodcont := head_nexus_rel_phrase & head_nexus_que_phrase.
head_nexus_phrase := head_nexus_rel_phrase & head_nexus_que_phrase &
		     head_nexus_modcont_phrase.

; All phrases are either unary or binary.

unary_phrase := headed_phrase &
  [ SYNSEM.LOCAL [ CONT [ LISZT *diff-list* &
				[ LIST #first,
				  LAST #last ],
			  H-STORE *diff-list* &
				[ LIST #hsfirst,
				  LAST #hslast ],
			  H-CONS *diff-list* &
				[ LIST #scfirst,
				  LAST #sclast ],
			  TOP-H #top ],
		   CTXT.C-INDS #c-inds ],
    C-CONT [ LISZT [ LIST #middle,
		     LAST #last ],
	     H-STORE [ LIST #hsmiddle,
		       LAST #hslast ],
	     H-CONS [ LIST #scmiddle,
		      LAST #sclast ]],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle ],
					  H-STORE *diff-list* &
						[ LIST #hsfirst,
						  LAST #hsmiddle ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle ],
					  TOP-H #top ],
				   CTXT.C-INDS #c-inds ] ] > ].

binary_phrase := sign &
  [ SYNSEM.LOCAL [ CONT [ LISZT *diff-list* &
				[ LIST #first,
				  LAST #last ],
			  H-STORE *diff-list* &
				[ LIST #hsfirst,
				   LAST #hslast ],
			  H-CONS *diff-list* &
				[ LIST #scfirst,
				  LAST #sclast ],
			  TOP-H #top ],
		   CTXT.C-INDS #c-inds ],
    C-CONT [ LISZT *diff-list* & 
		   [ LIST #middle1,
		     LAST #middle2 ],
	     H-STORE *diff-list* &
		   [ LIST #hsmiddle2,
		      LAST #hslast ],
	     H-CONS *diff-list* &
		   [ LIST #scmiddle2,
		     LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle1 ],
					  H-STORE *diff-list* &
						[ LIST #hsfirst,
						  LAST #hsmiddle1 ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle1 ],
					  TOP-H #top ],
				   CTXT.C-INDS #c-inds ] ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #middle2,
						  LAST #last ],
					  H-STORE *diff-list* &
						[ LIST #hsmiddle1,
						   LAST #hsmiddle2 ],
					  H-CONS *diff-list* &
						[ LIST #scmiddle1,
						  LAST #scmiddle2 ],
					  TOP-H #top ],
				   CTXT.C-INDS #c-inds ] ] > ].

binary_headed_phrase := headed_phrase & binary_phrase &
  [ NON-HEAD-DTR sign ].

binary_rule_left_to_right := rule & sign &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary_rule_right_to_left := rule & sign &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head_only := unary_phrase & headed_phrase &
  [ HEAD-DTR #head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head > ].

head_initial := binary_headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head, #non-head > ].

head_final := binary_headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #non-head, #head > ].

; C-CONT is the semantic contribution of the phrase itself.  The handle and
; index of the phrase come from the handle and index of C-CONT (which are
; possibly but not necessarily identified with the handle and index of one of
; the daughters).  The liszt of the phrase is the append of the liszt of
; C-CONT and the liszts of the daughters.

head_compositional := headed_phrase &
  [ C-CONT [ TOP #hand,
	     INDEX #index,
	     H-CONS <! !>,
	     H-STORE <! !>,
	     MODCONT #modcont ],
    HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
				 INDEX #index,
				 MODCONT #modcont ] ].

nonhead_compositional := binary_headed_phrase &
  [ C-CONT [ TOP #hand,
	     INDEX #index,
	     LISZT <! !>,
	     H-STORE <! !> ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
				     INDEX #index ] ].

; DPF (01-14-96) Removed restriction on HEAD-DTR saying [QUE <! !>], in order
; to allow the head_comp rule to admit "which of the books" with partitive
; "which".  May be too permissive.
;   Identify ROOT value of mother with that of the head-daughter.

rqip := binary_headed_phrase &
  [ SYNSEM [ LOCAL.CAT.ROOT #root,
             NON-LOCAL [ QUE *diff-list* &
			     [ LIST #first,
			       LAST #last ],
			 REL #rel ] ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.ROOT #root,
		      NON-LOCAL [ QUE *diff-list* &
				      [ LIST #first,
					LAST #middle ],
				  REL <! !> ] ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ QUE *diff-list* &
					[ LIST #middle,
					  LAST #last ],
				    REL #rel ] ].

non_clause := head_nexus_phrase & 
  [ SYNSEM.LOCAL [ CAT.ROOT na,
		   CONT.MESSAGE no_rel ] ].

non_clause_unary := unary_phrase &
  [ SYNSEM [ LOCAL [ CAT.ROOT #root & na,
		     CONT.MESSAGE no_rel ],
	     NON-LOCAL [ QUE #que,
			 REL <! !> ] ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.ROOT #root,
		      NON-LOCAL [ QUE #que,
				  REL <! !> ] ] ].

; ERB (05-10-97) The immediate subtypes of clause are now rel_cl and
; non_rel_clause.  The latter groups together decl, imp, and (wh_)interrog,
; which are similar in that they can't serve as modifiers and have empty REL
; values.  That type used to be (misleadingly) named msg_clause.  The
; remaining constraint (MESSAGE message) has been moved to the type clause
; where it belongs.

; We will need to loosen this to allow nominal clauses (i.e., ACC-ing gerunds)

clause := head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verbal,
			   VALENCE.COMPS *olist*,
			   ROOT bool ],
		     CONT.MESSAGE message,
		     CONJ cnil ],
	     NON-LOCAL [ QUE <! !>,
			 REL <! !> ] ],
    HEAD-DTR.SYNSEM.NON-LOCAL [ QUE <! !>,
				REL <! !> ] ].

root_phrase := phrase &
  [ SYNSEM [ LOCAL.CAT.ROOT +,
	     NON-LOCAL [ SLASH <! !>,
			 QUE <! !> ] ] ].

nonroot := phrase &
  [ SYNSEM.LOCAL.CAT.ROOT - ].

; ERB (03-10-96) hcomp_nc is no longer a subtype of this because some of them
; are "clauses" in the sense of having a message other than no_rel (e.g., "Kim
; wants [to leave]").  This is actually in need of revision: we are probably
; going to need to distinguish between to-headed hcomp_ncs which are selected
; by equi predicates or otherwise have PRO subjects and whether-headed
; hcomp_ncs on the one hand, and all other instances on the other with a
; restriction equivalent to SUBJ list(PRO) in order to block "To rain is
; difficult" etc.  I think this should be possible without resorting to
; anything like VFORM whether to identify cases -- see Ivan's interrogatives
; paper.

non_rel_clause := head_nexus_nonque & clause &
  [ SYNSEM.LOCAL.CAT.MOD no-mod ].

decl := non_rel_clause & 
  [ SYNSEM.LOCAL [ CAT.HEAD.INV -,
		   CONT.MESSAGE propositional_rel ],
    C-CONT.LISZT <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE <! !> ].

imp := non_rel_clause & head_valence_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ INV -,
				VFORM imp_vform ],
			 VALENCE [ SUBJ < >,
				   COMPS < > ],
			 ROOT + ],
		   CONT [ MESSAGE imp_rel,
			  TOP-H #hand ] ],
    C-CONT.LISZT <! pron_rel & [ HANDEL #hand,
				 INST #inst &
				      [ PRONTYPE std_pron ] ] !>,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb,
				  ROOT na,
				  VALENCE [ SUBJ < unexpressed &
						 [ LOCAL.CONT.INDEX #inst &
							    [ PNG.PN 2per ] ] >,
					    COMPS *olist* ] ] ] ].

; ERB (05-10-97) There is no longer a subtype of interrog for polar questions,
; as a result of streamlining the hcomp family (subordinate polar questions
; didn't inherit from the old ynq type anyway).  So interrog and its sole
; subtype wh_interrog could be collapsed into each other, but it seems clearer
; to have the separate.  I don't know what the effect of losing the constraint
; on SLASH in matrix polar questions will be.

interrog := non_rel_clause & 
  [ SYNSEM [ LOCAL.CONT.MESSAGE int_rel,
	     NON-LOCAL.SLASH <! !> ],
    C-CONT.LISZT <! !> ].

; Restrict NON-HEAD-DTR to be [HEAD subst] to avoid trying non-partitive
; determiner "whose" as filler in filler-head-wh rules.  Assume all
; wh-interrog phrases are [MOOD ind_or_mod_subj].

wh_interrog := interrog & 
  [ SYNSEM.LOCAL [ CAT [ HEAD verbal &
			      [ MOOD ind_or_mod_subj & strict_mood ],
			 MOD no-mod ],
		   CONT.MESSAGE.PARAMS <! #que & handle !> ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD subst,
			  NON-LOCAL.QUE <! #que !> ] ].

; This type has subtypes for subj_head and filler_head.  If we assumed only
; finite subj_head phrases, and explicitly made the relevant filler_head
; phrases be finite (which we do), we wouldn't have to stipulate VFORM here.

wh_interrog_fin := wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin,
		       VALENCE.SUBJ < > ] ].

rel_cl := clause & nonroot & head_nexus_nonrel &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin_or_inf,
				  MOOD ind_or_mod_subj & strict_mood,
				  INV - ],
			   MOD @nbar() &
				[ CONT [ TOP #hand,
					 INDEX #ind ] ] ,
			   ROOT - ],
		     CONT [ MESSAGE hypo_rel,
			    MODCONT [ TOP #hand,
				      INDEX #ind,
				      LISZT <! !> ] ] ],
	     NON-LOCAL.QUE <! !> ],
    C-CONT.LISZT <! !> ].

; We prevent PP adjunct extraction from feeding thatless_rel rule by requiring
; that the gap be [ MOD no-mod ], to block "the man kim slept walks." To handle
; "I remember the time Kim fell" maybe we can make the words "time" and
; "place" take an S/PP complement, not treat them as thatless_rels.  Also, 
; to block "*Sandy likes the man walks" and "*Sandy likes the man who thinks 
; went home", we require the S/NP to be [ ROOT + ], which excludes subject
; extraction for that daughter.

non_wh_rel_cl := head_only & rel_cl &
  [ SYNSEM [ LOCAL.CAT [ MOD.CONT.INDEX #ind,
			 POSTHEAD +,
			 VALENCE #valence ],
	     NON-LOCAL.SLASH <! !> ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT.VALENCE #valence & [ SUBJ < > ],
			      CONT.MESSAGE propositional_rel ],
		      NON-LOCAL.SLASH <! [ CAT [ HEAD noun &
						      [ PRD - ],   
						 VALENCE [ SPR *olist*,
							   COMPS *olist* ],
						 MOD no-mod ],

					   CONT.INDEX #ind ] !> ] ].

fin_non_wh_rel_cl := non_wh_rel_cl &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb &
				     [ VFORM fin ],
				ROOT + ] ].

inf_non_wh_rel_cl := non_wh_rel_cl &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verbal &
				     [ VFORM inf ] ] ].

; The version of the Non-local Feature Principle here assumes that there will
; only be one value on the SLASH list.  To handle multiple gaps, we'll need
; more general set-manipulation functions.  This version also doesn't use a
; distinction between INHERITED and TO-BIND non-local features.  Instead, it
; treats non-local features like valence features.

; ERB (17-10-96) in order to get "Kim knows who to ask" under the current
; hacks (i.e., no PRO), I need a head_filler_phrase that takes something like
; "to ask" (i.e., VFORM in, SUBJ @nomp()) as its head.  So I am making a
; separate parallel type that will only be inherited by the embedded wh
; nonfinite questions.

; N.B. Since all head_filler constructions inherit from type clause, which
; inherits from head_compositional, this type does not (though it could,
; redundantly).

head_filler_phrase := head_final & head_nexus_phrase & 
  [ SYNSEM [ LOCAL [ CAT.VALENCE [ SUBJ #subj,
				   COMPS < >,
				   SPR < > ],
		     CONJ cnil ],
	     NON-LOCAL.SLASH <! !> ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal,
				    VALENCE [ SUBJ #subj,
					      COMPS *olist* ] ] ],
		      NON-LOCAL [ SLASH <! #slash !>,
				  QUE <! !>,
				  REL <! !> ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL #slash & local &
				[ CAT.VALENCE [ COMPS *olist*,
						SPR *olist* ],
				  CTXT.ACTIVATED + ],
			  NON-LOCAL.SLASH <! !> ] ].

head_filler_phrase_fin := head_filler_phrase &
  [ SYNSEM.LOCAL.CAT.VALENCE.SUBJ < >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

head_filler_phrase_inf := head_filler_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.VFORM inf,
			    CONT.MESSAGE hypo_rel ] ].

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to that of the head daughter, which has already amalgamated
; the SLASH values of its arguments.  See discussion of head_nexus_phrase for
; treatment of REL and QUE.

head_valence_phrase := head_nexus_phrase &
  [ SYNSEM [ LOCAL.CONT.MODCONT #mcont,
	     NON-LOCAL.SLASH #slash ],
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    C-CONT [ MODCONT #mcont,
	     H-CONS <! !> ] ].

; 1-May-96 (DPF) Restricted head to be verb only, to block spurious parses
; where NP modifed by PP was also analyzed as its subject.
; 12-Jun-96 (RPM) Allow verbal gerunds to head head/subj phrases.

; N.B. Since all head_subj_phrase constructions inherit from type clause,
; which inherits from head_compositional, this type does not (though it could,
; redundantly).

head_subj_phrase := head_valence_phrase & head_final &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb & [ VFORM fin ],
			 VALENCE [ SUBJ < >,
				   COMPS < >,
				   SPR < > ] ],
		   CONT.MESSAGE prpstn_rel,
		   CONJ cnil ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ < #synsem >,
					  COMPS *olist* ],
				ROOT na ],
    NON-HEAD-DTR.SYNSEM #synsem & synsem &
		 [ LOCAL [ CAT [ HEAD subst,
				 VALENCE [ SUBJ < >,
					   COMPS *olist*,
					   SPR *olist* ] ],
			   CONT.MESSAGE no_rel ] ] ].

 
; A head/comps phrase is a phrase that combines a head with something selected
; for by the COMPS feature.  Head/comps phrases come in two denominations:
; head/comp phrases and head/marker phrases.  A head/comp phrases is like the
; usual VP rule, and its head (and therefore the whole phrase) must be CONJ
; cnil.  A head/comp phrase is unmarked for ROOT, but will inherit a ROOT
; specification from its head daughter.  Head/marker phrases takes the place
; of the P&S94 head/marker rule.  The head must be lexical (i.e., of type
; "word") and CONJ non-cnil. 

head_comp_or_marker_phrase := head_valence_phrase & head_compositional & 
			      head_initial &
  [ SYNSEM.LOCAL [ CAT [ ROOT #root,
			 VALENCE [ SUBJ #subj,
				   COMPS #comps,
				   SPR #spr ],
			 MOD #mod ],
		   CONT.MESSAGE #mes ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ ROOT #root,
				  VALENCE [ SUBJ #subj,
					    COMPS < #synsem . #comps >,
					    SPR #spr ],
				  MOD #mod ],
			    CONT.MESSAGE #mes ],
    NON-HEAD-DTR.SYNSEM #synsem,
    C-CONT.LISZT <! !> ].

; ERB (05-10-97) In order for one single hcomp rule to build things like "how
; about on Friday", the restriction HEAD subst needs to be removed from this
; rule, or else root-marker needs to inherit from subst.  I am opting for the
; former.

head_comp_phrase := head_comp_or_marker_phrase &
  [ SYNSEM.LOCAL [ CAT.POSTHEAD +,
		   CONJ cnil ] ].

head_marker_phrase := head_comp_or_marker_phrase &
  [ SYNSEM [ LOCAL.CONJ strict-conj,
	     NON-LOCAL #nonlocal ],
    HEAD-DTR word,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nonlocal ].

; Skip an optional complement as long as there is still another complement 
; on the list.  The only trick here is to make sure the MODCONT.LISZT of the
; optional complement is the empty list, since the head may have wanted to
; pick up its MODCONT.LISZT as a meaning-bearing PP complement, for example.

head_opt_comp_phrase := head_valence_phrase & head_only & head_compositional &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #subj,
				 COMPS #comps,
				 SPR #spr ],
		       MOD #mod,
		       POSTHEAD + ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VALENCE 
			[ SUBJ #subj,
			  COMPS < unexpressed & [ OPT + ]
				  . #comps & < synsem, ... > >,
			  SPR #spr ],
				MOD #mod ],
    C-CONT.LISZT <! !> ].

extracted_arg_phrase := head_only & head_compositional & 
			head_valence_phrase & 
  [ SYNSEM.LOCAL [ CAT [ HEAD v_or_p &
			      [ MOOD indicative ],
			 VALENCE.SPR #spr,
			 MOD #mod ],
		   CONJ cnil ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ VALENCE.SPR #spr,
				  MOD #mod ],
			    CONJ cnil ],
    C-CONT.LISZT <! !> ].

; To block extraction of subjects of inverted auxiliaries, introduce (hack)
; restriction to accusative case on the extracted complement. This restriction
; is irrelevant (and probably unwanted) if the complement is not an NP, but we
; avoid using an awkward disjunction this way.  We also block extraction of
; complements out of subjunctive-verb-headed phrases.

; *** We still need special extraction rules for fronting CPs and VPs.

extracted_comp_phrase := extracted_arg_phrase & non_clause &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #subj,
				 COMPS #comps ],
		       ROOT na ],
    HEAD-DTR.SYNSEM 
	   [ LOCAL.CAT.VALENCE [ SUBJ #subj,
				 COMPS < gap &
					 [ LOCAL.CAT [ HEAD mobile & 
							    [ CASE acc ] ] ]
					 . #comps > ] ] ].

; Assume only finite clauses have explicit subjects that can be extracted, and
; restrict these to indicative verbs (not subjunctives). 

extracted_subj_phrase := extracted_arg_phrase &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ < >,
				 COMPS < > ],
		       ROOT - ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb &
				     [ VFORM fin ],
				VALENCE [ SUBJ < gap >,
					  COMPS *olist* ],
				ROOT na ] ].    

; For specifiers of nouns (det and non-det), adjectives and prepositions.
; Also for specifiers of determiners, as in "almost all".  Needs to be modified
; to also allow "exactly which books".

head_spec_phrase := head_valence_phrase & head_final & non_clause &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #subj,
				 COMPS < >,
				 SPR #spr ],
		       MOD #mod,
		       POSTHEAD #ph ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ VALENCE [ SUBJ #subj,
					    COMPS *olist*,
					    SPR < #synsem & synsem . #spr > ],
				  MOD #mod,
				  POSTHEAD #ph,
				  ROOT na ],
			    CONT.MODCONT #mcont,
			    CONJ cnil ],
    NON-HEAD-DTR.SYNSEM #synsem &
		        [ LOCAL.CAT.ROOT na,
			  NON-LOCAL.SLASH <! !> ], 
    C-CONT.MODCONT #mcont ].

; The noncompositional head_spec is for making non-number phrases:
;  - determiner + noun NPs  "the book"
;  - NP + poss phrases      "the manager 's"
;  - adv + adj APs          "very tall"

head_spec_noncompos := head_spec_phrase & nonhead_compositional &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT [ TOP #hand,
				     KEY non_number_rel ],
    C-CONT [ TOP #hand,
	     LISZT <! !>,
	     H-CONS <! !>,
	     H-STORE <! !> ] ].


; Among others, the compositional head_spec is used for number expressions 
; like "two hundred".

head_spec_compos := head_spec_phrase & head_compositional &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.KEY number_rel,
    C-CONT.LISZT <! !> ].

; The SYNSEM value of the head of a head/modifier phrase is token-identical to
; the MOD value of the adjunct daughter.  Additionally, the adjunct daughter
; must be complement-saturated.  The SLASH value is not set in the basic
; schema, but rather in each of the subtypes: in head_mod_phrase_simple the
; SLASH value is passed up from both daughters, but in the
; extracted_adj_phrase the SLASH value of the mother is effectively the
; adjunct that would have modified the head.

head_mod_phrase := head_nexus_nonmodcont &
  [ SYNSEM.LOCAL [ CAT [ VALENCE [ SUBJ #subj,
				   SPR #spr,
				   COMPS < > ],
			 MOD #mod,
			 POSTHEAD #ph,
			 ROOT #root ],
		   CONT.KEY #hkey ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ VALENCE [ SUBJ #subj,
					      SPR #spr,
					      COMPS *olist* ],
				    MOD #mod,
				    POSTHEAD #ph,
				    ROOT #root ],
			      CONT.KEY #hkey,
			      CONJ cnil ],
		      NON-LOCAL [ QUE <! !>,
				  REL <! !> ] ],
    C-CONT.H-STORE <! !> ].

; Added restriction on adjunct's specifier to prevent unsaturated nouns
; (like 'afternoon') from serving as modifiers before they pick up their
; specifiers.

; head_mod_phrase_simple takes the MESSAGE value from its non-head dtr's 
; MODCONT.MESSAGE.  Most modifiers identify their MODCONT's message with their
; modifiee's message, but tags don't.  (Modifiers cannot simply identify their
; own message with that of their modifiee, since some signs (like "not")
; can be either a modifier or an argument, and hence need a message value 
; independent of that of their modifiee.

;; The following paragraph is perhaps false.  But true for PPs whose CONT.H is
;; not same as MCONT.H, which should be mother's CONT.H.

; head_mod_phrase_simple cannot inherit from nonhead_compositional, since some
; adjuncts (e.g. relative clauses) specify a value for TOP and/or INDEX on
; the mother which is distinct from their own (this is the purpose of the
; MODCONT attribute).  Thus it is true that the nonhead daughter determines
; the TOP and INDEX of the mother, but they are not necessarily simply the
; nonhead's own.  It is assumed here that every adjunct (sign with non-empty
; MOD value) will also specify in its MODCONT attribute values for TOP,
; INDEX, and LISZT.

; Also, head_mod phrases cannot identify the mother's MODCONT with the head
; daughter's, since the modifier may itself be modified, and that can affect
; the handle and index of the resulting phrase.  Cf. Kasper's example of
; "an apparently unsolvable problem", where the handle of the modifier phrase
; will depend on whether there is an adverb modifying the adjective or not.

; SLASH of mother is append of SLASH lists for the two daughters.  In principle
; this allows distinct slash values on the two daughters, without enforcing
; parasitic gaps.  Worry about this later.

; Changed SSM.MC.IND to be HD.MC.IND, along with H.  Needed for "perhaps in
; Berlin"

; Removed identification of hddtr's MESSAGE with mother's - wrong for tags,
; at least.  Should be handled independently by each modifier.

head_mod_phrase_simple := head_mod_phrase &
  [ SYNSEM [ LOCAL [ CONT [ TOP #hand,
			    MODCONT [ TOP #mchand,
				      LISZT #hliszt,
				      KEY.HANDEL #mchand ],
			    MESSAGE #mes ] ],
	     NON-LOCAL [ SLASH *diff-list* &
			       [ LIST #first,
				 LAST #last ],
			 QUE <! !>,
			 REL <! !> ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT #localcat,
			      CONT [ MODCONT [ TOP #mchand,
					       KEY.HANDEL #hdhand,
					       INDEX #hmcind,
					       LISZT #hliszt ],
				     INDEX #hind,
				     MESSAGE #hmsg,
				     H-STORE #hstore ] ],
		      NON-LOCAL.SLASH *diff-list* &
	                              [ LIST #first,
					LAST #middle ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ MOD local & 
					    [ CAT #localcat,
					      CONT [ TOP #hdhand,
						     INDEX #hind,
						     H-STORE #hstore,
						     MESSAGE #hmsg,
						     MODCONT [TOP #mchand,
							      INDEX #hmcind]]],
					VALENCE.SPR *olist* ],
				  CONT.MODCONT #mcont &
				               [ TOP #hand,
						 KEY.HANDEL #hand,
						 MESSAGE #mes ] ],
			  NON-LOCAL [ SLASH *diff-list* &
					    [ LIST #middle,
					      LAST #last ],
				      QUE <! !>,
				      REL <! !> ] ],
    C-CONT #mcont ].



adj_head_phrase := head_mod_phrase_simple & head_final &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.PRD -,
				    VALENCE [ SUBJ *olist*,
					      COMPS *olist* ],
				    POSTHEAD - ] ].

; ERB (07-11-96) Non-head dtr is QUE <! !> to rule out "*Leaving when do you
; think would bother Sandy?" or "*Your house where did the government forclose
; on?"  Not on higher type because "How long a book did you write?"

head_adj_phrase := head_mod_phrase_simple & head_initial &
  [ SYNSEM.LOCAL.CAT.POSTHEAD +,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ POSTHEAD +,
				      VALENCE [ SUBJ *olist*,
						COMPS *olist* ] ],
			  NON-LOCAL.QUE <! !> ] ].

; For now, restrict adjunct extraction to posthead modifiers of VPs.  This
; will produce two parses for "Tuesday Kim might dance", but the alternatives
; (e.g., blocking modification of all auxiliaries except the copula) seem even
; less attractive.  Also block extraction of adjuncts out of
; subjunctive-verb-headed phrases.

; ERB (12-11-96) This is the exception; the reason I couldn't put the MESSAGE
; stuff on head_mod_phrase.

extracted_adj_phrase := head_mod_phrase & head_only & non_clause &
  [ SYNSEM [ LOCAL.CONT [ MESSAGE #mes,
			  MODCONT.LISZT #hliszt ],
	     NON-LOCAL.SLASH <! local &
			      [ CAT [ POSTHEAD +,
				      MOD #local,
				      VALENCE [ COMPS *olist*,
						SPR *olist* ] ],
				CONT.MODCONT #mcont & 
				    [ MESSAGE #mes ] ] !> ],
    C-CONT #mcont,
    HEAD-DTR.SYNSEM synsem & [ LOCAL #local & local &
				     [ CAT [ HEAD verb &
						  [ MOOD ind_or_mod_subj & 
							 strict_mood ],
					     VALENCE [ SUBJ < synsem >,
						       COMPS *olist* ],
				       CONT.MODCONT.LISZT #hliszt ] ],
			       NON-LOCAL.SLASH <! !> ] ].

;;
;; Bare plural and mass NPs, distinguished by the INDEX feature [ DIVISIBLE + ]
;;

bare_np_phrase := head_only & non_clause & head_valence_phrase &
  [ SYNSEM.LOCAL [ CAT [ VALENCE [ SUBJ < >,
				   COMPS < >,
				   SPR < > ],
			 MOD #mod ],
		   CONT.MESSAGE #mes ],
    HEAD-DTR.SYNSEM.LOCAL 
	 [ CAT [ HEAD noun,
		 VALENCE [ SUBJ < >,
			   COMPS *olist*,
			   SPR < unexpressed & 
				 [ OPT -,
				   LOCAL local &
				       [ CONT.KEY #quant &
						  [ RESTR #arg  ] ] ] > ],
		 MOD #mod ],
	   CONJ cnil,
	   CONT [ INDEX #index & [ DIVISIBLE + ],
		  KEY basic_nom_rel,
		  MESSAGE #mes,
		  MODCONT #mcont ] ],
    C-CONT [ TOP #hand,
	     INDEX #index,
	     LISZT <! udef_rel & #quant &
		    [ HANDEL #hand,
		      BV #index,
		      RESTR #arg ] !>,
	     H-STORE <! #hand !>,
	     MODCONT #mcont ] ].

;; 
;; Noun-noun compounds
;;

; Make left member be [ COMPS < > ] to avoid spurious ambiguity since we have
; separate lexical entries to handle optional nominal complements.  Also,
; restrict left member to have ordinary quant_rel determiner.

; Would like to make this sign simply inherit from head_final, but want LHS to
; be of type word not of type phrase so this sign inherits instead from
; binary_phrase (which is of type sign, not type phrase), and duplicates the
; relevant information from headed_phrase, head_final, and head_compositional.

n_n_cmpnd_phr := binary_phrase & word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD head & #head,
			   VALENCE #valence,
			   MOD no-mod,
			   ROOT #root ],
		     CONJ cnil,
		     CONT mrs & [ TOP #hand,
				  MESSAGE #mes,
				  INDEX #hind,
				  KEY #key ] ],

	     NON-LOCAL [ SLASH #slash,
			 QUE <! !>,
			 REL <! !> ] ],
    HD-DTR #head-dtr & word & 
	   [ SYNSEM common_noun_synsem &
		    [ LOCAL [ CAT [ HEAD #head,
				    VALENCE #valence,
				    ROOT #root ],
			      CONT [ TOP #hand,
				     MESSAGE #mes,
				     INDEX #hind,
				     KEY #key,
				     MODCONT #mcont ],
			      CONJ cnil ],
		      NON-LOCAL [ SLASH #slash,
				  QUE <! !>,
				  REL <! !> ] ] ],
    NON-HD-DTR word & #non-head-dtr & 
	   [ SYNSEM noun_synsem &
		    [ LOCAL [ CAT.VALENCE.COMPS *olist*,
                              AGR.PNG.PN 3sg,
			      CONT [ INDEX #modind,
				     KEY reg_nom_rel ],
			      CONJ cnil ],
		      NON-LOCAL [ SLASH <! !>,
				  QUE <! !>,
				  REL <! !> ] ] ],
    C-CONT [ TOP #hand,
	     INDEX #hind,
	     LISZT <! unspec_rel & [ HANDEL #hand,
				     HINST #hind,
				     NHINST #modind ] !>,
	     H-CONS <! !>,
	     H-STORE <! !>,
	     MODCONT #mcont ],
    ARGS < #non-head-dtr, #head-dtr > ].

;;
;; Coordinate structures
;;
; To enable coordination of categories that are similar but not identical, we
; introduce intermediate types for some attribute values, including those for
; HEAD, AUX, and AGR.  Lexical items and the phrases they project will have
; these intermediate types as values, while signs that select for a given
; type will usually specify values for the above features using their most
; specific types.  For example, a preposition will be [ HEAD prep* ] but a
; verb which subcategorizes for a PP will specify that its complement must be
; [ HEAD prep ], assuming that HEAD values are of type 'head' organized in a
; type hierarchy as follows (simplified for exposition):
; 	
; 		head
;            /   |   \
; 	verb*  prep*  noun*
;         /  \  /  |  \  /  \
;      verb  v+p  prep p+n   noun
; 
; Most heads will select for a specific value for HEAD, but the copula "be"
; leaves the HEAD value underspecified, requiring only that its complement be
; [ PRD + ], so it will happily take as complement the conjoined phrase
; "in Paris and shopping", where the value of HEAD for this phrase is the
; unification of 'verb*' and 'prep*", namely 'v+p'.  This assumes that the
; constituent coordination schema simply requires that the CAT values of both
; conjuncts unify.
; 
; In a similar manner, the conjunction of two verb phrases, one headed by a
; main verb and one by an auxiliary, will work as long as no other constraints
; are imposed on the attribute AUX for this conjoined phrase.  Here the feature
; AUX is boolean-valued, with the following sort hierarchy for this value type:
; 
; 		bool
; 	 	/   \
;             +*     -*
; 	     /  \   /  \
;  	    +  +_and_-  -
; 
; Then in the sentence "Kim sings and has danced" the VP is [ AUX +_and_- ],
; and since declarative clauses impose no constraint on the value for AUX, the
; sentence is correctly admitted. In contrast, the auxiliary verb "do" requires
; its complement to be [ AUX - ], and since the sort '-' does not unify with
; the sort '+_and_-', the following example is correctly ruled out: 
; "*Kim did sing and have danced".
; 
; Elaborations:
; 
; 1. Since some heads only partially constrain their complements, as with
; "consider" which accepts either an AP or an NP complement, we enrich the
; above hierarchies to include a notion of 'strict' or most specific values,
; so "consider" can restrict its complement to be [ HEAD a_or_n & strict_head ]
; assuming the following more elaborate (though again partial) hierarchy:
; 
;                        head
;              	       /  |   \			    
; 		      /   |    strict_head
; 	             /  a_or_n/ /   | 
;                   /     /  /\/    | 
;                 prep*   adj*/ /noun*|
;                 |  _\__/_|_/\/  /\  |
;                 | /  \/  |  /\ /  \ |
;                prep p+a  adj a+n  noun
; 
; Here the only consistent values for the complement of "consider" are 'adj'
; or 'noun'.  Of course this isn't quite right, since we thereby exclude the
; coordination "consider Kim a friend and reliable".  What we would need is a
; way of specifying for the complement of "consider" all and only the most
; specific values subsumed by 'a_or_n'.  But at present if a head needs to
; impose partial constraint on an attribute, we cannot also get the kind of
; non-identical coordination we showed for the copula.  Leave for future work.
; 
; 2. We also undergenerate coordination of non-identical phrases in those cases
; where more than one sign imposes constraints on a single attribute.  For
; example, both determiners and verbs can constrain the AGR value of a noun
; phrase, but as soon as one of them does, we are left with a "strict" value,
; which precludes coordination with a non-identical value.  Thus we currently
; get the following incorrect pattern of grammaticality assignments:
; 
; 	a.  Abrams and the consultant
; 	b.  Abrams and the consultants
; 	c.  Abrams and this consultant
; 	d. *Abrams and these consultants
; 
; Example (b) is okay because the determiner "the" does not constrain the AGR
; value of the noun it specifies, so the NP "the consultants" will still be
; (nonstrict) [AGR 3pl*], and hence the conjoined "Abrams and the consultants"
; unifies [AGR 3sg*] and [AGR 3pl*] to give [AGR 3sg+3pl] (assuming a hierarchy
; for AGR analogous to those above for 'head' and 'bool').  Example (d) fails
; because "these" constrains its noun to be (strict) [AGR 3pl], and thus the NP
; "these consultants" will also be [AGR 3pl], and will not coordinate with
; "Abrams" because their CAT values will not unify.

coord_phr := binary_phrase & non_headed_phrase & 
  [ SYNSEM [ LOCAL [ CAT #cat,
 		     CONT [ TOP #hand,
 			    INDEX #ind,
 			    MESSAGE #msg,
 			    MODCONT [ TOP #hand,
 				      INDEX #ind,
				      LISZT *diff-list* &
                                          [ LIST #first,
                                            LAST #last ] ] ],
                     AGR #agr ],
             NON-LOCAL #non-local ],
    LCONJ-DTR sign & #left &
		[ SYNSEM [ LOCAL [ CAT #cat,
				   CONT [ MODCONT.LISZT *diff-list* &
                                                        [ LIST #first,
                                                          LAST #middle ],
                                          MESSAGE #msg ] ],
                           NON-LOCAL #non-local ] ],
    RCONJ-DTR sign & #right &
		[ SYNSEM phr_synsem &
			 [ LOCAL [ CAT #cat,
				   CONT [ MODCONT.LISZT *diff-list* &
                                                        [ LIST #middle,
                                                          LAST #last ],
                                          MESSAGE #msg ],
                                   AGR #agr ],
			   NON-LOCAL #non-local ] ],
    C-CONT [ H-CONS <! !>,
	     H-STORE <! !> ],
    ARGS < #left, #right > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Proto-instance types

subjh_rule_decl := binary_rule_right_to_left & head_subj_phrase & decl.

hcomp_rule := binary_rule_left_to_right & head_comp_phrase.

hoptcomp_rule := rule & head_opt_comp_phrase.

hmark_rule := binary_rule_left_to_right & head_marker_phrase.

extracomp_rule := rule & extracted_comp_phrase.

extrasubj_rule := rule & extracted_subj_phrase & decl & nonroot.

hspec_nc_rule := binary_rule_right_to_left & head_spec_noncompos.

hspec_c_rule := binary_rule_right_to_left & head_spec_compos.

hadj_rule := binary_rule_right_to_left & head_adj_phrase.

adjh_rule := binary_rule_left_to_right & adj_head_phrase.

extradj_rule := rule & extracted_adj_phrase.

fin_non_wh_rel_rule := rule & fin_non_wh_rel_cl.

inf_non_wh_rel_rule := rule & inf_non_wh_rel_cl.

bare_np_rule := rule & bare_np_phrase.

n_n_cmpnd_rule := binary_rule_right_to_left & n_n_cmpnd_phr.

filler_head_rule_non_wh := binary_rule_right_to_left & non_rel_clause &
                           head_filler_phrase_fin & root_phrase & 
  [ SYNSEM.LOCAL.CONT.MESSAGE #mes,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin_or_imp,
					 INV - ],
  				  ROOT + ],
			    CONT.MESSAGE #mes ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE <! !> ].
  
filler_head_rule_wh_root := binary_rule_right_to_left & 
			    head_filler_phrase_fin & wh_interrog_fin & 
                            root_phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.INV +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VALENCE.SUBJ < > ].

filler_head_rule_wh_subj := binary_rule_right_to_left & 
			    head_filler_phrase_fin & wh_interrog_fin & 
                            root_phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.INV -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VALENCE.SUBJ < > ].

filler_head_rule_wh_nr_fin := binary_rule_right_to_left & 
			      head_filler_phrase_fin & wh_interrog_fin &
                              nonroot & 
  [ SYNSEM.LOCAL.CAT.HEAD.INV -,
    HEAD-DTR.LOCAL.CAT.ROOT - ].

filler_head_rule_wh_nr_inf := binary_rule_right_to_left & 
			      head_filler_phrase_inf & wh_interrog & nonroot & 
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
		       VALENCE.SUBJ < synsem >,
		       ROOT - ] ].

filler_head_rule_rel := binary_rule_right_to_left & rel_cl & 
			head_filler_phrase_fin &
  [ SYNSEM.LOCAL.CAT [ MOD.CONT.INDEX #ind,
		       VALENCE.SUBJ < > ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.VFORM fin,
			    CONT.MESSAGE propositional_rel ], 
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ QUE <! !>,
				    REL <! #ind !> ],
    C-CONT.H-CONS <! !> ].


; ERB (05-10-96) This no longer inherits from root_phrase because it also
; serve to make nonroot phrases, such as the braketed phrase in: "On Tuesday
; [plan to meet Kim]".

imperative_rule := rule & head_only & imp.

; The top_coord_rule is for building the top of a (potential iterated)
; coordinate structure and the mid_coord_rule is for building intermediate
; parts of an iterated coordinate structure.  The mid_coord_rule (and the
; head/marker schema) collect the handels and indices of the conjuncts under
; the CONJ feature and passes them (with the lexically specified coordination
; relation) up from the right conjunct.  The top_coord_rule uses handels and
; liszts from the CONJ value to build an n-ary coordination relation.  We
; could skip all this feature passing if we weren't limited by performance
; considerations to binary trees.  That is, we could build coordinate
; structures like:					  
;       						  
;       						  
;      coord_phrase					  
;             +-			          -+	  
;             | conj_rel  		           |	  
;      LISZT  | C-HANDELS  [h1], [h2], ..., [hn]   |	  
;             | C-INDICES  [i1], [i2], ..., [in]   |	  
;             +-    		                  -+	  
;             /             /                \ 	 	  
;            /  	   /    	      \  	  
;           /   	  /     	       \ 	  
;          /    	 /      		\ 	  
;         /     	/       		 \ 	  
;      phrase        phrase    	       	       phrase	  
;      TOP   [h1]    TOP   [h2] ...            TOP   [hn]
;      INDEX [i1]    INDEX [i2]                INDEX [in]
;        |             |                	 |  
;        |             |                         |  
;       Kim          Sandy       ...            Lee 
;       			     
; then we could eliminate the features HANDELS, INDICES, and REL.  These
; feature are just for bookkeeping.  The feature LEFT, on the other hand, is
; essential to the analysis.  The LEFT value is a list of (up to) two
; elements.  The first element is the required CONJ value of the left conjunct
; in a top_coord_phrase and the second element is the CONJ value of the left
; conjunct in a mid_coord_phrase.  For example, a LEFT value of < either, or >
; permits a coordinate structure like "either Kim or Sandy or Chris or Lee".
                                  
top_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM.LOCAL.CONJ cnil,
    C-CONT [ TOP #hand,
	     INDEX #ind,
	     LISZT <! #rel & 
		      [ HANDEL #hand,
			C-ARG #ind,
			C-HANDELS *diff-list* &
			       [ LIST < #lhand . #hands >,
				  LAST #hlast ],
			C-INDICES *diff-list* &
			       [ LIST < #lind . #inds >,
				 LAST #ilast ] ] !> ],
    LCONJ-DTR.SYNSEM.LOCAL local &
		      [ CONJ conj & #left,
			     CONT [ TOP #lhand,
				    INDEX #lind ] ],
    RCONJ-DTR.SYNSEM.LOCAL local &
		      [ CONJ complex-conj &
				  [ CHEAD [ LEFT <#left, ...>,
					    RELTN #rel ], 
				    HANDELS *diff-list* &
					    [ LIST #hands,
					      LAST #hlast ],
				    INDICES *diff-list* &
					    [ LIST #inds,
					      LAST #ilast ] ] ] ].

mid_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM.LOCAL.CONJ complex-conj &
		      [ CHEAD #chead,
			HANDELS *diff-list* &
			        [ LIST < #lhand . #hands >,
				  LAST #hlast ],
			INDICES *diff-list* &
			        [ LIST < #lind . #inds >,
				  LAST #ilast ] ],
    C-CONT [ INDEX.PNG.PN non1sg,
	     LISZT <! !> ],
    LCONJ-DTR.SYNSEM.LOCAL [ CONJ conj & #left,
			     CONT [ TOP #lhand,
				    INDEX #lind ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CONJ complex-conj &
				  [ CHEAD #chead & 
					  [ LEFT < *top*, #left > ],
				    HANDELS *diff-list* &
					    [ LIST #hands,
					      LAST #hlast ],
				    INDICES *diff-list* &
					    [ LIST #inds,
					      LAST #ilast ] ] ] ].
