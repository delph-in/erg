;;; -*- Mode: TDL; Package: DISCO -*-
;;;
;;;  syntax.tdl
;;;
;;;  The grammar rules for English
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;  Last revised: Dan Flickinger, 24-Feb-97
;;;
;;;  $Id$

;;
;;  Phrase structure schemata
;;

; Headed phrases must obey the Head Feature Principle and the Revised Marking
; Principle.  They do not all obey the NLFP with respect to QUE, but it
; appears that all CLAUSE phrases account for QUE on mother and non-head-dtr.
; Hence moved the QUE coreference to NON-CLAUSE.  Headed phrases also identify
; the value of AGR on mother and head daughter, unlike e.g. the coordination
; schemata which identify HEAD but not AGR.

non_headed_phrase :< phrase.

headed_phrase := phrase & 
  [ SYNSEM.LOCAL [ CAT [ HEAD head & #head,
			 AGR #agr ],
		   CONJ #conj,
		   CONT [ KEY #key,
			  ALTKEY #altkey,
			  COMPKEY #ckey,
			  OCOMPKEY #ockey ] ],
    HEAD-DTR.SYNSEM.LOCAL local &
		 [ CAT [ HEAD #head,
			 AGR #agr ],
		   CONJ #conj,
		   CONT [ KEY #key,
			  ALTKEY #altkey,
			  COMPKEY #ckey,
			  OCOMPKEY #ockey ] ] ].

; Head/nexus phrases pass up the REL and QUE values of the head daughter
; (which has amalgamated the REL and QUE values of its arguments a la Ivan's
; relative clause paper) to the mother.  

head_nexus_rel_phrase := headed_phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ].

head_nexus_que_phrase := headed_phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head_nexus_modcont_phrase := headed_phrase &
  [ SYNSEM.LOCAL.MODCONT #modcont,
    C-CONT [ MODCONT #modcont,
	     H-CONS <! !> ] ].

head_nexus_nonrel := head_nexus_que_phrase & head_nexus_modcont_phrase.
head_nexus_nonque := head_nexus_rel_phrase & head_nexus_modcont_phrase.
head_nexus_nonmodcont := head_nexus_rel_phrase & head_nexus_que_phrase.
head_nexus_phrase := head_nexus_rel_phrase & head_nexus_que_phrase &
		     head_nexus_modcont_phrase.

; All phrases are either unary or binary.

unary_phrase := phrase &
  [ SYNSEM.LOCAL [ CONT [ LISZT *diff-list* &
				[ LIST #first,
				  LAST #last ],
			  H-STORE *diff-list* &
				[ LIST #hsfirst,
				  LAST #hslast ],
			  H-CONS *diff-list* &
				[ LIST #scfirst,
				  LAST #sclast ],
			  TOP-H #top ],
		   CTXT.C-INDS #c-inds ],
    C-CONT [ LISZT [ LIST #middle,
		     LAST #last ],
	     H-STORE [ LIST #hsmiddle,
		       LAST #hslast ],
	     H-CONS [ LIST #scmiddle,
		      LAST #sclast ]],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle ],
					  H-STORE *diff-list* &
						[ LIST #hsfirst,
						  LAST #hsmiddle ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle ],
					  TOP-H #top ],
				   CTXT.C-INDS #c-inds ] ] > ].

binary_phrase := sign &
  [ SYNSEM.LOCAL [ CONT [ LISZT *diff-list* &
				[ LIST #first,
				  LAST #last ],
			  H-STORE *diff-list* &
				[ LIST #hsfirst,
				   LAST #hslast ],
			  H-CONS *diff-list* &
				[ LIST #scfirst,
				  LAST #sclast ],
			  TOP-H #top ],
		   CTXT.C-INDS #c-inds ],
    C-CONT [ LISZT *diff-list* & 
		   [ LIST #middle1,
		     LAST #middle2 ],
	     H-STORE *diff-list* &
		   [ LIST #hsmiddle2,
		      LAST #hslast ],
	     H-CONS *diff-list* &
		   [ LIST #scmiddle2,
		     LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #first,
						  LAST #middle1 ],
					  H-STORE *diff-list* &
						[ LIST #hsfirst,
						  LAST #hsmiddle1 ],
					  H-CONS *diff-list* &
						[ LIST #scfirst,
						  LAST #scmiddle1 ],
					  TOP-H #top ],
				   CTXT.C-INDS #c-inds ] ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ LISZT *diff-list* &
						[ LIST #middle2,
						  LAST #last ],
					  H-STORE *diff-list* &
						[ LIST #hsmiddle1,
						   LAST #hsmiddle2 ],
					  H-CONS *diff-list* &
						[ LIST #scmiddle1,
						  LAST #scmiddle2 ],
					  TOP-H #top ],
				   CTXT.C-INDS #c-inds ] ] > ].

binary_rule_right_to_left := rule &
  [ ARGS < [ ] , [ KEY-ARG + ] > ].

head_only := unary_phrase & headed_phrase &
  [ HEAD-DTR #head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head > ].

head_initial := binary_phrase & headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head, #non-head > ].

head_final := binary_phrase & headed_phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #non-head, #head > ].

; C-CONT is the semantic contribution of the phrase itself.  The handle and
; index of the phrase come from the handle and index of C-CONT (which are
; possibly but not necessarily identified with the handle and index of one of
; the daughters).  The liszt of the phrase is the append of the liszt of
; C-CONT and the liszts of the daughters.

head_compositional := headed_phrase &
  [ C-CONT [ HANDEL #hand,
	     INDEX #index,
	     H-CONS <! !>,
	     H-STORE <! !>,
	     MODCONT #modcont ],
    HEAD-DTR.SYNSEM.LOCAL.CONT [ HANDEL #hand,
				 INDEX #index,
				 MODCONT #modcont ] ].

nonhead_compositional := headed_phrase &
  [ C-CONT [ HANDEL #hand,
	     INDEX #index,
	     LISZT <! !>,
	     H-STORE <! !> ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT [ HANDEL #hand,
				     INDEX #index ] ].

;;
;; Root phrases
;;

non_clause := head_nexus_phrase & 
  [ SYNSEM.LOCAL [ CAT.ROOT na,
		   CONT.MESSAGE no_rel ] ].

; ERB (05-10-97) The immediate subtypes of clause are now rel_cl and
; non_rel_clause.  The latter groups together decl, imp, and (wh_)interrog,
; which are similar in that they can't serve as modifiers and have empty REL
; values.  That type used to be (misleadingly) named msg_clause.  The
; remaining constraint (MESSAGE message) has been moved to the type clause
; where it belongs.

; We will need to loosen this to allow nominal clauses (i.e., ACC-ing gerunds)

clause := head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verbal,
			   VALENCE [ SUBJ mod_synsem,
				     COMPS *olist* ],
			   ROOT bool ],
		     CONT.MESSAGE message,
		     CONJ cnil ],
	     NON-LOCAL [ QUE <! !>,
			 REL <! !> ] ],
    HEAD-DTR.SYNSEM.NON-LOCAL [ QUE <! !>,
				REL <! !> ] ].

root_phrase := phrase &
  [ SYNSEM [ LOCAL.CAT.ROOT +,
	     NON-LOCAL [ SLASH <! !>,
			 QUE <! !> ] ] ].

nonroot := phrase &
  [ SYNSEM.LOCAL.CAT.ROOT - ].

; ERB (03-10-96) hcomp_nc is no longer a subtype of this because some of them
; are "clauses" in the sense of having a message other than no_rel (e.g., "Kim
; wants [to leave]").  This is actually in need of revision: we are probably
; going to need to distinguish between to-headed hcomp_ncs which are selected
; by equi predicates or otherwise have PRO subjects and whether-headed
; hcomp_ncs on the one hand, and all other instances on the other with a
; restriction equivalent to SUBJ list(PRO) in order to block "To rain is
; difficult" etc.  I think this should be possible without resorting to
; anything like VFORM whether to identify cases -- see Ivan's interrogatives
; paper.

non_rel_clause := head_nexus_nonque & clause &
  [ SYNSEM.LOCAL.CAT.MOD no-mod ].

decl := non_rel_clause & 
  [ SYNSEM.LOCAL [ CAT.HEAD.INV -,
		   CONT.MESSAGE propositional_rel ],
    C-CONT.LISZT <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE <! !> ].

imp := non_rel_clause & head_valence_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ INV -,
				VFORM imp_vform ],
			 VALENCE [ SUBJ none,
				   COMPS < > ] ],
		   CONT [ MESSAGE imp_rel,
			  TOP-H #hand ] ],
    C-CONT.LISZT <! pron_rel & [ HANDEL #hand,
				 INST #inst &
				      [ PRONTYPE std_pron ] ] !>,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb,
				  ROOT na,
				  VALENCE [ SUBJ unexpressed &
						 [ LOCAL.CONT.INDEX #inst &
							    [ PNG 2per ] ],
					    COMPS *olist* ] ] ] ].

; ERB (05-10-97) There is no longer a subtype of interrog for polar questions,
; as a result of streamlining the hcomp family (subordinate polar questions
; didn't inherit from the old ynq type anyway).  So interrog and its sole
; subtype wh_interrog could be collapsed into each other, but it seems clearer
; to have the separate.  I don't know what the effect of losing the constraint
; on SLASH in matrix polar questions will be.

interrog := non_rel_clause & 
  [ SYNSEM [ LOCAL.CONT.MESSAGE int_rel,
	     NON-LOCAL.SLASH <! !> ],
    C-CONT.LISZT <! !> ].

; Restrict NON-HEAD-DTR to be [HEAD subst] to avoid trying non-partitive
; determiner "whose" as filler in filler-head-wh rules.  Assume all
; wh-interrog phrases are [MOOD ind_or_mod_subj].

wh_interrog := interrog &
  [ SYNSEM.LOCAL [ CAT [ HEAD verbal &
			      [ MOOD ind_or_mod_subj ],
			 MOD no-mod ],
		   CONT.MESSAGE.PARAMS <! #que & handle !> ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD subst,
			  NON-LOCAL.QUE <! #que !> ] ].

; This type has subtypes for subj_head and filler_head.  If we assumed only
; finite subj_head phrases, and explicitly made the relevant filler_head
; phrases be finite (which we do), we wouldn't have to stipulate VFORM here.

wh_interrog_fin := wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin,
		       VALENCE.SUBJ none ] ].

rel_cl := clause & nonroot & head_nexus_nonrel &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin_or_inf,
				  MOOD indicative,
				  INV - ],
			   MOD @nbar() &
				[ CONT [ HANDEL #hand,
					 INDEX #ind ] ] ],
		     CONT [ MESSAGE hypo_rel,
			    MODCONT [ HANDEL #hand,
				      INDEX #ind,
				      LISZT <! !> ] ] ],
	     NON-LOCAL.QUE <! !> ],
    C-CONT.LISZT <! !> ].

; We prevent PP adjunct extraction from feeding thatless_rel rule by requiring
; that the gap be [ MOD no-mod ], to block "the man kim slept walks." To handle
; "I remember the time Kim fell" maybe we can make the words "time" and
; "place" take an S/PP complement, not treat them as thatless_rels.  Also, 
; to block "*Sandy likes the man walks" and "*Sandy likes the man who thinks 
; went home", we require the S/NP to be [ ROOT + ], which excludes subject
; extraction for that daughter.

non_wh_rel_cl := head_only & rel_cl &
  [ SYNSEM [ LOCAL.CAT [ MOD.CONT.INDEX #ind,
			 POSTHEAD +,
			 VALENCE #valence ],
	     NON-LOCAL.SLASH <! !> ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT.VALENCE #valence & [ SUBJ none ],
			      CONT.MESSAGE propositional_rel ],
		      NON-LOCAL.SLASH <! [ CAT [ HEAD noun &
						      [ PRD - ],   
						 VALENCE [ SPR *olist*,
							   COMPS *olist* ],
						 MOD no-mod ],

					   CONT.INDEX #ind ] !> ] ].

fin_non_wh_rel_cl := non_wh_rel_cl &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb &
				     [ VFORM fin ],
				ROOT + ] ].

inf_non_wh_rel_cl := non_wh_rel_cl &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verbal &
				     [ VFORM inf ] ] ].

; The version of the Non-local Feature Principle here assumes that there will
; only be one value on the SLASH list.  To handle multiple gaps, we'll need
; more general set-manipulation functions.  This version also doesn't use a
; distinction between INHERITED and TO-BIND non-local features.  Instead, it
; treats non-local features like valence features.

; ERB (17-10-96) in order to get "Kim knows who to ask" under the current
; hacks (i.e., no PRO), I need a head_filler_phrase that takes something like
; "to ask" (i.e., VFORM in, SUBJ @nomp()) as its head.  So I am making a
; separate parallel type that will only be inherited by the embedded wh
; nonfinite questions.

; N.B. Since all head_filler constructions inherit from type clause, which
; inherits from head_compositional, this type does not (though it could,
; redundantly).

head_filler_phrase := head_final & head_nexus_phrase & 
  [ SYNSEM [ LOCAL [ CAT.VALENCE [ SUBJ #subj,
				   COMPS < >,
				   SPR < > ],
		     CONJ cnil ],
	     NON-LOCAL.SLASH <! !> ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal,
				    VALENCE [ SUBJ #subj,
					      COMPS *olist* ] ] ],
		      NON-LOCAL [ SLASH <! #slash !>,
				  QUE <! !>,
				  REL <! !> ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL #slash & local &
				[ CAT.VALENCE [ COMPS *olist*,
						SPR *olist* ],
				  CTXT.ACTIVATED + ],
			  NON-LOCAL.SLASH <! !> ] ].

head_filler_phrase_fin := head_filler_phrase &
  [ SYNSEM.LOCAL.CAT.VALENCE.SUBJ none,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

head_filler_phrase_inf := head_filler_phrase &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.VFORM inf,
			    CONT.MESSAGE hypo_rel ] ].

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to that of the head daughter, which has already amalgamated
; the SLASH values of its arguments.  See discussion of head_nexus_phrase for
; treatment of REL and QUE.

head_valence_phrase := head_nexus_phrase &
  [ SYNSEM [ LOCAL.CONT.MODCONT #mcont,
	     NON-LOCAL.SLASH #slash ],
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    C-CONT [ MODCONT #mcont,
	     H-CONS <! !> ] ].

; 1-May-96 (DPF) Restricted head to be verb only, to block spurious parses
; where NP modifed by PP was also analyzed as its subject.
; 12-Jun-96 (RPM) Allow verbal gerunds to head head/subj phrases.

; N.B. Since all head_subj_phrase constructions inherit from type clause,
; which inherits from head_compositional, this type does not (though it could,
; redundantly).

head_subj_phrase := head_valence_phrase & head_final &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb & [ VFORM fin ],
			 VALENCE [ SUBJ none,
				   COMPS < >,
				   SPR < > ] ],
		   CONT.MESSAGE prpstn_rel,
		   CONJ cnil ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #synsem,
					  COMPS *olist* ],
				ROOT na ],
    NON-HEAD-DTR.SYNSEM #synsem & synsem &
		 [ LOCAL [ CAT [ HEAD subst,
				 VALENCE [ SUBJ none,
					   COMPS *olist*,
					   SPR *olist* ] ],
			   CONT.MESSAGE no_rel ] ] ].

; A head/comps phrase is a phrase that combines a head with something selected
; for by the COMPS feature.  Head/comps phrases come in two denominations:
; head/comp phrases and head/marker phrases.  A head/comp phrases is like the
; usual VP rule, and its head (and therefore the whole phrase) must be CONJ
; cnil.  A head/comp phrase is unmarked for ROOT, but will inherit a ROOT
; specification from its head daughter.  Head/marker phrases takes the place
; of the P&S94 head/marker rule.  The head must be lexical (i.e., of type
; "word") and CONJ non-cnil. 

head_comp_or_marker_phrase := head_valence_phrase & head_compositional & 
			      head_initial &
  [ SYNSEM.LOCAL [ CAT [ ROOT #root,
			 VALENCE [ SUBJ #subj,
				   COMPS #comps,
				   SPR #spr ],
			 MOD #mod ],
		   CONT.MESSAGE #mes ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ ROOT #root,
				  VALENCE [ SUBJ #subj,
					    COMPS < #synsem . #comps >,
					    SPR #spr ],
				  MOD #mod ],
			    CONT.MESSAGE #mes ],
    NON-HEAD-DTR.SYNSEM #synsem,
    C-CONT.LISZT <! !> ].

; ERB (05-10-97) In order for one single hcomp rule to build things like "how
; about on Friday", the restriction HEAD subst needs to be removed from this
; rule, or else root-marker needs to inherit from subst.  I am opting for the
; former.

head_comp_phrase := head_comp_or_marker_phrase &
  [ SYNSEM.LOCAL [ CAT.POSTHEAD +,
		   CONJ cnil ] ].

head_marker_phrase := head_comp_or_marker_phrase &
  [ SYNSEM [ LOCAL.CONJ strict-conj,
	     NON-LOCAL #nonlocal ],
    HEAD-DTR word,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nonlocal ].

; Skip an optional complement as long as there is still another complement 
; on the list.  The only trick here is to make sure the MODCONT.LISZT of the
; optional complement is the empty list, since the head may have wanted to
; pick up its MODCONT.LISZT as a meaning-bearing PP complement, for example.

head_opt_comp_phrase := head_valence_phrase & head_only & head_compositional &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #subj,
				 COMPS #comps,
				 SPR #spr ],
		       MOD #mod,
		       POSTHEAD + ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VALENCE 
			[ SUBJ #subj,
			  COMPS < unexpressed & [ OPT + ]
				  . #comps & < synsem, ... > >,
			  SPR #spr ],
				MOD #mod ],
    C-CONT.LISZT <! !> ].

extracted_arg_phrase := head_only & head_compositional & 
			head_valence_phrase & 
  [ SYNSEM.LOCAL [ CAT [ HEAD v_or_p &
			      [ MOOD indicative ],
			 VALENCE.SPR #spr,
			 MOD #mod ],
		   CONJ cnil ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ VALENCE.SPR #spr,
				  MOD #mod ],
			    CONJ cnil ],
    C-CONT.LISZT <! !> ].

; To block extraction of subjects of inverted auxiliaries, introduce (hack)
; restriction to accusative case on the extracted complement. This restriction
; is irrelevant (and probably unwanted) if the complement is not an NP, but we
; avoid using an awkward disjunction this way.  We also block extraction of
; complements out of subjunctive-verb-headed phrases.

extracted_comp_phrase := extracted_arg_phrase & non_clause &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #subj,
				 COMPS #comps ],
		       ROOT na ],
    HEAD-DTR.SYNSEM 
	   [ LOCAL.CAT.VALENCE [ SUBJ #subj,
				 COMPS < gap &
					 [ LOCAL.CAT [ HEAD n_or_p & 
							    [ CASE acc ] ] ]
					 . #comps > ] ] ].

; Assume only finite clauses have explicit subjects that can be extracted, and
; restrict these to indicative verbs (not subjunctives). 

extracted_subj_phrase := extracted_arg_phrase &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ none,
				 COMPS < > ],
		       ROOT - ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb &
				     [ VFORM fin ],
				VALENCE [ SUBJ gap,
					  COMPS *olist* ],
				ROOT na ] ].    

; For specifiers of nouns (det and non-det), adjectives and prepositions.
; Also for specifiers of determiners, as in "almost all".  Needs to be modified
; to also allow "exactly which books".

head_spec_phrase := head_valence_phrase & head_final & non_clause &
  [ SYNSEM.LOCAL.CAT [ VALENCE [ SUBJ #subj,
				 COMPS < >,
				 SPR #spr ],
		       MOD #mod,
		       POSTHEAD #ph ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ VALENCE [ SUBJ #subj,
					    COMPS *olist*,
					    SPR < #synsem & synsem . #spr > ],
				  MOD #mod,
				  POSTHEAD #ph,
				  ROOT na ],
			    CONT.H-STORE #hstore,
			    CONJ cnil ],
    NON-HEAD-DTR.SYNSEM #synsem &
		        [ LOCAL [ CAT.ROOT na,
				  CONT.--HH-STORE #hstore ] ] ].

; The noncompositional head_spec is for making non-number phrases:
;  - determiner + noun NPs  "the book"
;  - NP + poss phrases      "the manager 's"
;  - adv + adj APs          "very tall"

head_spec_noncompos := head_spec_phrase & nonhead_compositional &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT [ HANDEL #hand,
				     KEY non_number_rel,
				     MODCONT #mcont ],
    C-CONT [ HANDEL #hand,
	     MODCONT #mcont,
	     LISZT <! !>,
	     H-CONS <! !>,
	     H-STORE <! !> ] ].

; Among others, the compositional head_spec is used for number expressions 
; like "two hundred".

head_spec_compos := head_spec_phrase & head_compositional &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.KEY number_rel,
    C-CONT.LISZT <! !> ].

; The SYNSEM value of the head of a head/modifier phrase is token-identical to
; the MOD value of the adjunct daughter.  Additionally, the adjunct daughter
; must be complement-saturated.  The SLASH value is not set in the basic
; schema, but rather in each of the subtypes: in head_mod_phrase_simple the
; SLASH value is passed up from both daughters, but in the
; extracted_adj_phrase the SLASH value of the mother is effectively the
; adjunct that would have modified the head.

head_mod_phrase := head_nexus_nonmodcont &
  [ SYNSEM.LOCAL [ CAT [ VALENCE [ SUBJ #subj,
				   SPR #spr,
				   COMPS < > ],
			 MOD #mod,
			 POSTHEAD #ph,
			 ROOT #root ],
		   CONT.KEY #hkey ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ VALENCE [ SUBJ #subj,
					      SPR #spr,
					      COMPS *olist* ],
				    MOD #mod,
				    POSTHEAD #ph,
				    ROOT #root ],
			      CONT.KEY #hkey,
			      CONJ cnil ],
		      NON-LOCAL [ QUE <! !>,
				  REL <! !> ] ],
    C-CONT.H-STORE <! !> ].

; Added restriction on adjunct's specifier to prevent unsaturated nouns
; (like 'afternoon') from serving as modifiers before they pick up their
; specifiers.

; head_mod_phrase_simple takes the MESSAGE value from its non-head dtr's 
; MODCONT.MESSAGE.  Most modifiers identify their MODCONT's message with their
; modifiee's message, but tags don't.  (Modifiers cannot simply identify their
; own message with that of their modifiee, since some signs (like "not")
; can be either a modifier or an argument, and hence need a message value 
; independent of that of their modifiee.

;; The following paragraph is perhaps false.  But true for PPs whose CONT.H is
;; not same as MCONT.H, which should be mother's CONT.H.

; head_mod_phrase_simple cannot inherit from nonhead_compositional, since some
; adjuncts (e.g. relative clauses) specify a value for HANDEL and/or INDEX on
; the mother which is distinct from their own (this is the purpose of the
; MODCONT attribute).  Thus it is true that the nonhead daughter determines
; the HANDEL and INDEX of the mother, but they are not necessarily simply the
; nonhead's own.  It is assumed here that every adjunct (sign with non-empty
; MOD value) will also specify in its MODCONT attribute values for HANDEL,
; INDEX, and LISZT.

; Also, head_mod phrases cannot identify the mother's MODCONT with the head
; daughter's, since the modifier may itself be modified, and that can affect
; the handle and index of the resulting phrase.  Cf. Kasper's example of
; "an apparently unsolvable problem", where the handle of the modifier phrase
; will depend on whether there is an adverb modifying the adjective or not.

; SLASH of mother is append of SLASH lists for the two daughters.  In principle
; this allows distinct slash values on the two daughters, without enforcing
; parasitic gaps.  Worry about this later.

; Changed SSM.MC.IND to be HD.MC.IND, along with H.  Needed for "perhaps in
; Berlin"

; Removed identification of hddtr's MESSAGE with mother's - wrong for tags,
; at least.  Should be handled independently by each modifier.

head_mod_phrase_simple := head_mod_phrase &
  [ SYNSEM [ LOCAL [ CONT [ HANDEL #hand,
			    INDEX #ind,
			    MODCONT [ HANDEL #mchand,
				      INDEX #ind,
				      LISZT #hliszt,
				      KEY.HANDEL #mchand ],
			    MESSAGE #mes ] ],
	     NON-LOCAL [ SLASH *diff-list* &
			       [ LIST #first,
				 LAST #last ],
			 QUE <! !>,
			 REL <! !> ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT #localcat,
			      CONT [ MODCONT [ HANDEL #mchand,
					       KEY.HANDEL #hdhand,
					       INDEX #hmcind,
					       LISZT #hliszt ],
				     INDEX #hind,
				     H-STORE #hstore ] ],
		      NON-LOCAL.SLASH *diff-list* &
	                              [ LIST #first,
					LAST #middle ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ MOD local & 
					    [ CAT #localcat,
					      CONT [ HANDEL #hdhand,
						     INDEX #hind,
						     H-STORE #hstore,
						     MODCONT [HANDEL #mchand,
							      INDEX #hmcind]]],
					VALENCE.SPR *olist* ],
				  CONT.MODCONT #mcont &
				               [ HANDEL #hand,
						 KEY.HANDEL #hand,
						 MESSAGE #mes ] ],
			  NON-LOCAL [ SLASH *diff-list* &
					    [ LIST #middle,
					      LAST #last ],
				      QUE <! !>,
				      REL <! !> ] ],
    C-CONT #mcont ].



adj_head_phrase := head_mod_phrase_simple & head_final &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.PRD -,
				    POSTHEAD - ] ].

; ERB (07-11-96) Non-head dtr is QUE <! !> to rule out "*Leaving when do you
; think would bother Sandy?" or "*Your house where did the government forclose
; on?"  Not on higher type because "How long a book did you write?"

head_adj_phrase := head_mod_phrase_simple & head_initial &
  [ SYNSEM.LOCAL.CAT.POSTHEAD +,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ POSTHEAD +,
				      VALENCE.COMPS *olist* ],
			  NON-LOCAL.QUE <! !> ] ].

; For now, restrict adjunct extraction to posthead modifiers of VPs.  This
; will produce two parses for "Tuesday Kim might dance", but the alternatives
; (e.g., blocking modification of all auxiliaries except the copula) seem even
; less attractive.  Also block extraction of adjuncts out of
; subjunctive-verb-headed phrases.

; ERB (12-11-96) This is the exception; the reason I couldn't put the MESSAGE
; stuff on head_mod_phrase.

extracted_adj_phrase := head_mod_phrase & head_only & non_clause &
  [ SYNSEM [ LOCAL.CONT.MESSAGE #mes,
	     NON-LOCAL.SLASH <! local & [ CAT [ POSTHEAD +,
						MOD #local,
						VALENCE [ COMPS *olist*,
							  SPR *olist* ] ],
					  CONT.MODCONT #mcont & 
					      [ MESSAGE #mes ] ] !> ],
    C-CONT #mcont,
    HEAD-DTR.SYNSEM synsem & [ LOCAL #local & local &
				     [ CAT [ HEAD verb &
						  [ MOOD indicative ],
					     VALENCE.SUBJ synsem ] ],
			       NON-LOCAL.SLASH <! !> ] ].
;;
;; Bare plural and mass NPs, distinguished by the INDEX feature [ DIVISIBLE + ]
;;

bare_np_phrase := head_only & non_clause & head_valence_phrase &
  [ SYNSEM.LOCAL [ CAT [ VALENCE [ SUBJ none,
				   COMPS < >,
				   SPR < > ],
			 MOD #mod ],
		   CONT.MESSAGE #mes ],
    HEAD-DTR.SYNSEM.LOCAL 
	 [ CAT [ HEAD noun,
		 VALENCE [ SUBJ none,
			   COMPS *olist*,
			   SPR < unexpressed & 
				 [ OPT -,
				   LOCAL local &
				       [ CONT.KEY #quant &
						  [ RESTR #arg  ] ] ] > ],
		 MOD #mod ],
	   CONJ cnil,
	   CONT [ INDEX #index & [ DIVISIBLE + ],
		  KEY basic_nom_rel,
		  MESSAGE #mes,
		  MODCONT #mcont ] ],
    C-CONT [ HANDEL #hand,
	     INDEX #index,
	     LISZT <! udef_rel & #quant &
		    [ HANDEL #hand,
		      BV #index,
		      RESTR #arg ] !>,
	     H-STORE <! #hand !>,
	     MODCONT #mcont ] ].

;; 
;; Noun-noun compounds
;;

; Make left member be [ COMPS < > ] to avoid spurious ambiguity since we have
; separate lexical entries to handle optional nominal complements.  Also,
; restrict left member to have ordinary quant_rel determiner.

; Would like to make this sign simply inherit from head_final, but want LHS to
; be of type word not of type phrase so this sign inherits instead from
; binary_phrase (which is of type sign, not type phrase), and duplicates the
; relevant information from headed_phrase, head_final, and head_compositional.

n_n_cmpnd_phr := binary_phrase & word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD head & #head,
			   VALENCE #valence,
			   MOD no-mod,
			   ROOT #root ],
		     CONJ cnil,
		     CONT mrs & [ HANDEL #hand,
				  MESSAGE #mes,
				  INDEX #hind,
				  KEY #key ] ],

	     NON-LOCAL [ SLASH #slash,
			 QUE <! !>,
			 REL <! !> ] ],
    HEAD-DTR #head-dtr & word & 
	   [ SYNSEM common_noun_synsem &
		    [ LOCAL [ CAT [ HEAD #head,
				    VALENCE #valence,
				    ROOT #root ],
			      CONT [ HANDEL #hand,
				     MESSAGE #mes,
				     INDEX #hind,
				     KEY #key,
				     MODCONT #mcont ],
			      CONJ cnil ],
		      NON-LOCAL [ SLASH #slash,
				  QUE <! !>,
				  REL <! !> ] ] ],
    NON-HEAD-DTR word & #non-head-dtr & 
	   [ SYNSEM noun_synsem &
		    [ LOCAL [ CAT [ VALENCE.COMPS *olist*,
				    AGR.PNG 3sg ],
			      CONT [ INDEX #modind,
				     KEY reg_nom_rel ],
			      CONJ cnil ],
		      NON-LOCAL [ SLASH <! !>,
				  QUE <! !>,
				  REL <! !> ] ] ],
    C-CONT [ HANDEL #hand,
	     INDEX #hind,
	     LISZT <! unspec_rel & [ HANDEL #hand,
				     HINST #hind,
				     NHINST #modind ] !>,
	     H-CONS <! !>,
	     H-STORE <! !>,
	     MODCONT #mcont ],
    ARGS < #non-head-dtr, #head-dtr > ].

;;
;; Coordinate structures
;;

; Ideally, the CAT value of the mother should be the least upper bound of the
; CAT values of the daughters.  The TDL formalism doesn't make this easy to
; say, so we used to just identify them.  But, that means we can't parse
; ordinary examples like "Kim eats and can walk."  So we've adopted an uneasy
; compromise which specifies each of the attributes in CAT which must be
; unified on mother and both daughters, and leaves the others underspecified.
; Unfortunately, since not all of the features in HEAD unify, we can't unify
; HEAD itself on mother and daughters, so we can't ensure that both daughters
; have the same HEAD type, short of inferring the type from the appropriate
; features (not doable in TDL).  So we unify the HEAD value of the mother with
; that of the right conjunct - not a great solution, but better than none.


coord_phr := binary_phrase & non_headed_phrase & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   VALENCE #val,
			   POSTHEAD #ph,
			   MOD #mod,
			   ROOT #root ],
		     CONT [ HANDEL #hand,
			    INDEX #ind,
			    MODCONT [ HANDEL #hand,
				      INDEX #ind,
				      LISZT <! !> ] ] ],
	     NON-LOCAL #non-local ],
    LCONJ-DTR sign & #left &
		[ SYNSEM [ LOCAL.CAT [ HEAD [ VFORM #vf,
					      POSS #poss,
					      PRD #prd,
					      CASE #case,
					      MOOD #mood ],
				       VALENCE #val,
				       POSTHEAD #ph,
				       MOD #mod,
				       ROOT #root ],
			   NON-LOCAL #non-local ] ],
    RCONJ-DTR sign & #right &
		[ SYNSEM phr_synsem &
			 [ LOCAL.CAT [ HEAD #head &
					    [ VFORM #vf,
					      POSS #poss,
					      PRD #prd,
					      CASE #case,
					      MOOD #mood ],
				       VALENCE #val,
				       POSTHEAD #ph,
				       MOD #mod,
				       ROOT #root ],
			   NON-LOCAL #non-local ] ],
    C-CONT [ H-CONS <! !>,
	     H-STORE <! !> ],
    ARGS < #left, #right > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Proto-instance types

subjh_rule_decl := binary_rule_right_to_left & head_subj_phrase & decl.

hcomp_rule := rule & head_comp_phrase.

hoptcomp_rule := rule & head_opt_comp_phrase.

hmark_rule := rule & head_marker_phrase.

extracomp_rule := rule & extracted_comp_phrase.

extrasubj_rule := rule & extracted_subj_phrase & decl & nonroot.

hspec_nc_rule := binary_rule_right_to_left & head_spec_noncompos.

hspec_c_rule := binary_rule_right_to_left & head_spec_compos.

hadj_rule := binary_rule_right_to_left & head_adj_phrase.

adjh_rule := rule & adj_head_phrase.

extradj_rule := rule & extracted_adj_phrase.

fin_non_wh_rel_rule := rule & fin_non_wh_rel_cl.

inf_non_wh_rel_rule := rule & inf_non_wh_rel_cl.

bare_np_rule := rule & bare_np_phrase.

n_n_cmpnd_rule := binary_rule_right_to_left & n_n_cmpnd_phr.

filler_head_rule_non_wh := binary_rule_right_to_left & non_rel_clause &
                           head_filler_phrase_fin & root_phrase & 
  [ SYNSEM.LOCAL.CONT.MESSAGE #mes,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM fin_or_imp,
					 INV - ],
  				  ROOT + ],
			    CONT.MESSAGE #mes ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE <! !> ].
  
filler_head_rule_wh_root := binary_rule_right_to_left & 
			    head_filler_phrase_fin & wh_interrog_fin & 
                            root_phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.INV +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VALENCE.SUBJ none ].

filler_head_rule_wh_subj := binary_rule_right_to_left & 
			    head_filler_phrase_fin & wh_interrog_fin & 
                            root_phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.INV -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VALENCE.SUBJ none ].

filler_head_rule_wh_nr_fin := binary_rule_right_to_left & 
			      head_filler_phrase_fin & wh_interrog_fin &
                              nonroot & 
  [ SYNSEM.LOCAL.CAT.HEAD.INV -,
    HEAD-DTR.LOCAL.CAT.ROOT - ].

filler_head_rule_wh_nr_inf := binary_rule_right_to_left & 
			      head_filler_phrase_inf & wh_interrog & nonroot & 
  [ SYNSEM.LOCAL.CAT [ HEAD.INV -,
		       VALENCE.SUBJ synsem ],
    HEAD-DTR.LOCAL.CAT.ROOT - ].

filler_head_rule_rel := binary_rule_right_to_left & rel_cl & 
			head_filler_phrase_fin &
  [ SYNSEM.LOCAL.CAT [ MOD.CONT.INDEX #ind,
		       VALENCE.SUBJ none ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.VFORM fin,
			    CONT.MESSAGE propositional_rel ], 
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.REL <! #ind !> ].

; ERB (05-10-96) This no longer inherits from root_phrase because it also
; serve to make nonroot phrases, such as the braketed phrase in: "On Tuesday
; [plan to meet Kim]".

imperative_rule := rule & head_only & imp.

; The top_coord_rule is for building the top of a (potential iterated)
; coordinate structure and the mid_coord_rule is for building intermediate
; parts of an iterated coordinate structure.  The mid_coord_rule (and the
; head/marker schema) collect the handels and indices of the conjuncts under
; the CONJ feature and passes them (with the lexically specified coordination
; relation) up from the right conjunct.  The top_coord_rule uses handels and
; liszts from the CONJ value to build an n-ary coordination relation.  We
; could skip all this feature passing if we weren't limited by performance
; considerations to binary trees.  That is, we could build coordinate
; structures like:					  
;       						  
;       						  
;      coord_phrase					  
;             +-			        -+	  
;             | conj_rel		         |	  
;      LISZT  | HANDELS  [h1], [h2], ..., [hn]   |	  
;             | INDICES  [i1], [i2], ..., [in]   |	  
;             +-    		                -+	  
;             /             /                \ 	 	  
;            /  	   /    	      \  	  
;           /   	  /     	       \ 	  
;          /    	 /      		\ 	  
;         /     	/       		 \ 	  
;      phrase        phrase    	       	       phrase	  
;      HANDEL [h1]   HANDEL [h2] ...           HANDEL [hn]
;      INDEX  [i1]   INDEX  [i2]               INDEX  [in]
;        |             |                	 |  
;        |             |                         |  
;       Kim          Sandy       ...            Lee 
;       			     
; then we could eliminate the features HANDELS, INDICES, and REL.  These
; feature are just for bookkeeping.  The feature LEFT, on the other hand, is
; essential to the analysis.  The LEFT value is a list of (up to) two
; elements.  The first element is the required CONJ value of the left conjunct
; in a top_coord_phrase and the second element is the CONJ value of the left
; conjunct in a mid_coord_phrase.  For example, a LEFT value of < either, or >
; permits a coordinate structure like "either Kim or Sandy or Chris or Lee".
                                  
; For now, stamp [AGR non1sg] on mother, to avoid singular verb agreement with
; conjoined subject NPs.

top_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM.LOCAL [ CAT.AGR.PNG non1sg,
		   CONJ cnil ],
    C-CONT [ HANDEL #hand,
	     INDEX #ind,
	     LISZT <! #rel & 
		      [ HANDEL #hand,
			C-ARG #ind,
			HANDELS *diff-list* &
			       [ LIST < #lhand . #hands >,
				  LAST #hlast ],
			INDICES *diff-list* &
			       [ LIST < #lind . #inds >,
				 LAST #ilast ] ] !> ],
    LCONJ-DTR.SYNSEM.LOCAL local &
		      [ CONJ conj & #left,
			     CONT [ HANDEL #lhand,
				    INDEX #lind ] ],
    RCONJ-DTR.SYNSEM.LOCAL local &
		      [ CONJ complex-conj &
				  [ CHEAD [ LEFT <#left, ...>,
					    RELTN #rel ], 
				    HANDELS *diff-list* &
					    [ LIST #hands,
					      LAST #hlast ],
				    INDICES *diff-list* &
					    [ LIST #inds,
					      LAST #ilast ] ] ] ].

mid_coord_rule := binary_rule_right_to_left & coord_phr &
  [ SYNSEM.LOCAL.CONJ complex-conj &
		      [ CHEAD #chead,
			HANDELS *diff-list* &
			        [ LIST < #lhand . #hands >,
				  LAST #hlast ],
			INDICES *diff-list* &
			        [ LIST < #lind . #inds >,
				  LAST #ilast ] ],
    C-CONT [ INDEX.PNG non1sg,
	     LISZT <! !> ],
    LCONJ-DTR.SYNSEM.LOCAL [ CONJ conj & #left,
			     CONT [ HANDEL #lhand,
				    INDEX #lind ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CONJ complex-conj &
				  [ CHEAD #chead & 
					  [ LEFT < *top*, #left > ],
				    HANDELS *diff-list* &
					    [ LIST #hands,
					      LAST #hlast ],
				    INDICES *diff-list* &
					    [ LIST #inds,
					      LAST #ilast ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Constructions

:begin :instance.

; The instances ROOT and FRAG are needed by the parser to know which phrase 
; types to accept as successful parses of the full input string.  They should 
; be the only instances of phrase that fail to assign some other status 
; (e.g. 'rule or 'lex-entry), so they alone get to be of status 'root-node 
; (assigned on type sign), which is what the parser requires.  This is obscure,
; but seems to work.

; ERB (13-11-96) Nifty trick: all clauses have a MESSAGE value, but only those
; that are actually functioning as the root of the sentence get to put that
; MESSAGE into the semantics.  All root clauses will therefore have an RLISZT
; consisting of their MESSAGE appended to their C-CONT.LISZT.  Similarly, 
; ROOT also introduces an RH-CONS which adds the relevant scope constraint to 
; the H-CONS attribute of the clause itself.

root := phrase & 
  [ SYNSEM [ LOCAL [ CAT [ ROOT +,
			   HEAD.MOOD ind_or_mod_subj,
			   VALENCE [ SUBJ none,
				     SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE message & #mes & 
				    [ HANDEL #mhand,
				      SOA #soa ],
			    LISZT *diff-list* &
				    [ LIST #list,
				      LAST #last ],
			    H-CONS *diff-list* &
				    [ LIST #sclist,
				      LAST #sclast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist ],
			    TOP-H #mhand,
			    RLISZT *diff-list* &
				    [ LIST < #mes . #list >,
				      LAST #last ],
			    RH-CONS *diff-list* &
				    [ LIST 
				    < is-one-of &
				    [ SC-ARG #soa,
				      CANDS < #hand . #hslist > ] . #sclist >,
				     LAST #sclast ] ],
		     CONJ cnil ],
	     NON-LOCAL [ SLASH <! !>,
			 REL <! !>,
			 QUE <! !> ] ],
    C-CONT.HANDEL #hand ].

;; MODCONT's HANDEL cannot be identified with C-CONT's HANDEL, given examples
;; like "perhaps in Berlin", where the MODCONT.HANDEL is that of "in", but
;; the C-CONT.HANDEL must be that of "perhaps" which takes scope over "in".

frag := sign &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ PRD +,
				  INV -,
				  VFORM non_fin],
			   ROOT na,
			   VALENCE [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ RLISZT *diff-list* &
				    [ LIST < message &
					     [ HANDEL #mhand,
					       SOA #soa ]
					     . < abstr_rel &
						 [ HANDEL #hand,
						   EVENT event ] . #first > >,
				      LAST #last ],
			    LISZT [ LIST #middle,
				    LAST #last ],
			    TOP-H #mhand,
			    RH-CONS *diff-list* &
				   [ LIST < is-one-of &
					    [ SC-ARG #soa,
					      CANDS < #hand . #hslist > ] 
					    . #hconslist >,
				     LAST #hconslast ],
			    H-CONS [ LIST #hconslist,
				     LAST #hconslast ],
			    H-STORE *diff-list* &
				    [ LIST #hslist ],
			    MODCONT.LISZT [ LIST #first,
					    LASt #middle ],
			    MESSAGE no_rel ] ],
	     NON-LOCAL [ REL <! !>,
			 SLASH <! !> ] ] ].

frag-msg := sign &
  [ SYNSEM [ LOCAL [ CAT [ ROOT na,
			   VALENCE [ SPR *olist*,
				     COMPS *olist* ] ],
		     CONT [ MESSAGE relation & #msg &
				    [ HANDEL #mhand,
				      RESTR #hand ],
			    TOP-H #mhand,
			    RLISZT *diff-list* &
				    [ LIST < #msg . < abstr_rel &
					              [ HANDEL #hand,
							ARG #arg & individual] 
						      . < abstr_rel &
							  [ HANDEL handle,
							    INST #index,
							    ARG3 #arg ]
							  . #first > > >,
				      LAST #last ],
			    LISZT *diff-list* &
				    [ LIST #middle,
				      LAST #last ],
			    RH-CONS #hclist,
			    H-CONS #hclist,
			    MODCONT [ HANDEL #hand,
				      INDEX #index,
				      LISZT [ LIST #first,
					      LASt #middle ] ] ] ],
	     NON-LOCAL [ REL <! !>,
			 SLASH <! !> ] ],
    C-CONT.HANDEL #mhand ].

subjh_d := subjh_rule_decl &
  [ RULE-NAME 'subjh_d ].

hcomp := hcomp_rule &
  [ RULE-NAME 'hcomp_nc ].

hoptcomp := hoptcomp_rule &
  [ RULE-NAME 'hoptcomp ].

hmark := hmark_rule &
  [ RULE-NAME 'hmark ].

extracomp := extracomp_rule &
  [ RULE-NAME 'extracomp ].

extrasubj := extrasubj_rule &
  [ RULE-NAME 'extrasubj ].

hspec_nc := hspec_nc_rule &
  [ RULE-NAME 'hspec_nc ].

hspec_c := hspec_c_rule &
  [ RULE-NAME 'hspec_c ].

hadj := hadj_rule &
  [ RULE-NAME 'hadj ].

adjh := adjh_rule &
  [ RULE-NAME 'adjh ].

extradj := extradj_rule &
  [ RULE-NAME 'extradj ].

fin_non_wh_rel := fin_non_wh_rel_rule &
  [ RULE-NAME 'fin_non_wh_rel ].

inf_non_wh_rel := inf_non_wh_rel_rule &
  [ RULE-NAME 'inf_non_wh_rel ].

bare_np := bare_np_rule &
  [ RULE-NAME 'bare_np ].

n_n_cmpnd := n_n_cmpnd_rule &
  [ RULE-NAME 'n_n_cmpnd ].

fillhead_non_wh := filler_head_rule_non_wh &
  [ RULE-NAME 'fillhead_non_wh ].

fillhead_wh_r := filler_head_rule_wh_root &
  [ RULE-NAME 'fillhead_wh_r ].

fillhead_wh_subj_r := filler_head_rule_wh_subj &
  [ RULE-NAME 'fillhead_wh_subj_r ].

fillhead_wh_nr_f := filler_head_rule_wh_nr_fin &
  [ RULE-NAME 'fillhead_wh_nr_f ].

fillhead_wh_nr_i := filler_head_rule_wh_nr_inf &
  [ RULE-NAME 'fillhead_wh_nr_i ].

fillhead_rel := filler_head_rule_rel &
  [ RULE-NAME 'fillhead_rel ].

top_coord := top_coord_rule &
       [ RULE-NAME 'top_coord ].

mid_coord := mid_coord_rule &
       [ RULE-NAME 'mid_coord ].

imper := imperative_rule &
       [ RULE-NAME 'imper_r ].

:end :instance.
