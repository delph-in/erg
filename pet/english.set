;;;
;;; This file is part of the English Level 2 Language model.  It should be
;;; kept in the same directory as the accompanying files `english.grm' and 
;;; `l2global.set'.  Do not read any further; if you feel you have to, do not,
;;; under no circumstances, whatsover, change any of the following.
;;;

encoding := iso-8859-1.

include "global".

;;
;; type of a valid parse --- used only for CSLI test suite
;;
;;start-symbols := $root_strict $root_frag.
start-symbols := $root_strict.

;;
;; word-breaking characters in tokenization --- treated as whitespace
;;
;;punctuation-characters := "?!.:;,()<>{}[]+*-`_\"".
punctuation-characters := ",()<>{}[]+*`_\"".

;;
;; suppress results of regular morphology rules if irregular form exists
;;
irregular-forms-only.

lex-entries-can-fail.

;;
;; names of attributes not to pass from daughter to mother in parsing
;;
deleted-daughters := ARGS HEAD-DTR NON-HEAD-DTR LCONJ-DTR RCONJ-DTR DTR1 DTR2
                     DTRA DTRB.

;;
;; names of attributes to filter for packing parser
;;
packing-restrictor := RELS HCONS.

;;
;; path into the MRS semantics
;;
mrs-path := "SYNSEM.LOCAL.CONT".

;;
;; path to LABEL for relation-to-word mapping, absolute and within a relation
;;
label-path := "SYNSEM.LOCAL.KEYS.KEY.LABEL".
label-path-tail := "LABEL".

;;
;; name of type containing quick check structure
;;
qc-structure := $qc_paths.

;;;
;;; generic lexical entries for unknown words: for each unknown word in the
;;; input all generic entries are postulated.  those that require a certain
;;; suffix (`generic-le-suffixes') only fire if the input form has the suffix.
;;; scoring for generic items is based on the default priority (typically 
;;; fairly low) and (optionally) adjusted on the basis of POS information that
;;; may be available for the unknown word.  if the input word has one more more
;;; POS tags associated to it, these are looked up in the `posmapping' table:
;;; this table is a list of triples (tag, score, gle) where `gle' is the name
;;; of one of the generic items in `generic-les'.  for each generic item, the
;;; score is adjusted to the first match of one of the tags associated with the
;;; unknown word in the mapping table.
;;;

generic-lexentry-status-values := generic-lex-entry.

;;;
;;; default initial priority assigned to generic lexical entries; this may be
;;; re-adjusted by later steps in unknown word handling.  generic entries that
;;; end up with a zero priority are dropped before parsing.
;;;
default-gen-le-priority := 0.

;;;
;;; some generic lexical entries require inflectional marking.  this mechanism
;;; is a filter on which generic entries proposed by other means can survive:
;;; generic entries listed here will only be postulated if the required suffix 
;;; can be matched against the input token.
;;;
;;; when using only the generic entries licensed by a POS tag (i.e. a default
;;; priority of 0 and a non-empty `posmapping'), the suffix filter really does
;;; not make a lot of sense anymore.
;;;
generic-le-suffixes := 
#|
  $generic_trans_verb_pres3sg "S" 
  $generic_trans_verb_past "ED" 
  $generic_trans_verb_psp "ED" 
  $generic_trans_verb_prp "ING" 
  $generic_pl_noun "S"
|#
.

posmapping := 
  UpperAndLowerCase 800 $genericname
  UpperAndLowerCaseInitial 200 $genericname
  JJ 100 $generic_adj
  JJR 100 $generic_adj_compar
  JJS 100 $generic_adj_superl
  NN 100 $generic_sg_noun
  NN 100 $generic_mass_noun
  NNS 100 $generic_pl_noun
  NNPS 100 $generic_pl_noun
  NNP 100 $genericname
  FW 100 $generic_mass_noun
  RB 100 $generic_adverb
  VB 100 $generic_trans_verb_bse
  VBD 100 $generic_trans_verb_past
  VBG 100 $generic_trans_verb_prp
  VBN 100 $generic_trans_verb_psp
  VBP 100 $generic_trans_verb_presn3sg
  VBZ 100 $generic_trans_verb_pres3sg
. 

;;;
;;; the setting `pos-completion' enables an additional mechanism:
;;; whenever we receive POS information as part of the input, we check
;;; to see whether the built-in lexical entries suffice to satisfy the
;;; POS annotations: each lexical entry retrieved for an input token
;;; <string, pos_1, pos_2, pos_3> is mapped to an application-specific
;;; POS tag, using the `type-to-pos' map, and checking the type of each
;;; lexical entry for subsumption against the left-hand side of each
;;; `type-to-pos' rule.  some or all POS annotations from the input may
;;; be `satisfied' under this mapping by built-in lexical entries,
;;; e.g. for the example above, there may be lexical entries whose type
;;; maps to `pos_1' and `pos_3'.  unless all POS annotations are
;;; satisfied after all built-in lexical entries have been processed,
;;; the remaining POS categories are processed by the regular
;;; `posmapping' look-up.  however, the resulting generic lexical
;;; entries will have their scores discounted by the value of
;;; `discount-gen-le-priority', so as to distinguish them from
;;; completely unknown words.  note that, as a side effect, an empty
;;; `type-to-pos' map will always result in activating all generic
;;; lexical entries, even for input tokens that were found in the
;;; built-in lexicon.
;;;
;pos-completion.

type-to-pos :=
  basic_noun_word NN
  basic_noun_word NNS
  basic_noun_word NNP
  basic_pronoun_word NN
  basic_pronoun_word NNS
  basic_pronoun_word NNP
;  basic_det_word UpperAndLowerCase
;  basic_prep_word UpperAndLowerCase
.

discount-gen-le-priority := 10.

;;;
;;; the scoring model, either for on-line use in best-first parsing or off-line
;;; ranking of complete parse results after parsing.
;;;
sm := "vm6p.mem".

;;;
;;; based on selectional dependencies between lexical entries, reduce chart
;;; right after lexical look-up: `chart-dependencies' is a list of pairs of
;;; paths into lexical entries.  the type of the node at the end of the first
;;; path in one lexical entry makes that entry depend on the existence of some
;;; other lexical entry that has that same type as the value of the node at the
;;; end of the second path.
;;;
;;; _fix_me_
;;; not entirely sure, but it must (in principle) be possible to saturate a
;;; dependency from lexical and grammar rules.  say, a lexical entry selected
;;; for something nominalized, and that relation was introduced by a lexical
;;; rule, in turn.  unless this is the case already, compute static list of all
;;; relations introduced by rules (which, presumably, requires another setting
;;; to declare how to find constructional semantic contributions; C-CONT) and
;;; consider all such dependencies on lexical entries always saturated.
;;;                                                          (11-oct-02; oe)
unidirectional-chart-dependencies.
chart-dependencies := 
;  "SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.INDEX"
;  "SYNSEM.LOCAL.CONT.INDEX"
  "SYNSEM.LKEYS.--+COMPKEY" "SYNSEM.LOCAL.KEYS.KEY"
  "SYNSEM.LKEYS.--+OCOMPKEY" "SYNSEM.LOCAL.KEYS.KEY"
.
